{"filename": "tests/test_asn1.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport enum\n\timport re\n\timport pytest\n\timport dpapi_ng._asn1 as asn1\n\tclass EnumeratedEnum(enum.IntEnum):\n\t    ENUM0 = 0\n\t    ENUM1 = 1\n", "    ENUM2 = 2\n\t    ENUM3 = 3\n\tASN1_TAG_TESTS = [\n\t    # Simple universal\n\t    (asn1.TagClass.UNIVERSAL, False, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\", b\"\\x04\\x01\\x00\"),\n\t    # Constructed value\n\t    (asn1.TagClass.UNIVERSAL, True, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\\x00\", b\"\\x24\\x02\\x00\\x00\"),\n\t    # Large tag number\n\t    (asn1.TagClass.APPLICATION, True, 1024, b\"\\x00\\x00\", b\"\\x7F\\x88\\x00\\x02\\x00\\x00\"),\n\t    (asn1.TagClass.APPLICATION, True, 1048576, b\"\\x00\\x00\", b\"\\x7F\\xC0\\x80\\x00\\x02\\x00\\x00\"),\n", "    # Long length\n\t    (asn1.TagClass.UNIVERSAL, False, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\" * 127, b\"\\x04\\x7F\" + (b\"\\x00\" * 127)),\n\t    (asn1.TagClass.UNIVERSAL, False, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\" * 128, b\"\\x04\\x81\\x80\" + (b\"\\x00\" * 128)),\n\t    (\n\t        asn1.TagClass.UNIVERSAL,\n\t        False,\n\t        asn1.TypeTagNumber.OCTET_STRING,\n\t        b\"\\x00\" * 1024,\n\t        b\"\\x04\\x82\\x04\\x00\" + (b\"\\x00\" * 1024),\n\t    ),\n", "]\n\t# openssl asn1parse -genstr 'INTEGER:<val>' -out test && hexdump -C test && rm test\n\tINTEGER_TESTS = [  # INTEGER has weird rules that I don't fully understand, use a test of test cases.\n\t    (-748591, b\"\\x02\\x03\\xF4\\x93\\xD1\"),\n\t    (-32769, b\"\\x02\\x03\\xFF\\x7F\\xFF\"),\n\t    (-32768, b\"\\x02\\x02\\x80\\x00\"),\n\t    (-32767, b\"\\x02\\x02\\x80\\x01\"),\n\t    (-257, b\"\\x02\\x02\\xFE\\xFF\"),\n\t    (-256, b\"\\x02\\x02\\xFF\\x00\"),\n\t    (-255, b\"\\x02\\x02\\xFF\\x01\"),\n", "    (-129, b\"\\x02\\x02\\xFF\\x7F\"),\n\t    (-128, b\"\\x02\\x01\\x80\"),\n\t    (-127, b\"\\x02\\x01\\x81\"),\n\t    (-17, b\"\\x02\\x01\\xEF\"),\n\t    (-16, b\"\\x02\\x01\\xF0\"),\n\t    (-10, b\"\\x02\\x01\\xF6\"),\n\t    (-1, b\"\\x02\\x01\\xFF\"),\n\t    (0, b\"\\x02\\x01\\x00\"),\n\t    (1, b\"\\x02\\x01\\x01\"),\n\t    (10, b\"\\x02\\x01\\x0A\"),\n", "    (16, b\"\\x02\\x01\\x10\"),\n\t    (17, b\"\\x02\\x01\\x11\"),\n\t    (127, b\"\\x02\\x01\\x7F\"),\n\t    (128, b\"\\x02\\x02\\x00\\x80\"),\n\t    (129, b\"\\x02\\x02\\x00\\x81\"),\n\t    (255, b\"\\x02\\x02\\x00\\xFF\"),\n\t    (256, b\"\\x02\\x02\\x01\\x00\"),\n\t    (257, b\"\\x02\\x02\\x01\\x01\"),\n\t    (32767, b\"\\x02\\x02\\x7F\\xFF\"),\n\t    (32768, b\"\\x02\\x03\\x00\\x80\\x00\"),\n", "    (32769, b\"\\x02\\x03\\x00\\x80\\x01\"),\n\t    (748591, b\"\\x02\\x03\\x0B\\x6C\\x2F\"),\n\t]\n\t@pytest.mark.parametrize(\"tag_class, constructed, tag_number, data, expected\", ASN1_TAG_TESTS)\n\tdef test_pack_asn1_tlv(\n\t    tag_class: asn1.TagClass,\n\t    constructed: bool,\n\t    tag_number: int,\n\t    data: bytes,\n\t    expected: bytes,\n", ") -> None:\n\t    actual = asn1._pack_asn1(tag_class, constructed, tag_number, data)\n\t    assert actual == expected\n\t@pytest.mark.parametrize(\"tag_class, constructed, tag_number, data, value\", ASN1_TAG_TESTS)\n\tdef test_unpack_asn1_tlv(\n\t    tag_class: asn1.TagClass,\n\t    constructed: bool,\n\t    tag_number: int,\n\t    data: bytes,\n\t    value: bytes,\n", ") -> None:\n\t    actual = asn1._read_asn1_header(value)\n\t    assert actual.tag.tag_class == tag_class\n\t    assert actual.tag.is_constructed == constructed\n\t    assert actual.tag.tag_number == tag_number\n\t    assert actual.tag_length == len(value) - len(data)\n\t    assert actual.length == len(data)\n\t@pytest.mark.parametrize(\"value, expected\", INTEGER_TESTS)\n\tdef test_pack_asn1_integer(value: int, expected: bytes) -> None:\n\t    actual = asn1._pack_asn1_integer(value)\n", "    assert actual == expected\n\t@pytest.mark.parametrize(\"expected, value\", INTEGER_TESTS)\n\tdef test_unpack_asn1_integer(expected: int, value: bytes) -> None:\n\t    actual, consumed = asn1._read_asn1_integer(value)\n\t    assert actual == expected\n\t    assert consumed == len(value)\n\t@pytest.mark.parametrize(\n\t    \"expected, value\",\n\t    [\n\t        (True, b\"\\x01\\x01\\x01\"),\n", "        (True, b\"\\x01\\x01\\x02\"),\n\t        (True, b\"\\x01\\x01\\xFF\"),\n\t        (True, b\"\\x01\\x02\\x00\\x01\"),\n\t        (True, b\"\\x01\\x02\\x01\\x00\"),\n\t        (False, b\"\\x01\\x01\\x00\"),\n\t        (False, b\"\\x01\\x02\\x00\\x00\"),\n\t    ],\n\t)\n\tdef test_unpack_asn1_boolean(expected: bool, value: bytes) -> None:\n\t    actual = asn1.ASN1Reader(value).read_boolean()\n", "    assert actual == expected\n\t@pytest.mark.parametrize(\n\t    \"expected, value\",\n\t    [\n\t        (EnumeratedEnum.ENUM0, b\"\\x0a\\x01\\x00\"),\n\t        (EnumeratedEnum.ENUM1, b\"\\x0a\\x01\\x01\"),\n\t        (EnumeratedEnum.ENUM2, b\"\\x0a\\x01\\x02\"),\n\t    ],\n\t)\n\tdef test_unpack_asn1_enumerator(expected: EnumeratedEnum, value: bytes) -> None:\n", "    actual = asn1.ASN1Reader(value).read_enumerated(EnumeratedEnum)\n\t    assert actual == expected\n\t@pytest.mark.parametrize(\n\t    \"expected, value\",\n\t    [\n\t        (\"19851106210627.3\", b\"\\x18\\x1019851106210627.3\"),\n\t        (\"19851106210627.3Z\", b\"\\x18\\x1119851106210627.3Z\"),\n\t        (\"19851106210627.3-0500\", b\"\\x18\\x1519851106210627.3-0500\"),\n\t    ],\n\t)\n", "def test_unpack_asn1_generalized_time(expected: str, value: bytes) -> None:\n\t    actual = asn1.ASN1Reader(value).read_generalized_time()\n\t    assert actual == expected\n\tdef test_reader_skip_value() -> None:\n\t    with asn1.ASN1Writer() as writer:\n\t        with writer.push_set_of() as w:\n\t            w.write_octet_string(b\"value 1\")\n\t            w.write_octet_string(b\"value 2\")\n\t    reader = asn1.ASN1Reader(writer.get_data())\n\t    set_reader = reader.read_set_of()\n", "    next_header = set_reader.peek_header()\n\t    set_reader.skip_value(next_header)\n\t    assert set_reader.read_octet_string() == b\"value 2\"\n\t    assert set_reader.get_remaining_data() == b\"\"\n\tdef test_reader_get_remaining() -> None:\n\t    with asn1.ASN1Writer() as writer:\n\t        with writer.push_set_of() as w:\n\t            w.write_octet_string(b\"value 1\")\n\t            w.write_octet_string(b\"value 2\")\n\t    reader = asn1.ASN1Reader(writer.get_data())\n", "    set_reader = reader.read_set_of()\n\t    assert reader.get_remaining_data() == b\"\"\n\t    assert set_reader.read_octet_string() == b\"value 1\"\n\t    assert set_reader.get_remaining_data() == b\"\\x04\\x07value 2\"\n\tdef test_writer_push_sequence() -> None:\n\t    expected = b\"\\x30\\x0A\\x02\\x01\\x01\\x04\\x05\\x76\\x61\\x6C\\x75\\x65\"\n\t    with asn1.ASN1Writer() as writer:\n\t        with writer.push_sequence() as w:\n\t            w.write_integer(1)\n\t            w.write_octet_string(b\"value\")\n", "    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_writer_push_sequence_with_tag() -> None:\n\t    expected = b\"\\xA0\\x0A\\x02\\x01\\x01\\x04\\x05\\x76\\x61\\x6C\\x75\\x65\"\n\t    with asn1.ASN1Writer() as writer:\n\t        with writer.push_sequence(asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True)) as w:\n\t            w.write_integer(1)\n\t            w.write_octet_string(b\"value\")\n\t    actual = writer.get_data()\n\t    assert actual == expected\n", "def test_writer_push_set() -> None:\n\t    expected = b\"\\x31\\x06\\x01\\x01\\x00\\x01\\x01\\xFF\"\n\t    with asn1.ASN1Writer() as writer:\n\t        with writer.push_set() as w:\n\t            w.write_boolean(False)\n\t            w.write_boolean(True)\n\t    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_writer_push_set_with_tag() -> None:\n\t    expected = b\"\\xA0\\x06\\x01\\x01\\x00\\x01\\x01\\xFF\"\n", "    with asn1.ASN1Writer() as writer:\n\t        with writer.push_set(asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True)) as w:\n\t            w.write_boolean(False)\n\t            w.write_boolean(True)\n\t    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_writer_write_bool() -> None:\n\t    expected = b\"\\x01\\x01\\xFF\"\n\t    with asn1.ASN1Writer() as writer:\n\t        writer.write_boolean(True)\n", "    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_writer_write_bool_with_tag() -> None:\n\t    expected = b\"\\xA0\\x01\\xFF\"\n\t    with asn1.ASN1Writer() as writer:\n\t        writer.write_boolean(True, asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True))\n\t    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_writer_write_octet_string() -> None:\n\t    expected = b\"\\x04\\x01\\xFF\"\n", "    with asn1.ASN1Writer() as writer:\n\t        writer.write_octet_string(b\"\\xFF\")\n\t    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_writer_write_octet_with_tag() -> None:\n\t    expected = b\"\\xA0\\x01\\xFF\"\n\t    with asn1.ASN1Writer() as writer:\n\t        writer.write_octet_string(b\"\\xFF\", asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True))\n\t    actual = writer.get_data()\n\t    assert actual == expected\n", "def test_writer_write_object_identifier() -> None:\n\t    expected = b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\x07\\x03\"\n\t    with asn1.ASN1Writer() as writer:\n\t        writer.write_object_identifier(\"1.2.840.113549.1.7.3\")\n\t    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_fail_pack_invalid_object_identifier() -> None:\n\t    with pytest.raises(ValueError, match=\"Illegal object identifier\"):\n\t        asn1._encode_object_identifier(\"40.50.1.2.3\")\n\tdef test_writer_write_enumerated() -> None:\n", "    expected = b\"\\x0A\\x01\\x01\"\n\t    with asn1.ASN1Writer() as writer:\n\t        writer.write_enumerated(EnumeratedEnum.ENUM1)\n\t    actual = writer.get_data()\n\t    assert actual == expected\n\tdef test_writer_write_enumerated_with_tag() -> None:\n\t    expected = b\"\\xA0\\x01\\x01\"\n\t    with asn1.ASN1Writer() as writer:\n\t        writer.write_enumerated(EnumeratedEnum.ENUM1, asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True))\n\t    actual = writer.get_data()\n", "    assert actual == expected\n\tdef test_fail_get_data_on_inner_writer() -> None:\n\t    with asn1.ASN1Writer() as writer:\n\t        with writer.push_set_of() as w:\n\t            with pytest.raises(TypeError, match=\"Cannot get_data\\\\(\\\\) on child ASN1 writer\"):\n\t                w.get_data()\n\tdef test_fail_pack_invalid_class() -> None:\n\t    with pytest.raises(ValueError, match=\"tag_class must be between 0 and 3\"):\n\t        asn1._pack_asn1(4, True, 0, b\"\")  # type: ignore[arg-type]  # For test\n\tdef test_fail_read_header_not_enough_for_tag_class() -> None:\n", "    with pytest.raises(asn1.NotEnougData):\n\t        asn1._read_asn1_header(b\"\")\n\tdef test_fail_read_header_not_enough_for_tag_length() -> None:\n\t    with pytest.raises(asn1.NotEnougData):\n\t        asn1._read_asn1_header(b\"\\xFF\")\n\tdef test_fail_read_header_not_enough_for_length() -> None:\n\t    with pytest.raises(asn1.NotEnougData):\n\t        asn1._read_asn1_header(b\"\\x01\")\n\tdef test_fail_read_header_with_indefinite_length() -> None:\n\t    expected = \"Received BER indefinite encoded value which is unsupported by LDAP messages\"\n", "    with pytest.raises(ValueError, match=expected):\n\t        asn1._read_asn1_header(b\"\\x01\\x80\")\n\tdef test_fail_read_header_not_enough_for_length_octets() -> None:\n\t    with pytest.raises(asn1.NotEnougData):\n\t        asn1._read_asn1_header(b\"\\x04\\x81\")\n\tdef test_fail_unpack_not_enough_for_value() -> None:\n\t    with pytest.raises(asn1.NotEnougData):\n\t        asn1._read_asn1_boolean(b\"\\x01\\x01\")\n\tdef test_fail_invalid_tag() -> None:\n\t    expected = \"Expected tag ASN1Tag(tag_class=<TagClass.UNIVERSAL: 0>, tag_number=<TypeTagNumber.BOOLEAN: 1>, is_constructed=False) but got ASN1Tag(tag_class=<TagClass.CONTEXT_SPECIFIC: 2>, tag_number=0, is_constructed=False)\"\n", "    with pytest.raises(ValueError, match=re.escape(expected)):\n\t        asn1._read_asn1_boolean(b\"\\x80\\x01\\x00\")\n\t@pytest.mark.parametrize(\n\t    \"expected, value\",\n\t    [\n\t        (False, b\"\\x01\\x01\\x00\"),\n\t        (True, b\"\\x01\\x01\\xFF\"),\n\t    ],\n\t)\n\tdef test_read_asn1_boolean(expected: bool, value: bytes) -> None:\n", "    actual, consumed = asn1._read_asn1_boolean(value)\n\t    assert actual == expected\n\t    assert consumed == 3\n\t@pytest.mark.parametrize(\n\t    \"expected, value\",\n\t    [\n\t        (False, b\"\\x80\\x01\\x00\"),\n\t        (True, b\"\\x80\\x01\\xFF\"),\n\t    ],\n\t)\n", "def test_read_asn1_boolean_with_tag(expected: bool, value: bytes) -> None:\n\t    actual, consumed = asn1._read_asn1_boolean(\n\t        value,\n\t        tag=asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, False),\n\t    )\n\t    assert actual == expected\n\t    assert consumed == 3\n\t@pytest.mark.parametrize(\n\t    \"expected, value\",\n\t    [\n", "        (0, b\"\\x0A\\x01\\x00\"),\n\t        (1, b\"\\x0A\\x01\\x01\"),\n\t    ],\n\t)\n\tdef test_read_asn1_enumerated(expected: int, value: bytes) -> None:\n\t    actual, consumed = asn1._read_asn1_enumerated(value)\n\t    assert actual == expected\n\t    assert consumed == 3\n\t@pytest.mark.parametrize(\n\t    \"expected, value\",\n", "    [\n\t        (0, b\"\\x80\\x01\\x00\"),\n\t        (1, b\"\\x80\\x01\\x01\"),\n\t    ],\n\t)\n\tdef test_read_asn1_enumerated_with_tag(expected: int, value: bytes) -> None:\n\t    actual, consumed = asn1._read_asn1_enumerated(\n\t        value,\n\t        tag=asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, False),\n\t    )\n", "    assert actual == expected\n\t    assert consumed == 3\n"]}
{"filename": "tests/test_security_descriptor.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport re\n\timport typing as t\n\timport uuid\n\timport pytest\n\tfrom dpapi_ng import _security_descriptor as security_descriptor\n\tfrom .conftest import get_test_data\n\tdef test_sid_to_bytes() -> None:\n", "    expected = (\n\t        b\"\\x01\\x05\\x00\\x00\\x00\\x00\\x00\\x05\"\n\t        b\"\\x15\\x00\\x00\\x00\\x1D\\x93\\x77\\xF7\"\n\t        b\"\\x44\\x35\\x7A\\xCC\\x8C\\xD3\\x7B\\xA9\"\n\t        b\"\\x50\\x04\\x00\\x00\"\n\t    )\n\t    actual = security_descriptor.sid_to_bytes(\"S-1-5-21-4151808797-3430561092-2843464588-1104\")\n\t    assert actual == expected\n\t@pytest.mark.parametrize(\n\t    \"value\",\n", "    [\n\t        \"S-1-5\",\n\t        \"S-1-51\",\n\t        \"S-1-5-\",\n\t        \"Z-1-5-1\",\n\t        \"S-1-5-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16\",\n\t    ],\n\t)\n\tdef test_sid_to_bytes_invalid(value: str) -> None:\n\t    expected = re.escape(f\"Input string '{value}' is not a valid SID string\")\n", "    with pytest.raises(ValueError, match=expected):\n\t        security_descriptor.sid_to_bytes(value)\n\tdef test_sd_to_bytes_no_sacl() -> None:\n\t    expected = (\n\t        b\"\\x01\\x00\\x04\\x80\\x30\\x00\\x00\\x00\"\n\t        b\"\\x3C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x14\\x00\\x00\\x00\\x02\\x00\\x1C\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x14\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n", "        b\"\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x05\"\n\t        b\"\\x12\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n\t    )\n\t    actual = security_descriptor.sd_to_bytes(\n\t        \"S-1-5-18\",\n\t        \"S-1-5-18\",\n\t        dacl=[security_descriptor.ace_to_bytes(\"S-1-5-18\", 1)],\n\t    )\n\t    assert actual == expected\n", "def test_sd_to_bytes_no_dacl() -> None:\n\t    expected = (\n\t        b\"\\x01\\x00\\x10\\x80\\x30\\x00\\x00\\x00\"\n\t        b\"\\x3C\\x00\\x00\\x00\\x14\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x02\\x00\\x1C\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x14\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n\t        b\"\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x05\"\n\t        b\"\\x12\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n", "        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n\t    )\n\t    actual = security_descriptor.sd_to_bytes(\n\t        \"S-1-5-18\",\n\t        \"S-1-5-18\",\n\t        sacl=[security_descriptor.ace_to_bytes(\"S-1-5-18\", 1)],\n\t    )\n\t    assert actual == expected\n"]}
{"filename": "tests/test_crypto.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport typing as t\n\timport uuid\n\timport pytest\n\tfrom cryptography.hazmat.primitives import hashes\n\tfrom dpapi_ng import _crypto as crypto\n\tdef test_cek_decrypt_invalid_algorithm() -> None:\n\t    with pytest.raises(NotImplementedError, match=\"Unknown cek encryption algorithm OID '1.2'\"):\n", "        crypto.cek_decrypt(\"1.2\", None, b\"\", b\"\")\n\tdef test_content_decrypt_aes256_gcm_no_parameters() -> None:\n\t    with pytest.raises(ValueError, match=\"Expecting parameters for AES256 GCM decryption but received none\"):\n\t        crypto.content_decrypt(\"2.16.840.1.101.3.4.1.46\", None, b\"\", b\"\")\n\tdef test_content_decrypt_invalid_algorithm() -> None:\n\t    with pytest.raises(NotImplementedError, match=\"Unknown content encryption algorithm OID '1.2'\"):\n\t        crypto.content_decrypt(\"1.2\", None, b\"\", b\"\")\n\tdef test_cek_encrypt_invalid_algorithm() -> None:\n\t    with pytest.raises(NotImplementedError, match=\"Unknown cek encryption algorithm OID '1.2'\"):\n\t        crypto.cek_encrypt(\"1.2\", None, b\"\", b\"\")\n", "def test_content_encrypt_aes256_gcm_no_parameters() -> None:\n\t    with pytest.raises(ValueError, match=\"Expecting parameters for AES256 GCM encryption but received none\"):\n\t        crypto.content_encrypt(\"2.16.840.1.101.3.4.1.46\", None, b\"\", b\"\")\n\tdef test_content_encrypt_invalid_algorithm() -> None:\n\t    with pytest.raises(NotImplementedError, match=\"Unknown content encryption algorithm OID '1.2'\"):\n\t        crypto.content_encrypt(\"1.2\", None, b\"\", b\"\")\n\tdef test_cek_generate_invalid_algorithm() -> None:\n\t    with pytest.raises(NotImplementedError, match=\"Unknown cek encryption algorithm OID '1.2'\"):\n\t        crypto.cek_generate(\"1.2\")\n"]}
{"filename": "tests/test_epm.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport uuid\n\timport dpapi_ng._rpc as rpc\n\tfrom dpapi_ng import _epm as epm\n\tdef test_ept_map_pack() -> None:\n\t    expected = (\n\t        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n\t        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n\t        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n", "        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n\t        b\"\\x00\\x07\\x02\\x00\\x00\\x87\\x01\\x00\"\n\t        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\"\n\t    )\n\t    service = rpc.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n\t    data_rep = rpc.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)\n\t    msg = epm.EptMap(\n", "        obj=None,\n\t        tower=epm.build_tcpip_tower(service, data_rep, 135, 0),\n\t        entry_handle=None,\n\t        max_towers=4,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ept_map_unpack() -> None:\n\t    data = (\n\t        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n\t        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n", "        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n\t        b\"\\x00\\x07\\x02\\x00\\x00\\x87\\x01\\x00\"\n\t        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\"\n\t    )\n\t    resp = epm.EptMap.unpack(data)\n\t    assert isinstance(resp, epm.EptMap)\n", "    assert resp.obj is None\n\t    assert len(resp.tower) == 5\n\t    assert isinstance(resp.tower[0], epm.UUIDFloor)\n\t    assert resp.tower[0].uuid == uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\")\n\t    assert resp.tower[0].version == 1\n\t    assert resp.tower[0].version_minor == 0\n\t    assert resp.tower[0].protocol == epm.FloorProtocol.UUID_ID\n\t    assert resp.tower[0].lhs\n\t    assert resp.tower[0].rhs\n\t    assert isinstance(resp.tower[1], epm.UUIDFloor)\n", "    assert resp.tower[1].uuid == uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\")\n\t    assert resp.tower[1].version == 2\n\t    assert resp.tower[1].version_minor == 0\n\t    assert resp.tower[1].protocol == epm.FloorProtocol.UUID_ID\n\t    assert resp.tower[1].lhs\n\t    assert resp.tower[1].rhs\n\t    assert isinstance(resp.tower[2], epm.RPCConnectionOrientedFloor)\n\t    assert resp.tower[2].version_minor == 0\n\t    assert resp.tower[2].protocol == epm.FloorProtocol.RPC_CONNECTION_ORIENTED\n\t    assert resp.tower[2].lhs == b\"\"\n", "    assert resp.tower[2].rhs\n\t    assert isinstance(resp.tower[3], epm.TCPFloor)\n\t    assert resp.tower[3].port == 135\n\t    assert resp.tower[3].protocol == epm.FloorProtocol.TCP\n\t    assert resp.tower[3].lhs == b\"\"\n\t    assert resp.tower[3].rhs\n\t    assert isinstance(resp.tower[4], epm.IPFloor)\n\t    assert resp.tower[4].addr == 0\n\t    assert resp.tower[4].protocol == epm.FloorProtocol.IP\n\t    assert resp.tower[4].lhs == b\"\"\n", "    assert resp.tower[4].rhs\n\t    assert resp.entry_handle is None\n\t    assert resp.max_towers == 4\n\tdef test_ept_map_pack_obj_and_entry_handle() -> None:\n\t    expected = (\n\t        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x90\\x80\\x92\\xbc\\x6f\\x40\"\n\t        b\"\\xbf\\xbb\\xb2\\xdc\\xd4\\xa7\\x26\\xee\"\n\t        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x09\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n\t        b\"\\x0b\\x02\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x50\\x62\\x62\\xea\"\n\t        b\"\\x2f\\x27\\xb2\\x4a\\x88\\xa7\\x8a\\xbe\"\n\t        b\"\\x11\\x40\\x37\\x24\\x01\\x00\\x00\\x00\"\n\t    )\n\t    msg = epm.EptMap(\n\t        obj=uuid.UUID(\"80900533-bc92-406f-bfbb-b2dcd4a726ee\"),\n\t        tower=[epm.RPCConnectionOrientedFloor(0)],\n\t        entry_handle=(0, uuid.UUID(\"ea626250-272f-4ab2-88a7-8abe11403724\")),\n", "        max_towers=1,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ept_map_unpack_obj_and_entry_handle() -> None:\n\t    data = (\n\t        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x90\\x80\\x92\\xbc\\x6f\\x40\"\n\t        b\"\\xbf\\xbb\\xb2\\xdc\\xd4\\xa7\\x26\\xee\"\n\t        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x09\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n\t        b\"\\x0b\\x02\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x50\\x62\\x62\\xea\"\n\t        b\"\\x2f\\x27\\xb2\\x4a\\x88\\xa7\\x8a\\xbe\"\n\t        b\"\\x11\\x40\\x37\\x24\\x01\\x00\\x00\\x00\"\n\t    )\n\t    resp = epm.EptMap.unpack(data)\n\t    assert isinstance(resp, epm.EptMap)\n\t    assert resp.obj == uuid.UUID(\"80900533-bc92-406f-bfbb-b2dcd4a726ee\")\n", "    assert len(resp.tower) == 1\n\t    assert isinstance(resp.tower[0], epm.RPCConnectionOrientedFloor)\n\t    assert resp.tower[0].version_minor == 0\n\t    assert resp.tower[0].protocol == epm.FloorProtocol.RPC_CONNECTION_ORIENTED\n\t    assert resp.tower[0].lhs == b\"\"\n\t    assert resp.tower[0].rhs\n\t    assert resp.entry_handle == (0, uuid.UUID(\"ea626250-272f-4ab2-88a7-8abe11403724\"))\n\t    assert resp.max_towers == 1\n\tdef test_ept_map_result_pack() -> None:\n\t    expected = (\n", "        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n\t        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n\t        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n\t        b\"\\x00\\x07\\x02\\x00\\xc2\\x08\\x01\\x00\"\n\t        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n\t        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n\t        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n\t        b\"\\x00\\x07\\x02\\x00\\xc2\\x06\\x01\\x00\"\n", "        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n\t        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n\t        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n", "        b\"\\x00\\x07\\x02\\x00\\xc2\\x03\\x01\\x00\"\n\t        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n\t    )\n\t    service = rpc.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n\t    data_rep = rpc.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)\n\t    msg = epm.EptMapResult(\n\t        entry_handle=None,\n\t        towers=[\n\t            epm.build_tcpip_tower(service, data_rep, 49672, 0),\n", "            epm.build_tcpip_tower(service, data_rep, 49670, 0),\n\t            epm.build_tcpip_tower(service, data_rep, 49667, 0),\n\t        ],\n\t        status=0,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ept_map_result_unpack() -> None:\n\t    data = (\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n", "        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n\t        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n\t        b\"\\x00\\x07\\x02\\x00\\xc2\\x08\\x01\\x00\"\n\t        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n\t        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n\t        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n\t        b\"\\x00\\x07\\x02\\x00\\xc2\\x06\\x01\\x00\"\n\t        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n\t        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n\t        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n\t        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n\t        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n\t        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n\t        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n\t        b\"\\x00\\x07\\x02\\x00\\xc2\\x03\\x01\\x00\"\n", "        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n\t    )\n\t    resp = epm.EptMapResult.unpack(data)\n\t    assert isinstance(resp, epm.EptMapResult)\n\t    assert resp.entry_handle is None\n\t    assert len(resp.towers) == 3\n\t    for idx, port in enumerate([49672, 49670, 49667]):\n\t        floors = resp.towers[idx]\n\t        assert len(floors) == 5\n", "        assert isinstance(floors[0], epm.UUIDFloor)\n\t        assert floors[0].uuid == uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\")\n\t        assert floors[0].version == 1\n\t        assert floors[0].version_minor == 0\n\t        assert floors[0].protocol == epm.FloorProtocol.UUID_ID\n\t        assert floors[0].lhs\n\t        assert floors[0].rhs\n\t        assert isinstance(floors[1], epm.UUIDFloor)\n\t        assert floors[1].uuid == uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\")\n\t        assert floors[1].version == 2\n", "        assert floors[1].version_minor == 0\n\t        assert floors[1].protocol == epm.FloorProtocol.UUID_ID\n\t        assert floors[1].lhs\n\t        assert floors[1].rhs\n\t        assert isinstance(floors[2], epm.RPCConnectionOrientedFloor)\n\t        assert floors[2].version_minor == 0\n\t        assert floors[2].protocol == epm.FloorProtocol.RPC_CONNECTION_ORIENTED\n\t        assert floors[2].lhs == b\"\"\n\t        assert floors[2].rhs\n\t        assert isinstance(floors[3], epm.TCPFloor)\n", "        assert floors[3].port == port\n\t        assert floors[3].protocol == epm.FloorProtocol.TCP\n\t        assert floors[3].lhs == b\"\"\n\t        assert floors[3].rhs\n\t        assert isinstance(floors[4], epm.IPFloor)\n\t        assert floors[4].addr == 0\n\t        assert floors[4].protocol == epm.FloorProtocol.IP\n\t        assert floors[4].lhs == b\"\"\n\t        assert floors[4].rhs\n\tdef test_ept_map_result_pack_handle() -> None:\n", "    expected = (\n\t        b\"\\x00\\x00\\x00\\x00\\xc9\\x53\\xc3\\x6b\"\n\t        b\"\\xe9\\x11\\xaa\\x47\\xb6\\xfd\\x13\\x8d\"\n\t        b\"\\x04\\xda\\x08\\x9d\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n\t    )\n\t    msg = epm.EptMapResult(\n", "        entry_handle=(0, uuid.UUID(\"6bc353c9-11e9-47aa-b6fd-138d04da089d\")),\n\t        towers=[],\n\t        status=0,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ept_map_result_unpack_handle() -> None:\n\t    data = (\n\t        b\"\\x00\\x00\\x00\\x00\\xc9\\x53\\xc3\\x6b\"\n\t        b\"\\xe9\\x11\\xaa\\x47\\xb6\\xfd\\x13\\x8d\"\n", "        b\"\\x04\\xda\\x08\\x9d\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n\t    )\n\t    resp = epm.EptMapResult.unpack(data)\n\t    assert isinstance(resp, epm.EptMapResult)\n\t    assert resp.entry_handle == (0, uuid.UUID(\"6bc353c9-11e9-47aa-b6fd-138d04da089d\"))\n\t    assert len(resp.towers) == 0\n", "def test_unpack_unknown_floor() -> None:\n\t    data = b\"\\x02\\x00\\xFF\\x00\\x01\\x00\\x00\"\n\t    msg = epm.Floor.unpack(data)\n\t    assert msg.protocol == epm.FloorProtocol(0xFF)\n\t    assert msg.lhs == b\"\\x00\"\n\t    assert msg.rhs == b\"\\x00\"\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n"]}
{"filename": "tests/test_gkdi.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport typing as t\n\timport uuid\n\timport pytest\n\tfrom cryptography.hazmat.primitives import hashes\n\tfrom dpapi_ng import _blob as blob\n\tfrom dpapi_ng import _gkdi as gkdi\n\tfrom .conftest import get_test_data\n", "def test_get_key_pack() -> None:\n\t    expected = (\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x20\\x44\\x29\\x73\\x7f\\x91\\x6a\\x41\"\n\t        b\"\\x9e\\xc3\\x86\\x08\\x2a\\xfa\\xfb\\x9e\"\n\t        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n\t        b\"\\x1f\\x00\\x00\\x00\"\n", "    )\n\t    msg = gkdi.GetKey(\n\t        target_sd=b\"\\x01\\x02\\x03\\x04\",\n\t        root_key_id=uuid.UUID(\"73294420-917f-416a-9ec3-86082afafb9e\"),\n\t        l0_key_id=-1,\n\t        l1_key_id=1,\n\t        l2_key_id=31,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n", "def test_get_key_unpack() -> None:\n\t    data = (\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x20\\x44\\x29\\x73\\x7f\\x91\\x6a\\x41\"\n\t        b\"\\x9e\\xc3\\x86\\x08\\x2a\\xfa\\xfb\\x9e\"\n\t        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n\t        b\"\\x1f\\x00\\x00\\x00\"\n", "    )\n\t    resp = gkdi.GetKey.unpack(data)\n\t    assert isinstance(resp, gkdi.GetKey)\n\t    assert resp.target_sd == b\"\\x01\\x02\\x03\\x04\"\n\t    assert resp.root_key_id == uuid.UUID(\"73294420-917f-416a-9ec3-86082afafb9e\")\n\t    assert resp.l0_key_id == -1\n\t    assert resp.l1_key_id == 1\n\t    assert resp.l2_key_id == 31\n\tdef test_get_key_pack_no_root_key() -> None:\n\t    expected = (\n", "        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n\t        b\"\\x1f\\x00\\x00\\x00\"\n\t    )\n\t    msg = gkdi.GetKey(\n\t        target_sd=b\"\\x01\\x02\\x03\\x04\",\n\t        root_key_id=None,\n", "        l0_key_id=-1,\n\t        l1_key_id=1,\n\t        l2_key_id=31,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_get_key_unpack_no_root_key() -> None:\n\t    data = (\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n\t        b\"\\x1f\\x00\\x00\\x00\"\n\t    )\n\t    resp = gkdi.GetKey.unpack(data)\n\t    assert isinstance(resp, gkdi.GetKey)\n\t    assert resp.target_sd == b\"\\x01\\x02\\x03\\x04\"\n\t    assert resp.root_key_id is None\n\t    assert resp.l0_key_id == -1\n", "    assert resp.l1_key_id == 1\n\t    assert resp.l2_key_id == 31\n\tdef test_get_key_unpack_response() -> None:\n\t    expected = gkdi.GroupKeyEnvelope(1, 0, 0, 0, 0, uuid.UUID(int=0), \"\", b\"\", \"\", b\"\", 0, 0, \"\", \"\", b\"\", b\"\")\n\t    b_expected = expected.pack()\n\t    data = (\n\t        len(b_expected).to_bytes(4, byteorder=\"little\")\n\t        + (b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n\t        + b_expected\n\t        + b\"\\x00\\x00\\x00\\x00\"\n", "    )\n\t    actual = gkdi.GetKey.unpack_response(data)\n\t    assert isinstance(actual, gkdi.GroupKeyEnvelope)\n\t    assert actual == expected\n\tdef test_get_key_unpack_response_fail() -> None:\n\t    data = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x57\\x00\\x07\\x80\"\n\t    with pytest.raises(Exception, match=\"GetKey failed 0x80070057\"):\n\t        gkdi.GetKey.unpack_response(data)\n\tdef test_kdf_parameters_pack() -> None:\n\t    expected = (\n", "        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n\t        b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n\t    )\n\t    msg = gkdi.KDFParameters(\"SHA512\")\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_kdf_parameters_unpack() -> None:\n\t    data = (\n", "        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n\t        b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n\t    )\n\t    msg = gkdi.KDFParameters.unpack(data)\n\t    assert msg.hash_name == \"SHA512\"\n\t@pytest.mark.parametrize(\n\t    \"name, expected\",\n\t    [\n", "        (\"SHA1\", hashes.SHA1),\n\t        (\"SHA256\", hashes.SHA256),\n\t        (\"SHA384\", hashes.SHA384),\n\t        (\"SHA512\", hashes.SHA512),\n\t    ],\n\t)\n\tdef test_kdf_parameter_hash_algo(\n\t    name: str,\n\t    expected: t.Type[hashes.HashAlgorithm],\n\t) -> None:\n", "    msg = gkdi.KDFParameters(name)\n\t    assert isinstance(msg.hash_algorithm, expected)\n\tdef test_kdf_parameters_invalid_hash() -> None:\n\t    with pytest.raises(NotImplementedError, match=\"Unsupported hash algorithm MD5\"):\n\t        gkdi.KDFParameters(\"MD5\").hash_algorithm\n\tdef test_kdf_parameters_invalid_magic() -> None:\n\t    data = b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x01\"\n\t    with pytest.raises(ValueError, match=\"Failed to unpack KDFParameters as magic identifier is invalid\"):\n\t        gkdi.KDFParameters.unpack(data)\n\tdef test_ffc_dh_parameters_pack() -> None:\n", "    expected = get_test_data(\"ffc_dh_parameters\")\n\t    msg = gkdi.FFCDHParameters(\n\t        key_length=256,\n\t        field_order=17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183,\n\t        generator=8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ffc_dh_parameters_pack_small_int() -> None:\n\t    expected = b\"\\x0C\\x02\\x00\\x00\\x44\\x48\\x50\\x4D\\x00\\x01\\x00\\x00\" + (b\"\\x00\" * 512)\n", "    msg = gkdi.FFCDHParameters(\n\t        key_length=256,\n\t        field_order=0,\n\t        generator=0,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ffc_dh_parameters_unpack() -> None:\n\t    data = get_test_data(\"ffc_dh_parameters\")\n\t    msg = gkdi.FFCDHParameters.unpack(data)\n", "    assert msg.key_length == 256\n\t    assert (\n\t        msg.field_order\n\t        == 17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183\n\t    )\n\t    assert (\n\t        msg.generator\n\t        == 8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313\n\t    )\n\tdef test_ffc_dh_parameters_invalid_magic() -> None:\n", "    data = b\"\\x00\\x00\\x00\\x00\\x44\\x48\\x50\\x00\"\n\t    with pytest.raises(ValueError, match=\"Failed to unpack FFCDHParameters as magic identifier is invalid\"):\n\t        gkdi.FFCDHParameters.unpack(data)\n\tdef test_ffc_dh_key_pack() -> None:\n\t    expected = get_test_data(\"ffc_dh_key\")\n\t    msg = gkdi.FFCDHKey(\n\t        key_length=256,\n\t        field_order=17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183,\n\t        generator=8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313,\n\t        public_key=5704885921161305204062286453104607919457992927353423073733430775789858496179130688612797173128744245915638749285001365389666398628213879947801588663753164579318944467717026038784117675067248922438216443819787917524104523712708262452393840096093436355765031795113819575193160867788883459494877281145141827767886732955150877747794489653818702322115914625862335942729341854451475767409522001908542192343439374586040439834199899031631166319847176777504380608639274486108367307182844033431414378380156678122207936287391923825983630503829617043562049870198440347689535112361024113575576761204481698354807673154816364980520,\n", "    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ffc_dh_key_pack_small_int() -> None:\n\t    expected = b\"\\x44\\x48\\x50\\x42\\x00\\x01\\x00\\x00\" + (b\"\\x00\" * 768)\n\t    msg = gkdi.FFCDHKey(\n\t        key_length=256,\n\t        field_order=0,\n\t        generator=0,\n\t        public_key=0,\n", "    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ffc_dh_key_unpack() -> None:\n\t    data = get_test_data(\"ffc_dh_key\")\n\t    msg = gkdi.FFCDHKey.unpack(data)\n\t    assert msg.key_length == 256\n\t    assert (\n\t        msg.field_order\n\t        == 17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183\n", "    )\n\t    assert (\n\t        msg.generator\n\t        == 8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313\n\t    )\n\t    assert (\n\t        msg.public_key\n\t        == 5704885921161305204062286453104607919457992927353423073733430775789858496179130688612797173128744245915638749285001365389666398628213879947801588663753164579318944467717026038784117675067248922438216443819787917524104523712708262452393840096093436355765031795113819575193160867788883459494877281145141827767886732955150877747794489653818702322115914625862335942729341854451475767409522001908542192343439374586040439834199899031631166319847176777504380608639274486108367307182844033431414378380156678122207936287391923825983630503829617043562049870198440347689535112361024113575576761204481698354807673154816364980520\n\t    )\n\tdef test_ffc_dh_key_invalid_magic() -> None:\n", "    data = b\"\\x00\\x00\\x00\\x00\"\n\t    with pytest.raises(ValueError, match=\"Failed to unpack FFCDHKey as magic identifier is invalid\"):\n\t        gkdi.FFCDHKey.unpack(data)\n\tdef test_ecdh_key_pack() -> None:\n\t    expected = get_test_data(\"ecdh_key\")\n\t    msg = gkdi.ECDHKey(\n\t        curve_name=\"P256\",\n\t        key_length=32,\n\t        x=25243830316603712129559807215192800963817053918117758232684283953073092162706,\n\t        y=5597696687659389228845157203945777531845995814681629604081047981407116394432,\n", "    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ecdh_key_pack_small_int() -> None:\n\t    expected = b\"\\x45\\x43\\x4B\\x31\\x20\\x00\\x00\\x00\" + (b\"\\x00\" * 64)\n\t    msg = gkdi.ECDHKey(\n\t        curve_name=\"P256\",\n\t        key_length=32,\n\t        x=0,\n\t        y=0,\n", "    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_ecdh_key_pack_invalid_curve() -> None:\n\t    with pytest.raises(ValueError, match=\"Unknown curve 'test', cannot pack\"):\n\t        gkdi.ECDHKey(curve_name=\"test\", key_length=0, x=0, y=0).pack()\n\tdef test_ecdh_key_unpack() -> None:\n\t    data = get_test_data(\"ecdh_key\")\n\t    msg = gkdi.ECDHKey.unpack(data)\n\t    assert msg.key_length == 32\n", "    assert msg.curve_name == \"P256\"\n\t    assert msg.curve_and_hash\n\t    assert msg.x == 25243830316603712129559807215192800963817053918117758232684283953073092162706\n\t    assert msg.y == 5597696687659389228845157203945777531845995814681629604081047981407116394432\n\tdef test_ecdh_key_unpack_invalid_curve() -> None:\n\t    data = b\"\\x00\\x00\\x00\\x00\"\n\t    with pytest.raises(ValueError, match=\"Failed to unpack ECDHKey with unknown curve 0x00000000\"):\n\t        gkdi.ECDHKey.unpack(data)\n\tdef test_group_key_envelope_pack() -> None:\n\t    expected = get_test_data(\"group_key_envelope\")\n", "    l1 = (\n\t        b\"\\x9C\\x8F\\x03\\x85\\xD7\\x46\\x06\\x2A\"\n\t        b\"\\xFB\\x90\\xBA\\x9D\\x02\\x3A\\x3A\\x5C\"\n\t        b\"\\x24\\x2E\\xB5\\x33\\x43\\x41\\xBE\\xFA\"\n\t        b\"\\xDC\\x49\\xE2\\x7A\\x90\\x8F\\xC3\\x39\"\n\t        b\"\\x3B\\xAC\\x40\\x14\\x56\\xA8\\x65\\x61\"\n\t        b\"\\x04\\xC8\\x72\\xD0\\xC9\\x96\\xAA\\x25\"\n\t        b\"\\x9A\\x95\\x4B\\xF5\\xA3\\x8B\\x8D\\x6E\"\n\t        b\"\\xC7\\xCD\\xBA\\xC1\\x35\\x9E\\x5A\\x09\"\n\t    )\n", "    l2 = (\n\t        b\"\\x1B\\xAC\\x68\\xA1\\xA7\\xC8\\xB9\\xAC\"\n\t        b\"\\x94\\x4C\\x8E\\xB1\\xEA\\x39\\x6C\\xC3\"\n\t        b\"\\x66\\x68\\x5E\\x17\\xA4\\x11\\x0A\\x1F\"\n\t        b\"\\xB5\\x5E\\x7C\\x44\\x11\\xA6\\xFA\\xA5\"\n\t        b\"\\x8F\\x8E\\x5B\\xE1\\x25\\x24\\xFA\\xBB\"\n\t        b\"\\xC3\\x44\\xC5\\x9B\\xEA\\xF9\\xB3\\xEC\"\n\t        b\"\\xE2\\x18\\xEA\\x8E\\x4F\\x81\\x1B\\x6C\"\n\t        b\"\\xAF\\xEA\\x4B\\x77\\xE7\\xEF\\x0A\\xED\"\n\t    )\n", "    msg = gkdi.GroupKeyEnvelope(\n\t        version=1,\n\t        flags=2,\n\t        l0=361,\n\t        l1=17,\n\t        l2=8,\n\t        root_key_identifier=uuid.UUID(\"d778c271-9025-9a82-f6dc-b8960b8ad8c5\"),\n\t        kdf_algorithm=\"SP800_108_CTR_HMAC\",\n\t        kdf_parameters=(\n\t            b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n", "            b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t            b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n\t            b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n\t        ),\n\t        secret_algorithm=\"DH\",\n\t        secret_parameters=get_test_data(\"ffc_dh_parameters\"),\n\t        private_key_length=512,\n\t        public_key_length=2048,\n\t        domain_name=\"domain.test\",\n\t        forest_name=\"domain.test\",\n", "        l1_key=l1,\n\t        l2_key=l2,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_group_key_envelope_unpack() -> None:\n\t    data = get_test_data(\"group_key_envelope\")\n\t    expected_l1 = (\n\t        b\"\\x9C\\x8F\\x03\\x85\\xD7\\x46\\x06\\x2A\"\n\t        b\"\\xFB\\x90\\xBA\\x9D\\x02\\x3A\\x3A\\x5C\"\n", "        b\"\\x24\\x2E\\xB5\\x33\\x43\\x41\\xBE\\xFA\"\n\t        b\"\\xDC\\x49\\xE2\\x7A\\x90\\x8F\\xC3\\x39\"\n\t        b\"\\x3B\\xAC\\x40\\x14\\x56\\xA8\\x65\\x61\"\n\t        b\"\\x04\\xC8\\x72\\xD0\\xC9\\x96\\xAA\\x25\"\n\t        b\"\\x9A\\x95\\x4B\\xF5\\xA3\\x8B\\x8D\\x6E\"\n\t        b\"\\xC7\\xCD\\xBA\\xC1\\x35\\x9E\\x5A\\x09\"\n\t    )\n\t    expected_l2 = (\n\t        b\"\\x1B\\xAC\\x68\\xA1\\xA7\\xC8\\xB9\\xAC\"\n\t        b\"\\x94\\x4C\\x8E\\xB1\\xEA\\x39\\x6C\\xC3\"\n", "        b\"\\x66\\x68\\x5E\\x17\\xA4\\x11\\x0A\\x1F\"\n\t        b\"\\xB5\\x5E\\x7C\\x44\\x11\\xA6\\xFA\\xA5\"\n\t        b\"\\x8F\\x8E\\x5B\\xE1\\x25\\x24\\xFA\\xBB\"\n\t        b\"\\xC3\\x44\\xC5\\x9B\\xEA\\xF9\\xB3\\xEC\"\n\t        b\"\\xE2\\x18\\xEA\\x8E\\x4F\\x81\\x1B\\x6C\"\n\t        b\"\\xAF\\xEA\\x4B\\x77\\xE7\\xEF\\x0A\\xED\"\n\t    )\n\t    msg = gkdi.GroupKeyEnvelope.unpack(data)\n\t    assert msg.version == 1\n\t    assert msg.flags == 2\n", "    assert msg.is_public_key is False\n\t    assert msg.l0 == 361\n\t    assert msg.l1 == 17\n\t    assert msg.l2 == 8\n\t    assert msg.root_key_identifier == uuid.UUID(\"d778c271-9025-9a82-f6dc-b8960b8ad8c5\")\n\t    assert msg.kdf_algorithm == \"SP800_108_CTR_HMAC\"\n\t    assert msg.kdf_parameters == (\n\t        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n", "        b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n\t    )\n\t    assert msg.secret_algorithm == \"DH\"\n\t    assert msg.secret_parameters == get_test_data(\"ffc_dh_parameters\")\n\t    assert msg.private_key_length == 512\n\t    assert msg.public_key_length == 2048\n\t    assert msg.domain_name == \"domain.test\"\n\t    assert msg.forest_name == \"domain.test\"\n\t    assert msg.l1_key == expected_l1\n\t    assert msg.l2_key == expected_l2\n", "def test_group_key_envelope_invalid_magic() -> None:\n\t    data = b\"\\x00\\x00\\x00\\x00\"\n\t    with pytest.raises(ValueError, match=\"Failed to unpack GroupKeyEnvelope as magic identifier is invalid\"):\n\t        gkdi.GroupKeyEnvelope.unpack(data)\n\tdef test_group_key_envelope_get_kek_is_public() -> None:\n\t    envelope = gkdi.GroupKeyEnvelope(\n\t        version=1,\n\t        flags=1,\n\t        l0=0,\n\t        l1=0,\n", "        l2=0,\n\t        root_key_identifier=uuid.UUID(int=0),\n\t        kdf_algorithm=\"\",\n\t        kdf_parameters=b\"\",\n\t        secret_algorithm=\"\",\n\t        secret_parameters=b\"\",\n\t        private_key_length=0,\n\t        public_key_length=0,\n\t        domain_name=\"\",\n\t        forest_name=\"\",\n", "        l1_key=b\"\",\n\t        l2_key=b\"\",\n\t    )\n\t    with pytest.raises(ValueError, match=\"Current user is not authorized to retrieve the KEK information\"):\n\t        envelope.get_kek(blob.KeyIdentifier(1, 1, 0, 0, 0, uuid.UUID(int=0), b\"\", \"\", \"\"))\n\tdef test_group_key_envelope_get_kek_l0_mismatch() -> None:\n\t    envelope = gkdi.GroupKeyEnvelope(\n\t        version=1,\n\t        flags=0,\n\t        l0=1,\n", "        l1=0,\n\t        l2=0,\n\t        root_key_identifier=uuid.UUID(int=0),\n\t        kdf_algorithm=\"test\",\n\t        kdf_parameters=b\"\",\n\t        secret_algorithm=\"\",\n\t        secret_parameters=b\"\",\n\t        private_key_length=0,\n\t        public_key_length=0,\n\t        domain_name=\"\",\n", "        forest_name=\"\",\n\t        l1_key=b\"\",\n\t        l2_key=b\"\",\n\t    )\n\t    with pytest.raises(ValueError, match=\"L0 index 1 does not match the requested L0 index 0\"):\n\t        envelope.get_kek(blob.KeyIdentifier(1, 1, 0, 0, 0, uuid.UUID(int=0), b\"\", \"\", \"\"))\n\tdef test_group_key_envelope_get_kek_invalid_kdf() -> None:\n\t    envelope = gkdi.GroupKeyEnvelope(\n\t        version=1,\n\t        flags=0,\n", "        l0=0,\n\t        l1=0,\n\t        l2=0,\n\t        root_key_identifier=uuid.UUID(int=0),\n\t        kdf_algorithm=\"test\",\n\t        kdf_parameters=b\"\",\n\t        secret_algorithm=\"\",\n\t        secret_parameters=b\"\",\n\t        private_key_length=0,\n\t        public_key_length=0,\n", "        domain_name=\"\",\n\t        forest_name=\"\",\n\t        l1_key=b\"\",\n\t        l2_key=b\"\",\n\t    )\n\t    with pytest.raises(NotImplementedError, match=\"Unknown KDF algorithm 'test'\"):\n\t        envelope.get_kek(blob.KeyIdentifier(1, 1, 0, 0, 0, uuid.UUID(int=0), b\"\", \"\", \"\"))\n\t# See tests/integration/files/generate_seed_keys.py on how to generate the\n\t# known values from the L1 seed key.\n\t@pytest.mark.parametrize(\n", "    \"l1, l2, l1_key, l2_key\",\n\t    [\n\t        (\n\t            0,\n\t            0,\n\t            b\"\",\n\t            (\n\t                b\"\\x1B\\x0F\\x11\\x3F\\x01\\x93\\x10\\xE5\"\n\t                b\"\\xA8\\x4E\\xA3\\x0B\\x3A\\xCB\\xC6\\x58\"\n\t                b\"\\x21\\x79\\xC9\\xB0\\x49\\x2B\\xA8\\x4A\"\n", "                b\"\\xF6\\xA2\\x5D\\xE3\\xCA\\x42\\x82\\xC9\"\n\t                b\"\\x1B\\x50\\x3B\\x7E\\x01\\x15\\x1E\\x29\"\n\t                b\"\\x27\\x72\\x93\\x07\\xDA\\x8E\\x60\\xC6\"\n\t                b\"\\x4E\\x3D\\x3A\\xFB\\x66\\x80\\x06\\xE2\"\n\t                b\"\\x2F\\x2B\\xFF\\x7F\\x7C\\x14\\xAA\\x18\"\n\t            ),\n\t        ),\n\t        (\n\t            0,\n\t            31,\n", "            (\n\t                b\"\\xC7\\xA2\\x2B\\x5B\\x09\\x70\\x53\\x80\"\n\t                b\"\\xB4\\x5C\\xDD\\x29\\x33\\xE0\\xFA\\xA6\"\n\t                b\"\\x8E\\xA2\\xC9\\x8A\\x3E\\x50\\x47\\x27\"\n\t                b\"\\x5D\\xD3\\xB2\\xE2\\xDC\\xCF\\x55\\x86\"\n\t                b\"\\xD7\\x2A\\x58\\xA0\\x76\\x2D\\x2E\\x5A\"\n\t                b\"\\x53\\x42\\x99\\xF5\\x40\\x5E\\x31\\xEE\"\n\t                b\"\\x51\\x4B\\xD4\\xE1\\x3A\\xA2\\xF5\\x4A\"\n\t                b\"\\xF0\\xC3\\x0C\\xDB\\xC9\\xCC\\x03\\x01\"\n\t            ),\n", "            b\"\",\n\t        ),\n\t        (\n\t            31,\n\t            31,\n\t            (\n\t                b\"\\x60\\xE0\\xA8\\x1F\\x93\\x16\\x4F\\x5D\"\n\t                b\"\\xC3\\xAB\\xE9\\x81\\xE1\\xEE\\x54\\xC1\"\n\t                b\"\\xA6\\xB9\\xB0\\xED\\xB6\\xFF\\x82\\x74\"\n\t                b\"\\x64\\x27\\x58\\xD2\\x9B\\xBC\\x66\\x55\"\n", "                b\"\\x9D\\x11\\xF1\\x87\\x1A\\x82\\xA6\\xE3\"\n\t                b\"\\xF2\\x32\\xC4\\x24\\x90\\xD7\\xC4\\x1C\"\n\t                b\"\\x6A\\xD2\\xB8\\xB1\\x89\\xFE\\x27\\x52\"\n\t                b\"\\xA8\\x8C\\xEC\\x2E\\xA4\\xB2\\x02\\x1C\"\n\t            ),\n\t            b\"\",\n\t        ),\n\t        (\n\t            2,\n\t            6,\n", "            (\n\t                b\"\\x58\\xC8\\xE7\\xF9\\xC2\\xB7\\x26\\x0B\"\n\t                b\"\\xE8\\x8F\\xB1\\x88\\xEB\\x62\\x1A\\x60\"\n\t                b\"\\x91\\x97\\x74\\xB9\\x30\\x6F\\xCF\\xE4\"\n\t                b\"\\x5B\\x6C\\x17\\xD0\\x49\\x4A\\x43\\xD5\"\n\t                b\"\\x55\\xA2\\x74\\xE6\\xDD\\x79\\x5C\\xF0\"\n\t                b\"\\xA6\\x81\\x92\\x63\\xDD\\x3E\\xC9\\x12\"\n\t                b\"\\x5E\\xB9\\xC5\\xB6\\x2F\\xBE\\x04\\x1A\"\n\t                b\"\\x51\\x33\\xC1\\xA2\\xCB\\x0A\\x58\\x92\"\n\t            ),\n", "            b\"\",\n\t        ),\n\t    ],\n\t    ids=[\n\t        \"ExactValue\",\n\t        \"FromL1Seed\",\n\t        \"FromRootSeed\",\n\t        \"L1AndL2Different\",\n\t    ],\n\t)\n", "def test_compute_l2_key(\n\t    l1: int,\n\t    l2: int,\n\t    l1_key: bytes,\n\t    l2_key: bytes,\n\t) -> None:\n\t    expected = (\n\t        b\"\\x1B\\x0F\\x11\\x3F\\x01\\x93\\x10\\xE5\"\n\t        b\"\\xA8\\x4E\\xA3\\x0B\\x3A\\xCB\\xC6\\x58\"\n\t        b\"\\x21\\x79\\xC9\\xB0\\x49\\x2B\\xA8\\x4A\"\n", "        b\"\\xF6\\xA2\\x5D\\xE3\\xCA\\x42\\x82\\xC9\"\n\t        b\"\\x1B\\x50\\x3B\\x7E\\x01\\x15\\x1E\\x29\"\n\t        b\"\\x27\\x72\\x93\\x07\\xDA\\x8E\\x60\\xC6\"\n\t        b\"\\x4E\\x3D\\x3A\\xFB\\x66\\x80\\x06\\xE2\"\n\t        b\"\\x2F\\x2B\\xFF\\x7F\\x7C\\x14\\xAA\\x18\"\n\t    )\n\t    l0 = 361\n\t    key_id = uuid.UUID(\"2e1b932a-4e21-ced3-0b7b-8815aff8335d\")\n\t    actual = gkdi.compute_l2_key(\n\t        hashes.SHA512(),\n", "        0,\n\t        0,\n\t        gkdi.GroupKeyEnvelope(\n\t            version=1,\n\t            flags=0,\n\t            l0=l0,\n\t            l1=l1,\n\t            l2=l2,\n\t            root_key_identifier=key_id,\n\t            kdf_algorithm=\"\",\n", "            kdf_parameters=b\"\",\n\t            secret_algorithm=\"\",\n\t            secret_parameters=b\"\",\n\t            private_key_length=0,\n\t            public_key_length=0,\n\t            domain_name=\"\",\n\t            forest_name=\"\",\n\t            l1_key=l1_key,\n\t            l2_key=l2_key,\n\t        ),\n", "    )\n\t    assert actual == expected\n\tdef test_compute_kek_invalid_algorithm() -> None:\n\t    with pytest.raises(NotImplementedError, match=\"Unknown secret agreement algorithm 'test'\"):\n\t        gkdi.compute_kek_from_public_key(hashes.SHA256(), b\"\", \"test\", None, b\"\", 0)\n"]}
{"filename": "tests/test_client.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport base64\n\timport json\n\timport os\n\timport typing as t\n\timport uuid\n\timport pytest\n\tfrom cryptography.hazmat.primitives.asymmetric import ec\n", "import dpapi_ng\n\timport dpapi_ng._client as client\n\timport dpapi_ng._gkdi as gkdi\n\tfrom .conftest import get_test_data\n\t# These scenarios were created with tests/integration/files/New-KdsRootKey.ps1\n\t# and tests/integration/files/ConvertTo-DpapiNgBlob.ps1\n\tdef _load_root_key(scenario: str) -> tuple[bytes, dpapi_ng.KeyCache]:\n\t    data = json.loads(get_test_data(f\"{scenario}.json\"))\n\t    cache = dpapi_ng.KeyCache()\n\t    cache.load_key(\n", "        key=base64.b16decode(data[\"RootKeyData\"]),\n\t        root_key_id=uuid.UUID(data[\"RootKeyId\"]),\n\t        version=data[\"Version\"],\n\t        kdf_algorithm=data[\"KdfAlgorithm\"],\n\t        kdf_parameters=base64.b16decode(data[\"KdfParameters\"]),\n\t        secret_algorithm=data[\"SecretAgreementAlgorithm\"],\n\t        secret_parameters=base64.b16decode(data[\"SecretAgreementParameters\"]),\n\t        private_key_length=data[\"PrivateKeyLength\"],\n\t        public_key_length=data[\"PublicKeyLength\"],\n\t    )\n", "    return base64.b16decode(data[\"Data\"]), cache\n\t@pytest.mark.parametrize(\n\t    \"scenario\",\n\t    [\n\t        \"kdf_sha1_nonce\",\n\t        \"kdf_sha256_nonce\",\n\t        \"kdf_sha384_nonce\",\n\t        \"kdf_sha512_nonce\",\n\t    ],\n\t)\n", "def test_protect_secret(scenario: str) -> None:\n\t    test_data = b\"schorschii\"\n\t    test_protection_descriptor = \"S-1-5-21-2185496602-3367037166-1388177638-1103\"\n\t    key_cache = _load_root_key(scenario)[1]\n\t    test_root_key_identifier = list(key_cache._root_keys.keys())[0]\n\t    encrypted = dpapi_ng.ncrypt_protect_secret(\n\t        test_data,\n\t        test_protection_descriptor,\n\t        root_key_identifier=test_root_key_identifier,\n\t        cache=key_cache,\n", "    )\n\t    decrypted = dpapi_ng.ncrypt_unprotect_secret(encrypted, cache=key_cache)\n\t    assert test_data == decrypted\n\t@pytest.mark.asyncio\n\t@pytest.mark.parametrize(\n\t    \"scenario\",\n\t    [\n\t        \"kdf_sha1_nonce\",\n\t        \"kdf_sha256_nonce\",\n\t        \"kdf_sha384_nonce\",\n", "        \"kdf_sha512_nonce\",\n\t    ],\n\t)\n\tasync def test_async_protect_secret(scenario: str) -> None:\n\t    test_data = b\"schorschii\"\n\t    test_protection_descriptor = \"S-1-5-21-2185496602-3367037166-1388177638-1103\"\n\t    key_cache = _load_root_key(scenario)[1]\n\t    test_root_key_identifier = list(key_cache._root_keys.keys())[0]\n\t    encrypted = await dpapi_ng.async_ncrypt_protect_secret(\n\t        test_data,\n", "        test_protection_descriptor,\n\t        root_key_identifier=test_root_key_identifier,\n\t        cache=key_cache,\n\t    )\n\t    decrypted = await dpapi_ng.async_ncrypt_unprotect_secret(encrypted, cache=key_cache)\n\t    assert test_data == decrypted\n\t@pytest.mark.parametrize(\n\t    \"kdf_algo, secret_algo\",\n\t    [\n\t        (\"SHA1\", \"DH\"),\n", "        (\"SHA1\", \"ECDH_P256\"),\n\t        (\"SHA1\", \"ECDH_P384\"),\n\t        (\"SHA256\", \"DH\"),\n\t        (\"SHA256\", \"ECDH_P256\"),\n\t        (\"SHA256\", \"ECDH_P384\"),\n\t        (\"SHA384\", \"DH\"),\n\t        (\"SHA384\", \"ECDH_P256\"),\n\t        (\"SHA384\", \"ECDH_P384\"),\n\t        (\"SHA512\", \"DH\"),\n\t        (\"SHA512\", \"ECDH_P256\"),\n", "        (\"SHA512\", \"ECDH_P384\"),\n\t    ],\n\t)\n\tdef test_protect_secret_public_key(\n\t    kdf_algo: str,\n\t    secret_algo: str,\n\t    monkeypatch: pytest.MonkeyPatch,\n\t) -> None:\n\t    test_data = b\"schorschii\"\n\t    test_protection_descriptor = \"S-1-5-21-2185496602-3367037166-1388177638-1103\"\n", "    private_key_length, public_key_length = {\n\t        \"DH\": (512, 2048),\n\t        \"ECDH_P256\": (256, 256),\n\t        \"ECDH_P384\": (384, 384),\n\t        \"ECDH_P521\": (521, 521),\n\t    }[secret_algo]\n\t    root_key_id = uuid.uuid4()\n\t    key_cache = dpapi_ng.KeyCache()\n\t    key_cache.load_key(\n\t        os.urandom(64),\n", "        root_key_id=root_key_id,\n\t        version=1,\n\t        kdf_parameters=gkdi.KDFParameters(kdf_algo).pack(),\n\t        secret_algorithm=secret_algo,\n\t        private_key_length=private_key_length,\n\t        public_key_length=public_key_length,\n\t    )\n\t    original_get_gke = client._get_protection_gke_from_cache\n\t    def get_protection_gke(\n\t        root_key_identifier: t.Optional[uuid.UUID],\n", "        target_sd: bytes,\n\t        cache: client.KeyCache,\n\t    ) -> gkdi.GroupKeyEnvelope:\n\t        gke = original_get_gke(root_key_identifier, target_sd, cache)\n\t        assert gke\n\t        private_key = gkdi.kdf(\n\t            gkdi.KDFParameters.unpack(gke.kdf_parameters).hash_algorithm,\n\t            gke.l2_key,\n\t            gkdi.KDS_SERVICE_LABEL,\n\t            (gke.secret_algorithm + \"\\0\").encode(\"utf-16-le\"),\n", "            (gke.private_key_length // 8),\n\t        )\n\t        if gke.secret_algorithm == \"DH\":\n\t            secret_params = gkdi.FFCDHParameters.unpack(gke.secret_parameters)\n\t            public_key = pow(\n\t                secret_params.generator,\n\t                int.from_bytes(private_key, byteorder=\"big\"),\n\t                secret_params.field_order,\n\t            )\n\t            pub_key = gkdi.FFCDHKey(\n", "                key_length=secret_params.key_length,\n\t                field_order=secret_params.field_order,\n\t                generator=secret_params.generator,\n\t                public_key=public_key,\n\t            ).pack()\n\t        else:\n\t            curve, curve_name = {\n\t                \"ECDH_P256\": (ec.SECP256R1(), \"P256\"),\n\t                \"ECDH_P384\": (ec.SECP384R1(), \"P384\"),\n\t                \"ECDH_P521\": (ec.SECP521R1(), \"P521\"),\n", "            }[gke.secret_algorithm]\n\t            ecdh_private = ec.derive_private_key(\n\t                int.from_bytes(private_key, byteorder=\"big\"),\n\t                curve,\n\t            )\n\t            key_numbers = ecdh_private.public_key().public_numbers()\n\t            pub_key = gkdi.ECDHKey(\n\t                curve_name=curve_name,\n\t                key_length=ecdh_private.key_size // 8,\n\t                x=key_numbers.x,\n", "                y=key_numbers.y,\n\t            ).pack()\n\t        object.__setattr__(gke, \"flags\", 1)\n\t        object.__setattr__(gke, \"l2_key\", pub_key)\n\t        return gke\n\t    monkeypatch.setattr(client, \"_get_protection_gke_from_cache\", get_protection_gke)\n\t    encrypted = dpapi_ng.ncrypt_protect_secret(\n\t        test_data,\n\t        test_protection_descriptor,\n\t        root_key_identifier=root_key_id,\n", "        cache=key_cache,\n\t    )\n\t    decrypted = dpapi_ng.ncrypt_unprotect_secret(encrypted, cache=key_cache)\n\t    assert test_data == decrypted\n\t@pytest.mark.parametrize(\n\t    \"scenario\",\n\t    [\n\t        \"kdf_sha1_nonce\",\n\t        \"kdf_sha256_nonce\",\n\t        \"kdf_sha384_nonce\",\n", "        \"kdf_sha512_nonce\",\n\t        \"kdf_sha1_dh\",\n\t        \"kdf_sha256_dh\",\n\t        \"kdf_sha384_dh\",\n\t        \"kdf_sha512_dh\",\n\t        \"kdf_sha1_ecdh_p256\",\n\t        \"kdf_sha256_ecdh_p256\",\n\t        \"kdf_sha384_ecdh_p256\",\n\t        \"kdf_sha512_ecdh_p256\",\n\t        \"kdf_sha1_ecdh_p384\",\n", "        \"kdf_sha256_ecdh_p384\",\n\t        \"kdf_sha384_ecdh_p384\",\n\t        \"kdf_sha512_ecdh_p384\",\n\t    ],\n\t)\n\tdef test_unprotect_secret(\n\t    scenario: str,\n\t) -> None:\n\t    expected = b\"\\x00\"\n\t    data, key_cache = _load_root_key(scenario)\n", "    actual = dpapi_ng.ncrypt_unprotect_secret(data, cache=key_cache)\n\t    assert actual == expected\n\t@pytest.mark.asyncio\n\t@pytest.mark.parametrize(\n\t    \"scenario\",\n\t    [\n\t        \"kdf_sha1_nonce\",\n\t        \"kdf_sha256_nonce\",\n\t        \"kdf_sha384_nonce\",\n\t        \"kdf_sha512_nonce\",\n", "        \"kdf_sha1_dh\",\n\t        \"kdf_sha256_dh\",\n\t        \"kdf_sha384_dh\",\n\t        \"kdf_sha512_dh\",\n\t        \"kdf_sha1_ecdh_p256\",\n\t        \"kdf_sha256_ecdh_p256\",\n\t        \"kdf_sha384_ecdh_p256\",\n\t        \"kdf_sha512_ecdh_p256\",\n\t        \"kdf_sha1_ecdh_p384\",\n\t        \"kdf_sha256_ecdh_p384\",\n", "        \"kdf_sha384_ecdh_p384\",\n\t        \"kdf_sha512_ecdh_p384\",\n\t    ],\n\t)\n\tasync def test_async_unprotect_secret(\n\t    scenario: str,\n\t) -> None:\n\t    expected = b\"\\x00\"\n\t    data, key_cache = _load_root_key(scenario)\n\t    actual = await dpapi_ng.async_ncrypt_unprotect_secret(data, cache=key_cache)\n", "    assert actual == expected\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport pathlib\n\tdef get_test_data(name: str) -> bytes:\n\t    test_path = pathlib.Path(__file__).parent / \"data\" / name\n\t    return test_path.read_bytes()\n"]}
{"filename": "tests/test_blob.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport uuid\n\tfrom dpapi_ng import _blob as blob\n\tfrom .conftest import get_test_data\n\tdef test_blob_unpack() -> None:\n\t    data = get_test_data(\"dpapi_ng_blob\")\n\t    msg = blob.DPAPINGBlob.unpack(data)\n\t    assert msg.key_identifier.version == 1\n", "    assert msg.key_identifier.flags == 3\n\t    assert msg.key_identifier.is_public_key\n\t    assert msg.key_identifier.l0 == 361\n\t    assert msg.key_identifier.l1 == 16\n\t    assert msg.key_identifier.l2 == 3\n\t    assert msg.key_identifier.root_key_identifier == uuid.UUID(\"d778c271-9025-9a82-f6dc-b8960b8ad8c5\")\n\t    assert msg.key_identifier.key_info == get_test_data(\"ffc_dh_key\")\n\t    assert msg.key_identifier.domain_name == \"domain.test\"\n\t    assert msg.key_identifier.forest_name == \"domain.test\"\n\t    assert isinstance(msg.protection_descriptor, blob.SIDDescriptor)\n", "    assert msg.protection_descriptor.value == \"S-1-5-21-3337337973-3297078028-437386066-512\"\n\t    assert msg.enc_cek == (\n\t        b\"\\x89\\x7F\\xC4\\x3F\\x74\\x8E\\xFD\\x09\"\n\t        b\"\\x57\\x27\\xDD\\xE9\\x8F\\x4E\\x1A\\x6F\"\n\t        b\"\\xFB\\x9D\\x41\\x63\\xD3\\x9F\\xB3\\x74\"\n\t        b\"\\xD0\\x49\\xC7\\x3D\\x89\\x69\\x0C\\x7E\"\n\t        b\"\\xFA\\x45\\xE6\\xBE\\x11\\x9E\\x0D\\x6B\"\n\t    )\n\t    assert msg.enc_cek_algorithm == \"2.16.840.1.101.3.4.1.45\"\n\t    assert msg.enc_cek_parameters is None\n", "    assert msg.enc_content == (\n\t        b\"\\xE4\\xCD\\xF6\\x54\\x72\\x2A\\x49\\xD5\"\n\t        b\"\\x5F\\x53\\x08\\x55\\x0E\\xC4\\xE8\\xAA\"\n\t        b\"\\xC6\\xD0\\xBE\\x49\\x51\\x16\\xF6\\x13\"\n\t        b\"\\x2A\\x4D\\x59\\x17\\x9F\\xD7\\x13\\x8E\"\n\t        b\"\\xC9\\x4B\\x53\\x6E\\x25\\x11\\xD5\\xCA\"\n\t        b\"\\x0D\\x37\\x8D\\xEC\\x3C\\x42\\x3D\\x55\"\n\t        b\"\\xC5\\x0A\\x60\\xDC\\x41\\x8F\\x90\\x17\"\n\t        b\"\\x82\\x48\\x46\\xE0\\x2B\\x62\\x04\\xC8\"\n\t        b\"\\xB3\\x27\\x3C\\x9F\\xC4\\x43\\x37\\x63\"\n", "        b\"\\x94\\x47\\x3B\\xF9\\x7B\\xDC\\x55\\x80\"\n\t        b\"\\x09\\x51\\xAD\\xF9\\x23\\x8D\\x8A\\x02\"\n\t        b\"\\xFF\\xE0\\x38\\xCD\\x4D\\x7B\\x16\\x01\"\n\t        b\"\\x2F\\x7A\\xE8\\xB8\\x79\\x03\\xE0\\x50\"\n\t        b\"\\x00\\xD8\\xE3\\x10\\xDE\\x1B\\x2D\\x1C\"\n\t        b\"\\xA3\\x44\\xB2\\xF2\\x67\\x3A\\x3D\\x5A\"\n\t        b\"\\x5C\\x4D\\xE4\\x63\\x26\\x4B\\x95\\x64\"\n\t        b\"\\xEB\\x9E\\xB0\\x4C\\x52\\x71\\x1C\\x33\"\n\t        b\"\\xC5\\xA7\\xA9\\x74\\x0D\\x66\\x54\\x88\"\n\t        b\"\\x55\\xB6\"\n", "    )\n\t    assert msg.enc_content_algorithm == \"2.16.840.1.101.3.4.1.46\"\n\t    assert msg.enc_content_parameters == b\"\\x30\\x11\\x04\\x0C\\x9E\\x5B\\x2E\\x17\\xC2\\x3F\\x04\\xFC\\x35\\x25\\xE1\\x18\\x02\\x01\\x10\"\n"]}
{"filename": "tests/_rpc/test_verification.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport uuid\n\timport pytest\n\tfrom dpapi_ng._rpc import _bind as bind\n\tfrom dpapi_ng._rpc import _pdu as pdu\n\tfrom dpapi_ng._rpc import _verification as verification\n\tdef test_verification_trailer_pack() -> None:\n\t    expected = (\n", "        b\"\\x8a\\xe3\\x13\\x71\\x02\\xf4\\x36\\x71\"\n\t        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n\t        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n\t        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n\t    )\n\t    msg = verification.VerificationTrailer(\n\t        [\n", "            verification.CommandPContext(\n\t                verification.CommandFlags.SEC_VT_COMMAND_END,\n\t                bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0),\n\t                bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0),\n\t            )\n\t        ]\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_verification_trailer_unpack() -> None:\n", "    data = (\n\t        b\"\\x8a\\xe3\\x13\\x71\\x02\\xf4\\x36\\x71\"\n\t        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n\t        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n\t        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n\t    )\n\t    msg = verification.VerificationTrailer.unpack(data)\n", "    assert len(msg.commands) == 1\n\t    assert isinstance(msg.commands[0], verification.CommandPContext)\n\t    assert msg.commands[0].command == verification.CommandType.SEC_VT_COMMAND_PCONTEXT\n\t    assert msg.commands[0].flags == verification.CommandFlags.SEC_VT_COMMAND_END\n\t    assert msg.commands[0].value\n\t    assert msg.commands[0].interface_id == bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n\t    assert msg.commands[0].transfer_syntax == bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)\n\tdef test_verification_trailer_unpack_invalid_signature() -> None:\n\t    with pytest.raises(ValueError, match=\"Failed to unpack VerificationTrailer as signature header is invalid\"):\n\t        verification.VerificationTrailer.unpack(b\"\\x00\")\n", "def test_verification_trailer_unpack_multiple_commands() -> None:\n\t    data = b\"\\x8a\\xe3\\x13\\x71\\x02\\xf4\\x36\\x71\\x01\\x00\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x60\\x01\\x00\\x00\"\n\t    msg = verification.VerificationTrailer.unpack(data)\n\t    assert len(msg.commands) == 2\n\t    assert isinstance(msg.commands[0], verification.CommandBitmask)\n\t    assert msg.commands[0].command == verification.CommandType.SEC_VT_COMMAND_BITMASK_1\n\t    assert msg.commands[0].flags == verification.CommandFlags.NONE\n\t    assert msg.commands[0].value == b\"\\x01\\x00\\x00\\x00\"\n\t    assert msg.commands[0].bits == 1\n\t    assert isinstance(msg.commands[1], verification.Command)\n", "    assert msg.commands[1].command == verification.CommandType(0x2000)\n\t    assert msg.commands[1].flags == verification.CommandFlags.SEC_VT_COMMAND_END\n\t    assert msg.commands[1].value == b\"\\x00\"\n\tdef test_command_bitmask_pack() -> None:\n\t    expected = b\"\\x01\\x00\\x04\\x00\\x01\\x00\\x00\\x00\"\n\t    msg = verification.CommandBitmask(flags=verification.CommandFlags.NONE, bits=1)\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_command_bitmask_unpack() -> None:\n\t    data = b\"\\x01\\x00\\x04\\x00\\x01\\x00\\x00\\x00\"\n", "    msg = verification.Command.unpack(data)\n\t    assert isinstance(msg, verification.CommandBitmask)\n\t    assert msg.command == verification.CommandType.SEC_VT_COMMAND_BITMASK_1\n\t    assert msg.flags == verification.CommandFlags.NONE\n\t    assert msg.value == b\"\\x01\\x00\\x00\\x00\"\n\t    assert msg.bits == 1\n\tdef test_command_pcontext_pack() -> None:\n\t    expected = (\n\t        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n\t        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n", "        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n\t    )\n\t    msg = verification.CommandPContext(\n\t        verification.CommandFlags.SEC_VT_COMMAND_END,\n\t        bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0),\n\t        bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0),\n\t    )\n", "    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_command_pcontext_unpack() -> None:\n\t    data = (\n\t        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n\t        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n\t        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n", "    )\n\t    msg = verification.Command.unpack(data)\n\t    assert isinstance(msg, verification.CommandPContext)\n\t    assert msg.command == verification.CommandType.SEC_VT_COMMAND_PCONTEXT\n\t    assert msg.flags == verification.CommandFlags.SEC_VT_COMMAND_END\n\t    assert msg.value\n\t    assert msg.interface_id == bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n\t    assert msg.transfer_syntax == bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)\n\tdef test_command_header2_pack() -> None:\n\t    expected = b\"\\x03\\x80\\x10\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\"\n", "    msg = verification.CommandHeader2(\n\t        verification.CommandFlags.SEC_VT_MUST_PROCESS_COMMAND,\n\t        pdu.PacketType.REQUEST,\n\t        pdu.DataRep(),\n\t        1,\n\t        2,\n\t        3,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n", "def test_command_header2_unpack() -> None:\n\t    data = b\"\\x03\\x80\\x10\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\"\n\t    msg = verification.Command.unpack(data)\n\t    assert isinstance(msg, verification.CommandHeader2)\n\t    assert msg.command == verification.CommandType.SEC_VT_COMMAND_HEADER2\n\t    assert msg.flags == verification.CommandFlags.SEC_VT_MUST_PROCESS_COMMAND\n\t    assert msg.value == b\"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\"\n\t    assert msg.packet_type == pdu.PacketType.REQUEST\n\t    assert msg.data_rep == pdu.DataRep()\n\t    assert msg.call_id == 1\n", "    assert msg.context_id == 2\n\t    assert msg.opnum == 3\n\tdef test_unknown_command_unpack() -> None:\n\t    data = b\"\\x00\\xA0\\x02\\x00\\x00\\x01\"\n\t    msg = verification.Command.unpack(data)\n\t    assert isinstance(msg, verification.Command)\n\t    assert msg.command == verification.CommandType(0x2000)\n\t    assert msg.flags == verification.CommandFlags.SEC_VT_MUST_PROCESS_COMMAND\n\t    assert msg.value == b\"\\x00\\x01\"\n"]}
{"filename": "tests/_rpc/test_request.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport uuid\n\tfrom dpapi_ng._rpc import _pdu as pdu\n\tfrom dpapi_ng._rpc import _request as request\n\tdef test_request_pack() -> None:\n\t    expected = (\n\t        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n", "        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n\t    )\n\t    msg = request.Request(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.REQUEST,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=pdu.DataRep(),\n", "            frag_len=28,\n\t            auth_len=0,\n\t            call_id=2,\n\t        ),\n\t        sec_trailer=None,\n\t        alloc_hint=144,\n\t        context_id=1,\n\t        opnum=3,\n\t        obj=None,\n\t        stub_data=b\"\\x01\\x00\\x00\\x00\",\n", "    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_request_unpack() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n\t    )\n", "    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, request.Request)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.REQUEST\n\t    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 28\n", "    assert msg.header.auth_len == 0\n\t    assert msg.header.call_id == 2\n\t    assert msg.alloc_hint == 144\n\t    assert msg.context_id == 1\n\t    assert msg.opnum == 3\n\t    assert msg.obj is None\n\t    assert msg.stub_data == b\"\\x01\\x00\\x00\\x00\"\n\t    assert msg.sec_trailer is None\n\tdef test_request_pack_with_obj() -> None:\n\t    expected = (\n", "        b\"\\x05\\x00\\x00\\x83\\x10\\x00\\x00\\x00\"\n\t        b\"\\x2c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n\t        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n\t        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n\t    )\n\t    msg = request.Request(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n", "            version_minor=0,\n\t            packet_type=pdu.PacketType.REQUEST,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n\t            | pdu.PacketFlags.PFC_LAST_FRAG\n\t            | pdu.PacketFlags.PFC_OBJECT_UUID,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=44,\n\t            auth_len=0,\n\t            call_id=2,\n\t        ),\n", "        sec_trailer=None,\n\t        alloc_hint=144,\n\t        context_id=1,\n\t        opnum=3,\n\t        obj=uuid.UUID(bytes_le=b\"\\xff\" * 16),\n\t        stub_data=b\"\\x01\\x00\\x00\\x00\",\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_request_unpack_with_obj() -> None:\n", "    data = (\n\t        b\"\\x05\\x00\\x00\\x83\\x10\\x00\\x00\\x00\"\n\t        b\"\\x2c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n\t        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n\t        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n\t        b\"\\x01\\x00\\x00\\x00\"\n\t    )\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, request.Request)\n", "    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.REQUEST\n\t    assert (\n\t        msg.header.packet_flags\n\t        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_OBJECT_UUID\n\t    )\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n", "    assert msg.header.frag_len == 44\n\t    assert msg.header.auth_len == 0\n\t    assert msg.header.call_id == 2\n\t    assert msg.alloc_hint == 144\n\t    assert msg.context_id == 1\n\t    assert msg.opnum == 3\n\t    assert msg.obj == uuid.UUID(bytes_le=b\"\\xff\" * 16)\n\t    assert msg.stub_data == b\"\\x01\\x00\\x00\\x00\"\n\t    assert msg.sec_trailer is None\n\tdef test_request_pack_sec_trailer() -> None:\n", "    expected = (\n\t        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x38\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\"\n\t        b\"\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\"\n\t        b\"\\x09\\x06\\x0c\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x05\\x04\\x06\\xff\"\n\t    )\n\t    msg = request.Request(\n", "        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.REQUEST,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=56,\n\t            auth_len=4,\n\t            call_id=2,\n\t        ),\n", "        sec_trailer=pdu.SecTrailer(\n\t            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n\t            pad_length=12,\n\t            context_id=0,\n\t            auth_value=b\"\\x05\\x04\\x06\\xff\",\n\t        ),\n\t        alloc_hint=148,\n\t        context_id=1,\n\t        opnum=0,\n", "        obj=None,\n\t        stub_data=b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\",\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_request_unpack_sec_trailer() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x38\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n", "        b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\"\n\t        b\"\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\"\n\t        b\"\\x09\\x06\\x0c\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x05\\x04\\x06\\xff\"\n\t    )\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, request.Request)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.REQUEST\n", "    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 56\n\t    assert msg.header.auth_len == 4\n\t    assert msg.header.call_id == 2\n\t    assert msg.alloc_hint == 148\n\t    assert msg.context_id == 1\n\t    assert msg.opnum == 0\n", "    assert msg.obj is None\n\t    assert msg.stub_data == b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\"\n\t    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n\t    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n\t    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n\t    assert msg.sec_trailer.pad_length == 12\n\t    assert msg.sec_trailer.context_id == 0\n\t    assert msg.sec_trailer.auth_value == b\"\\x05\\x04\\x06\\xff\"\n\tdef test_response_pack() -> None:\n\t    expected = (\n", "        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n\t    )\n\t    msg = request.Response(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.RESPONSE,\n", "            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=28,\n\t            auth_len=0,\n\t            call_id=2,\n\t        ),\n\t        sec_trailer=None,\n\t        alloc_hint=148,\n\t        context_id=1,\n\t        cancel_count=0,\n", "        stub_data=b\"\\x00\\x00\\x00\\x00\",\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_response_unpack() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n", "    )\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, request.Response)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.RESPONSE\n\t    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n", "    assert msg.header.frag_len == 28\n\t    assert msg.header.auth_len == 0\n\t    assert msg.header.call_id == 2\n\t    assert msg.alloc_hint == 148\n\t    assert msg.context_id == 1\n\t    assert msg.cancel_count == 0\n\t    assert msg.stub_data == b\"\\x00\\x00\\x00\\x00\"\n\t    assert msg.sec_trailer is None\n\tdef test_response_pack_sec_trailer() -> None:\n\t    expected = (\n", "        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x28\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x60\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x9d\\x08\\xd7\\x07\\x09\\x06\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x05\\x04\\x07\\xff\"\n\t    )\n\t    msg = request.Response(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n", "            packet_type=pdu.PacketType.RESPONSE,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=40,\n\t            auth_len=4,\n\t            call_id=2,\n\t        ),\n\t        sec_trailer=pdu.SecTrailer(\n\t            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n", "            pad_length=0,\n\t            context_id=0,\n\t            auth_value=b\"\\x05\\x04\\x07\\xff\",\n\t        ),\n\t        alloc_hint=96,\n\t        context_id=1,\n\t        cancel_count=0,\n\t        stub_data=b\"\\x9d\\x08\\xd7\\x07\",\n\t    )\n\t    actual = msg.pack()\n", "    assert actual == expected\n\tdef test_response_unpack_sec_trailer() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x28\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\x60\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x9d\\x08\\xd7\\x07\\x09\\x06\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x05\\x04\\x07\\xff\"\n\t    )\n\t    msg = pdu.PDU.unpack(data)\n", "    assert isinstance(msg, request.Response)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.RESPONSE\n\t    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 40\n\t    assert msg.header.auth_len == 4\n", "    assert msg.header.call_id == 2\n\t    assert msg.alloc_hint == 96\n\t    assert msg.context_id == 1\n\t    assert msg.cancel_count == 0\n\t    assert msg.stub_data == b\"\\x9d\\x08\\xd7\\x07\"\n\t    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n\t    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n\t    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n\t    assert msg.sec_trailer.pad_length == 0\n\t    assert msg.sec_trailer.context_id == 0\n", "    assert msg.sec_trailer.auth_value == b\"\\x05\\x04\\x07\\xff\"\n"]}
{"filename": "tests/_rpc/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n"]}
{"filename": "tests/_rpc/test_pdu.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\tfrom dpapi_ng._rpc import _pdu as pdu\n\tdef test_pdu_header_pack() -> None:\n\t    expected = b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t    msg = pdu.PDUHeader(\n\t        version=5,\n\t        version_minor=0,\n\t        packet_type=pdu.PacketType.BIND,\n", "        packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t        data_rep=pdu.DataRep(),\n\t        frag_len=160,\n\t        auth_len=0,\n\t        call_id=1,\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_pdu_header_unpack() -> None:\n\t    data = b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n", "    header = pdu.PDUHeader.unpack(data)\n\t    assert header.version == 5\n\t    assert header.version_minor == 0\n\t    assert header.packet_type == pdu.PacketType.BIND\n\t    assert header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert header.frag_len == 160\n\t    assert header.auth_len == 0\n", "    assert header.call_id == 1\n\tdef test_sec_trailer_pack() -> None:\n\t    expected = b\"\\x09\\x06\\x08\\x00\\x01\\x00\\x00\\x00\\x01\"\n\t    msg = pdu.SecTrailer(\n\t        type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t        level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n\t        pad_length=8,\n\t        context_id=1,\n\t        auth_value=b\"\\x01\",\n\t    )\n", "    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_sec_trailer_unpack() -> None:\n\t    data = b\"\\x09\\x06\\x08\\x00\\x01\\x00\\x00\\x00\\x01\"\n\t    sec_trailer = pdu.SecTrailer.unpack(data)\n\t    assert sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n\t    assert sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n\t    assert sec_trailer.pad_length == 8\n\t    assert sec_trailer.context_id == 1\n\t    assert sec_trailer.auth_value == b\"\\x01\"\n", "def test_fault_pack() -> None:\n\t    expected = b\"\\x05\\x00\\x03\\x23\\x10\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x01\\x1c\\x00\\x00\\x00\\x00\"\n\t    msg = pdu.Fault(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.FAULT,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n\t            | pdu.PacketFlags.PFC_LAST_FRAG\n\t            | pdu.PacketFlags.PFC_DID_NOT_EXECUTE,\n", "            data_rep=pdu.DataRep(),\n\t            frag_len=32,\n\t            auth_len=0,\n\t            call_id=1,\n\t        ),\n\t        sec_trailer=None,\n\t        alloc_hint=32,\n\t        context_id=0,\n\t        cancel_count=0,\n\t        status=0x1C010003,\n", "        flags=pdu.FaultFlags.NONE,\n\t        stub_data=b\"\",\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_fault_unpack() -> None:\n\t    data = b\"\\x05\\x00\\x03\\x23\\x10\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x01\\x1c\\x00\\x00\\x00\\x00\"\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, pdu.Fault)\n\t    assert msg.header.version == 5\n", "    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.FAULT\n\t    assert (\n\t        msg.header.packet_flags\n\t        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_DID_NOT_EXECUTE\n\t    )\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 32\n", "    assert msg.header.auth_len == 0\n\t    assert msg.header.call_id == 1\n\t    assert msg.alloc_hint == 32\n\t    assert msg.context_id == 0\n\t    assert msg.cancel_count == 0\n\t    assert msg.flags == pdu.FaultFlags.NONE\n\t    assert msg.status == 0x1C010003\n\t    assert msg.stub_data == b\"\"\n\t    assert msg.sec_trailer is None\n"]}
{"filename": "tests/_rpc/test_bind.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport uuid\n\timport pytest\n\tfrom dpapi_ng._rpc import _bind as bind\n\tfrom dpapi_ng._rpc import _pdu as pdu\n\tdef test_bind_pack() -> None:\n\t    expected = (\n\t        b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\"\n", "        b\"\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n\t        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n\t        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n\t        b\"\\x03\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n\t        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n\t        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n\t        b\"\\x02\\x00\\x01\\x00\\x08\\x83\\xaf\\xe1\"\n\t        b\"\\x1f\\x5d\\xc9\\x11\\x91\\xa4\\x08\\x00\"\n", "        b\"\\x2b\\x14\\xa0\\xfa\\x03\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x01\\x00\"\n\t        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n\t        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n\t        b\"\\x03\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n\t        b\"\\x12\\x98\\x40\\x45\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t    )\n", "    syntax_id = bind.SyntaxId(uuid.UUID(\"e1af8308-5d1f-11c9-91a4-08002b14a0fa\"), 3, 0)\n\t    msg = bind.Bind(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.BIND,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=160,\n\t            auth_len=0,\n", "            call_id=1,\n\t        ),\n\t        sec_trailer=None,\n\t        max_xmit_frag=5840,\n\t        max_recv_frag=5840,\n\t        assoc_group=0,\n\t        contexts=[\n\t            bind.ContextElement(\n\t                context_id=1,\n\t                abstract_syntax=syntax_id,\n", "                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)],\n\t            ),\n\t            bind.ContextElement(\n\t                context_id=2,\n\t                abstract_syntax=syntax_id,\n\t                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)],\n\t            ),\n\t            bind.ContextElement(\n\t                context_id=3,\n\t                abstract_syntax=syntax_id,\n", "                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"6cb71c2c-9812-4540-0000-000000000000\"), 1, 0)],\n\t            ),\n\t        ],\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_bind_unpack() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n", "        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n\t        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n\t        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n\t        b\"\\x03\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n\t        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n\t        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n\t        b\"\\x02\\x00\\x01\\x00\\x08\\x83\\xaf\\xe1\"\n\t        b\"\\x1f\\x5d\\xc9\\x11\\x91\\xa4\\x08\\x00\"\n\t        b\"\\x2b\\x14\\xa0\\xfa\\x03\\x00\\x00\\x00\"\n", "        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x01\\x00\"\n\t        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n\t        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n\t        b\"\\x03\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n\t        b\"\\x12\\x98\\x40\\x45\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t    )\n\t    syntax_id = bind.SyntaxId(uuid.UUID(\"e1af8308-5d1f-11c9-91a4-08002b14a0fa\"), 3, 0)\n", "    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, bind.Bind)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.BIND\n\t    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 160\n", "    assert msg.header.auth_len == 0\n\t    assert msg.header.call_id == 1\n\t    assert msg.max_xmit_frag == 5840\n\t    assert msg.max_recv_frag == 5840\n\t    assert msg.assoc_group == 0\n\t    assert len(msg.contexts) == 3\n\t    assert msg.contexts[0].context_id == 1\n\t    assert msg.contexts[0].abstract_syntax == syntax_id\n\t    assert len(msg.contexts[0].transfer_syntaxes) == 1\n\t    assert msg.contexts[0].transfer_syntaxes[0] == bind.SyntaxId(\n", "        uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0\n\t    )\n\t    assert msg.contexts[1].context_id == 2\n\t    assert msg.contexts[1].abstract_syntax == syntax_id\n\t    assert len(msg.contexts[1].transfer_syntaxes) == 1\n\t    assert msg.contexts[1].transfer_syntaxes[0] == bind.SyntaxId(\n\t        uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0\n\t    )\n\t    assert msg.contexts[2].context_id == 3\n\t    assert msg.contexts[2].abstract_syntax == syntax_id\n", "    assert len(msg.contexts[2].transfer_syntaxes) == 1\n\t    assert msg.contexts[2].transfer_syntaxes[0] == bind.SyntaxId(\n\t        uuid.UUID(\"6cb71c2c-9812-4540-0000-000000000000\"), 1, 0\n\t    )\n\t    assert msg.sec_trailer is None\n\tdef test_bind_pack_sec_trailer() -> None:\n\t    expected = (\n\t        b\"\\x05\\x00\\x0b\\x07\\x10\\x00\\x00\\x00\"\n\t        b\"\\xac\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n", "        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x01\\x00\"\n\t        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n\t        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n\t        b\"\\x04\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n\t        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n\t        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x01\\x00\\x35\\x42\\x51\\xe3\"\n\t        b\"\\x06\\x4b\\xd1\\x11\\xab\\x04\\x00\\xc0\"\n\t        b\"\\x4f\\xc2\\xdc\\xd2\\x04\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n", "        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\"\n\t        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n\t        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n\t        b\"\\x04\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n\t        b\"\\x12\\x98\\x40\\x45\\x03\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x60\\x82\\x07\\x3c\"\n\t    )\n", "    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n\t    msg = bind.Bind(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.BIND,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n\t            | pdu.PacketFlags.PFC_LAST_FRAG\n\t            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n\t            data_rep=pdu.DataRep(),\n", "            frag_len=172,\n\t            auth_len=4,\n\t            call_id=2,\n\t        ),\n\t        sec_trailer=pdu.SecTrailer(\n\t            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n\t            pad_length=0,\n\t            context_id=0,\n\t            auth_value=b\"\\x60\\x82\\x07\\x3c\",\n", "        ),\n\t        max_xmit_frag=5840,\n\t        max_recv_frag=5840,\n\t        assoc_group=0,\n\t        contexts=[\n\t            bind.ContextElement(\n\t                context_id=0,\n\t                abstract_syntax=syntax_id,\n\t                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)],\n\t            ),\n", "            bind.ContextElement(\n\t                context_id=1,\n\t                abstract_syntax=syntax_id,\n\t                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)],\n\t            ),\n\t            bind.ContextElement(\n\t                context_id=2,\n\t                abstract_syntax=syntax_id,\n\t                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"6cb71c2c-9812-4540-0300-000000000000\"), 1, 0)],\n\t            ),\n", "        ],\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_bind_unpack_sec_trailer() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x0b\\x07\\x10\\x00\\x00\\x00\"\n\t        b\"\\xac\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x01\\x00\"\n", "        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n\t        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n\t        b\"\\x04\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n\t        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n\t        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x01\\x00\\x35\\x42\\x51\\xe3\"\n\t        b\"\\x06\\x4b\\xd1\\x11\\xab\\x04\\x00\\xc0\"\n\t        b\"\\x4f\\xc2\\xdc\\xd2\\x04\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n", "        b\"\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\"\n\t        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n\t        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n\t        b\"\\x04\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n\t        b\"\\x12\\x98\\x40\\x45\\x03\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x60\\x82\\x07\\x3c\"\n\t    )\n\t    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n", "    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, bind.Bind)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.BIND\n\t    assert (\n\t        msg.header.packet_flags\n\t        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n\t    )\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n", "    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 172\n\t    assert msg.header.auth_len == 4\n\t    assert msg.header.call_id == 2\n\t    assert msg.max_xmit_frag == 5840\n\t    assert msg.max_recv_frag == 5840\n\t    assert msg.assoc_group == 0\n\t    assert len(msg.contexts) == 3\n\t    assert msg.contexts[0].context_id == 0\n", "    assert msg.contexts[0].abstract_syntax == syntax_id\n\t    assert len(msg.contexts[0].transfer_syntaxes) == 1\n\t    assert msg.contexts[0].transfer_syntaxes[0] == bind.SyntaxId(\n\t        uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0\n\t    )\n\t    assert msg.contexts[1].context_id == 1\n\t    assert msg.contexts[1].abstract_syntax == syntax_id\n\t    assert len(msg.contexts[1].transfer_syntaxes) == 1\n\t    assert msg.contexts[1].transfer_syntaxes[0] == bind.SyntaxId(\n\t        uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0\n", "    )\n\t    assert msg.contexts[2].context_id == 2\n\t    assert msg.contexts[2].abstract_syntax == syntax_id\n\t    assert len(msg.contexts[2].transfer_syntaxes) == 1\n\t    assert msg.contexts[2].transfer_syntaxes[0] == bind.SyntaxId(\n\t        uuid.UUID(\"6cb71c2c-9812-4540-0300-000000000000\"), 1, 0\n\t    )\n\t    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n\t    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n\t    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n", "    assert msg.sec_trailer.pad_length == 0\n\t    assert msg.sec_trailer.context_id == 0\n\t    assert msg.sec_trailer.auth_value == b\"\\x60\\x82\\x07\\x3c\"\n\tdef test_bind_ack_pack() -> None:\n\t    expected = (\n\t        b\"\\x05\\x00\\x0c\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x6c\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\x04\\x14\\x00\\x00\"\n\t        b\"\\x04\\x00\\x31\\x33\\x35\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n", "        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n\t    )\n", "    msg = bind.BindAck(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.BIND_ACK,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=108,\n\t            auth_len=0,\n\t            call_id=1,\n", "        ),\n\t        sec_trailer=None,\n\t        max_xmit_frag=5840,\n\t        max_recv_frag=5840,\n\t        assoc_group=5124,\n\t        sec_addr=\"135\",\n\t        results=[\n\t            bind.ContextResult(\n\t                result=bind.ContextResultCode.PROVIDER_REJECTION,\n\t                reason=2,\n", "                syntax=uuid.UUID(int=0),\n\t                syntax_version=0,\n\t            ),\n\t            bind.ContextResult(\n\t                result=bind.ContextResultCode.ACCEPTANCE,\n\t                reason=0,\n\t                syntax=uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"),\n\t                syntax_version=1,\n\t            ),\n\t            bind.ContextResult(\n", "                result=bind.ContextResultCode.NEGOTIATE_ACK,\n\t                reason=3,\n\t                syntax=uuid.UUID(int=0),\n\t                syntax_version=0,\n\t            ),\n\t        ],\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_bind_ack_unpack() -> None:\n", "    data = (\n\t        b\"\\x05\\x00\\x0c\\x03\\x10\\x00\\x00\\x00\"\n\t        b\"\\x6c\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\x04\\x14\\x00\\x00\"\n\t        b\"\\x04\\x00\\x31\\x33\\x35\\x00\\x00\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n", "        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\"\n\t    )\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, bind.BindAck)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n", "    assert msg.header.packet_type == pdu.PacketType.BIND_ACK\n\t    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 108\n\t    assert msg.header.auth_len == 0\n\t    assert msg.header.call_id == 1\n\t    assert msg.max_xmit_frag == 5840\n\t    assert msg.max_recv_frag == 5840\n", "    assert msg.assoc_group == 5124\n\t    assert msg.sec_addr == \"135\"\n\t    assert len(msg.results) == 3\n\t    assert msg.results[0].result == bind.ContextResultCode.PROVIDER_REJECTION\n\t    assert msg.results[0].reason == 2\n\t    assert msg.results[0].syntax == uuid.UUID(int=0)\n\t    assert msg.results[0].syntax_version == 0\n\t    assert msg.results[1].result == bind.ContextResultCode.ACCEPTANCE\n\t    assert msg.results[1].reason == 0\n\t    assert msg.results[1].syntax == uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\")\n", "    assert msg.results[1].syntax_version == 1\n\t    assert msg.results[2].result == bind.ContextResultCode.NEGOTIATE_ACK\n\t    assert msg.results[2].reason == 3\n\t    assert msg.results[2].syntax == uuid.UUID(int=0)\n\t    assert msg.results[2].syntax_version == 0\n\t    assert msg.sec_trailer is None\n\tdef test_bind_ack_pack_sec_trailer() -> None:\n\t    expected = (\n\t        b\"\\x05\\x00\\x0c\\x07\\x10\\x00\\x00\\x00\"\n\t        b\"\\x78\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n", "        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n\t        b\"\\x06\\x00\\x34\\x39\\x36\\x36\\x37\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x09\\x06\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\xa1\\x81\\xa6\\x30\"\n\t    )\n\t    msg = bind.BindAck(\n\t        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.BIND_ACK,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n", "            | pdu.PacketFlags.PFC_LAST_FRAG\n\t            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=120,\n\t            auth_len=4,\n\t            call_id=2,\n\t        ),\n\t        sec_trailer=pdu.SecTrailer(\n\t            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n", "            pad_length=0,\n\t            context_id=0,\n\t            auth_value=b\"\\xa1\\x81\\xa6\\x30\",\n\t        ),\n\t        max_xmit_frag=5840,\n\t        max_recv_frag=5840,\n\t        assoc_group=4036,\n\t        sec_addr=\"49667\",\n\t        results=[\n\t            bind.ContextResult(\n", "                result=bind.ContextResultCode.PROVIDER_REJECTION,\n\t                reason=2,\n\t                syntax=uuid.UUID(int=0),\n\t                syntax_version=0,\n\t            ),\n\t            bind.ContextResult(\n\t                result=bind.ContextResultCode.ACCEPTANCE,\n\t                reason=0,\n\t                syntax=uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"),\n\t                syntax_version=1,\n", "            ),\n\t            bind.ContextResult(\n\t                result=bind.ContextResultCode.NEGOTIATE_ACK,\n\t                reason=3,\n\t                syntax=uuid.UUID(int=0),\n\t                syntax_version=0,\n\t            ),\n\t        ],\n\t    )\n\t    actual = msg.pack()\n", "    assert actual == expected\n\tdef test_bind_ack_unpack_sec_trailer() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x0c\\x07\\x10\\x00\\x00\\x00\"\n\t        b\"\\x78\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n\t        b\"\\x06\\x00\\x34\\x39\\x36\\x36\\x37\\x00\"\n\t        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n", "        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n\t        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n\t        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x09\\x06\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\xa1\\x81\\xa6\\x30\"\n\t    )\n\t    msg = pdu.PDU.unpack(data)\n", "    assert isinstance(msg, bind.BindAck)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.BIND_ACK\n\t    assert (\n\t        msg.header.packet_flags\n\t        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n\t    )\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n", "    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 120\n\t    assert msg.header.auth_len == 4\n\t    assert msg.header.call_id == 2\n\t    assert msg.max_xmit_frag == 5840\n\t    assert msg.max_recv_frag == 5840\n\t    assert msg.assoc_group == 4036\n\t    assert msg.sec_addr == \"49667\"\n\t    assert len(msg.results) == 3\n\t    assert msg.results[0].result == bind.ContextResultCode.PROVIDER_REJECTION\n", "    assert msg.results[0].reason == 2\n\t    assert msg.results[0].syntax == uuid.UUID(int=0)\n\t    assert msg.results[0].syntax_version == 0\n\t    assert msg.results[1].result == bind.ContextResultCode.ACCEPTANCE\n\t    assert msg.results[1].reason == 0\n\t    assert msg.results[1].syntax == uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\")\n\t    assert msg.results[1].syntax_version == 1\n\t    assert msg.results[2].result == bind.ContextResultCode.NEGOTIATE_ACK\n\t    assert msg.results[2].reason == 3\n\t    assert msg.results[2].syntax == uuid.UUID(int=0)\n", "    assert msg.results[2].syntax_version == 0\n\t    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n\t    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n\t    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n\t    assert msg.sec_trailer.pad_length == 0\n\t    assert msg.sec_trailer.context_id == 0\n\t    assert msg.sec_trailer.auth_value == b\"\\xa1\\x81\\xa6\\x30\"\n\tdef test_bind_nak_pack() -> None:\n\t    expected = b\"\\x05\\x00\\x0d\\x03\\x10\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x05\\x00\\x00\\x00\\x00\"\n\t    msg = bind.BindNak(\n", "        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.BIND_NAK,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=24,\n\t            auth_len=0,\n\t            call_id=1,\n\t        ),\n", "        sec_trailer=None,\n\t        reject_reason=0,\n\t        versions=[(5, 0)],\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_bind_nak_unpack() -> None:\n\t    data = b\"\\x05\\x00\\x0d\\x03\\x10\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x05\\x00\\x00\\x00\\x00\"\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, bind.BindNak)\n", "    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n\t    assert msg.header.packet_type == pdu.PacketType.BIND_NAK\n\t    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 24\n\t    assert msg.header.auth_len == 0\n\t    assert msg.header.call_id == 1\n", "    assert msg.reject_reason == 0\n\t    assert msg.versions == [(5, 0)]\n\t    assert msg.sec_trailer is None\n\tdef test_alter_context_pack() -> None:\n\t    expected = (\n\t        b\"\\x05\\x00\\x0e\\x07\\x10\\x00\\x00\\x00\"\n\t        b\"\\x54\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n\t        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n", "        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n\t        b\"\\x04\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n\t        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n\t        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n\t        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\xa1\\x81\\x89\\x30\"\n\t    )\n\t    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n\t    msg = bind.Bind(\n\t        header=pdu.PDUHeader(\n", "            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.ALTER_CONTEXT,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n\t            | pdu.PacketFlags.PFC_LAST_FRAG\n\t            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=84,\n\t            auth_len=4,\n\t            call_id=2,\n", "        ),\n\t        sec_trailer=pdu.SecTrailer(\n\t            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n\t            pad_length=0,\n\t            context_id=0,\n\t            auth_value=b\"\\xa1\\x81\\x89\\x30\",\n\t        ),\n\t        max_xmit_frag=5840,\n\t        max_recv_frag=5840,\n", "        assoc_group=0,\n\t        contexts=[\n\t            bind.ContextElement(\n\t                context_id=1,\n\t                abstract_syntax=syntax_id,\n\t                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)],\n\t            ),\n\t        ],\n\t    )\n\t    actual = msg.pack()\n", "    assert actual == expected\n\tdef test_alter_context_unpack() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x0e\\x07\\x10\\x00\\x00\\x00\"\n\t        b\"\\x54\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n\t        b\"\\x01\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n\t        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n\t        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n\t        b\"\\x04\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n", "        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n\t        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n\t        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\xa1\\x81\\x89\\x30\"\n\t    )\n\t    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, bind.AlterContext)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n", "    assert msg.header.packet_type == pdu.PacketType.ALTER_CONTEXT\n\t    assert (\n\t        msg.header.packet_flags\n\t        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n\t    )\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 84\n\t    assert msg.header.auth_len == 4\n", "    assert msg.header.call_id == 2\n\t    assert msg.max_xmit_frag == 5840\n\t    assert msg.max_recv_frag == 5840\n\t    assert msg.assoc_group == 0\n\t    assert len(msg.contexts) == 1\n\t    assert msg.contexts[0].context_id == 1\n\t    assert msg.contexts[0].abstract_syntax == syntax_id\n\t    assert len(msg.contexts[0].transfer_syntaxes) == 1\n\t    assert msg.contexts[0].transfer_syntaxes[0] == bind.SyntaxId(\n\t        uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0\n", "    )\n\t    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n\t    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n\t    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n\t    assert msg.sec_trailer.pad_length == 0\n\t    assert msg.sec_trailer.context_id == 0\n\t    assert msg.sec_trailer.auth_value == b\"\\xa1\\x81\\x89\\x30\"\n\tdef test_alter_context_resp_pack() -> None:\n\t    expected = (\n\t        b\"\\x05\\x00\\x0f\\x07\\x10\\x00\\x00\\x00\"\n", "        b\"\\x44\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\t        b\"\\x00\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n\t        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n\t        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n\t        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\xa1\\x27\\x30\\x25\"\n\t    )\n\t    msg = bind.AlterContextResponse(\n", "        header=pdu.PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=pdu.PacketType.ALTER_CONTEXT_RESP,\n\t            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n\t            | pdu.PacketFlags.PFC_LAST_FRAG\n\t            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n\t            data_rep=pdu.DataRep(),\n\t            frag_len=68,\n\t            auth_len=4,\n", "            call_id=2,\n\t        ),\n\t        sec_trailer=pdu.SecTrailer(\n\t            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n\t            pad_length=0,\n\t            context_id=0,\n\t            auth_value=b\"\\xa1\\x27\\x30\\x25\",\n\t        ),\n\t        max_xmit_frag=5840,\n", "        max_recv_frag=5840,\n\t        assoc_group=4036,\n\t        sec_addr=\"\",\n\t        results=[\n\t            bind.ContextResult(\n\t                result=bind.ContextResultCode.ACCEPTANCE,\n\t                reason=0,\n\t                syntax=uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"),\n\t                syntax_version=1,\n\t            ),\n", "        ],\n\t    )\n\t    actual = msg.pack()\n\t    assert actual == expected\n\tdef test_alter_context_resp_unpack() -> None:\n\t    data = (\n\t        b\"\\x05\\x00\\x0f\\x07\\x10\\x00\\x00\\x00\"\n\t        b\"\\x44\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n\t        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n\t        b\"\\x00\\x00\\x34\\x39\\x01\\x00\\x00\\x00\"\n", "        b\"\\x00\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n\t        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n\t        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n\t        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t        b\"\\xa1\\x27\\x30\\x25\"\n\t    )\n\t    msg = pdu.PDU.unpack(data)\n\t    assert isinstance(msg, bind.AlterContextResponse)\n\t    assert msg.header.version == 5\n\t    assert msg.header.version_minor == 0\n", "    assert msg.header.packet_type == pdu.PacketType.ALTER_CONTEXT_RESP\n\t    assert (\n\t        msg.header.packet_flags\n\t        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n\t    )\n\t    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n\t    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n\t    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n\t    assert msg.header.frag_len == 68\n\t    assert msg.header.auth_len == 4\n", "    assert msg.header.call_id == 2\n\t    assert msg.max_xmit_frag == 5840\n\t    assert msg.max_recv_frag == 5840\n\t    assert msg.assoc_group == 4036\n\t    assert msg.sec_addr == \"\"\n\t    assert len(msg.results) == 1\n\t    assert msg.results[0].result == bind.ContextResultCode.ACCEPTANCE\n\t    assert msg.results[0].reason == 0\n\t    assert msg.results[0].syntax == uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\")\n\t    assert msg.results[0].syntax_version == 1\n", "    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n\t    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n\t    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n\t    assert msg.sec_trailer.pad_length == 0\n\t    assert msg.sec_trailer.context_id == 0\n\t    assert msg.sec_trailer.auth_value == b\"\\xa1\\x27\\x30\\x25\"\n\t@pytest.mark.parametrize(\n\t    \"flags, expected\",\n\t    [\n\t        (bind.BindTimeFeatureNegotiation.NONE, \"6cb71c2c-9812-4540-0000-000000000000\"),\n", "        (bind.BindTimeFeatureNegotiation.SECURITY_CONTEXT_MULTIPLEXING, \"6cb71c2c-9812-4540-0100-000000000000\"),\n\t        (bind.BindTimeFeatureNegotiation.KEEP_CONNECTION_ON_ORPHAN, \"6cb71c2c-9812-4540-0200-000000000000\"),\n\t        (\n\t            bind.BindTimeFeatureNegotiation.SECURITY_CONTEXT_MULTIPLEXING\n\t            | bind.BindTimeFeatureNegotiation.KEEP_CONNECTION_ON_ORPHAN,\n\t            \"6cb71c2c-9812-4540-0300-000000000000\",\n\t        ),\n\t    ],\n\t    ids=[\n\t        \"NONE\",\n", "        \"SECURITY_CONTEXT_MULTIPLEXING\",\n\t        \"KEEP_CONNECTION_ON_ORPHAN\",\n\t        \"SECURITY_CONTEXT_MULTIPLEXING|KEEP_CONNECTION_ON_ORPHAN\",\n\t    ],\n\t)\n\tdef test_bind_time_feature_negotiation(\n\t    flags: bind.BindTimeFeatureNegotiation,\n\t    expected: str,\n\t) -> None:\n\t    actual = bind.bind_time_feature_negotiation(flags)\n", "    assert actual.uuid == uuid.UUID(expected)\n\t    assert actual.version == 1\n\t    assert actual.version_minor == 0\n"]}
{"filename": "tests/integration/templates/test_integration.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\timport os\n\timport socket\n\timport typing as t\n\timport psrp\n\timport pytest\n\timport dpapi_ng\n\tDOMAIN_REALM = \"{{ domain_name }}\"\n\tDC_FQDN = f\"dc01.{DOMAIN_REALM}\"\n", "DC_IP = socket.gethostbyname(DC_FQDN)\n\tUSERNAME1 = \"{{ domain_username | lower }}\"\n\tUSERNAME2 = \"{{ domain_username2 | lower }}\"\n\tPASSWORD = \"{{ domain_password }}\"\n\tUSER_UPN = f\"{USERNAME1}@{DOMAIN_REALM.upper()}\"\n\tGET_SID_SCRIPT = r\"\"\"[CmdletBinding()]\n\tparam (\n\t    [Parameter(Mandatory)]\n\t    [string]\n\t    $UserName\n", ")\n\t([System.Security.Principal.NTAccount]$UserName).Translate([System.Security.Principal.SecurityIdentifier]).Value\n\t\"\"\"\n\tENCRYPT_SCRIPT = r\"\"\"[CmdletBinding()]\n\tparam (\n\t    [Parameter(Mandatory)]\n\t    [string]\n\t    $ProtectionDescriptor,\n\t    [Parameter(Mandatory)]\n\t    [byte[]]\n", "    $InputObject\n\t)\n\t$ErrorActionPreference = 'Stop'\n\t# Ensure we remove any cached key so the latest KDS root is selected\n\t$cryptoKeysPath = \"$env:LOCALAPPDATA\\Microsoft\\Crypto\\KdsKey\"\n\tif (Test-Path -LiteralPath $cryptoKeysPath) {\n\t    Get-ChildItem -LiteralPath $cryptoKeysPath | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue\n\t}\n\t[byte[]]$res = . \"C:\\temp\\ConvertTo-DpapiNgBlob.ps1\" -ProtectionDescriptor $ProtectionDescriptor -InputObject $InputObject\n\t, $res\n", "\"\"\"\n\tDECRYPT_SCRIPT = r\"\"\"[CmdletBinding()]\n\tparam (\n\t    [Parameter(Mandatory)]\n\t    [byte[]]\n\t    $InputObject\n\t)\n\t$ErrorActionPreference = 'Stop'\n\t[byte[]]$res = . \"C:\\temp\\ConvertFrom-DpapiNgBlob.ps1\" -InputObject $InputObject\n\t, $res\n", "\"\"\"\n\twsman = psrp.WSManInfo(DC_FQDN)\n\twith psrp.SyncRunspacePool(wsman) as rp:\n\t    ps = psrp.SyncPowerShell(rp)\n\t    ps.add_script(GET_SID_SCRIPT).add_parameter(\"UserName\", USERNAME1)\n\t    USERNAME1_SID = ps.invoke()[0]\n\t    ps = psrp.SyncPowerShell(rp)\n\t    ps.add_script(GET_SID_SCRIPT).add_parameter(\"UserName\", USERNAME2)\n\t    USERNAME2_SID = ps.invoke()[0]\n\tdef test_decrypt_sync_with_nonce() -> None:\n", "    data = os.urandom(64)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n\t    with psrp.SyncRunspacePool(wsman) as rp:\n\t        ps = psrp.SyncPowerShell(rp)\n\t        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n\t            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n\t            InputObject=data,\n\t        )\n\t        enc_blob = ps.invoke()[0]\n\t    actual = dpapi_ng.ncrypt_unprotect_secret(enc_blob)\n", "    assert actual == data\n\t@pytest.mark.asyncio\n\tasync def test_decrypt_async_with_nonce() -> None:\n\t    data = os.urandom(64)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n\t    async with psrp.AsyncRunspacePool(wsman) as rp:\n\t        ps = psrp.AsyncPowerShell(rp)\n\t        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n\t            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n\t            InputObject=data,\n", "        )\n\t        enc_blob = (await ps.invoke())[0]\n\t    actual = await dpapi_ng.async_ncrypt_unprotect_secret(enc_blob)\n\t    assert actual == data\n\tdef test_decrypt_sync_with_public_key() -> None:\n\t    data = os.urandom(64)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n\t    with psrp.SyncRunspacePool(wsman) as rp:\n\t        ps = psrp.SyncPowerShell(rp)\n\t        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n", "            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n\t            InputObject=data,\n\t        )\n\t        enc_blob = ps.invoke()[0]\n\t    actual = dpapi_ng.ncrypt_unprotect_secret(enc_blob)\n\t    assert actual == data\n\t@pytest.mark.asyncio\n\tasync def test_decrypt_async_with_public_key() -> None:\n\t    data = os.urandom(64)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n", "    async with psrp.AsyncRunspacePool(wsman) as rp:\n\t        ps = psrp.AsyncPowerShell(rp)\n\t        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n\t            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n\t            InputObject=data,\n\t        )\n\t        enc_blob = (await ps.invoke())[0]\n\t    actual = dpapi_ng.ncrypt_unprotect_secret(enc_blob)\n\t    assert actual == data\n\tdef test_encrypt_sync_as_authorised_user() -> None:\n", "    data = os.urandom(64)\n\t    kwargs: t.Dict[str, t.Any] = {}\n\t    if os.name != \"nt\":\n\t        kwargs[\"domain_name\"] = DOMAIN_REALM\n\t    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME1_SID, **kwargs)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n\t    with psrp.SyncRunspacePool(wsman) as rp:\n\t        ps = psrp.SyncPowerShell(rp)\n\t        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n\t        actual = ps.invoke()\n", "        assert not ps.had_errors\n\t        assert actual == [data]\n\t@pytest.mark.asyncio\n\tasync def test_encrypt_async_as_authorised_user() -> None:\n\t    data = os.urandom(64)\n\t    kwargs: t.Dict[str, t.Any] = {}\n\t    if os.name != \"nt\":\n\t        kwargs[\"domain_name\"] = DOMAIN_REALM\n\t    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME1_SID, **kwargs)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n", "    async with psrp.AsyncRunspacePool(wsman) as rp:\n\t        ps = psrp.AsyncPowerShell(rp)\n\t        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n\t        actual = await ps.invoke()\n\t        assert not ps.had_errors\n\t        assert actual == [data]\n\tdef test_encrypt_sync_as_unauthorised_user() -> None:\n\t    data = os.urandom(64)\n\t    kwargs: t.Dict[str, t.Any] = {}\n\t    if os.name != \"nt\":\n", "        kwargs[\"domain_name\"] = DOMAIN_REALM\n\t    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME2_SID, **kwargs)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n\t    with psrp.SyncRunspacePool(wsman) as rp:\n\t        ps = psrp.SyncPowerShell(rp)\n\t        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n\t        actual = ps.invoke()\n\t        assert not ps.had_errors\n\t        assert actual == [data]\n\t@pytest.mark.asyncio\n", "async def test_encrypt_async_as_unauthorised_user() -> None:\n\t    data = os.urandom(64)\n\t    kwargs: t.Dict[str, t.Any] = {}\n\t    if os.name != \"nt\":\n\t        kwargs[\"domain_name\"] = DOMAIN_REALM\n\t    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME2_SID, **kwargs)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n\t    async with psrp.AsyncRunspacePool(wsman) as rp:\n\t        ps = psrp.AsyncPowerShell(rp)\n\t        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n", "        actual = await ps.invoke()\n\t        assert not ps.had_errors\n\t        assert actual == [data]\n\t@pytest.mark.parametrize(\"protocol\", [\"negotiate\", \"negotiate-ntlm\", \"kerberos\", \"ntlm\"])\n\tdef test_rpc_auth(protocol: str) -> None:\n\t    data = os.urandom(64)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n\t    with psrp.SyncRunspacePool(wsman) as rp:\n\t        ps = psrp.SyncPowerShell(rp)\n\t        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n", "            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n\t            InputObject=data,\n\t        )\n\t        enc_blob = ps.invoke()[0]\n\t    server = None\n\t    username = None\n\t    password = None\n\t    is_ntlm = protocol in [\"negotiate-ntlm\", \"ntlm\"]\n\t    if protocol == \"negotiate-ntlm\":\n\t        server = DC_IP\n", "        protocol = \"negotiate\"\n\t    if os.name != \"nt\" and is_ntlm:\n\t        username = USER_UPN\n\t        password = PASSWORD\n\t    actual = dpapi_ng.ncrypt_unprotect_secret(\n\t        enc_blob,\n\t        server,\n\t        username=username,\n\t        password=password,\n\t        auth_protocol=protocol,\n", "    )\n\t    assert actual == data\n\t@pytest.mark.asyncio\n\t@pytest.mark.parametrize(\"protocol\", [\"negotiate\", \"negotiate-ntlm\", \"kerberos\", \"ntlm\"])\n\tasync def test_rpc_auth_async(protocol: str) -> None:\n\t    data = os.urandom(64)\n\t    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n\t    async with psrp.AsyncRunspacePool(wsman) as rp:\n\t        ps = psrp.AsyncPowerShell(rp)\n\t        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n", "            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n\t            InputObject=data,\n\t        )\n\t        enc_blob = (await ps.invoke())[0]\n\t    server = None\n\t    username = None\n\t    password = None\n\t    is_ntlm = protocol in [\"negotiate-ntlm\", \"ntlm\"]\n\t    if protocol == \"negotiate-ntlm\":\n\t        server = DC_IP\n", "        protocol = \"negotiate\"\n\t    if os.name != \"nt\" and is_ntlm:\n\t        username = USER_UPN\n\t        password = PASSWORD\n\t    actual = await dpapi_ng.async_ncrypt_unprotect_secret(\n\t        enc_blob,\n\t        server,\n\t        username=username,\n\t        password=password,\n\t        auth_protocol=protocol,\n", "    )\n\t    assert actual == data\n"]}
{"filename": "tests/integration/files/generate_seed_keys.py", "chunked_list": ["import base64\n\timport uuid\n\tfrom cryptography.hazmat.primitives import hashes\n\tfrom dpapi_ng import _crypto as crypto\n\tfrom dpapi_ng import _gkdi as gkdi\n\talgorithm = hashes.SHA512()\n\tkey_id = uuid.UUID(\"2e1b932a-4e21-ced3-0b7b-8815aff8335d\")\n\t# This should be the L1 seed key for (L0, 31, -1)\n\tl1_key = base64.b16decode(\n\t    \"60E0A81F93164F5DC3ABE981E1EE54C1A6B9B0EDB6FF8274642758D29BBC66559D11F1871A82A6E3F232C42490D7C41C6AD2B8B189FE2752A88CEC2EA4B2021C\"\n", ")\n\tl0 = 361\n\tl1 = 31\n\tl2 = 31\n\tl2_key = b\"\"\n\twhile l1 >= 0:\n\t    print(f\"({l0}, {l1:<2}, -1) {base64.b16encode(l1_key).decode()}\")\n\t    while l2 >= 0:\n\t        if l2 == 31:\n\t            l2_key = crypto.kdf(\n", "                algorithm,\n\t                l1_key,\n\t                gkdi.KDS_SERVICE_LABEL,\n\t                gkdi.compute_kdf_context(key_id, l0, l1, l2),\n\t                64,\n\t            )\n\t        else:\n\t            l2_key = crypto.kdf(\n\t                algorithm,\n\t                l2_key,\n", "                gkdi.KDS_SERVICE_LABEL,\n\t                gkdi.compute_kdf_context(key_id, l0, l1, l2),\n\t                64,\n\t            )\n\t        print(f\"({l0}, {l1:<2}, {l2:<2}) {base64.b16encode(l2_key).decode()}\")\n\t        l2 -= 1\n\t    l2 = 31\n\t    l1 -= 1\n\t    l1_key = crypto.kdf(\n\t        algorithm,\n", "        l1_key,\n\t        gkdi.KDS_SERVICE_LABEL,\n\t        gkdi.compute_kdf_context(key_id, l0, l1, -1),\n\t        64,\n\t    )\n"]}
{"filename": "tests/integration/files/sp800_56a_concat.py", "chunked_list": ["import base64\n\timport dataclasses\n\timport hashlib\n\timport sys\n\timport typing as t\n\tfrom cryptography.hazmat.primitives import hashes\n\tfrom cryptography.hazmat.primitives.asymmetric import ec\n\tfrom cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash\n\t@dataclasses.dataclass(frozen=True)\n\tclass FFCDHKey:\n", "    # MS-GKDI 2.2.3.1 FFC DH Key:\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/f8770f01-036d-4bf6-a4cf-1bd0e3913404\n\t    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x44\\x48\\x50\\x42\")\n\t    key_length: int\n\t    field_order: int\n\t    generator: int\n\t    public_key: int\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n", "        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> \"FFCDHKey\":\n\t        view = memoryview(data)\n\t        if view[:4].tobytes() != cls.magic:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\t        key_length = int.from_bytes(view[4:8], byteorder=\"little\")\n\t        field_order = view[8 : 8 + key_length].tobytes()\n\t        view = view[8 + key_length :]\n\t        generator = view[:key_length].tobytes()\n\t        view = view[key_length:]\n", "        public_key = view[:key_length].tobytes()\n\t        return FFCDHKey(\n\t            key_length=key_length,\n\t            field_order=int.from_bytes(field_order, byteorder=\"big\"),\n\t            generator=int.from_bytes(generator, byteorder=\"big\"),\n\t            public_key=int.from_bytes(public_key, byteorder=\"big\"),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass ECDHKey:\n\t    # MS-GKDI 2.2.3.2 ECDH Key:\n", "    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/24876a37-9a92-4187-9052-222bb6f85d4a\n\t    curve_name: str\n\t    key_length: int\n\t    x: int\n\t    y: int\n\t    @property\n\t    def curve_and_hash(self) -> tuple[ec.EllipticCurve, hashes.HashAlgorithm]:\n\t        return {\n\t            \"P256\": (ec.SECP256R1(), hashes.SHA256()),\n\t            \"P384\": (ec.SECP384R1(), hashes.SHA384()),\n", "            \"P521\": (ec.SECP521R1(), hashes.SHA512()),\n\t        }[self.curve_name]\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> \"ECDHKey\":\n\t        view = memoryview(data)\n\t        curve_id = int.from_bytes(view[:4], byteorder=\"little\")\n\t        curve = {\n", "            0x314B4345: \"P256\",\n\t            0x334B4345: \"P384\",\n\t            0x354B4345: \"P521\",\n\t        }.get(curve_id, None)\n\t        if not curve:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} with unknown curve 0x{curve_id:08X}\")\n\t        length = int.from_bytes(view[4:8], byteorder=\"little\")\n\t        x = view[8 : 8 + length].tobytes()\n\t        view = view[8 + length :]\n\t        y = view[:length].tobytes()\n", "        return ECDHKey(\n\t            curve_name=curve,\n\t            key_length=length,\n\t            x=int.from_bytes(x, byteorder=\"big\"),\n\t            y=int.from_bytes(y, byteorder=\"big\"),\n\t        )\n\tscenarios = {\n\t    \"DH\": {\n\t        \"KeyLength\": 2048,\n\t        \"SecretParams\": \"0C0200004448504D0001000087A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A15973FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659\",\n", "        \"PublicKey\": \"444850420001000087A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A15973FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659535CC9DB0F3BE1D18BA5D691DCBD7ADFC2A3F331E8875264BDB99B71F0DD0715ED1002DFFDC00BEA4A252738BFD027B283C0A61C3BA7A060732B2DBEC520BCA23941810CBC555A4C69F45F35C05EE02E71E3ACB6ED5B9B55F0DC408E13640CDC58A04900E73018ADBD7D5840DD29CB6482AF75483C22AF35A48AD0D166FADED4C1C58F749CD130BDB4726938FC6A90E17726D75B2284592AA292B52A97807B80355705794340702333C9558EC671DD206D9C796BC26953D7F7261776E69A2DA8496E3AD04877D645571BBCCE655CD57C53BFE3406B457B807BB497B79C99D0766DD3D19B594E98D5B685302171A02313DA5BE5F5F6D1B98BC6B9BF5B68992C1C\",\n\t        \"PrivateKey\": \"8844C8622AF1CC0D2ACF6581CD4F03DBDA3C97C08E37C97CA6E8C30C0B4E27926C6726FF6EF74EFA6D7F9AF818564A73D511A661E37CB41D07098B0F4D0D5B80\",\n\t        \"ExpectedSecretAgreement\": \"2F3ED6CECAFBDF3E386240FCFB5B499310015243651BC97AEFF9EE23E760100E3A825814CCBD7B064339B9105512CEA22D6E9C0FEFBBDADCC26E01BD8F286BD9993F0068B3CFEF9113311BBAA7B37D05462E2B740259CC211E75260708706A98B3FB967C45109FDABF6589312490B6F03AA65F0E4C882317865C55708916D82B962912909F6ED6E85EDEB7CB2CC1AC8C812A390A23B4E2DB645D17BF7417BF9F176CE807366A46A5797E7F5828B64389ADAEDDED099A9BC634C037315D0389B008C5D3CB966AF458FC524F8C7FBF814DD93117979F5410952510BED6B5BA4A7DBCA10FFDC4B7A5709C223C9A1AF9C9B36BF92883333417A3606CC59A200B12D1\",\n\t        \"ExpectedSecret\": \"CAF41BA47887FB04AC7B80B6FF1BD15C5135500372B889A143C3AAC7D695955E\",\n\t    },\n\t    \"ECDH_P256\": {\n\t        \"KeyLength\": 256,\n\t        \"SecretParams\": \"\",\n\t        \"PublicKey\": \"45434B31200000005AFBDDBB412E39B367302AEDF04A8F8D184D9801FA4A560BF35AB0FD83E5C93CB5EE98D8B938672442C1CFCDFAADADA31A014776F9B72C2CA9F06E5B6DDA2218\",\n\t        \"PrivateKey\": \"B65D20E0916BE7C6A9F865826432C4F3B5347FAA07271D675C065EE2BA34AA13\",\n", "        \"ExpectedSecretAgreement\": \"98E13228F67F865CB9A699679F37C394BCA0DF718AF71C9F9E97B7108C16D74B\",\n\t        \"ExpectedSecret\": \"37208B86DC931C2F5FB4E5A0295B877D0AE98B8F4CE79F6B407B5926B519AF6C\",\n\t    },\n\t    \"ECDH_P384\": {\n\t        \"KeyLength\": 384,\n\t        \"SecretParams\": \"\",\n\t        \"PublicKey\": \"45434B3330000000519FB25DB5692BADEE44DE4044EC0F0AAF4BD86F9D3F1967031AD2E7B7A656EEE7E114EFFCF0D83E682C246F3E04119FED903CE810FC060F6DCA3E4901E20DFA5EE82AE9DCB237102892E8A2997BFF0CC9C755541F066E83550FD200B3D4B50E\",\n\t        \"PrivateKey\": \"1D94E9DE911B17981356E4464B691FDAB12AE822ECC152C2D786CD060CA32255ACE7B1EB0F3644AAE19AF5F75D03FFC3\",\n\t        \"ExpectedSecretAgreement\": \"2441392B082A8A8AD52BE6707517DA5CF19A629B4AF177B19FF03D13BF6CBA2D0A06A98259C16F6A3CDDD29EE50B72FC\",\n\t        \"ExpectedSecret\": \"8A10120B4DD74F21DA5C79917E993DBC5DE1A8346112A33300C8F30CCC77E5F1DEAD404BBDA472E6CB42D6A448872425\",\n", "    },\n\t}\n\tscenario = sys.argv[1]\n\tkey_length = scenarios[scenario][\"KeyLength\"]\n\tsecret_params = base64.b16decode(str(scenarios[scenario][\"SecretParams\"]))\n\tpublic_key = base64.b16decode(str(scenarios[scenario][\"PublicKey\"]))\n\tprivate_key = base64.b16decode(str(scenarios[scenario][\"PrivateKey\"]))\n\texpected_secret_agreement = base64.b16decode(str(scenarios[scenario][\"ExpectedSecretAgreement\"]))\n\texpected_secret = base64.b16decode(str(scenarios[scenario][\"ExpectedSecret\"]))\n\tsecret_hash_algorithm: hashes.HashAlgorithm\n", "if scenario == \"DH\":\n\t    dh_pub_key = FFCDHKey.unpack(public_key)\n\t    shared_secret_int = pow(\n\t        dh_pub_key.public_key,\n\t        int.from_bytes(private_key, byteorder=\"big\"),\n\t        dh_pub_key.field_order,\n\t    )\n\t    shared_secret = shared_secret_int.to_bytes(dh_pub_key.key_length, byteorder=\"big\")\n\t    secret_hash_algorithm = hashes.SHA256()\n\telse:\n", "    ecdh_pub_key_info = ECDHKey.unpack(public_key)\n\t    curve, secret_hash_algorithm = ecdh_pub_key_info.curve_and_hash\n\t    ecdh_pub_key = ec.EllipticCurvePublicNumbers(ecdh_pub_key_info.x, ecdh_pub_key_info.y, curve).public_key()\n\t    ecdh_private = ec.derive_private_key(\n\t        int.from_bytes(private_key, byteorder=\"big\"),\n\t        curve,\n\t    )\n\t    shared_secret = ecdh_private.exchange(ec.ECDH(), ecdh_pub_key)\n\tshared_secret1 = hashlib.sha256(shared_secret).digest()\n\tprint(f\"Actual Secret Agreement  : {base64.b16encode(shared_secret).decode()}\")\n", "print(f\"Expected Secret Agreement: {base64.b16encode(expected_secret_agreement).decode()}\")\n\talgorithm_id = \"SHA512\\0\"\n\tparty_uinfo = \"KDS public key\\0\"\n\tparty_vinfo = \"KDS service\\0\"\n\totherinfo = f\"{algorithm_id}{party_uinfo}{party_vinfo}\".encode(\"utf-16-le\")\n\tactual = ConcatKDFHash(\n\t    secret_hash_algorithm,\n\t    length=secret_hash_algorithm.digest_size,\n\t    otherinfo=otherinfo,\n\t).derive(shared_secret)\n", "print(f\"Actual Secret  : {base64.b16encode(actual).decode()}\")\n\tprint(f\"Expected Secret: {base64.b16encode(expected_secret).decode()}\")\n"]}
{"filename": "src/dpapi_ng/_epm.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport enum\n\timport typing as t\n\timport uuid\n\tfrom ._rpc import SyntaxId\n\tEPM = SyntaxId(uuid.UUID(\"e1af8308-5d1f-11c9-91a4-08002b14a0fa\"), 3, 0)\n\t# https://pubs.opengroup.org/onlinepubs/9629399/apdxl.htm\n", "# https://pubs.opengroup.org/onlinepubs/9629399/apdxi.htm#tagcjh_28\n\tclass FloorProtocol(enum.IntEnum):\n\t    OSI = 0x00\n\t    DNA_SESSION_CONTROL = 0x02\n\t    DNA_SESSION_CONTROL_V3 = 0x03\n\t    DNA_NSP_TRANSPORT = 0x04\n\t    TP4 = 0x05\n\t    CLNS = 0x06\n\t    TCP = 0x07\n\t    UDP = 0x08\n", "    IP = 0x09\n\t    RPC_CONNECTIONLESS = 0x0A\n\t    RPC_CONNECTION_ORIENTED = 0x0B\n\t    UUID_ID = 0x0D\n\t    NAMED_PIPES = 0x10\n\t    NETBIOS = 0x11\n\t    NETBEUI = 0x12\n\t    NETWARE_SPX = 0x13\n\t    NETWARE_IPX = 0x14\n\t    APPLETALK_STREAM = 0x16\n", "    APPLETALK_DATARAM = 0x17\n\t    APPLETALK = 0x18\n\t    NETBIOS2 = 0x19\n\t    VINES_SPP = 0x1A\n\t    VINES_IPC = 0x1B\n\t    STREET_TALK = 0x1C\n\t    UNIX_DOMAIN_SOCKET = 0x20\n\t    NULL = 0x21\n\t    NETBIOS3 = 0x22\n\t    @classmethod\n", "    def _missing_(cls, value: object) -> t.Optional[enum.Enum]:\n\t        new_member = int.__new__(cls)\n\t        new_member._name_ = f\"FloorProtocol Unknown 0x{value:04X}\"\n\t        new_member._value_ = value  # type: ignore[assignment]\n\t        return cls._value2member_map_.setdefault(value, new_member)\n\t@dataclasses.dataclass(frozen=True)\n\tclass Floor:\n\t    protocol: FloorProtocol\n\t    lhs: bytes\n\t    rhs: bytes\n", "    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                (len(self.lhs) + 1).to_bytes(2, byteorder=\"little\"),\n\t                self.protocol.to_bytes(1, byteorder=\"little\"),\n\t                self.lhs,\n\t                len(self.rhs).to_bytes(2, byteorder=\"little\"),\n\t                self.rhs,\n\t            ]\n\t        )\n", "    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> Floor:\n\t        view = memoryview(data)\n\t        lhs_len = int.from_bytes(view[:2], byteorder=\"little\")\n\t        proto = FloorProtocol(view[2])\n\t        lhs = view[3 : lhs_len + 2].tobytes()\n\t        offset = lhs_len + 2\n", "        rhs_len = int.from_bytes(view[offset : offset + 2], byteorder=\"little\")\n\t        rhs = view[offset + 2 : offset + rhs_len + 2].tobytes()\n\t        unpack_func = _FLOOR_TYPE_REGISTRY.get(proto, None)\n\t        if unpack_func:\n\t            floor = unpack_func(lhs, rhs)\n\t            object.__setattr__(floor, \"lhs\", lhs)\n\t            object.__setattr__(floor, \"rhs\", rhs)\n\t            return floor\n\t        else:\n\t            return cls(protocol=proto, lhs=lhs, rhs=rhs)\n", "T = t.TypeVar(\"T\")\n\t_FLOOR_TYPE_REGISTRY: t.Dict[FloorProtocol, t.Callable[[bytes, bytes], Floor]] = {}\n\tdef register_floor(cls: T) -> T:\n\t    _FLOOR_TYPE_REGISTRY[getattr(cls, \"protocol\").default] = getattr(cls, \"_unpack\")\n\t    return cls\n\t@dataclasses.dataclass(frozen=True)\n\tclass _KnownFloor(Floor):\n\t    lhs: bytes = dataclasses.field(init=False, repr=False, default=b\"\")\n\t    rhs: bytes = dataclasses.field(init=False, repr=False, default=b\"\")\n\t@dataclasses.dataclass(frozen=True)\n", "@register_floor\n\tclass TCPFloor(_KnownFloor):\n\t    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.TCP)\n\t    port: int\n\t    def pack(self) -> bytes:\n\t        return Floor(self.protocol, b\"\", self.port.to_bytes(2, byteorder=\"big\")).pack()\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        lhs: bytes,\n", "        rhs: bytes,\n\t    ) -> TCPFloor:\n\t        return TCPFloor(int.from_bytes(rhs, byteorder=\"big\"))\n\t@dataclasses.dataclass(frozen=True)\n\t@register_floor\n\tclass IPFloor(_KnownFloor):\n\t    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.IP)\n\t    addr: int\n\t    def pack(self) -> bytes:\n\t        return Floor(self.protocol, b\"\", self.addr.to_bytes(4, byteorder=\"big\")).pack()\n", "    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        lhs: bytes,\n\t        rhs: bytes,\n\t    ) -> IPFloor:\n\t        return IPFloor(int.from_bytes(rhs, byteorder=\"big\"))\n\t@dataclasses.dataclass(frozen=True)\n\t@register_floor\n\tclass RPCConnectionOrientedFloor(_KnownFloor):\n", "    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.RPC_CONNECTION_ORIENTED)\n\t    version_minor: int\n\t    def pack(self) -> bytes:\n\t        return Floor(self.protocol, b\"\", self.version_minor.to_bytes(2, byteorder=\"little\")).pack()\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        lhs: bytes,\n\t        rhs: bytes,\n\t    ) -> RPCConnectionOrientedFloor:\n", "        return RPCConnectionOrientedFloor(int.from_bytes(rhs, byteorder=\"little\"))\n\t@dataclasses.dataclass(frozen=True)\n\t@register_floor\n\tclass UUIDFloor(_KnownFloor):\n\t    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.UUID_ID)\n\t    uuid: uuid.UUID\n\t    version: int\n\t    version_minor: int\n\t    def pack(self) -> bytes:\n\t        return Floor(\n", "            protocol=self.protocol,\n\t            lhs=self.uuid.bytes_le + self.version.to_bytes(2, byteorder=\"little\"),\n\t            rhs=self.version_minor.to_bytes(2, byteorder=\"little\"),\n\t        ).pack()\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        lhs: bytes,\n\t        rhs: bytes,\n\t    ) -> UUIDFloor:\n", "        object_uuid = uuid.UUID(bytes_le=lhs[:16])\n\t        version = int.from_bytes(lhs[16:18], byteorder=\"little\")\n\t        version_minor = int.from_bytes(rhs, byteorder=\"little\")\n\t        return UUIDFloor(object_uuid, version, version_minor)\n\tdef build_tcpip_tower(\n\t    service: SyntaxId,\n\t    data_rep: SyntaxId,\n\t    port: int,\n\t    addr: int,\n\t) -> t.List[Floor]:\n", "    return [\n\t        UUIDFloor(service.uuid, service.version, service.version_minor),\n\t        UUIDFloor(data_rep.uuid, data_rep.version, data_rep.version_minor),\n\t        RPCConnectionOrientedFloor(0),\n\t        TCPFloor(port),\n\t        IPFloor(addr),\n\t    ]\n\t@dataclasses.dataclass(frozen=True)\n\tclass EptMap:\n\t    opnum: int = dataclasses.field(init=False, repr=False, default=3)\n", "    obj: t.Optional[uuid.UUID]\n\t    tower: t.List[Floor]\n\t    entry_handle: t.Optional[tuple[int, uuid.UUID]]\n\t    max_towers: int\n\t    # MS-RPCE 2.2.1.2.5 ept_map Method\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/ab744583-430e-4055-8901-3c6bc007e791\n\t    # void ept_map(\n\t    #     [in] handle_t hEpMapper,\n\t    #     [in, ptr] UUID* obj,\n\t    #     [in, ptr] twr_p_t map_tower,\n", "    #     [in, out] ept_lookup_handle_t* entry_handle,\n\t    #     [in, range(0,500)] unsigned long max_towers,\n\t    #     [out] unsigned long* num_towers,\n\t    #     [out, ptr, size_is(max_towers), length_is(*num_towers)]\n\t    #         twr_p_t* ITowers,\n\t    #     [out] error_status* status\n\t    # );\n\t    def pack(self) -> bytes:\n\t        b_tower = b\"\".join(\n\t            [\n", "                len(self.tower).to_bytes(2, byteorder=\"little\"),\n\t                b\"\".join(f.pack() for f in self.tower),\n\t            ]\n\t        )\n\t        tower_padding = -(len(b_tower) + 4) % 8\n\t        if self.entry_handle:\n\t            b_entry_handle = self.entry_handle[0].to_bytes(4, byteorder=\"little\") + self.entry_handle[1].bytes_le\n\t        else:\n\t            b_entry_handle = b\"\\x00\" * 20\n\t        return b\"\".join(\n", "            [\n\t                # obj with a referent id of 1\n\t                b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t                self.obj.bytes_le if self.obj else b\"\\x00\" * 16,\n\t                # Tower referent id 2\n\t                b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t                len(b_tower).to_bytes(8, byteorder=\"little\"),\n\t                len(b_tower).to_bytes(4, byteorder=\"little\"),\n\t                b_tower,\n\t                b\"\\x00\" * tower_padding,\n", "                b_entry_handle,\n\t                self.max_towers.to_bytes(4, byteorder=\"little\"),\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> EptMap:\n\t        view = memoryview(data)\n", "        b_obj = view[8:24].tobytes()\n\t        if b_obj == b\"\\x00\" * 16:\n\t            obj = None\n\t        else:\n\t            obj = uuid.UUID(bytes_le=b_obj)\n\t        view = view[32:]\n\t        tower_length = int.from_bytes(view[:8], byteorder=\"little\")\n\t        padding = -(tower_length + 4) % 8\n\t        floor_len = int.from_bytes(view[12:14], byteorder=\"little\")\n\t        view = view[14:]\n", "        tower = []\n\t        for _ in range(floor_len):\n\t            floor = Floor.unpack(view)\n\t            view = view[len(floor.lhs) + len(floor.rhs) + 5 :]\n\t            tower.append(floor)\n\t        view = view[padding:]\n\t        b_entry_handle = view[:20].tobytes()\n\t        if b_entry_handle == b\"\\x00\" * 20:\n\t            entry_handle = None\n\t        else:\n", "            entry_handle = (\n\t                int.from_bytes(view[:4], byteorder=\"little\"),\n\t                uuid.UUID(bytes_le=view[4:20].tobytes()),\n\t            )\n\t        max_towers = int.from_bytes(view[20:24], byteorder=\"little\")\n\t        return cls(\n\t            obj=obj,\n\t            tower=tower,\n\t            entry_handle=entry_handle,\n\t            max_towers=max_towers,\n", "        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass EptMapResult:\n\t    entry_handle: t.Optional[tuple[int, uuid.UUID]]\n\t    towers: t.List[t.List[Floor]]\n\t    status: int\n\t    def pack(self) -> bytes:\n\t        if self.entry_handle:\n\t            b_entry_handle = self.entry_handle[0].to_bytes(4, byteorder=\"little\") + self.entry_handle[1].bytes_le\n\t        else:\n", "            b_entry_handle = b\"\\x00\" * 20\n\t        b_tower_referents = bytearray()\n\t        b_tower = bytearray()\n\t        for idx, t in enumerate(self.towers):\n\t            b_tower_referents += (idx + 3).to_bytes(8, byteorder=\"little\")\n\t            b_t = b\"\".join(\n\t                [\n\t                    len(t).to_bytes(2, byteorder=\"little\"),\n\t                    b\"\".join(f.pack() for f in t),\n\t                ]\n", "            )\n\t            padding = -(len(b_t)) % 4\n\t            b_tower += b\"\".join(\n\t                [\n\t                    len(b_t).to_bytes(8, byteorder=\"little\"),\n\t                    len(b_t).to_bytes(4, byteorder=\"little\"),\n\t                    b_t,\n\t                    b\"\\x00\" * padding,\n\t                ]\n\t            )\n", "        return b\"\".join(\n\t            [\n\t                b_entry_handle,\n\t                len(self.towers).to_bytes(4, byteorder=\"little\"),\n\t                len(self.towers).to_bytes(8, byteorder=\"little\"),\n\t                b\"\\x00\" * 8,  # Tower pointer offset\n\t                len(self.towers).to_bytes(8, byteorder=\"little\"),\n\t                b_tower_referents,\n\t                b_tower,\n\t                self.status.to_bytes(4, byteorder=\"little\"),\n", "            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> EptMapResult:\n\t        view = memoryview(data)\n\t        status = int.from_bytes(view[-4:], byteorder=\"little\")\n\t        b_entry_handle = view[:20].tobytes()\n", "        if b_entry_handle == b\"\\x00\" * 20:\n\t            entry_handle = None\n\t        else:\n\t            entry_handle = (\n\t                int.from_bytes(view[:4], byteorder=\"little\"),\n\t                uuid.UUID(bytes_le=view[4:20].tobytes()),\n\t            )\n\t        # num_towers = int.from_bytes(view[20:24], byteorder=\"little\")\n\t        # max_tower_count = int.from_bytes(view[24:32], byteorder=\"little\")\n\t        # tower_offset = int.from_bytes(view[32:40], byteorder=\"little\")\n", "        tower_count = int.from_bytes(view[40:48], byteorder=\"little\")\n\t        tower_data_offset = 8 * tower_count  # Ignore referent ids\n\t        view = view[48 + tower_data_offset :]\n\t        towers: t.List[t.List[Floor]] = []\n\t        for _ in range(tower_count):\n\t            tower_length = int.from_bytes(view[:8], byteorder=\"little\")\n\t            padding = -(tower_length + 4) % 8\n\t            floor_len = int.from_bytes(view[12:14], byteorder=\"little\")\n\t            view = view[14:]\n\t            tower = []\n", "            for _ in range(floor_len):\n\t                floor = Floor.unpack(view)\n\t                view = view[len(floor.lhs) + len(floor.rhs) + 5 :]\n\t                tower.append(floor)\n\t            towers.append(tower)\n\t            view = view[padding:]\n\t        return cls(\n\t            entry_handle=entry_handle,\n\t            towers=towers,\n\t            status=status,\n", "        )\n"]}
{"filename": "src/dpapi_ng/_version.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\t__version__ = \"0.2.0\"\n"]}
{"filename": "src/dpapi_ng/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\tfrom ._client import (\n\t    KeyCache,\n\t    async_ncrypt_protect_secret,\n\t    async_ncrypt_unprotect_secret,\n\t    ncrypt_protect_secret,\n\t    ncrypt_unprotect_secret,\n\t)\n", "__all__ = [\n\t    \"KeyCache\",\n\t    \"async_ncrypt_protect_secret\",\n\t    \"async_ncrypt_unprotect_secret\",\n\t    \"ncrypt_protect_secret\",\n\t    \"ncrypt_unprotect_secret\",\n\t]\n"]}
{"filename": "src/dpapi_ng/_asn1.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport enum\n\timport struct\n\timport typing as t\n\tfrom types import TracebackType\n\tT = t.TypeVar(\"T\", bound=int)\n\tclass NotEnougData(Exception):\n\t    \"There is not enough data available to unpack ASN.1 value\"\n", "class TagClass(enum.IntEnum):\n\t    \"\"\"The ASN.1 tag class types.\"\"\"\n\t    UNIVERSAL = 0\n\t    APPLICATION = 1\n\t    CONTEXT_SPECIFIC = 2\n\t    PRIVATE = 3\n\tclass TypeTagNumber(enum.IntEnum):\n\t    \"\"\"The ASN.1 tag numbers for universal classes.\"\"\"\n\t    END_OF_CONTENT = 0\n\t    BOOLEAN = 1\n", "    INTEGER = 2\n\t    BIT_STRING = 3\n\t    OCTET_STRING = 4\n\t    NULL = 5\n\t    OBJECT_IDENTIFIER = 6\n\t    OBJECT_DESCRIPTOR = 7\n\t    EXTERNAL = 8\n\t    REAL = 9\n\t    ENUMERATED = 10\n\t    EMBEDDED_PDV = 11\n", "    UTF8_STRING = 12\n\t    RELATIVE_OID = 13\n\t    TIME = 14\n\t    RESERVED = 15\n\t    SEQUENCE = 16\n\t    SEQUENCE_OF = 16\n\t    SET = 17\n\t    SET_OF = 17\n\t    NUMERIC_STRING = 18\n\t    PRINTABLE_STRING = 19\n", "    T61_STRING = 20\n\t    VIDEOTEX_STRING = 21\n\t    IA5_STRING = 22\n\t    UTC_TIME = 23\n\t    GENERALIZED_TIME = 24\n\t    GRAPHIC_STRING = 25\n\t    VISIBLE_STRING = 26\n\t    GENERAL_STRING = 27\n\t    UNIVERSAL_STRING = 28\n\t    CHARACTER_STRING = 29\n", "    BMP_STRING = 30\n\t    DATE = 31\n\t    TIME_OF_DAY = 32\n\t    DATE_TIME = 33\n\t    DURATION = 34\n\t    OID_IRL = 35\n\t    RELATIVE_OID_IRL = 36\n\tclass ASN1Tag(t.NamedTuple):\n\t    \"\"\"ASN.1 tag information.\n\t    Defines the explicit ASN.1 tag used in a value which includes the tag class,\n", "    tag number, and whether it is a constructed or primitive value.\n\t    Args:\n\t        tag_class: The tag class the value represents.\n\t        tag_number: The tag number of the value.\n\t        is_constructed: Whether the value is constructed (True) or primitive\n\t            (False).\n\t    \"\"\"\n\t    tag_class: TagClass\n\t    \"The tag class.\"\n\t    tag_number: t.Union[int, TypeTagNumber]\n", "    \"The tag number, will be TypeTagNumber if the tag_class is UNIVERSAL.\"\n\t    is_constructed: bool\n\t    \"Whether the value is marked as constructed or primitive.\"\n\t    @classmethod\n\t    def universal_tag(\n\t        cls,\n\t        number: TypeTagNumber,\n\t        is_constructed: bool = False,\n\t    ) -> ASN1Tag:\n\t        \"\"\"Generates a universal tag with the type specified.\"\"\"\n", "        return ASN1Tag(\n\t            tag_class=TagClass.UNIVERSAL,\n\t            tag_number=number,\n\t            is_constructed=is_constructed,\n\t        )\n\tclass ASN1Header(t.NamedTuple):\n\t    \"\"\"A representation of an ASN.1 TLV as a tuple.\n\t    Defines the ASN.1 Type Length Value (TLV) values as separate objects for\n\t    easier parsing. This is returned by :func:`ASN1Reader.peek_header`.\n\t    Args:\n", "        tag: The tag details, including the class and tag number.\n\t        tag_length: The length of the encoded tag.\n\t        length: The length of the value the tag represents.\n\t    \"\"\"\n\t    tag: ASN1Tag\n\t    \"The ASN.1 tag details for the current entry.\"\n\t    tag_length: int\n\t    \"The length of the tag/length ASN.1 octets.\"\n\t    length: int\n\t    \"The length of the ASN.1 value.\"\n", "class ASN1Reader:\n\t    \"\"\"ASN.1 value reader.\n\t    Class used to read ASN.1 data that is passed in. It provides a an easy way\n\t    to stream through the data as well as peek as the subsequent entries.\n\t    Args:\n\t        data: The data to read from.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        data: t.Union[bytes, bytearray, memoryview],\n", "    ) -> None:\n\t        self._data = data\n\t        self._view = memoryview(self._data)\n\t    def __bool__(self) -> bool:\n\t        return bool(self._view)\n\t    def peek_header(self) -> ASN1Header:\n\t        \"\"\"Get the next value header.\n\t        Gets the header for the next value. This will not read the value so it\n\t        will still be at the same position once run.\n\t        Returns:\n", "            ASN1Header: The header information including the tag information as\n\t            well as the length of the next value.\n\t        \"\"\"\n\t        return _read_asn1_header(self._view)\n\t    def skip_value(\n\t        self,\n\t        header: ASN1Header,\n\t    ) -> None:\n\t        \"\"\"Skips the next value.\n\t        Skips the next value as indicated by the header.\n", "        Args:\n\t            header: The header which contains the metadata of the next value to\n\t                skip.\n\t        \"\"\"\n\t        self._view = self._view[header.tag_length + header.length :]\n\t    def get_remaining_data(self) -> bytes:\n\t        \"\"\"Gets the remaining data in the reader.\"\"\"\n\t        data = self._view.tobytes()\n\t        self._view = memoryview(b\"\")\n\t        return data\n", "    def read_boolean(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n\t        hint: t.Optional[str] = None,\n\t    ) -> bool:\n\t        \"\"\"Reads an ASN.1 BOOLEAN value.\n\t        Args:\n\t            tag: The tag to validate with, defaults to the BOOLEAN universal\n\t                tag.\n", "            header: Optional header from :func:`peek_header` to make the\n\t                extraction more efficient.\n\t            hint: A hint used in error messages to display what this step was\n\t                used for.\n\t        Returns:\n\t            bool: The bool value.\n\t        \"\"\"\n\t        val, consumed = _read_asn1_boolean(\n\t            self._view,\n\t            tag=tag,\n", "            header=header,\n\t            hint=hint,\n\t        )\n\t        self._view = self._view[consumed:]\n\t        return val\n\t    def read_enumerated(\n\t        self,\n\t        enum_type: t.Type[T],\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n", "        hint: t.Optional[str] = None,\n\t    ) -> T:\n\t        \"\"\"Reads an ASN.1 ENUMERATED value.\n\t        Args:\n\t            enum_type: The enum.IntEnum type to cast the integer value to.\n\t            tag: The tag to validate with, defaults to the ENUMERATED universal\n\t                tag.\n\t            header: Optional header from :func:`peek_header` to make the\n\t                extraction more efficient.\n\t            hint: A hint used in error messages to display what this step was\n", "                used for.\n\t        Returns:\n\t            T: The instance of enum_type that the value represents.\n\t        \"\"\"\n\t        val, consumed = _read_asn1_enumerated(\n\t            self._view,\n\t            tag=tag,\n\t            header=header,\n\t            hint=hint,\n\t        )\n", "        self._view = self._view[consumed:]\n\t        return enum_type(val)\n\t    def read_generalized_time(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n\t        hint: t.Optional[str] = None,\n\t    ) -> str:\n\t        val, consumed = _read_asn1_generalized_time(\n\t            self._view,\n", "            tag=tag,\n\t            header=header,\n\t            hint=hint,\n\t        )\n\t        self._view = self._view[consumed:]\n\t        return val\n\t    def read_integer(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n", "        hint: t.Optional[str] = None,\n\t    ) -> int:\n\t        \"\"\"Reads an ASN.1 INTEGER value.\n\t        Args:\n\t            tag: The tag to validate with, defaults to the INTEGER universal\n\t                tag.\n\t            header: Optional header from :func:`peek_header` to make the\n\t                extraction more efficient.\n\t            hint: A hint used in error messages to display what this step was\n\t                used for.\n", "        Returns:\n\t            int: The int value.\n\t        \"\"\"\n\t        val, consumed = _read_asn1_integer(\n\t            self._view,\n\t            tag=tag,\n\t            header=header,\n\t            hint=hint,\n\t        )\n\t        self._view = self._view[consumed:]\n", "        return val\n\t    def read_object_identifier(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n\t        hint: t.Optional[str] = None,\n\t    ) -> str:\n\t        val, consumed = _read_asn1_object_identifier(\n\t            self._view,\n\t            tag=tag,\n", "            header=header,\n\t            hint=hint,\n\t        )\n\t        self._view = self._view[consumed:]\n\t        return val\n\t    def read_octet_string(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n\t        hint: t.Optional[str] = None,\n", "    ) -> bytes:\n\t        \"\"\"Reads an ASN.1 OCTET_STRING value.\n\t        As this returns a bytes string, it is useful to extract the raw ASN.1\n\t        value as long as the correct tag or header is provided.\n\t        Args:\n\t            tag: The tag to validate with, defaults to the OCTET_STRING\n\t                universal tag (primitive).\n\t            header: Optional header from :func:`peek_header` to make the\n\t                extraction more efficient.\n\t            hint: A hint used in error messages to display what this step was\n", "                used for.\n\t        Returns:\n\t            bytes: The octet string bytes.\n\t        \"\"\"\n\t        val, consumed = _read_asn1_octet_string(\n\t            self._view,\n\t            tag=tag,\n\t            header=header,\n\t            hint=hint,\n\t        )\n", "        self._view = self._view[consumed:]\n\t        return val.tobytes()\n\t    def read_set(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n\t        hint: t.Optional[str] = None,\n\t    ) -> ASN1Reader:\n\t        \"\"\"Reads an ASN.1 SET or SET_OF value.\n\t        The returned reader can be used to then read the values inside the set.\n", "        Args:\n\t            tag: The tag to validate with, defaults to the SET/SET_OF universal\n\t                tag.\n\t            header: Optional header from :func:`peek_header` to make the\n\t                extraction more efficient.\n\t            hint: A hint used in error messages to display what this step was\n\t                used for.\n\t        Returns:\n\t            ASN1Reader: The ASN.1 reader object that can be used to read the\n\t                set elements.\n", "        \"\"\"\n\t        new_view, consumed = _read_asn1_set(\n\t            self._view,\n\t            tag=tag,\n\t            header=header,\n\t            hint=hint,\n\t        )\n\t        self._view = self._view[consumed:]\n\t        return ASN1Reader(new_view)\n\t    read_set_of = read_set\n", "    def read_sequence(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n\t        hint: t.Optional[str] = None,\n\t    ) -> ASN1Reader:\n\t        \"\"\"Reads an ASN.1 SEQUENCE or SEQUENCE_OF value.\n\t        The returned reader can be used to then read the values inside the\n\t        sequence.\n\t        Args:\n", "            tag: The tag to validate with, defaults to the SEQUENCE/SEQUENCE_OF\n\t                universal tag.\n\t            header: Optional header from :func:`peek_header` to make the\n\t                extraction more efficient.\n\t            hint: A hint used in error messages to display what this step was\n\t                used for.\n\t        Returns:\n\t            ASN1Reader: The ASN.1 reader object that can be used to read the\n\t                sequence elements.\n\t        \"\"\"\n", "        new_view, consumed = _read_asn1_sequence(\n\t            self._view,\n\t            tag=tag,\n\t            header=header,\n\t            hint=hint,\n\t        )\n\t        self._view = self._view[consumed:]\n\t        return ASN1Reader(new_view)\n\t    read_sequence_of = read_sequence\n\t    def read_utf8_string(\n", "        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        header: t.Optional[ASN1Header] = None,\n\t        hint: t.Optional[str] = None,\n\t    ) -> str:\n\t        val, consumed = _read_asn1_utf8_string(\n\t            self._view,\n\t            tag=tag,\n\t            header=header,\n\t            hint=hint,\n", "        )\n\t        self._view = self._view[consumed:]\n\t        return val\n\tclass ASN1Writer:\n\t    \"\"\"ASN.1 value writer.\n\t    Class used to write ASN.1 data into an internal buffer. This data can then\n\t    be retrieved using :func:`get_data`. It provides a nice helper to easily\n\t    accumulate multiple values in one object.\n\t    Args:\n\t        tag: Optional tag to used when in a sequence/set writer.\n", "        parent: The parent writer used when in a sequence/set writer.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        *,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t        parent: t.Optional[ASN1Writer] = None,\n\t    ) -> None:\n\t        self._data = bytearray()\n\t        self._tag = tag\n", "        self._parent = parent\n\t    def __enter__(self) -> ASN1Writer:\n\t        return self\n\t    def __exit__(\n\t        self,\n\t        exc_type: t.Optional[t.Type[BaseException]] = None,\n\t        exc_val: t.Optional[BaseException] = None,\n\t        exc_tb: t.Optional[TracebackType] = None,\n\t    ) -> None:\n\t        if not self._parent or not self._tag:\n", "            return\n\t        data = _pack_asn1(\n\t            self._tag.tag_class,\n\t            self._tag.is_constructed,\n\t            self._tag.tag_number,\n\t            self._data,\n\t        )\n\t        self._parent._data.extend(data)\n\t    def push_sequence(\n\t        self,\n", "        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> ASN1Writer:\n\t        \"\"\"Get new writer for a SEQUENCE or SEQUENCE_OF value.\n\t        Gets a new writer to start writing values inside a sequence or sequence\n\t        of object. Make sure to wrap the writer in a with statement to ensure\n\t        the sequence is closed and written back to the parent writer.\n\t        Examples:\n\t            .. code-block:: python\n\t                with writer.push_sequence() as seq_writer:\n\t                    seq_writer.write_octet_string(b\"foo\")\n", "        Args:\n\t            tag: Optional tag to mark the sequence/sequence_of with.\n\t        Returns:\n\t            ASN1Writer: The writer object that can be used to write the\n\t            sequence elements.\n\t        \"\"\"\n\t        if not tag:\n\t            tag = ASN1Tag.universal_tag(TypeTagNumber.SEQUENCE, is_constructed=True)\n\t        return ASN1Writer(tag=tag, parent=self)\n\t    push_sequence_of = push_sequence\n", "    def push_set(\n\t        self,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> ASN1Writer:\n\t        \"\"\"Get new writer for a SET or SET_OF value.\n\t        Gets a new writer to start writing values inside a set or set of\n\t        object. Make sure to wrap the writer in a with statement to ensure\n\t        the sequence is closed and written back to the parent writer.\n\t        Examples:\n\t            .. code-block:: python\n", "                with writer.push_set() as seq_writer:\n\t                    seq_writer.write_octet_string(b\"foo\")\n\t        Args:\n\t            tag: Optional tag to mark the sequence/sequence_of with.\n\t        Returns:\n\t            ASN1Writer: The writer object that can be used to write the\n\t            set elements.\n\t        \"\"\"\n\t        if not tag:\n\t            tag = ASN1Tag.universal_tag(TypeTagNumber.SET, is_constructed=True)\n", "        return ASN1Writer(tag=tag, parent=self)\n\t    push_set_of = push_set\n\t    def write_boolean(\n\t        self,\n\t        value: bool,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> None:\n\t        \"\"\"Write an ASN.1 BOOLEAN value.\n\t        Writes a boolean value to the current writer.\n\t        Args:\n", "            value: The bool to write.\n\t            tag: Optional tag to use with the value, defaults to the BOOLEAN\n\t                universal tag.\n\t        \"\"\"\n\t        self._data.extend(_pack_asn1_boolean(value, tag=tag))\n\t    def write_enumerated(\n\t        self,\n\t        value: int,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> None:\n", "        \"\"\"Write an ASN.1 ENUMERATED value.\n\t        Writes a enumerated value to the current writer.\n\t        Args:\n\t            value: The enumerated/int to write.\n\t            tag: Optional tag to use with the value, defaults to the ENUMERATED\n\t                universal tag.\n\t        \"\"\"\n\t        self._data.extend(_pack_asn1_enumerated(value, tag=tag))\n\t    def write_generalized_time(\n\t        self,\n", "        value: str,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> None:\n\t        \"\"\"Write an ASN.1 GENERALIZED_TIME value.\n\t        Writes a generalized time string to the current writer.\n\t        Args:\n\t            value: The generalized time to write.\n\t            tag: Optional tag to use with the value, defaults to the\n\t                GENERALIZED_TIME universal tag.\n\t        \"\"\"\n", "        self._data.extend(_pack_asn1_generalized_time(value, tag=tag))\n\t    def write_integer(\n\t        self,\n\t        value: int,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> None:\n\t        \"\"\"Write an ASN.1 INTEGER value.\n\t        Writes an int value to the current writer.\n\t        Args:\n\t            value: The int to write.\n", "            tag: Optional tag to use with the value, defaults to the INTEGER\n\t                universal tag.\n\t        \"\"\"\n\t        self._data.extend(_pack_asn1_integer(value, tag=tag))\n\t    def write_octet_string(\n\t        self,\n\t        value: bytes,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> None:\n\t        \"\"\"Write an ASN.1 OCTET_STRING value.\n", "        Writes a bytes string value to the current writer.\n\t        Args:\n\t            value: The bytes to write.\n\t            tag: Optional tag to use with the value, defaults to the\n\t                OCTET_STRING universal tag.\n\t        \"\"\"\n\t        self._data.extend(_pack_asn1_octet_string(value, tag=tag))\n\t    def write_object_identifier(\n\t        self,\n\t        value: str,\n", "        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> None:\n\t        \"\"\"Write an ASN.1 OBJECT_IDENTIFIER value.\n\t        Writes a bytes string value to the current writer.\n\t        Args:\n\t            value: The object identifier (string representation) to write.\n\t            tag: Optional tag to use with the value, defaults to the\n\t                OBJECT_IDENTIFIER universal tag.\n\t        \"\"\"\n\t        self._data.extend(_pack_asn1_object_identifier(value, tag=tag))\n", "    def write_utf8_string(\n\t        self,\n\t        value: str,\n\t        tag: t.Optional[ASN1Tag] = None,\n\t    ) -> None:\n\t        \"\"\"Write an ASN.1 UTF8_STRING value.\n\t        Writes a UTF-8 string value to the current writer.\n\t        Args:\n\t            value: The string to write.\n\t            tag: Optional tag to use with the value, defaults to the\n", "                UTF8_STRING universal tag.\n\t        \"\"\"\n\t        self._data.extend(_pack_asn1_utf8_string(value, tag=tag))\n\t    def write_raw(\n\t        self,\n\t        value: bytes,\n\t    ) -> None:\n\t        \"\"\"Appends raw values onto the ASN1 writer.\"\"\"\n\t        self._data.extend(value)\n\t    def get_data(self) -> bytearray:\n", "        \"\"\"Gets the data written to the writer.\n\t        This is used to get the final ASN.1 value after all the values have\n\t        been written to it. It cannot be called on a child writer returned by\n\t        push_sequence or push_set.\n\t        Returns:\n\t            bytearray: The data that has been written.\n\t        \"\"\"\n\t        if self._parent or self._tag:\n\t            raise TypeError(\"Cannot get_data() on child ASN1 writer\")\n\t        return self._data\n", "def _pack_asn1(\n\t    tag_class: TagClass,\n\t    constructed: bool,\n\t    tag_number: t.Union[TypeTagNumber, int],\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t) -> bytes:\n\t    \"\"\"Pack the ASN.1 value into the ASN.1 bytes.\n\t    Will pack the raw bytes into an ASN.1 Type Length Value (TLV) value. A TLV\n\t    is in the form:\n\t    | Identifier Octet(s) | Length Octet(s) | Data Octet(s) |\n", "    Args:\n\t        tag_class: The tag class of the data.\n\t        constructed: Whether the data is constructed (True), i.e. contains 0,\n\t            1, or more element encodings, or is primitive (False).\n\t        tag_number: The type tag number if tag_class is universal else the\n\t            explicit tag number of the TLV.\n\t        b_data: The encoded value to pack into the ASN.1 TLV.\n\t    Returns:\n\t        bytes: The ASN.1 value as raw bytes.\n\t    \"\"\"\n", "    b_asn1_data = bytearray()\n\t    # ASN.1 Identifier octet is\n\t    #\n\t    # |             Octet 1             |  |              Octet 2              |\n\t    # | 8 | 7 |  6  | 5 | 4 | 3 | 2 | 1 |  |   8   | 7 | 6 | 5 | 4 | 3 | 2 | 1 |\n\t    # | Class | P/C | Tag Number (0-30) |  | More  | Tag number                |\n\t    #\n\t    # If Tag Number is >= 31 the first 5 bits are 1 and the 2nd octet is used\n\t    # to encode the length.\n\t    if tag_class < 0 or tag_class > 3:\n", "        raise ValueError(\"tag_class must be between 0 and 3\")\n\t    identifier_octets = tag_class << 6\n\t    identifier_octets |= (1 if constructed else 0) << 5\n\t    if tag_number < 31:\n\t        identifier_octets |= tag_number\n\t        b_asn1_data.append(identifier_octets)\n\t    else:\n\t        # Set the first 5 bits of the first octet to 1 and encode the tag\n\t        # number in subsequent octets.\n\t        identifier_octets |= 31\n", "        b_asn1_data.append(identifier_octets)\n\t        b_asn1_data.extend(_pack_asn1_octet_number(tag_number))\n\t    # ASN.1 Length octet for DER encoding is always in the definite form. This\n\t    # form packs the lengths in the following octet structure:\n\t    #\n\t    # |                       Octet 1                       |  |            Octet n            |\n\t    # |     8     |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |\n\t    # | Long form | Short = length, Long = num octets       |  | Big endian length for long    |\n\t    #\n\t    # Basically if the length < 127 it's encoded in the first octet, otherwise\n", "    # the first octet 7 bits indicates how many subsequent octets were used to\n\t    # encode the length.\n\t    length = len(data)\n\t    if length < 128:\n\t        b_asn1_data.append(length)\n\t    else:\n\t        length_octets = bytearray()\n\t        while length:\n\t            length_octets.append(length & 0b11111111)\n\t            length >>= 8\n", "        # Reverse the octets so the higher octets are first, add the initial\n\t        # length octet with the MSB set and add them all to the main ASN.1 byte\n\t        # array.\n\t        length_octets.reverse()\n\t        b_asn1_data.append(len(length_octets) | 0b10000000)\n\t        b_asn1_data.extend(length_octets)\n\t    return bytes(b_asn1_data) + bytes(data)\n\tdef _pack_asn1_boolean(\n\t    value: bool,\n\t    tag: t.Optional[ASN1Tag] = None,\n", ") -> bytes:\n\t    \"\"\"Packs an int into an ASN.1 BOOLEAN byte value with optional universal tagging.\"\"\"\n\t    if not tag:\n\t        tag = ASN1Tag.universal_tag(TypeTagNumber.BOOLEAN)\n\t    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, b\"\\xFF\" if value else b\"\\x00\")\n\tdef _pack_asn1_enumerated(\n\t    value: int,\n\t    tag: t.Optional[ASN1Tag] = None,\n\t) -> bytes:\n\t    \"\"\"Packs an int into an ASN.1 ENUMERATED byte value with optional universal tagging.\"\"\"\n", "    return _pack_asn1_integer(value, tag=tag or ASN1Tag.universal_tag(TypeTagNumber.ENUMERATED))\n\tdef _pack_asn1_generalized_time(\n\t    value: str,\n\t    tag: t.Optional[ASN1Tag] = None,\n\t) -> bytes:\n\t    \"\"\"Packs an int into an ASN.1 GENERALIZED_TIME byte value with optional universal tagging.\"\"\"\n\t    if not tag:\n\t        tag = ASN1Tag.universal_tag(TypeTagNumber.GENERALIZED_TIME)\n\t    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, value.encode(\"utf-8\"))\n\tdef _pack_asn1_integer(\n", "    value: int,\n\t    tag: t.Optional[ASN1Tag] = None,\n\t) -> bytes:\n\t    \"\"\"Packs an int value into an ASN.1 INTEGER byte value with optional universal tagging.\"\"\"\n\t    if not tag:\n\t        tag = ASN1Tag.universal_tag(TypeTagNumber.INTEGER)\n\t    # Thanks to https://github.com/andrivet/python-asn1 for help with the negative value logic.\n\t    is_negative = False\n\t    limit = 0x7F\n\t    if value < 0:\n", "        value = -value\n\t        is_negative = True\n\t        limit = 0x80\n\t    b_int = bytearray()\n\t    while value > limit:\n\t        val = value & 0xFF\n\t        if is_negative:\n\t            val = 0xFF - val\n\t        b_int.append(val)\n\t        value >>= 8\n", "    b_int.append(((0xFF - value) if is_negative else value) & 0xFF)\n\t    if is_negative:\n\t        # The nocover is here because it's reporting no coverage for the no\n\t        # enumerate branch. We don't care about that.\n\t        for idx, val in enumerate(b_int):  # pragma: nocover\n\t            if val < 0xFF:\n\t                b_int[idx] += 1\n\t                break\n\t            b_int[idx] = 0\n\t    if is_negative and b_int[-1] == 0x7F:  # Two's complement corner case\n", "        b_int.append(0xFF)\n\t    b_int.reverse()\n\t    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, b_int)\n\tdef _pack_asn1_octet_string(\n\t    b_data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n\t) -> bytes:\n\t    \"\"\"Packs an bytes value into an ASN.1 OCTET STRING byte value with optional universal tagging.\"\"\"\n\t    if not tag:\n\t        tag = ASN1Tag.universal_tag(TypeTagNumber.OCTET_STRING)\n", "    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, b_data)\n\tdef _pack_asn1_object_identifier(\n\t    value: str,\n\t    tag: t.Optional[ASN1Tag] = None,\n\t) -> bytes:\n\t    \"\"\"Packs an object identifier value represented as string into an\n\t    ASN.1 OBJECT IDENTIFIER value with optional universal tagging.\"\"\"\n\t    if not tag:\n\t        tag = ASN1Tag.universal_tag(TypeTagNumber.OBJECT_IDENTIFIER)\n\t    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, _encode_object_identifier(value))\n", "def _pack_asn1_utf8_string(\n\t    value: str,\n\t    tag: t.Optional[ASN1Tag] = None,\n\t) -> bytes:\n\t    \"\"\"Packs an object identifier value represented as string into an\n\t    ASN.1 UTF8 STRING byte value with optional universal tagging.\"\"\"\n\t    if not tag:\n\t        tag = ASN1Tag.universal_tag(TypeTagNumber.UTF8_STRING)\n\t    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, value.encode(\"utf-8\"))\n\tdef _encode_object_identifier(oid: str) -> bytes:\n", "    \"\"\"Encode an object identifier.\"\"\"\n\t    cmps = list(map(int, oid.split(\".\")))\n\t    if cmps[0] > 39 or cmps[1] > 39:\n\t        raise ValueError(\"Illegal object identifier\")\n\t    cmps = [40 * cmps[0] + cmps[1]] + cmps[2:]\n\t    cmps.reverse()\n\t    result = []\n\t    for cmp_data in cmps:\n\t        result.append(cmp_data & 0x7F)\n\t        while cmp_data > 0x7F:\n", "            cmp_data >>= 7\n\t            result.append(0x80 | (cmp_data & 0x7F))\n\t    result.reverse()\n\t    return bytes(result)\n\tdef _read_asn1_header(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t) -> ASN1Header:\n\t    \"\"\"Reads the ASN.1 Tag and Length octets\n\t    Reads the raw ASN.1 value to retrieve the tag and length values.\n\t    Args:\n", "      data: The raw bytes to read.\n\t    Returns:\n\t        ASN1Value: A tuple containing the tag and length information.\n\t    \"\"\"\n\t    view = memoryview(data)\n\t    if not view:\n\t        raise NotEnougData()\n\t    octet1 = struct.unpack(\"B\", view[:1])[0]\n\t    tag_class = TagClass((octet1 & 0b11000000) >> 6)\n\t    constructed = bool(octet1 & 0b00100000)\n", "    tag_number = octet1 & 0b00011111\n\t    tag_octets = 1\n\t    if tag_number == 31:\n\t        tag_number, octet_count = _unpack_asn1_octet_number(view[1:])\n\t        tag_octets += octet_count\n\t    if tag_class == TagClass.UNIVERSAL:\n\t        tag_number = TypeTagNumber(tag_number)\n\t    view = view[tag_octets:]\n\t    if not view:\n\t        raise NotEnougData()\n", "    length = struct.unpack(\"B\", view[:1])[0]\n\t    length_octets = 1\n\t    if length == 0b10000000:\n\t        # Indefinite length, the length is not known and will be marked by two\n\t        # NULL octets known as end-of-content octets later in the stream. It is\n\t        # not meant to be sent in LDAP so fail here.\n\t        # https://www.rfc-editor.org/rfc/rfc4511#section-5.1\n\t        raise ValueError(\"Received BER indefinite encoded value which is unsupported by LDAP messages\")\n\t    elif length & 0b10000000:\n\t        # If the MSB is set then the length octet just contains the number of\n", "        # octets that encodes the actual length.\n\t        length_octets += length & 0b01111111\n\t        length = 0\n\t        for idx in range(1, length_octets):\n\t            if len(view) < (idx + 1):\n\t                raise NotEnougData()\n\t            octet_val = struct.unpack(\"B\", view[idx : idx + 1])[0]\n\t            length += octet_val << (8 * (length_octets - 1 - idx))\n\t    return ASN1Header(\n\t        tag=ASN1Tag(\n", "            tag_class=tag_class,\n\t            tag_number=tag_number,\n\t            is_constructed=constructed,\n\t        ),\n\t        tag_length=tag_octets + length_octets,\n\t        length=length,\n\t    )\n\tdef _read_asn1_boolean(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n", "    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[bool, int]:\n\t    \"\"\"Unpacks an ASN.1 BOOLEAN value.\"\"\"\n\t    raw_bool, consumed = _validate_tag(\n\t        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.BOOLEAN, False),\n\t        header=header,\n\t        hint=hint,\n", "    )\n\t    return raw_bool.tobytes().replace(b\"\\x00\", b\"\") != b\"\", consumed\n\tdef _read_asn1_enumerated(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n\t    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[int, int]:\n\t    \"\"\"Unpacks an ASN.1 ENUMERATED value.\"\"\"\n\t    if not tag:\n", "        tag = header.tag if header else ASN1Tag.universal_tag(TypeTagNumber.ENUMERATED, False)\n\t    return _read_asn1_integer(data, tag, header=header, hint=hint)\n\tdef _read_asn1_generalized_time(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n\t    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[str, int]:\n\t    \"\"\"Unpacks an ASN.1 GENERALIZED_TIME value.\"\"\"\n\t    raw_time, consumed = _validate_tag(\n", "        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.GENERALIZED_TIME, False),\n\t        header=header,\n\t        hint=hint,\n\t    )\n\t    return raw_time.tobytes().decode(\"utf-8\"), consumed\n\tdef _read_asn1_integer(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n", "    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[int, int]:\n\t    \"\"\"Unpacks an ASN.1 INTEGER value.\"\"\"\n\t    raw_int, consumed = _validate_tag(\n\t        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.INTEGER, False),\n\t        header=header,\n\t        hint=hint,\n", "    )\n\t    b_int = bytearray(raw_int)\n\t    is_negative = b_int[0] & 0b10000000\n\t    if is_negative:\n\t        # Get the two's compliment.\n\t        for i in range(len(b_int)):\n\t            b_int[i] = 0xFF - b_int[i]\n\t        # Coverage is skipped because branch will not occur with no loop\n\t        for i in range(len(b_int) - 1, -1, -1):  # pragma: nocover\n\t            if b_int[i] == 0xFF:\n", "                b_int[i - 1] += 1\n\t                b_int[i] = 0\n\t                break\n\t            else:\n\t                b_int[i] += 1\n\t                break\n\t    int_value = 0\n\t    for val in b_int:\n\t        int_value = (int_value << 8) | val\n\t    if is_negative:\n", "        int_value *= -1\n\t    return int_value, consumed\n\tdef _read_asn1_object_identifier(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n\t    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[str, int]:\n\t    \"\"\"Unpacks an ASN.1 OBJECT_IDENTIFIER value.\"\"\"\n\t    raw_oid, consumed = _validate_tag(\n", "        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.OBJECT_IDENTIFIER, False),\n\t        header=header,\n\t        hint=hint,\n\t    )\n\t    first_element = struct.unpack(\"B\", raw_oid[:1])[0]\n\t    second_element = first_element % 40\n\t    ids = [(first_element - second_element) // 40, second_element]\n\t    idx = 1\n", "    while idx != len(raw_oid):\n\t        oid, octet_len = _unpack_asn1_octet_number(raw_oid[idx:])\n\t        ids.append(oid)\n\t        idx += octet_len\n\t    return \".\".join([str(i) for i in ids]), consumed\n\tdef _read_asn1_octet_string(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n\t    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n", ") -> t.Tuple[memoryview, int]:\n\t    \"\"\"Unpacks an ASN.1 OCTET_STRING value.\"\"\"\n\t    return _validate_tag(\n\t        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.OCTET_STRING, False),\n\t        header=header,\n\t        hint=hint,\n\t    )\n\tdef _read_asn1_sequence(\n", "    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n\t    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[memoryview, int]:\n\t    \"\"\"Unpacks an ASN.1 SEQUENCE value.\"\"\"\n\t    return _validate_tag(\n\t        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.SEQUENCE, True),\n", "        header=header,\n\t        hint=hint,\n\t    )\n\tdef _read_asn1_set(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n\t    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[memoryview, int]:\n\t    \"\"\"Unpacks an ASN.1 SET value.\"\"\"\n", "    return _validate_tag(\n\t        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.SET, True),\n\t        header=header,\n\t        hint=hint,\n\t    )\n\tdef _read_asn1_utf8_string(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    tag: t.Optional[ASN1Tag] = None,\n", "    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[str, int]:\n\t    \"\"\"Unpacks an ASN.1 UTF8_STRING value.\"\"\"\n\t    raw_str, consumed = _validate_tag(\n\t        data,\n\t        tag,\n\t        ASN1Tag.universal_tag(TypeTagNumber.UTF8_STRING, False),\n\t        header=header,\n\t        hint=hint,\n", "    )\n\t    return raw_str.tobytes().decode(\"utf-8\"), consumed\n\tdef _validate_tag(\n\t    data: t.Union[bytes, bytearray, memoryview],\n\t    expected_tag: t.Optional[ASN1Tag],\n\t    type_tag: ASN1Tag,\n\t    header: t.Optional[ASN1Header] = None,\n\t    hint: t.Optional[str] = None,\n\t) -> t.Tuple[memoryview, int]:\n\t    view = memoryview(data)\n", "    if header:\n\t        actual_tag, tag_length, data_length = header\n\t    else:\n\t        actual_tag, tag_length, data_length = _read_asn1_header(view)\n\t    hint_str = f\" for {hint}\" if hint else \"\"\n\t    if not expected_tag:\n\t        expected_tag = header.tag if header else type_tag\n\t    if actual_tag != expected_tag:\n\t        raise ValueError(f\"Expected tag {expected_tag}{hint_str} but got {actual_tag}\")\n\t    view = view[tag_length:]\n", "    if len(view) < data_length:\n\t        raise NotEnougData(f\"Not enough data{hint_str}: expecting {data_length} but got {len(view)}\")\n\t    return view[:data_length], tag_length + data_length\n\tdef _unpack_asn1_octet_number(\n\t    data: memoryview,\n\t) -> t.Tuple[int, int]:\n\t    \"\"\"Unpacks an ASN.1 INTEGER value that can span across multiple octets.\"\"\"\n\t    i = 0\n\t    idx = 0\n\t    while True:\n", "        if len(data) < (idx + 1):\n\t            raise NotEnougData()\n\t        element = struct.unpack(\"B\", data[idx : idx + 1])[0]\n\t        idx += 1\n\t        i = (i << 7) + (element & 0b01111111)\n\t        if not element & 0b10000000:\n\t            break\n\t    return i, idx  # int value and the number of octets used.\n\tdef _pack_asn1_octet_number(\n\t    num: int,\n", ") -> bytes:\n\t    \"\"\"Packs an int number into an ASN.1 integer value that spans multiple octets.\"\"\"\n\t    num_octets = bytearray()\n\t    while num:\n\t        # Get the 7 bit value of the number.\n\t        octet_value = num & 0b01111111\n\t        # Set the MSB if this isn't the first octet we are processing (overall last octet)\n\t        if len(num_octets):\n\t            octet_value |= 0b10000000\n\t        num_octets.append(octet_value)\n", "        # Shift the number by 7 bits as we've just processed them.\n\t        num >>= 7\n\t    # Finally we reverse the order so the higher octets are first.\n\t    num_octets.reverse()\n\t    return num_octets\n\t__all__ = [\n\t    \"ASN1Reader\",\n\t    \"ASN1Writer\",\n\t    \"ASN1Header\",\n\t    \"ASN1Tag\",\n", "    \"NotEnougData\",\n\t    \"TagClass\",\n\t    \"TypeTagNumber\",\n\t]\n"]}
{"filename": "src/dpapi_ng/_security_descriptor.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport re\n\timport typing as t\n\tdef sid_to_bytes(sid: str) -> bytes:\n\t    sid_pattern = re.compile(r\"^S-(\\d)-(\\d+)(?:-\\d+){1,15}$\")\n\t    sid_match = sid_pattern.match(sid)\n\t    if not sid_match:\n\t        raise ValueError(f\"Input string '{sid}' is not a valid SID string\")\n", "    sid_split = sid.split(\"-\")\n\t    revision = int(sid_split[1])\n\t    authority = int(sid_split[2])\n\t    data = bytearray(authority.to_bytes(8, byteorder=\"big\"))\n\t    data[0] = revision\n\t    data[1] = len(sid_split) - 3\n\t    for idx in range(3, len(sid_split)):\n\t        sub_auth = int(sid_split[idx])\n\t        data += sub_auth.to_bytes(4, byteorder=\"little\")\n\t    return bytes(data)\n", "def ace_to_bytes(sid: str, access_mask: int) -> bytes:\n\t    b_sid = sid_to_bytes(sid)\n\t    return b\"\".join(\n\t        [\n\t            b\"\\x00\\x00\",  # AceType, AceFlags - ACCESS_ALLOWED_ACE_TYPE\n\t            (8 + len(b_sid)).to_bytes(2, byteorder=\"little\"),\n\t            access_mask.to_bytes(4, byteorder=\"little\"),\n\t            b_sid,\n\t        ]\n\t    )\n", "def acl_to_bytes(aces: t.List[bytes]) -> bytes:\n\t    ace_data = b\"\".join(aces)\n\t    return b\"\".join(\n\t        [\n\t            b\"\\x02\\x00\",  # AclRevision, Sbz1 - ACL_REVISION\n\t            (8 + len(ace_data)).to_bytes(2, byteorder=\"little\"),\n\t            len(aces).to_bytes(2, byteorder=\"little\"),\n\t            b\"\\x00\\x00\",  # Sbz1\n\t            ace_data,\n\t        ]\n", "    )\n\tdef sd_to_bytes(\n\t    owner: str,\n\t    group: str,\n\t    sacl: t.Optional[t.List[bytes]] = None,\n\t    dacl: t.Optional[t.List[bytes]] = None,\n\t) -> bytes:\n\t    control = 0b10000000 << 8  # Self-Relative\n\t    # While MS-DTYP state there is no required order for the dynamic data, it\n\t    # is important that the raw bytes are exactly what Microsoft uses on the\n", "    # server side when it computes the seed key values. Luckily the footnote\n\t    # give the correct order the MS-GKDI expects: Sacl, Dacl, Owner, Group\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/11e1608c-6169-4fbc-9c33-373fc9b224f4#Appendix_A_72\n\t    dynamic_data = bytearray()\n\t    current_offset = 20  # Length of the SD header bytes\n\t    sacl_offset = 0\n\t    if sacl:\n\t        sacl_bytes = acl_to_bytes(sacl)\n\t        sacl_offset = current_offset\n\t        current_offset += len(sacl_bytes)\n", "        control |= 0b00010000  # SACL Present\n\t        dynamic_data += sacl_bytes\n\t    dacl_offset = 0\n\t    if dacl:\n\t        dacl_bytes = acl_to_bytes(dacl)\n\t        dacl_offset = current_offset\n\t        current_offset += len(dacl_bytes)\n\t        control |= 0b00000100  # DACL Present\n\t        dynamic_data += dacl_bytes\n\t    owner_bytes = sid_to_bytes(owner)\n", "    owner_offset = current_offset\n\t    current_offset += len(owner_bytes)\n\t    dynamic_data += owner_bytes\n\t    group_bytes = sid_to_bytes(group)\n\t    group_offset = current_offset\n\t    dynamic_data += group_bytes\n\t    return b\"\".join(\n\t        [\n\t            b\"\\x01\\x00\",  # Revision and Sbz1\n\t            control.to_bytes(2, byteorder=\"little\"),\n", "            owner_offset.to_bytes(4, byteorder=\"little\"),\n\t            group_offset.to_bytes(4, byteorder=\"little\"),\n\t            sacl_offset.to_bytes(4, byteorder=\"little\"),\n\t            dacl_offset.to_bytes(4, byteorder=\"little\"),\n\t            dynamic_data,\n\t        ]\n\t    )\n"]}
{"filename": "src/dpapi_ng/_crypto.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport enum\n\timport os\n\timport typing as t\n\tfrom cryptography.hazmat.primitives import hashes, keywrap\n\tfrom cryptography.hazmat.primitives.asymmetric import ec\n\tfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\n\tfrom cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash\n", "from cryptography.hazmat.primitives.kdf.kbkdf import KBKDFHMAC, CounterLocation, Mode\n\tfrom ._asn1 import ASN1Reader\n\tclass AlgorithmOID(str, enum.Enum):\n\t    \"\"\"OIDs for cryptographic algorithms.\"\"\"\n\t    AES256_WRAP = \"2.16.840.1.101.3.4.1.45\"\n\t    AES256_GCM = \"2.16.840.1.101.3.4.1.46\"\n\tdef cek_decrypt(\n\t    algorithm: str,\n\t    parameters: t.Optional[bytes],\n\t    kek: bytes,\n", "    value: bytes,\n\t) -> bytes:\n\t    if algorithm == AlgorithmOID.AES256_WRAP:\n\t        return keywrap.aes_key_unwrap(kek, value)\n\t    else:\n\t        raise NotImplementedError(f\"Unknown cek encryption algorithm OID '{algorithm}'\")\n\tdef cek_encrypt(\n\t    algorithm: str,\n\t    parameters: t.Optional[bytes],\n\t    kek: bytes,\n", "    value: bytes,\n\t) -> bytes:\n\t    if algorithm == AlgorithmOID.AES256_WRAP:\n\t        return keywrap.aes_key_wrap(kek, value)\n\t    else:\n\t        raise NotImplementedError(f\"Unknown cek encryption algorithm OID '{algorithm}'\")\n\tdef cek_generate(\n\t    algorithm: str,\n\t) -> t.Tuple[bytes, bytes]:\n\t    if algorithm == AlgorithmOID.AES256_WRAP:\n", "        cek = AESGCM.generate_key(bit_length=256)\n\t        cek_iv = os.urandom(12)\n\t        return cek, cek_iv\n\t    else:\n\t        raise NotImplementedError(f\"Unknown cek encryption algorithm OID '{algorithm}'\")\n\tdef content_decrypt(\n\t    algorithm: str,\n\t    parameters: t.Optional[bytes],\n\t    cek: bytes,\n\t    value: bytes,\n", ") -> bytes:\n\t    if algorithm == AlgorithmOID.AES256_GCM:\n\t        if not parameters:\n\t            raise ValueError(\"Expecting parameters for AES256 GCM decryption but received none.\")\n\t        reader = ASN1Reader(parameters).read_sequence()\n\t        iv = reader.read_octet_string()\n\t        cipher = AESGCM(cek)\n\t        return cipher.decrypt(iv, value, None)\n\t    else:\n\t        raise NotImplementedError(f\"Unknown content encryption algorithm OID '{algorithm}'\")\n", "def content_encrypt(\n\t    algorithm: str,\n\t    parameters: t.Optional[bytes],\n\t    cek: bytes,\n\t    value: bytes,\n\t) -> bytes:\n\t    if algorithm == AlgorithmOID.AES256_GCM:\n\t        if not parameters:\n\t            raise ValueError(\"Expecting parameters for AES256 GCM encryption but received none.\")\n\t        reader = ASN1Reader(parameters).read_sequence()\n", "        iv = reader.read_octet_string()\n\t        cipher = AESGCM(cek)\n\t        return cipher.encrypt(iv, value, None)\n\t    else:\n\t        raise NotImplementedError(f\"Unknown content encryption algorithm OID '{algorithm}'\")\n\tdef kdf(\n\t    algorithm: hashes.HashAlgorithm,\n\t    secret: bytes,\n\t    label: bytes,\n\t    context: bytes,\n", "    length: int,\n\t) -> bytes:\n\t    # KDF(HashAlg, KI, Label, Context, L)\n\t    # where KDF is SP800-108 in counter mode.\n\t    kdf = KBKDFHMAC(\n\t        algorithm=algorithm,\n\t        mode=Mode.CounterMode,\n\t        length=length,\n\t        label=label,\n\t        context=context,\n", "        # MS-SMB2 uses the same KDF function and my implementation that\n\t        # sets a value of 4 seems to work so assume that's the case here.\n\t        rlen=4,\n\t        llen=4,\n\t        location=CounterLocation.BeforeFixed,\n\t        fixed=None,\n\t    )\n\t    return kdf.derive(secret)\n\tdef kdf_concat(\n\t    algorithm: hashes.HashAlgorithm,\n", "    shared_secret: bytes,\n\t    algorithm_id: bytes,\n\t    party_uinfo: bytes,\n\t    party_vinfo: bytes,\n\t    length: int,\n\t) -> bytes:\n\t    otherinfo = b\"\".join([algorithm_id, party_uinfo, party_vinfo])\n\t    return ConcatKDFHash(\n\t        algorithm,\n\t        length=length,\n", "        otherinfo=otherinfo,\n\t    ).derive(shared_secret)\n"]}
{"filename": "src/dpapi_ng/_blob.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport enum\n\timport typing as t\n\timport uuid\n\tfrom ._asn1 import ASN1Reader, ASN1Writer\n\tfrom ._pkcs7 import (\n\t    AlgorithmIdentifier,\n", "    ContentInfo,\n\t    EncryptedContentInfo,\n\t    EnvelopedData,\n\t    KEKIdentifier,\n\t    KEKRecipientInfo,\n\t    OtherKeyAttribute,\n\t)\n\tfrom ._security_descriptor import ace_to_bytes, sd_to_bytes\n\t@dataclasses.dataclass(frozen=True)\n\tclass KeyIdentifier:\n", "    \"\"\"Key Identifier.\n\t    This contains the key identifier info that can be used by MS-GKDI GetKey\n\t    to retrieve the group key seed values. This structure is not defined\n\t    publicly by Microsoft but it closely matches the :class:`GroupKeyEnvelope`\n\t    structure.\n\t    Args:\n\t        version: The version of the structure, should be 1\n\t        flags: Flags describing the values inside the structure\n\t        l0: The L0 index of the key\n\t        l1: The L1 index of the key\n", "        l2: The L2 index of the key\n\t        root_key_identifier: The key identifier\n\t        key_info: If is_public_key this is the public key, else it is the key\n\t            KDF context value.\n\t        domain_name: The domain name of the server in DNS format.\n\t        forest_name: The forest name of the server in DNS format.\n\t    \"\"\"\n\t    version: int\n\t    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x4B\\x44\\x53\\x4B\")\n\t    flags: int\n", "    l0: int\n\t    l1: int\n\t    l2: int\n\t    root_key_identifier: uuid.UUID\n\t    key_info: bytes\n\t    domain_name: str\n\t    forest_name: str\n\t    @property\n\t    def is_public_key(self) -> bool:\n\t        return bool(self.flags & 1)\n", "    def pack(self) -> bytes:\n\t        b_domain_name = (self.domain_name + \"\\00\").encode(\"utf-16-le\")\n\t        b_forest_name = (self.forest_name + \"\\00\").encode(\"utf-16-le\")\n\t        return b\"\".join(\n\t            [\n\t                self.version.to_bytes(4, byteorder=\"little\"),\n\t                self.magic,\n\t                self.flags.to_bytes(4, byteorder=\"little\"),\n\t                self.l0.to_bytes(4, byteorder=\"little\"),\n\t                self.l1.to_bytes(4, byteorder=\"little\"),\n", "                self.l2.to_bytes(4, byteorder=\"little\"),\n\t                self.root_key_identifier.bytes_le,\n\t                len(self.key_info).to_bytes(4, byteorder=\"little\"),\n\t                len(b_domain_name).to_bytes(4, byteorder=\"little\"),\n\t                len(b_forest_name).to_bytes(4, byteorder=\"little\"),\n\t                self.key_info,\n\t                b_domain_name,\n\t                b_forest_name,\n\t            ]\n\t        )\n", "    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> KeyIdentifier:\n\t        view = memoryview(data)\n\t        version = int.from_bytes(view[:4], byteorder=\"little\")\n\t        if view[4:8].tobytes() != cls.magic:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\t        flags = int.from_bytes(view[8:12], byteorder=\"little\")\n", "        l0_index = int.from_bytes(view[12:16], byteorder=\"little\")\n\t        l1_index = int.from_bytes(view[16:20], byteorder=\"little\")\n\t        l2_index = int.from_bytes(view[20:24], byteorder=\"little\")\n\t        root_key_identifier = uuid.UUID(bytes_le=view[24:40].tobytes())\n\t        key_info_len = int.from_bytes(view[40:44], byteorder=\"little\")\n\t        domain_len = int.from_bytes(view[44:48], byteorder=\"little\")\n\t        forest_len = int.from_bytes(view[48:52], byteorder=\"little\")\n\t        view = view[52:]\n\t        key_info = view[:key_info_len].tobytes()\n\t        view = view[key_info_len:]\n", "        # Take away 2 for the final null padding\n\t        domain = view[: domain_len - 2].tobytes().decode(\"utf-16-le\")\n\t        view = view[domain_len:]\n\t        forest = view[: forest_len - 2].tobytes().decode(\"utf-16-le\")\n\t        view = view[forest_len:]\n\t        return KeyIdentifier(\n\t            version=version,\n\t            flags=flags,\n\t            l0=l0_index,\n\t            l1=l1_index,\n", "            l2=l2_index,\n\t            root_key_identifier=root_key_identifier,\n\t            key_info=key_info,\n\t            domain_name=domain,\n\t            forest_name=forest,\n\t        )\n\tclass ProtectionDescriptorType(enum.Enum):\n\t    SID = \"1.3.6.1.4.1.311.74.1.1\"\n\t    KEY_FILE = \"1.3.6.1.4.1.311.74.1.2\"  # KeyFile in UF8String type\n\t    SDDL = \"1.3.6.1.4.1.311.74.1.5\"\n", "    LOCAL = \"1.3.6.1.4.1.311.74.1.8\"\n\t@dataclasses.dataclass(frozen=True)\n\tclass ProtectionDescriptor:\n\t    type: ProtectionDescriptorType\n\t    value: str\n\t    def get_target_sd(self) -> bytes:\n\t        raise NotImplementedError()  # pragma: nocover\n\t    def pack(self) -> bytes:\n\t        writer = ASN1Writer()\n\t        with writer.push_sequence() as w:\n", "            w.write_object_identifier(self.type.value)\n\t            with w.push_sequence() as w1:\n\t                with w1.push_sequence() as w2:\n\t                    with w2.push_sequence() as w3:\n\t                        w3.write_utf8_string(self.type.name)\n\t                        w3.write_utf8_string(self.value)\n\t        return writer.get_data()\n\t    @classmethod\n\t    def parse(\n\t        cls,\n", "        value: str,\n\t    ) -> ProtectionDescriptor:\n\t        # Currently only the SID type is supported\n\t        return SIDDescriptor(value)\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> ProtectionDescriptor:\n\t        reader = ASN1Reader(data).read_sequence()\n", "        content_type = reader.read_object_identifier()\n\t        reader = reader.read_sequence().read_sequence().read_sequence()\n\t        value_type = reader.read_utf8_string()\n\t        value = reader.read_utf8_string()\n\t        if content_type == ProtectionDescriptorType.SID.value and value_type == \"SID\":\n\t            return SIDDescriptor(value)\n\t        else:\n\t            raise ValueError(f\"DPAPI-NG protection descriptor type {content_type} '{value_type}' is unsupported\")\n\t@dataclasses.dataclass(frozen=True)\n\tclass SIDDescriptor(ProtectionDescriptor):\n", "    type: ProtectionDescriptorType = dataclasses.field(init=False, default=ProtectionDescriptorType.SID)\n\t    def get_target_sd(self) -> bytes:\n\t        # Build the target security descriptor from the SID passed in. This SD\n\t        # contains an ACE per target user with a mask of 0x3 and a final ACE of\n\t        # the current user with a mask of 0x2. When viewing this over the wire\n\t        # the current user is set as S-1-1-0 (World) and the owner/group is\n\t        # S-1-5-18 (SYSTEM).\n\t        return sd_to_bytes(\n\t            owner=\"S-1-5-18\",\n\t            group=\"S-1-5-18\",\n", "            dacl=[ace_to_bytes(self.value, 3), ace_to_bytes(\"S-1-1-0\", 2)],\n\t        )\n\t@dataclasses.dataclass\n\tclass DPAPINGBlob:\n\t    MICROSOFT_SOFTWARE_OID = \"1.3.6.1.4.1.311.74.1\"\n\t    \"\"\"DPAPI NG Blob.\n\t    The unpacked DPAPI NG blob that contains the information needed to decrypt\n\t    the encrypted content. The key identifier and protection descriptor can be\n\t    used to generate the KEK. The KEK is used to decrypt the encrypted CEK. The\n\t    CEK can be used to decrypt the encrypted contents.\n", "    Args:\n\t        key_identifier: The key identifier for the KEK.\n\t        protection_descriptor: The protection descriptor that protects the key.\n\t        enc_cek: The encrypted CEK.\n\t        enc_cek_algorithm: The encrypted CEK algorithm OID.\n\t        enc_cek_parameters: The encrypted CEK algorithm parameters.\n\t        enc_content: The encrypted content.\n\t        enc_content_algorithm: The encrypted content algorithm OID.\n\t        enc_content_parameters: The encrypted content parameters.\n\t    \"\"\"\n", "    key_identifier: KeyIdentifier\n\t    protection_descriptor: ProtectionDescriptor\n\t    enc_cek: bytes\n\t    enc_cek_algorithm: str\n\t    enc_cek_parameters: t.Optional[bytes]\n\t    enc_content: bytes\n\t    enc_content_algorithm: str\n\t    enc_content_parameters: t.Optional[bytes]\n\t    def pack(\n\t        self,\n", "        blob_in_envelope: bool = True,\n\t    ) -> bytes:\n\t        \"\"\"Pack the DPAPI-NG Blob\n\t        Packs the DPAPI-NG blob into a byte string.\n\t        Args:\n\t            blob_in_envelope: True to store the encrypted blob in the\n\t                EnvelopedData structure (NCryptProtectSecret general), False to\n\t                append the encrypted blob after the EnvelopedData structure\n\t                (LAPS style).\n\t        Returns:\n", "            bytes: The DPAPI NG Blob data.\n\t        \"\"\"\n\t        writer = ASN1Writer()\n\t        recipient_info = KEKRecipientInfo(\n\t            version=4,\n\t            kekid=KEKIdentifier(\n\t                key_identifier=self.key_identifier.pack(),\n\t                other=OtherKeyAttribute(\n\t                    key_attr_id=DPAPINGBlob.MICROSOFT_SOFTWARE_OID,\n\t                    key_attr=self.protection_descriptor.pack(),\n", "                ),\n\t            ),\n\t            key_encryption_algorithm=AlgorithmIdentifier(\n\t                self.enc_cek_algorithm,\n\t                self.enc_cek_parameters,\n\t            ),\n\t            encrypted_key=self.enc_cek,\n\t        )\n\t        enveloped_data = EnvelopedData(\n\t            version=2,\n", "            recipient_infos=[recipient_info],\n\t            encrypted_content_info=EncryptedContentInfo(\n\t                content_type=EnvelopedData.CONTENT_TYPE_DATA_OID,\n\t                algorithm=AlgorithmIdentifier(\n\t                    algorithm=self.enc_content_algorithm,\n\t                    parameters=self.enc_content_parameters,\n\t                ),\n\t                content=self.enc_content if blob_in_envelope else b\"\",\n\t            ),\n\t        )\n", "        writer = ASN1Writer()\n\t        enveloped_data.pack(writer)\n\t        content_info = ContentInfo(\n\t            content_type=EnvelopedData.CONTENT_TYPE_ENVELOPED_DATA_OID,\n\t            content=writer.get_data(),\n\t        )\n\t        writer = ASN1Writer()\n\t        content_info.pack(writer)\n\t        return b\"\".join(\n\t            [\n", "                writer.get_data(),\n\t                b\"\" if blob_in_envelope else self.enc_content,\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> DPAPINGBlob:\n\t        view = memoryview(data)\n", "        header = ASN1Reader(view).peek_header()\n\t        content_info = ContentInfo.unpack(view[: header.tag_length + header.length], header=header)\n\t        remaining_data = view[header.tag_length + header.length :]\n\t        if content_info.content_type != EnvelopedData.CONTENT_TYPE_ENVELOPED_DATA_OID:\n\t            raise ValueError(f\"DPAPI-NG blob content type '{content_info.content_type}' is unsupported\")\n\t        enveloped_data = EnvelopedData.unpack(content_info.content)\n\t        if (\n\t            enveloped_data.version != 2\n\t            or len(enveloped_data.recipient_infos) != 1\n\t            or not isinstance(enveloped_data.recipient_infos[0], KEKRecipientInfo)\n", "            or enveloped_data.recipient_infos[0].version != 4\n\t        ):\n\t            raise ValueError(f\"DPAPI-NG blob is not in the expected format\")\n\t        kek_info = enveloped_data.recipient_infos[0]\n\t        key_identifier = KeyIdentifier.unpack(kek_info.kekid.key_identifier)\n\t        if not kek_info.kekid.other or kek_info.kekid.other.key_attr_id != DPAPINGBlob.MICROSOFT_SOFTWARE_OID:\n\t            raise ValueError(\"DPAPI-NG KEK Id is not in the expected format\")\n\t        protection_descriptor = ProtectionDescriptor.unpack(kek_info.kekid.other.key_attr or b\"\")\n\t        # Some DPAPI blobs don't include the content in the PKCS7 payload but\n\t        # just append after the blob.\n", "        enc_content = enveloped_data.encrypted_content_info.content or remaining_data.tobytes()\n\t        return DPAPINGBlob(\n\t            key_identifier=key_identifier,\n\t            protection_descriptor=protection_descriptor,\n\t            enc_cek=kek_info.encrypted_key,\n\t            enc_cek_algorithm=kek_info.key_encryption_algorithm.algorithm,\n\t            enc_cek_parameters=kek_info.key_encryption_algorithm.parameters,\n\t            enc_content=enc_content,\n\t            enc_content_algorithm=enveloped_data.encrypted_content_info.algorithm.algorithm,\n\t            enc_content_parameters=enveloped_data.encrypted_content_info.algorithm.parameters,\n", "        )\n"]}
{"filename": "src/dpapi_ng/_gkdi.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport math\n\timport os\n\timport typing as t\n\timport uuid\n\tfrom cryptography.hazmat.primitives import hashes\n\tfrom cryptography.hazmat.primitives.asymmetric import ec\n", "from ._blob import KeyIdentifier\n\tfrom ._crypto import kdf, kdf_concat\n\tfrom ._rpc import SyntaxId\n\tKDS_SERVICE_LABEL = \"KDS service\\0\".encode(\"utf-16-le\")\n\tISD_KEY = SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n\t@dataclasses.dataclass\n\tclass GetKey:\n\t    \"\"\"GetKey RPC Request\n\t    This can be used to build the stub data for the GetKey RPC request. The\n\t    syntax for this function is defined in `MS-GKDI 3.1.4.1 GetKey (Opnum 0)`_.\n", "    Args:\n\t        target_sd: The security descriptor to derive the key for.\n\t        root_key_id: The optional key identifier.\n\t        l0_key_id: The L0 index of the requested key.\n\t        l1_key_id: The L1 index of the requested key.\n\t        l2_key_id: THe L2 index of the requested key.\n\t    .. _MS-GKDI 3.1.4.1 GetKey (Opnum 0):\n\t        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/4cac87a3-521e-4918-a272-240f8fabed39\n\t    \"\"\"\n\t    opnum: int = dataclasses.field(init=False, repr=False, default=0)\n", "    target_sd: bytes\n\t    root_key_id: t.Optional[uuid.UUID] = None\n\t    l0_key_id: int = -1\n\t    l1_key_id: int = -1\n\t    l2_key_id: int = -1\n\t    # HRESULT GetKey(\n\t    #     [in] handle_t hBinding,\n\t    #     [in] ULONG cbTargetSD,\n\t    #     [in] [size_is(cbTargetSD)] [ref] char* pbTargetSD,\n\t    #     [in] [unique] GUID* pRootKeyID,\n", "    #     [in] LONG L0KeyID,\n\t    #     [in] LONG L1KeyID,\n\t    #     [in] LONG L2KeyID,\n\t    #     [out] unsigned long* pcbOut,\n\t    #     [out] [size_is(, *pcbOut)] byte** ppbOut);\n\t    def pack(self) -> bytes:\n\t        # Strictly speaking it is only 4 bytes but NDR64 needs 8 byte alignment\n\t        # on the field after.\n\t        target_sd_len = len(self.target_sd).to_bytes(8, byteorder=\"little\")\n\t        if self.root_key_id:\n", "            b_root_key = b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\" + self.root_key_id.bytes_le\n\t        else:\n\t            b_root_key = b\"\\x00\" * 8\n\t        return b\"\".join(\n\t            [\n\t                # cbTargetSD\n\t                target_sd_len,\n\t                # pbTargetSD - pointer header includes the length + padding\n\t                target_sd_len,\n\t                self.target_sd,\n", "                b\"\\x00\" * (-len(self.target_sd) % 8),\n\t                # pRootKeyID - includes referent id\n\t                b_root_key,\n\t                # L0KeyID\n\t                self.l0_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n\t                # L1KeyID\n\t                self.l1_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n\t                # L2KeyID\n\t                self.l2_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n\t            ]\n", "        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> GetKey:\n\t        view = memoryview(data)\n\t        target_sd_len = int.from_bytes(view[:4], byteorder=\"little\")\n\t        target_sd = view[16 : 16 + target_sd_len].tobytes()\n\t        padding = -target_sd_len % 8\n", "        view = view[16 + target_sd_len + padding :]\n\t        root_key_referent = view[:8].tobytes()\n\t        if root_key_referent == b\"\\x00\" * 8:\n\t            root_key_id = None\n\t            view = view[8:]\n\t        else:\n\t            root_key_id = uuid.UUID(bytes_le=view[8:24].tobytes())\n\t            view = view[24:]\n\t        l0_key_id = int.from_bytes(view[:4], byteorder=\"little\", signed=True)\n\t        l1_key_id = int.from_bytes(view[4:8], byteorder=\"little\", signed=True)\n", "        l2_key_id = int.from_bytes(view[8:12], byteorder=\"little\", signed=True)\n\t        return GetKey(\n\t            target_sd=target_sd,\n\t            root_key_id=root_key_id,\n\t            l0_key_id=l0_key_id,\n\t            l1_key_id=l1_key_id,\n\t            l2_key_id=l2_key_id,\n\t        )\n\t    @classmethod\n\t    def unpack_response(\n", "        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> GroupKeyEnvelope:\n\t        view = memoryview(data)\n\t        hresult = int.from_bytes(view[-4:], byteorder=\"little\")\n\t        view = view[:-4]\n\t        if hresult != 0:\n\t            raise ValueError(f\"GetKey failed 0x{hresult:08X}\")\n\t        key_length = int.from_bytes(view[:4], byteorder=\"little\")\n\t        view = view[8:]  # Skip padding as well\n", "        # Skip the referent id and double up on pointer size\n\t        return GroupKeyEnvelope.unpack(view[16 : 16 + key_length])\n\t@dataclasses.dataclass(frozen=True)\n\tclass KDFParameters:\n\t    \"\"\"KDF Parameters\n\t    The format and field descriptions for the key derivation function (KDF)\n\t    parameters. The format of this struct is defined in\n\t    `MS-GKDI 2.2.1 KDF Parameters`_.\n\t    Args:\n\t        hash_name: The name of the hash algorithm.\n", "    .. _MS-GKDI 2.2.1 KDF Parameters:\n\t        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/9946aeff-a914-45e9-b9e5-6cb5b4059187\n\t    \"\"\"\n\t    hash_name: str\n\t    @property\n\t    def hash_algorithm(self) -> hashes.HashAlgorithm:\n\t        \"\"\"The hash algorithm object.\"\"\"\n\t        if self.hash_name == \"SHA1\":\n\t            return hashes.SHA1()\n\t        elif self.hash_name == \"SHA256\":\n", "            return hashes.SHA256()\n\t        elif self.hash_name == \"SHA384\":\n\t            return hashes.SHA384()\n\t        elif self.hash_name == \"SHA512\":\n\t            return hashes.SHA512()\n\t        else:\n\t            raise NotImplementedError(f\"Unsupported hash algorithm {self.hash_name}\")\n\t    def pack(self) -> bytes:\n\t        b_hash_name = (self.hash_name + \"\\00\").encode(\"utf-16-le\")\n\t        return b\"\".join(\n", "            [\n\t                b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\",\n\t                len(b_hash_name).to_bytes(4, byteorder=\"little\"),\n\t                b\"\\x00\\x00\\x00\\x00\",\n\t                b_hash_name,\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n", "        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> KDFParameters:\n\t        view = memoryview(data)\n\t        if view[:8].tobytes() != b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" or view[12:16].tobytes() != b\"\\x00\\x00\\x00\\x00\":\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\t        hash_length = int.from_bytes(view[8:12], byteorder=\"little\")\n\t        hash_name = view[16 : 16 + hash_length - 2].tobytes().decode(\"utf-16-le\")\n\t        return KDFParameters(hash_name=hash_name)\n\t@dataclasses.dataclass(frozen=True)\n\tclass FFCDHParameters:\n", "    \"\"\"FFC DH Parameters\n\t    The field parameters for use in deriving finite field cryptography (FFC)\n\t    Diffie-Hellman (DH) keys. The format of this struct is defined in\n\t    `MS-GKDI 2.2.2 FFC DH Parameters`_.\n\t    Args:\n\t        key_length: The length of the public key.\n\t        field_order: The large prime field order, otherwise known as p.\n\t        generator: The generator of the subgroup, otherwise known as g.\n\t    .. _MS-GKDI 2.2.2 FFC DH Parameters:\n\t        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/e15ae269-ee21-446a-a480-de3ea243db5f\n", "    \"\"\"\n\t    key_length: int\n\t    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x44\\x48\\x50\\x4D\")\n\t    field_order: int\n\t    generator: int\n\t    def pack(self) -> bytes:\n\t        b_field_order = self.field_order.to_bytes(self.key_length, byteorder=\"big\")\n\t        b_generator = self.generator.to_bytes(self.key_length, byteorder=\"big\")\n\t        return b\"\".join(\n\t            [\n", "                (12 + len(b_field_order) + len(b_generator)).to_bytes(4, byteorder=\"little\"),\n\t                self.magic,\n\t                self.key_length.to_bytes(4, byteorder=\"little\"),\n\t                b_field_order,\n\t                b_generator,\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n", "        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> FFCDHParameters:\n\t        view = memoryview(data)\n\t        # length = int.from_bytes(view[:4], byteorder=\"little\")\n\t        if view[4:8].tobytes() != cls.magic:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\t        key_length = int.from_bytes(view[8:12], byteorder=\"little\")\n\t        field_order = view[12 : 12 + key_length].tobytes()\n\t        generator = view[12 + key_length : 12 + key_length + key_length].tobytes()\n\t        return FFCDHParameters(\n", "            key_length=key_length,\n\t            field_order=int.from_bytes(field_order, byteorder=\"big\"),\n\t            generator=int.from_bytes(generator, byteorder=\"big\"),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass FFCDHKey:\n\t    \"\"\"FFC DH Key\n\t    The finite field cryptography (FFC) Diffie-Hellman (DH) public key info.\n\t    The format of this struct is defined in `MS-GKDI 2.2.3.1 FFC DH Key`_.\n\t    Args:\n", "        key_length: The length of the public key.\n\t        field_order: The large prime field order, otherwise known as p.\n\t        generator: The generator of the subgroup, otherwise known as g.\n\t        public_key: The public key of the peer, otherwise known as y.\n\t    .. _MS-GKDI 2.2.3.1 FFC DH Key:\n\t        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/f8770f01-036d-4bf6-a4cf-1bd0e3913404\n\t    \"\"\"\n\t    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x44\\x48\\x50\\x42\")\n\t    key_length: int\n\t    field_order: int\n", "    generator: int\n\t    public_key: int\n\t    def pack(self) -> bytes:\n\t        b_field_order = self.field_order.to_bytes(self.key_length, byteorder=\"big\")\n\t        b_generator = self.generator.to_bytes(self.key_length, byteorder=\"big\")\n\t        b_pub_key = self.public_key.to_bytes(self.key_length, byteorder=\"big\")\n\t        return b\"\".join(\n\t            [\n\t                self.magic,\n\t                self.key_length.to_bytes(4, byteorder=\"little\"),\n", "                b_field_order,\n\t                b_generator,\n\t                b_pub_key,\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> FFCDHKey:\n", "        view = memoryview(data)\n\t        if view[:4].tobytes() != cls.magic:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\t        key_length = int.from_bytes(view[4:8], byteorder=\"little\")\n\t        field_order = view[8 : 8 + key_length].tobytes()\n\t        view = view[8 + key_length :]\n\t        generator = view[:key_length].tobytes()\n\t        view = view[key_length:]\n\t        public_key = view[:key_length].tobytes()\n\t        return FFCDHKey(\n", "            key_length=key_length,\n\t            field_order=int.from_bytes(field_order, byteorder=\"big\"),\n\t            generator=int.from_bytes(generator, byteorder=\"big\"),\n\t            public_key=int.from_bytes(public_key, byteorder=\"big\"),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass ECDHKey:\n\t    \"\"\"ECDH Key\n\t    The elliptic curve Diffie-Hellman (ECDH) public key info. The format of\n\t    this struct is defined in `MS-GKDI 2.2.3.2 ECDH Key`_.\n", "    Args:\n\t        curve_name: The curve name used, currently only the curves P256, P384,\n\t            P521 are supported.\n\t        key_length: The length of the public key.\n\t        x: The X coordinate of the point P.\n\t        y: The Y coordinate of the point P.\n\t    .. _MS-GKDI 2.2.3.2 ECDH Key:\n\t        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/24876a37-9a92-4187-9052-222bb6f85d4a\n\t    \"\"\"\n\t    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x45\\x43\\x4B\")\n", "    curve_name: str\n\t    key_length: int\n\t    x: int\n\t    y: int\n\t    @property\n\t    def curve_and_hash(self) -> tuple[ec.EllipticCurve, hashes.HashAlgorithm]:\n\t        return {\n\t            \"P256\": (ec.SECP256R1(), hashes.SHA256()),\n\t            \"P384\": (ec.SECP384R1(), hashes.SHA384()),\n\t            \"P521\": (ec.SECP521R1(), hashes.SHA512()),\n", "        }[self.curve_name]\n\t    def pack(self) -> bytes:\n\t        b_x = self.x.to_bytes(self.key_length, byteorder=\"big\")\n\t        b_y = self.y.to_bytes(self.key_length, byteorder=\"big\")\n\t        b_curve = {\n\t            \"P256\": b\"\\x45\\x43\\x4B\\x31\",\n\t            \"P384\": b\"\\x45\\x43\\x4B\\x33\",\n\t            \"P521\": b\"\\x45\\x43\\x4B\\x35\",\n\t        }.get(self.curve_name, None)\n\t        if not b_curve:\n", "            raise ValueError(f\"Unknown curve '{self.curve_name}', cannot pack.\")\n\t        return b\"\".join(\n\t            [\n\t                b_curve,\n\t                self.key_length.to_bytes(4, byteorder=\"little\"),\n\t                b_x,\n\t                b_y,\n\t            ]\n\t        )\n\t    @classmethod\n", "    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> ECDHKey:\n\t        view = memoryview(data)\n\t        curve_id = int.from_bytes(view[:4], byteorder=\"little\")\n\t        curve = {\n\t            0x314B4345: \"P256\",\n\t            0x334B4345: \"P384\",\n\t            0x354B4345: \"P521\",\n", "        }.get(curve_id, None)\n\t        if not curve:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} with unknown curve 0x{curve_id:08X}\")\n\t        length = int.from_bytes(view[4:8], byteorder=\"little\")\n\t        x = view[8 : 8 + length].tobytes()\n\t        view = view[8 + length :]\n\t        y = view[:length].tobytes()\n\t        return ECDHKey(\n\t            curve_name=curve,\n\t            key_length=length,\n", "            x=int.from_bytes(x, byteorder=\"big\"),\n\t            y=int.from_bytes(y, byteorder=\"big\"),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass GroupKeyEnvelope:\n\t    \"\"\"Group Key Envelope\n\t    The group key envelope structure that describes the group key information\n\t    returned by a GetKey RPC request. The format of this struct is defined in\n\t    `MS-GKDI 2.2.4 Group Key Envelope`_.\n\t    Args:\n", "        version: The version of the structure, should be 1\n\t        flags: Flags describing the values inside the structure\n\t        l0: The L0 index of the key\n\t        l1: The L1 index of the key\n\t        l2: The L2 index of the key\n\t        root_key_identifier: The key identifier\n\t        kdf_algorithm: The KDF algorithm name.\n\t        kdf_parameters: The KDF algorithm parameters\n\t        secret_algorithm: The secret agreement algorithm name.\n\t        secret_parameters: The secret agreement algorithm parameters.\n", "        private_key_length: The private key length associated with the root key.\n\t        public_key_length: The public key length associated with the root key.\n\t        domain_name: The domain name of the server in DNS format.\n\t        forest_name: The forest name of the server in DNS format.\n\t        l1_key: The L1 seed key.\n\t        l2_key: If is_public_key this is the public key, else this is the L2\n\t            seed key.\n\t    .. _MS-GKDI 2.2.4 Group Key Envelope\n\t        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/192c061c-e740-4aa0-ab1d-6954fb3e58f7\n\t    \"\"\"\n", "    version: int\n\t    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x4B\\x44\\x53\\x4B\")\n\t    flags: int\n\t    l0: int\n\t    l1: int\n\t    l2: int\n\t    root_key_identifier: uuid.UUID\n\t    kdf_algorithm: str\n\t    kdf_parameters: bytes\n\t    secret_algorithm: str\n", "    secret_parameters: bytes\n\t    private_key_length: int\n\t    public_key_length: int\n\t    domain_name: str\n\t    forest_name: str\n\t    l1_key: bytes\n\t    l2_key: bytes\n\t    @property\n\t    def is_public_key(self) -> bool:\n\t        \"\"\"If True, the value of l2_key is the public key.\"\"\"\n", "        return bool(self.flags & 1)\n\t    def pack(self) -> bytes:\n\t        b_kdf_algorithm = (self.kdf_algorithm + \"\\00\").encode(\"utf-16-le\")\n\t        b_secret_algorithm = (self.secret_algorithm + \"\\00\").encode(\"utf-16-le\")\n\t        b_domain_name = (self.domain_name + \"\\00\").encode(\"utf-16-le\")\n\t        b_forest_name = (self.forest_name + \"\\00\").encode(\"utf-16-le\")\n\t        return b\"\".join(\n\t            [\n\t                self.version.to_bytes(4, byteorder=\"little\"),\n\t                self.magic,\n", "                self.flags.to_bytes(4, byteorder=\"little\"),\n\t                self.l0.to_bytes(4, byteorder=\"little\"),\n\t                self.l1.to_bytes(4, byteorder=\"little\"),\n\t                self.l2.to_bytes(4, byteorder=\"little\"),\n\t                self.root_key_identifier.bytes_le,\n\t                len(b_kdf_algorithm).to_bytes(4, byteorder=\"little\"),\n\t                len(self.kdf_parameters).to_bytes(4, byteorder=\"little\"),\n\t                len(b_secret_algorithm).to_bytes(4, byteorder=\"little\"),\n\t                len(self.secret_parameters).to_bytes(4, byteorder=\"little\"),\n\t                self.private_key_length.to_bytes(4, byteorder=\"little\"),\n", "                self.public_key_length.to_bytes(4, byteorder=\"little\"),\n\t                len(self.l1_key).to_bytes(4, byteorder=\"little\"),\n\t                len(self.l2_key).to_bytes(4, byteorder=\"little\"),\n\t                len(b_domain_name).to_bytes(4, byteorder=\"little\"),\n\t                len(b_forest_name).to_bytes(4, byteorder=\"little\"),\n\t                b_kdf_algorithm,\n\t                self.kdf_parameters,\n\t                b_secret_algorithm,\n\t                self.secret_parameters,\n\t                b_domain_name,\n", "                b_forest_name,\n\t                self.l1_key,\n\t                self.l2_key,\n\t            ]\n\t        )\n\t    def get_kek(\n\t        self,\n\t        key_id: KeyIdentifier,\n\t    ) -> bytes:\n\t        if self.is_public_key:\n", "            raise ValueError(\"Current user is not authorized to retrieve the KEK information\")\n\t        if self.l0 != key_id.l0:\n\t            raise ValueError(f\"L0 index {self.l0} does not match the requested L0 index {key_id.l0}\")\n\t        if self.kdf_algorithm != \"SP800_108_CTR_HMAC\":\n\t            raise NotImplementedError(f\"Unknown KDF algorithm '{self.kdf_algorithm}'\")\n\t        kdf_parameters = KDFParameters.unpack(self.kdf_parameters)\n\t        hash_algo = kdf_parameters.hash_algorithm\n\t        l2_key = compute_l2_key(hash_algo, key_id.l1, key_id.l2, self)\n\t        if key_id.is_public_key:\n\t            return compute_kek_from_public_key(\n", "                algorithm=hash_algo,\n\t                seed=l2_key,\n\t                secret_algorithm=self.secret_algorithm,\n\t                secret_parameters=self.secret_parameters,\n\t                public_key=key_id.key_info,\n\t                private_key_length=math.ceil(self.private_key_length / 8),\n\t            )\n\t        else:\n\t            return kdf(\n\t                hash_algo,\n", "                l2_key,\n\t                KDS_SERVICE_LABEL,\n\t                key_id.key_info,\n\t                32,\n\t            )\n\t    def new_kek(\n\t        self,\n\t    ) -> tuple[bytes, KeyIdentifier]:\n\t        if self.kdf_algorithm != \"SP800_108_CTR_HMAC\":\n\t            raise NotImplementedError(f\"Unknown KDF algorithm '{self.kdf_algorithm}'\")\n", "        kdf_parameters = KDFParameters.unpack(self.kdf_parameters)\n\t        hash_algo = kdf_parameters.hash_algorithm\n\t        if self.is_public_key:\n\t            # If is_public_key flag is set, the L2 key is the peer's public key\n\t            private_key = os.urandom(math.ceil(self.private_key_length / 8))\n\t            kek = compute_kek(\n\t                algorithm=hash_algo,\n\t                secret_algorithm=self.secret_algorithm,\n\t                secret_parameters=self.secret_parameters,\n\t                private_key=private_key,\n", "                public_key=self.l2_key,\n\t            )\n\t            key_info = compute_public_key(\n\t                secret_algorithm=self.secret_algorithm,\n\t                secret_parameters=self.secret_parameters,\n\t                private_key=private_key,\n\t                peer_public_key=self.l2_key,\n\t            )\n\t        else:\n\t            key_info = os.urandom(32)\n", "            kek = kdf(\n\t                hash_algo,\n\t                self.l2_key,\n\t                KDS_SERVICE_LABEL,\n\t                key_info,\n\t                32,\n\t            )\n\t        key_identifier = KeyIdentifier(\n\t            version=1,\n\t            flags=self.flags,\n", "            l0=self.l0,\n\t            l1=self.l1,\n\t            l2=self.l2,\n\t            root_key_identifier=self.root_key_identifier,\n\t            key_info=key_info,\n\t            domain_name=self.domain_name,\n\t            forest_name=self.forest_name,\n\t        )\n\t        return kek, key_identifier\n\t    @classmethod\n", "    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> GroupKeyEnvelope:\n\t        view = memoryview(data)\n\t        version = int.from_bytes(view[:4], byteorder=\"little\")\n\t        if view[4:8].tobytes() != cls.magic:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\t        flags = int.from_bytes(view[8:12], byteorder=\"little\")\n\t        l0_index = int.from_bytes(view[12:16], byteorder=\"little\")\n", "        l1_index = int.from_bytes(view[16:20], byteorder=\"little\")\n\t        l2_index = int.from_bytes(view[20:24], byteorder=\"little\")\n\t        root_key_identifier = uuid.UUID(bytes_le=view[24:40].tobytes())\n\t        kdf_algo_len = int.from_bytes(view[40:44], byteorder=\"little\")\n\t        kdf_para_len = int.from_bytes(view[44:48], byteorder=\"little\")\n\t        sec_algo_len = int.from_bytes(view[48:52], byteorder=\"little\")\n\t        sec_para_len = int.from_bytes(view[52:56], byteorder=\"little\")\n\t        priv_key_len = int.from_bytes(view[56:60], byteorder=\"little\")\n\t        publ_key_len = int.from_bytes(view[60:64], byteorder=\"little\")\n\t        l1_key_len = int.from_bytes(view[64:68], byteorder=\"little\")\n", "        l2_key_len = int.from_bytes(view[68:72], byteorder=\"little\")\n\t        domain_len = int.from_bytes(view[72:76], byteorder=\"little\")\n\t        forest_len = int.from_bytes(view[76:80], byteorder=\"little\")\n\t        view = view[80:]\n\t        kdf_algo = view[: kdf_algo_len - 2].tobytes().decode(\"utf-16-le\")\n\t        view = view[kdf_algo_len:]\n\t        kdf_param = view[:kdf_para_len].tobytes()\n\t        view = view[kdf_para_len:]\n\t        secret_algo = view[: sec_algo_len - 2].tobytes().decode(\"utf-16-le\")\n\t        view = view[sec_algo_len:]\n", "        secret_param = view[:sec_para_len].tobytes()\n\t        view = view[sec_para_len:]\n\t        domain = view[: domain_len - 2].tobytes().decode(\"utf-16-le\")\n\t        view = view[domain_len:]\n\t        forest = view[: forest_len - 2].tobytes().decode(\"utf-16-le\")\n\t        view = view[forest_len:]\n\t        l1_key = view[:l1_key_len].tobytes()\n\t        view = view[l1_key_len:]\n\t        l2_key = view[:l2_key_len].tobytes()\n\t        view = view[l2_key_len:]\n", "        return GroupKeyEnvelope(\n\t            version=version,\n\t            flags=flags,\n\t            l0=l0_index,\n\t            l1=l1_index,\n\t            l2=l2_index,\n\t            root_key_identifier=root_key_identifier,\n\t            kdf_algorithm=kdf_algo,\n\t            kdf_parameters=kdf_param,\n\t            secret_algorithm=secret_algo,\n", "            secret_parameters=secret_param,\n\t            private_key_length=priv_key_len,\n\t            public_key_length=publ_key_len,\n\t            domain_name=domain,\n\t            forest_name=forest,\n\t            l1_key=l1_key,\n\t            l2_key=l2_key,\n\t        )\n\tdef compute_l1_key(\n\t    target_sd: bytes,\n", "    root_key_id: uuid.UUID,\n\t    l0: int,\n\t    root_key: bytes,\n\t    algorithm: hashes.HashAlgorithm,\n\t) -> bytes:\n\t    # Note: 512 is number of bits, we use byte length here\n\t    # Key(SD, RK, L0, -1, -1) = KDF(\n\t    #   HashAlg,\n\t    #   RK.msKds-RootKeyData,\n\t    #   \"KDS service\",\n", "    #   RKID || L0 || 0xffffffff || 0xffffffff,\n\t    #   512\n\t    # )\n\t    l0_seed = kdf(\n\t        algorithm,\n\t        root_key,\n\t        KDS_SERVICE_LABEL,\n\t        compute_kdf_context(root_key_id, l0, -1, -1),\n\t        64,\n\t    )\n", "    # Key(SD, RK, L0, 31, -1) = KDF(\n\t    #   HashAlg,\n\t    #   Key(SD, RK, L0, -1, -1),\n\t    #   \"KDS service\",\n\t    #   RKID || L0 || 31 || 0xffffffff || SD,\n\t    #   512\n\t    # )\n\t    return kdf(\n\t        algorithm,\n\t        l0_seed,\n", "        KDS_SERVICE_LABEL,\n\t        compute_kdf_context(root_key_id, l0, 31, -1) + target_sd,\n\t        64,\n\t    )\n\tdef compute_l2_key(\n\t    algorithm: hashes.HashAlgorithm,\n\t    request_l1: int,\n\t    request_l2: int,\n\t    rk: GroupKeyEnvelope,\n\t) -> bytes:\n", "    l1 = rk.l1\n\t    l1_key = rk.l1_key\n\t    l2 = rk.l2\n\t    l2_key = rk.l2_key\n\t    reseed_l2 = l2 == 31 or rk.l1 != request_l1\n\t    # MS-GKDI 2.2.4 Group key Envelope\n\t    # If the value in the L2 index field is equal to 31, this contains the\n\t    # L1 key with group key identifier (L0 index, L1 index, -1). In all\n\t    # other cases, this field contains the L1 key with group key identifier\n\t    # (L0 index, L1 index - 1, -1). If this field is present, its length\n", "    # MUST be equal to 64 bytes.\n\t    if l2 != 31 and l1 != request_l1:\n\t        l1 -= 1\n\t    while l1 != request_l1:\n\t        reseed_l2 = True\n\t        l1 -= 1\n\t        l1_key = kdf(\n\t            algorithm,\n\t            l1_key,\n\t            KDS_SERVICE_LABEL,\n", "            compute_kdf_context(\n\t                rk.root_key_identifier,\n\t                rk.l0,\n\t                l1,\n\t                -1,\n\t            ),\n\t            64,\n\t        )\n\t    if reseed_l2:\n\t        l2 = 31\n", "        l2_key = kdf(\n\t            algorithm,\n\t            l1_key,\n\t            KDS_SERVICE_LABEL,\n\t            compute_kdf_context(\n\t                rk.root_key_identifier,\n\t                rk.l0,\n\t                l1,\n\t                l2,\n\t            ),\n", "            64,\n\t        )\n\t    while l2 != request_l2:\n\t        l2 -= 1\n\t        l2_key = kdf(\n\t            algorithm,\n\t            l2_key,\n\t            KDS_SERVICE_LABEL,\n\t            compute_kdf_context(\n\t                rk.root_key_identifier,\n", "                rk.l0,\n\t                l1,\n\t                l2,\n\t            ),\n\t            64,\n\t        )\n\t    return l2_key\n\tdef compute_kdf_context(\n\t    key_guid: uuid.UUID,\n\t    l0: int,\n", "    l1: int,\n\t    l2: int,\n\t) -> bytes:\n\t    return b\"\".join(\n\t        [\n\t            key_guid.bytes_le,\n\t            l0.to_bytes(4, byteorder=\"little\", signed=True),\n\t            l1.to_bytes(4, byteorder=\"little\", signed=True),\n\t            l2.to_bytes(4, byteorder=\"little\", signed=True),\n\t        ]\n", "    )\n\tdef compute_kek_from_public_key(\n\t    algorithm: hashes.HashAlgorithm,\n\t    seed: bytes,\n\t    secret_algorithm: str,\n\t    secret_parameters: t.Optional[bytes],\n\t    public_key: bytes,\n\t    private_key_length: int,\n\t) -> bytes:\n\t    private_key = kdf(\n", "        algorithm,\n\t        seed,\n\t        KDS_SERVICE_LABEL,\n\t        (secret_algorithm + \"\\0\").encode(\"utf-16-le\"),\n\t        private_key_length,\n\t    )\n\t    return compute_kek(\n\t        algorithm,\n\t        secret_algorithm=secret_algorithm,\n\t        secret_parameters=secret_parameters,\n", "        private_key=private_key,\n\t        public_key=public_key,\n\t    )\n\tdef compute_kek(\n\t    algorithm: hashes.HashAlgorithm,\n\t    secret_algorithm: str,\n\t    secret_parameters: t.Optional[bytes],\n\t    private_key: bytes,\n\t    public_key: bytes,\n\t) -> bytes:\n", "    # Special thanks for Grzegorz Tworek (@0gtweet) and Micha Grzegorzewski\n\t    # for providing access to CQDPAPINGPFXDecrypter.exe which contains the\n\t    # BCrypt* APIs Microsoft use to derive the KEK.\n\t    secret_hash_algorithm: hashes.HashAlgorithm\n\t    if secret_algorithm == \"DH\":\n\t        # p = FFCDHParameters.unpack(secret_parameters or b\"\")\n\t        # We can derive the shared secret based on the DH formula.\n\t        # s = y**x mod p\n\t        dh_pub_key = FFCDHKey.unpack(public_key)\n\t        shared_secret_int = pow(\n", "            dh_pub_key.public_key,\n\t            int.from_bytes(private_key, byteorder=\"big\"),\n\t            dh_pub_key.field_order,\n\t        )\n\t        shared_secret = shared_secret_int.to_bytes(dh_pub_key.key_length, byteorder=\"big\")\n\t        secret_hash_algorithm = hashes.SHA256()\n\t    elif secret_algorithm.startswith(\"ECDH_P\"):\n\t        ecdh_pub_key_info = ECDHKey.unpack(public_key)\n\t        curve, secret_hash_algorithm = ecdh_pub_key_info.curve_and_hash\n\t        ecdh_pub_key = ec.EllipticCurvePublicNumbers(ecdh_pub_key_info.x, ecdh_pub_key_info.y, curve).public_key()\n", "        ecdh_private = ec.derive_private_key(\n\t            int.from_bytes(private_key, byteorder=\"big\"),\n\t            curve,\n\t        )\n\t        shared_secret = ecdh_private.exchange(ec.ECDH(), ecdh_pub_key)\n\t    else:\n\t        raise NotImplementedError(f\"Unknown secret agreement algorithm '{secret_algorithm}'\")\n\t    # This part isn't documented but we use the key derivation algorithm\n\t    # SP 800-56A to derive the kek secret input value. On Windows this uses\n\t    # BCryptDeriveKey with the following parameters.\n", "    #   KDF_ALGORITHMID - SHA512\n\t    #   KDF_PARTYUINFO  - KDS public key\n\t    #   KDF_PARTYVINFO  - KDS service\n\t    # Each of these is just appended to the otherinfo value used in\n\t    # cryptography as the UTF-16-LE NULL terminated strings.\n\t    kek_context = \"KDS public key\\0\".encode(\"utf-16-le\")\n\t    secret = kdf_concat(\n\t        secret_hash_algorithm,\n\t        shared_secret,\n\t        algorithm_id=\"SHA512\\0\".encode(\"utf-16-le\"),\n", "        party_uinfo=kek_context,\n\t        party_vinfo=KDS_SERVICE_LABEL,\n\t        length=secret_hash_algorithm.digest_size,\n\t    )\n\t    return kdf(\n\t        algorithm,\n\t        secret,\n\t        KDS_SERVICE_LABEL,\n\t        kek_context,\n\t        32,\n", "    )\n\tdef compute_public_key(\n\t    secret_algorithm: str,\n\t    secret_parameters: t.Optional[bytes],\n\t    private_key: bytes,\n\t    peer_public_key: bytes,\n\t) -> bytes:\n\t    if secret_algorithm == \"DH\":\n\t        dh_pub_key = FFCDHKey.unpack(peer_public_key)\n\t        # We can derive our public key based on the DH formula.\n", "        # X = G**x mod p\n\t        my_pub_key = pow(\n\t            dh_pub_key.generator,\n\t            int.from_bytes(private_key, byteorder=\"big\"),\n\t            dh_pub_key.field_order,\n\t        )\n\t        return FFCDHKey(\n\t            dh_pub_key.key_length,\n\t            dh_pub_key.field_order,\n\t            dh_pub_key.generator,\n", "            my_pub_key,\n\t        ).pack()\n\t    elif secret_algorithm.startswith(\"ECDH_P\"):\n\t        ecdh_pub_key = ECDHKey.unpack(peer_public_key)\n\t        curve = ecdh_pub_key.curve_and_hash[0]\n\t        ecdh_private = ec.derive_private_key(\n\t            int.from_bytes(private_key, byteorder=\"big\"),\n\t            curve,\n\t        )\n\t        my_ecdh_pub_key = ecdh_private.public_key().public_numbers()\n", "        return ECDHKey(\n\t            ecdh_pub_key.curve_name,\n\t            ecdh_pub_key.key_length,\n\t            my_ecdh_pub_key.x,\n\t            my_ecdh_pub_key.y,\n\t        ).pack()\n\t    else:\n\t        raise NotImplementedError(f\"Unknown secret agreement algorithm '{secret_algorithm}'\")\n"]}
{"filename": "src/dpapi_ng/_dns.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport typing as t\n\timport dns.asyncresolver\n\timport dns.resolver\n\tclass SrvRecord(t.NamedTuple):\n\t    target: str\n\t    port: int\n\t    weight: int\n", "    priority: int\n\tdef _get_highest_answer(\n\t    answer: dns.resolver.Answer,\n\t) -> SrvRecord:\n\t    answers: t.List[SrvRecord] = []\n\t    for a in answer:\n\t        answers.append(\n\t            SrvRecord(\n\t                # The trailing . causes errors on Windows and the SPN lookup.\n\t                target=str(a.target).rstrip(\".\"),\n", "                port=a.port,\n\t                weight=a.weight,\n\t                priority=a.priority,\n\t            )\n\t        )\n\t    # Sorts the array by lowest priority then highest weight.\n\t    return sorted(answers, key=lambda a: (a.priority, -a.weight))[0]\n\tasync def async_lookup_dc(\n\t    domain_name: t.Optional[str] = None,\n\t) -> SrvRecord:\n", "    \"\"\"Lookup DC for domain name\n\t    Attempts to lookup LDAP server based on the domain name specified or the\n\t    system's search domain if available. This is done through an SRV lookup for\n\t    '_ldap._tcp.dc._msdcs.{domain_name}'.\n\t    Args:\n\t        domain_name: The domain to lookup the DC for.\n\t    Returns:\n\t        SrvRecord: The SRV record result.\n\t    Raises:\n\t        dns.exception.DNSException: DNS lookup error.\n", "    \"\"\"\n\t    if domain_name:\n\t        record = f\"_ldap._tcp.dc._msdcs.{domain_name}\"\n\t    else:\n\t        record = f\"_ldap._tcp.dc._msdcs\"\n\t    answers = await dns.asyncresolver.resolve(record, \"SRV\", search=True)\n\t    return _get_highest_answer(answers)\n\tdef lookup_dc(\n\t    domain_name: t.Optional[str] = None,\n\t) -> SrvRecord:\n", "    \"\"\"Lookup DC for domain name\n\t    Attempts to lookup LDAP server based on the domain name specified or the\n\t    system's search domain if available. This is done through an SRV lookup for\n\t    '_ldap._tcp.dc._msdcs.{domain_name}'.\n\t    Args:\n\t        domain_name: The domain to lookup the DC for.\n\t    Returns:\n\t        SrvRecord: The SRV record result.\n\t    Raises:\n\t        dns.exception.DNSException: DNS lookup error.\n", "    \"\"\"\n\t    if domain_name:\n\t        record = f\"_ldap._tcp.dc._msdcs.{domain_name}\"\n\t    else:\n\t        record = f\"_ldap._tcp.dc._msdcs\"\n\t    answers = dns.resolver.resolve(record, \"SRV\", search=True)\n\t    return _get_highest_answer(answers)\n"]}
{"filename": "src/dpapi_ng/_client.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport time\n\timport typing as t\n\timport uuid\n\tfrom ._asn1 import ASN1Writer\n\tfrom ._blob import DPAPINGBlob, ProtectionDescriptor\n\tfrom ._crypto import (\n\t    AlgorithmOID,\n", "    cek_decrypt,\n\t    cek_encrypt,\n\t    cek_generate,\n\t    content_decrypt,\n\t    content_encrypt,\n\t)\n\tfrom ._dns import async_lookup_dc, lookup_dc\n\tfrom ._epm import EPM, EptMap, EptMapResult, TCPFloor, build_tcpip_tower\n\tfrom ._gkdi import (\n\t    ISD_KEY,\n", "    FFCDHParameters,\n\t    GetKey,\n\t    GroupKeyEnvelope,\n\t    KDFParameters,\n\t    compute_l1_key,\n\t    compute_l2_key,\n\t)\n\tfrom ._rpc import (\n\t    NDR,\n\t    NDR64,\n", "    BindAck,\n\t    CommandFlags,\n\t    CommandPContext,\n\t    ContextElement,\n\t    ContextResultCode,\n\t    Response,\n\t    VerificationTrailer,\n\t    async_create_rpc_connection,\n\t    bind_time_feature_negotiation,\n\t    create_rpc_connection,\n", ")\n\t_EPOCH_FILETIME = 116444736000000000  # 1970-01-01 as FILETIME\n\t_EPM_CONTEXTS = [\n\t    ContextElement(\n\t        context_id=0,\n\t        abstract_syntax=EPM,\n\t        transfer_syntaxes=[NDR64],\n\t    )\n\t]\n\t_ISD_KEY_CONTEXTS = [\n", "    ContextElement(\n\t        context_id=0,\n\t        abstract_syntax=ISD_KEY,\n\t        transfer_syntaxes=[NDR64],\n\t    ),\n\t    ContextElement(\n\t        context_id=1,\n\t        abstract_syntax=ISD_KEY,\n\t        transfer_syntaxes=[bind_time_feature_negotiation()],\n\t    ),\n", "]\n\t_EPT_MAP_ISD_KEY = EptMap(\n\t    obj=None,\n\t    tower=build_tcpip_tower(\n\t        service=ISD_KEY,\n\t        data_rep=NDR,\n\t        port=135,\n\t        addr=0,\n\t    ),\n\t    entry_handle=None,\n", "    max_towers=4,\n\t)\n\t_VERIFICATION_TRAILER = VerificationTrailer(\n\t    [\n\t        CommandPContext(\n\t            flags=CommandFlags.SEC_VT_COMMAND_END,\n\t            interface_id=ISD_KEY,\n\t            transfer_syntax=NDR64,\n\t        ),\n\t    ]\n", ")\n\tdef _process_bind_result(\n\t    requested_contexts: t.List[ContextElement],\n\t    bind_ack: BindAck,\n\t    desired_context: int,\n\t) -> None:\n\t    accepted_ids = []\n\t    for idx, c in enumerate(bind_ack.results):\n\t        if c.result == ContextResultCode.ACCEPTANCE:\n\t            ctx = requested_contexts[idx]\n", "            accepted_ids.append(ctx.context_id)\n\t    if desired_context not in accepted_ids:\n\t        raise ValueError(\"Failed to bind to desired context\")\n\t    return\n\tdef _process_ept_map_result(\n\t    response: Response,\n\t) -> int:\n\t    map_response = EptMapResult.unpack(response.stub_data)\n\t    if map_response.status != 0:\n\t        raise ValueError(f\"Receive error during ept_map call 0x{map_response.status:08X}\")\n", "    for tower in map_response.towers:\n\t        for floor in tower:\n\t            if isinstance(floor, TCPFloor):\n\t                return floor.port\n\t    raise ValueError(\"Did not find expected TCP Port in ept_map response\")\n\tdef _process_get_key_result(\n\t    response: Response,\n\t) -> GroupKeyEnvelope:\n\t    pad_length = len(response.stub_data)\n\t    if response.sec_trailer and response.sec_trailer.pad_length:\n", "        pad_length -= response.sec_trailer.pad_length\n\t    raw_resp = response.stub_data[:pad_length]\n\t    return GetKey.unpack_response(raw_resp)\n\tasync def _async_get_key(\n\t    server: str,\n\t    target_sd: bytes,\n\t    root_key_id: t.Optional[uuid.UUID],\n\t    l0: int = -1,\n\t    l1: int = -1,\n\t    l2: int = -1,\n", "    username: t.Optional[str] = None,\n\t    password: t.Optional[str] = None,\n\t    auth_protocol: str = \"negotiate\",\n\t) -> GroupKeyEnvelope:\n\t    rpc = await async_create_rpc_connection(server)\n\t    async with rpc:\n\t        context_id = _EPM_CONTEXTS[0].context_id\n\t        ack = await rpc.bind(contexts=_EPM_CONTEXTS)\n\t        _process_bind_result(_EPM_CONTEXTS, ack, context_id)\n\t        ept_map = _EPT_MAP_ISD_KEY\n", "        resp = await rpc.request(context_id, ept_map.opnum, ept_map.pack())\n\t        isd_key_port = _process_ept_map_result(resp)\n\t    rpc = await async_create_rpc_connection(\n\t        server,\n\t        isd_key_port,\n\t        username=username,\n\t        password=password,\n\t        auth_protocol=auth_protocol,\n\t    )\n\t    async with rpc:\n", "        context_id = _ISD_KEY_CONTEXTS[0].context_id\n\t        ack = await rpc.bind(contexts=_ISD_KEY_CONTEXTS)\n\t        _process_bind_result(_ISD_KEY_CONTEXTS, ack, context_id)\n\t        get_key = GetKey(target_sd, root_key_id, l0, l1, l2)\n\t        resp = await rpc.request(\n\t            context_id,\n\t            get_key.opnum,\n\t            get_key.pack(),\n\t            verification_trailer=_VERIFICATION_TRAILER,\n\t        )\n", "        return _process_get_key_result(resp)\n\tdef _sync_get_key(\n\t    server: str,\n\t    target_sd: bytes,\n\t    root_key_id: t.Optional[uuid.UUID] = None,\n\t    l0: int = -1,\n\t    l1: int = -1,\n\t    l2: int = -1,\n\t    username: t.Optional[str] = None,\n\t    password: t.Optional[str] = None,\n", "    auth_protocol: str = \"negotiate\",\n\t) -> GroupKeyEnvelope:\n\t    with create_rpc_connection(server) as rpc:\n\t        context_id = _EPM_CONTEXTS[0].context_id\n\t        ack = rpc.bind(contexts=_EPM_CONTEXTS)\n\t        _process_bind_result(_EPM_CONTEXTS, ack, context_id)\n\t        ept_map = _EPT_MAP_ISD_KEY\n\t        resp = rpc.request(0, ept_map.opnum, ept_map.pack())\n\t        isd_key_port = _process_ept_map_result(resp)\n\t    with create_rpc_connection(\n", "        server,\n\t        isd_key_port,\n\t        username=username,\n\t        password=password,\n\t        auth_protocol=auth_protocol,\n\t    ) as rpc:\n\t        context_id = _ISD_KEY_CONTEXTS[0].context_id\n\t        ack = rpc.bind(contexts=_ISD_KEY_CONTEXTS)\n\t        _process_bind_result(_ISD_KEY_CONTEXTS, ack, context_id)\n\t        get_key = GetKey(target_sd, root_key_id, l0, l1, l2)\n", "        resp = rpc.request(\n\t            context_id,\n\t            get_key.opnum,\n\t            get_key.pack(),\n\t            verification_trailer=_VERIFICATION_TRAILER,\n\t        )\n\t        return _process_get_key_result(resp)\n\tdef _decrypt_blob(\n\t    blob: DPAPINGBlob,\n\t    key: GroupKeyEnvelope,\n", ") -> bytes:\n\t    kek = key.get_kek(blob.key_identifier)\n\t    # With the kek we can unwrap the encrypted cek in the LAPS payload.\n\t    cek = cek_decrypt(\n\t        blob.enc_cek_algorithm,\n\t        blob.enc_cek_parameters,\n\t        kek,\n\t        blob.enc_cek,\n\t    )\n\t    # With the cek we can decrypt the encrypted content in the LAPS payload.\n", "    return content_decrypt(\n\t        blob.enc_content_algorithm,\n\t        blob.enc_content_parameters,\n\t        cek,\n\t        blob.enc_content,\n\t    )\n\tdef _encrypt_blob(\n\t    blob: bytes,\n\t    key: GroupKeyEnvelope,\n\t    protection_descriptor: ProtectionDescriptor,\n", ") -> bytes:\n\t    # Generate cek and encrypt our payload.\n\t    enc_cek_algorithm = AlgorithmOID.AES256_WRAP\n\t    cek, cek_iv = cek_generate(enc_cek_algorithm)\n\t    parameters_writer = ASN1Writer()\n\t    with parameters_writer.push_sequence() as parameters:\n\t        parameters.write_octet_string(cek_iv)\n\t        parameters.write_integer(16)\n\t    enc_content_algorithm = AlgorithmOID.AES256_GCM\n\t    enc_content_parameters = parameters_writer.get_data()\n", "    enc_content = content_encrypt(\n\t        enc_content_algorithm,\n\t        enc_content_parameters,\n\t        cek,\n\t        blob,\n\t    )\n\t    kek, key_identifier = key.new_kek()\n\t    enc_cek_parameters = None\n\t    enc_cek = cek_encrypt(\n\t        enc_cek_algorithm,\n", "        enc_cek_parameters,\n\t        kek,\n\t        cek,\n\t    )\n\t    return DPAPINGBlob(\n\t        key_identifier=key_identifier,\n\t        protection_descriptor=protection_descriptor,\n\t        enc_cek=enc_cek,\n\t        enc_cek_algorithm=enc_cek_algorithm,\n\t        enc_cek_parameters=enc_cek_parameters,\n", "        enc_content=enc_content,\n\t        enc_content_algorithm=enc_content_algorithm,\n\t        enc_content_parameters=enc_content_parameters,\n\t    ).pack()\n\tdef _get_protection_gke_from_cache(\n\t    root_key_identifier: t.Optional[uuid.UUID],\n\t    target_sd: bytes,\n\t    cache: KeyCache,\n\t) -> t.Optional[GroupKeyEnvelope]:\n\t    if not root_key_identifier:\n", "        return None\n\t    # MS-GKDI 3.1.4.1 GetKey rules on how to generate the group key identifier\n\t    # values from the current time\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/4cac87a3-521e-4918-a272-240f8fabed39\n\t    current_time = (time.time_ns() // 100) + _EPOCH_FILETIME\n\t    base = 360000000000  # 3.6 * 10**11\n\t    l0 = int(current_time / (32 * 32 * base))\n\t    l1 = int((current_time % (32 * 32 * base)) / (32 * base))\n\t    l2 = int((current_time % (32 * base)) / base)\n\t    rk = cache._get_key(\n", "        target_sd,\n\t        root_key_identifier,\n\t        l0,\n\t        l1,\n\t        l2,\n\t    )\n\t    if not rk:\n\t        return None\n\t    kdf_parameters = KDFParameters.unpack(rk.kdf_parameters)\n\t    l2_key = compute_l2_key(\n", "        kdf_parameters.hash_algorithm,\n\t        l1,\n\t        l2,\n\t        rk,\n\t    )\n\t    return GroupKeyEnvelope(\n\t        version=rk.version,\n\t        flags=rk.flags,\n\t        l0=l0,\n\t        l1=l1,\n", "        l2=l2,\n\t        root_key_identifier=root_key_identifier,\n\t        kdf_algorithm=rk.kdf_algorithm,\n\t        kdf_parameters=rk.kdf_parameters,\n\t        secret_algorithm=rk.secret_algorithm,\n\t        secret_parameters=rk.secret_parameters,\n\t        private_key_length=rk.private_key_length,\n\t        public_key_length=rk.public_key_length,\n\t        domain_name=rk.domain_name,\n\t        forest_name=rk.forest_name,\n", "        l1_key=b\"\",\n\t        l2_key=l2_key,\n\t    )\n\tclass RootKey(t.NamedTuple):\n\t    \"\"\"The KDS Root Key.\"\"\"\n\t    key: bytes\n\t    version: int\n\t    kdf_algorithm: str\n\t    kdf_parameters: bytes\n\t    secret_algorithm: str\n", "    secret_parameters: t.Optional[bytes]\n\t    private_key_length: int\n\t    public_key_length: int\n\tclass KeyCache:\n\t    \"\"\"Key Cache.\n\t    This is a cache used to store the KDS keys. It can be used with\n\t    :meth:`async_ncrypt_unprotect_secret` and :meth:`ncrypt_unprotect_secret`\n\t    to avoid any extra RPC calls if the data was already retrieved.\n\t    \"\"\"\n\t    def __init__(self) -> None:\n", "        self._root_keys: t.Dict[uuid.UUID, RootKey] = {}\n\t        self._seed_keys: t.Dict[uuid.UUID, t.Dict[bytes, t.Dict[int, GroupKeyEnvelope]]] = {}\n\t    def load_key(\n\t        self,\n\t        key: bytes,\n\t        root_key_id: uuid.UUID,\n\t        version: int = 1,\n\t        kdf_algorithm: str = \"SP800_108_CTR_HMAC\",\n\t        kdf_parameters: t.Optional[bytes] = None,\n\t        secret_algorithm: str = \"DH\",\n", "        secret_parameters: t.Optional[bytes] = None,\n\t        private_key_length: int = 512,\n\t        public_key_length: int = 2048,\n\t    ) -> None:\n\t        \"\"\"Load a KDS root key into the cache.\n\t        This loads the KDS root key provided into the cache for use in future\n\t        operations.\n\t        A domain administrator can retrieve the required information from a DC\n\t        using this PowerShell code.\n\t        .. code-block:: powershell\n", "            $configurationContext = (Get-ADRootDSE).configurationNamingContext\n\t            $getParams = @{\n\t                LDAPFilter = '(objectClass=msKds-ProvRootKey)'\n\t                SearchBase = \"CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,$configurationContext\"\n\t                SearchScope = 'OneLevel'\n\t                Properties = @(\n\t                    'cn'\n\t                    'msKds-KDFAlgorithmID'\n\t                    'msKds-KDFParam'\n\t                    'msKds-SecretAgreementAlgorithmID'\n", "                    'msKds-SecretAgreementParam'\n\t                    'msKds-PrivateKeyLength'\n\t                    'msKds-PublicKeyLength'\n\t                    'msKds-RootKeyData'\n\t                )\n\t            }\n\t            Get-ADObject @getParams | ForEach-Object {\n\t                [PSCustomObject]@{\n\t                    Version = 1\n\t                    RootKeyId = [Guid]::new($_.cn)\n", "                    KdfAlgorithm = $_.'msKds-KDFAlgorithmID'\n\t                    KdfParameters = [System.Convert]::ToBase64String($_.'msKds-KDFParam')\n\t                    SecretAgreementAlgorithm = $_.'msKds-SecretAgreementAlgorithmID'\n\t                    SecretAgreementParameters = [System.Convert]::ToBase64String($_.'msKds-SecretAgreementParam')\n\t                    PrivateKeyLength = $_.'msKds-PrivateKeyLength'\n\t                    PublicKeyLength = $_.'msKds-PublicKeyLength'\n\t                    RootKeyData = [System.Convert]::ToBase64String($_.'msKds-RootKeyData')\n\t                }\n\t            }\n\t        It can also be retrieved using this OpenLDAP command:\n", "        .. code-block:: bash\n\t            ldapsearch \\\n\t                -b 'CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,CN=Configuration,DC=domain,DC=test' \\\n\t                -s one \\\n\t                '(objectClass=msKds-ProvRootKey)' \\\n\t                cn \\\n\t                msKds-KDFAlgorithmID \\\n\t                msKds-KDFParam \\\n\t                msKds-SecretAgreementAlgorithmID \\\n\t                msKds-SecretAgreementParam \\\n", "                msKds-PrivateKeyLength \\\n\t                msKds-PublicKeyLength \\\n\t                msKds-RootKeyData\n\t        Args:\n\t            key: The root key bytes stored in ``msKds-RootKeyData``.\n\t            root_key_id: The root key id as stored in ``cn``.\n\t            version: The key version number.\n\t            kdf_algorithm: The KDF algorithm name stored in\n\t                ``msKds-KDFAlgorithmID``.\n\t            kdf_parameters: The KDF parameters stored in ``msKds-KDFParam`.\n", "            secret_algorithm: The secret agreement algorithm stored in\n\t                ``msKds-SecretAgreementAlgorithmID``.\n\t            secret_parameters: The secret agreement parameters stored in\n\t                ``msKds-SecretAgreementParam``.\n\t            private_key_length: The private key length stored in\n\t                ``msKds-PrivateKeyLength``.\n\t            public_key_length: The public key length stored in\n\t                ``msKds-PublicKeyLength``.\n\t        \"\"\"\n\t        if not kdf_parameters:\n", "            kdf_parameters = KDFParameters(\"SHA512\").pack()\n\t        if secret_algorithm == \"DH\" and not secret_parameters:\n\t            # RFC 5114 - 2.3. 2048-bit MODP Group with 256-bit Prime Order Subgroup\n\t            # https://www.rfc-editor.org/rfc/rfc5114#section-2.3\n\t            secret_parameters = FFCDHParameters(\n\t                key_length=256,\n\t                field_order=17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183,\n\t                generator=8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313,\n\t            ).pack()\n\t        self._root_keys[root_key_id] = RootKey(\n", "            key=key,\n\t            version=version,\n\t            kdf_algorithm=kdf_algorithm,\n\t            kdf_parameters=kdf_parameters,\n\t            secret_algorithm=secret_algorithm,\n\t            secret_parameters=secret_parameters,\n\t            private_key_length=private_key_length,\n\t            public_key_length=public_key_length,\n\t        )\n\t    def _get_key(\n", "        self,\n\t        target_sd: bytes,\n\t        root_key_id: uuid.UUID,\n\t        l0: int,\n\t        l1: int,\n\t        l2: int,\n\t    ) -> t.Optional[GroupKeyEnvelope]:\n\t        \"\"\"Get key from the cache.\n\t        Attempts to get the key from a cache if it's available. A key is cached\n\t        either from the root key stored in :meth:`load_key` or from a previous\n", "        RPC call for the same target sd and root key id.\n\t        Args:\n\t            target_sd: The target security descriptor the key is for.\n\t            root_key_id: The root key id requested.\n\t            l0: The L0 index needed.\n\t            l1: The L1 index needed.\n\t            l2: The L2 index needed.\n\t        Returns:\n\t            Optional[GroupKeyEnvelope]: The cached key if one was available.\n\t        \"\"\"\n", "        seed_key = self._seed_keys.setdefault(root_key_id, {}).setdefault(target_sd, {}).get(l0, None)\n\t        if seed_key and (seed_key.l1 > l1 or (seed_key.l1 == l1 and seed_key.l2 >= l2)):\n\t            return seed_key\n\t        root_key = self._root_keys.get(root_key_id, None)\n\t        if root_key:\n\t            l1_seed = compute_l1_key(\n\t                target_sd,\n\t                root_key_id,\n\t                l0,\n\t                root_key.key,\n", "                KDFParameters.unpack(root_key.kdf_parameters).hash_algorithm,\n\t            )\n\t            gke = GroupKeyEnvelope(\n\t                version=root_key.version,\n\t                flags=2,\n\t                l0=l0,\n\t                l1=31,\n\t                l2=31,\n\t                root_key_identifier=root_key_id,\n\t                kdf_algorithm=root_key.kdf_algorithm,\n", "                kdf_parameters=root_key.kdf_parameters,\n\t                secret_algorithm=root_key.secret_algorithm,\n\t                secret_parameters=root_key.secret_parameters or b\"\",\n\t                private_key_length=root_key.private_key_length,\n\t                public_key_length=root_key.public_key_length,\n\t                domain_name=\"\",\n\t                forest_name=\"\",\n\t                l1_key=l1_seed,\n\t                l2_key=b\"\",\n\t            )\n", "            return self._seed_keys.setdefault(root_key_id, {}).setdefault(target_sd, {}).setdefault(l0, gke)\n\t        return None\n\t    def _store_key(\n\t        self,\n\t        target_sd: bytes,\n\t        key: GroupKeyEnvelope,\n\t    ) -> None:\n\t        seed_key = self._seed_keys.setdefault(key.root_key_identifier, {}).setdefault(target_sd, {})\n\t        existing = seed_key.get(key.l0, None)\n\t        if not existing or key.l1 > existing.l1 or (key.l1 == existing.l1 and key.l2 > existing.l2):\n", "            seed_key[key.l0] = key\n\tdef ncrypt_unprotect_secret(\n\t    data: bytes,\n\t    server: t.Optional[str] = None,\n\t    username: t.Optional[str] = None,\n\t    password: t.Optional[str] = None,\n\t    auth_protocol: str = \"negotiate\",\n\t    cache: t.Optional[KeyCache] = None,\n\t) -> bytes:\n\t    \"\"\"Decrypt DPAPI-NG Blob.\n", "    Decrypts the DPAPI-NG blob provided. This is meant to replicate the Win32\n\t    API `NCryptUnprotectSecret`_.\n\t    Decrypting the DPAPI-NG blob requires making an RPC call to the domain\n\t    controller for the domain the blob was created in. It will attempt this\n\t    by looking up the DC through an SRV lookup but ``server`` can be specified\n\t    to avoid this SRV lookup.\n\t    The RPC call requires the caller to authenticate before the key information\n\t    is provided. This user must be one who is authorized to decrypt the secret.\n\t    Explicit credentials can be specified, if none are the current Kerberos\n\t    ticket retrieved by ``kinit`` will be used instead. Make sure to install\n", "    the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure Kerberos auth\n\t    can be used.\n\t    Args:\n\t        data: The DPAPI-NG blob to decrypt.\n\t        server: The domain controller to lookup the root key info.\n\t        username: The username to decrypt the DPAPI-NG blob as.\n\t        password: The password for the user.\n\t        auth_protocol: The authentication protocol to use, defaults to\n\t            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n\t        cache: Optional cache that is used as the key source to avoid making\n", "            the RPC call.\n\t    Returns:\n\t        bytes: The decrypt DPAPI-NG data.\n\t    Raises:\n\t        ValueError: An invalid data structure was found.\n\t        NotImplementedError: An unknown value was found and has not been\n\t            implemented yet.\n\t    _NCryptUnprotectSecret:\n\t        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret\n\t    \"\"\"\n", "    blob = DPAPINGBlob.unpack(data)\n\t    target_sd = blob.protection_descriptor.get_target_sd()\n\t    cache = cache or KeyCache()\n\t    rk = cache._get_key(\n\t        target_sd,\n\t        blob.key_identifier.root_key_identifier,\n\t        blob.key_identifier.l0,\n\t        blob.key_identifier.l1,\n\t        blob.key_identifier.l2,\n\t    )\n", "    if not rk:\n\t        if not server:\n\t            srv = lookup_dc(blob.key_identifier.domain_name)\n\t            server = srv.target\n\t        rk = _sync_get_key(\n\t            server,\n\t            target_sd,\n\t            blob.key_identifier.root_key_identifier,\n\t            blob.key_identifier.l0,\n\t            blob.key_identifier.l1,\n", "            blob.key_identifier.l2,\n\t            username=username,\n\t            password=password,\n\t            auth_protocol=auth_protocol,\n\t        )\n\t    if not rk.is_public_key:\n\t        cache._store_key(target_sd, rk)\n\t    return _decrypt_blob(blob, rk)\n\tdef ncrypt_protect_secret(\n\t    data: bytes,\n", "    protection_descriptor: str,\n\t    root_key_identifier: t.Optional[uuid.UUID] = None,\n\t    server: t.Optional[str] = None,\n\t    domain_name: t.Optional[str] = None,\n\t    username: t.Optional[str] = None,\n\t    password: t.Optional[str] = None,\n\t    auth_protocol: str = \"negotiate\",\n\t    cache: t.Optional[KeyCache] = None,\n\t) -> bytes:\n\t    \"\"\"Encrypt DPAPI-NG Blob.\n", "    Encrypts the blob provided as DPAPI-NG Blob. This is meant to\n\t    replicate the Win32 API `NCryptProtectSecret`_. While NCryptProtectSecret\n\t    supports multiple protection descriptor values, currently only the SID type\n\t    is supported.\n\t    Encrypting the DPAPI-NG blob requires making an RPC call to the domain\n\t    controller for the domain the blob was created in. It will attempt this\n\t    by looking up the DC through an SRV lookup but ``server`` can be specified\n\t    to avoid this SRV lookup.\n\t    The RPC call requires the caller to authenticate before the key information\n\t    is provided. Explicit credentials can be specified, if none are then the\n", "    current Kerberos ticket retrieved by ``kinit`` will be used instead. Make\n\t    sure to install the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure\n\t    Kerberos auth can be used.\n\t    Args:\n\t        data: The bytes blob to encrypt.\n\t        protection_descriptor: The security identifier to protect the secret\n\t            with.\n\t        root_key_identifier: Use the root key identified by this id, if not set,\n\t            the root key id returned by the server will be used.\n\t        server: The domain controller to lookup the root key info.\n", "        domain_name: The domain name to query the domain controller hostname\n\t            via DNS.\n\t        username: The username to encrypt the DPAPI-NG blob as.\n\t        password: The password for the user.\n\t        auth_protocol: The authentication protocol to use, defaults to\n\t            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n\t        cache: Optional cache that is used as the key source to avoid making\n\t            the RPC call. This only works if root_key_identifier is also\n\t            specified.\n\t    Returns:\n", "        bytes: The encrypted DPAPI-NG data.\n\t    Raises:\n\t        ValueError: An invalid data structure was found.\n\t        NotImplementedError: An unknown value was found and has not been\n\t            implemented yet.\n\t    _NCryptProtectSecret:\n\t        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret\n\t    \"\"\"\n\t    l0 = -1\n\t    l1 = -1\n", "    l2 = -1\n\t    descriptor = ProtectionDescriptor.parse(protection_descriptor)\n\t    sd = descriptor.get_target_sd()\n\t    cache = cache or KeyCache()\n\t    rk = _get_protection_gke_from_cache(root_key_identifier, sd, cache)\n\t    if not rk:\n\t        if not server:\n\t            srv = lookup_dc(domain_name)\n\t            server = srv.target\n\t        rk = _sync_get_key(\n", "            server,\n\t            sd,\n\t            root_key_identifier,\n\t            l0,\n\t            l1,\n\t            l2,\n\t            username=username,\n\t            password=password,\n\t            auth_protocol=auth_protocol,\n\t        )\n", "    if not rk.is_public_key:\n\t        cache._store_key(sd, rk)\n\t    return _encrypt_blob(data, rk, descriptor)\n\tasync def async_ncrypt_unprotect_secret(\n\t    data: bytes,\n\t    server: t.Optional[str] = None,\n\t    username: t.Optional[str] = None,\n\t    password: t.Optional[str] = None,\n\t    auth_protocol: str = \"negotiate\",\n\t    cache: t.Optional[KeyCache] = None,\n", ") -> bytes:\n\t    \"\"\"Decrypt DPAPI-NG Blob.\n\t    Decrypts the DPAPI-NG blob provided. This is meant to replicate the Win32\n\t    API `NCryptUnprotectSecret`_.\n\t    Decrypting the DPAPI-NG blob requires making an RPC call to the domain\n\t    controller for the domain the blob was created in. It will attempt this\n\t    by looking up the DC through an SRV lookup but ``server`` can be specified\n\t    to avoid this SRV lookup.\n\t    The RPC call requires the caller to authenticate before the key information\n\t    is provided. This user must be one who is authorized to decrypt the secret.\n", "    Explicit credentials can be specified, if none are the current Kerberos\n\t    ticket retrieved by ``kinit`` will be used instead. Make sure to install\n\t    the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure Kerberos auth\n\t    can be used.\n\t    Args:\n\t        data: The DPAPI-NG blob to decrypt.\n\t        server: The domain controller to lookup the root key info.\n\t        username: The username to decrypt the DPAPI-NG blob as.\n\t        password: The password for the user.\n\t        auth_protocol: The authentication protocol to use, defaults to\n", "            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n\t        cache: Optional cache that is used as the key source to avoid making\n\t            the RPC call.\n\t    Returns:\n\t        bytes: The decrypt DPAPI-NG data.\n\t    Raises:\n\t        ValueError: An invalid data structure was found.\n\t        NotImplementedError: An unknown value was found and has not been\n\t            implemented yet.\n\t    _NCryptUnprotectSecret:\n", "        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret\n\t    \"\"\"\n\t    blob = DPAPINGBlob.unpack(data)\n\t    target_sd = blob.protection_descriptor.get_target_sd()\n\t    cache = cache or KeyCache()\n\t    rk = cache._get_key(\n\t        target_sd,\n\t        blob.key_identifier.root_key_identifier,\n\t        blob.key_identifier.l0,\n\t        blob.key_identifier.l1,\n", "        blob.key_identifier.l2,\n\t    )\n\t    if not rk:\n\t        if not server:\n\t            srv = await async_lookup_dc(blob.key_identifier.domain_name)\n\t            server = srv.target\n\t        rk = await _async_get_key(\n\t            server,\n\t            target_sd,\n\t            blob.key_identifier.root_key_identifier,\n", "            blob.key_identifier.l0,\n\t            blob.key_identifier.l1,\n\t            blob.key_identifier.l2,\n\t            username=username,\n\t            password=password,\n\t            auth_protocol=auth_protocol,\n\t        )\n\t    if not rk.is_public_key:\n\t        cache._store_key(target_sd, rk)\n\t    return _decrypt_blob(blob, rk)\n", "async def async_ncrypt_protect_secret(\n\t    data: bytes,\n\t    protection_descriptor: str,\n\t    root_key_identifier: t.Optional[uuid.UUID] = None,\n\t    server: t.Optional[str] = None,\n\t    domain_name: t.Optional[str] = None,\n\t    username: t.Optional[str] = None,\n\t    password: t.Optional[str] = None,\n\t    auth_protocol: str = \"negotiate\",\n\t    cache: t.Optional[KeyCache] = None,\n", ") -> bytes:\n\t    \"\"\"Encrypt DPAPI-NG Blob.\n\t    Encrypts the blob provided as DPAPI-NG Blob. This is meant to\n\t    replicate the Win32 API `NCryptProtectSecret`_. While NCryptProtectSecret\n\t    supports multiple protection descriptor values, currently only the SID type\n\t    is supported.\n\t    Encrypting the DPAPI-NG blob requires making an RPC call to the domain\n\t    controller for the domain the blob was created in. It will attempt this\n\t    by looking up the DC through an SRV lookup but ``server`` can be specified\n\t    to avoid this SRV lookup.\n", "    The RPC call requires the caller to authenticate before the key information\n\t    is provided. Explicit credentials can be specified, if none are then the\n\t    current Kerberos ticket retrieved by ``kinit`` will be used instead. Make\n\t    sure to install the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure\n\t    Kerberos auth can be used.\n\t    Args:\n\t        data: The bytes blob to encrypt.\n\t        protection_descriptor: The security identifier to protect the secret\n\t            with.\n\t        root_key_identifier: Use the root key identified by this id, if not set,\n", "            the root key id returned by the server will be used.\n\t        server: The domain controller to lookup the root key info.\n\t        domain_name: The domain name to query the domain controller hostname\n\t            via DNS.\n\t        username: The username to encrypt the DPAPI-NG blob as.\n\t        password: The password for the user.\n\t        auth_protocol: The authentication protocol to use, defaults to\n\t            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n\t        cache: Optional cache that is used as the key source to avoid making\n\t            the RPC call. This only works if root_key_identifier is also\n", "            specified.\n\t    Returns:\n\t        bytes: The encrypted DPAPI-NG data.\n\t    Raises:\n\t        ValueError: An invalid data structure was found.\n\t        NotImplementedError: An unknown value was found and has not been\n\t            implemented yet.\n\t    _NCryptProtectSecret:\n\t        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret\n\t    \"\"\"\n", "    l0 = -1\n\t    l1 = -1\n\t    l2 = -1\n\t    descriptor = ProtectionDescriptor.parse(protection_descriptor)\n\t    sd = descriptor.get_target_sd()\n\t    cache = cache or KeyCache()\n\t    rk = _get_protection_gke_from_cache(root_key_identifier, sd, cache)\n\t    if not rk:\n\t        if not server:\n\t            srv = await async_lookup_dc(domain_name)\n", "            server = srv.target\n\t        rk = await _async_get_key(\n\t            server,\n\t            sd,\n\t            root_key_identifier,\n\t            l0,\n\t            l1,\n\t            l2,\n\t            username=username,\n\t            password=password,\n", "            auth_protocol=auth_protocol,\n\t        )\n\t    if not rk.is_public_key:\n\t        cache._store_key(sd, rk)\n\t    return _encrypt_blob(data, rk, descriptor)\n"]}
{"filename": "src/dpapi_ng/_pkcs7.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport typing as t\n\tfrom ._asn1 import ASN1Header, ASN1Reader, ASN1Tag, ASN1Writer, TagClass, TypeTagNumber\n\t@dataclasses.dataclass\n\tclass ContentInfo:\n\t    content_type: str\n\t    content: bytes\n", "    # https://www.rfc-editor.org/rfc/rfc5652#section-3\n\t    #   ContentInfo ::= SEQUENCE {\n\t    #     contentType ContentType,\n\t    #     content [0] EXPLICIT ANY DEFINED BY contentType }\n\t    #   ContentType ::= OBJECT IDENTIFIER\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        with writer.push_sequence() as ci_sequence:\n", "            ci_sequence.write_object_identifier(self.content_type)\n\t            ci_sequence.write_octet_string(\n\t                self.content,\n\t                ASN1Tag(\n\t                    tag_class=TagClass.CONTEXT_SPECIFIC,\n\t                    tag_number=0,\n\t                    is_constructed=True,\n\t                ),\n\t            )\n\t    @classmethod\n", "    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: t.Optional[ASN1Header] = None,\n\t    ) -> ContentInfo:\n\t        reader = ASN1Reader(data).read_sequence(header=header)\n\t        content_type = reader.read_object_identifier(\n\t            hint=\"ContentInfo.contentType\",\n\t        )\n\t        content_tag = ASN1Tag(\n", "            tag_class=TagClass.CONTEXT_SPECIFIC,\n\t            tag_number=0,\n\t            is_constructed=True,\n\t        )\n\t        content = reader.read_octet_string(\n\t            tag=content_tag,\n\t            hint=\"ContentInfo.content\",\n\t        )\n\t        return ContentInfo(content_type, content)\n\t@dataclasses.dataclass\n", "class EnvelopedData:\n\t    CONTENT_TYPE_ENVELOPED_DATA_OID = \"1.2.840.113549.1.7.3\"\n\t    CONTENT_TYPE_DATA_OID = \"1.2.840.113549.1.7.1\"\n\t    version: int\n\t    recipient_infos: t.List[RecipientInfo]\n\t    encrypted_content_info: EncryptedContentInfo\n\t    # https://www.rfc-editor.org/rfc/rfc5652#section-6.1\n\t    #   EnvelopedData ::= SEQUENCE {\n\t    #     version CMSVersion,\n\t    #     originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,\n", "    #     recipientInfos RecipientInfos,\n\t    #     encryptedContentInfo EncryptedContentInfo,\n\t    #     unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\n\t    #   OriginatorInfo ::= SEQUENCE {\n\t    #     certs [0] IMPLICIT CertificateSet OPTIONAL,\n\t    #     crls [1] IMPLICIT RevocationInfoChoices OPTIONAL }\n\t    #   RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo\n\t    #   EncryptedContentInfo ::= SEQUENCE {\n\t    #     contentType ContentType,\n\t    #     contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,\n", "    #     encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }\n\t    #   EncryptedContent ::= OCTET STRING\n\t    #   UnprotectedAttributes ::= SET SIZE (1..MAX) OF Attribute\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        with writer.push_sequence() as w:\n\t            w.write_integer(self.version)\n\t            with w.push_set_of() as recipient_writer:\n", "                for ri in self.recipient_infos:\n\t                    ri.pack(recipient_writer)\n\t            self.encrypted_content_info.pack(w)\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> EnvelopedData:\n\t        reader = ASN1Reader(data).read_sequence()\n\t        version = reader.read_integer(hint=\"EnvelopedData.version\")\n", "        if version != 2:\n\t            raise NotImplementedError(\"Cannot unpack EnvelopedData that is not version 2\")\n\t        recipient_infos: t.List[RecipientInfo] = []\n\t        recipient_infos_reader = reader.read_set_of(hint=\"EnvelopedData.recipientInfos\")\n\t        while recipient_infos_reader:\n\t            info = RecipientInfo.unpack(recipient_infos_reader)\n\t            recipient_infos.append(info)\n\t        enc_content = EncryptedContentInfo.unpack(reader)\n\t        return EnvelopedData(\n\t            version=version,\n", "            recipient_infos=recipient_infos,\n\t            encrypted_content_info=enc_content,\n\t        )\n\t@dataclasses.dataclass\n\tclass RecipientInfo:\n\t    choice: int\n\t    # https://www.rfc-editor.org/rfc/rfc5652#section-6.2\n\t    # RecipientInfo ::= CHOICE {\n\t    #     ktri KeyTransRecipientInfo,\n\t    #     kari [1] KeyAgreeRecipientInfo,\n", "    #     kekri [2] KEKRecipientInfo,\n\t    #     pwri [3] PasswordRecipientinfo,\n\t    #     ori [4] OtherRecipientInfo }\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        raise NotImplementedError()  # pragma: nocover\n\t    @classmethod\n\t    def unpack(\n", "        cls,\n\t        reader: ASN1Reader,\n\t    ) -> RecipientInfo:\n\t        header = reader.peek_header()\n\t        tag = header.tag\n\t        if tag.tag_class == TagClass.CONTEXT_SPECIFIC and tag.tag_number == KEKRecipientInfo.choice:\n\t            return KEKRecipientInfo.unpack(reader, header=header)\n\t        raise NotImplementedError(f\"Unimplemented RecipientInfo choice {tag}\")\n\t@dataclasses.dataclass\n\tclass KEKRecipientInfo(RecipientInfo):\n", "    choice: int = dataclasses.field(init=False, repr=False, default=2)\n\t    version: int\n\t    kekid: KEKIdentifier\n\t    key_encryption_algorithm: AlgorithmIdentifier\n\t    encrypted_key: bytes\n\t    # https://www.rfc-editor.org/rfc/rfc5652#section-6.2.3\n\t    # KEKRecipientInfo ::= SEQUENCE {\n\t    #     version CMSVersion,  -- always set to 4\n\t    #     kekid KEKIdentifier,\n\t    #     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,\n", "    #     encryptedKey EncryptedKey }\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        with writer.push_sequence(\n\t            tag=ASN1Tag(\n\t                tag_class=TagClass.CONTEXT_SPECIFIC,\n\t                tag_number=self.choice,\n\t                is_constructed=True,\n", "            )\n\t        ) as w:\n\t            w.write_integer(self.version)\n\t            self.kekid.pack(w)\n\t            self.key_encryption_algorithm.pack(w)\n\t            w.write_octet_string(self.encrypted_key)\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        reader: ASN1Reader,\n", "        header: t.Optional[ASN1Header] = None,\n\t    ) -> KEKRecipientInfo:\n\t        reader = reader.read_sequence(header=header)\n\t        version = reader.read_integer(hint=\"KEKRecipientInfo.version\")\n\t        kekid = KEKIdentifier.unpack(reader)\n\t        key_encryption_algorithm = AlgorithmIdentifier.unpack(reader)\n\t        encrypted_key = reader.read_octet_string(hint=\"KEKRecipientInfo.encryptedKey\")\n\t        return KEKRecipientInfo(\n\t            version=version,\n\t            kekid=kekid,\n", "            key_encryption_algorithm=key_encryption_algorithm,\n\t            encrypted_key=encrypted_key,\n\t        )\n\t@dataclasses.dataclass\n\tclass KEKIdentifier:\n\t    key_identifier: bytes\n\t    date: t.Optional[str] = None\n\t    other: t.Optional[OtherKeyAttribute] = None\n\t    # https://www.rfc-editor.org/rfc/rfc5652#section-6.2.3\n\t    # KEKIdentifier ::= SEQUENCE {\n", "    #     keyIdentifier OCTET STRING,\n\t    #     date GeneralizedTime OPTIONAL,\n\t    #     other OtherKeyAttribute OPTIONAL }\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        with writer.push_sequence() as w:\n\t            w.write_octet_string(self.key_identifier)\n\t            if self.date:\n", "                w.write_generalized_time(self.date)\n\t            if self.other:\n\t                self.other.pack(w)\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        reader: ASN1Reader,\n\t    ) -> KEKIdentifier:\n\t        reader = reader.read_sequence()\n\t        key_identifier = reader.read_octet_string(hint=\"KEKIdentifier.keyIdentifier\")\n", "        header = reader.peek_header()\n\t        date = None\n\t        if header.tag.tag_class == TagClass.UNIVERSAL and header.tag.tag_number == TypeTagNumber.GENERALIZED_TIME:\n\t            date = reader.read_generalized_time(header=header, hint=\"KEKIdentifier.date\")\n\t            header = reader.peek_header()\n\t        other = None\n\t        if header.tag.tag_class == TagClass.UNIVERSAL and header.tag.tag_number == TypeTagNumber.SEQUENCE:\n\t            other = OtherKeyAttribute.unpack(reader, header=header)\n\t        return KEKIdentifier(\n\t            key_identifier=key_identifier,\n", "            date=date,\n\t            other=other,\n\t        )\n\t@dataclasses.dataclass\n\tclass OtherKeyAttribute:\n\t    key_attr_id: str\n\t    key_attr: t.Optional[bytes]\n\t    # https://www.rfc-editor.org/rfc/rfc5652#section-10.2.7\n\t    # OtherKeyAttribute ::= SEQUENCE {\n\t    #     keyAttrId OBJECT IDENTIFIER,\n", "    #     keyAttr ANY DEFINED BY keyAttrId OPTIONAL }\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        with writer.push_sequence() as w:\n\t            w.write_object_identifier(self.key_attr_id)\n\t            if self.key_attr:\n\t                w.write_raw(self.key_attr)\n\t    @classmethod\n", "    def unpack(\n\t        cls,\n\t        reader: ASN1Reader,\n\t        header: t.Optional[ASN1Header] = None,\n\t    ) -> OtherKeyAttribute:\n\t        reader = reader.read_sequence(header=header)\n\t        key_attr_id = reader.read_object_identifier(hint=\"OtherKeyAttribute.keyAttrId\")\n\t        key_attr = None\n\t        if reader:\n\t            key_attr = reader.get_remaining_data()\n", "        return OtherKeyAttribute(\n\t            key_attr_id=key_attr_id,\n\t            key_attr=key_attr,\n\t        )\n\t@dataclasses.dataclass\n\tclass EncryptedContentInfo:\n\t    content_type: str\n\t    algorithm: AlgorithmIdentifier\n\t    content: t.Optional[bytes]\n\t    # EncryptedContentInfo ::= SEQUENCE {\n", "    #     contentType ContentType,\n\t    #     contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,\n\t    #     encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }\n\t    # ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        with writer.push_sequence() as w:\n\t            w.write_object_identifier(self.content_type)\n", "            self.algorithm.pack(w)\n\t            if self.content:\n\t                w.write_octet_string(\n\t                    self.content,\n\t                    ASN1Tag(\n\t                        tag_class=TagClass.CONTEXT_SPECIFIC,\n\t                        tag_number=0,\n\t                        is_constructed=False,\n\t                    ),\n\t                )\n", "    @classmethod\n\t    def unpack(\n\t        cls,\n\t        reader: ASN1Reader,\n\t    ) -> EncryptedContentInfo:\n\t        reader = reader.read_sequence()\n\t        content_type = reader.read_object_identifier(hint=\"EncryptedContentInfo.contentType\")\n\t        content_encryption_algorithm = AlgorithmIdentifier.unpack(reader)\n\t        enc_content = None\n\t        if reader:\n", "            enc_tag = ASN1Tag(\n\t                tag_class=TagClass.CONTEXT_SPECIFIC,\n\t                tag_number=0,\n\t                is_constructed=False,\n\t            )\n\t            enc_content = reader.read_octet_string(\n\t                enc_tag,\n\t                hint=\"EncryptedContentInfo.encryptedContent\",\n\t            )\n\t        return EncryptedContentInfo(\n", "            content_type=content_type,\n\t            algorithm=content_encryption_algorithm,\n\t            content=enc_content,\n\t        )\n\t@dataclasses.dataclass\n\tclass AlgorithmIdentifier:\n\t    algorithm: str\n\t    parameters: t.Optional[bytes] = None\n\t    # AlgorithmIdentifier ::= SEQUENCE {\n\t    #   algorithm       OBJECT IDENTIFIER,\n", "    #   parameters      ANY DEFINED BY algorithm OPTIONAL\n\t    # }\n\t    def pack(\n\t        self,\n\t        writer: ASN1Writer,\n\t    ) -> None:\n\t        with writer.push_sequence() as w:\n\t            w.write_object_identifier(self.algorithm)\n\t            if self.parameters:\n\t                w.write_raw(self.parameters)\n", "    @classmethod\n\t    def unpack(\n\t        cls,\n\t        reader: ASN1Reader,\n\t    ) -> AlgorithmIdentifier:\n\t        reader = reader.read_sequence()\n\t        algorithm = reader.read_object_identifier()\n\t        parameters = None\n\t        if reader:\n\t            parameters = reader.get_remaining_data()\n", "        return AlgorithmIdentifier(\n\t            algorithm=algorithm,\n\t            parameters=parameters,\n\t        )\n"]}
{"filename": "src/dpapi_ng/_rpc/_verification.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport enum\n\timport typing as t\n\tfrom ._bind import SyntaxId\n\tfrom ._pdu import DataRep, PacketType\n\t# https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/0e9fea61-1bff-4478-9bfe-a3b6d8b64ac3\n\tclass CommandType(enum.IntEnum):\n", "    SEC_VT_COMMAND_BITMASK_1 = 0x0001\n\t    SEC_VT_COMMAND_PCONTEXT = 0x0002\n\t    SEC_VT_COMMAND_HEADER2 = 0x0003\n\t    @classmethod\n\t    def _missing_(cls, value: object) -> t.Optional[enum.Enum]:\n\t        new_member = int.__new__(cls)\n\t        new_member._name_ = f\"CommandType Unknown 0x{value:04X}\"\n\t        new_member._value_ = value  # type: ignore[assignment]\n\t        return cls._value2member_map_.setdefault(value, new_member)\n\tclass CommandFlags(enum.IntFlag):\n", "    NONE = 0x0000\n\t    SEC_VT_COMMAND_END = 0x4000\n\t    SEC_VT_MUST_PROCESS_COMMAND = 0x8000\n\t@dataclasses.dataclass(frozen=True)\n\tclass Command:\n\t    command: CommandType\n\t    flags: CommandFlags\n\t    value: bytes\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n", "            [\n\t                (self.command.value | self.flags.value).to_bytes(2, byteorder=\"little\"),\n\t                len(self.value).to_bytes(2, byteorder=\"little\"),\n\t                self.value,\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n", "    ) -> Command:\n\t        view = memoryview(data)\n\t        cmd_field = int.from_bytes(view[:2], byteorder=\"little\")\n\t        command_type = CommandType(cmd_field & 0x3FFF)\n\t        command_flags = CommandFlags(cmd_field & 0xC000)\n\t        command_length = int.from_bytes(view[2:4], byteorder=\"little\")\n\t        value = view[4 : 4 + command_length].tobytes()\n\t        unpack_func = _COMMAND_TYPE_REGISTRY.get(command_type, None)\n\t        if unpack_func:\n\t            cmd = unpack_func(command_flags, value)\n", "            object.__setattr__(cmd, \"value\", value)\n\t            return cmd\n\t        else:\n\t            return cls(command_type, command_flags, value)\n\tT = t.TypeVar(\"T\")\n\t_COMMAND_TYPE_REGISTRY: t.Dict[CommandType, t.Callable[[CommandFlags, bytes], Command]] = {}\n\tdef register_cmd(cls: T) -> T:\n\t    _COMMAND_TYPE_REGISTRY[getattr(cls, \"command\").default] = getattr(cls, \"_unpack\")\n\t    return cls\n\t@dataclasses.dataclass(frozen=True)\n", "class _KnownCommand(Command):\n\t    value: bytes = dataclasses.field(init=False, repr=False, default=b\"\")\n\t@dataclasses.dataclass(frozen=True)\n\t@register_cmd\n\tclass CommandBitmask(_KnownCommand):\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/35d7781d-6c5b-46b2-9083-3d53f98bef0d\n\t    CLIENT_SUPPORT_HEADER_SIGNING: int = dataclasses.field(init=False, repr=False, default=0x00000001)\n\t    command: CommandType = dataclasses.field(init=False, default=CommandType.SEC_VT_COMMAND_BITMASK_1)\n\t    bits: int\n\t    def pack(self) -> bytes:\n", "        return Command(self.command, self.flags, self.bits.to_bytes(4, byteorder=\"little\")).pack()\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        flags: CommandFlags,\n\t        value: bytes,\n\t    ) -> CommandBitmask:\n\t        return cls(\n\t            flags=flags,\n\t            bits=int.from_bytes(value, byteorder=\"little\"),\n", "        )\n\t@dataclasses.dataclass(frozen=True)\n\t@register_cmd\n\tclass CommandPContext(_KnownCommand):\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/41e3cf7a-3b42-470c-9d27-c4e047ac6445\n\t    command: CommandType = dataclasses.field(init=False, default=CommandType.SEC_VT_COMMAND_PCONTEXT)\n\t    interface_id: SyntaxId\n\t    transfer_syntax: SyntaxId\n\t    def pack(self) -> bytes:\n\t        value = self.interface_id.pack() + self.transfer_syntax.pack()\n", "        return Command(self.command, self.flags, value).pack()\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        flags: CommandFlags,\n\t        value: bytes,\n\t    ) -> CommandPContext:\n\t        interface_id = SyntaxId.unpack(value)\n\t        transfer_syntax = SyntaxId.unpack(value[20:])\n\t        return cls(\n", "            flags=flags,\n\t            interface_id=interface_id,\n\t            transfer_syntax=transfer_syntax,\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\t@register_cmd\n\tclass CommandHeader2(_KnownCommand):\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/0a108fbd-c848-4755-9e15-6c4df1c35134\n\t    command: CommandType = dataclasses.field(init=False, default=CommandType.SEC_VT_COMMAND_HEADER2)\n\t    packet_type: PacketType\n", "    data_rep: DataRep\n\t    call_id: int\n\t    context_id: int\n\t    opnum: int\n\t    def pack(self) -> bytes:\n\t        value = b\"\".join(\n\t            [\n\t                self.packet_type.to_bytes(1, byteorder=\"little\"),\n\t                b\"\\x00\\x00\\x00\",  # Reserved\n\t                self.data_rep.pack(),\n", "                self.call_id.to_bytes(4, byteorder=\"little\"),\n\t                self.context_id.to_bytes(2, byteorder=\"little\"),\n\t                self.opnum.to_bytes(2, byteorder=\"little\"),\n\t            ]\n\t        )\n\t        return Command(self.command, self.flags, value).pack()\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        flags: CommandFlags,\n", "        value: bytes,\n\t    ) -> CommandHeader2:\n\t        view = memoryview(value)\n\t        return cls(\n\t            flags=flags,\n\t            packet_type=PacketType(view[0]),\n\t            data_rep=DataRep.unpack(view[4:8]),\n\t            call_id=int.from_bytes(view[8:12], byteorder=\"little\"),\n\t            context_id=int.from_bytes(view[12:14], byteorder=\"little\"),\n\t            opnum=int.from_bytes(view[14:16], byteorder=\"little\"),\n", "        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass VerificationTrailer:\n\t    signature: bytes = dataclasses.field(init=False, default=b\"\\x8A\\xE3\\x13\\x71\\x02\\xF4\\x36\\x71\")\n\t    commands: t.List[Command]\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                self.signature,\n\t                b\"\".join(c.pack() for c in self.commands),\n", "            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> VerificationTrailer:\n\t        view = memoryview(data)\n\t        if view[:8].tobytes() != cls.signature:\n\t            raise ValueError(f\"Failed to unpack {cls.__name__} as signature header is invalid\")\n", "        view = view[8:]\n\t        commands = []\n\t        while True:\n\t            cmd = Command.unpack(view)\n\t            commands.append(cmd)\n\t            view = view[4 + len(cmd.value) :]\n\t            if cmd.flags & CommandFlags.SEC_VT_COMMAND_END:\n\t                break\n\t        return cls(commands=commands)\n"]}
{"filename": "src/dpapi_ng/_rpc/_pdu.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport enum\n\timport typing as t\n\tclass IntegerRep(enum.IntEnum):\n\t    BIG_ENDIAN = 0\n\t    LITTLE_ENDIAN = 1\n\tclass CharacterRep(enum.IntEnum):\n", "    ASCII = 0\n\t    EBCDIC = 1\n\tclass FloatingPointRep(enum.IntEnum):\n\t    IEEE = 0\n\t    VAX = 1\n\t    CRAY = 2\n\t    IBM = 3\n\tclass PacketType(enum.IntEnum):\n\t    REQUEST = 0\n\t    PING = 1\n", "    RESPONSE = 2\n\t    FAULT = 3\n\t    WORKING = 4\n\t    NOCALL = 5\n\t    REJECT = 6\n\t    ACK = 7\n\t    CL_CANCEL = 8\n\t    FACK = 9\n\t    CANCEL_ACK = 10\n\t    BIND = 11\n", "    BIND_ACK = 12\n\t    BIND_NAK = 13\n\t    ALTER_CONTEXT = 14\n\t    ALTER_CONTEXT_RESP = 15\n\t    SHUTDOWN = 17\n\t    CO_CANCEL = 18\n\t    ORPHANED = 19\n\tclass PacketFlags(enum.IntFlag):\n\t    NONE = 0x00\n\t    PFC_FIRST_FRAG = 0x01\n", "    PFC_LAST_FRAG = 0x02\n\t    PFC_PENDING_CANCEL = 0x04\n\t    PFC_SUPPORT_HEADER_SIGN = 0x04  # MS-RPCE extension used in Bind/AlterContext\n\t    PFC_RESERVED_1 = 0x08\n\t    PFC_CONC_MPX = 0x10\n\t    PFC_DID_NOT_EXECUTE = 0x20\n\t    PFC_MAYBE = 0x40\n\t    PFC_OBJECT_UUID = 0x80\n\t@dataclasses.dataclass(frozen=True)\n\tclass DataRep:\n", "    # https://pubs.opengroup.org/onlinepubs/9629399/chap14.htm\n\t    byte_order: IntegerRep = IntegerRep.LITTLE_ENDIAN\n\t    character: CharacterRep = CharacterRep.ASCII\n\t    floating_point: FloatingPointRep = FloatingPointRep.IEEE\n\t    def pack(self) -> bytes:\n\t        first_octet = self.byte_order << 4 | self.character\n\t        return b\"\".join(\n\t            [\n\t                first_octet.to_bytes(1, byteorder=\"little\"),\n\t                self.floating_point.to_bytes(1, byteorder=\"little\"),\n", "                b\"\\x00\\x00\",\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> DataRep:\n\t        view = memoryview(data)\n\t        return cls(\n", "            byte_order=IntegerRep((view[0] & 0b11110000) >> 4),\n\t            character=CharacterRep(view[0] & 0b00001111),\n\t            floating_point=FloatingPointRep(view[1]),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass PDUHeader:\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n\t    version: int\n\t    version_minor: int\n\t    packet_type: PacketType\n", "    packet_flags: PacketFlags\n\t    data_rep: DataRep\n\t    frag_len: int\n\t    auth_len: int\n\t    call_id: int\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                self.version.to_bytes(1, byteorder=\"little\"),\n\t                self.version_minor.to_bytes(1, byteorder=\"little\"),\n", "                self.packet_type.to_bytes(1, byteorder=\"little\"),\n\t                self.packet_flags.to_bytes(1, byteorder=\"little\"),\n\t                self.data_rep.pack(),\n\t                self.frag_len.to_bytes(2, byteorder=\"little\"),\n\t                self.auth_len.to_bytes(2, byteorder=\"little\"),\n\t                self.call_id.to_bytes(4, byteorder=\"little\"),\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n", "        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> PDUHeader:\n\t        view = memoryview(data)\n\t        return cls(\n\t            version=view[0],\n\t            version_minor=view[1],\n\t            packet_type=PacketType(view[2]),\n\t            packet_flags=PacketFlags(view[3]),\n\t            data_rep=DataRep.unpack(view[4:8]),\n", "            frag_len=int.from_bytes(view[8:10], byteorder=\"little\"),\n\t            auth_len=int.from_bytes(view[10:12], byteorder=\"little\"),\n\t            call_id=int.from_bytes(view[12:16], byteorder=\"little\"),\n\t        )\n\tclass SecurityProvider(enum.IntEnum):\n\t    RPC_C_AUTHN_NONE = 0x00\n\t    RPC_C_AUTHN_GSS_NEGOTIATE = 0x09\n\t    RPC_C_AUTHN_WINNT = 0x0A\n\t    RPC_C_AUTHN_GSS_SCHANNEL = 0x0E\n\t    RPC_C_AUTHN_GSS_KERBEROS = 0x10\n", "    RPC_C_AUTHN_NETLOGON = 0x44\n\t    RPC_C_AUTHN_DEFAULT = 0xFF\n\tclass AuthenticationLevel(enum.IntEnum):\n\t    RPC_C_AUTHN_LEVEL_DEFAULT = 0x00\n\t    RPC_C_AUTHN_LEVEL_NONE = 0x01\n\t    RPC_C_AUTHN_LEVEL_CONNECT = 0x02\n\t    RPC_C_AUTHN_LEVEL_CALL = 0x03\n\t    RPC_C_AUTHN_LEVEL_PKT = 0x04\n\t    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = 0x05\n\t    RPC_C_AUTHN_LEVEL_PKT_PRIVACY = 0x06\n", "@dataclasses.dataclass(frozen=True)\n\tclass SecTrailer:\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap13.htm\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/ab45c6a5-951a-4096-b805-7347674dc6ab\n\t    type: SecurityProvider\n\t    level: AuthenticationLevel\n\t    pad_length: int\n\t    context_id: int\n\t    auth_value: bytes\n\t    def pack(self) -> bytes:\n", "        return b\"\".join(\n\t            [\n\t                self.type.to_bytes(1, byteorder=\"little\"),\n\t                self.level.to_bytes(1, byteorder=\"little\"),\n\t                self.pad_length.to_bytes(1, byteorder=\"little\"),\n\t                b\"\\x00\",  # Auth-Rsrvd\n\t                self.context_id.to_bytes(4, byteorder=\"little\"),\n\t                self.auth_value,\n\t            ]\n\t        )\n", "    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> SecTrailer:\n\t        view = memoryview(data)\n\t        return cls(\n\t            type=SecurityProvider(view[0]),\n\t            level=AuthenticationLevel(view[1]),\n\t            pad_length=view[2],\n", "            context_id=int.from_bytes(view[4:8], byteorder=\"little\"),\n\t            auth_value=view[8:].tobytes(),\n\t        )\n\tT = t.TypeVar(\"T\")\n\t_PACKET_TYPE_REGISTRY: t.Dict[PacketType, t.Callable[[memoryview, PDUHeader, t.Optional[SecTrailer]], PDU]] = {}\n\t@dataclasses.dataclass(frozen=True)\n\tclass PDU:\n\t    header: PDUHeader\n\t    sec_trailer: t.Optional[SecTrailer]\n\t    def pack(self) -> bytes:\n", "        raise NotImplementedError()  # pragma: nocover\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> PDU:\n\t        view = memoryview(data)\n\t        header = PDUHeader.unpack(view)\n\t        view = view[16 : header.frag_len]\n\t        sec_trailer = None\n", "        if header.auth_len:\n\t            sec_trailer = SecTrailer.unpack(view[-(header.auth_len + 8) :])\n\t            view = view[: -(header.auth_len + 8)]\n\t        return _PACKET_TYPE_REGISTRY[header.packet_type](\n\t            view,\n\t            header,\n\t            sec_trailer,\n\t        )\n\tdef register_pdu(packet_type: PacketType) -> t.Callable[[T], T]:\n\t    def wrap(cls: T) -> T:\n", "        _PACKET_TYPE_REGISTRY[packet_type] = getattr(cls, \"_unpack\")\n\t        return cls\n\t    return wrap\n\tclass FaultFlags(enum.IntFlag):\n\t    NONE = 0x00\n\t    EXTENDED_ERROR_PRESENT = 0x01\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.FAULT)\n\tclass Fault(PDU):\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n", "    alloc_hint: int\n\t    context_id: int\n\t    cancel_count: int\n\t    status: int\n\t    flags: FaultFlags  # Extension of MS-RPCE\n\t    stub_data: bytes\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                self.header.pack(),\n", "                self.alloc_hint.to_bytes(4, byteorder=\"little\"),\n\t                self.context_id.to_bytes(2, byteorder=\"little\"),\n\t                self.cancel_count.to_bytes(1, byteorder=\"little\"),\n\t                self.flags.to_bytes(1, byteorder=\"little\"),\n\t                self.status.to_bytes(4, byteorder=\"little\"),\n\t                b\"\\x00\\x00\\x00\\x00\",  # alignment padding\n\t                self.stub_data,\n\t                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n\t            ]\n\t        )\n", "    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n\t        sec_trailer: t.Optional[SecTrailer],\n\t    ) -> Fault:\n\t        view = memoryview(data)\n\t        return cls(\n\t            header=header,\n", "            sec_trailer=sec_trailer,\n\t            alloc_hint=int.from_bytes(view[:4], byteorder=\"little\"),\n\t            context_id=int.from_bytes(view[4:6], byteorder=\"little\"),\n\t            cancel_count=view[6],\n\t            flags=FaultFlags(view[7]),\n\t            status=int.from_bytes(view[8:12], byteorder=\"little\"),\n\t            stub_data=view[16:].tobytes(),\n\t        )\n"]}
{"filename": "src/dpapi_ng/_rpc/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\tfrom ._bind import (\n\t    AlterContext,\n\t    AlterContextResponse,\n\t    Bind,\n\t    BindAck,\n\t    BindNak,\n\t    BindTimeFeatureNegotiation,\n", "    ContextElement,\n\t    ContextResult,\n\t    ContextResultCode,\n\t    SyntaxId,\n\t    bind_time_feature_negotiation,\n\t)\n\tfrom ._client import (\n\t    NDR,\n\t    NDR64,\n\t    AsyncRpcClient,\n", "    SyncRpcClient,\n\t    async_create_rpc_connection,\n\t    create_rpc_connection,\n\t)\n\tfrom ._pdu import (\n\t    AuthenticationLevel,\n\t    CharacterRep,\n\t    DataRep,\n\t    Fault,\n\t    FaultFlags,\n", "    FloatingPointRep,\n\t    IntegerRep,\n\t    PacketFlags,\n\t    PacketType,\n\t    PDUHeader,\n\t    SecTrailer,\n\t    SecurityProvider,\n\t)\n\tfrom ._request import Request, Response\n\tfrom ._verification import (\n", "    Command,\n\t    CommandBitmask,\n\t    CommandFlags,\n\t    CommandHeader2,\n\t    CommandPContext,\n\t    CommandType,\n\t    VerificationTrailer,\n\t)\n\t__all__ = [\n\t    \"NDR\",\n", "    \"NDR64\",\n\t    \"AlterContext\",\n\t    \"AlterContextResponse\",\n\t    \"AsyncRpcClient\",\n\t    \"AuthenticationLevel\",\n\t    \"Bind\",\n\t    \"BindAck\",\n\t    \"BindNak\",\n\t    \"BindTimeFeatureNegotiation\",\n\t    \"CharacterRep\",\n", "    \"Command\",\n\t    \"CommandBitmask\",\n\t    \"CommandFlags\",\n\t    \"CommandHeader2\",\n\t    \"CommandPContext\",\n\t    \"CommandType\",\n\t    \"ContextElement\",\n\t    \"ContextResult\",\n\t    \"ContextResultCode\",\n\t    \"DataRep\",\n", "    \"Fault\",\n\t    \"FaultFlags\",\n\t    \"FloatingPointRep\",\n\t    \"IntegerRep\",\n\t    \"PacketFlags\",\n\t    \"PacketType\",\n\t    \"PDUHeader\",\n\t    \"SecTrailer\",\n\t    \"SecurityProvider\",\n\t    \"SyncRpcClient\",\n", "    \"SyntaxId\",\n\t    \"Request\",\n\t    \"Response\",\n\t    \"VerificationTrailer\",\n\t    \"async_create_rpc_connection\",\n\t    \"bind_time_feature_negotiation\",\n\t    \"create_rpc_connection\",\n\t]\n"]}
{"filename": "src/dpapi_ng/_rpc/_bind.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport enum\n\timport typing as t\n\timport uuid\n\tfrom ._pdu import PDU, PacketType, PDUHeader, SecTrailer, register_pdu\n\tclass BindTimeFeatureNegotiation(enum.IntFlag):\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/cef529cc-77b5-4794-85dc-91e1467e80f0\n", "    NONE = 0x00\n\t    SECURITY_CONTEXT_MULTIPLEXING = 0x01\n\t    KEEP_CONNECTION_ON_ORPHAN = 0x02\n\t@dataclasses.dataclass(frozen=True)\n\tclass SyntaxId:\n\t    uuid: uuid.UUID\n\t    version: int\n\t    version_minor: int\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n", "            [\n\t                self.uuid.bytes_le,\n\t                self.version.to_bytes(2, byteorder=\"little\"),\n\t                self.version_minor.to_bytes(2, byteorder=\"little\"),\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n", "    ) -> SyntaxId:\n\t        view = memoryview(data)\n\t        return cls(\n\t            uuid=uuid.UUID(bytes_le=view[:16].tobytes()),\n\t            version=int.from_bytes(view[16:18], byteorder=\"little\"),\n\t            version_minor=int.from_bytes(view[18:20], byteorder=\"little\"),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass ContextElement:\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n", "    context_id: int\n\t    abstract_syntax: SyntaxId\n\t    transfer_syntaxes: t.List[SyntaxId]\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                self.context_id.to_bytes(2, byteorder=\"little\"),\n\t                len(self.transfer_syntaxes).to_bytes(2, byteorder=\"little\"),\n\t                self.abstract_syntax.pack(),\n\t                b\"\".join([t.pack() for t in self.transfer_syntaxes]),\n", "            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> ContextElement:\n\t        view = memoryview(data)\n\t        context_id = int.from_bytes(view[:2], byteorder=\"little\")\n\t        num_transfers = int.from_bytes(view[2:4], byteorder=\"little\")\n", "        abstract_syntax = SyntaxId.unpack(view[4:])\n\t        view = view[24:]\n\t        transfer_syntaxes = []\n\t        for _ in range(num_transfers):\n\t            transfer_syntaxes.append(SyntaxId.unpack(view))\n\t            view = view[20:]\n\t        return cls(\n\t            context_id=context_id,\n\t            abstract_syntax=abstract_syntax,\n\t            transfer_syntaxes=transfer_syntaxes,\n", "        )\n\tclass ContextResultCode(enum.IntEnum):\n\t    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/8df5c4d4-364d-468c-81fe-ec94c1b40917\n\t    ACCEPTANCE = 0\n\t    USER_REJECTION = 1\n\t    PROVIDER_REJECTION = 2\n\t    NEGOTIATE_ACK = 3  # MS-RPCE extension\n\t@dataclasses.dataclass(frozen=True)\n\tclass ContextResult:\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n", "    result: ContextResultCode\n\t    reason: int\n\t    syntax: uuid.UUID\n\t    syntax_version: int\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                self.result.to_bytes(2, byteorder=\"little\"),\n\t                self.reason.to_bytes(2, byteorder=\"little\"),\n\t                self.syntax.bytes_le,\n", "                self.syntax_version.to_bytes(4, byteorder=\"little\"),\n\t            ]\n\t        )\n\t    @classmethod\n\t    def unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t    ) -> ContextResult:\n\t        view = memoryview(data)\n\t        return cls(\n", "            result=ContextResultCode(int.from_bytes(view[:2], byteorder=\"little\")),\n\t            reason=int.from_bytes(view[2:4], byteorder=\"little\"),\n\t            syntax=uuid.UUID(bytes_le=view[4:20].tobytes()),\n\t            syntax_version=int.from_bytes(view[20:24], byteorder=\"little\"),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.BIND)\n\tclass Bind(PDU):\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n\t    max_xmit_frag: int\n", "    max_recv_frag: int\n\t    assoc_group: int\n\t    contexts: t.List[ContextElement]\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                self.header.pack(),\n\t                self.max_xmit_frag.to_bytes(2, byteorder=\"little\"),\n\t                self.max_recv_frag.to_bytes(2, byteorder=\"little\"),\n\t                self.assoc_group.to_bytes(4, byteorder=\"little\"),\n", "                len(self.contexts).to_bytes(4, byteorder=\"little\"),\n\t                b\"\".join(c.pack() for c in self.contexts),\n\t                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n\t            ]\n\t        )\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n", "        sec_trailer: t.Optional[SecTrailer],\n\t    ) -> Bind:\n\t        view = memoryview(data)\n\t        max_xmit_frag = int.from_bytes(view[:2], byteorder=\"little\")\n\t        max_recv_frag = int.from_bytes(view[2:4], byteorder=\"little\")\n\t        assoc_group = int.from_bytes(view[4:8], byteorder=\"little\")\n\t        num_contexts = view[8]\n\t        view = view[12:]\n\t        contexts = []\n\t        for _ in range(num_contexts):\n", "            c = ContextElement.unpack(view)\n\t            contexts.append(c)\n\t            view = view[24 + (len(c.transfer_syntaxes) * 20) :]\n\t        return cls(\n\t            header=header,\n\t            sec_trailer=sec_trailer,\n\t            max_xmit_frag=max_xmit_frag,\n\t            max_recv_frag=max_recv_frag,\n\t            assoc_group=assoc_group,\n\t            contexts=contexts,\n", "        )\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.BIND_ACK)\n\tclass BindAck(PDU):\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n\t    max_xmit_frag: int\n\t    max_recv_frag: int\n\t    assoc_group: int\n\t    sec_addr: str\n\t    results: t.List[ContextResult]\n", "    def pack(self) -> bytes:\n\t        b_sec_addr = b\"\"\n\t        if self.sec_addr:\n\t            b_sec_addr = self.sec_addr.encode(\"utf-8\") + b\"\\x00\"\n\t        sec_addr_len = len(b_sec_addr)\n\t        padding = -(2 + sec_addr_len) % 4\n\t        b_result = b\"\".join([r.pack() for r in self.results])\n\t        return b\"\".join(\n\t            [\n\t                self.header.pack(),\n", "                self.max_xmit_frag.to_bytes(2, byteorder=\"little\"),\n\t                self.max_recv_frag.to_bytes(2, byteorder=\"little\"),\n\t                self.assoc_group.to_bytes(4, byteorder=\"little\"),\n\t                sec_addr_len.to_bytes(2, byteorder=\"little\"),\n\t                b_sec_addr,\n\t                b\"\\x00\" * padding,\n\t                len(self.results).to_bytes(4, byteorder=\"little\"),\n\t                b_result,\n\t                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n\t            ]\n", "        )\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n\t        sec_trailer: t.Optional[SecTrailer],\n\t    ) -> BindAck:\n\t        view = memoryview(data)\n\t        max_xmit_frag = int.from_bytes(view[:2], byteorder=\"little\")\n", "        max_recv_frag = int.from_bytes(view[2:4], byteorder=\"little\")\n\t        assoc_group = int.from_bytes(view[4:8], byteorder=\"little\")\n\t        sec_addr_len = int.from_bytes(view[8:10], byteorder=\"little\")\n\t        sec_addr = view[10 : 10 + sec_addr_len - 1].tobytes().decode(\"utf-8\")\n\t        padding = -(2 + sec_addr_len) % 4\n\t        view = view[10 + sec_addr_len + padding :]\n\t        num_result = view[0]\n\t        view = view[4:]\n\t        results = []\n\t        for _ in range(num_result):\n", "            results.append(ContextResult.unpack(view))\n\t            view = view[24:]\n\t        return cls(\n\t            header=header,\n\t            sec_trailer=sec_trailer,\n\t            max_xmit_frag=max_xmit_frag,\n\t            max_recv_frag=max_recv_frag,\n\t            assoc_group=assoc_group,\n\t            sec_addr=sec_addr,\n\t            results=results,\n", "        )\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.BIND_NAK)\n\tclass BindNak(PDU):\n\t    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n\t    reject_reason: int\n\t    versions: t.List[tuple[int, int]]\n\t    def pack(self) -> bytes:\n\t        protocols = [v[0].to_bytes(1, byteorder=\"little\") + v[1].to_bytes(1, byteorder=\"little\") for v in self.versions]\n\t        b_versions = b\"\".join(\n", "            [\n\t                len(protocols).to_bytes(1, byteorder=\"little\"),\n\t                b\"\".join(protocols),\n\t            ]\n\t        )\n\t        padding = -(2 + len(b_versions)) % 4\n\t        return b\"\".join(\n\t            [\n\t                self.header.pack(),\n\t                self.reject_reason.to_bytes(2, byteorder=\"little\"),\n", "                b_versions,\n\t                b\"\\x00\" * padding,\n\t            ]\n\t        )\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n\t        sec_trailer: t.Optional[SecTrailer],\n", "    ) -> BindNak:\n\t        view = memoryview(data)\n\t        reject_reason = int.from_bytes(view[:2], byteorder=\"little\")\n\t        versions = []\n\t        num_versions = view[2]\n\t        view = view[3:]\n\t        for _ in range(num_versions):\n\t            versions.append((view[0], view[1]))\n\t            view = view[2:]\n\t        return cls(\n", "            header=header,\n\t            sec_trailer=None,\n\t            reject_reason=reject_reason,\n\t            versions=versions,\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.ALTER_CONTEXT)\n\tclass AlterContext(Bind):\n\t    @classmethod\n\t    def _unpack(\n", "        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n\t        sec_trailer: t.Optional[SecTrailer],\n\t    ) -> AlterContext:\n\t        return Bind._unpack.__func__(cls, data, header, sec_trailer)  # type: ignore[attr-defined]\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.ALTER_CONTEXT_RESP)\n\tclass AlterContextResponse(BindAck):\n\t    @classmethod\n", "    def _unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n\t        sec_trailer: t.Optional[SecTrailer],\n\t    ) -> AlterContextResponse:\n\t        return BindAck._unpack.__func__(cls, data, header, sec_trailer)  # type: ignore[attr-defined]\n\tdef bind_time_feature_negotiation(\n\t    flags: BindTimeFeatureNegotiation = BindTimeFeatureNegotiation.NONE,\n\t) -> SyntaxId:\n", "    \"\"\"Creates the Bind Time Feature Negotiation Syntax value from the flags specified.\"\"\"\n\t    return SyntaxId(\n\t        uuid=uuid.UUID(fields=(0x6CB71C2C, 0x9812, 0x4540, flags, 0, 0)),\n\t        version=1,\n\t        version_minor=0,\n\t    )\n"]}
{"filename": "src/dpapi_ng/_rpc/_auth.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport typing as t\n\timport spnego\n\timport spnego.iov\n\tfrom ._pdu import AuthenticationLevel, SecTrailer, SecurityProvider\n\tclass AuthenticationProvider:\n\t    def __init__(\n\t        self,\n", "        username: t.Optional[str] = None,\n\t        password: t.Optional[str] = None,\n\t        hostname: str = \"unspecified\",\n\t        protocol: str = \"negotiate\",\n\t    ) -> None:\n\t        self.ctx = spnego.client(\n\t            username,\n\t            password,\n\t            hostname=hostname,\n\t            service=\"host\",\n", "            protocol=protocol,\n\t            context_req=spnego.ContextReq.default | spnego.ContextReq.dce_style,\n\t        )\n\t        self.provider = {\n\t            \"negotiate\": SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n\t            \"ntlm\": SecurityProvider.RPC_C_AUTHN_WINNT,\n\t            \"kerberos\": SecurityProvider.RPC_C_AUTHN_GSS_KERBEROS,\n\t        }[protocol]\n\t        self._header_length = 0\n\t    @property\n", "    def complete(self) -> bool:\n\t        return self.ctx.complete\n\t    def step(\n\t        self,\n\t        in_token: t.Optional[bytes] = None,\n\t    ) -> SecTrailer:\n\t        out_token = self.ctx.step(in_token) or b\"\"\n\t        return SecTrailer(\n\t            type=self.provider,\n\t            level=AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n", "            pad_length=0,\n\t            context_id=0,\n\t            auth_value=out_token,\n\t        )\n\t    def get_empty_trailer(self, pad_length: int) -> SecTrailer:\n\t        header_length = self._header_length = self._header_length or self.ctx.query_message_sizes().header\n\t        return SecTrailer(\n\t            type=self.provider,\n\t            level=AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n\t            pad_length=pad_length,\n", "            context_id=0,\n\t            auth_value=b\"\\x00\" * header_length,\n\t        )\n\t    def wrap(\n\t        self,\n\t        header: bytes,\n\t        body: bytes,\n\t        trailer: bytes,\n\t        sign_header: bool,\n\t    ) -> bytes:\n", "        sign_buffer_type = spnego.iov.BufferType.sign_only if sign_header else spnego.iov.BufferType.data_readonly\n\t        res = self.ctx.wrap_iov(\n\t            [\n\t                (sign_buffer_type, header),\n\t                body,\n\t                (sign_buffer_type, trailer),\n\t                spnego.iov.BufferType.header,\n\t            ],\n\t            encrypt=True,\n\t            qop=None,\n", "        )\n\t        return b\"\".join(\n\t            [\n\t                header,\n\t                res.buffers[1].data or b\"\",\n\t                trailer,\n\t                res.buffers[3].data or b\"\",\n\t            ]\n\t        )\n\t    def unwrap(\n", "        self,\n\t        header: bytes,\n\t        body: bytes,\n\t        trailer: bytes,\n\t        signature: bytes,\n\t        sign_header: bool,\n\t    ) -> bytes:\n\t        sign_buffer_type = spnego.iov.BufferType.sign_only if sign_header else spnego.iov.BufferType.data_readonly\n\t        res = self.ctx.unwrap_iov(\n\t            [\n", "                (sign_buffer_type, header),\n\t                body,\n\t                (sign_buffer_type, trailer),\n\t                (spnego.iov.BufferType.header, signature),\n\t            ],\n\t        )\n\t        return res.buffers[1].data or b\"\"\n"]}
{"filename": "src/dpapi_ng/_rpc/_client.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport asyncio\n\timport concurrent.futures\n\timport socket\n\timport typing as t\n\timport uuid\n\tfrom ._auth import AuthenticationProvider\n\tfrom ._bind import (\n", "    AlterContext,\n\t    AlterContextResponse,\n\t    Bind,\n\t    BindAck,\n\t    BindNak,\n\t    ContextElement,\n\t    ContextResultCode,\n\t    SyntaxId,\n\t)\n\tfrom ._pdu import PDU, DataRep, Fault, PacketFlags, PacketType, PDUHeader, SecTrailer\n", "from ._request import Request, Response\n\tfrom ._verification import VerificationTrailer\n\tNDR = SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)\n\tNDR64 = SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)\n\tT = t.TypeVar(\"T\")\n\tasync def async_create_rpc_connection(\n\t    server: str,\n\t    port: int = 135,\n\t    connection_timeout: int = 5,\n\t    username: t.Optional[str] = None,\n", "    password: t.Optional[str] = None,\n\t    auth_protocol: t.Optional[str] = None,\n\t) -> AsyncRpcClient:\n\t    auth_provider = None\n\t    if auth_protocol:\n\t        auth_provider = AuthenticationProvider(username, password, server, auth_protocol)\n\t    conn_future = asyncio.open_connection(server, port=port)\n\t    reader, writer = await asyncio.wait_for(conn_future, connection_timeout)\n\t    return AsyncRpcClient(reader, writer, auth_provider)\n\tdef create_rpc_connection(\n", "    server: str,\n\t    port: int = 135,\n\t    connection_timeout: int = 5,\n\t    username: t.Optional[str] = None,\n\t    password: t.Optional[str] = None,\n\t    auth_protocol: t.Optional[str] = None,\n\t) -> SyncRpcClient:\n\t    auth_provider = None\n\t    if auth_protocol:\n\t        auth_provider = AuthenticationProvider(username, password, server, auth_protocol)\n", "    sock = socket.create_connection(\n\t        (server, port),\n\t        timeout=connection_timeout,\n\t    )\n\t    sock.settimeout(None)\n\t    return SyncRpcClient(sock, auth_provider)\n\tclass RpcClient:\n\t    def __init__(\n\t        self,\n\t        auth: t.Optional[AuthenticationProvider] = None,\n", "    ) -> None:\n\t        self._auth = auth\n\t        self._sign_header = False\n\t    def _create_pdu_header(\n\t        self,\n\t        packet_type: PacketType,\n\t        auth_len: int,\n\t        call_id: int,\n\t        *,\n\t        flags: PacketFlags = PacketFlags.NONE,\n", "    ) -> PDUHeader:\n\t        return PDUHeader(\n\t            version=5,\n\t            version_minor=0,\n\t            packet_type=packet_type,\n\t            packet_flags=flags | PacketFlags.PFC_FIRST_FRAG | PacketFlags.PFC_LAST_FRAG,\n\t            data_rep=DataRep(),\n\t            frag_len=0,  # Set after building the PDU\n\t            auth_len=auth_len,\n\t            call_id=call_id,\n", "        )\n\t    def _create_bind(\n\t        self,\n\t        contexts: t.List[ContextElement],\n\t        sec_trailer: t.Optional[SecTrailer] = None,\n\t    ) -> Bind:\n\t        flags = PacketFlags.NONE\n\t        auth_len = 0\n\t        if sec_trailer:\n\t            self._sign_header = True\n", "            flags |= PacketFlags.PFC_SUPPORT_HEADER_SIGN\n\t            auth_len = len(sec_trailer.auth_value)\n\t        return Bind(\n\t            header=self._create_pdu_header(\n\t                PacketType.BIND,\n\t                auth_len,\n\t                1,\n\t                flags=flags,\n\t            ),\n\t            sec_trailer=sec_trailer,\n", "            max_xmit_frag=5840,\n\t            max_recv_frag=5840,\n\t            assoc_group=0,\n\t            contexts=contexts,\n\t        )\n\t    def _create_alter_context(\n\t        self,\n\t        contexts: t.List[ContextElement],\n\t        sec_trailer: SecTrailer,\n\t    ) -> AlterContext:\n", "        flags = PacketFlags.PFC_SUPPORT_HEADER_SIGN if self._sign_header else PacketFlags.NONE\n\t        return AlterContext(\n\t            header=self._create_pdu_header(\n\t                PacketType.ALTER_CONTEXT,\n\t                len(sec_trailer.auth_value),\n\t                1,\n\t                flags=flags,\n\t            ),\n\t            sec_trailer=sec_trailer,\n\t            max_xmit_frag=5840,\n", "            max_recv_frag=5840,\n\t            assoc_group=0,\n\t            contexts=contexts,\n\t        )\n\t    def _create_request(\n\t        self,\n\t        context_id: int,\n\t        opnum: int,\n\t        stub_data: bytes,\n\t        *,\n", "        verification_trailer: t.Optional[VerificationTrailer] = None,\n\t    ) -> tuple[Request, t.Optional[tuple[int, int]]]:\n\t        if verification_trailer:\n\t            # The verification trailer needs to be aligned to the next 4 byte\n\t            # boundary.\n\t            padding = -len(stub_data) % 4\n\t            stub_data += (b\"\\x00\" * padding) + verification_trailer.pack()\n\t        auth_len = 0\n\t        sec_trailer = None\n\t        encrypt_offsets = None\n", "        if self._auth:\n\t            # If the security trailer is present it must be aligned to the\n\t            # next 16 byte boundary after the stub data. This padding is\n\t            # included as part of the stub data to be encrypted.\n\t            pad_length = -len(stub_data) % 16\n\t            stub_data += b\"\\x00\" * pad_length\n\t            sec_trailer = self._auth.get_empty_trailer(pad_length)\n\t            auth_len = len(sec_trailer.auth_value)\n\t            encrypt_offsets = (24, 24 + len(stub_data))\n\t        return (\n", "            Request(\n\t                header=self._create_pdu_header(\n\t                    PacketType.REQUEST,\n\t                    auth_len,\n\t                    1,\n\t                ),\n\t                sec_trailer=sec_trailer,\n\t                alloc_hint=len(stub_data),\n\t                context_id=context_id,\n\t                opnum=opnum,\n", "                obj=None,\n\t                stub_data=stub_data,\n\t            ),\n\t            encrypt_offsets,\n\t        )\n\t    def _prepare_pdu(\n\t        self,\n\t        pdu: PDU,\n\t        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n\t    ) -> t.Union[bytes, bytearray]:\n", "        b_pdu: t.Union[bytes, bytearray] = bytearray(pdu.pack())\n\t        view = memoryview(b_pdu)\n\t        view[8:10] = len(b_pdu).to_bytes(2, byteorder=\"little\")\n\t        if self._auth and encrypt_offsets:\n\t            view = memoryview(b_pdu)\n\t            header = view[: encrypt_offsets[0]].tobytes()\n\t            body = view[encrypt_offsets[0] : encrypt_offsets[1]].tobytes()\n\t            sec_trailer = view[encrypt_offsets[1] : encrypt_offsets[1] + 8].tobytes()\n\t            b_pdu = self._auth.wrap(header, body, sec_trailer, self._sign_header)\n\t        return b_pdu\n", "    def _process_bind_ack(\n\t        self,\n\t        ack: t.Union[BindAck, AlterContextResponse],\n\t        contexts: t.List[ContextElement],\n\t    ) -> tuple[t.List[ContextElement], t.Optional[bytes]]:\n\t        alter_contexts = []\n\t        for idx, c in enumerate(contexts):\n\t            context_res = ack.results[idx]\n\t            if context_res.result == ContextResultCode.ACCEPTANCE:\n\t                alter_contexts.append(c)\n", "        if not ack.header.packet_flags & PacketFlags.PFC_SUPPORT_HEADER_SIGN:\n\t            self._sign_header = False\n\t        auth_value = None\n\t        if ack.sec_trailer:\n\t            auth_value = ack.sec_trailer.auth_value\n\t        return alter_contexts, auth_value\n\t    def _process_response(\n\t        self,\n\t        response: bytearray,\n\t        pdu_header: PDUHeader,\n", "        resp_type: t.Type[T],\n\t        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n\t    ) -> T:\n\t        if self._auth and encrypt_offsets and pdu_header.auth_len:\n\t            view = memoryview(response)\n\t            sec_trailer_offset = pdu_header.frag_len - (pdu_header.auth_len + 8)\n\t            header = view[: encrypt_offsets[0]].tobytes()\n\t            body = view[encrypt_offsets[0] : sec_trailer_offset].tobytes()\n\t            sec_trailer = view[sec_trailer_offset : sec_trailer_offset + 8].tobytes()\n\t            signature = view[sec_trailer_offset + 8 :].tobytes()\n", "            dec_stub = self._auth.unwrap(header, body, sec_trailer, signature, self._sign_header)\n\t            response[encrypt_offsets[0] : sec_trailer_offset] = dec_stub\n\t        pdu_resp = PDU.unpack(response)\n\t        if isinstance(pdu_resp, BindNak):\n\t            raise ValueError(f\"Received BindNack with reason 0x{pdu_resp.reject_reason:08X}\")\n\t        elif isinstance(pdu_resp, Fault):\n\t            raise ValueError(f\"Receive Fault with status 0x{pdu_resp.status:08X}\")\n\t        elif not isinstance(pdu_resp, resp_type):\n\t            raise ValueError(\n\t                f\"Received unexpected PDU response of {type(pdu_resp).__name__} when expecting {resp_type.__name__}\"\n", "            )\n\t        return pdu_resp\n\tclass AsyncRpcClient(RpcClient):\n\t    def __init__(\n\t        self,\n\t        reader: asyncio.StreamReader,\n\t        writer: asyncio.StreamWriter,\n\t        auth: t.Optional[AuthenticationProvider] = None,\n\t    ) -> None:\n\t        super().__init__(auth)\n", "        self._reader = reader\n\t        self._writer = writer\n\t    async def __aenter__(self) -> AsyncRpcClient:\n\t        return self\n\t    async def __aexit__(\n\t        self,\n\t        *args: t.Any,\n\t        **kwargs: t.Any,\n\t    ) -> None:\n\t        await self.close()\n", "    async def close(self) -> None:\n\t        self._writer.close()\n\t        await self._writer.wait_closed()\n\t    async def bind(\n\t        self,\n\t        contexts: t.List[ContextElement],\n\t    ) -> BindAck:\n\t        sec_trailer = None\n\t        if self._auth:\n\t            sec_trailer = await self._wrap_sync(self._auth.step)\n", "        bind = self._create_bind(contexts, sec_trailer)\n\t        bind_ack = await self._send_pdu(bind, BindAck)\n\t        if not self._auth:\n\t            return bind_ack\n\t        final_contexts, in_token = self._process_bind_ack(bind_ack, contexts)\n\t        while not self._auth.complete:\n\t            sec_trailer = await self._wrap_sync(self._auth.step, (in_token or b\"\"))\n\t            if not sec_trailer.auth_value:\n\t                break\n\t            alter_context = self._create_alter_context(final_contexts, sec_trailer)\n", "            alter_resp = await self._send_pdu(alter_context, AlterContextResponse)\n\t            _, in_token = self._process_bind_ack(alter_resp, final_contexts)\n\t        return bind_ack\n\t    async def request(\n\t        self,\n\t        context_id: int,\n\t        opnum: int,\n\t        stub_data: bytes,\n\t        *,\n\t        verification_trailer: t.Optional[VerificationTrailer] = None,\n", "    ) -> Response:\n\t        req, encrypt_offsets = self._create_request(\n\t            context_id,\n\t            opnum,\n\t            stub_data,\n\t            verification_trailer=verification_trailer,\n\t        )\n\t        return await self._send_pdu(req, Response, encrypt_offsets=encrypt_offsets)\n\t    async def _send_pdu(\n\t        self,\n", "        pdu: PDU,\n\t        resp_type: t.Type[T],\n\t        *,\n\t        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n\t    ) -> T:\n\t        b_pdu = self._prepare_pdu(pdu, encrypt_offsets)\n\t        self._writer.write(b_pdu)\n\t        await self._writer.drain()\n\t        header = await self._reader.readexactly(16)\n\t        resp_header = PDUHeader.unpack(header)\n", "        resp = bytearray(resp_header.frag_len)\n\t        view = memoryview(resp)\n\t        view[:16] = header\n\t        view[16:] = await self._reader.readexactly(len(resp) - 16)\n\t        return self._process_response(resp, resp_header, resp_type, encrypt_offsets)\n\t    async def _wrap_sync(\n\t        self,\n\t        func: t.Callable[..., T],\n\t        *args: t.Any,\n\t    ) -> T:\n", "        exec = concurrent.futures.ThreadPoolExecutor()\n\t        return await asyncio.get_event_loop().run_in_executor(exec, func, *args)\n\tclass SyncRpcClient(RpcClient):\n\t    def __init__(\n\t        self,\n\t        sock: socket.socket,\n\t        auth: t.Optional[AuthenticationProvider] = None,\n\t    ) -> None:\n\t        super().__init__(auth)\n\t        self._sock = sock\n", "    def __enter__(self) -> SyncRpcClient:\n\t        return self\n\t    def __exit__(self, *args: t.Any, **kwargs: t.Any) -> None:\n\t        self.close()\n\t    def close(self) -> None:\n\t        try:\n\t            self._sock.shutdown(socket.SHUT_RDWR)\n\t        except OSError:\n\t            # The socket has already been shutdown for some other reason\n\t            pass\n", "        self._sock.close()\n\t    def bind(\n\t        self,\n\t        contexts: t.List[ContextElement],\n\t    ) -> BindAck:\n\t        sec_trailer = None\n\t        if self._auth:\n\t            sec_trailer = self._auth.step()\n\t        bind = self._create_bind(contexts, sec_trailer)\n\t        bind_ack = self._send_pdu(bind, BindAck)\n", "        if not self._auth:\n\t            return bind_ack\n\t        final_contexts, in_token = self._process_bind_ack(bind_ack, contexts)\n\t        while not self._auth.complete:\n\t            sec_trailer = self._auth.step(in_token or b\"\")\n\t            if not sec_trailer.auth_value:\n\t                break\n\t            alter_context = self._create_alter_context(final_contexts, sec_trailer)\n\t            alter_resp = self._send_pdu(alter_context, AlterContextResponse)\n\t            _, in_token = self._process_bind_ack(alter_resp, final_contexts)\n", "        return bind_ack\n\t    def request(\n\t        self,\n\t        context_id: int,\n\t        opnum: int,\n\t        stub_data: bytes,\n\t        *,\n\t        verification_trailer: t.Optional[VerificationTrailer] = None,\n\t    ) -> Response:\n\t        req, encrypt_offsets = self._create_request(\n", "            context_id,\n\t            opnum,\n\t            stub_data,\n\t            verification_trailer=verification_trailer,\n\t        )\n\t        return self._send_pdu(req, Response, encrypt_offsets=encrypt_offsets)\n\t    def _send_pdu(\n\t        self,\n\t        pdu: PDU,\n\t        resp_type: t.Type[T],\n", "        *,\n\t        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n\t    ) -> T:\n\t        b_pdu = self._prepare_pdu(pdu, encrypt_offsets)\n\t        self._sock.sendall(b_pdu)\n\t        header = self._sock.recv(16)\n\t        resp_header = PDUHeader.unpack(header)\n\t        resp = bytearray(resp_header.frag_len)\n\t        view = memoryview(resp)\n\t        view[:16] = header\n", "        view = view[16:]\n\t        while view:\n\t            read = self._sock.recv_into(view)\n\t            view = view[read:]\n\t        return self._process_response(resp, resp_header, resp_type, encrypt_offsets)\n"]}
{"filename": "src/dpapi_ng/_rpc/_request.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n\t# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\tfrom __future__ import annotations\n\timport dataclasses\n\timport typing as t\n\timport uuid\n\tfrom ._pdu import PDU, PacketFlags, PacketType, PDUHeader, SecTrailer, register_pdu\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.REQUEST)\n\tclass Request(PDU):\n", "    alloc_hint: int\n\t    context_id: int\n\t    opnum: int\n\t    obj: t.Optional[uuid.UUID]\n\t    stub_data: bytes\n\t    def pack(self) -> bytes:\n\t        return b\"\".join(\n\t            [\n\t                self.header.pack(),\n\t                self.alloc_hint.to_bytes(4, byteorder=\"little\"),\n", "                self.context_id.to_bytes(2, byteorder=\"little\"),\n\t                self.opnum.to_bytes(2, byteorder=\"little\"),\n\t                self.obj.bytes_le if self.obj else b\"\",\n\t                self.stub_data,\n\t                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n\t            ]\n\t        )\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n", "        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n\t        sec_trailer: t.Optional[SecTrailer],\n\t    ) -> Request:\n\t        view = memoryview(data)\n\t        alloc_hint = int.from_bytes(view[:4], byteorder=\"little\")\n\t        context_id = int.from_bytes(view[4:6], byteorder=\"little\")\n\t        opnum = int.from_bytes(view[6:8], byteorder=\"little\")\n\t        view = view[8:]\n\t        obj = None\n", "        if header.packet_flags & PacketFlags.PFC_OBJECT_UUID:\n\t            obj = uuid.UUID(bytes_le=view[:16].tobytes())\n\t            view = view[16:]\n\t        return cls(\n\t            header=header,\n\t            sec_trailer=sec_trailer,\n\t            alloc_hint=alloc_hint,\n\t            context_id=context_id,\n\t            opnum=opnum,\n\t            obj=obj,\n", "            stub_data=view.tobytes(),\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\t@register_pdu(PacketType.RESPONSE)\n\tclass Response(PDU):\n\t    alloc_hint: int\n\t    context_id: int\n\t    cancel_count: int\n\t    stub_data: bytes\n\t    def pack(self) -> bytes:\n", "        return b\"\".join(\n\t            [\n\t                self.header.pack(),\n\t                self.alloc_hint.to_bytes(4, byteorder=\"little\"),\n\t                self.context_id.to_bytes(2, byteorder=\"little\"),\n\t                self.cancel_count.to_bytes(1, byteorder=\"little\"),\n\t                b\"\\x00\",  # reserved\n\t                self.stub_data,\n\t                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n\t            ]\n", "        )\n\t    @classmethod\n\t    def _unpack(\n\t        cls,\n\t        data: t.Union[bytes, bytearray, memoryview],\n\t        header: PDUHeader,\n\t        sec_trailer: t.Optional[SecTrailer],\n\t    ) -> Response:\n\t        view = memoryview(data)\n\t        return cls(\n", "            header=header,\n\t            sec_trailer=sec_trailer,\n\t            alloc_hint=int.from_bytes(view[:4], byteorder=\"little\"),\n\t            context_id=int.from_bytes(view[4:6], byteorder=\"little\"),\n\t            cancel_count=view[6],\n\t            stub_data=view[8:].tobytes(),\n\t        )\n"]}
