{"filename": "scripts/import_content.py", "chunked_list": ["import os\n\timport sys\n\tfrom pathlib import Path\n\t# FIXME: CHANGE THIS TO GETTING PATH\n\tROOT_DIR = str(Path(os.path.abspath(__file__)).parent.parent)\n\tsys.path.append(ROOT_DIR)\n\timport asyncio\n\tfrom argparse import ArgumentParser\n\tfrom datetime import UTC, datetime, timedelta\n\tfrom uuid import uuid4\n", "import pandas as pd\n\tfrom skill.db.repos.get_repo import get_repo\n\tfrom skill.entities import Activity, Tip, TipsTopic\n\tfrom skill.utils import TextWithTTS\n\tdef prep(s: str) -> str:\n\t    return s.replace('\"', \"\")\n\tasync def extract_activities(activities: pd.DataFrame) -> list[Activity]:\n\t    activities_to_insert: list[Activity] = []\n\t    for _, row in activities.iterrows():\n\t        hours, minutes = list(map(lambda x: int(x), row[2].split(\":\")))\n", "        activities_to_insert.append(\n\t            Activity(\n\t                uuid4(),\n\t                TextWithTTS(row[0], row[1]),\n\t                occupation_time=timedelta(hours=hours, minutes=minutes),\n\t                repo=repo,\n\t                created_date=datetime.utcnow().astimezone(UTC),\n\t            )\n\t        )\n\t    return activities_to_insert\n", "async def extract_tips_topics(\n\t    tips_topics: pd.DataFrame,\n\t) -> list[TipsTopic]:\n\t    tips_topics_to_insert: list[TipsTopic] = []\n\t    for _, row in tips_topics.iterrows():\n\t        tips_topics_to_insert.append(\n\t            TipsTopic(\n\t                uuid4(),\n\t                TextWithTTS(\n\t                    prep(row.iloc[0]).lower().strip(), prep(row.iloc[1])\n", "                ),\n\t                TextWithTTS(prep(row.iloc[2]), prep(row.iloc[3])),\n\t                created_date=datetime.utcnow().astimezone(UTC),\n\t                repo=repo,\n\t            )\n\t        )\n\t    return tips_topics_to_insert\n\tasync def extract_tips(\n\t    tips: pd.DataFrame,\n\t) -> list[Tip]:\n", "    tips_to_insert: list[Tip] = []\n\t    for _, row in tips.iterrows():\n\t        # topic = list(\n\t        #     filter(\n\t        #         lambda tips_topic: tips_topic.name.text.lower()\n\t        #         == row.topic_name.lower(),\n\t        #         tips_topics,\n\t        #     )\n\t        # )[0]\n\t        # if not topic:\n", "        #     raise ValueError(\n\t        #         f\"No topic with next name: {row.topic_name}\\n\"\n\t        #         f\"This error found in row with next data: {row}\"\n\t        # )\n\t        topic_name = prep(row.iloc[4]).lower().strip()\n\t        topic = await repo.get_tips_topic_by_name(topic_name)\n\t        if not topic:\n\t            print(f\"No topic with such topic name: {topic_name}\")\n\t            sys.exit()\n\t        tips_to_insert.append(\n", "            Tip(\n\t                uuid4(),\n\t                TextWithTTS(prep(row.iloc[0]), prep(row.iloc[1])),\n\t                TextWithTTS(prep(row.iloc[2]), prep(row.iloc[3])),\n\t                tips_topic=topic,\n\t                created_date=datetime.utcnow().astimezone(UTC),\n\t                repo=repo,\n\t            )\n\t        )\n\t    return tips_to_insert\n", "if __name__ == \"__main__\":\n\t    parser = ArgumentParser(\n\t        description=\"Manager for tips and activities content\"\n\t    )\n\t    parser.add_argument(\n\t        \"-a\",\n\t        \"--activities\",\n\t        action=\"store_true\",\n\t        help=\"either drop all activities and import new ones or not\",\n\t    )\n", "    parser.add_argument(\n\t        \"-T\",\n\t        \"--tips\",\n\t        action=\"store_true\",\n\t        help=\"either drop all tips topics with all tips and\"\n\t        \"import new ones or not\",\n\t    )\n\t    args = vars(parser.parse_args())\n\t    if not (args.get(\"activities\") or args.get(\"tips\")):\n\t        print(\n", "            \"At least one correct argument should be provided. \"\n\t            \"If you need help, add --help flag\"\n\t        )\n\t        sys.exit()\n\t    repo = get_repo(\"sa\")\n\t    loop = asyncio.get_event_loop()\n\t    if args.get(\"activities\"):\n\t        activities = pd.read_csv(\n\t            ROOT_DIR + \"/content/activities.csv\", index_col=False\n\t        )\n", "        extracted_activities = loop.run_until_complete(\n\t            extract_activities(activities)\n\t        )\n\t        loop.run_until_complete(repo.delete_all_activities())\n\t        loop.run_until_complete(repo.insert_activities(extracted_activities))\n\t    if args.get(\"tips\"):\n\t        tips_topics = pd.read_csv(\n\t            ROOT_DIR + \"/content/tips_topics.csv\", index_col=False\n\t        )\n\t        extracted_topics = loop.run_until_complete(\n", "            extract_tips_topics(tips_topics)\n\t        )\n\t        loop.run_until_complete(repo.delete_all_tips_topics())\n\t        loop.run_until_complete(repo.insert_tips_topics(extracted_topics))\n\t        tips = pd.read_csv(ROOT_DIR + \"/content/tips.csv\", index_col=False)\n\t        extracted_tips = loop.run_until_complete(extract_tips(tips))\n\t        loop.run_until_complete(repo.delete_all_tips())\n\t        loop.run_until_complete(repo.insert_tips(extracted_tips))\n\t    print(\"Content successfully imported!\")\n\t    loop.close()\n"]}
{"filename": "tests/sa_db_settings.py", "chunked_list": ["import os\n\tfrom pathlib import Path\n\tfrom dotenv import load_dotenv\n\tfrom sqlalchemy import event\n\tfrom sqlalchemy.engine import Engine\n\tfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom skill.db.repos.sa_repo import SARepoConfig\n\tload_dotenv()\n\t# Needed for some developing features\n", "# Should be False when production\n\tDEBUG = os.getenv(\"BOT_TOKEN\") or False\n\tDB_PROVIDER = os.getenv(\"TEST_DB_PROVIDER\") or \"sqlite\"\n\tmatch DB_PROVIDER:\n\t    case \"postgres\":\n\t        POSTGRES_DRIVER_NAME = (\n\t            os.getenv(\"TEST_POSTGRES_DRIVER_NAME\") or \"asyncpg\"\n\t        )\n\t        POSTGRES_DB_NAME = os.getenv(\"TEST_POSTGRES_DB_NAME\") or \"postgres\"\n\t        POSTGRES_USERNAME = os.getenv(\"TEST_POSTGRES_USERNAME\") or \"postgres\"\n", "        POSTGRES_HOST = os.getenv(\"TEST_POSTGRES_HOST\") or \"localhost\"\n\t        POSTGRES_DB_PORT = os.getenv(\"TEST_POSTGRES_PORT\") or \"5432\"\n\t        POSTGRES_PASSWORD = os.getenv(\"TEST_POSTGRES_PASSWORD\") or \"postgres\"\n\t        if not POSTGRES_PASSWORD:\n\t            raise EnvironmentError(\n\t                \"POSTGRES_PASSWORD required if you are using PostgreSQL\"\n\t            )\n\t        DB_URL = (\n\t            f\"postgresql+{POSTGRES_DRIVER_NAME}://\"\n\t            + f\"{POSTGRES_USERNAME}:{POSTGRES_PASSWORD}\"\n", "            + f\"@{POSTGRES_HOST}:{POSTGRES_DB_PORT}\"\n\t            + f\"/{POSTGRES_DB_NAME}\"\n\t        )\n\t    case _:\n\t        SQLITE_DRIVER_NAME = (\n\t            os.getenv(\"TEST_SQLITE_DRIVER_NAME\") or \"aiosqlite\"\n\t        )\n\t        SQLITE_DB_NAME = os.getenv(\"TEST_SQLITE_DB_NAME\") or \"SAMPLEDATA.db\"\n\t        ROOT_DIR = Path(__file__).parent.parent.parent.resolve()\n\t        # In case you want to change path to SQLite DB file,\n", "        # just change this variable\n\t        SQLITE_DB_FILE_PATH = os.getenv(\n\t            \"TEST_SQLITE_DB_FILE_PATH\"\n\t        ) or os.path.join(ROOT_DIR, f\"{SQLITE_DB_NAME}\")\n\t        # URL for your database\n\t        DB_URL = f\"sqlite+{SQLITE_DRIVER_NAME}:///\" + SQLITE_DB_FILE_PATH\n\tengine = create_async_engine(DB_URL, echo=False)\n\tasync_session = sessionmaker(  # type: ignore\n\t    engine, expire_on_commit=False, class_=AsyncSession  # type: ignore\n\t)\n", "sa_repo_config = SARepoConfig(connection_provider=async_session)\n\tif DB_PROVIDER == \"sqlite\":\n\t    @event.listens_for(Engine, \"connect\")\n\t    def set_sqlite_pragma(dbapi_connection, connection_record):\n\t        cursor = dbapi_connection.cursor()\n\t        cursor.execute(\"PRAGMA foreign_keys=ON\")\n\t        cursor.close()\n"]}
{"filename": "tests/test_dataconvert.py", "chunked_list": ["import datetime\n\tfrom skill.dataconvert.ya_converter import YaDataConverter\n\tdef test_data_convert():\n\t    dataconvert = YaDataConverter()\n\t    test_obj = {\n\t        \"type\": \"YANDEX.DATETIME\",\n\t        \"value\": {\n\t            \"year\": 1982,\n\t            \"month\": 9,\n\t            \"day\": 15,\n", "            \"hour\": 22,\n\t            \"minute\": 30,\n\t        }\n\t    }\n\t    converted1 = dataconvert.datetime(test_obj, \"UTC\")\n\t    needed1 = datetime.datetime(1982, 9, 15, 22, 30, tzinfo=datetime.UTC)\n\t    assert converted1 == needed1\n\t    converted2 = dataconvert.time(test_obj, \"UTC\")\n\t    needed2 = datetime.time(22, 30, tzinfo=datetime.UTC)\n\t    assert converted2 == needed2\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_api.py", "chunked_list": ["import requests as r\n\tfrom skill.states import States\n\tTIME_REQUEST = {\n\t    \"meta\": {\n\t        \"locale\": \"ru-RU\",\n\t        \"timezone\": \"Europe/Moscow\",\n\t        \"client_id\": \"ru.yandex.searchplugin/7.16 (none none; android 4.4.2)\",\n\t        \"interfaces\": {\"screen\": {}, \"account_linking\": {}, \"audio_player\": {}},\n\t    },\n\t    \"request\": {\n", "        \"command\": \"Во сколько мне надо лечь, чтобы встать в 7:00\",\n\t        \"type\": \"SimpleUtterance\",\n\t        \"nlu\": {\n\t            \"intents\": {\n\t                \"sleep_calc\": {\n\t                    \"slots\": {\n\t                        \"time\": {\n\t                            \"type\": \"YANDEX.DATETIME\",\n\t                            \"value\": {\"hour\": 7, \"minute\": 0},\n\t                        }\n", "                    }\n\t                }\n\t            }\n\t        },\n\t    },\n\t    \"session\": {\n\t        \"message_id\": 0,\n\t        \"session_id\": \"2eac4854-fce721f3-b845abba-20d60\",\n\t        \"skill_id\": \"3ad36498-f5rd-4079-a14b-788652932056\",\n\t        \"user_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\",\n", "        \"user\": {\n\t            \"user_id\": \"6C91DA5198D1758C6A9F63A7C5CDDF09359F683B13A18A151FBF4C8B092BB0C2\",\n\t            \"access_token\": \"AgAAAAAB4vpbAAApoR1oaCd5yR6eiXSHqOGT8dT\",\n\t        },\n\t        \"application\": {\n\t            \"application_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\"\n\t        },\n\t        \"new\": True,\n\t    },\n\t    \"state\": {\n", "        \"session\": {\"value\": 10},\n\t        \"user\": {\"value\": 42},\n\t        \"application\": {\"value\": 37},\n\t    },\n\t    \"version\": \"1.0\",\n\t}\n\tdef make_request(command: str) -> dict:\n\t    return {\n\t        \"meta\": {\n\t            \"locale\": \"ru-RU\",\n", "            \"timezone\": \"Europe/Moscow\",\n\t            \"client_id\": \"ru.yandex.searchplugin/5.80 (Samsung Galaxy; Android 4.4)\",\n\t            \"interfaces\": {\"screen\": {}, \"account_linking\": {}},\n\t        },\n\t        \"request\": {\n\t            \"command\": command,\n\t            \"original_utterance\": command,\n\t            \"type\": \"SimpleUtterance\",\n\t            \"markup\": {\"dangerous_context\": True},\n\t            \"payload\": {},\n", "        },\n\t        \"session\": {\n\t            \"message_id\": 0,\n\t            \"session_id\": \"2eac4854-fce721f3-b845abba-20d60\",\n\t            \"skill_id\": \"3ad36498-f5rd-4079-a14b-788652932056\",\n\t            \"user_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\",\n\t            \"user\": {\n\t                \"user_id\": \"6C91DA5198D1758C6A9F63A7C5CDDF09359F683B13A18A151FBF4C8B092BB0C2\",\n\t                \"access_token\": \"AgAAAAAB4vpbAAApoR1oaCd5yR6eiXSHqOGT8dT\",\n\t            },\n", "            \"application\": {\n\t                \"application_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\"\n\t            },\n\t            \"new\": True,\n\t        },\n\t        \"version\": \"1.0\",\n\t    }\n\tdef make_test(req: dict | str, target_state: str):\n\t    if type(req) == str:\n\t        req = make_request(req)\n", "    resp = r.post(\"http://localhost:5555/\", json=req)\n\t    resp = resp.json()\n\t    print(resp)\n\t    assert resp[\"application_state\"] == target_state.lower()\n\tdef test_handler_main_func_short():\n\t    make_test(\"Привет\", str(States.MAIN_MENU))\n\t    make_test(TIME_REQUEST, str(States.IN_CALCULATOR))\n\t    make_test(\"Долгий\", str(States.CALCULATED))\n\t    make_test(\"Да\", str(States.MAIN_MENU))\n\t    # make_test(\"Ночной сон\", str(States.MAIN_MENU))\n", "def test_handler_main_func_long():\n\t    make_test(\"Я хочу спать\", str(States.TIME_PROPOSED))\n\t    make_test(\"Да\", str(States.IN_CALCULATOR))\n\t    make_test(\"Короткий\", str(States.CALCULATED))\n\t    make_test(\"Меню\", str(States.MAIN_MENU))\n\tdef test_handler_ask_tip():\n\t    make_test(\"Посоветуй\", str(States.ASKING_FOR_TIP))\n\t    make_test(\"Ночной сон\", str(States.MAIN_MENU))\n\tdef test_handler_info():\n\t    make_test(\"Расскажи о навыке\", str(States.MAIN_MENU))\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["import asyncio\n\timport pytest\n\timport pytest_asyncio\n\tfrom skill.db.models.sa_models import BaseModel\n\tfrom tests.sa_db_settings import engine\n\t@pytest.fixture(scope=\"session\")\n\tdef event_loop():\n\t    loop = asyncio.new_event_loop()\n\t    yield loop\n\t    loop.close()\n", "@pytest_asyncio.fixture()\n\tasync def init_db() -> None:\n\t    async with engine.begin() as conn:\n\t        await conn.run_sync(BaseModel.metadata.drop_all)\n\t        await conn.run_sync(BaseModel.metadata.create_all)\n"]}
{"filename": "tests/db/test_repo.py", "chunked_list": ["import random\n\tfrom datetime import UTC, datetime, time, timedelta, timezone\n\tfrom uuid import uuid4\n\timport pytest\n\timport pytest_asyncio\n\tfrom skill.db.repos.base_repo import BaseRepo\n\tfrom skill.db.repos.sa_repo import SARepo\n\tfrom skill.entities import Activity, Tip, TipsTopic, User\n\tfrom skill.exceptions import NoSuchEntityInDB\n\tfrom skill.utils import TextWithTTS\n", "from tests.sa_db_settings import sa_repo_config\n\trepos_to_test = (SARepo(sa_repo_config),)\n\tdef generate_random_string_id() -> str:\n\t    return \"\".join(\n\t        (random.choice(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"))\n\t        for x in range(64)\n\t    )\n\t# @pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest_asyncio.fixture()\n\tasync def insert_values(repo: BaseRepo, init_db):\n", "    now = datetime.now(UTC)\n\t    user = User(\n\t        id=generate_random_string_id(),\n\t        streak=0,\n\t        last_skill_use=now,\n\t        heard_tips=[],\n\t        last_wake_up_time=time(12, 5, 30),\n\t        join_date=now,\n\t        repo=repo,\n\t    )\n", "    new_user = User(\n\t        id=generate_random_string_id(),\n\t        streak=100,\n\t        last_skill_use=None,\n\t        heard_tips=[],\n\t        last_wake_up_time=time(12, 5, 30),\n\t        join_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_users([user, new_user])\n", "    topic = TipsTopic(\n\t        uuid4(),\n\t        TextWithTTS(\"Дневные советы\", \"Дн+евные сов+еты\"),\n\t        TextWithTTS(\n\t            \"Ну тупо какие-то дневные советы, а почему бы и нет\",\n\t            \"Ну т+упо как+ие-то дневн+ые сов+еты, а почем+у бы и нет\",\n\t        ),\n\t        now,\n\t        repo,\n\t    )\n", "    new_topic = TipsTopic(\n\t        uuid4(),\n\t        TextWithTTS(\"Newtopic\", \"Newt+opic\"),\n\t        TextWithTTS(\n\t            \"Just a new topic, nothing much\",\n\t            \"Just a new t+opic, n+othing much\",\n\t        ),\n\t        datetime.now(),\n\t        repo,\n\t    )\n", "    await repo.insert_tips_topics([topic, new_topic])\n\t    tip = Tip(\n\t        uuid4(),\n\t        short_description=TextWithTTS(\n\t            \"Ну тупо какой-то дневной совет, а почему бы и нет\",\n\t            \"Ну т+упо как+ой-то дневн+ой сов+ет, а почем+у бы и нет\",\n\t        ),\n\t        tip_content=TextWithTTS(\n\t            \"Ну тупо какой-то дневной совет, а почему бы и нет\",\n\t            \"Ну т+упо как+ой-то дневн+ой сов+ет, а почем+у бы и нет\",\n", "        ),\n\t        tips_topic=topic,\n\t        created_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_tip(tip)\n\t    activity = Activity(\n\t        uuid4(),\n\t        TextWithTTS(\"Сходить посрать\", \"Сходить в окно\"),\n\t        occupation_time=timedelta(hours=23, minutes=59, seconds=59),\n", "        created_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_activity(activity)\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_users(repo: BaseRepo, init_db):\n\t    now = datetime.now()\n\t    user = User(\n\t        id=generate_random_string_id(),\n", "        streak=0,\n\t        last_skill_use=now,\n\t        heard_tips=[],\n\t        last_wake_up_time=time(12, 5, 30),\n\t        join_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_user(user)\n\t    deleted_user = await repo.delete_user(user)\n\t    assert deleted_user == user\n", "    with pytest.raises(NoSuchEntityInDB):\n\t        await repo.delete_user(user)\n\t    with pytest.raises(NoSuchEntityInDB):\n\t        user.increase_streak()\n\t        await repo.update_user(user)\n\t    assert await repo.get_user_by_id(user._id) is None\n\t    new_user = User(\n\t        id=generate_random_string_id(),\n\t        streak=0,\n\t        last_skill_use=None,\n", "        heard_tips=[],\n\t        last_wake_up_time=time(12, 5, 30),\n\t        join_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_users([user, new_user])\n\t    users_list = await repo.get_users()\n\t    assert user in users_list and new_user in users_list\n\t    user_from_repo = await repo.get_user_by_id(user._id)\n\t    assert user == user_from_repo\n", "@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_activities(repo: BaseRepo, init_db):\n\t    now = datetime.now()\n\t    activity = Activity(\n\t        uuid4(),\n\t        TextWithTTS(\"Сходить посрать\", \"Сходить в окно\"),\n\t        occupation_time=timedelta(hours=23, minutes=59, seconds=59),\n\t        created_date=now,\n\t        repo=repo,\n", "    )\n\t    await repo.insert_activity(activity)\n\t    deleted_activity = await repo.delete_activity(activity)\n\t    assert deleted_activity == activity\n\t    with pytest.raises(NoSuchEntityInDB):\n\t        await repo.delete_activity(activity)\n\t    with pytest.raises(NoSuchEntityInDB):\n\t        activity.description = TextWithTTS(\n\t            \"Huge description\", \"+Huge description\"\n\t        )\n", "        await repo.update_activity(activity)\n\t    assert await repo.get_activity_by_id(activity._id) is None\n\t    new_activity = Activity(\n\t        uuid4(),\n\t        TextWithTTS(\"Сходить в Лувр\", \"Сходить в Третьяковку\"),\n\t        occupation_time=timedelta(\n\t            hours=0, minutes=0, seconds=0, milliseconds=0, microseconds=1\n\t        ),\n\t        created_date=now,\n\t        repo=repo,\n", "    )\n\t    await repo.insert_activities([activity, new_activity])\n\t    activities_list = await repo.get_activities()\n\t    assert activity in activities_list and new_activity in activities_list\n\t    activity_from_repo = await repo.get_activity_by_id(activity._id)\n\t    assert activity == activity_from_repo\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_tips_topics(repo: BaseRepo, init_db):\n\t    now = datetime.now()\n", "    topic = TipsTopic(\n\t        uuid4(),\n\t        TextWithTTS(\"Дневные советы\", \"Дн+евные сов+еты\"),\n\t        TextWithTTS(\n\t            \"Ну тупо какие-то дневные советы, а почему бы и нет\",\n\t            \"Ну т+упо как+ие-то дневн+ые сов+еты, а почем+у бы и нет\",\n\t        ),\n\t        now,\n\t        repo,\n\t    )\n", "    await repo.insert_tips_topic(topic)\n\t    deleted_tips_topic = await repo.delete_tips_topic(topic)\n\t    assert deleted_tips_topic == topic\n\t    with pytest.raises(NoSuchEntityInDB):\n\t        await repo.delete_tips_topic(topic)\n\t    with pytest.raises(NoSuchEntityInDB):\n\t        topic.topic_description = TextWithTTS(\n\t            \"Huge description\", \"+Huge description\"\n\t        )\n\t        await repo.update_tips_topic(topic)\n", "    assert await repo.get_tips_topic_by_id(topic._id) is None\n\t    new_topic = TipsTopic(\n\t        uuid4(),\n\t        TextWithTTS(\"Newtopic\", \"Newt+opic\"),\n\t        TextWithTTS(\n\t            \"Just a new topic, nothing much\",\n\t            \"Just a new t+opic, n+othing much\",\n\t        ),\n\t        datetime.now(),\n\t        repo,\n", "    )\n\t    await repo.insert_tips_topics([topic, new_topic])\n\t    topics_list = await repo.get_tips_topics()\n\t    assert topic in topics_list and new_topic in topics_list\n\t    tips_topic_from_repo = await repo.get_tips_topic_by_id(topic._id)\n\t    assert tips_topic_from_repo == topic\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_tips(repo: BaseRepo, insert_values):\n\t    now = datetime.now()\n", "    tip = Tip(\n\t        uuid4(),\n\t        short_description=TextWithTTS(\n\t            \"Ну тупо очередной какой-то дневной совет, а почему бы и нет\",\n\t            \"Ну т+упо как+ой-то дневн+ой сов+ет, а почем+у бы и нет\",\n\t        ),\n\t        tip_content=TextWithTTS(\n\t            \"Ну тупо очередной какой-то дневной совет, а почему бы и нет\",\n\t            \"Ну т+упо как+ой-то дневн+ой сов+ет, а почем+у бы и нет\",\n\t        ),\n", "        tips_topic=(await repo.get_tips_topics(1))[0],\n\t        created_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_tip(tip)\n\t    deleted_tip = await repo.delete_tip(tip)\n\t    assert deleted_tip == tip\n\t    with pytest.raises(NoSuchEntityInDB):\n\t        await repo.delete_tip(tip)\n\t    with pytest.raises(NoSuchEntityInDB):\n", "        tip.short_description = TextWithTTS(\n\t            \"Huge description\", \"+Huge description\"\n\t        )\n\t        await repo.update_tip(tip)\n\t    assert await repo.get_tip_by_id(tip._id) is None\n\t    new_tip = Tip(\n\t        uuid4(),\n\t        TextWithTTS(\n\t            \"A new description for the tip\",\n\t            \"A new descr+iption for the tip\",\n", "        ),\n\t        TextWithTTS(\"Its content\", \"Its c+ontent\"),\n\t        (await repo.get_tips_topics(1))[0],\n\t        datetime.now(),\n\t        repo,\n\t    )\n\t    await repo.insert_tips([tip, new_tip])\n\t    tips_list = await repo.get_tips()\n\t    assert tip in tips_list and new_tip in tips_list\n\t    tip_from_repo = await repo.get_tip_by_id(tip._id)\n", "    assert tip_from_repo == tip\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_update(repo: BaseRepo, insert_values):\n\t    activity = (await repo.get_activities(1))[0]\n\t    activity.description = TextWithTTS(\n\t        activity.description.text, activity.description.tts + \" Updated now!\"\n\t    )\n\t    activity.occupation_time = timedelta(\n\t        hours=0, minutes=0, seconds=0, microseconds=0, milliseconds=1\n", "    )\n\t    updated_activity = await repo.update_activity(activity)\n\t    assert (\n\t        activity._id == updated_activity._id\n\t        and activity.description == updated_activity.description\n\t        and activity.occupation_time == updated_activity.occupation_time\n\t    )\n\t    tips_topic = (await repo.get_tips_topics(1))[0]\n\t    tips_topic.name = TextWithTTS(\"Newname\", \"Newn+ame\")\n\t    tips_topic.topic_description = TextWithTTS(\n", "        \"Just a topic for testing\", \"Just a t+opic for t+esting\"\n\t    )\n\t    updated_tips_topic = await repo.update_tips_topic(tips_topic)\n\t    assert (\n\t        tips_topic._id == updated_tips_topic._id\n\t        and tips_topic.name == updated_tips_topic.name\n\t        and tips_topic.topic_description\n\t        == updated_tips_topic.topic_description\n\t    )\n\t    # TODO Add filtering\n", "    new_topic = list(\n\t        filter(lambda x: x._id != tips_topic._id, await repo.get_tips_topics())\n\t    )[0]\n\t    tip = (await repo.get_tips(1))[0]\n\t    tip.short_description = TextWithTTS(\n\t        \"Well, another description goes here\",\n\t        \"Well, an+other descr+iption goes h+ere\",\n\t    )\n\t    tip.tip_content = TextWithTTS(\n\t        \"Well, that's the content I'd like to read\",\n", "        \"Well, that's the c+ontent I'd like to read\",\n\t    )\n\t    tip.tips_topic = new_topic\n\t    updated_tip = await repo.update_tip(tip)\n\t    assert (\n\t        tip.short_description == updated_tip.short_description\n\t        and tip.tip_content == updated_tip.tip_content\n\t        and tip.tips_topic == updated_tip.tips_topic\n\t    )\n\t    user = (await repo.get_users(1))[0].increase_streak()\n", "    new_tip = await repo.insert_tip(\n\t        Tip(\n\t            uuid4(),\n\t            TextWithTTS(\n\t                \"A new description for the tip\",\n\t                \"A new descr+iption for the tip\",\n\t            ),\n\t            TextWithTTS(\"Its content\", \"Its c+ontent\"),\n\t            tips_topic,\n\t            datetime.now(),\n", "            repo,\n\t        )\n\t    )\n\t    user.add_heard_tip(new_tip)\n\t    user.last_skill_use = datetime.now()\n\t    user.last_wake_up_time = time(1, 50, 32)\n\t    updated_user = await repo.update_user(user)\n\t    assert user._streak == updated_user._streak\n\t    assert updated_user.last_skill_use == user.last_skill_use.astimezone(\n\t        timezone(timedelta(0))\n", "    )\n\t    assert updated_user.last_wake_up_time == user.last_wake_up_time\n\t    assert new_tip in user._heard_tips\n\t    assert new_tip in updated_user._heard_tips\n\t    user.drop_heard_tips()\n\t    updated_user = await repo.update_user(user)\n\t    assert updated_user._heard_tips == []\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_getting(repo: BaseRepo, insert_values):\n", "    activities = await repo.get_activities()\n\t    assert await repo.get_activity_by_id(activities[0]._id) in activities\n\t    tips = await repo.get_tips()\n\t    assert await repo.get_tip_by_id(tips[0]._id) in tips\n\t    tips_topics = await repo.get_tips_topics()\n\t    assert await repo.get_tips_topic_by_id(tips_topics[0]._id) in tips_topics\n\t    users = await repo.get_users()\n\t    assert await repo.get_user_by_id(users[0]._id) in users\n\t    tips_with_topic = await repo.get_topic_tips(tips_topics[0]._id)\n\t    assert tips_with_topic != []\n", "@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_users_stats(repo: BaseRepo, insert_values):\n\t    BIG_STREAK = 10000\n\t    all_users = await repo.get_users()\n\t    all_user_counter = await repo.count_all_users()\n\t    assert len(all_users) == all_user_counter\n\t    assert await repo.count_users_with_streak(BIG_STREAK, condition=\">\") == 0\n\t    assert await repo.count_users_with_streak(BIG_STREAK, condition=\">=\") == 0\n\t    assert (\n", "        await repo.count_users_with_streak(BIG_STREAK, condition=\"<\")\n\t        == all_user_counter\n\t    )\n\t    assert (\n\t        await repo.count_users_with_streak(BIG_STREAK, condition=\"<=\")\n\t        == all_user_counter\n\t    )\n\t    assert await repo.count_users_with_streak(100, condition=\"<\") == 1\n\t    assert await repo.count_users_with_streak(100, condition=\"<=\") == 2\n\t    assert await repo.count_users_with_streak(100, condition=\">=\") == 1\n", "    assert await repo.count_users_with_streak(100, condition=\"==\") == 1\n\t    assert await repo.count_users_with_streak(100, condition=\">\") == 0\n\t    assert await repo.count_users_with_streak(100, condition=\"==\") == 1\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_deleting_all_users(repo: BaseRepo, insert_values):\n\t    await repo.delete_all_users()\n\t    assert await repo.get_users() == []\n\t    await repo.delete_all_tips_topics()\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n", "@pytest.mark.asyncio\n\tasync def test_deleting_all_activities(repo: BaseRepo, insert_values):\n\t    await repo.delete_all_activities()\n\t    assert await repo.get_activities() == []\n\t@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_deleting_all_tips_topics(repo: BaseRepo, insert_values):\n\t    await repo.delete_all_tips_topics()\n\t    assert await repo.get_tips_topics() == []\n\t    assert await repo.get_tips() == []\n", "@pytest.mark.parametrize(\"repo\", repos_to_test)\n\t@pytest.mark.asyncio\n\tasync def test_deleting_all_tips(repo: BaseRepo, insert_values):\n\t    await repo.delete_all_tips_topics()\n\t    topics_before_deleting = await repo.get_tips_topics()\n\t    assert await repo.get_tips() == []\n\t    assert await repo.get_tips_topics() == topics_before_deleting\n"]}
{"filename": "tests/db/__init__.py", "chunked_list": []}
{"filename": "tests/user_manager/test_user_manager.py", "chunked_list": ["import datetime\n\timport random\n\tfrom uuid import uuid4\n\timport pytest\n\timport pytz\n\tfrom skill.db.repos.sa_repo import SARepo\n\tfrom skill.entities import Activity, TipsTopic, User\n\tfrom skill.messages.ru_messages import RUMessages\n\tfrom skill.sleep_calculator import SleepMode\n\tfrom skill.user_manager import UserManager\n", "from skill.utils import TextWithTTS\n\tfrom tests.sa_db_settings import sa_repo_config\n\tdef generate_random_string_id() -> str:\n\t    return \"\".join(\n\t        (random.choice(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"))\n\t        for x in range(64)\n\t    )\n\t@pytest.mark.asyncio\n\tasync def test_me():\n\t    repo = SARepo(sa_repo_config)\n", "    now = datetime.datetime.now(tz=pytz.utc)\n\t    tips_topic = TipsTopic(\n\t        id=uuid4(),\n\t        name=TextWithTTS(\"Ночной сон\"),\n\t        topic_description=TextWithTTS(\"вот как\"),\n\t        created_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_tips_topic(tips_topic)\n\t    await tips_topic.add_tip(\n", "        short_description=TextWithTTS(\"святая вода\"),\n\t        tip_content=TextWithTTS(\"[1] мойте руки святой водой кншн\"),\n\t        tips_topic=tips_topic,\n\t        created_date=now,\n\t    )\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"зачем\"),\n\t        tip_content=TextWithTTS(\"[2] не мойте руки вообще никак вы что дурак\"),\n\t        tips_topic=tips_topic,\n\t        created_date=now,\n", "    )\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"оближи\"),\n\t        tip_content=TextWithTTS(\"[3] всё что нам нужно у нас в руках\"),\n\t        tips_topic=tips_topic,\n\t        created_date=now,\n\t    )\n\t    tips_topic = TipsTopic(\n\t        id=uuid4(),\n\t        name=TextWithTTS(\"Дневной сон\"),\n", "        topic_description=TextWithTTS(\"вот как\"),\n\t        created_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_tips_topic(tips_topic)\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"святая вода\"),\n\t        tip_content=TextWithTTS(\"[1] мойте руки святой водой кншн\"),\n\t        tips_topic=tips_topic,\n\t        created_date=now,\n", "    )\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"зачем\"),\n\t        tip_content=TextWithTTS(\"[2] не мойте руки вообще никак вы что дурак\"),\n\t        tips_topic=tips_topic,\n\t        created_date=now,\n\t    )\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"оближи\"),\n\t        tip_content=TextWithTTS(\"[3] всё что нам нужно у нас в руках\"),\n", "        tips_topic=tips_topic,\n\t        created_date=now,\n\t    )\n\t@pytest.mark.asyncio\n\tasync def test_check_in():\n\t    repo = SARepo(sa_repo_config)\n\t    messages = RUMessages()\n\t    now = datetime.datetime.now(tz=pytz.utc)\n\t    for user in await repo.get_users():\n\t        await repo.delete_user(user)\n", "    test_user_id = generate_random_string_id()\n\t    loser_user = User(\n\t        id=generate_random_string_id(),\n\t        streak=0,\n\t        last_skill_use=(now - datetime.timedelta(days=1)),\n\t        last_wake_up_time=datetime.time(hour=4, minute=20, tzinfo=pytz.utc),\n\t        heard_tips=[],\n\t        join_date=datetime.datetime(\n\t            year=2022, month=1, day=1, tzinfo=pytz.utc\n\t        ),\n", "        repo=repo,\n\t    )\n\t    user = User(\n\t        id=test_user_id,\n\t        streak=4,\n\t        last_skill_use=(now - datetime.timedelta(days=1)),\n\t        last_wake_up_time=datetime.time(hour=4, minute=20, tzinfo=pytz.utc),\n\t        heard_tips=[],\n\t        join_date=datetime.datetime(\n\t            year=2022, month=1, day=1, tzinfo=pytz.utc\n", "        ),\n\t        repo=repo,\n\t    )\n\t    await repo.insert_users((user, loser_user))\n\t    user_manager = await UserManager.new_manager(\n\t        test_user_id, repo, messages, create_user_if_not_found=False\n\t    )\n\t    assert user_manager is not None\n\t    message = await user_manager.check_in(now)\n\t    assert \"5 день подряд\" in message.text  # type: ignore\n", "    assert \"50%\" in message.text  # type: ignore\n\t    user_upd = await repo.get_user_by_id(test_user_id)\n\t    assert bool(user_upd)\n\t    assert user_upd._streak == 5\n\t    assert user_upd.last_skill_use == now\n\t    # Fast forward 5 days later\n\t    now = now + datetime.timedelta(days=5)\n\t    user_manager = await UserManager.new_manager(\n\t        test_user_id, repo, messages, create_user_if_not_found=False\n\t    )\n", "    assert bool(user_manager)\n\t    message = await user_manager.check_in(now)\n\t    assert \"день подряд\" not in message.text  # type: ignore\n\t    user_upd = await repo.get_user_by_id(test_user_id)\n\t    assert bool(user_upd)\n\t    assert user_upd._streak == 0\n\t    assert user_upd.last_skill_use == now\n\t@pytest.mark.asyncio\n\tasync def test_sleep_calc():\n\t    repo = SARepo(sa_repo_config)\n", "    messages = RUMessages()\n\t    test_user_id = generate_random_string_id()\n\t    user_manager = await UserManager.new_manager(test_user_id, repo, messages)\n\t    user_test = await repo.get_user_by_id(test_user_id)\n\t    assert bool(user_test) and bool(user_manager)\n\t    assert user_manager.is_new_user()\n\t    message1 = await user_manager.get_ask_sleep_time_message()\n\t    assert \"как в прошлый раз\" not in message1.text_with_tts.text\n\t    now = datetime.datetime(\n\t        year=1420, month=1, day=1, hour=11, minute=0, second=0, tzinfo=pytz.utc\n", "    )\n\t    wake_up_time = datetime.time(hour=14, minute=0, second=0, tzinfo=pytz.utc)\n\t    message2 = await user_manager.ask_sleep_time(\n\t        now, wake_up_time, SleepMode.LONG\n\t    )\n\t    print(message2.text_with_tts)\n\t    assert not user_manager.is_new_user()\n\t    # assert \"02:00\" in message2.text_with_tts.text  # type: ignore\n\t    message2 = await user_manager.ask_sleep_time(\n\t        now, wake_up_time, SleepMode.SHORT\n", "    )\n\t    print(message2.text_with_tts)\n\t    message2 = await user_manager.ask_sleep_time(\n\t        now, wake_up_time, SleepMode.VERY_SHORT\n\t    )\n\t    print(message2.text_with_tts)\n\t    message2 = await user_manager.ask_sleep_time(\n\t        now, wake_up_time, SleepMode.MEDIUM\n\t    )\n\t    print(message2.text_with_tts)\n", "    assert \"12:30\" in message2.text_with_tts.text  # type: ignore\n\t    message3 = await user_manager.get_ask_sleep_time_message()\n\t    print(message3.text_with_tts)\n\t    assert \"14:00\" in message3.text\n\t@pytest.mark.asyncio\n\tasync def test_activities_proposal():\n\t    repo = SARepo(sa_repo_config)\n\t    messages = RUMessages()\n\t    test_user_id = generate_random_string_id()\n\t    user_manager = await UserManager.new_manager(test_user_id, repo, messages)\n", "    user_test = await repo.get_user_by_id(test_user_id)\n\t    assert bool(user_test) and bool(user_manager)\n\t    now = datetime.datetime(\n\t        year=1420,\n\t        month=1,\n\t        day=1,\n\t        hour=11,\n\t        minute=00,\n\t        second=0,\n\t        tzinfo=pytz.utc,\n", "    )\n\t    for activity in await repo.get_activities():\n\t        await repo.delete_activity(activity)\n\t    activity1 = Activity(\n\t        id=uuid4(),\n\t        description=TextWithTTS(\"[FINDME_1] моргнуть\"),\n\t        created_date=now,\n\t        occupation_time=datetime.timedelta(hours=0, minutes=0, seconds=1),\n\t        repo=repo,\n\t    )\n", "    activity2 = Activity(\n\t        id=uuid4(),\n\t        description=TextWithTTS(\"[FINDME_2] анжуманя\"),\n\t        created_date=now,\n\t        occupation_time=datetime.timedelta(hours=1, minutes=29, seconds=1),\n\t        repo=repo,\n\t    )\n\t    activity3 = Activity(\n\t        id=uuid4(),\n\t        description=TextWithTTS(\"[EXCLUDEME] бегит\"),\n", "        created_date=now,\n\t        occupation_time=datetime.timedelta(hours=2, minutes=29, seconds=1),\n\t        repo=repo,\n\t    )\n\t    await repo.insert_activities((activity1, activity2, activity3))\n\t    wake_up_time = datetime.time(hour=14, minute=0, second=0, tzinfo=pytz.utc)\n\t    message1 = await user_manager.ask_sleep_time(\n\t        now, wake_up_time, SleepMode.SHORT\n\t    )\n\t    assert message1.text.count(\"[FINDME_1]\") == 1  # type: ignore\n", "    assert message1.text.count(\"[FINDME_2]\") == 1  # type: ignore\n\t    assert message1.text.count(\"[EXCLUDEME]\") == 0  # type: ignore\n\t    now = datetime.datetime(\n\t        year=1420,\n\t        month=1,\n\t        day=1,\n\t        hour=12,\n\t        minute=30,\n\t        second=0,\n\t        tzinfo=pytz.utc,\n", "    )\n\t    message2 = await user_manager.ask_sleep_time(\n\t        now, wake_up_time, SleepMode.SHORT\n\t    )\n\t    assert message2.text.count(\"[FINDME_1]\") == 0  # type: ignore\n\t    assert message2.text.count(\"[FINDME_2]\") == 0  # type: ignore\n\t    assert message2.text.count(\"[EXCLUDEME]\") == 0  # type: ignore\n\t@pytest.mark.asyncio\n\tasync def test_tips():\n\t    repo = SARepo(sa_repo_config)\n", "    messages = RUMessages()\n\t    test_user_id = generate_random_string_id()\n\t    user_manager = await UserManager.new_manager(test_user_id, repo, messages)\n\t    assert bool(user_manager)\n\t    for tip in await repo.get_tips():\n\t        await repo.delete_tip(tip)\n\t    now = datetime.datetime.now(pytz.utc)\n\t    tips_topic = TipsTopic(\n\t        id=uuid4(),\n\t        name=TextWithTTS(\"как правильно мыть руки\"),\n", "        topic_description=TextWithTTS(\"вот как\"),\n\t        created_date=now,\n\t        repo=repo,\n\t    )\n\t    await repo.insert_tips_topic(tips_topic)\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"святая вода\"),\n\t        tip_content=TextWithTTS(\"[1] мойте руки святой водой кншн\"),\n\t        tips_topic=tips_topic,\n\t        created_date=now,\n", "    )\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"зачем\"),\n\t        tip_content=TextWithTTS(\"[2] не мойте руки вообще никак вы что дурак\"),\n\t        tips_topic=tips_topic,\n\t        created_date=now,\n\t    )\n\t    await tips_topic.add_tip(\n\t        short_description=TextWithTTS(\"оближи\"),\n\t        tip_content=TextWithTTS(\"[3] всё что нам нужно у нас в руках\"),\n", "        tips_topic=tips_topic,\n\t        created_date=now,\n\t    )\n\t    for _ in range(10):\n\t        user = await repo.update_user(user_manager.user.drop_heard_tips())\n\t        user_manager = UserManager(user, repo, messages)\n\t        message1 = await user_manager.ask_tip(tips_topic.name.text)\n\t        assert isinstance(message1, TextWithTTS)\n\t        exclude = False\n\t        for tag in (\"[1]\", \"[2]\", \"[3]\"):\n", "            if tag in message1.text:\n\t                exclude = tag\n\t                break\n\t        assert exclude\n\t        message2 = await user_manager.ask_tip(tips_topic.name.text)\n\t        assert isinstance(message2, TextWithTTS)\n\t        assert exclude not in message2.text\n"]}
{"filename": "tests/user_manager/__init__.py", "chunked_list": []}
{"filename": "skill/entities.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime, time, timedelta\n\tfrom uuid import UUID, uuid4\n\tfrom skill.db.repos.base_repo import BaseRepo\n\tfrom skill.utils import IdComparable, TextWithTTS\n\tclass User(IdComparable):\n\t    _id: str\n\t    _streak: int\n\t    last_skill_use: datetime | None\n\t    last_wake_up_time: time | None\n", "    _heard_tips: list[Tip]\n\t    _join_date: datetime\n\t    def __init__(\n\t        self,\n\t        id: str,\n\t        streak: int,\n\t        last_skill_use: datetime | None,\n\t        last_wake_up_time: time | None,\n\t        heard_tips: list[Tip],\n\t        join_date: datetime,\n", "        repo: BaseRepo,\n\t    ) -> None:\n\t        self._id = id\n\t        self._streak = streak\n\t        self.last_skill_use = last_skill_use\n\t        self.last_wake_up_time = last_wake_up_time\n\t        self._heard_tips = heard_tips\n\t        self._join_date = join_date\n\t        self.__repo = repo\n\t    def increase_streak(self) -> User:\n", "        self._streak += 1\n\t        return self\n\t    def drop_streak(self) -> User:\n\t        self._streak = 0\n\t        return self\n\t    def drop_heard_tips(self) -> User:\n\t        self._heard_tips = []\n\t        return self\n\t    def add_heard_tip(self, tip: Tip) -> User:\n\t        self._heard_tips.append(tip)\n", "        return self\n\tclass Activity(IdComparable):\n\t    _id: UUID\n\t    _created_date: datetime\n\t    occupation_time: timedelta\n\t    # description: TextWithTTS\n\t    @property\n\t    def description(self) -> TextWithTTS:\n\t        return self.__description\n\t    @description.setter\n", "    def description(self, value: TextWithTTS):\n\t        if len(max(value.text, value.tts, key=len)) > 512:\n\t            raise ValueError(\n\t                \"Text and its speech format lengths should both be < 512\"\n\t            )\n\t        self.__description = value\n\t    def __init__(\n\t        self,\n\t        id: UUID,\n\t        description: TextWithTTS,\n", "        created_date: datetime,\n\t        occupation_time: timedelta,\n\t        repo: BaseRepo,\n\t    ) -> None:\n\t        self._id = id\n\t        self.description = description\n\t        self.occupation_time = occupation_time\n\t        self._created_date = created_date\n\t        self.__repo = repo\n\tclass Tip(IdComparable):\n", "    _id: UUID\n\t    _created_date: datetime\n\t    tips_topic: TipsTopic\n\t    # short_description: TextWithTTS\n\t    @property\n\t    def short_description(self) -> TextWithTTS:\n\t        return self.__short_description\n\t    @short_description.setter\n\t    def short_description(self, value: TextWithTTS):\n\t        if len(max(value.text, value.tts, key=len)) > 256:\n", "            raise ValueError(\n\t                \"Text and its speech format lengths should both be < 256\"\n\t            )\n\t        self.__short_description = value\n\t    # tip_content: TextWithTTS\n\t    @property\n\t    def tip_content(self) -> TextWithTTS:\n\t        return self.__tip_content\n\t    @tip_content.setter\n\t    def tip_content(self, value: TextWithTTS):\n", "        if len(max(value.text, value.tts, key=len)) > 1024:\n\t            raise ValueError(\n\t                \"Text and its speech format lengths should both be < 1024\"\n\t            )\n\t        self.__tip_content = value\n\t    def __init__(\n\t        self,\n\t        id: UUID,\n\t        short_description: TextWithTTS,\n\t        tip_content: TextWithTTS,\n", "        tips_topic: TipsTopic,\n\t        created_date: datetime,\n\t        repo: BaseRepo,\n\t    ) -> None:\n\t        self._id = id\n\t        self.short_description = short_description\n\t        self.tip_content = tip_content\n\t        self._created_date = created_date\n\t        self.tips_topic = tips_topic\n\t        self.__repo = repo\n", "class TipsTopic(IdComparable):\n\t    _id: UUID\n\t    _created_date: datetime\n\t    # name: TextWithTTS\n\t    @property\n\t    def name(self) -> TextWithTTS:\n\t        return self.__name\n\t    @name.setter\n\t    def name(self, value: TextWithTTS):\n\t        if len(max(value.text, value.tts, key=len)) > 1024:\n", "            raise ValueError(\n\t                \"Text and its speech format lengths should both be < 1024\"\n\t            )\n\t        self.__name = value\n\t    # topic_description: TextWithTTS\n\t    @property\n\t    def topic_description(self) -> TextWithTTS:\n\t        return self.__topic_description\n\t    @topic_description.setter\n\t    def topic_description(self, value: TextWithTTS):\n", "        if len(max(value.text, value.tts, key=len)) > 1024:\n\t            raise ValueError(\n\t                \"Text and its speech format lengths should both be < 1024\"\n\t            )\n\t        self.__topic_description = value\n\t    def __init__(\n\t        self,\n\t        id: UUID,\n\t        name: TextWithTTS,\n\t        topic_description: TextWithTTS,\n", "        created_date: datetime,\n\t        repo: BaseRepo,\n\t    ) -> None:\n\t        self._id = id\n\t        self.name = name\n\t        self.topic_description = topic_description\n\t        self._created_date = created_date\n\t        self.__repo = repo\n\t    async def get_all_tips(self) -> list[Tip]:\n\t        return await self.__repo.get_topic_tips(self._id)\n", "    async def add_tip(\n\t        self,\n\t        short_description: TextWithTTS,\n\t        tip_content: TextWithTTS,\n\t        tips_topic: TipsTopic,\n\t        created_date: datetime,\n\t    ) -> Tip:\n\t        return await self.__repo.insert_tip(\n\t            Tip(\n\t                id=uuid4(),\n", "                short_description=short_description,\n\t                tip_content=tip_content,\n\t                tips_topic=tips_topic,\n\t                created_date=created_date,\n\t                repo=self.__repo,\n\t            )\n\t        )\n"]}
{"filename": "skill/handlers.py", "chunked_list": ["import datetime\n\timport logging\n\tfrom aioalice import Dispatcher\n\tfrom aioalice.dispatcher import MemoryStorage\n\tfrom aioalice.types import Button\n\tfrom aioalice.types.alice_request import AliceRequest\n\tfrom pytz import timezone\n\tfrom skill.db.repos.sa_repo import SARepo\n\tfrom skill.db.sa_db_settings import sa_repo_config\n\tfrom skill.messages.ru_messages import RUMessages\n", "from skill.sleep_calculator import SleepMode\n\tfrom skill.states import States\n\tfrom skill.user_manager import UserManager\n\tlogging.basicConfig(format=\"%(asctime)s %(name)-12s %(levelname)-8s %(message)s\")\n\tdp = Dispatcher(storage=MemoryStorage())\n\tICO_ID = \"1540737/a491c8169a8b2597ba37\"\n\tTO_MENU_REPLICS = [\"выйди\", \"меню\", \"Меню\"]\n\t# Asking info\n\tGIVE_INFO_REPLICS = [\"расскажи о навыке\", \"расскажи о себе\"]\n\t# What can you do\n", "GIVE_WHAT_CAN_YOU_DO_REPLICS = [\"что ты делаешь\", \"что ты умеешь\"]\n\t# Asking tip\n\tASK_FOR_TIP_REPLICS = [\n\t    \"посоветуй\",\n\t    \"совет\",\n\t    \"лайфхак\",\n\t    \"подскажи\",\n\t    \"подсказка\",\n\t]\n\t# Using main functionality (sleep time calculation)\n", "MAIN_FUNCTIONALITY_ENTER = [\"я хочу спать\", \"рассчитай сон\"]\n\t# Using main functionality (sleep time calculation) (skip asking the time)\n\tMAIN_FUNCTIONALITY_ENTER_FAST = [\"Во сколько\", \"Когда\", \"Через сколько\"]\n\t# Choosing short sleep mode\n\tSHORT_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]\n\t# Choosing very short sleep mode\n\tVERY_SHORT_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.VERY_SHORT]\n\t# Choosing long sleep mode\n\tLONG_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.LONG]\n\t# Choosing medium sleep mode\n", "MEDIUM_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.MEDIUM]\n\t# Yes answer\n\tYES_REPLICS = [\"да\", \"конечно\", \"естественно\", \"хочу\"]\n\t# No answer\n\tNO_REPLICS = [\"нет\", \"отказываюсь\", \"не хочу\"]\n\t# Asking tip about night sleep\n\tWANT_NIGHT_TIP = [\"ночной\"]\n\t# Asking tip abot day sleep\n\tWANT_DAY_TIP = [\"дневной\"]\n\t# User aking help\n", "HELP_REPLICS = [\"помощь\", \"помогите\", \"справка\"]\n\t# User wants to stop skill\n\tQUIT_SKILL_REPLICS = [\"выйди\", \"выход\", \"закрой навык\"]\n\tdef get_buttons_with_text(texts: list[str] | None) -> list[Button] | None:\n\t    if texts is None:\n\t        return None\n\t    result = []\n\t    for text in texts:\n\t        button = Button(title=text)  # type: ignore\n\t        result.append(button)\n", "    return result\n\tdef contains_intent(req: AliceRequest, intent_name: str) -> bool:\n\t    return intent_name in req.request._raw_kwargs[\"nlu\"].get(\"intents\")\n\t@dp.request_handler(\n\t    state=States.SELECTING_TIME, func=lambda req: contains_intent(req, \"YANDEX.HELP\")\n\t)\n\tasync def time_form_info(alice_request: AliceRequest):\n\t    text_with_tts = RUMessages().get_sleep_form_message()\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n", "        tts=text_with_tts.tts,\n\t    )\n\t@dp.request_handler(\n\t    state=States.all(),  # type: ignore\n\t    func=lambda req: contains_intent(req, \"QUIT_SKILL\"),\n\t)\n\tasync def quit_skill(alice_request: AliceRequest):\n\t    text_with_tts = RUMessages().get_quit_message()\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n", "        tts=text_with_tts.tts,\n\t        end_session=True,\n\t    )\n\tdp.register_request_handler(\n\t    quit_skill,\n\t    state=States.all(),\n\t    contains=QUIT_SKILL_REPLICS,\n\t)\n\t@dp.request_handler(\n\t    state=States.all(),  # type: ignore\n", "    func=lambda req: contains_intent(req, \"TO_MENU\"),\n\t    contains=TO_MENU_REPLICS,\n\t)\n\tasync def go_to_menu(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    text_with_tts = RUMessages().get_menu_welcome_message()\n\t    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n", "        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n\t    )\n\tdp.register_request_handler(\n\t    go_to_menu,\n\t    state=States.all(),\n\t    contains=TO_MENU_REPLICS,\n\t)\n\t@dp.request_handler(\n\t    state=States.all(),  # type: ignore\n\t    func=lambda req: contains_intent(req, \"YANDEX.HELP\"),\n", ")\n\tasync def ask_help(alice_request: AliceRequest):\n\t    text_with_tts = RUMessages().get_help_message()\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages().HELP_BUTTONS_TEXT),\n\t    )\n\tdp.register_request_handler(\n\t    ask_help,\n", "    state=States.all(),\n\t    contains=HELP_REPLICS,\n\t)\n\t@dp.request_handler(\n\t    state=States.MAIN_MENU,\n\t    func=lambda req: contains_intent(req, \"GIVE_INFO\"),\n\t)  # type: ignore\n\tasync def give_info(alice_request: AliceRequest):\n\t    text_with_tts = RUMessages().get_info_message()\n\t    return alice_request.response_big_image(\n", "        text=text_with_tts.text,\n\t        image_id=ICO_ID,\n\t        title=\"О навыке\",\n\t        description=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n\t    )\n\tdp.register_request_handler(\n\t    give_info,\n\t    state=States.MAIN_MENU,\n", "    contains=GIVE_INFO_REPLICS,\n\t)\n\t@dp.request_handler(\n\t    state=States.MAIN_MENU,\n\t    func=lambda req: contains_intent(req, \"GIVE_WHAT_CAN_YOU_DO\"),\n\t)  # type: ignore\n\tasync def give_functions(alice_request: AliceRequest):\n\t    text_with_tts = RUMessages().get_what_can_you_do_message()\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n", "        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n\t    )\n\tdp.register_request_handler(\n\t    give_functions,\n\t    state=States.MAIN_MENU,\n\t    contains=GIVE_WHAT_CAN_YOU_DO_REPLICS,\n\t)\n\t@dp.request_handler(\n\t    state=States.ASKING_FOR_TIP,\n", "    func=lambda req: contains_intent(req, \"WANT_NIGHT_TIP\"),  # type: ignore\n\t)\n\tasync def send_night_tip(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n\t    response = await user_manager.ask_tip(\"ночной\")\n\t    await dp.storage.set_state(user_id, response.state)\n\t    text_with_tts = response.text_with_tts\n", "    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n\tdp.register_request_handler(\n\t    send_night_tip,\n\t    state=States.ASKING_FOR_TIP,\n\t    contains=WANT_NIGHT_TIP,\n\t)\n", "@dp.request_handler(\n\t    state=States.ASKING_FOR_TIP,\n\t    func=lambda req: contains_intent(req, \"WANT_DAY_TIP\"),\n\t)  # type: ignore\n\tasync def send_day_tip(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n\t    response = await user_manager.ask_tip(\"дневной\")\n", "    await dp.storage.set_state(user_id, response.state)\n\t    text_with_tts = response.text_with_tts\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n\tdp.register_request_handler(\n\t    send_day_tip,\n\t    state=States.ASKING_FOR_TIP,\n", "    contains=WANT_DAY_TIP,\n\t)\n\t@dp.request_handler(state=States.ASKING_FOR_TIP)  # type: ignore\n\tasync def reask_tip_topic(alice_request: AliceRequest):\n\t    text_with_tts = RUMessages().get_wrong_topic_message(\"\")\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text, tts=text_with_tts.tts\n\t    )\n\t@dp.request_handler(\n\t    state=States.MAIN_MENU,\n", "    func=lambda req: contains_intent(req, \"ASK_FOR_TIP\"),  # type: ignore\n\t)\n\tasync def send_tip(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    text_with_tts = RUMessages().get_ask_tip_topic_message()\n\t    await dp.storage.set_state(user_id, States.ASKING_FOR_TIP)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages.TIP_TOPIC_SELECTION_BUTTONS_TEXT),\n", "    )\n\tdp.register_request_handler(\n\t    send_tip,\n\t    state=States.MAIN_MENU,\n\t    contains=ASK_FOR_TIP_REPLICS,\n\t)\n\t@dp.request_handler(\n\t    state=States.IN_CALCULATOR,\n\t    func=lambda req: contains_intent(req, \"VERY_SHORT_SLEEP\"),  # type: ignore,\n\t)\n", "async def choose_very_short_duration(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    # time when user wants to get up, saved from previous dialogues\n\t    time = await dp.storage.get_data(user_id)\n\t    user_timezone = timezone(alice_request.meta.timezone)\n\t    hour = time[\"hour\"]\n\t    minute = time.get(\"minute\")\n\t    if minute is None:\n\t        minute = 0\n\t    wake_up_time = (\n", "        datetime.datetime.now(user_timezone)\n\t        .time()\n\t        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n\t    )\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n\t    response = await user_manager.ask_sleep_time(\n\t        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n\t        wake_up_time=wake_up_time,\n", "        mode=SleepMode.VERY_SHORT,\n\t    )\n\t    text_with_tts = response.text_with_tts\n\t    await dp.storage.set_state(user_id, States.CALCULATED)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n\tdp.register_request_handler(\n", "    choose_very_short_duration,\n\t    state=States.IN_CALCULATOR,\n\t    contains=VERY_SHORT_SLEEP_KEYWORDS,\n\t)\n\t@dp.request_handler(\n\t    state=States.IN_CALCULATOR,\n\t    func=lambda req: contains_intent(req, \"SHORT_SLEEP\"),  # type: ignore\n\t)\n\tasync def choose_short_duration(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n", "    # time when user wants to get up, saved from previous dialogues\n\t    time = await dp.storage.get_data(user_id)\n\t    user_timezone = timezone(alice_request.meta.timezone)\n\t    hour = time[\"hour\"]\n\t    minute = time.get(\"minute\")\n\t    if minute is None:\n\t        minute = 0\n\t    wake_up_time = (\n\t        datetime.datetime.now(user_timezone)\n\t        .time()\n", "        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n\t    )\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n\t    response = await user_manager.ask_sleep_time(\n\t        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n\t        wake_up_time=wake_up_time,\n\t        mode=SleepMode.SHORT,\n\t    )\n", "    text_with_tts = response.text_with_tts\n\t    await dp.storage.set_state(user_id, States.CALCULATED)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n\tdp.register_request_handler(\n\t    choose_short_duration,\n\t    state=States.IN_CALCULATOR,\n", "    contains=SHORT_SLEEP_KEYWORDS,\n\t)\n\t@dp.request_handler(\n\t    state=States.IN_CALCULATOR,\n\t    func=lambda req: contains_intent(req, \"MEDIUM_SLEEP\"),  # type: ignore\n\t)\n\tasync def choose_medium_duration(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    # time when user wants to get up, saved from previous dialogues\n\t    time = await dp.storage.get_data(user_id)\n", "    user_timezone = timezone(alice_request.meta.timezone)\n\t    hour = time[\"hour\"]\n\t    minute = time.get(\"minute\")\n\t    if minute is None:\n\t        minute = 0\n\t    wake_up_time = (\n\t        datetime.datetime.now(user_timezone)\n\t        .time()\n\t        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n\t    )\n", "    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n\t    response = await user_manager.ask_sleep_time(\n\t        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n\t        wake_up_time=wake_up_time,\n\t        mode=SleepMode.MEDIUM,\n\t    )\n\t    text_with_tts = response.text_with_tts\n\t    await dp.storage.set_state(user_id, States.CALCULATED)\n", "    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n\tdp.register_request_handler(\n\t    choose_medium_duration,\n\t    state=States.IN_CALCULATOR,\n\t    contains=MEDIUM_SLEEP_KEYWORDS,\n\t)\n", "@dp.request_handler(\n\t    state=States.IN_CALCULATOR,\n\t    func=lambda req: contains_intent(req, \"LONG_SLEEP\"),  # type: ignore)\n\t)\n\tasync def choose_long_duration(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    # time when user wants to get up, saved from previous dialogues\n\t    time = await dp.storage.get_data(user_id)\n\t    user_timezone = timezone(alice_request.meta.timezone)\n\t    hour = time[\"hour\"]\n", "    minute = time.get(\"minute\")\n\t    if minute is None:\n\t        minute = 0\n\t    wake_up_time = (\n\t        datetime.datetime.now(user_timezone)\n\t        .time()\n\t        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n\t    )\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n", "    )\n\t    response = await user_manager.ask_sleep_time(\n\t        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n\t        wake_up_time=wake_up_time,\n\t        mode=SleepMode.LONG,\n\t    )\n\t    text_with_tts = response.text_with_tts\n\t    await dp.storage.set_state(user_id, States.CALCULATED)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n", "        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n\tdp.register_request_handler(\n\t    choose_long_duration,\n\t    state=States.IN_CALCULATOR,\n\t    contains=LONG_SLEEP_KEYWORDS,\n\t)\n\t@dp.request_handler(state=States.SELECTING_TIME)  # type: ignore\n\tasync def enter_calculator(alice_request: AliceRequest):\n", "    user_id = alice_request.session.user_id\n\t    if \"nlu\" not in alice_request.request._raw_kwargs.keys():\n\t        response = RUMessages().get_ask_wake_up_time_message().text\n\t        return response\n\t    try:\n\t        value = alice_request.request._raw_kwargs[\"nlu\"][\"intents\"][\"sleep_calc\"][\n\t            \"slots\"\n\t        ][\"time\"][\"value\"]\n\t    except KeyError:\n\t        text_with_tts = RUMessages().get_wrong_time_message()\n", "        return alice_request.response(\n\t            response_or_text=text_with_tts.text,\n\t            tts=text_with_tts.tts,\n\t        )\n\t    if \"hour\" not in value.keys():\n\t        text_with_tts = RUMessages().get_wrong_time_message()\n\t        return alice_request.response(\n\t            response_or_text=text_with_tts.text,\n\t            tts=text_with_tts.tts,\n\t        )\n", "    if \"minute\" not in value.keys():\n\t        value[\"minutes\"] = 0\n\t    # save time sleep time\n\t    await dp.storage.set_data(user_id, value)\n\t    text_with_tts = RUMessages().get_ask_sleep_mode_message()\n\t    await dp.storage.set_state(user_id, States.IN_CALCULATOR)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages.SLEEP_MODE_SELECTION_BUTTONS_TEXT),\n", "    )\n\tdp.register_request_handler(\n\t    enter_calculator,\n\t    state=States.MAIN_MENU,  # type: ignore\n\t    func=lambda req: contains_intent(req, \"MAIN_FUNCTIONALITY_ENTER_FAST\"),\n\t)\n\tdp.register_request_handler(\n\t    enter_calculator,\n\t    state=States.MAIN_MENU,  # type: ignore\n\t    contains=MAIN_FUNCTIONALITY_ENTER_FAST,\n", ")\n\t@dp.request_handler(\n\t    state=States.MAIN_MENU,\n\t    func=lambda req: contains_intent(req, \"MAIN_FUNCTIONALITY_ENTER\"),  # type: ignore\n\t)\n\tasync def enter_calculator_with_no_time(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n", "    response = await user_manager.get_ask_sleep_time_message()\n\t    await dp.storage.set_state(user_id, response.state)\n\t    text_with_tts = response.text_with_tts\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n\tdp.register_request_handler(\n\t    enter_calculator_with_no_time,\n", "    state=States.MAIN_MENU,  # type: ignore\n\t    contains=MAIN_FUNCTIONALITY_ENTER,\n\t)\n\t@dp.request_handler(\n\t    state=States.TIME_PROPOSED,\n\t    func=lambda req: contains_intent(req, \"YANDEX.REJECT\"),\n\t)  # type: ignore\n\tasync def enter_calculator_new_time(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    text_with_tts = RUMessages().get_ask_wake_up_time_message()\n", "    await dp.storage.set_state(user_id, States.SELECTING_TIME)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text, tts=text_with_tts.tts\n\t    )\n\tdp.register_request_handler(\n\t    enter_calculator_new_time,\n\t    state=States.TIME_PROPOSED,\n\t    contains=NO_REPLICS,\n\t)\n\t@dp.request_handler(\n", "    state=States.TIME_PROPOSED,\n\t    func=lambda req: contains_intent(req, \"YANDEX.CONFIRM\"),\n\t)  # type: ignore\n\tasync def enter_calculator_proposed_time(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n\t    time = {\n\t        \"hour\": user_manager.user.last_wake_up_time.hour,\n", "        \"minute\": user_manager.user.last_wake_up_time.minute,\n\t    }\n\t    await dp.storage.set_data(user_id, time)\n\t    text_with_tts = RUMessages().get_ask_sleep_mode_message()\n\t    await dp.storage.set_state(user_id, States.IN_CALCULATOR)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages.SLEEP_MODE_SELECTION_BUTTONS_TEXT),\n\t    )\n", "dp.register_request_handler(\n\t    enter_calculator_proposed_time,\n\t    state=States.TIME_PROPOSED,\n\t    contains=YES_REPLICS,\n\t)\n\t@dp.request_handler(\n\t    state=States.CALCULATED,\n\t    func=lambda req: contains_intent(req, \"YANDEX.REJECT\"),\n\t)  # type: ignore\n\tasync def end_skill(alice_request: AliceRequest):\n", "    user_id = alice_request.session.user_id\n\t    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\t    text_with_tts = RUMessages().get_good_night_message()\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages().MENU_BUTTONS_TEXT),\n\t    )\n\tdp.register_request_handler(\n\t    end_skill,\n", "    state=States.CALCULATED,\n\t    contains=NO_REPLICS,\n\t)\n\tdp.register_request_handler(\n\t    send_night_tip,\n\t    state=States.CALCULATED,  # type: ignore\n\t    func=lambda req: contains_intent(req, \"YANDEX.CONFIRM\"),\n\t    contains=YES_REPLICS,\n\t)\n\tdp.register_request_handler(\n", "    send_night_tip,\n\t    state=States.CALCULATED,\n\t    contains=YES_REPLICS,\n\t)\n\t@dp.request_handler()\n\tasync def welcome_user(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    user_manager = await UserManager.new_manager(\n\t        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n\t    )\n", "    response = await user_manager.check_in(\n\t        now=datetime.datetime.now(timezone(alice_request.meta.timezone))\n\t    )\n\t    text_with_tts = response.text_with_tts\n\t    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(response.buttons_text),\n\t    )\n", "@dp.errors_handler()\n\tasync def error_handler(alice_request: AliceRequest, e):\n\t    user_id = alice_request.session.user_id\n\t    state = await dp.storage.get_state(user_id)\n\t    logging.error(str(state), exc_info=e)\n\t    text_with_tts = RUMessages().get_generic_error_message()\n\t    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\t    return alice_request.response(\n\t        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n", "        buttons=get_buttons_with_text(RUMessages().MENU_BUTTONS_TEXT),\n\t    )\n\t@dp.request_handler(\n\t    state=States.all(),  # type: ignore\n\t)\n\tasync def universal_handler(alice_request: AliceRequest):\n\t    user_id = alice_request.session.user_id\n\t    text_with_tts = RUMessages().get_menu_welcome_message()\n\t    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\t    return alice_request.response(\n", "        response_or_text=text_with_tts.text,\n\t        tts=text_with_tts.tts,\n\t        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n\t    )\n"]}
{"filename": "skill/__main__.py", "chunked_list": ["from aioalice import get_new_configured_app\n\tfrom aiohttp import web\n\tfrom skill.config import WEBAPP_HOST, WEBAPP_PORT, WEBHOOK_URL_PATH\n\tfrom skill.handlers import dp\n\tif __name__ == \"__main__\":\n\t    app = get_new_configured_app(dispatcher=dp, path=WEBHOOK_URL_PATH)\n\t    web.run_app(app, host=WEBAPP_HOST, port=int(WEBAPP_PORT), loop=dp.loop)\n"]}
{"filename": "skill/config.py", "chunked_list": ["import os\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tWEBHOOK_URL_PATH = os.getenv(\"WEBHOOK_URL_PATH\") or \"/\"\n\tWEBAPP_HOST = os.getenv(\"WEBAPP_HOST\") or \"localhost\"\n\tWEBAPP_PORT = os.getenv(\"WEBAPP_PORT\") or 5555\n"]}
{"filename": "skill/states.py", "chunked_list": ["from aioalice.utils.helper import Helper, HelperMode, Item\n\tclass States(Helper):\n\t    mode = HelperMode.snake_case\n\t    MAIN_MENU = Item()  # = main_menu\n\t    ASKING_FOR_TIP = Item()  # = asking_for_tip\n\t    SELECTING_TIME = Item()  # = selecting_time\n\t    IN_CALCULATOR = Item()  # = in_calculator\n\t    CALCULATED = Item()  # = calculated\n\t    TIME_PROPOSED = Item()  # = time_proposed\n"]}
{"filename": "skill/user_manager.py", "chunked_list": ["from __future__ import annotations\n\timport datetime\n\timport logging\n\timport random\n\tfrom dataclasses import dataclass\n\timport pytz\n\tfrom skill.entities import User\n\tfrom skill.exceptions import InvalidInputError\n\tfrom skill.db.repos.base_repo import BaseRepo\n\tfrom skill.messages.base_messages import BaseMessages\n", "from skill.sleep_calculator import SleepCalculator, SleepMode\n\tfrom skill.states import States\n\tfrom skill.utils import TextWithTTS\n\t@dataclass\n\tclass SkillResponse:\n\t    text_with_tts: TextWithTTS\n\t    state: str | None\n\t    buttons_text: list[str] | None\n\tclass UserManager:\n\t    user: User\n", "    repo: BaseRepo\n\t    messages: BaseMessages\n\t    def __init__(\n\t        self, user: User, repo: BaseRepo, messages: BaseMessages\n\t    ) -> None:\n\t        self.user = user\n\t        self.repo = repo\n\t        self.messages = messages\n\t    @classmethod\n\t    async def new_manager(\n", "        cls,\n\t        user_id: str,\n\t        repo: BaseRepo,\n\t        messages: BaseMessages,\n\t        create_user_if_not_found: bool = True,\n\t    ) -> UserManager:\n\t        \"\"\"Sets up UserManager with given user repo and messages.\n\t        If user_id is not found in the DB and create_user_if_not_found\n\t        is True, creates a new user.\n\t        Args:\n", "            user_id (str): User's ID as it is stored in the DB\n\t            and returned in the API request\n\t            repo (BaseRepo): the repo which this user manager should\n\t            work with\n\t            messages (BaseMessages): the messages generator used\n\t            by reply constructors\n\t            create_user_if_not_found (bool, optional): whether to create\n\t            a new user if user_id is not found in the DB or not.\n\t            Defaults to True.\n\t        Returns:\n", "            UserManager | None: proper UserManager instance. If\n\t            the user_id is not found in the DB and create_user_if_not_found\n\t            is False, returns None\n\t        \"\"\"\n\t        user = await repo.get_user_by_id(user_id)\n\t        # if not user and not create_user_if_not_found:\n\t        #    return None\n\t        if not user:\n\t            user = User(\n\t                id=user_id,\n", "                streak=0,\n\t                last_skill_use=None,\n\t                last_wake_up_time=None,\n\t                heard_tips=[],\n\t                join_date=datetime.datetime.now(),\n\t                repo=repo,\n\t            )\n\t            await repo.insert_user(user)\n\t        inst = cls(user=user, repo=repo, messages=messages)\n\t        return inst\n", "    def is_new_user(self):\n\t        return not (self.user.last_skill_use or self.user.last_wake_up_time)\n\t    async def count_scoreboard(self, percentages: bool = True) -> int:\n\t        \"\"\"Calculates user's position in the global streak scoreboard,\n\t        starting from the lowest.\n\t        Args:\n\t            percentages (bool, optional): whether to convert the score\n\t            to percentage rate of users with lower streak or not\n\t            Defaults to True\n\t        Returns:\n", "            int: user's scoreboard position or the percentage rate\n\t        \"\"\"\n\t        streak = self.user._streak\n\t        score = await self.repo.count_users_with_streak(streak, \"<=\") - 1\n\t        if not percentages:\n\t            return score\n\t        total = await self.repo.count_all_users()\n\t        percentage = round(score / total * 100)\n\t        return percentage\n\t    async def check_in(\n", "        self, now: datetime.datetime | None = None\n\t    ) -> SkillResponse:\n\t        \"\"\"Perform all needed processes when a user starts the skill.\n\t        To be more precise, this method:\n\t        - Drops user's streak if the streak is lost\n\t        - Increases user's streak if the streak is kept\n\t        - Updates user's last_skill_use field\n\t        Returns a properly constructed greeting message to welcome the user\n\t        Args:\n\t            now (datetime.datetime | None, optional): the time at which the\n", "            user started the skill. If not set, the method will recieve the\n\t            time with datetime.datetime.now() (using UTC). However, leaving\n\t            this parameter to None is deprecated due to the possible difference\n\t            between the request time and the execution time.\n\t            Defaults to None.\n\t        Returns:\n\t            TextWithTTS: a greeting message.\n\t        \"\"\"\n\t        if now is None:\n\t            now = datetime.datetime.now(pytz.utc)\n", "        new_user = True\n\t        if self.user.last_skill_use is not None:\n\t            new_user = False\n\t            yesterday = (now - datetime.timedelta(days=1)).date()\n\t            today = now.date()\n\t            if self.user.last_skill_use.date() == yesterday:\n\t                # Last skill use was yesterday, streak increased\n\t                self.user.increase_streak()\n\t            elif self.user.last_skill_use.date() != today:\n\t                # Last skill use was neither yesterday, nor today,\n", "                # thus streak dropped.\n\t                self.user.drop_streak()\n\t        self.user.last_skill_use = now\n\t        await self.repo.update_user(self.user)\n\t        if new_user:\n\t            return SkillResponse(\n\t                self.messages.get_start_message_intro(now),\n\t                States.MAIN_MENU,\n\t                self.messages.MENU_BUTTONS_TEXT,\n\t            )\n", "        streak = self.user._streak\n\t        scoreboard = await self.count_scoreboard(percentages=True)\n\t        return SkillResponse(\n\t            self.messages.get_start_message_comeback(\n\t                time=now, streak=streak, scoreboard=scoreboard\n\t            ),\n\t            States.MAIN_MENU,\n\t            self.messages.MENU_BUTTONS_TEXT,\n\t        )\n\t    async def ask_tip(self, topic_name: str) -> SkillResponse:\n", "        \"\"\"Chooses a tip on given topic that has most likely never\n\t        been heard before by the user and tracks the heard tips buffer.\n\t        Args:\n\t            topic_name (str): the name of the topic of tips\n\t        Returns:\n\t            TextWithTTS: a tip message in a form of TextWithTTS or\n\t            error message if the topic is not found.\n\t        \"\"\"\n\t        topic = await self.repo.get_tips_topic_by_name(topic_name)\n\t        if topic is None:\n", "            return SkillResponse(\n\t                self.messages.get_wrong_topic_message(topic_name),\n\t                States.ASKING_FOR_TIP,\n\t                self.messages.TIP_TOPIC_SELECTION_BUTTONS_TEXT,\n\t            )\n\t        tips = await self.repo.get_topic_tips(topic_id=topic._id)\n\t        heard_tips = self.user._heard_tips\n\t        if len(heard_tips) == len(tips):\n\t            self.user.drop_heard_tips()\n\t            heard_tips = []\n", "        if heard_tips:\n\t            tips = list(filter(lambda x: x not in heard_tips, tips))\n\t        tip = random.choice(tips)\n\t        self.user.add_heard_tip(tip)\n\t        await self.repo.update_user(self.user)\n\t        return SkillResponse(\n\t            self.messages.get_tip_message(tip),\n\t            States.MAIN_MENU,\n\t            self.messages.MENU_BUTTONS_TEXT,\n\t        )\n", "    async def get_ask_sleep_time_message(self) -> SkillResponse:\n\t        \"\"\"Get the proper message to ask a user the time at which\n\t        they want to wake up. The selected message depends on whether\n\t        the user have already used the sleep calculator or not.\"\"\"\n\t        last_wake_up_time = self.user.last_wake_up_time\n\t        if last_wake_up_time is not None:\n\t            return SkillResponse(\n\t                self.messages.get_propose_yesterday_wake_up_time_message(\n\t                    last_wake_up_time\n\t                ),\n", "                States.TIME_PROPOSED,\n\t                self.messages.SLEEP_TIME_PROPOSAL_BUTTONS_TEXT,\n\t            )\n\t        return SkillResponse(\n\t            self.messages.get_ask_wake_up_time_message(),\n\t            States.SELECTING_TIME,\n\t            None,\n\t        )\n\t    async def ask_sleep_time(\n\t        self,\n", "        now: datetime.datetime,\n\t        wake_up_time: datetime.time,\n\t        mode: SleepMode,\n\t        remember_time: bool = True,\n\t    ) -> SkillResponse:\n\t        \"\"\"Calculate user's sleep time. Constructs a response message,\n\t        in which it proposes the user a number of activities for the rest of\n\t        the evening, and returns the message.\n\t        Args:\n\t            now (datetime.datetime): the timestamp at which the user asks to\n", "            calculate their sleep time.\n\t            wake_up_time (datetime.time): the time at which the user\n\t            wants to wake up\n\t            mode (SleepMode.LONG | SleepMode.SHORT): user's selected\n\t            sleep mode\n\t            remember_time (bool, optional): whether to record the time at which\n\t            the user wants to wake up to the DB or not\n\t            Defaults to True.\n\t        Returns:\n\t            TextWithTTS: a response message in a form of TextWithTTS.\n", "        \"\"\"\n\t        logging.debug(wake_up_time)\n\t        if remember_time:\n\t            self.user.last_wake_up_time = wake_up_time\n\t            await self.repo.update_user(self.user)\n\t        try:\n\t            wake_up_datetime = datetime.datetime.combine(\n\t                date=now.date(),\n\t                time=wake_up_time,\n\t                tzinfo=now.tzinfo,\n", "            )\n\t            sleep_calc_result = SleepCalculator.calc(\n\t                wake_up_time=wake_up_datetime, origin_time=now, mode=mode\n\t            )\n\t        except InvalidInputError:\n\t            wake_up_datetime = datetime.datetime.combine(\n\t                date=(now + datetime.timedelta(days=1)).date(),\n\t                time=wake_up_time,\n\t                tzinfo=now.tzinfo,\n\t            )\n", "            sleep_calc_result = SleepCalculator.calc(\n\t                wake_up_time=wake_up_datetime, origin_time=now, mode=mode\n\t            )\n\t        all_activities = await self.repo.get_activities()\n\t        activities = SleepCalculator.activities_compilation(\n\t            now, sleep_calc_result.bed_time, all_activities\n\t        )\n\t        return SkillResponse(\n\t            self.messages.get_sleep_calc_time_message(\n\t                sleep_calc_result, activities\n", "            ),\n\t            States.CALCULATED,\n\t            self.messages.POST_SLEEP_CALCULATION_BUTTONS_TEXT,\n\t        )\n"]}
{"filename": "skill/__init__.py", "chunked_list": []}
{"filename": "skill/utils.py", "chunked_list": ["from __future__ import annotations\n\timport datetime\n\timport enum\n\timport itertools\n\timport random\n\tfrom typing import Any, Callable, Iterable, List, Union\n\tclass Daytime(enum.Enum):\n\t    DAY = enum.auto()\n\t    NIGHT = enum.auto()\n\t    EVENING = enum.auto()\n", "    MORNING = enum.auto()\n\t    @classmethod\n\t    def from_time(cls, time: Union[datetime.datetime, datetime.time]):\n\t        \"\"\"Identify Daytime from time\n\t        Args:\n\t            time (datetime.datetime | datetime.time): time to recieve daytime.\n\t        Returns:\n\t            Daytime: one of daytime options according to the given time\n\t        \"\"\"\n\t        if isinstance(time, datetime.datetime):\n", "            time = time.time()\n\t        morning = datetime.time(5, 0, 0)\n\t        day = datetime.time(12, 0, 0)\n\t        evening = datetime.time(16, 0, 0)\n\t        night = datetime.time(23, 0, 0)\n\t        if time < morning:\n\t            return cls.NIGHT\n\t        if time < day:\n\t            return cls.MORNING\n\t        if time < evening:\n", "            return cls.DAY\n\t        if time < night:\n\t            return cls.EVENING\n\t        return cls.NIGHT\n\tclass TextWithTTS:\n\t    text: str\n\t    tts: str\n\t    def __init__(self, text: str, tts: str | None = None):\n\t        self.text = text\n\t        if tts is None:\n", "            self.tts = text\n\t            return\n\t        self.tts = tts\n\t    def __eq__(self, __o: object) -> bool:\n\t        return (\n\t            isinstance(__o, TextWithTTS)\n\t            and self.text == __o.text\n\t            and self.tts == __o.tts\n\t        )\n\t    def __str__(self) -> str:\n", "        return \"Text:\\n\" f\"{self.text}\" \"\\n\" \"TTS:\\n\" f\"{self.tts}\"\n\t    def __add__(self, __o: Union[str, TextWithTTS]) -> TextWithTTS:\n\t        if isinstance(__o, TextWithTTS):\n\t            return TextWithTTS(self.text + __o.text, self.tts + __o.tts)\n\t        return TextWithTTS(self.text + __o, self.tts + __o)\n\t    def __radd__(self, __o: Union[str, TextWithTTS]) -> TextWithTTS:\n\t        if isinstance(__o, TextWithTTS):\n\t            return TextWithTTS(__o.text + self.text, __o.tts + self.tts)\n\t        return TextWithTTS(__o + self.text, __o + self.text)\n\t    def __iadd__(self, __o: Union[str, TextWithTTS]) -> TextWithTTS:\n", "        return self + __o\n\t    def transform(self, func: Callable[[str], str]) -> TextWithTTS:\n\t        \"\"\"Apply a function to both text and speech parts\n\t        of TextWithTTS.\n\t        Args:\n\t            func (Callable[[str], str]): the function to transform\n\t            TextWithTTS strings\n\t        Returns:\n\t            TextWithTTS: new TextWithTTS with transformed strings\n\t        \"\"\"\n", "        return TextWithTTS(func(self.text), func(self.tts))\n\t    def join(self, __iterable: Iterable[TextWithTTS], /):\n\t        \"\"\"Likewise str.join, concatenate any number of TextWithTTS.\n\t        Calls str.join for text parts and tts parts of TextWithTTS objects\n\t        seperately and returns a new instance with concatenated text and tts.\n\t        TextWithTTS whose method is being called inserts its text and tts\n\t        between the concatenated objects.\n\t        Args:\n\t            Iterable[TextWithTTS]: sequence of TextWithTTS to concatenate\n\t        Returns:\n", "            TextWithTTS: the concatenation result\n\t        \"\"\"\n\t        i1, i2 = itertools.tee(__iterable, 2)\n\t        return TextWithTTS(\n\t            self.text.join(map(lambda x: x.text, i1)),\n\t            self.tts.join(map(lambda x: x.tts, i2)),\n\t        )\n\tclass IdComparable:\n\t    _id: Any\n\t    def __eq__(self, __o: object) -> bool:\n", "        return isinstance(__o, self.__class__) and self._id == __o._id\n\tdef gentle_capitalize(text: str):\n\t    \"\"\"Make the first character of a string have upper case\n\t    leaving the rest of the string as is, unlike built-in\n\t    str.capitalize method, which makes all other characters\n\t    have lower case.\n\t    Args:\n\t        text (str): the string to convert\n\t    Returns:\n\t        str: gently capitalized string\n", "    \"\"\"\n\t    if not text:\n\t        return text\n\t    return text[0].upper() + text[1:]\n\tdef construct_random_message(*parts: List[TextWithTTS], insert_spaces=True):\n\t    \"\"\"Construct randomly generated message from a sequence\n\t    of message parts options.\n\t    Args:\n\t        *parts (List[TextWithTTS]): message parts options\n\t        in the sequential order.\n", "        insert_spaces (bool, optional): whether to insert\n\t        spaces inbetween the parts of a message or not.\n\t        Degaults to True.\n\t    Returns:\n\t        TextWithTTS: constructed message\n\t    \"\"\"\n\t    if insert_spaces:\n\t        delimiter = TextWithTTS(\" \")\n\t    else:\n\t        delimiter = TextWithTTS(\"\")\n", "    return delimiter.join(map(lambda x: random.choice(x), parts))\n"]}
{"filename": "skill/sleep_calculator.py", "chunked_list": ["import datetime\n\tfrom skill.exceptions import InvalidInputError\n\tfrom typing import Iterable, Callable\n\tfrom skill.entities import Activity\n\tfrom dataclasses import dataclass\n\timport enum\n\tclass SleepModeDoesntFitError(Exception):\n\t    pass\n\tclass SleepMode(enum.Enum):\n\t    LONG = enum.auto()\n", "    MEDIUM = enum.auto()\n\t    SHORT = enum.auto()\n\t    VERY_SHORT = enum.auto()\n\t@dataclass\n\tclass SleepCalculation:\n\t    bed_time: datetime.datetime = datetime.datetime(datetime.MINYEAR, 1, 1)\n\t    selected_mode: SleepMode = SleepMode.LONG\n\t    sleep_time: datetime.timedelta = datetime.timedelta(0)\n\t    changed_mode: SleepMode | None = None\n\tclass SleepCalculator:\n", "    _mode_calculators: dict[\n\t        SleepMode,\n\t        Callable[[datetime.datetime, datetime.datetime], datetime.timedelta],\n\t    ] = {}\n\t    _mode_priorities: dict[\n\t        SleepMode,\n\t        int,\n\t    ] = {}\n\t    @classmethod\n\t    def mode_calculator(cls, mode: SleepMode, priority: int):\n", "        def wrapper(func):\n\t            cls._mode_calculators[mode] = func\n\t            cls._mode_priorities[mode] = priority\n\t            def newfunc(*args, **kwargs):\n\t                sleep_time = func(*args, **kwargs)\n\t                if sleep_time <= datetime.timedelta(0):\n\t                    raise SleepModeDoesntFitError(\n\t                        \"Can't fit any sleep time in given range\"\n\t                    )\n\t                return sleep_time\n", "            return newfunc\n\t        return wrapper\n\t    @staticmethod\n\t    def activities_compilation(\n\t        time_a: datetime.datetime,\n\t        time_b: datetime.datetime,\n\t        all_activities: Iterable[Activity],\n\t        limit: int = 2,\n\t    ) -> list[Activity]:\n\t        \"\"\"Returns a number of activities that can be done between time_a and\n", "        time_b.\n\t        Args:\n\t            time_a (datetime.datetime): opening time boundary\n\t            time_b (datetime.datetime): closing time boundary\n\t            all_activities (Iterable[Activity]): the pool of all activities\n\t            limit (int, optional): the number of best fitting activities to\n\t            return.\n\t            Defaults to 2\n\t        Returns:\n\t            list[Activity]: the list of best fitting activities compilation\n", "        \"\"\"\n\t        if time_b < time_a:\n\t            raise InvalidInputError(\n\t                \"Closing boundary cannot be less than the opening boundary\"\n\t            )\n\t        delta = time_b - time_a\n\t        sorted_activities = sorted(\n\t            filter(lambda x: x.occupation_time < delta, all_activities),\n\t            reverse=True,\n\t            key=lambda x: x.occupation_time,\n", "        )\n\t        return sorted_activities[:limit]\n\t    @classmethod\n\t    def calc(\n\t        cls,\n\t        wake_up_time: datetime.datetime,\n\t        origin_time: datetime.datetime | None = None,\n\t        mode: SleepMode = SleepMode.LONG,\n\t    ) -> SleepCalculation:\n\t        \"\"\"Returns the time at which the user need to go to bed according to\n", "        their request.\n\t        Args:\n\t            wake_up_time (datetime.datetime): user's desired time to wake up\n\t            origin_time (datetime.datetime | None, optional): the starting\n\t            point in time from which the calculations are made.\n\t            If None is passed, origin_time sets to datetime.datetime.now()\n\t            result with the timezone of wake_up_time.\n\t            Defaults to None\n\t            mode (SleepMode.LONG | SleepMode.MEDIUM | SleepMode.SHORT |\n\t            SleepMode.VERY_SHORT): user's desired sleep mode\n", "        Returns:\n\t            datetime.datetime: the time at which the user should go to bed\n\t        \"\"\"\n\t        if origin_time is None:\n\t            origin_time = datetime.datetime.now(wake_up_time.tzinfo)\n\t        if wake_up_time <= origin_time:\n\t            raise InvalidInputError(\n\t                \"Wake up time is earlier than current time\"\n\t            )\n\t        result = SleepCalculation()\n", "        result.selected_mode = mode\n\t        # Initial calculation for the desired mode\n\t        try:\n\t            result.sleep_time = cls._mode_calculators[mode](\n\t                origin_time, wake_up_time\n\t            )\n\t        except SleepModeDoesntFitError:\n\t            # Impossible mode: choose the mode that fits the most\n\t            sleep_time = None\n\t            for mode, calculator in sorted(\n", "                cls._mode_calculators.items(),\n\t                key=lambda pair: cls._mode_priorities[pair[0]],\n\t            ):\n\t                try:\n\t                    sleep_time = calculator(origin_time, wake_up_time)\n\t                except SleepModeDoesntFitError:\n\t                    continue\n\t                result.sleep_time = sleep_time\n\t                result.changed_mode = mode\n\t                break\n", "            if sleep_time is None:\n\t                raise InvalidInputError(\n\t                    \"It is not possible to sleep in given period of time\"\n\t                )\n\t        result.bed_time = wake_up_time - result.sleep_time\n\t        return result\n\t# TODO: Change the sleep mode definition architecture to be more\n\t# developer-friendly (Issue #87)\n\t@SleepCalculator.mode_calculator(SleepMode.VERY_SHORT, 3)\n\tdef vert_short_sleep(\n", "    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n\t) -> datetime.timedelta:\n\t    origin_time += datetime.timedelta(minutes=10)\n\t    step = datetime.timedelta(hours=0, minutes=15)\n\t    delta = wake_up_time - origin_time\n\t    delta_steps = delta // step\n\t    sleep_time = delta_steps * step\n\t    min_time = datetime.timedelta(hours=0, minutes=15)\n\t    max_time = datetime.timedelta(hours=3, minutes=0)\n\t    sleep_time = min(sleep_time, max_time)\n", "    if sleep_time < min_time:\n\t        raise SleepModeDoesntFitError\n\t    return sleep_time\n\t@SleepCalculator.mode_calculator(SleepMode.SHORT, 2)\n\tdef short_sleep(\n\t    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n\t) -> datetime.timedelta:\n\t    origin_time += datetime.timedelta(minutes=20)\n\t    step = datetime.timedelta(hours=1, minutes=00)\n\t    delta = wake_up_time - origin_time\n", "    delta_steps = delta // step\n\t    sleep_time = delta_steps * step\n\t    min_time = datetime.timedelta(hours=3, minutes=0)\n\t    max_time = datetime.timedelta(hours=6, minutes=0)\n\t    sleep_time = min(sleep_time, max_time)\n\t    if sleep_time < min_time:\n\t        raise SleepModeDoesntFitError\n\t    return sleep_time\n\t@SleepCalculator.mode_calculator(SleepMode.MEDIUM, 1)\n\tdef medium_sleep(\n", "    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n\t) -> datetime.timedelta:\n\t    origin_time += datetime.timedelta(minutes=20)\n\t    step = datetime.timedelta(hours=1, minutes=30)\n\t    delta = wake_up_time - origin_time\n\t    delta_steps = delta // step\n\t    sleep_time = delta_steps * step\n\t    min_time = datetime.timedelta(hours=6, minutes=0)\n\t    max_time = datetime.timedelta(hours=9, minutes=0)\n\t    sleep_time = min(sleep_time, max_time)\n", "    if sleep_time < min_time:\n\t        raise SleepModeDoesntFitError\n\t    return sleep_time\n\t@SleepCalculator.mode_calculator(SleepMode.LONG, 0)\n\tdef long_sleep(\n\t    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n\t) -> datetime.timedelta:\n\t    origin_time += datetime.timedelta(minutes=20)\n\t    step = datetime.timedelta(hours=1, minutes=30)\n\t    delta = wake_up_time - origin_time\n", "    delta_steps = delta // step\n\t    sleep_time = delta_steps * step\n\t    min_time = datetime.timedelta(hours=9, minutes=0)\n\t    max_time = datetime.timedelta(hours=12, minutes=0)\n\t    sleep_time = min(sleep_time, max_time)\n\t    if sleep_time < min_time:\n\t        raise SleepModeDoesntFitError\n\t    return sleep_time\n"]}
{"filename": "skill/exceptions.py", "chunked_list": ["class IncorrectConditionError(Exception):\n\t    \"\"\"Raised when an incorrect condition passed to a Repo method\"\"\"\n\t    pass\n\tclass NoSuchEntityInDB(Exception):\n\t    \"\"\"Raised by a Repo when no passed entity found in the DB\"\"\"\n\t    pass\n\tclass InvalidInputError(Exception):\n\t    \"\"\"raises when an incorrect input passed to skill methods\"\"\"\n\t    pass\n"]}
{"filename": "skill/db/sa_db_settings.py", "chunked_list": ["import os\n\tfrom pathlib import Path\n\tfrom dotenv import load_dotenv\n\tfrom sqlalchemy import event\n\tfrom sqlalchemy.engine import Engine\n\tfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom skill.db.repos.sa_repo import SARepoConfig\n\tload_dotenv()\n\t# Needed for some developing features\n", "# Should be False when production\n\tDEBUG = os.getenv(\"BOT_TOKEN\") or False\n\tDB_PROVIDER = os.getenv(\"DB_PROVIDER\") or \"sqlite\"\n\tmatch DB_PROVIDER:\n\t    case \"postgres\":\n\t        POSTGRES_DRIVER_NAME = os.getenv(\"POSTGRES_DRIVER_NAME\") or \"asyncpg\"\n\t        POSTGRES_DB_NAME = os.getenv(\"POSTGRES_DB_NAME\") or \"postgres\"\n\t        POSTGRES_USERNAME = os.getenv(\"POSTGRES_USERNAME\") or \"postgres\"\n\t        POSTGRES_HOST = os.getenv(\"POSTGRES_HOST\") or \"localhost\"\n\t        POSTGRES_PORT = os.getenv(\"POSTGRES_PORT\") or \"5432\"\n", "        POSTGRES_PASSWORD = os.getenv(\"POSTGRES_PASSWORD\")\n\t        if not POSTGRES_PASSWORD:\n\t            raise EnvironmentError(\n\t                \"POSTGRES_PASSWORD required if you are using PostgreSQL\"\n\t            )\n\t        DB_URL = (\n\t            f\"postgresql+{POSTGRES_DRIVER_NAME}://\"\n\t            + f\"{POSTGRES_USERNAME}:{POSTGRES_PASSWORD}\"\n\t            + f\"@{POSTGRES_HOST}:{POSTGRES_PORT}\"\n\t            + f\"/{POSTGRES_DB_NAME}\"\n", "        )\n\t    case _:\n\t        SQLITE_DRIVER_NAME = os.getenv(\"SQLITE_DRIVER_NAME\") or \"aiosqlite\"\n\t        SQLITE_DB_NAME = os.getenv(\"SQLITE_DB_NAME\") or \"data.db\"\n\t        ROOT_DIR = Path(__file__).parent.parent.parent.resolve()\n\t        # In case you want to change path to SQLite DB file,\n\t        # just change this variable\n\t        SQLITE_DB_FILE_PATH = os.getenv(\"SQLITE_DB_FILE_PATH\") or os.path.join(\n\t            ROOT_DIR, f\"{SQLITE_DB_NAME}\"\n\t        )\n", "        # URL for your database\n\t        DB_URL = f\"sqlite+{SQLITE_DRIVER_NAME}:///\" + SQLITE_DB_FILE_PATH\n\tengine = create_async_engine(DB_URL, echo=False)\n\tasync_session = sessionmaker(\n\t    engine, expire_on_commit=False, class_=AsyncSession  # type: ignore\n\t)\n\tsa_repo_config = SARepoConfig(connection_provider=async_session)\n\tif DB_PROVIDER == \"sqlite\":\n\t    @event.listens_for(Engine, \"connect\")\n\t    def set_sqlite_pragma(dbapi_connection, connection_record):\n", "        cursor = dbapi_connection.cursor()\n\t        cursor.execute(\"PRAGMA foreign_keys=ON\")\n\t        cursor.close()\n"]}
{"filename": "skill/db/__init__.py", "chunked_list": []}
{"filename": "skill/db/repos/get_repo.py", "chunked_list": ["from typing import Literal\n\tfrom skill.db.repos.base_repo import BaseRepo\n\tfrom skill.db.repos.sa_repo import SARepo\n\tfrom skill.db.sa_db_settings import sa_repo_config\n\tdef get_repo(repo_type: Literal[\"sa\"]) -> BaseRepo:\n\t    match repo_type:\n\t        case \"sa\":\n\t            return SARepo(sa_repo_config)\n"]}
{"filename": "skill/db/repos/base_repo.py", "chunked_list": ["from __future__ import annotations\n\timport abc\n\tfrom typing import (TYPE_CHECKING, Any, AsyncContextManager, Callable,\n\t                    Iterable, Literal)\n\tfrom uuid import UUID\n\tif TYPE_CHECKING:\n\t    from skill.entities import Activity, Tip, TipsTopic, User\n\tclass RepoConfig:\n\t    connection_provider: Callable[..., AsyncContextManager[Any]]\n\t    def __init__(\n", "        self, connection_provider: Callable[..., AsyncContextManager[Any]]\n\t    ) -> None:\n\t        self.connection_provider = connection_provider\n\tclass BaseRepo(abc.ABC):\n\t    @abc.abstractmethod\n\t    def __init__(self, config: RepoConfig) -> None:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def insert_user(self, user: User) -> User:\n\t        pass\n", "    @abc.abstractmethod\n\t    async def insert_users(self, users: Iterable[User]) -> list[User]:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def insert_activity(self, activity: Activity) -> Activity:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def insert_activities(\n\t        self, activities: Iterable[Activity]\n\t    ) -> list[Activity]:\n", "        pass\n\t    @abc.abstractmethod\n\t    async def insert_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def insert_tips_topics(\n\t        self, tips_topics: Iterable[TipsTopic]\n\t    ) -> list[TipsTopic]:\n\t        pass\n\t    @abc.abstractmethod\n", "    async def insert_tip(self, tip: Tip) -> Tip:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def insert_tips(self, tips: Iterable[Tip]) -> list[Tip]:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def delete_all_users(self) -> None:\n\t        \"\"\"Deletes ALL users entities from the db\"\"\"\n\t        pass\n\t    @abc.abstractmethod\n", "    async def delete_all_activities(self) -> None:\n\t        \"\"\"Deletes ALL activities entities from the db\"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def delete_all_tips_topics(self) -> None:\n\t        \"\"\"Deletes ALL tips topics entities from the db\"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def delete_all_tips(self) -> None:\n\t        \"\"\"Deletes ALL tips entities from the db\"\"\"\n", "        pass\n\t    @abc.abstractmethod\n\t    async def delete_user(self, user: User) -> User:\n\t        \"\"\"Deletes the passed user entity from the db\n\t        Args:\n\t            user (User): user that is going to be deleted\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            User: deleted entity\n", "        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def delete_activity(self, activity: Activity) -> Activity:\n\t        \"\"\"Deletes the passed activity entity from the db\n\t        Args:\n\t            activity (Activity): activity that is going to be deleted\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n", "            Activity: deleted entity\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def delete_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n\t        \"\"\"Deletes the passed tips topic entity from the db\n\t        with all the related tips\n\t        Args:\n\t            tips_topic (TipsTopic): tips topic that is going to be deleted\n\t        Raises:\n", "            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            TipsTopic: deleted entity\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def delete_tip(self, tip: Tip) -> Tip:\n\t        \"\"\"Deletes the passed tip entity from the db\n\t        Args:\n\t            tip (Tip): tip that is going to be deleted\n", "        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            Tip: deleted entity\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def update_user(self, user: User) -> User:\n\t        \"\"\"Updates the passed user entity in the db\n\t        Args:\n", "            user (User): user that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            User: updated entity\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def update_activity(self, activity: Activity) -> Activity:\n\t        \"\"\"Updates the passed user entity in the db\n", "        Args:\n\t            activity (User): activity that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            Activity: updated entity\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def update_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n", "        \"\"\"Updates the passed tips topic entity in the db\n\t        Args:\n\t            tips_topic (TipsTopic): tips topic that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            TipsTopic: updated entity\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n", "    async def update_tip(self, tip: Tip) -> Tip:\n\t        \"\"\"Updates the passed tip entity in the db\n\t        Args:\n\t            tip (Tip): tip that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            Tip: updated entity\n\t        \"\"\"\n\t        pass\n", "    @abc.abstractmethod\n\t    async def get_user_by_id(self, id: str) -> User | None:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def get_activity_by_id(self, id: UUID) -> Activity | None:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def get_tips_topic_by_id(self, id: UUID) -> TipsTopic | None:\n\t        pass\n\t    @abc.abstractmethod\n", "    async def get_tips_topic_by_name(self, name: str) -> TipsTopic | None:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def get_tip_by_id(self, id: UUID) -> Tip | None:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def get_tips_topics(\n\t        self, limit: int | None = None\n\t    ) -> list[TipsTopic]:\n\t        \"\"\"If no limit provided, the method should return\n", "        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n\t        Returns:\n\t            list[TipsTopic]: list with objects\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def get_topic_tips(self, topic_id: UUID) -> list[Tip]:\n", "        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n\t        Returns:\n\t            list[Tip]: list with objects ordered by creation date\n\t        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n", "    async def get_tips(self, limit: int | None = None) -> list[Tip]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n\t        Returns:\n\t            list[Tip]: list with objects\n\t        \"\"\"\n\t        pass\n", "    @abc.abstractmethod\n\t    async def get_activities(self, limit: int | None = None) -> list[Activity]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n\t        Returns:\n\t            list[Activity]: list with objects\n\t        \"\"\"\n", "        pass\n\t    @abc.abstractmethod\n\t    async def get_users(self, limit: int | None = None) -> list[User]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n\t        Returns:\n\t            list[User]: list with objects\n", "        \"\"\"\n\t        pass\n\t    @abc.abstractmethod\n\t    async def count_all_users(self) -> int:\n\t        pass\n\t    @abc.abstractmethod\n\t    async def count_users_with_streak(\n\t        self,\n\t        streak: int,\n\t        condition: Literal[\"<\"]\n", "        | Literal[\">\"]\n\t        | Literal[\"<=\"]\n\t        | Literal[\">=\"]\n\t        | Literal[\"==\"],\n\t    ) -> int:\n\t        pass\n"]}
{"filename": "skill/db/repos/sa_repo.py", "chunked_list": ["import asyncio\n\tfrom typing import Callable, Iterable, Literal\n\tfrom uuid import UUID\n\tfrom sqlalchemy import delete, func, select\n\tfrom sqlalchemy.ext.asyncio import AsyncSession\n\tfrom skill.db.models.sa_models import (ActivityModel, TipModel, TipsTopicModel,\n\t                                       UserModel)\n\tfrom skill.db.repos.base_repo import BaseRepo, RepoConfig\n\tfrom skill.entities import Activity, Tip, TipsTopic, User\n\tfrom skill.exceptions import IncorrectConditionError, NoSuchEntityInDB\n", "class SARepoConfig(RepoConfig):\n\t    connection_provider: Callable[..., AsyncSession]\n\t    def __init__(\n\t        self, connection_provider: Callable[..., AsyncSession]\n\t    ) -> None:\n\t        self.connection_provider = connection_provider\n\tclass SARepo(BaseRepo):\n\t    def __init__(self, config: SARepoConfig) -> None:\n\t        self.__config = config\n\t    async def insert_user(self, user: User) -> User:\n", "        async with self.__config.connection_provider() as session:\n\t            model = UserModel(user)\n\t            session.add(model)\n\t            await session.commit()\n\t            return await self.get_user_by_id(model.id)  # type: ignore\n\t    async def insert_users(self, users: Iterable[User]) -> list[User]:\n\t        async with self.__config.connection_provider() as session:\n\t            models = [UserModel(user) for user in users]\n\t            session.add_all(models)\n\t            await session.commit()\n", "            return [\n\t                entity\n\t                for entity in await asyncio.gather(\n\t                    *[self.get_user_by_id(model.id) for model in models]\n\t                )\n\t            ]  # type: ignore\n\t    async def insert_activity(self, activity: Activity) -> Activity:\n\t        async with self.__config.connection_provider() as session:\n\t            model = ActivityModel(activity)\n\t            session.add(model)\n", "            await session.commit()\n\t            return await self.get_activity_by_id(model.id)  # type: ignore\n\t    async def insert_activities(\n\t        self, activities: Iterable[Activity]\n\t    ) -> list[Activity]:\n\t        async with self.__config.connection_provider() as session:\n\t            models = [ActivityModel(activity) for activity in activities]\n\t            session.add_all(models)\n\t            await session.commit()\n\t            return [\n", "                entity\n\t                for entity in await asyncio.gather(\n\t                    *[self.get_activity_by_id(model.id) for model in models]\n\t                )\n\t            ]  # type: ignore\n\t    async def insert_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n\t        async with self.__config.connection_provider() as session:\n\t            model = TipsTopicModel(tips_topic)\n\t            session.add(model)\n\t            await session.commit()\n", "            return await self.get_tips_topic_by_id(model.id)  # type: ignore\n\t    async def insert_tips_topics(\n\t        self, tips_topics: Iterable[TipsTopic]\n\t    ) -> list[TipsTopic]:\n\t        async with self.__config.connection_provider() as session:\n\t            models = [TipsTopicModel(tips_topic) for tips_topic in tips_topics]\n\t            session.add_all(models)\n\t            await session.commit()\n\t            return [\n\t                entity\n", "                for entity in await asyncio.gather(\n\t                    *[self.get_tips_topic_by_id(model.id) for model in models]\n\t                )\n\t            ]  # type: ignore\n\t    async def insert_tip(self, tip: Tip) -> Tip:\n\t        async with self.__config.connection_provider() as session:\n\t            model = TipModel(tip)\n\t            session.add(model)\n\t            await session.commit()\n\t            return await self.get_tip_by_id(model.id)  # type: ignore\n", "    async def insert_tips(self, tips: Iterable[Tip]) -> list[Tip]:\n\t        async with self.__config.connection_provider() as session:\n\t            models = [TipModel(tip) for tip in tips]\n\t            session.add_all(models)\n\t            await session.commit()\n\t            return [\n\t                entity\n\t                for entity in await asyncio.gather(\n\t                    *[self.get_tip_by_id(model.id) for model in models]\n\t                )\n", "            ]\n\t    async def delete_all_users(self) -> None:\n\t        \"\"\"Deletes ALL users entities from the db\"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = delete(UserModel)\n\t            await session.execute(q)\n\t            await session.commit()\n\t    async def delete_all_activities(self) -> None:\n\t        \"\"\"Deletes ALL activities entities from the db\"\"\"\n\t        async with self.__config.connection_provider() as session:\n", "            q = delete(ActivityModel)\n\t            await session.execute(q)\n\t            await session.commit()\n\t    async def delete_all_tips_topics(self) -> None:\n\t        \"\"\"Deletes ALL tips AND ALL related tips from the db\"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = delete(TipsTopicModel)\n\t            await session.execute(q)\n\t            await session.commit()\n\t    async def delete_all_tips(self) -> None:\n", "        \"\"\"Deletes ALL tips entities from the db\"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = delete(TipModel)\n\t            await session.execute(q)\n\t            await session.commit()\n\t    async def delete_user(self, user: User) -> User:\n\t        \"\"\"Deletes the passed user entity from the db\n\t        Args:\n\t            user (User): user that is going to be deleted\n\t        Raises:\n", "            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            User: deleted entity\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            model = await session.get(UserModel, user._id)\n\t            if not model:\n\t                raise NoSuchEntityInDB(f\"No user with next id: {user._id}\")\n\t            await session.delete(model)\n\t            await session.commit()\n", "            return model.as_entity(self)\n\t    async def delete_activity(self, activity: Activity) -> Activity:\n\t        \"\"\"Deletes the passed activity entity from the db\n\t        Args:\n\t            activity (Activity): activity that is going to be deleted\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            Activity: deleted entity\n\t        \"\"\"\n", "        async with self.__config.connection_provider() as session:\n\t            model = await session.get(ActivityModel, activity._id)\n\t            if not model:\n\t                raise NoSuchEntityInDB(\n\t                    f\"No activity with next id: {activity._id}\"\n\t                )\n\t            await session.delete(model)\n\t            await session.commit()\n\t            return model.as_entity(self)\n\t    async def delete_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n", "        \"\"\"Deletes the passed tips topic entity from the db\n\t        with all the related tips\n\t        Args:\n\t            tips_topic (TipsTopic): tips topic that is going to be deleted\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            TipsTopic: deleted entity\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n", "            model = await session.get(TipsTopicModel, tips_topic._id)\n\t            if not model:\n\t                raise NoSuchEntityInDB(\n\t                    f\"No tips topic with next id: {tips_topic._id}\"\n\t                )\n\t            await session.delete(model)\n\t            await session.commit()\n\t            return model.as_entity(self)\n\t    async def delete_tip(self, tip: Tip) -> Tip:\n\t        \"\"\"Deletes the passed tip entity from the db\n", "        Args:\n\t            tip (Tip): tip that is going to be deleted\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            Tip: deleted entity\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            model = await session.get(TipModel, tip._id)\n\t            if not model:\n", "                raise NoSuchEntityInDB(f\"No tip with next id: {tip._id}\")\n\t            await session.delete(model)\n\t            await session.commit()\n\t            return model.as_entity(self)\n\t    async def update_user(self, user: User) -> User:\n\t        \"\"\"Updates the passed user entity in the db\n\t        Args:\n\t            user (User): user that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n", "        Returns:\n\t            User: updated entity\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            model_in_db = await session.get(UserModel, user._id)\n\t            if not model_in_db:\n\t                raise NoSuchEntityInDB(f\"No user with next id: {user._id}\")\n\t            model = UserModel(user)\n\t            await session.merge(model)\n\t            await session.commit()\n", "            return await self.get_user_by_id(model.id)  # type: ignore\n\t    async def update_activity(self, activity: Activity) -> Activity:\n\t        \"\"\"Updates the passed user entity in the db\n\t        Args:\n\t            activity (User): activity that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            Activity: updated entity\n\t        \"\"\"\n", "        async with self.__config.connection_provider() as session:\n\t            model_in_db = await session.get(ActivityModel, activity._id)\n\t            if not model_in_db:\n\t                raise NoSuchEntityInDB(\n\t                    f\"No activity with next id: {activity._id}\"\n\t                )\n\t            model = ActivityModel(activity)\n\t            await session.merge(model)\n\t            await session.commit()\n\t            return await self.get_activity_by_id(model.id)  # type: ignore\n", "    async def update_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n\t        \"\"\"Updates the passed tips topic entity in the db\n\t        Args:\n\t            tips_topic (TipsTopic): tips topic that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            TipsTopic: updated entity\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n", "            model_in_db = await session.get(TipsTopicModel, tips_topic._id)\n\t            if not model_in_db:\n\t                raise NoSuchEntityInDB(\n\t                    f\"No tips topic with next id: {tips_topic._id}\"\n\t                )\n\t            model = TipsTopicModel(tips_topic)\n\t            await session.merge(model)\n\t            await session.commit()\n\t            return await self.get_tips_topic_by_id(model.id)  # type: ignore\n\t    async def update_tip(self, tip: Tip) -> Tip:\n", "        \"\"\"Updates the passed tip entity in the db\n\t        Args:\n\t            tip (Tip): tip that is going to be updated\n\t        Raises:\n\t            NoSuchEntityInDB: raised if no such entity in the DB\n\t        Returns:\n\t            Tip: updated entity\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            model_in_db = await session.get(TipModel, tip._id)\n", "            if not model_in_db:\n\t                raise NoSuchEntityInDB(\n\t                    f\"No tips topic with next id: {tip._id}\"\n\t                )\n\t            model = TipModel(tip)\n\t            await session.merge(model)\n\t            await session.commit()\n\t            return await self.get_tip_by_id(model.id)  # type: ignore\n\t    async def get_user_by_id(self, id: str) -> User | None:\n\t        async with self.__config.connection_provider() as session:\n", "            q = select(UserModel).where(UserModel.id == id)\n\t            res = (await session.execute(q)).scalar()\n\t            return res and res.as_entity(self)\n\t    async def get_activity_by_id(self, id: UUID) -> Activity | None:\n\t        async with self.__config.connection_provider() as session:\n\t            q = select(ActivityModel).where(ActivityModel.id == id)\n\t            res = (await session.execute(q)).scalar()\n\t            return res and res.as_entity(self)\n\t    async def get_tips_topic_by_id(self, id: UUID) -> TipsTopic | None:\n\t        async with self.__config.connection_provider() as session:\n", "            q = select(TipsTopicModel).where(TipsTopicModel.id == id)\n\t            res = (await session.execute(q)).scalar()\n\t            return res and res.as_entity(self)\n\t    async def get_tips_topic_by_name(self, name: str) -> TipsTopic | None:\n\t        async with self.__config.connection_provider() as session:\n\t            q = select(TipsTopicModel).where(TipsTopicModel.name_text == name)\n\t            res = (await session.execute(q)).scalar()\n\t            return res and res.as_entity(self)\n\t    async def get_tip_by_id(self, id: UUID) -> Tip | None:\n\t        async with self.__config.connection_provider() as session:\n", "            q = select(TipModel).where(TipModel.id == id)\n\t            res = (await session.execute(q)).scalar()\n\t            return res and res.as_entity(self)\n\t    async def get_tips_topics(\n\t        self, limit: int | None = None\n\t    ) -> list[TipsTopic]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n", "            Defaults to None.\n\t        Returns:\n\t            list[TipsTopic]: list with objects ordered by creation date\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = (\n\t                select(TipsTopicModel)\n\t                .order_by(TipsTopicModel.created_date)\n\t                .limit(limit)\n\t            )\n", "            res = (await session.execute(q)).scalars().all()\n\t            return [model.as_entity(self) for model in res]\n\t    async def get_topic_tips(\n\t        self, topic_id: UUID, limit: int | None = None\n\t    ) -> list[Tip]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n", "        Returns:\n\t            list[Tip]: list with objects ordered by creation date\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = (\n\t                select(TipModel)\n\t                .where(TipModel.tips_topic_id == topic_id)\n\t                .order_by(TipModel.created_date)\n\t                .limit(limit)\n\t            )\n", "            res = (await session.execute(q)).scalars().all()\n\t            return [model.as_entity(self) for model in res]\n\t    async def get_tips(self, limit: int | None = None) -> list[Tip]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n\t        Returns:\n\t            list[Tip]: list with objects ordered by creation date\n", "        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = select(TipModel).order_by(TipModel.created_date).limit(limit)\n\t            res = (await session.execute(q)).scalars().all()\n\t            return [model.as_entity(self) for model in res]\n\t    async def get_activities(self, limit: int | None = None) -> list[Activity]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n", "            Defaults to None.\n\t        Returns:\n\t            list[Activity]: list with objects ordered by creation date\n\t        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = (\n\t                select(ActivityModel)\n\t                .order_by(ActivityModel.created_date)\n\t                .limit(limit)\n\t            )\n", "            res = (await session.execute(q)).scalars().all()\n\t            return [model.as_entity(self) for model in res]\n\t    async def get_users(self, limit: int | None = None) -> list[User]:\n\t        \"\"\"If no limit provided, the method should return\n\t        all tips topics from the DB\n\t        Args:\n\t            limit (int | None, optional): how many objects you want to get.\n\t            Defaults to None.\n\t        Returns:\n\t            list[User]: list with objects ordered by joining date\n", "        \"\"\"\n\t        async with self.__config.connection_provider() as session:\n\t            q = select(UserModel).order_by(UserModel.join_date).limit(limit)\n\t            res = (await session.execute(q)).scalars().all()\n\t            return [model.as_entity(self) for model in res]\n\t    async def count_all_users(self) -> int:\n\t        async with self.__config.connection_provider() as session:\n\t            q = select(func.count(UserModel.id))\n\t            return (await session.execute(q)).scalar()  # type: ignore\n\t    async def count_users_with_streak(\n", "        self,\n\t        streak: int,\n\t        condition: Literal[\"<\"]\n\t        | Literal[\">\"]\n\t        | Literal[\"<=\"]\n\t        | Literal[\">=\"]\n\t        | Literal[\"==\"],\n\t    ) -> int:\n\t        async with self.__config.connection_provider() as session:\n\t            Q_CONDITIONS = {\n", "                \">\": UserModel.streak > streak,\n\t                \"<\": UserModel.streak < streak,\n\t                \">=\": UserModel.streak >= streak,\n\t                \"<=\": UserModel.streak <= streak,\n\t                \"==\": UserModel.streak == streak,\n\t            }\n\t            if condition not in Q_CONDITIONS:\n\t                raise IncorrectConditionError()\n\t            q = select(func.count(UserModel.id)).where(Q_CONDITIONS[condition])\n\t            return (await session.execute(q)).scalar()  # type: ignore\n"]}
{"filename": "skill/db/repos/__init__.py", "chunked_list": []}
{"filename": "skill/db/models/__init__.py", "chunked_list": []}
{"filename": "skill/db/models/sa_models.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime, time, timedelta\n\tfrom uuid import UUID\n\tfrom sqlalchemy import (Column, DateTime, ForeignKey, Integer, Interval,\n\t                        String, Table, Time, Uuid)\n\tfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\tfrom skill.db.repos.base_repo import BaseRepo\n\tfrom skill.entities import Activity, Tip, TipsTopic, User\n\tfrom skill.utils import TextWithTTS\n\tclass BaseModel(DeclarativeBase):\n", "    pass\n\theard_tips_table = Table(\n\t    \"heard_tips\",\n\t    BaseModel.metadata,\n\t    Column(\"user_id\", ForeignKey(\"users.id\"), primary_key=True),\n\t    Column(\"tip_id\", ForeignKey(\"tips.id\"), primary_key=True),\n\t)\n\tclass UserModel(BaseModel):\n\t    __tablename__ = \"users\"\n\t    id: Mapped[str] = mapped_column(String(64), primary_key=True)\n", "    streak: Mapped[int] = mapped_column(Integer)\n\t    last_skill_use: Mapped[datetime | None] = mapped_column(\n\t        DateTime(True), default=None\n\t    )\n\t    last_wake_up_time: Mapped[time | None] = mapped_column(\n\t        Time(), default=None\n\t    )\n\t    join_date: Mapped[datetime] = mapped_column(DateTime(True))\n\t    heard_tips: Mapped[list[TipModel]] = relationship(\n\t        \"TipModel\",\n", "        back_populates=\"users_heard\",\n\t        order_by=\"TipModel.created_date\",\n\t        lazy=\"selectin\",\n\t        secondary=heard_tips_table,\n\t    )\n\t    def __init__(self, entity: User):\n\t        self.id = entity._id\n\t        self.streak = entity._streak\n\t        self.last_skill_use = entity.last_skill_use\n\t        self.last_wake_up_time = entity.last_wake_up_time\n", "        self.join_date = entity._join_date\n\t        self.heard_tips = [\n\t            TipModel(heard_tip) for heard_tip in entity._heard_tips\n\t        ]\n\t    def as_entity(self, repo: BaseRepo) -> User:\n\t        return User(\n\t            id=self.id,\n\t            streak=self.streak,\n\t            last_skill_use=self.last_skill_use,\n\t            last_wake_up_time=self.last_wake_up_time,\n", "            join_date=self.join_date,\n\t            heard_tips=[tip.as_entity(repo) for tip in self.heard_tips],\n\t            repo=repo,\n\t        )\n\tclass ActivityModel(BaseModel):\n\t    __tablename__ = \"activities\"\n\t    id: Mapped[UUID] = mapped_column(Uuid, primary_key=True)\n\t    description_text: Mapped[str] = mapped_column(\n\t        String(512), unique=True, index=True\n\t    )\n", "    description_tts: Mapped[str] = mapped_column(String(512))\n\t    created_date: Mapped[datetime] = mapped_column(DateTime(True))\n\t    occupation_time: Mapped[timedelta] = mapped_column(Interval)\n\t    def __init__(self, entity: Activity):\n\t        self.id = entity._id\n\t        self.created_date = entity._created_date\n\t        self.description_text, self.description_tts = (\n\t            entity.description.text,\n\t            entity.description.tts,\n\t        )\n", "        self.occupation_time = entity.occupation_time\n\t    def as_entity(self, repo: BaseRepo) -> Activity:\n\t        return Activity(\n\t            id=self.id,\n\t            created_date=self.created_date,\n\t            description=TextWithTTS(\n\t                self.description_text, self.description_tts\n\t            ),\n\t            occupation_time=self.occupation_time,\n\t            repo=repo,\n", "        )\n\tclass TipModel(BaseModel):\n\t    __tablename__ = \"tips\"\n\t    id: Mapped[UUID] = mapped_column(Uuid, primary_key=True)\n\t    short_description_text: Mapped[str] = mapped_column(\n\t        String(256), unique=True, index=True\n\t    )\n\t    short_description_tts: Mapped[str] = mapped_column(String(256))\n\t    tip_content_text: Mapped[str] = mapped_column(\n\t        String(1024), unique=True, index=True\n", "    )\n\t    tip_content_tts: Mapped[str] = mapped_column(String(1024))\n\t    tips_topic_id: Mapped[UUID] = mapped_column(\n\t        Uuid, ForeignKey(\"tips_topics.id\", ondelete=\"CASCADE\")\n\t    )\n\t    tips_topic = relationship(\n\t        \"TipsTopicModel\",\n\t        back_populates=\"tips\",\n\t        lazy=\"selectin\",\n\t    )\n", "    users_heard = relationship(\"UserModel\", secondary=heard_tips_table)\n\t    created_date: Mapped[datetime] = mapped_column(DateTime(True))\n\t    def __init__(self, entity: Tip) -> None:\n\t        self.id = entity._id\n\t        self.short_description_text, self.short_description_tts = (\n\t            entity.short_description.text,\n\t            entity.short_description.tts,\n\t        )\n\t        self.tip_content_text, self.tip_content_tts = (\n\t            entity.tip_content.text,\n", "            entity.tip_content.tts,\n\t        )\n\t        self.tips_topic_id = entity.tips_topic._id\n\t        self.created_date = entity._created_date\n\t    def as_entity(self, repo: BaseRepo) -> Tip:\n\t        return Tip(\n\t            id=self.id,\n\t            created_date=self.created_date,\n\t            short_description=TextWithTTS(\n\t                self.short_description_text, self.short_description_tts\n", "            ),\n\t            tip_content=TextWithTTS(\n\t                self.tip_content_text, self.tip_content_tts\n\t            ),\n\t            tips_topic=self.tips_topic.as_entity(repo),\n\t            repo=repo,\n\t        )\n\tclass TipsTopicModel(BaseModel):\n\t    __tablename__ = \"tips_topics\"\n\t    id: Mapped[UUID] = mapped_column(Uuid, primary_key=True)\n", "    name_text: Mapped[str] = mapped_column(\n\t        String(256), unique=True, index=True\n\t    )\n\t    name_tts: Mapped[str] = mapped_column(String(256))\n\t    topic_description_text: Mapped[str] = mapped_column(\n\t        String(1024), unique=True, index=True\n\t    )\n\t    topic_description_tts: Mapped[str] = mapped_column(String(1024))\n\t    tips = relationship(\n\t        \"TipModel\",\n", "        back_populates=\"tips_topic\",\n\t        passive_deletes=True,\n\t    )\n\t    created_date: Mapped[datetime] = mapped_column(DateTime(True))\n\t    def __init__(self, entity: TipsTopic) -> None:\n\t        self.id = entity._id\n\t        self.name_text, self.name_tts = entity.name.text, entity.name.tts\n\t        self.topic_description_text, self.topic_description_tts = (\n\t            entity.topic_description.text,\n\t            entity.topic_description.tts,\n", "        )\n\t        self.created_date = entity._created_date\n\t    def as_entity(self, repo: BaseRepo) -> TipsTopic:\n\t        return TipsTopic(\n\t            id=self.id,\n\t            created_date=self.created_date,\n\t            name=TextWithTTS(self.name_text, self.name_tts),\n\t            topic_description=TextWithTTS(\n\t                self.topic_description_text, self.topic_description_tts\n\t            ),\n", "            repo=repo,\n\t        )\n"]}
{"filename": "skill/db/migrations/alembic/env.py", "chunked_list": ["import asyncio\n\tfrom logging.config import fileConfig\n\tfrom alembic import context\n\tfrom sqlalchemy import engine_from_config, pool\n\tfrom sqlalchemy.engine import Connection\n\tfrom sqlalchemy.ext.asyncio import AsyncEngine\n\tfrom skill.db.models.sa_models import BaseModel\n\tfrom skill.db.sa_db_settings import DB_URL\n\t# this is the Alembic Config object, which provides\n\t# access to the values within the .ini file in use.\n", "config = context.config\n\tconfig.set_main_option(\"sqlalchemy.url\", DB_URL)\n\t# Interpret the config file for Python logging.\n\t# This line sets up loggers basically.\n\tif config.config_file_name is not None:\n\t    fileConfig(config.config_file_name)\n\t# add your model's MetaData object here\n\t# for 'autogenerate' support\n\t# from myapp import mymodel\n\t# target_metadata = mymodel.Base.metadata\n", "target_metadata = BaseModel.metadata\n\t# other values from the config, defined by the needs of env.py,\n\t# can be acquired:\n\t# my_important_option = config.get_main_option(\"my_important_option\")\n\t# ... etc.\n\tdef run_migrations_offline() -> None:\n\t    \"\"\"Run migrations in 'offline' mode.\n\t    This configures the context with just a URL\n\t    and not an Engine, though an Engine is acceptable\n\t    here as well.  By skipping the Engine creation\n", "    we don't even need a DBAPI to be available.\n\t    Calls to context.execute() here emit the given string to the\n\t    script output.\n\t    \"\"\"\n\t    url = config.get_main_option(\"sqlalchemy.url\")\n\t    context.configure(\n\t        url=url,\n\t        target_metadata=target_metadata,\n\t        literal_binds=True,\n\t        dialect_opts={\"paramstyle\": \"named\"},\n", "    )\n\t    with context.begin_transaction():\n\t        context.run_migrations()\n\tdef do_run_migrations(connection: Connection) -> None:\n\t    context.configure(connection=connection, target_metadata=target_metadata)\n\t    with context.begin_transaction():\n\t        context.run_migrations()\n\tasync def run_migrations_online() -> None:\n\t    \"\"\"Run migrations in 'online' mode.\n\t    In this scenario we need to create an Engine\n", "    and associate a connection with the context.\n\t    \"\"\"\n\t    connectable = AsyncEngine(\n\t        engine_from_config(\n\t            config.get_section(config.config_ini_section),  # type: ignore\n\t            prefix=\"sqlalchemy.\",\n\t            poolclass=pool.NullPool,\n\t            future=True,\n\t        )\n\t    )\n", "    async with connectable.connect() as connection:\n\t        await connection.run_sync(do_run_migrations)\n\t    await connectable.dispose()\n\tif context.is_offline_mode():\n\t    run_migrations_offline()\n\telse:\n\t    asyncio.run(run_migrations_online())\n"]}
{"filename": "skill/db/migrations/alembic/versions/13f56def336c_initial.py", "chunked_list": ["\"\"\"Initial\n\tRevision ID: 13f56def336c\n\tRevises: \n\tCreate Date: 2023-03-25 22:31:06.656168\n\t\"\"\"\n\timport sqlalchemy as sa\n\tfrom alembic import op\n\t# revision identifiers, used by Alembic.\n\trevision = '13f56def336c'\n\tdown_revision = None\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.create_table('activities',\n\t    sa.Column('id', sa.Uuid(), nullable=False),\n\t    sa.Column('description_text', sa.String(length=512), nullable=False),\n\t    sa.Column('description_tts', sa.String(length=512), nullable=False),\n\t    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n\t    sa.Column('occupation_time', sa.Interval(), nullable=False),\n", "    sa.PrimaryKeyConstraint('id')\n\t    )\n\t    op.create_table('tips_topics',\n\t    sa.Column('id', sa.Uuid(), nullable=False),\n\t    sa.Column('name_text', sa.String(length=256), nullable=False),\n\t    sa.Column('name_tts', sa.String(length=256), nullable=False),\n\t    sa.Column('topic_description_text', sa.String(length=1024), nullable=False),\n\t    sa.Column('topic_description_tts', sa.String(length=1024), nullable=False),\n\t    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n\t    sa.PrimaryKeyConstraint('id')\n", "    )\n\t    op.create_table('users',\n\t    sa.Column('id', sa.String(length=64), nullable=False),\n\t    sa.Column('streak', sa.Integer(), nullable=False),\n\t    sa.Column('last_skill_use', sa.DateTime(timezone=True), nullable=True),\n\t    sa.Column('last_wake_up_time', sa.Time(), nullable=True),\n\t    sa.Column('join_date', sa.DateTime(timezone=True), nullable=False),\n\t    sa.PrimaryKeyConstraint('id')\n\t    )\n\t    op.create_table('tips',\n", "    sa.Column('id', sa.Uuid(), nullable=False),\n\t    sa.Column('short_description_text', sa.String(length=256), nullable=False),\n\t    sa.Column('short_description_tts', sa.String(length=256), nullable=False),\n\t    sa.Column('tip_content_text', sa.String(length=1024), nullable=False),\n\t    sa.Column('tip_content_tts', sa.String(length=1024), nullable=False),\n\t    sa.Column('tips_topic_id', sa.Uuid(), nullable=False),\n\t    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n\t    sa.ForeignKeyConstraint(['tips_topic_id'], ['tips_topics.id'], ondelete='CASCADE'),\n\t    sa.PrimaryKeyConstraint('id')\n\t    )\n", "    op.create_table('heard_tips',\n\t    sa.Column('user_id', sa.String(length=64), nullable=False),\n\t    sa.Column('tip_id', sa.Uuid(), nullable=False),\n\t    sa.ForeignKeyConstraint(['tip_id'], ['tips.id'], ),\n\t    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n\t    sa.PrimaryKeyConstraint('user_id', 'tip_id')\n\t    )\n\t    # ### end Alembic commands ###\n\tdef downgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n", "    op.drop_table('heard_tips')\n\t    op.drop_table('tips')\n\t    op.drop_table('users')\n\t    op.drop_table('tips_topics')\n\t    op.drop_table('activities')\n\t    # ### end Alembic commands ###\n"]}
{"filename": "skill/db/migrations/alembic/versions/17ae56c4d705_added_unique_fields_and_indexes.py", "chunked_list": ["\"\"\"Added unique fields and indexes\n\tRevision ID: 17ae56c4d705\n\tRevises: 13f56def336c\n\tCreate Date: 2023-03-28 22:08:20.183143\n\t\"\"\"\n\timport sqlalchemy as sa\n\tfrom alembic import op\n\t# revision identifiers, used by Alembic.\n\trevision = '17ae56c4d705'\n\tdown_revision = '13f56def336c'\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.create_index(op.f('ix_activities_description_text'), 'activities', ['description_text'], unique=True)\n\t    op.create_index(op.f('ix_tips_short_description_text'), 'tips', ['short_description_text'], unique=True)\n\t    op.create_index(op.f('ix_tips_tip_content_text'), 'tips', ['tip_content_text'], unique=True)\n\t    op.create_index(op.f('ix_tips_topics_name_text'), 'tips_topics', ['name_text'], unique=True)\n\t    op.create_index(op.f('ix_tips_topics_topic_description_text'), 'tips_topics', ['topic_description_text'], unique=True)\n\t    # ### end Alembic commands ###\n", "def downgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_index(op.f('ix_tips_topics_topic_description_text'), table_name='tips_topics')\n\t    op.drop_index(op.f('ix_tips_topics_name_text'), table_name='tips_topics')\n\t    op.drop_index(op.f('ix_tips_tip_content_text'), table_name='tips')\n\t    op.drop_index(op.f('ix_tips_short_description_text'), table_name='tips')\n\t    op.drop_index(op.f('ix_activities_description_text'), table_name='activities')\n\t    # ### end Alembic commands ###\n"]}
{"filename": "skill/messages/select.py", "chunked_list": ["from skill.messages.ru_messages import RUMessages\n\tPOSIX_alliases = {\"ru-RU\": RUMessages}\n\tdef auto(locale):\n\t    \"\"\"Determine what Messages class should be used according to\n\t    user's locale.\n\t    Args:\n\t        locale (str): POSIX language code\n\t    Returns:\n\t        Type[BaseMessages]: Messages class for the specified language\n\t    \"\"\"\n", "    if locale not in POSIX_alliases:\n\t        return RUMessages\n\t    return POSIX_alliases[locale]\n"]}
{"filename": "skill/messages/base_messages.py", "chunked_list": ["import abc\n\timport datetime\n\tfrom skill.utils import TextWithTTS\n\tfrom typing import List\n\tfrom skill.sleep_calculator import SleepCalculation\n\tfrom skill.entities import Tip, Activity\n\tclass BaseMessages(abc.ABC):\n\t    MENU_BUTTONS_TEXT: list[str]\n\t    TIP_TOPIC_SELECTION_BUTTONS_TEXT: list[str]\n\t    SLEEP_TIME_PROPOSAL_BUTTONS_TEXT: list[str]\n", "    SLEEP_MODE_SELECTION_BUTTONS_TEXT: list[str]\n\t    POST_SLEEP_CALCULATION_BUTTONS_TEXT: list[str]\n\t    def __init__(self):\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_start_message_intro(self, time: datetime.datetime) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_start_message_comeback(\n\t        self, time: datetime.datetime, streak: int, scoreboard: int\n", "    ) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_menu_welcome_message(self) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_info_message(self) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_ask_tip_topic_message(self) -> TextWithTTS:\n", "        pass\n\t    @abc.abstractmethod\n\t    def get_propose_yesterday_wake_up_time_message(\n\t        self, last_time: datetime.time\n\t    ) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_ask_wake_up_time_message(self) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n", "    def get_ask_sleep_mode_message(self) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_tip_message(self, tip: Tip) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_sleep_calc_time_message(\n\t        self,\n\t        sleep_calc_result: SleepCalculation,\n\t        activities: List[Activity],\n", "    ) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_good_night_message(self) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_wrong_topic_message(self, topic_name: str) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_generic_error_message(self) -> TextWithTTS:\n", "        pass\n\t    @abc.abstractmethod\n\t    def get_wrong_time_message(self) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_help_message(self) -> TextWithTTS:\n\t        pass\n\t    @abc.abstractmethod\n\t    def get_quit_message(self) -> TextWithTTS:\n\t        pass\n"]}
{"filename": "skill/messages/unicode_literals.py", "chunked_list": ["DASH = \"—\"\n\tLAQUO = \"«\"\n\tRAQUO = \"»\"\n"]}
{"filename": "skill/messages/debug.py", "chunked_list": ["import datetime\n\tfrom skill.utils import TextWithTTS\n\tdef messages_showcase(messages_class):\n\t    msg = messages_class()\n\t    class QuaziTip:\n\t        tip_content = TextWithTTS(\n\t            \"ложитесь спать в полдень, это помогает пищеварению\",\n\t            \"лажитесь спать в п+олдень - это помогает пищеварению\",\n\t        )\n\t    class QuaziAct:\n", "        description = TextWithTTS(\"выкинуть мусор\", \"в+ыкинуть м+усор\")\n\t    print(msg.get_start_message_intro(datetime.datetime.now()))\n\t    print()\n\t    print(msg.get_start_message_comeback(datetime.datetime.now(), 42, 26))\n\t    print()\n\t    print(msg.get_menu_welcome_message())\n\t    print()\n\t    print(msg.get_info_message())\n\t    print()\n\t    print(msg.get_ask_tip_topic_message())\n", "    print()\n\t    print(\n\t        msg.get_propose_yesterday_wake_up_time_message(\n\t            datetime.datetime.now().time()\n\t        )\n\t    )\n\t    print()\n\t    print(msg.get_ask_wake_up_time_message())\n\t    print()\n\t    print(msg.get_ask_sleep_mode_message())\n", "    print()\n\t    print(msg.get_tip_message(QuaziTip()))\n\t    print()\n\t    print(\n\t        msg.get_sleep_calc_time_message(\n\t            datetime.datetime.now().time(), [QuaziAct()] * 4\n\t        )\n\t    )\n\t    print()\n\t    print(msg.get_good_night_message())\n"]}
{"filename": "skill/messages/ru_messages.py", "chunked_list": ["from __future__ import annotations\n\timport datetime\n\timport random\n\tfrom typing import TYPE_CHECKING, List\n\tfrom skill.messages.base_messages import BaseMessages\n\tfrom skill.sleep_calculator import SleepMode, SleepCalculation\n\tfrom skill.messages.unicode_literals import DASH, LAQUO, RAQUO\n\tfrom skill.utils import (\n\t    Daytime,\n\t    TextWithTTS,\n", "    construct_random_message,\n\t    gentle_capitalize,\n\t)\n\tif TYPE_CHECKING:\n\t    from skill.entities import Activity, Tip\n\tclass RUMessages(BaseMessages):\n\t    SLEEP_MODES_NOMINATIVE = {\n\t        SleepMode.VERY_SHORT: \"Лёгкий\",\n\t        SleepMode.SHORT: \"Короткий\",\n\t        SleepMode.MEDIUM: \"Средний\",\n", "        SleepMode.LONG: \"Длинный\",\n\t    }\n\t    SLEEP_MODES_INSTRUMENTAL = {\n\t        SleepMode.VERY_SHORT: \"Лёгким\",\n\t        SleepMode.SHORT: \"Коротким\",\n\t        SleepMode.MEDIUM: \"Средним\",\n\t        SleepMode.LONG: \"Длинным\",\n\t    }\n\t    MENU_BUTTONS_TEXT = [\n\t        \"Дай совет\",\n", "        \"Рассчитай сон\",\n\t        \"Расскажи о навыке\",\n\t        \"Помощь\",\n\t    ]\n\t    TIP_TOPIC_SELECTION_BUTTONS_TEXT = [\"Дневной сон\", \"Ночной сон\"]\n\t    SLEEP_TIME_PROPOSAL_BUTTONS_TEXT = [\"Да\", \"Нет\"]\n\t    POST_SLEEP_CALCULATION_BUTTONS_TEXT = [\"Да\", \"Нет\"]\n\t    SLEEP_MODE_SELECTION_BUTTONS_TEXT = list(SLEEP_MODES_NOMINATIVE.values())\n\t    HELP_BUTTONS_TEXT = [\n\t        \"Меню\",\n", "        \"Я хочу спать\",\n\t        \"Дай совет\",\n\t        \"Расскажи о навыке\",\n\t        \"Выход\",\n\t    ]\n\t    def __init__(self):\n\t        pass\n\t    def get_sleep_form_message(self) -> TextWithTTS:\n\t        return TextWithTTS(\n\t            f\"Скажите во сколько вы хотите встать по форме {LAQUO}В 12:12{RAQUO}\"\n", "        )\n\t    def get_start_message_intro(self, time: datetime.datetime) -> TextWithTTS:\n\t        daytime = Daytime.from_time(time)\n\t        greeting = TextWithTTS(\"Здравствуйте!\")\n\t        match daytime:\n\t            case Daytime.DAY:\n\t                greeting = TextWithTTS(\"Добрый день!\")\n\t            case Daytime.MORNING:\n\t                greeting = TextWithTTS(\"Доброе утро!\")\n\t            case Daytime.EVENING:\n", "                greeting = TextWithTTS(\"Добрый вечер!\")\n\t            case Daytime.NIGHT:\n\t                greeting = TextWithTTS(\"Доброй ночи!\")\n\t        intro = TextWithTTS(\n\t            f\"Я {DASH} Сонный Помощник. Я помогаю вам организовать\" \" ваш сон.\"\n\t        )\n\t        man = TextWithTTS(\n\t            \"Вы можете попросить меня рассчитать оптимальное для \"\n\t            \"вас время сна, за которое вы можете выспаться. \"\n\t            f\"Для этого скажите {LAQUO}Я хочу спать{RAQUO}. \"\n", "            \"А ещё вы можете попросить меня дать вам пару \"\n\t            \"советов по тому, как лучше высыпаться. Чтобы выйти из навка,\"\n\t            \" скажите «Выход». \"\n\t        )\n\t        replicas_tail = [\n\t            TextWithTTS(\"Чем я могу помочь?\"),\n\t            TextWithTTS(\"Чем могу помочь?\"),\n\t            TextWithTTS(\"Чем могу быть полезна?\"),\n\t            TextWithTTS(\"Я к вашим услугам.\"),\n\t        ]\n", "        message = TextWithTTS(\" \").join(\n\t            (greeting, intro, man, random.choice(replicas_tail))\n\t        )\n\t        return message\n\t    def get_start_message_comeback(\n\t        self, time: datetime.datetime, streak: int, scoreboard: int\n\t    ) -> TextWithTTS:\n\t        daytime = Daytime.from_time(time)\n\t        greeting = TextWithTTS(\"Здравствуйте! \")\n\t        match daytime:\n", "            case Daytime.DAY:\n\t                greeting = TextWithTTS(\"Добрый день! \")\n\t            case Daytime.MORNING:\n\t                greeting = TextWithTTS(\"Доброе утро! \")\n\t            case Daytime.EVENING:\n\t                greeting = TextWithTTS(\"Добрый вечер! \")\n\t            case Daytime.NIGHT:\n\t                greeting = TextWithTTS(\"Доброй ночи! \")\n\t        message = greeting\n\t        if streak > 1:\n", "            praise = TextWithTTS(\n\t                f\"Сегодня вы пользуетесь Сонным Помощником {streak}\" \" день подряд. \"\n\t            )\n\t            replicas_insert = [\n\t                TextWithTTS(\"Так держать!\"),\n\t                TextWithTTS(\"Замечательно!\"),\n\t                TextWithTTS(\"Здорово!\"),\n\t                TextWithTTS(\"Ура!\"),\n\t                TextWithTTS(\"Прекрасно!\"),\n\t                TextWithTTS(\"Продолжайте в том же духе!\"),\n", "            ]\n\t            praise += random.choice(replicas_insert)\n\t            praise += TextWithTTS(f\" Вы спите лучше, чем {scoreboard}% пользователей! \")\n\t            message += praise\n\t        man = TextWithTTS(\n\t            \"Вы можете попросить меня рассчитать оптимальное для \"\n\t            \"вас время сна, за которое вы можете выспаться. \"\n\t            f\"Для этого скажите {LAQUO}Я хочу спать{RAQUO}. \"\n\t            \"А ещё вы можете попросить меня дать вам пару \"\n\t            \"советов по тому, как лучше высыпаться. Чтобы выйти из навыка,\"\n", "            \" скажите «Выход». \"\n\t        )\n\t        message += man\n\t        replicas_tail = [\n\t            TextWithTTS(\"Чем я могу помочь?\"),\n\t            TextWithTTS(\"Чем могу помочь?\"),\n\t            TextWithTTS(\"Чем могу быть полезна?\"),\n\t            TextWithTTS(\"Я к вашим услугам.\"),\n\t        ]\n\t        message += random.choice(replicas_tail)\n", "        return message\n\t    def get_menu_welcome_message(self) -> TextWithTTS:\n\t        replicas_a = [\n\t            TextWithTTS(\"Вы находитесь в главном меню.\"),\n\t            TextWithTTS(\"Это главное меню Сонного Помощника.\"),\n\t            TextWithTTS(\"Вы в главном меню.\"),\n\t            TextWithTTS(\"Вы находитесь в главном меню Сонного Помощника.\"),\n\t        ]\n\t        replicas_b = [\n\t            TextWithTTS(\n", "                f\"Скажите {LAQUO}Помощь{RAQUO}, чтобы узнать о \" \"функциях навыка.\"\n\t            )\n\t        ]\n\t        replicas_c = [\n\t            TextWithTTS(\"Чем я могу помочь?\"),\n\t            TextWithTTS(\"Чем могу быть полезна?\"),\n\t            TextWithTTS(\"Я к вашим услугам.\"),\n\t            TextWithTTS(\"Что угодно, лишь бы вы спали хорошо.\"),\n\t            # NOTE:      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Informal\n\t        ]\n", "        message = construct_random_message(replicas_a, replicas_b, replicas_c)\n\t        return message\n\t    def get_info_message(self) -> TextWithTTS:\n\t        replicas_a = [\n\t            TextWithTTS(\n\t                f\"Я {DASH} Сонный Помощник.\"\n\t                \" Я могу помочь людям, испытывающим проблемы со сном.\"\n\t            ),\n\t            TextWithTTS(\n\t                f\"Я {DASH} Сонный Помощник. Я помогаю людям, которые хотят\"\n", "                \" организовать свой сон.\"\n\t            ),\n\t            TextWithTTS(\n\t                f\"Я {DASH} Сонный Помощник. Моя цель {DASH} помочь\"\n\t                \" обеспечить правильный здоровый сон тем, кому этого не\"\n\t                \" хватало.\"\n\t            ),\n\t            TextWithTTS(\n\t                f\"Я {DASH} Сонный Помощник. Моя цель {DASH} помочь\"\n\t                \" невыспавшимся людям обеспечить\"\n", "                \" себе хороший комфортный сон.\"\n\t            ),\n\t            TextWithTTS(\n\t                f\"Я {DASH} Сонный Помощник, я могу помочь лучше спать тем,\"\n\t                \" кто испытывает с этим проблемы.\"\n\t            ),\n\t            TextWithTTS(\n\t                f\"Я {DASH} Сонный Помощник, я могу помочь вам высыпаться,\"\n\t                \" если у вас есть проблемы со сном.\"\n\t            ),\n", "        ]\n\t        replicas_b = [\n\t            TextWithTTS(\n\t                \"Вы можете попросить меня рассчитать оптимальное для \"\n\t                \"вас время сна, за которое вы можете выспаться.\"\n\t            ),\n\t            TextWithTTS(\n\t                \"Я могу рассчитать для вас оптимальное \"\n\t                \"время сна, за которое вы можете выспаться.\"\n\t            ),\n", "            TextWithTTS(\n\t                \"С помощью меня, вы можете узнать, во сколько \"\n\t                \"вам стоит сегодня лечь, чтобы выспаться.\"\n\t            ),\n\t            TextWithTTS(\n\t                \"Я могу помочь вам подобрать подходящее для вас \"\n\t                \"время сна, чтобы вы смогли выспаться.\"\n\t            ),\n\t        ]\n\t        replicas_c = [\n", "            TextWithTTS(f\"Для этого скажите {LAQUO}Я хочу спать{RAQUO}.\"),\n\t            TextWithTTS(\n\t                \"Чтобы вызвать эту функцию, скажитe \" f\"{LAQUO}Я хочу спать{RAQUO}.\"\n\t            ),\n\t        ]\n\t        replicas_d = [\n\t            TextWithTTS(\n\t                \"А ещё вы можете попросить у меня совет по тому, \" \"как лучше спать.\"\n\t            ),\n\t            TextWithTTS(\n", "                \"Или вы можете попросить у меня совет по тому, \" \"как лучше спать.\"\n\t            ),\n\t            TextWithTTS(\"А ещё я могу поделиться советом по здоровому сну.\"),\n\t            TextWithTTS(\n\t                \"А ещё я могу дать вам небольшой совет по \"\n\t                \"интересующему вас виду сна.\"\n\t            ),\n\t            TextWithTTS(\n\t                \"Ещё я могу дать вам пару советов по улучшению \" \"качества вашего сна.\"\n\t            ),\n", "            TextWithTTS(\n\t                \"А ещё я могу дать вам пару советов по тому, \" \"как высыпаться.\"\n\t            ),\n\t        ]\n\t        message = construct_random_message(\n\t            replicas_a, replicas_b, replicas_c, replicas_d\n\t        )\n\t        return message\n\t    def get_ask_tip_topic_message(self) -> TextWithTTS:\n\t        replicas = [\n", "            TextWithTTS(\"Вас интересует совет по дневному или ночному сну? \"),\n\t            TextWithTTS(\n\t                \"По какому сну вы хотите получить совет, дневному, \" \"или ночному? \"\n\t            ),\n\t            TextWithTTS(\n\t                \"Я могу дать вам совет по дневному или ночному сну. \"\n\t                \"Какой сон вас интересует? \"\n\t            ),\n\t            TextWithTTS(\n\t                \"С каким сном вам нужна помощь? С дневным или ночным? \"\n", "            ),\n\t            TextWithTTS(\"Вам нужна помощь по дневному или ночному сну? \"),\n\t        ]\n\t        info = TextWithTTS(\n\t            \"Дневной сон — обычно, короткий перерыв от \"\n\t            \"рутины, способ снять накопившуюся усталость. Ночной сон —\"\n\t            \" продолжительный отдых организма после бодровствования, \"\n\t            \"подразумевающий соблюдение регулярного режима.\"\n\t        )\n\t        # NOTE: Tip topic options are currently hardcoded.\n", "        #       This may cause issues if new tip topics\n\t        #       are planned to be added in the future.\n\t        return random.choice(replicas) + info\n\t    def get_tip_message(self, tip: Tip) -> TextWithTTS:\n\t        return tip.tip_content.transform(gentle_capitalize)\n\t    def get_propose_yesterday_wake_up_time_message(\n\t        self, last_time: datetime.time\n\t    ) -> TextWithTTS:\n\t        return TextWithTTS(\n\t            text=\"Вы хотите завтра встать как в прошлый раз,\"\n", "            f\" в {last_time.isoformat(timespec='minutes')}?\"\n\t        )\n\t    def get_ask_wake_up_time_message(self) -> TextWithTTS:\n\t        return TextWithTTS(text=\"Во сколько вы хотите завтра проснуться?\")\n\t    def get_ask_sleep_mode_message(self) -> TextWithTTS:\n\t        message = TextWithTTS(\n\t            \"Выберите один из режимов сна:\\n\",\n\t            \"Выберите один из режимов сна.\\n\",\n\t        )\n\t        message += TextWithTTS(\n", "            f\"Режим {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.LONG]} \"\n\t            f\"сон {RAQUO} обеспечит вам продолжительный сон длиной от\"\n\t            \" 9 до 12 часов. Отличная опция после долгой бессонной недели.\\n\",\n\t            f\"Режим {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.LONG]} \"\n\t            f\"сон{RAQUO} обеспечит вам продолжительный сон длиной от\"\n\t            \" девяти до двенадцати часов. Отличная опция после долгой\"\n\t            \" бессонной недели!\\n\",\n\t        )\n\t        message += TextWithTTS(\n\t            f\"Режим {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.MEDIUM]} \"\n", "            f\"сон{RAQUO} предложит вам классический сон длиной от\"\n\t            \" 6 до 9 часов.\\n\",\n\t            f\"Режим {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.MEDIUM]} \"\n\t            f\"сон{RAQUO} предложит вам классический сон длиной от\"\n\t            \" шести до девяти часов.\\n\",\n\t        )\n\t        message += TextWithTTS(\n\t            \"Если у вас ещё много дел на вечер, или вы не хотите много спать,\"\n\t            \" вам подойдёт режим \"\n\t            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]} \"\n", "            f\"сон{RAQUO}. Вы проспите от 3 до 6 часов.\\n\",\n\t            \"Если у вас ещё много дел на вечер, или вы не хотите много спать,\"\n\t            \" вам подойдёт режим \"\n\t            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]} \"\n\t            f\"сон{RAQUO}. Вы проспите от трёх до шести часов.\\n\",\n\t        )\n\t        message += TextWithTTS(\n\t            \"Для небольшого дневного отдыха выберите режим \"\n\t            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.VERY_SHORT]} \"\n\t            f\"сон{RAQUO}. Он подберёт вам перерыв от 15 минут до 3 часов.\\n\",\n", "            \"Для небольшого дневного отдыха выберите режим \"\n\t            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.VERY_SHORT]} \"\n\t            f\"сон{RAQUO}. Он подберёт вам перерыв от пятнадцати минут до\"\n\t            \" трёх часов.\\n\",\n\t        )\n\t        return message\n\t    def get_sleep_calc_time_message(\n\t        self,\n\t        sleep_calc_result: SleepCalculation,\n\t        activities: List[Activity],\n", "    ) -> TextWithTTS:\n\t        if sleep_calc_result.changed_mode:\n\t            selected_mode = sleep_calc_result.selected_mode\n\t            changed_mode = sleep_calc_result.changed_mode\n\t            bed_time = sleep_calc_result.bed_time\n\t            message = TextWithTTS(\n\t                \"К сожалению, за этот промежуток времени вы не успеваете \"\n\t                \"поспать \"\n\t                f\"{self.SLEEP_MODES_INSTRUMENTAL[selected_mode].lower()} \"\n\t                \"сном. Вместо этого, предлагаю вам попробовать \"\n", "                f\"{self.SLEEP_MODES_NOMINATIVE[changed_mode].lower()} \"\n\t                \"сон и лечь в \"\n\t                f\"{bed_time.hour:02d}:{bed_time.minute:02d}. \"\n\t                f\"Вы проспите {sleep_calc_result.sleep_time.seconds // 60} \"\n\t                \"минут. \"\n\t            )\n\t        else:\n\t            bed_time = sleep_calc_result.bed_time\n\t            message = TextWithTTS(\n\t                \"Хорошо, рекомендую вам лечь в \"\n", "                f\"{bed_time.hour:02d}:{bed_time.minute:02d}. \"\n\t                f\"Вы проспите {sleep_calc_result.sleep_time.seconds // 60} \"\n\t                \"минут. \"\n\t            )\n\t        if activities:\n\t            message += TextWithTTS(\"За этот вечер вы можете успеть, например, \")\n\t            activities_text_with_tts = [act.description for act in activities]\n\t            if len(activities) > 1:\n\t                # Construct activity enumerating statement in proper Russian\n\t                # syntax: objects are seperated by a comma and a whitespace\n", "                # except for the last two, which have the word \"или\" inbetween.\n\t                activities_text_with_tts[-1] = TextWithTTS(\" или \").join(\n\t                    (\n\t                        activities_text_with_tts[-2],\n\t                        activities_text_with_tts[-1],\n\t                    )\n\t                )  # Glue the last two objects together with the word \"или\"\n\t                activities_text_with_tts.pop(-2)  # Get rid of the penultimate\n\t                #                                   object duplicate\n\t            message += TextWithTTS(\", \").join(activities_text_with_tts) + \". \"\n", "        replica_tail = [\n\t            TextWithTTS(\"Не желаете-ли получить совет по сну?\"),\n\t            TextWithTTS(\"Не хотите-ли получить совет по сну?\"),\n\t            TextWithTTS(\"Хотите получить совет по сну?\"),\n\t            TextWithTTS(\"Как насчёт совета по сну?\"),\n\t            TextWithTTS(\"Как насчёт небольшого совета по сну?\"),\n\t            TextWithTTS(\"Вас интересует совет по сну?\"),\n\t            TextWithTTS(\"Хотите совет по сну?\"),\n\t        ]\n\t        message += random.choice(replica_tail)\n", "        return message\n\t    def get_good_night_message(self) -> TextWithTTS:\n\t        replicas = [\n\t            TextWithTTS(text=\"Хорошего сна!\"),\n\t            TextWithTTS(text=\"Спокойной ночи!\"),\n\t            TextWithTTS(text=\"Доброй ночи!\"),\n\t            TextWithTTS(text=\"Сладких снов!\"),\n\t            TextWithTTS(text=\"Споки!\"),\n\t            # NOTE:           ^^^^^ Cringe\n\t            TextWithTTS(text=\"Хороших вам сноведений!\"),\n", "            TextWithTTS(text=\"Крепкого сна!\"),\n\t            TextWithTTS(text=\"Отбой!\"),\n\t            # NOTE:           ^^^^^ Informal\n\t        ]\n\t        return random.choice(replicas)\n\t    def get_wrong_topic_message(self, topic_name: str) -> TextWithTTS:\n\t        return TextWithTTS(\n\t            \"Пожалуйста, выберите один из вариантов тем для совета: \"\n\t            \" дневной сон или ночной сон, или вернитесь в главное меню, сказав\"\n\t            f\" {LAQUO}Меню{RAQUO}\"\n", "        )\n\t        # TODO: Rephrase replica and add variety\n\t    def get_generic_error_message(self) -> TextWithTTS:\n\t        return TextWithTTS(\"Что-то пошло не так, вы были возвращены в меню.\")\n\t    def get_wrong_time_message(self) -> TextWithTTS:\n\t        hour = random.randint(0, 23)\n\t        minute = random.randint(0, 59)\n\t        return TextWithTTS(\n\t            text=\"Пожалуйста, укажите время в формате ЧЧ:ММ, \"\n\t            f\"например, {hour}:{minute:02d}, \"\n", "            f\"или вернитесь  в главное меню, сказав {LAQUO}Меню{RAQUO}\",\n\t            tts=\"Пожалуйста, укажите время в формате час минута, \"\n\t            f\"например, {hour} часов {minute} минут, \"\n\t            f\"или вернитесь в главное меню, сказав {LAQUO}Меню{RAQUO}.\",\n\t        )\n\t    def get_help_message(self) -> TextWithTTS:\n\t        return TextWithTTS(\n\t            f\"Cкажите {LAQUO}Меню{RAQUO}, чтобы перейти в главное меню\\n\"\n\t            f\"Скажите {LAQUO}Я хочу спать{RAQUO}, чтобы рассчитать оптимальное\"\n\t            \" время сна\\n\"\n", "            f\"Скажите {LAQUO}Дай совет{RAQUO}, чтобы получить совет по сну\\n\"\n\t            f\"Скажите {LAQUO}Расскажи о навыке{RAQUO}, чтобы узнать побольше о\"\n\t            \" навыке\\nСкажите «Выход», чтобы выйти из навыка.\"\n\t        )\n\t    def get_what_can_you_do_message(self) -> TextWithTTS:\n\t        return TextWithTTS(\n\t            \"Я могу рассчитать оптимальное время для вашего отдыха и\"\n\t            \" предоставить вам советы по улучшению качества сна. Доверьтесь\"\n\t            \" моим знаниям и опыту, и вы обретете глубокий и полноценный\"\n\t            \" отдых, который позволит вам проснуться утром свежим и бодрым.\"\n", "        )\n\t    def get_quit_message(self) -> TextWithTTS:\n\t        replicas = [\n\t            TextWithTTS(text=\"Хорошего вам сна)\", tts=\"хар+ошего вам сна!\"),\n\t            TextWithTTS(text=\"Спокойной ночи!\"),\n\t            TextWithTTS(text=\"Доброй ночи!\"),\n\t            TextWithTTS(text=\"Сладких снов!\"),\n\t            TextWithTTS(text=\"Рад помочь!\"),\n\t            TextWithTTS(text=\"Хороших вам сноведений!\"),\n\t            TextWithTTS(text=\"Крепкого сна!\"),\n", "            TextWithTTS(text=\"Пока-пока!\"),\n\t            TextWithTTS(text=\"Пишите ещё!\"),\n\t            TextWithTTS(text=\"Да прибудет с вами сон!\"),\n\t            TextWithTTS(text=\"Досвидания!\"),\n\t            TextWithTTS(text=\"Удачи!\"),\n\t            TextWithTTS(text=\"Пишите почаще!\"),\n\t        ]\n\t        return random.choice(replicas)\n"]}
{"filename": "skill/dataconvert/ya_converter.py", "chunked_list": ["import datetime\n\timport pytz\n\tfrom skill.dataconvert.base_converter import BaseDataConverter\n\tfrom skill.exceptions import InvalidInputError\n\tclass YaDataConverter(BaseDataConverter):\n\t    \"\"\"Data converter for Yandex Alice API.\"\"\"\n\t    @staticmethod\n\t    def time(obj: dict, timezone: str | datetime.tzinfo) -> datetime.time:\n\t        \"\"\"Convert YANDEX.DATETIME JSON object to datetime.time with\n\t        given timezone\"\"\"\n", "        if obj[\"type\"] != \"YANDEX.DATETIME\":\n\t            raise InvalidInputError(\n\t                \"obj must be Alice API YANDEX.DATETIME object\"\n\t            )\n\t        tzinfo = (\n\t            timezone\n\t            if isinstance(timezone, datetime.tzinfo)\n\t            else pytz.timezone(timezone)\n\t        )\n\t        if \"hour\" not in obj[\"value\"] or \"minute\" not in obj[\"value\"]:\n", "            raise InvalidInputError(\n\t                \"obj should contain hour and minute information\"\n\t            )\n\t        time = datetime.time(\n\t            hour=obj[\"value\"][\"hour\"],\n\t            minute=obj[\"value\"][\"minute\"],\n\t            tzinfo=tzinfo,\n\t        )\n\t        return time\n\t    @staticmethod\n", "    def datetime(obj: dict, timezone: str) -> datetime.datetime:\n\t        \"\"\"Convert YANDEX.DATETIME JSON object to datetime.datetime with\n\t        given timezone\"\"\"\n\t        if obj[\"type\"] != \"YANDEX.DATETIME\":\n\t            raise InvalidInputError(\n\t                \"obj must be Alice API YANDEX.DATETIME object\"\n\t            )\n\t        if isinstance(timezone, str):\n\t            tzinfo = pytz.timezone(timezone)\n\t        elif isinstance(timezone, datetime.tzinfo):\n", "            tzinfo = timezone  # type: ignore\n\t        else:\n\t            raise InvalidInputError(\"Invalid timezone type\")\n\t        if not (\n\t            \"year\" in obj[\"value\"]\n\t            and \"month\" in obj[\"value\"]\n\t            and \"day\" in obj[\"value\"]\n\t            and \"hour\" in obj[\"value\"]\n\t            and \"minute\" in obj[\"value\"]\n\t        ):\n", "            raise InvalidInputError(\"Incomplete obj\")\n\t        result_datetime = datetime.datetime(\n\t            year=obj[\"value\"][\"year\"],\n\t            month=obj[\"value\"][\"month\"],\n\t            day=obj[\"value\"][\"day\"],\n\t            hour=obj[\"value\"][\"hour\"],\n\t            minute=obj[\"value\"][\"minute\"],\n\t            tzinfo=tzinfo,\n\t        )\n\t        return result_datetime\n"]}
{"filename": "skill/dataconvert/base_converter.py", "chunked_list": ["import abc\n\timport datetime\n\tclass BaseDataConverter(abc.ABC):\n\t    @staticmethod\n\t    @abc.abstractmethod\n\t    def time(obj: dict, timezone: str) -> datetime.time:\n\t        ...\n\t    @staticmethod\n\t    @abc.abstractmethod\n\t    def datetime(obj: dict, timezone: str) -> datetime.datetime:\n", "        ...\n"]}
{"filename": "content/__init__.py", "chunked_list": []}
