{"filename": "python/biobear/fastq_reader.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"FASTQ reader.\"\"\"\n\timport os\n\tfrom biobear.reader import Reader\n\tfrom biobear.compression import Compression\n\tfrom .biobear import _ExonReader\n\tclass FastqReader(Reader):\n\t    \"\"\"FASTQ file reader.\"\"\"\n", "    def __init__(\n\t        self, path: os.PathLike, compression: Compression = Compression.INFERRED\n\t    ):\n\t        \"\"\"Read a fastq file.\n\t        Args:\n\t            path (Path): Path to the fastq file.\n\t        Kwargs:\n\t            compression (Compression): Compression type of the file. Defaults to\n\t                Compression.INFERRED.\n\t        \"\"\"\n", "        self.compression = compression.infer_or_use(path)\n\t        if self.compression == Compression.GZIP:\n\t            self._fastq_reader = _ExonReader(str(path), \"FASTQ\", \"GZIP\")\n\t        else:\n\t            self._fastq_reader = _ExonReader(str(path), \"FASTQ\", None)\n\t    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._fastq_reader\n"]}
{"filename": "python/biobear/compression.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Compression configuration.\"\"\"\n\timport os\n\tfrom enum import Enum\n\tfrom pathlib import Path\n\tclass Compression(Enum):\n\t    \"\"\"Compression types for files.\"\"\"\n\t    INFERRED = \"INFERRED\"\n", "    NONE = \"NONE\"\n\t    GZIP = \"GZIP\"\n\t    @classmethod\n\t    def from_file(cls, path: os.PathLike) -> \"Compression\":\n\t        \"\"\"Infer the compression type from the file extension.\"\"\"\n\t        if Path(path).suffix == \".gz\":\n\t            return Compression.GZIP\n\t        return Compression.NONE\n\t    def infer_or_use(self, path: os.PathLike) -> \"Compression\":\n\t        \"\"\"Infer the compression type from the file extension if needed.\"\"\"\n", "        if self == Compression.INFERRED:\n\t            return Compression.from_file(path)\n\t        return self\n"]}
{"filename": "python/biobear/bcf_reader.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"BCF File Readers.\"\"\"\n\timport os\n\timport pyarrow as pa\n\tfrom biobear.reader import Reader\n\tfrom .biobear import _ExonReader, _BCFIndexedReader\n\tclass BCFReader(Reader):\n\t    \"\"\"A BCF File Reader.\n", "    This class is used to read a BCF file and convert it to a polars DataFrame.\n\t    \"\"\"\n\t    def __init__(self, path: os.PathLike):\n\t        \"\"\"Initialize the BCFReader.\n\t        Args:\n\t            path (Path): Path to the BCF file.\n\t        \"\"\"\n\t        self._bcf_reader = _ExonReader(str(path), \"BCF\", None)\n\t    @property\n\t    def inner(self):\n", "        \"\"\"Return the inner reader.\"\"\"\n\t        return self._bcf_reader\n\tclass BCFIndexedReader(Reader):\n\t    \"\"\"An Indexed BCF File Reader.\n\t    This class is used to read or query an indexed BCF file and convert it to a\n\t    polars DataFrame.\n\t    \"\"\"\n\t    def __init__(self, path: os.PathLike):\n\t        \"\"\"Initialize the BCFIndexedReader.\"\"\"\n\t        self._bcf_reader = _BCFIndexedReader(str(path))\n", "    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._bcf_reader\n\t    def query(self, region: str) -> pa.RecordBatchReader:\n\t        \"\"\"Query the BCF file and return an arrow batch reader.\n\t        Args:\n\t            region (str): The region to query.\n\t        \"\"\"\n\t        return self._bcf_reader.query(region)\n"]}
{"filename": "python/biobear/__init__.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Main biobear package.\"\"\"\n\tfrom biobear.fasta_reader import FastaReader\n\tfrom biobear.fastq_reader import FastqReader\n\tfrom biobear.vcf_reader import VCFReader, VCFIndexedReader\n\tfrom biobear.bam_reader import BamReader, BamIndexedReader\n\tfrom biobear.gtf_reader import GTFReader\n\tfrom biobear.gff_reader import GFFReader\n", "from biobear.mzml_reader import MzMLReader\n\tfrom biobear.genbank_reader import GenbankReader\n\tfrom biobear.bcf_reader import BCFReader, BCFIndexedReader\n\tfrom biobear import compression\n\t__version__ = \"0.7.4\"\n\t__all__ = [\n\t    \"FastaReader\",\n\t    \"FastqReader\",\n\t    \"VCFReader\",\n\t    \"VCFIndexedReader\",\n", "    \"BamReader\",\n\t    \"BamIndexedReader\",\n\t    \"BCFReader\",\n\t    \"BCFIndexedReader\",\n\t    \"GFFReader\",\n\t    \"GTFReader\",\n\t    \"GenbankReader\",\n\t    \"MzMLReader\",\n\t    \"compression\",\n\t    \"__version__\",\n", "]\n"]}
{"filename": "python/biobear/vcf_reader.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"VCF File Readers.\"\"\"\n\timport os\n\timport pyarrow as pa\n\tfrom biobear.reader import Reader\n\tfrom .biobear import _ExonReader, _VCFIndexedReader\n\tclass VCFReader(Reader):\n\t    \"\"\"A VCF File Reader.\n", "    This class is used to read a VCF file and convert it to a polars DataFrame.\n\t    \"\"\"\n\t    def __init__(self, path: os.PathLike):\n\t        \"\"\"Initialize the VCFReader.\n\t        Args:\n\t            path (Path): Path to the VCF file.\n\t        \"\"\"\n\t        self._vcf_reader = _ExonReader(str(path), \"VCF\", None)\n\t    @property\n\t    def inner(self):\n", "        \"\"\"Return the inner reader.\"\"\"\n\t        return self._vcf_reader\n\tclass VCFIndexedReader(Reader):\n\t    \"\"\"An Indexed VCF File Reader.\n\t    This class is used to read or query an indexed VCF file and convert it to a\n\t    polars DataFrame.\n\t    \"\"\"\n\t    def __init__(self, path: os.PathLike):\n\t        \"\"\"Initialize the VCFIndexedReader.\"\"\"\n\t        self._vcf_reader = _VCFIndexedReader(str(path))\n", "    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._vcf_reader\n\t    def query(self, region: str) -> pa.RecordBatchReader:\n\t        \"\"\"Query the VCF file and return a pyarrow RecordBatchReader.\n\t        Args:\n\t            region (str): The region to query.\n\t        \"\"\"\n\t        return self._vcf_reader.query(region)\n"]}
{"filename": "python/biobear/gtf_reader.py", "chunked_list": ["\"\"\"GTF File Reader.\"\"\"\n\timport os\n\timport pyarrow as pa\n\timport pyarrow.dataset as ds\n\tfrom biobear.compression import Compression\n\tfrom biobear.reader import Reader\n\tfrom .biobear import _ExonReader\n\tclass GTFReader(Reader):\n\t    \"\"\"A GTF File Reader.\"\"\"\n\t    def __init__(\n", "        self, path: os.PathLike, compression: Compression = Compression.INFERRED\n\t    ):\n\t        \"\"\"Initialize the GTFReader.\n\t        Args:\n\t            path: The path to the GTF file.\n\t        \"\"\"\n\t        self.compression = compression.infer_or_use(path)\n\t        if self.compression == Compression.GZIP:\n\t            self._gtf_reader = _ExonReader(str(path), \"GTF\", \"GZIP\")\n\t        else:\n", "            self._gtf_reader = _ExonReader(str(path), \"GTF\", None)\n\t    def to_polars(self):\n\t        \"\"\"Read the GTF file and return a polars DataFrame.\"\"\"\n\t        try:\n\t            import polars as pl\n\t        except ImportError as import_error:\n\t            raise ImportError(\n\t                \"The polars library is required to convert a GTF file to \"\n\t                \"a polars DataFrame.\"\n\t            ) from import_error\n", "        return pl.from_arrow(self.to_arrow().read_all())\n\t    def to_arrow(self) -> pa.RecordBatchReader:\n\t        \"\"\"Convert the GTF reader to an arrow batch reader.\"\"\"\n\t        return self._gtf_reader.to_pyarrow()\n\t    def to_arrow_scanner(self) -> ds.Scanner:\n\t        \"\"\"Convert the GTF reader to an arrow scanner.\"\"\"\n\t        return ds.Scanner.from_batches(self.to_arrow())\n\t    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n", "        return self._gtf_reader\n"]}
{"filename": "python/biobear/fasta_reader.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"FASTA file reader.\"\"\"\n\timport os\n\tfrom biobear.reader import Reader\n\tfrom biobear.compression import Compression\n\tfrom .biobear import _ExonReader\n\tclass FastaReader(Reader):\n\t    \"\"\"FASTA file reader.\"\"\"\n", "    def __init__(\n\t        self, path: os.PathLike, compression: Compression = Compression.INFERRED\n\t    ):\n\t        \"\"\"Read a fasta file.\n\t        Args:\n\t            path (Path): Path to the fasta file.\n\t        Kwargs:\n\t            compression (Compression): Compression type of the file. Defaults to\n\t                Compression.INFERRED.\n\t        \"\"\"\n", "        self.compression = compression.infer_or_use(path)\n\t        if self.compression == Compression.GZIP:\n\t            self._fasta_reader = _ExonReader(str(path), \"FASTA\", \"GZIP\")\n\t        else:\n\t            self._fasta_reader = _ExonReader(str(path), \"FASTA\", None)\n\t    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._fasta_reader\n"]}
{"filename": "python/biobear/genbank_reader.py", "chunked_list": ["\"\"\"Genbank file reader.\"\"\"\n\timport os\n\tfrom biobear.reader import Reader\n\tfrom biobear.compression import Compression\n\tfrom .biobear import _ExonReader\n\tclass GenbankReader(Reader):\n\t    \"\"\"Genbank file reader.\"\"\"\n\t    def __init__(\n\t        self, path: os.PathLike, compression: Compression = Compression.INFERRED\n\t    ):\n", "        \"\"\"Read a genbank file.\n\t        Args:\n\t            path (Path): Path to the fasta file.\n\t            compression (Compression): Compression type of the file.\n\t        \"\"\"\n\t        self.compression = compression.infer_or_use(path)\n\t        if self.compression == Compression.GZIP:\n\t            self._reader = _ExonReader(str(path), \"GENBANK\", \"GZIP\")\n\t        else:\n\t            self._reader = _ExonReader(str(path), \"GENBANK\", None)\n", "    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._reader\n"]}
{"filename": "python/biobear/bam_reader.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"BAM File Readers.\"\"\"\n\timport os\n\timport pyarrow as pa\n\tfrom biobear.reader import Reader\n\tfrom .biobear import _BamIndexedReader, _ExonReader\n\tclass BamReader(Reader):\n\t    \"\"\"A BAM File Reader.\"\"\"\n", "    def __init__(self, path: os.PathLike):\n\t        \"\"\"Initialize the BamReader.\n\t        Args:\n\t            path (Path): Path to the BAM file.\n\t        \"\"\"\n\t        self._bam_reader = _ExonReader(str(path), \"BAM\", None)\n\t    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._bam_reader\n", "class BamIndexedReader(Reader):\n\t    \"\"\"An Indexed BAM File Reader.\"\"\"\n\t    def __init__(self, path: os.PathLike):\n\t        \"\"\"Initialize the BamIndexedReader.\n\t        Args:\n\t            path (Path): Path to the BAM file.\n\t            index (Path): Path to the BAM index file.\n\t        \"\"\"\n\t        self._bam_reader = _BamIndexedReader(str(path))\n\t    @property\n", "    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._bam_reader\n\t    def query(self, region: str) -> pa.RecordBatchReader:\n\t        \"\"\"Query the BAM file and return an Arrow RecordBatchReader.\n\t        Args:\n\t            region: A region in the format \"chr:start-end\".\n\t        \"\"\"\n\t        return self._bam_reader.query(region)\n"]}
{"filename": "python/biobear/reader.py", "chunked_list": ["\"\"\"Abstract Reader class for reading data from a file or stream.\"\"\"\n\tfrom abc import ABC, abstractmethod\n\timport pyarrow as pa\n\timport pyarrow.dataset as ds\n\tclass Reader(ABC):\n\t    \"\"\"An abstract base class (ABC) representing a reader.\n\t    The class defines basic functionalities for conversion, but the specifics must be\n\t    implemented in a subclass.\n\t    \"\"\"\n\t    @property\n", "    @abstractmethod\n\t    def inner(self):\n\t        \"\"\"Abstract property for the inner reader.\n\t        Returns:\n\t            The inner reader. The type of the reader is defined by the specific\n\t            subclass.\n\t        \"\"\"\n\t    def to_pandas(self):\n\t        \"\"\"Convert the inner data to a Pandas DataFrame.\n\t        Returns:\n", "            pd.DataFrame: The converted data in a Pandas DataFrame.\n\t        Raises:\n\t            ImportError: If the 'pandas' package is not installed.\n\t        \"\"\"\n\t        try:\n\t            import pandas as pd  # noqa\n\t            return self.to_arrow_scanner().to_table().to_pandas()\n\t        except ImportError as import_error:\n\t            raise ImportError(\n\t                \"The 'pandas' package is required to use the to_pandas method.\"\n", "            ) from import_error\n\t    def to_polars(self):\n\t        \"\"\"Convert the inner data to a Polars DataFrame.\n\t        This method first converts the inner reader's data to an Arrow table,\n\t        then to a Python dictionary, and finally to a Polars DataFrame.\n\t        Returns:\n\t            pl.DataFrame: The converted data in a Polars DataFrame.\n\t        Raises:\n\t            ImportError: If the 'polars' package is not installed.\n\t        \"\"\"\n", "        try:\n\t            import polars as pl\n\t        except ImportError as import_error:\n\t            raise ImportError(\n\t                \"The 'polars' package is required to use the to_polars method.\"\n\t            ) from import_error\n\t        pydict = self.to_arrow_scanner().to_table().to_pydict()\n\t        return pl.from_dict(pydict)\n\t    def to_arrow_scanner(self) -> ds.Scanner:\n\t        \"\"\"Convert the inner data to an Arrow scanner.\n", "        This method first converts the inner reader's data to Arrow batches,\n\t        and then forms a scanner from these batches.\n\t        Returns:\n\t            ds.Scanner: The converted data in an Arrow scanner.\n\t        \"\"\"\n\t        return ds.Scanner.from_batches(self.to_arrow())\n\t    def to_arrow(self) -> pa.RecordBatchReader:\n\t        \"\"\"Convert the inner data to an Arrow record batch reader.\n\t        If the inner reader is exhausted, this method raises an exception.\n\t        Otherwise, it converts the inner reader's data to an Arrow record batch.\n", "        Returns:\n\t            pa.RecordBatchReader: The converted data in an Arrow record batch reader.\n\t        Raises:\n\t            StopIteration: If the inner reader is exhausted.\n\t        \"\"\"\n\t        if self.inner.is_exhausted():\n\t            raise StopIteration(\"The reader is exhausted.\")\n\t        return self.inner.to_pyarrow()\n"]}
{"filename": "python/biobear/gff_reader.py", "chunked_list": ["\"\"\"GFF File Reader.\"\"\"\n\timport os\n\timport pyarrow as pa\n\timport pyarrow.dataset as ds\n\tfrom biobear.compression import Compression\n\tfrom biobear.reader import Reader\n\tfrom .biobear import _ExonReader\n\tclass GFFReader(Reader):\n\t    \"\"\"A GFF File Reader.\"\"\"\n\t    def __init__(\n", "        self, path: os.PathLike, compression: Compression = Compression.INFERRED\n\t    ):\n\t        \"\"\"Initialize the GFFReader.\n\t        Args:\n\t            path: The path to the GFF file.\n\t        \"\"\"\n\t        self.compression = compression.infer_or_use(path)\n\t        if self.compression == Compression.GZIP:\n\t            self._gff_reader = _ExonReader(str(path), \"GFF\", \"GZIP\")\n\t        else:\n", "            self._gff_reader = _ExonReader(str(path), \"GFF\", None)\n\t    def to_polars(self):\n\t        \"\"\"Read the GFF file and return a polars DataFrame.\"\"\"\n\t        try:\n\t            import polars as pl\n\t        except ImportError as import_error:\n\t            raise ImportError(\n\t                \"The polars library is required to convert a GFF file \"\n\t                \"to a polars DataFrame.\"\n\t            ) from import_error\n", "        return pl.from_arrow(self.to_arrow().read_all())\n\t    def to_arrow(self) -> pa.RecordBatchReader:\n\t        \"\"\"Convert the GFF reader to an arrow batch reader.\"\"\"\n\t        return self._gff_reader.to_pyarrow()\n\t    def to_arrow_scanner(self) -> ds.Scanner:\n\t        \"\"\"Convert the GFF reader to an arrow scanner.\"\"\"\n\t        return ds.Scanner.from_batches(self.to_arrow())\n\t    @property\n\t    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n", "        return self._gff_reader\n"]}
{"filename": "python/biobear/mzml_reader.py", "chunked_list": ["\"\"\"MzML File Reader.\"\"\"\n\timport os\n\tfrom biobear.compression import Compression\n\tfrom biobear.reader import Reader\n\tfrom .biobear import _ExonReader\n\tclass MzMLReader(Reader):\n\t    \"\"\"A MzML File Reader.\"\"\"\n\t    def __init__(\n\t        self, path: os.PathLike, compression: Compression = Compression.INFERRED\n\t    ):\n", "        \"\"\"Initialize the MzMLReader.\n\t        Args:\n\t            path: The path to the MzML file.\n\t        \"\"\"\n\t        self.compression = compression.infer_or_use(path)\n\t        if self.compression == Compression.GZIP:\n\t            self._reader = _ExonReader(str(path), \"MZML\", \"GZIP\")\n\t        else:\n\t            self._reader = _ExonReader(str(path), \"MZML\", None)\n\t    @property\n", "    def inner(self):\n\t        \"\"\"Return the inner reader.\"\"\"\n\t        return self._reader\n"]}
{"filename": "python/tests/test_vcf_reader.py", "chunked_list": ["# Test the fasta reader can be converted to a polars dataframe\n\tfrom pathlib import Path\n\timport importlib\n\timport pytest\n\tfrom biobear import VCFReader, VCFIndexedReader\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_vcf_reader():\n", "    reader = VCFReader(DATA / \"vcf_file.vcf\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 15\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_vcf_reader_to_pandas():\n\t    reader = VCFReader(DATA / \"vcf_file.vcf\")\n\t    df = reader.to_pandas()\n\t    assert len(df) == 15\n", "def test_vcf_reader_missing_file():\n\t    with pytest.raises(OSError):\n\t        VCFReader(\"test.vcf\")\n\tdef test_vcf_indexed_reader_query():\n\t    reader = VCFIndexedReader(DATA / \"vcf_file.vcf.gz\")\n\t    rbr = reader.query(\"1\")\n\t    assert 11 == sum(b.num_rows for b in rbr)\n\tdef test_vcf_indexed_reader_query_no_results():\n\t    reader = VCFIndexedReader(DATA / \"vcf_file.vcf.gz\")\n\t    rbr = reader.query(\"chr1\")\n", "    with pytest.raises(Exception):\n\t        assert 0 == sum(b.num_rows for b in rbr)\n\tdef test_vcf_indexed_reader_query_missing_file():\n\t    with pytest.raises(ValueError):\n\t        VCFIndexedReader(\"test.vcf.gz\")\n"]}
{"filename": "python/tests/test_fasta_reader.py", "chunked_list": ["# Test the fasta reader can be converted to a polars dataframe\n\tfrom pathlib import Path\n\timport importlib\n\timport pytest\n\tfrom biobear import FastaReader\n\tfrom biobear.compression import Compression\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n", "def test_fasta_reader():\n\t    fasta_reader = FastaReader(DATA / \"test.fasta\")\n\t    df = fasta_reader.to_polars()\n\t    assert len(df) == 2\n\t# Add test for to_pandas() method\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_fasta_reader_to_pandas():\n\t    fasta_reader = FastaReader(DATA / \"test.fasta\")\n", "    df = fasta_reader.to_pandas()\n\t    assert len(df) == 2\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_fasta_gzipped_reader():\n\t    # Test that the gzip compression is inferred\n\t    fasta_reader = FastaReader((DATA / \"test.fasta.gz\").as_posix())\n\t    df = fasta_reader.to_polars()\n\t    assert len(df) == 2\n", "    # Test that the gzip compression is explicitly set\n\t    fasta_reader = FastaReader(DATA / \"test.fasta.gz\", Compression.GZIP)\n\t    df = fasta_reader.to_polars()\n\t    assert len(df) == 2\n\tdef test_fasta_reader_to_scanner():\n\t    fasta_reader = FastaReader(DATA / \"test.fasta\")\n\t    scanner = fasta_reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 2\n\tdef test_fasta_reader_to_arrow():\n\t    fasta_reader = FastaReader(DATA / \"test.fasta\")\n", "    arrow_reader = fasta_reader.to_arrow()\n\t    assert arrow_reader.read_all().num_rows == 2\n\tdef test_fasta_reader_no_file():\n\t    with pytest.raises(OSError):\n\t        FastaReader(\"test.fasta\")\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_multiple_calls_raise_an_exhausted_error():\n\t    fasta_reader = FastaReader(DATA / \"test.fasta\")\n", "    fasta_reader.to_polars()\n\t    with pytest.raises(StopIteration):\n\t        fasta_reader.to_polars()\n"]}
{"filename": "python/tests/test_genbank_reader.py", "chunked_list": ["\"\"\"Test the genbank reader can be converted to a polars dataframe\"\"\"\n\tfrom pathlib import Path\n\timport importlib\n\timport pytest\n\tfrom biobear import GenbankReader\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_genbank_reader():\n", "    reader = GenbankReader(DATA / \"BGC0000404.gbk\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 1\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_genbank_reader_to_pandas():\n\t    reader = GenbankReader(DATA / \"BGC0000404.gbk\")\n\t    df = reader.to_pandas()\n\t    assert len(df) == 1\n", "def test_genbank_missing_file():\n\t    with pytest.raises(OSError):\n\t        GenbankReader(DATA / \"missing.gbk\")\n"]}
{"filename": "python/tests/test_gff_reader.py", "chunked_list": ["# Test the fasta reader can be converted to a polars dataframe\n\timport importlib\n\tfrom pathlib import Path\n\timport pytest\n\tfrom biobear import GFFReader\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_gff_reader_polars():\n", "    reader = GFFReader(DATA / \"test.gff\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 2\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_gff_reader_pandas():\n\t    reader = GFFReader(DATA / \"test.gff\")\n\t    df = reader.to_pandas()\n\t    assert len(df) == 2\n", "@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_gff_attr_struct():\n\t    import polars as pl\n\t    reader = GFFReader(DATA / \"test.gff\")\n\t    df = reader.to_polars()\n\t    dtype = df.select(pl.col(\"attributes\")).dtypes[0]\n\t    key_field = pl.Field(\"key\", pl.Utf8)\n\t    value_field = pl.Field(\"value\", pl.List(pl.Utf8))\n", "    assert dtype == pl.List(pl.Struct([key_field, value_field]))\n\tdef test_gff_reader_to_scanner():\n\t    reader = GFFReader(DATA / \"test.gff\")\n\t    scanner = reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 2\n\tdef test_gff_reader_no_file():\n\t    with pytest.raises(OSError):\n\t        GFFReader(\"\")\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n", ")\n\tdef test_gff_reader_gz():\n\t    reader = GFFReader(DATA / \"test.gff.gz\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 2\n\tdef test_gff_reader_gz_to_scanner():\n\t    reader = GFFReader(DATA / \"test.gff.gz\")\n\t    scanner = reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 2\n\tdef test_gff_gz_no_file():\n", "    with pytest.raises(OSError):\n\t        GFFReader(\"test.gff.gz\")\n"]}
{"filename": "python/tests/test_gtf_reader.py", "chunked_list": ["# Test the fasta reader can be converted to a polars dataframe\n\tfrom pathlib import Path\n\timport pytest\n\tfrom biobear import GTFReader\n\timport importlib\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_gtf_reader_to_polars():\n", "    reader = GTFReader(DATA / \"test.gtf\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 77\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_gtf_reader_to_pandas():\n\t    reader = GTFReader(DATA / \"test.gtf\")\n\t    df = reader.to_pandas()\n\t    assert len(df) == 77\n", "@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_gtf_attr_struct():\n\t    import polars as pl\n\t    reader = GTFReader(DATA / \"test.gtf\")\n\t    df = reader.to_polars()\n\t    dtype = df.select(pl.col(\"attributes\")).dtypes[0]\n\t    key_field = pl.Field(\"key\", pl.Utf8)\n\t    value_field = pl.Field(\"value\", pl.Utf8)\n", "    assert dtype == pl.List(pl.Struct([key_field, value_field]))\n\tdef test_gtf_reader_to_scanner():\n\t    reader = GTFReader(DATA / \"test.gtf\")\n\t    scanner = reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 77\n\tdef test_gtf_reader_no_file():\n\t    with pytest.raises(OSError):\n\t        GTFReader(\"test.gtf\")\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n", ")\n\tdef test_gtf_reader_gz():\n\t    reader = GTFReader(DATA / \"test.gtf.gz\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 77\n\tdef test_gtf_reader_gz_to_scanner():\n\t    reader = GTFReader(DATA / \"test.gtf.gz\")\n\t    scanner = reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 77\n\tdef test_gtf_gz_no_file():\n", "    with pytest.raises(OSError):\n\t        GTFReader(\"test.gtf.gz\")\n"]}
{"filename": "python/tests/test_bam_reader.py", "chunked_list": ["# Test the fasta reader can be converted to a polars dataframe\n\tfrom pathlib import Path\n\timport importlib\n\timport pytest\n\tfrom biobear import BamReader, BamIndexedReader\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_bam_reader():\n", "    reader = BamReader(DATA / \"bedcov.bam\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 61\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_bam_reader_to_pandas():\n\t    reader = BamReader(DATA / \"bedcov.bam\")\n\t    df = reader.to_pandas()\n\t    assert len(df) == 61\n", "def test_bam_reader_no_file():\n\t    with pytest.raises(OSError):\n\t        BamReader(\"test.bam\")\n\tdef test_bam_indexed_reader():\n\t    reader = BamIndexedReader(DATA / \"bedcov.bam\")\n\t    rbr = reader.query(\"chr1:12203700-12205426\")\n\t    assert 1 == sum(b.num_rows for b in rbr)\n\tdef test_bam_indexed_reader_no_file():\n\t    with pytest.raises(OSError):\n\t        BamIndexedReader(\"test.bam\")\n"]}
{"filename": "python/tests/test_mzml_reader.py", "chunked_list": ["# Test the fasta reader can be converted to a polars dataframe\n\timport importlib\n\tfrom pathlib import Path\n\timport pytest\n\tfrom biobear import MzMLReader\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_mzml_reader_polars():\n", "    reader = MzMLReader(DATA / \"test.mzML\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 2\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_mzml_reader_pandas():\n\t    reader = MzMLReader(DATA / \"test.mzML\")\n\t    df = reader.to_pandas()\n\t    assert len(df) == 2\n", "def test_mzml_reader_to_scanner():\n\t    reader = MzMLReader(DATA / \"test.mzML\")\n\t    scanner = reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 2\n\tdef test_mzml_reader_no_file():\n\t    with pytest.raises(OSError):\n\t        MzMLReader(\"test.mzML\")\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n", "def test_mzml_reader_gz():\n\t    reader = MzMLReader(DATA / \"test.mzML.gz\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 2\n\tdef test_mzml_reader_gz_to_scanner():\n\t    reader = MzMLReader(DATA / \"test.mzML.gz\")\n\t    scanner = reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 2\n\tdef test_mzml_gz_no_file():\n\t    with pytest.raises(OSError):\n", "        MzMLReader(\"test.mzML.gz\")\n"]}
{"filename": "python/tests/test_fastq_reader.py", "chunked_list": ["# Test the fasta reader can be converted to a polars dataframe\n\tfrom pathlib import Path\n\timport importlib\n\timport pytest\n\tfrom biobear import FastqReader\n\tfrom biobear.compression import Compression\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n", "def test_fastq_reader():\n\t    fastq_reader = FastqReader(DATA / \"test.fastq\")\n\t    df = fastq_reader.to_polars()\n\t    assert len(df) == 2\n\t# Add test for to_pandas() method\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n\t)\n\tdef test_fastq_reader_to_pandas():\n\t    fastq_reader = FastqReader(DATA / \"test.fastq\")\n", "    df = fastq_reader.to_pandas()\n\t    assert len(df) == 2\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_fastq_gzipped_reader():\n\t    # Test that the gzip compression is inferred\n\t    fastq_reader = FastqReader(DATA / \"test.fastq.gz\")\n\t    df = fastq_reader.to_polars()\n\t    assert len(df) == 2\n", "    # Test that the gzip compression is explicitly set\n\t    fastq_reader = FastqReader(DATA / \"test.fastq.gz\", Compression.GZIP)\n\t    df = fastq_reader.to_polars()\n\t    assert len(df) == 2\n\tdef test_to_arrow_scanner():\n\t    fastq_reader = FastqReader(DATA / \"test.fastq\")\n\t    scanner = fastq_reader.to_arrow_scanner()\n\t    assert scanner.count_rows() == 2\n\t    gzipped_fastq_reader = FastqReader(DATA / \"test.fastq.gz\")\n\t    scanner = gzipped_fastq_reader.to_arrow_scanner()\n", "    assert scanner.count_rows() == 2\n\tdef test_fastq_reader_no_file():\n\t    with pytest.raises(OSError):\n\t        FastqReader(\"test.fastq\")\n"]}
{"filename": "python/tests/test_bcf_reader.py", "chunked_list": ["# Copyright 2023 WHERE TRUE Technologies.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Tests for the BCFReader and BCFIndexedReader classes.\"\"\"\n\tfrom pathlib import Path\n\timport importlib\n\timport pytest\n\tfrom biobear import BCFReader, BCFIndexedReader\n\tDATA = Path(__file__).parent / \"data\"\n\t@pytest.mark.skipif(\n", "    not importlib.util.find_spec(\"polars\"), reason=\"polars not installed\"\n\t)\n\tdef test_bcf_reader():\n\t    \"\"\"Test the BCFReader.\"\"\"\n\t    reader = BCFReader(DATA / \"index.bcf\")\n\t    df = reader.to_polars()\n\t    assert len(df) == 621\n\t# Add test for to_pandas() method\n\t@pytest.mark.skipif(\n\t    not importlib.util.find_spec(\"pandas\"), reason=\"pandas not installed\"\n", ")\n\tdef test_bcf_reader_to_pandas():\n\t    \"\"\"Test the BCFReader.\"\"\"\n\t    reader = BCFReader(DATA / \"index.bcf\")\n\t    df = reader.to_pandas()\n\t    assert len(df) == 621\n\tdef test_bcf_reader_missing_file():\n\t    \"\"\"Test the BCFReader with a missing file.\"\"\"\n\t    with pytest.raises(OSError):\n\t        BCFReader(\"test.bcf\")\n", "def test_bcf_indexed_reader_query():\n\t    \"\"\"Test the BCFIndexedReader.query() method.\"\"\"\n\t    reader = BCFIndexedReader(DATA / \"index.bcf\")\n\t    rbr = reader.query(\"1\")\n\t    assert 191 == sum(b.num_rows for b in rbr)\n\tdef test_bcf_indexed_reader_query_no_results():\n\t    reader = BCFIndexedReader(DATA / \"index.bcf\")\n\t    rbr = reader.query(\"1:100000000-100000001\")\n\t    with pytest.raises(Exception):\n\t        next(rbr)\n"]}
{"filename": "benchmarks/biopython-scan.py", "chunked_list": ["# Use biopython to count the number of records all the files in the data directory\n\tfrom Bio.SeqIO import parse\n\tfrom pathlib import Path\n\t# DATA = (Path.home() / \"data\" / \"uniref10.fasta.split\").glob(\"*.fasta\")\n\tDATA = [Path.home() / \"data\" / \"uniref10.fasta.split\" / \"uniref10.part_001.fasta\"]\n\ttotal_records = 0\n\tfor file in DATA:\n\t    with open(file, \"r\") as handle:\n\t        for record in parse(handle, \"fasta\"):\n\t            total_records += 1\n", "print(total_records)\n"]}
{"filename": "benchmarks/biobear-scan.py", "chunked_list": ["# Use biobear to count the number of records all the files in the data directory\n\tfrom pathlib import Path\n\tfrom biobear import FastaReader\n\t# DATA = Path.home() / \"data\" / \"uniref10.fasta.split\"\n\tDATA = Path.home() / \"data\" / \"uniref10.fasta.split\" / \"uniref10.part_001.fasta\"\n\ttotal_records = 0\n\tfor batch in FastaReader(DATA).to_arrow():\n\t    total_records += len(batch)\n\tprint(total_records)\n"]}
{"filename": ".github/workflows/smoketest.py", "chunked_list": ["\"\"\"Smoke test for biobear.\"\"\"\n\timport biobear\n\tdf = biobear.FastaReader(\"python/tests/data/test.fasta\").to_polars()\n\tassert df.shape == (2, 3)\n"]}
