{"filename": "run.py", "chunked_list": ["import os\n\timport logging\n\timport pandas as pd\n\tfrom argparse import ArgumentParser\n\tfrom trader import __version__ as ver\n\tfrom trader.config import TODAY_STR, holidays\n\tfrom trader.tasker import Tasks\n\tdef parse_args():\n\t    \"\"\"\n\t    執行指令:$ python run.py -TASK auto_trader -ACCT account_name\n", "    參數說明:\n\t    1. task(執行的目標程式): auto_trader, account_info, update_and_select_stock\n\t    2. account(代號): 若 task == 'auto_trader', 需指定要執行的帳戶代號\n\t    \"\"\"\n\t    parser = ArgumentParser()\n\t    parser.add_argument(\n\t        '--task', '-TASK', type=str, default='auto_trader', help='執行的目標程式')\n\t    parser.add_argument(\n\t        '--account', '-ACCT', type=str, default='chrisli_1', help='代號')\n\t    args = parser.parse_args()\n", "    return (args)\n\targs = parse_args()\n\ttask = args.task\n\taccount = args.account\n\tfilename = account if task == 'auto_trader' else task\n\tfor handler in logging.root.handlers[:]:\n\t    logging.root.removeHandler(handler)\n\tlogging.basicConfig(\n\t    level=logging.DEBUG,\n\t    format='%(asctime)s.%(msecs)03d|%(levelname)s: %(message)s',\n", "    datefmt='%Y-%m-%d %a %H:%M:%S',\n\t    handlers=[\n\t            logging.FileHandler(f'./logs/{filename}.log', 'a', encoding='utf-8'),\n\t            logging.StreamHandler()\n\t    ]\n\t)\n\tlogging.info('—'*100)\n\tlogging.info(f'Current trader version is {ver}')\n\tif __name__ == \"__main__\":\n\t    date = pd.to_datetime(TODAY_STR)\n", "    if task != 'create_env' and date in holidays:\n\t        logging.warning(f'{holidays[date]}不開盤')\n\t    elif task in Tasks:\n\t        functions = Tasks[task]\n\t        for func in functions:\n\t            if func.__name__ in ['runAutoTrader', 'runCrawlStockData']:\n\t                func(account)\n\t            else:\n\t                func()\n\t    else:\n", "        logging.warning(f\"The input task 【{task}】 does not exist.\")\n\t    logging.debug('End of tasker')\n\t    os._exit(0)\n"]}
{"filename": "trader/APItest.py", "chunked_list": ["import time\n\timport shioaji as sj\n\tfrom dotenv import dotenv_values\n\tfrom .config import TODAY\n\tfrom .utils.time import TimeTool\n\tclass APITester(TimeTool):\n\t    '''API串接測試，正式下單前，必須先經過測試，才可開通下單功能'''\n\t    def simulation_test(self, API_KEY, SECRET_KEY, acct):\n\t        api = sj.Shioaji(simulation=True)\n\t        api.login(API_KEY, SECRET_KEY)\n", "        is_simulate = api.simulation\n\t        if is_simulate:\n\t            print(f\"Log in to {acct} with simulation mode: {is_simulate}\")\n\t            time.sleep(30)\n\t        else:\n\t            print(f\"Log in to {acct} with real mode, log out\")\n\t            api.logout()\n\t            return\n\t        # 股票下單測試\n\t        stockid = '2603'\n", "        contract = api.Contracts.Stocks[stockid]\n\t        order = api.Order(\n\t            action=sj.constant.Action.Buy,\n\t            price=18,\n\t            quantity=1,\n\t            price_type=sj.constant.StockPriceType.LMT,\n\t            order_type=sj.constant.OrderType.ROD,\n\t            order_lot=sj.constant.StockOrderLot.Common,\n\t            account=api.stock_account\n\t        )\n", "        print(f'Stock order content:\\n{order}')\n\t        print('Place stock order')\n\t        trade = api.place_order(contract, order, timeout=0)\n\t        print(f'Done:\\n{trade}')\n\t        time.sleep(2)\n\t        # 期貨下單測試\n\t        futuresid = f'MXF{self.GetDueMonth(TODAY)}'\n\t        contract = api.Contracts.Futures.MXF[futuresid]\n\t        order = api.Order(\n\t            action=sj.constant.Action.Buy,\n", "            price=15000,\n\t            quantity=1,\n\t            price_type=sj.constant.FuturesPriceType.LMT,\n\t            order_type=sj.constant.OrderType.ROD,\n\t            octype=sj.constant.FuturesOCType.Auto,\n\t            account=api.futopt_account,\n\t        )\n\t        print(f'Futures order content:\\n{order}')\n\t        print('Place futures order')\n\t        trade = api.place_order(contract, order, timeout=0)\n", "        print(f'Done:\\n{trade}')\n\t        print(f'Log out {acct}: {api.logout()}\\n')\n\t    def verify_test(self, API_KEY, SECRET_KEY, acct):\n\t        api = sj.Shioaji(simulation=False)\n\t        api.login(API_KEY, SECRET_KEY)\n\t        print(f\"Log in to {acct} with real mode\")\n\t        time.sleep(10)\n\t        accounts = api.list_accounts()\n\t        for acct in accounts:\n\t            print(f'Account {acct.account_id}: {acct.signed}')\n", "        print(f'Log out {acct}: {api.logout()}\\n')\n\t    def run(self, account):\n\t        '''Shioaji 帳號測試'''\n\t        for i in range(2):\n\t            config = dotenv_values(f'./lib/envs/{account}.env')\n\t            API_KEY = config['API_KEY']\n\t            SECRET_KEY = config['SECRET_KEY']\n\t            if i == 0:\n\t                self.simulation_test(API_KEY, SECRET_KEY, account)\n\t                self.CountDown(720)\n", "            else:\n\t                self.verify_test(API_KEY, SECRET_KEY, account)\n\tif __name__ == \"__main__\":\n\t    tester = APITester()\n\t    account = 'test_account_1'\n\t    tester.run(account)\n"]}
{"filename": "trader/tasker.py", "chunked_list": ["import time\n\timport logging\n\timport pandas as pd\n\tfrom datetime import datetime\n\tfrom dotenv import dotenv_values\n\tfrom concurrent.futures import as_completed\n\tfrom . import executor, notifier, picker, crawler1, crawler2, tdp, file_handler\n\tfrom .config import API, PATH, TODAY_STR, ACCOUNTS, TEnd, ConvertScales\n\tfrom .create_env import app\n\tfrom .utils.database import redis_tick\n", "from .utils.subscribe import Subscriber\n\tfrom .utils.accounts import AccountInfo\n\tfrom .executor import StrategyExecutor\n\tfrom .performance.reports import PerformanceReport\n\ttry:\n\t    from .scripts.TaskList import customTasks\n\texcept:\n\t    customTasks = {}\n\tdef runCreateENV():\n\t    file_handler.create_folder('./lib')\n", "    file_handler.create_folder('./lib/envs')\n\t    file_handler.create_folder('./lib/schedules')\n\t    app.run()\n\tdef runPerformanceReport(start=None, end=None):\n\t    try:\n\t        logging.debug(f'ACCOUNTS: {ACCOUNTS}')\n\t        for env in ACCOUNTS:\n\t            logging.debug(f'Load 【{env}】 config')\n\t            config = dotenv_values(f'./lib/envs/{env}.env')\n\t            pr = PerformanceReport(env)\n", "            Tables = pr.getTables(config, start=start, end=end)\n\t            if Tables is not None:\n\t                pr.save_tables(Tables)\n\t                pr.plot_performance_report(Tables, save=True)\n\t                notifier.post(\n\t                    pr.TablesFile.split('/')[-1][:-5],\n\t                    image_name=pr.TablesFile.replace('xlsx', 'jpg'),\n\t                    msgType='AccountInfo'\n\t                )\n\t    except:\n", "        logging.exception('Catch an exception:')\n\t        notifier.post('\\n【Error】【帳務資訊查詢】發生異常', msgType='Tasker')\n\t        API.logout()\n\tdef runAccountInfo():\n\t    account = AccountInfo()\n\t    df = account.create_info_table()\n\t    tables = {}\n\t    try:\n\t        logging.debug(f'ACCOUNTS: {ACCOUNTS}')\n\t        for env in ACCOUNTS:\n", "            logging.debug(f'Load 【{env}】 config')\n\t            config = dotenv_values(f'./lib/envs/{env}.env')\n\t            API_KEY = config['API_KEY']\n\t            SECRET_KEY = config['SECRET_KEY']\n\t            acct = config['ACCOUNT_NAME']\n\t            account._login(API_KEY, SECRET_KEY, acct)\n\t            time.sleep(1)\n\t            row = account.query_all()\n\t            if row:\n\t                for i, data in enumerate(row):\n", "                    if i < 3:\n\t                        logging.info(f\"{data}： {row[data]}\")\n\t                    else:\n\t                        logging.info(f\"{data}： NT$ {'{:,}'.format(row[data])}\")\n\t                if hasattr(df, 'sheet_names') and acct in df.sheet_names:\n\t                    tb = account.update_info(df, row)\n\t                else:\n\t                    tb = pd.DataFrame([row])\n\t                tables[acct] = tb\n\t                # 推播訊息\n", "                account_id = API.stock_account.account_id\n\t                notifier.post_account_info(account_id, row)\n\t            elif hasattr(df, 'sheet_names') and account.account_name in df.sheet_names:\n\t                tables[acct] = pd.read_excel(df, sheet_name=env)\n\t            else:\n\t                tables[acct] = account.DEFAULT_TABLE\n\t            # 登出\n\t            time.sleep(5)\n\t            logging.info(f'登出系統: {API.logout()}')\n\t            time.sleep(10)\n", "        logging.info('儲存資訊')\n\t        writer = pd.ExcelWriter(\n\t            f'{PATH}/daily_info/{account.filename}', engine='xlsxwriter')\n\t        for sheet in tables:\n\t            try:\n\t                tables[sheet].to_excel(\n\t                    writer, encoding='utf-8-sig', index=False, sheet_name=sheet)\n\t            except:\n\t                logging.exception('Catch an exception:')\n\t                tables[sheet].to_excel(\n", "                    sheet+'.csv', encoding='utf-8-sig', index=False)\n\t        writer.save()\n\t    except:\n\t        logging.exception('Catch an exception:')\n\t        notifier.post('\\n【Error】【帳務資訊查詢】發生異常', msgType='Tasker')\n\t        API.logout()\n\tdef runAutoTrader(account):\n\t    try:\n\t        config = dotenv_values(f'./lib/envs/{account}.env')\n\t        se = StrategyExecutor(config=config)\n", "        se.login_and_activate()\n\t        se.run()\n\t    except KeyboardInterrupt:\n\t        notifier.post(\n\t            f\"\\n【Interrupt】【下單機監控】{se.ACCOUNT_NAME}已手動關閉\", msgType='Tasker')\n\t    except:\n\t        logging.exception('Catch an exception:')\n\t        notifier.post(\n\t            f\"\\n【Error】【下單機監控】{se.ACCOUNT_NAME}發生異常\", msgType='Tasker')\n\t    finally:\n", "        try:\n\t            se.output_files()\n\t        except:\n\t            logging.exception('Catch an exception (output_files):')\n\t            notifier.post(\n\t                f\"\\n【Error】【下單機監控】{se.ACCOUNT_NAME}資料儲存失敗\", msgType='Tasker')\n\t        logging.info(f'登出系統: {API.logout()}')\n\t        notifier.post(f\"\\n【停止監控】{se.ACCOUNT_NAME}關閉程式並登出\", msgType='Tasker')\n\t    del se\n\tdef runCrawlStockData(account):\n", "    target = pd.to_datetime('15:05:00')\n\t    config = dotenv_values(f'./lib/envs/{account}.env')\n\t    aInfo = AccountInfo()\n\t    try:\n\t        now = datetime.now()\n\t        if now < target:\n\t            logging.info(\n\t                f'Current time is still early, will start to crawl after {target}')\n\t            aInfo.CountDown(target)\n\t        logging.info('開始爬蟲')\n", "        # 登入\n\t        API_KEY = config['API_KEY']\n\t        SECRET_KEY = config['SECRET_KEY']\n\t        acct = config['ACCOUNT_NAME']\n\t        aInfo._login(API_KEY, SECRET_KEY, acct)\n\t        time.sleep(30)\n\t        # 更新股票清單\n\t        logging.info('Updating stock list')\n\t        stock_list = crawler1.get_security_list(stock_only=True)\n\t        crawler1.export_security_list(stock_list)\n", "        # 爬當天股價資料\n\t        crawler1.crawl_from_sinopac(stockids='all', update=True)\n\t        crawler1.merge_stockinfo()\n\t        # 更新歷史資料\n\t        for scale in ConvertScales:\n\t            crawler1.add_new_data(scale, save=True, start=TODAY_STR)\n\t            crawler1.merge_daily_data(TODAY_STR, scale, save=True)\n\t        crawler1.merge_daily_data(TODAY_STR, '1T', save=True)\n\t    except KeyboardInterrupt:\n\t        notifier.post(f\"\\n【Interrupt】【爬蟲程式】已手動關閉\", msgType='Tasker')\n", "    except:\n\t        logging.exception('Catch an exception:')\n\t        notifier.post(f\"\\n【Error】【爬蟲程式】股價爬蟲發生異常\", msgType='Tasker')\n\t        if len(crawler1.StockData):\n\t            df = pd.concat(crawler1.StockData)\n\t            filename = f'{crawler1.folder_path}/stock_data_1T.pkl'\n\t            file_handler.save_table(df, filename)\n\t    finally:\n\t        logging.info(f'登出系統: {API.logout()}')\n\tdef runSelectStock():\n", "    try:\n\t        df = picker.pick(3, 1.8, 3)\n\t        df = picker.melt_table(df)\n\t        tb = df[df.Time == TODAY_STR].reset_index(drop=True)\n\t        picker.export(tb)\n\t        notifier.post_stock_selection(tb)\n\t    except FileNotFoundError as e:\n\t        logging.warning(f'{e} No stock is selected.')\n\t    except KeyboardInterrupt:\n\t        notifier.post(f\"\\n【Interrupt】【選股程式】已手動關閉\", msgType='Tasker')\n", "    except:\n\t        logging.exception('Catch an exception:')\n\t        notifier.post(f\"\\n【Error】【選股程式】選股發生異常\", msgType='Tasker')\n\tdef runCrawlFromHTML():\n\t    try:\n\t        # update PutCallRatio\n\t        step = 'PutCallRatio'\n\t        df_pcr_new = crawler2.put_call_ratio()\n\t        crawler2.export_put_call_ratio(df_pcr_new)\n\t        # notifier.post_put_call_ratio(df_pcr_new)\n", "        # 爬除權息資料\n\t        step = '爬除權息資料'\n\t        dividends = crawler2.ex_dividend_list()\n\t        crawler2.export_ex_dividend_list(dividends)\n\t        # 期貨逐筆成交資料\n\t        step = '期貨逐筆成交資料'\n\t        crawler2.get_FuturesTickData(TODAY_STR)\n\t        # 轉換&更新期貨逐筆成交資料\n\t        df = tdp.convert_daily_tick(TODAY_STR, '1T')\n\t        crawler2.export_futures_kbar(df)\n", "    except KeyboardInterrupt:\n\t        notifier.post(f\"\\n【Interrupt】【爬蟲程式】已手動關閉\", msgType='Tasker')\n\t    except:\n\t        logging.exception('Catch an exception:')\n\t        notifier.post(f\"\\n【Error】【爬蟲程式】{step}發生異常\", msgType='Tasker')\n\tdef thread_subscribe(user, targets):\n\t    import shioaji as sj\n\t    subscriber = Subscriber()\n\t    api = sj.Shioaji()\n\t    @api.quote.on_event\n", "    def event_callback(resp_code: int, event_code: int, info: str, event: str):\n\t        if 'Subscription Not Found' in info:\n\t            logging.warning(info)\n\t        else:\n\t            logging.info(\n\t                f'Response code: {resp_code} | Event code: {event_code} | info: {info} | Event: {event}')\n\t    @api.on_quote_stk_v1()\n\t    def stk_quote_callback_v1(exchange, tick):\n\t        if tick.intraday_odd == 0 and tick.simtrade == 0:\n\t            tick_data = subscriber.stk_quote_v1(tick)\n", "            redis_tick.to_redis({tick.code: tick_data})\n\t    config = dotenv_values(f'./lib/envs/{user}.env')\n\t    API_KEY = config['API_KEY']\n\t    SECRET_KEY = config['SECRET_KEY']\n\t    api.login(API_KEY, SECRET_KEY)\n\t    time.sleep(2)\n\t    try:\n\t        logging.info('subscribe_targets')\n\t        for t in targets:\n\t            if t[:3] in api.Contracts.Indexs.__dict__:\n", "                target = api.Contracts.Indexs[t[:3]][t]\n\t            elif t[:3] in api.Contracts.Futures.__dict__:\n\t                target = api.Contracts.Futures[t[:3]][t]\n\t            elif t[:3] in api.Contracts.Options.__dict__:\n\t                target = api.Contracts.Options[t[:3]][t]\n\t            else:\n\t                target = api.Contracts.Stocks[t]\n\t            api.quote.subscribe(target, quote_type='tick', version='v1')\n\t        logging.info(f'Done subscribe {len(targets)} targets')\n\t        now = datetime.now()\n", "        time.sleep(max((TEnd - now).total_seconds(), 0))\n\t    except:\n\t        logging.exception('Catch an exception:')\n\t    finally:\n\t        logging.info(f'{datetime.now()} is log-out: {api.logout()}')\n\t        time.sleep(10)\n\t    return \"Task completed\"\n\tdef runShioajiSubscriber():\n\t    # TODO: 讀取要盤中選股的股票池\n\t    df = file_handler.read_table(f'{PATH}/selections/stock_list.xlsx')\n", "    codes = df[df.exchange.isin(['TSE', 'OTC'])].code.astype(str).values\n\t    N = 200\n\t    futures = []\n\t    for i, user in enumerate(ACCOUNTS):\n\t        targets = codes[N*i:N*(i+1)]\n\t        future = executor.submit(thread_subscribe, user, targets)\n\t        futures.append(future)\n\t    for future in as_completed(futures):\n\t        logging.info(future.result())\n\tdef runSimulationChecker():\n", "    try:\n\t        for account in ACCOUNTS:\n\t            config = dotenv_values(f'./lib/envs/{account}.env')\n\t            if config['MODE'] == 'Simulation':\n\t                se = StrategyExecutor(config=config)\n\t                # check stock pool size\n\t                watchlist = se.watchlist[se.watchlist.market == 'Stocks']\n\t                stocks = se.get_securityInfo('Stocks')\n\t                is_same_shape = watchlist.shape[0] == stocks.shape[0]\n\t                if not is_same_shape:\n", "                    text = f'\\n【{account} 庫存不一致】'\n\t                    text += f'\\nSize: watchlist {watchlist.shape[0]}; stocks: {stocks.shape[0]}'\n\t                    text += f'\\nwatchlist day start: {watchlist.buyday.min()}'\n\t                    text += f'\\nwatchlist day end: {watchlist.buyday.max()}'\n\t                    text += f'\\nwatchlist - stocks: {set(watchlist.code) - set(stocks.code)}'\n\t                    text += f'\\nstocks - watchlist: {set(stocks.code) - set(watchlist.code)}'\n\t                    notifier.post(text, msgType='Monitor')\n\t    except FileNotFoundError as e:\n\t        logging.warning(e)\n\t        notifier.post(f'\\n{e}', msgType='Tasker')\n", "    except:\n\t        logging.exception('Catch an exception:')\n\t        notifier.post('\\n【Error】【模擬帳戶檢查】發生異常', msgType='Tasker')\n\tTasks = {\n\t    'create_env': [runCreateENV],\n\t    'account_info': [runAccountInfo, runPerformanceReport, runSimulationChecker],\n\t    'update_and_select_stock': [runCrawlStockData, runSelectStock, runCrawlFromHTML],\n\t    'crawl_stock_data': [runCrawlStockData],\n\t    'select_stock': [runSelectStock],\n\t    'crawl_html': [runCrawlFromHTML],\n", "    'auto_trader': [runAutoTrader],\n\t    'subscribe': [runShioajiSubscriber],\n\t}\n\tfor taskName, tasks in customTasks.items():\n\t    if taskName in Tasks:\n\t        Tasks[taskName] += tasks\n\t    else:\n\t        Tasks[taskName] = tasks\n"]}
{"filename": "trader/config.py", "chunked_list": ["import logging\n\timport pandas as pd\n\timport configparser\n\timport shioaji as sj\n\tfrom datetime import datetime, timedelta\n\tAPI = sj.Shioaji()\n\tTODAY = datetime.today()\n\tTODAY_STR = TODAY.strftime(\"%Y-%m-%d\")\n\tSystemConfig = configparser.ConfigParser()\n\tSystemConfig.read('./lib/config.ini', encoding='utf8')\n", "def getList(section, option):\n\t    content = SystemConfig.get(section, option)\n\t    if len(content) > 0:\n\t        return content.replace(' ', '').split(',')\n\t    return []\n\tdef get_settings(section, option, dataType='str'):\n\t    funcs = {\n\t        'str': SystemConfig.get,\n\t        'int': SystemConfig.getint,\n\t        'float': SystemConfig.getfloat,\n", "        'bool': SystemConfig.getboolean,\n\t        'list': getList\n\t    }\n\t    if section in SystemConfig.sections():\n\t        options = SystemConfig.options(section)\n\t        if options and option.lower() in options:\n\t            try:\n\t                return funcs[dataType](section, option)\n\t            except:\n\t                return SystemConfig.get(section, option)\n", "    if dataType == 'list':\n\t        return []\n\t    return ''\n\tdef get_holidays():\n\t    try:\n\t        df = pd.read_csv('./lib/政府行政機關辦公日曆表.csv')\n\t        df.date = pd.to_datetime(df.date)\n\t        df.name = df.name.fillna(df.holidayCategory)\n\t        holidays = df.set_index('date').name.to_dict()\n\t        eves = {k: v for k, v in holidays.items() if v == '農曆除夕'}\n", "        for i in range(2):\n\t            days = {d - timedelta(days=i+1) if d - timedelta(days=i+1)\n\t                    not in holidays else d - timedelta(days=i+2): '年前封關' for d in eves}\n\t            holidays.update(days)\n\t        return holidays\n\t    except:\n\t        logging.warning('Run trader without holiday data.')\n\t        return {}\n\t# 使用者相關\n\tACCOUNTS = get_settings(\"ACCOUNT\", \"USERS\", dataType='list')\n", "# 資料庫相關\n\tREDIS_HOST = get_settings('DB', 'REDIS_HOST')\n\tREDIS_PORT = get_settings('DB', 'REDIS_PORT', dataType='int')\n\tREDIS_PWD = get_settings('DB', 'REDIS_PWD')\n\tHAS_REDIS = all(x for x in [REDIS_HOST, REDIS_PORT, REDIS_PWD])\n\tDB_HOST = get_settings('DB', 'DB_HOST')\n\tDB_PORT = get_settings('DB', 'DB_PORT', dataType='int')\n\tDB_USER = get_settings('DB', 'DB_USER')\n\tDB_PWD = get_settings('DB', 'DB_PWD')\n\tDB_NAME = get_settings('DB', 'DB_NAME')\n", "HAS_DB = all(x for x in [DB_HOST, DB_NAME, DB_PORT, DB_PWD, DB_USER])\n\tDB_URL = f'{DB_USER}:{DB_PWD}@{DB_HOST}:{DB_PORT}' if HAS_DB else ''\n\tPATH = get_settings('DATA', 'DATA_PATH')\n\t# LINE notify\n\tTOKEN_MONITOR = get_settings('LINENOTIFY', 'TOKEN_MONITOR')\n\tTOKEN_INFO = get_settings('LINENOTIFY', 'TOKEN_INFO')\n\tclass StrategyNameList:\n\t    StrategyLongNDT = get_settings('STRATEGY', 'Long', dataType='list')\n\t    StrategyShortNDT = get_settings('STRATEGY', 'Short', dataType='list')\n\t    StrategyLongDT = get_settings('STRATEGY', 'LongDT', dataType='list')\n", "    StrategyShortDT = get_settings('STRATEGY', 'ShortDT', dataType='list')\n\t    All = StrategyLongNDT + StrategyLongDT + StrategyShortNDT + StrategyShortDT\n\t    Long = StrategyLongNDT + StrategyLongDT\n\t    Short = StrategyShortNDT + StrategyShortDT\n\t    DayTrade = StrategyLongDT + StrategyShortDT\n\t    Code = {stra: f'Strategy{i+1}' for i, stra in enumerate(All)}\n\t# 策略相關\n\tStrategyList = StrategyNameList()\n\t# 交易相關\n\tFEE_RATE = .01\n", "# 時間相關\n\tT15K = pd.to_datetime('09:15:00')\n\tT30K = pd.to_datetime('09:30:00')\n\tTStart = pd.to_datetime('09:05:00')\n\tTEnd = pd.to_datetime('13:30:05')\n\tTCheck1 = pd.to_datetime('09:03:00')\n\tTBuy1 = pd.to_datetime('09:00:00')\n\tTBuy2 = pd.to_datetime('13:15:00')\n\tTTry = pd.to_datetime('13:25:00')\n\tTimeStartStock = pd.to_datetime('09:00:00')\n", "TimeEndStock = pd.to_datetime('13:30:00')\n\tTimeStartFuturesDay = pd.to_datetime('08:45:00')\n\tTimeEndFuturesDay = pd.to_datetime('13:45:00')\n\tTimeStartFuturesNight = pd.to_datetime('15:00:00')\n\tTimeEndFuturesNight = pd.to_datetime('05:00:00') + timedelta(days=1)\n\tTimeTransferFutures = pd.to_datetime('13:00:00')\n\tholidays = get_holidays()\n\t# 選股相關\n\tSelectMethods = get_settings('SELECT', 'METHODS', dataType='list')\n\t# 爬蟲相關\n", "ConvertScales = get_settings('CRAWLER', 'SCALES', dataType='list')\n\t# K棒特徵\n\tKbarFeatures = {\n\t    '2T': get_settings('KBARFEATURE', 'K2min', dataType='list'),\n\t    '5T': get_settings('KBARFEATURE', 'K5min', dataType='list'),\n\t    '15T': get_settings('KBARFEATURE', 'K15min', dataType='list'),\n\t    '30T': get_settings('KBARFEATURE', 'K30min', dataType='list'),\n\t    '60T': get_settings('KBARFEATURE', 'K60min', dataType='list'),\n\t}\n"]}
{"filename": "trader/executor.py", "chunked_list": ["import ssl\n\timport time\n\timport logging\n\timport numpy as np\n\timport pandas as pd\n\tfrom typing import Dict\n\tfrom sys import platform\n\tfrom shioaji import constant\n\tfrom collections import namedtuple\n\tfrom datetime import datetime, timedelta\n", "from . import __version__\n\tfrom . import notifier, picker, crawler2, file_handler\n\tfrom .config import API, PATH, TODAY, TODAY_STR, holidays\n\tfrom .config import FEE_RATE, TEnd, TTry, TimeStartStock, TimeStartFuturesDay\n\tfrom .config import TimeEndFuturesDay, TimeStartFuturesNight, TimeEndFuturesNight\n\tfrom .utils import get_contract\n\tfrom .utils.kbar import KBarTool\n\tfrom .utils.orders import OrderTool\n\tfrom .utils.cipher import CipherTool\n\tfrom .utils.accounts import AccountInfo\n", "from .utils.subscribe import Subscriber\n\tfrom .utils.watchlist import WatchListTool\n\tfrom .utils.database import db\n\tfrom .utils.database.tables import SecurityInfoStocks, SecurityInfoFutures\n\ttry:\n\t    from .scripts.StrategySet import StrategySet as StrategySets\n\texcept:\n\t    from .utils.strategy import StrategyTool as StrategySets\n\tssl._create_default_https_context = ssl._create_unverified_context\n\tclass StrategyExecutor(AccountInfo, WatchListTool, KBarTool, OrderTool, Subscriber):\n", "    def __init__(self, config=None):\n\t        self.ct = CipherTool(decrypt=True, encrypt=False)\n\t        self.CONFIG = config\n\t        # 交易帳戶設定\n\t        self.ACCOUNT_NAME = self.getENV('ACCOUNT_NAME')\n\t        self.__API_KEY__ = self.getENV('API_KEY')\n\t        self.__SECRET_KEY__ = self.getENV('SECRET_KEY')\n\t        self.__ACCOUNT_ID__ = self.getENV('ACCOUNT_ID', 'decrypt')\n\t        self.__CA_PASSWD__ = self.getENV('CA_PASSWD', 'decrypt')\n\t        # 股票使用者設定\n", "        self.KBAR_START_DAYay = self.getENV('KBAR_START_DAYay', 'date')\n\t        self.MODE = self.getENV('MODE')\n\t        self.MARKET = self.getENV('MARKET')\n\t        self.FILTER_OUT = self.getENV('FILTER_OUT', 'list')\n\t        self.STRATEGY_STOCK = self.getENV('STRATEGY_STOCK', 'list')\n\t        self.PRICE_THRESHOLD = self.getENV('PRICE_THRESHOLD', 'int')\n\t        self.INIT_POSITION = self.getENV('INIT_POSITION', 'int')\n\t        self.POSITION_LIMIT_LONG = self.getENV('POSITION_LIMIT_LONG', 'int')\n\t        self.POSITION_LIMIT_SHORT = self.getENV('POSITION_LIMIT_SHORT', 'int')\n\t        self.N_STOCK_LIMIT_TYPE = self.getENV('N_STOCK_LIMIT_TYPE')\n", "        self.N_LIMIT_LS = self.getENV('N_LIMIT_LS', 'int')\n\t        self.N_LIMIT_SS = self.getENV('N_LIMIT_SS', 'int')\n\t        self.BUY_UNIT = self.getENV('BUY_UNIT', 'int')\n\t        self.BUY_UNIT_TYPE = self.getENV('BUY_UNIT_TYPE')\n\t        self.ORDER_COND1 = self.getENV('ORDER_COND1')\n\t        self.ORDER_COND2 = self.getENV('ORDER_COND2')\n\t        self.LEVERAGE_LONG = {}\n\t        self.LEVERAGE_SHORT = {}\n\t        self.day_trade_cond = {\n\t            'MarginTrading': 'ShortSelling',\n", "            'ShortSelling': 'MarginTrading',\n\t            'Cash': 'Cash'\n\t        }\n\t        self.simulation = self.MODE == 'Simulation'\n\t        # 期貨使用者設定\n\t        self.TRADING_PERIOD = self.getENV('TRADING_PERIOD')\n\t        self.STRATEGY_FUTURES = self.getENV('STRATEGY_FUTURES', 'list')\n\t        self.MARGIN_LIMIT = self.getENV('MARGIN_LIMIT', 'int')\n\t        self.N_FUTURES_LIMIT_TYPE = self.getENV('N_FUTURES_LIMIT_TYPE')\n\t        self.N_FUTURES_LIMIT = self.getENV('N_FUTURES_LIMIT', 'int')\n", "        self.N_SLOT = self.getENV('N_SLOT', 'int')\n\t        self.N_SLOT_TYPE = self.getENV('N_SLOT_TYPE')\n\t        super().__init__()\n\t        KBarTool.__init__(self, self.KBAR_START_DAYay)\n\t        OrderTool.__init__(self)\n\t        Subscriber.__init__(self)\n\t        WatchListTool.__init__(self, self.ACCOUNT_NAME)\n\t        # 股票可進場籌碼 (進場時判斷用)\n\t        self.simulate_amount = np.iinfo(np.int64).max\n\t        self.stocks = pd.DataFrame()\n", "        self.desposal_money = 0\n\t        self.stock_bought = []\n\t        self.stock_sold = []\n\t        self.n_stocks_long = 0\n\t        self.n_stocks_short = 0\n\t        self.total_market_value = 0\n\t        self.punish_list = []\n\t        self.pct_chg_DowJones = self.get_pct_chg_DowJones()\n\t        self.n_categories = None\n\t        # 期貨可進場籌碼 (進場時判斷用)\n", "        self.futures_opened = []\n\t        self.futures_closed = []\n\t        self.futures_transferred = {}\n\t        self.n_futures = 0\n\t        self.futures = pd.DataFrame()\n\t        self.Futures_Code_List = {}\n\t        self.margin_table = None\n\t        # 交易相關\n\t        self.can_stock = 'stock' in self.MARKET\n\t        self.can_sell = self.MODE not in ['LongBuy', 'ShortBuy']\n", "        self.can_buy = self.MODE not in ['LongSell', 'ShortSell']\n\t        self.can_futures = 'futures' in self.MARKET\n\t        self.stocks_to_monitor = {}\n\t        self.futures_to_monitor = {}\n\t        # 載入指標模組\n\t        self.set_scripts(StrategySets)\n\t    def set_scripts(self, strategySet: object):\n\t        self.StrategySet = strategySet(\n\t            account_name=self.ACCOUNT_NAME,\n\t            hold_day=self.getENV('HOLD_DAY', 'int'),\n", "            is_simulation=self.simulation,\n\t            stock_limit_type=self.N_STOCK_LIMIT_TYPE,\n\t            futures_limit_type=self.N_FUTURES_LIMIT_TYPE,\n\t            stock_limit_long=self.N_LIMIT_LS,\n\t            stock_limit_short=self.N_LIMIT_SS,\n\t            futures_limit=self.N_FUTURES_LIMIT,\n\t        )\n\t    def getENV(self, key: str, type_: str = 'text'):\n\t        if self.CONFIG and key in self.CONFIG:\n\t            env = self.CONFIG[key]\n", "            if type_ == 'int':\n\t                return int(env)\n\t            elif type_ == 'list':\n\t                if 'none' in env.lower():\n\t                    return []\n\t                return env.replace(' ', '').split(',')\n\t            elif type_ == 'date' and env:\n\t                return pd.to_datetime(env)\n\t            elif type_ == 'decrypt':\n\t                if not env or (not env[0].isdigit() and env[1:].isdigit()):\n", "                    return env\n\t                return self.ct.decrypt(env)\n\t            return env\n\t        elif type_ == 'int':\n\t            return 0\n\t        elif type_ == 'list':\n\t            return []\n\t        return None\n\t    def _set_trade_risks(self):\n\t        '''設定交易風險值: 可交割金額、總市值'''\n", "        cost_value = (self.stocks.quantity * self.stocks.cost_price).sum()\n\t        pnl = self.stocks.pnl.sum()\n\t        if self.simulation:\n\t            account_balance = self.INIT_POSITION\n\t            settle_info = pnl\n\t        else:\n\t            account_balance = self.balance()\n\t            settle_info = self.settle_info(mode='info').iloc[1:, 1].sum()\n\t        self.desposal_money = min(\n\t            account_balance+settle_info, self.POSITION_LIMIT_LONG)\n", "        self.total_market_value = self.desposal_money + cost_value + pnl\n\t        logging.info(\n\t            f'Desposal amount = {self.desposal_money} (limit: {self.POSITION_LIMIT_LONG})')\n\t    def _set_margin_limit(self):\n\t        '''計算可交割的保證金額，不可超過帳戶可下單的保證金額上限'''\n\t        if self.simulation:\n\t            self.desposal_margin = self.simulate_amount\n\t            self.ProfitAccCount = self.simulate_amount\n\t        else:\n\t            self.get_account_margin()\n", "        self.desposal_margin = min(self.desposal_margin, self.MARGIN_LIMIT)\n\t        logging.info(f'權益總值: {self.ProfitAccCount}')\n\t        logging.info(\n\t            f'Margin available = {self.desposal_margin} (limit: {self.MARGIN_LIMIT})')\n\t    def _set_leverage(self, stockids: list):\n\t        '''\n\t        取得個股融資成數資料，\n\t        若帳戶設定為不可融資，則全部融資成數為0\n\t        '''\n\t        df = pd.DataFrame([crawler2.get_leverage(s) for s in stockids])\n", "        if df.shape[0]:\n\t            df.loc[df.個股融券信用資格 == 'N', '融券成數'] = 100\n\t            df.代號 = df.代號.astype(str)\n\t            df.融資成數 /= 100\n\t            df.融券成數 /= 100\n\t            if self.ORDER_COND1 != 'Cash':\n\t                self.LEVERAGE_LONG = df.set_index('代號').融資成數.to_dict()\n\t            else:\n\t                self.LEVERAGE_LONG = {code: 0 for code in stockids}\n\t            if self.ORDER_COND2 != 'Cash':\n", "                self.LEVERAGE_SHORT = df.set_index('代號').融券成數.to_dict()\n\t            else:\n\t                self.LEVERAGE_SHORT = {code: 1 for code in stockids}\n\t        logging.info(f'Long leverages: {self.LEVERAGE_LONG}')\n\t        logging.info(f'Short leverages: {self.LEVERAGE_SHORT}')\n\t    def _set_futures_code_list(self):\n\t        '''期貨商品代號與代碼對照表'''\n\t        if self.can_futures and self.Futures_Code_List == {}:\n\t            logging.debug('Set Futures_Code_List')\n\t            self.Futures_Code_List = {\n", "                f.code: f.symbol for m in API.Contracts.Futures for f in m}\n\t    def __order_callback(self, stat, msg):\n\t        '''處理委託/成交回報'''\n\t        if stat == constant.OrderState.StockOrder:\n\t            stock = msg['contract']['code']\n\t            order = msg['order']\n\t            operation = msg['operation']\n\t            c2 = operation['op_code'] == '00' or operation['op_msg'] == ''\n\t            c3 = order['action'] == 'Buy'\n\t            c4 = operation['op_code'] == '88' and '此證券配額張數不足' in operation['op_msg']\n", "            c5 = len(stock) == 4\n\t            if order['account']['account_id'] == self.account_id_stock:\n\t                notifier.post_tftOrder(stat, msg)\n\t                if c3 and c5 and stock not in self.stock_bought:\n\t                    self.stock_bought.append(stock)\n\t                leverage = self.check_leverage(stock, order['order_cond'])\n\t                if c2 and c3:\n\t                    # 記錄委託成功的買單\n\t                    price = self.Quotes.NowTargets[stock]['price'] if stock in self.Quotes.NowTargets else order['price']\n\t                    quantity = order['quantity']\n", "                    if order['order_lot'] == 'Common':\n\t                        quantity *= 1000\n\t                    order_data = {\n\t                        'Time': datetime.now(),\n\t                        'market': 'Stocks',\n\t                        'code': stock,\n\t                        'action': order['action'],\n\t                        'price': price,\n\t                        'quantity': quantity,\n\t                        'amount': self.get_stock_amount(stock, price, quantity, order['order_cond']),\n", "                        'order_cond': order['order_cond'],\n\t                        'order_lot': order['order_lot'],\n\t                        'leverage': leverage,\n\t                        'account_id': order['account']['account_id']\n\t                    }\n\t                    self.appendOrder(order_data)\n\t                # 若融資配額張數不足，改現股買進 ex: '此證券配額張數不足，餘額 0 張（證金： 0 ）'\n\t                elif c4:\n\t                    q_balance = operation['op_msg'].split(' ')\n\t                    if len(q_balance) > 1:\n", "                        q_balance = int(q_balance[1])\n\t                        infos = dict(\n\t                            action=order['action'], target=stock, pos_target=100, pos_balance=100)\n\t                        # 若本日還沒有下過融資且剩餘券數為0，才可以改下現股\n\t                        if q_balance == 0 and stock not in self.stock_bought:\n\t                            orderinfo = self.OrderInfo(\n\t                                quantity=1000 *\n\t                                int(order['quantity']*(1-leverage)),\n\t                                order_cond='Cash',\n\t                                **infos\n", "                            )\n\t                            self._place_order(orderinfo, market='Stocks')\n\t                        elif q_balance > 0:\n\t                            orderinfo = self.OrderInfo(\n\t                                quantity=q_balance,\n\t                                order_cond=order['order_cond'],\n\t                                **infos\n\t                            )\n\t                            self._place_order(orderinfo, market='Stocks')\n\t                # 若刪單成功就自清單移除\n", "                if operation['op_type'] == 'Cancel':\n\t                    self.deleteOrder(stock)\n\t                    if c3 and stock in self.stock_bought:\n\t                        self.stock_bought.remove(stock)\n\t        elif stat == constant.OrderState.StockDeal and msg['account_id'] == self.account_id_stock:\n\t            stock = msg['code']\n\t            msg.update({\n\t                'position': 100,\n\t                'yd_quantity': 0,\n\t                'bst': datetime.now(),\n", "                'cost_price': msg['price']\n\t            })\n\t            notifier.post_tftDeal(stat, msg)\n\t            if msg['order_lot'] == 'Common':\n\t                msg['quantity'] *= 1000\n\t            quantity = msg['quantity']\n\t            if msg['action'] == 'Sell':\n\t                if stock not in self.stock_sold and len(stock) == 4:\n\t                    self.stock_sold.append(stock)\n\t                price = msg['price']\n", "                leverage = self.check_leverage(stock, msg['order_cond'])\n\t                cost_price = self.get_cost_price(\n\t                    stock, price, msg['order_cond'])\n\t                # 紀錄成交的賣單\n\t                order_data = {\n\t                    'Time': datetime.now(),\n\t                    'market': 'Stocks',\n\t                    'code': stock,\n\t                    'price': -price,\n\t                    'quantity': quantity,\n", "                    # 賣出金額 - 融資金額 - 手續費\n\t                    'amount': -(price - cost_price*leverage)*quantity*(1 - FEE_RATE),\n\t                    'order_cond': msg['order_cond'],\n\t                    'order_lot': msg['order_lot'],\n\t                    'leverage': leverage,\n\t                    'account_id': msg['account_id']\n\t                }\n\t                self.appendOrder(order_data)\n\t            # 更新監控庫存\n\t            if not self.simulation:\n", "                self.update_monitor_lists(msg['action'], msg)\n\t        elif stat == constant.OrderState.FuturesOrder:\n\t            code = msg['contract']['code']\n\t            symbol = code + msg['contract']['delivery_month']\n\t            bsh = self.Quotes.AllTargets[symbol]['price']\n\t            msg.update({\n\t                'symbol': symbol,\n\t                'cost_price': self.Quotes.NowTargets[symbol]['price'] if symbol in self.Quotes.NowTargets else 0,\n\t                'bsh': max(bsh) if bsh else 0,\n\t                'bst': datetime.now(),\n", "                'position': 100\n\t            })\n\t            order = msg['order']\n\t            operation = msg['operation']\n\t            if order['account']['account_id'] == self.account_id_futopt:\n\t                notifier.post_fOrder(stat, msg)\n\t                if operation['op_code'] == '00' or operation['op_msg'] == '':\n\t                    self._update_futures_deal_list(symbol, order['oc_type'])\n\t                    # 紀錄成交的賣單\n\t                    price = -order['price'] if c4 else order['price']\n", "                    sign = -1 if order['action'] == 'Sell' else 1\n\t                    quantity = order['quantity']\n\t                    order_data = {\n\t                        'Time': datetime.now(),\n\t                        'market': 'Futures',\n\t                        'code': symbol,\n\t                        'price': price*sign,\n\t                        'quantity': quantity,\n\t                        'amount': self.get_open_margin(symbol, quantity)*sign,\n\t                        'op_type': order['oc_type'],\n", "                        'account_id': order['account']['account_id']\n\t                    }\n\t                    self.appendOrder(order_data)\n\t                # 若刪單成功就自清單移除\n\t                if operation['op_type'] == 'Cancel':\n\t                    self.deleteOrder(symbol)\n\t                    if symbol in self.futures_opened:\n\t                        self.futures_opened.remove(symbol)\n\t                # 更新監控庫存\n\t                if not self.simulation:\n", "                    self.update_monitor_lists(operation['op_type'], msg)\n\t        elif stat == constant.OrderState.FuturesDeal:\n\t            notifier.post_fDeal(stat, msg)\n\t    def login_and_activate(self):\n\t        # 登入\n\t        self._login(self.__API_KEY__, self.__SECRET_KEY__, self.ACCOUNT_NAME)\n\t        self.account_id_stock = API.stock_account.account_id\n\t        logging.info(f'Stock account ID: {self.account_id_stock}')\n\t        if self.HAS_FUTOPT_ACCOUNT:\n\t            self.can_futures = 'futures' in self.MARKET\n", "            self.account_id_futopt = API.futopt_account.account_id\n\t            self._set_futures_code_list()\n\t            logging.info(f'Futures account ID: {self.account_id_futopt}')\n\t        # 啟動憑證 (Mac 不需啟動)\n\t        if platform != 'darwin':\n\t            logging.info(f'Activate {self.ACCOUNT_NAME} CA')\n\t            if self.__CA_PASSWD__:\n\t                ca_passwd = self.__CA_PASSWD__\n\t            else:\n\t                ca_passwd = self.__ACCOUNT_ID__\n", "            API.activate_ca(\n\t                ca_path=f\"./lib/ekey/551/{self.__ACCOUNT_ID__}/S/Sinopac.pfx\",\n\t                ca_passwd=ca_passwd,\n\t                person_id=self.__ACCOUNT_ID__,\n\t            )\n\t        # 系統 callback 設定\n\t        self._set_callbacks()\n\t    def _set_callbacks(self):\n\t        '''取得API回傳報價'''\n\t        @API.on_tick_stk_v1()\n", "        def stk_quote_callback_v1(exchange, tick):\n\t            if tick.intraday_odd == 0 and tick.simtrade == 0:\n\t                if tick.code not in self.Quotes.NowTargets:\n\t                    logging.debug(f'First quote of {tick.code}')\n\t                tick_data = self.stk_quote_v1(tick)\n\t                # self.to_redis({tick.code: tick_data})\n\t        @API.on_tick_fop_v1()\n\t        def fop_quote_callback_v1(exchange, tick):\n\t            try:\n\t                if tick.simtrade == 0:\n", "                    symbol = self.Futures_Code_List[tick.code]\n\t                    if symbol not in self.Quotes.NowTargets:\n\t                        logging.debug(f'First quote of {symbol}')\n\t                    tick_data = self.fop_quote_v1(symbol, tick)\n\t                    # self.to_redis({symbol: tick_data})\n\t            except KeyError:\n\t                logging.exception('KeyError: ')\n\t        @API.quote.on_quote\n\t        def quote_callback(topic: str, quote: dict):\n\t            self.index_v0(quote)\n", "        @API.quote.on_event\n\t        def event_callback(resp_code: int, event_code: int, info: str, event: str):\n\t            if 'Subscription Not Found' in info:\n\t                logging.warning(info)\n\t            else:\n\t                logging.info(\n\t                    f'Response code: {resp_code} | Event code: {event_code} | info: {info} | Event: {event}')\n\t                if info == 'Session connect timeout' or event_code == 1:\n\t                    time.sleep(5)\n\t                    logging.info(f'登出系統: {API.logout()}')\n", "                    logging.warning('Re-login')\n\t                    time.sleep(5)\n\t                    self._login(self.__API_KEY__,\n\t                                self.__SECRET_KEY__, self.ACCOUNT_NAME)\n\t        # 訂閱下單回報\n\t        API.set_order_callback(self.__order_callback)\n\t        # 訂閱五檔回報\n\t        @API.on_bidask_stk_v1()\n\t        def stk_quote_callback(exchange, bidask):\n\t            self.BidAsk[bidask.code] = bidask\n", "        @API.on_bidask_fop_v1()\n\t        def fop_quote_callback(exchange, bidask):\n\t            symbol = self.Futures_Code_List[bidask.code]\n\t            self.BidAsk[symbol] = bidask\n\t    def _log_and_notify(self, msg: str):\n\t        '''將訊息加入log並推播'''\n\t        logging.info(msg)\n\t        notifier.post(f'\\n{msg}', msgType='Monitor')\n\t    def init_stocks(self):\n\t        '''初始化股票資訊'''\n", "        if not self.can_stock:\n\t            return None, []\n\t        # 讀取選股清單\n\t        strategies = self.get_stock_pool()\n\t        # 取得遠端庫存\n\t        self.stocks = self.get_securityInfo('Stocks')\n\t        # 取得策略清單\n\t        self.init_watchlist(self.stocks, strategies)\n\t        # 庫存的處理\n\t        self.stocks = self.stocks.merge(\n", "            self.watchlist,\n\t            how='left',\n\t            on=['account', 'market', 'code']\n\t        )\n\t        self.stocks.position.fillna(100, inplace=True)\n\t        strategies.update(self.stocks.set_index('code').strategy.to_dict())\n\t        # 剔除不堅控的股票\n\t        self.stocks = self.stocks[~self.stocks.code.isin(self.FILTER_OUT)]\n\t        # 新增歷史K棒資料\n\t        self.update_stocks_to_monitor(strategies)\n", "        all_targets = list(self.stocks_to_monitor)\n\t        self.history_kbars(['TSE001', 'OTC101'] + all_targets)\n\t        # 交易風險控制\n\t        buy_condition = self.stocks.action == 'Buy'\n\t        self.n_stocks_long = self.stocks[buy_condition].shape[0]\n\t        self.n_stocks_short = self.stocks[~buy_condition].shape[0]\n\t        self.N_LIMIT_LS = self.StrategySet.setNStockLimitLong(KBars=self.KBars)\n\t        self.N_LIMIT_SS = self.StrategySet.setNStockLimitShort(\n\t            KBars=self.KBars)\n\t        self.punish_list = crawler2.get_punish_list().證券代號.to_list()\n", "        self._set_leverage(all_targets)\n\t        self._set_trade_risks()\n\t        logging.debug(f'stocks_to_monitor: {self.stocks_to_monitor}')\n\t        return strategies, all_targets\n\t    def init_futures(self):\n\t        '''初始化期貨資訊'''\n\t        def preprocess_(df):\n\t            if df.shape[0]:\n\t                for c in ['Volume', 'ContractAverPrice', 'SettlePrice', 'RealPrice']:\n\t                    df[c] = df[c].astype(float)\n", "                    if c in ['ContractAverPrice', 'SettlePrice', 'RealPrice']:\n\t                        df[c] = df.groupby('Code')[c].transform('mean')\n\t                    else:\n\t                        df[c] = df.groupby('Code')[c].transform(sum)\n\t                df = df.drop_duplicates('Code')\n\t                df = df.rename(columns={'ContractAverPrice': 'cost_price'})\n\t                df.Code = df.Code.astype(str).map(self.Futures_Code_List)\n\t                df.OrderBS = df.OrderBS.apply(\n\t                    lambda x: 'Buy' if x == 'B' else ('Sell' if x == 'S' else x))\n\t                orders = df[['Volume', 'OrderBS']]\n", "                orders = orders.rename(\n\t                    columns={'Volume': 'quantity', 'OrderBS': 'action'})\n\t                df['order'] = orders.to_dict('records')\n\t                day = TODAY_STR.replace('-', '/')\n\t                df['isDue'] = df.CodeName.apply(\n\t                    lambda x: day == get_contract(x).delivery_date)\n\t            return df\n\t        if not self.can_futures:\n\t            return None, []\n\t        # 讀取選股清單\n", "        strategies = self.get_futures_pool()\n\t        # 取得遠端庫存\n\t        self.futures = self.get_securityInfo('Futures')\n\t        # 庫存的處理\n\t        self.futures = preprocess_(self.futures)\n\t        self.futures = self.futures.merge(\n\t            self.watchlist,\n\t            how='left',\n\t            left_on=['Account', 'Market', 'Code'],\n\t            right_on=['account', 'market', 'code']\n", "        )\n\t        self.futures.position.fillna(100, inplace=True)\n\t        self.n_futures = self.futures.shape[0]\n\t        # 取得策略清單\n\t        self.futures.index = self.futures.Code\n\t        strategies.update(self.futures.strategy.to_dict())\n\t        # 剔除不堅控的股票\n\t        self.futures = self.futures[~self.futures.Code.isin(self.FILTER_OUT)]\n\t        # update_futures_to_monitor\n\t        self.futures_to_monitor.update(self.futures.to_dict('index'))\n", "        self.futures_to_monitor.update({\n\t            f: None for f in strategies if f not in self.futures_to_monitor})\n\t        # 新增歷史K棒資料\n\t        all_futures = list(self.futures_to_monitor)\n\t        self.history_kbars(all_futures)\n\t        # 交易風險控制\n\t        self.N_FUTURES_LIMIT = self.StrategySet.setNFuturesLimit(\n\t            KBars=self.KBars)\n\t        self._set_margin_limit()\n\t        self.margin_table = self.get_margin_table().原始保證金.to_dict()\n", "        return strategies, all_futures\n\t    def _update_position(self, order: namedtuple, strategies: Dict[str, str]):\n\t        '''更新庫存部位比例'''\n\t        action = order.action if not order.octype else order.octype\n\t        target = order.target\n\t        position = order.pos_target\n\t        is_day_trade = self.StrategySet.isDayTrade(strategies[target])\n\t        # update monitor list position\n\t        if order.action_type == 'Close':\n\t            if action in ['Buy', 'Sell']:\n", "                self.stocks_to_monitor[target]['position'] -= position\n\t            else:\n\t                self.futures_to_monitor[target]['position'] -= position\n\t        # remove from monitor list\n\t        is_stock = target in self.stocks_to_monitor\n\t        is_futures = target in self.futures_to_monitor\n\t        c1 = position == 100 or position >= order.pos_balance\n\t        c2 = is_stock and self.stocks_to_monitor[target]['quantity'] <= 0\n\t        c3 = is_stock and self.stocks_to_monitor[target]['position'] <= 0\n\t        c4 = is_futures and self.futures_to_monitor[target]['order']['quantity'] <= 0\n", "        c5 = is_futures and self.futures_to_monitor[target]['position'] <= 0\n\t        if c1 or c2 or c3 or c4 or c5:\n\t            order = order._replace(pos_target=100)\n\t            if c2 or c3:\n\t                # TODO:if is_day_trade: self.stocks_to_monitor[target] = None\n\t                self.remove_stock_monitor_list(target)\n\t            if c4 or c5:\n\t                if is_day_trade:\n\t                    self.futures_to_monitor[target] = None\n\t                else:\n", "                    self.remove_futures_monitor_list(target)\n\t        # append watchlist or udpate watchlist position\n\t        self.update_watchlist_position(order, self.Quotes, strategies)\n\t    def update_stocks_to_monitor(self, stocks_pool: Dict[str, list]):\n\t        '''更新買進/賣出股票監控清單'''\n\t        df = self.stocks.copy()\n\t        df.index = df.code\n\t        if not self.simulation:\n\t            df.order_cond = df.order_cond.apply(lambda x: x._value_)\n\t        self.stocks_to_monitor = df.to_dict('index')\n", "        for stock, stra in stocks_pool.items():\n\t            if (\n\t                (self.can_buy and self.StrategySet.isLong(stra)) or\n\t                (self.can_sell and self.StrategySet.isShort(stra))\n\t            ) and (stock not in self.stocks_to_monitor):\n\t                self.stocks_to_monitor.update({stock: None})\n\t    def update_monitor_lists(self, action, data):\n\t        '''更新監控庫存(成交回報)'''\n\t        target = data['code']\n\t        if action in ['Buy', 'Sell']:\n", "            if target in self.stocks_to_monitor and self.stocks_to_monitor[target]:\n\t                logging.debug(\n\t                    f'更新 stocks_to_monitor 【QUANTITY】: {action} {target}')\n\t                quantity = data['quantity']\n\t                # TODO: 部分進場\n\t                self.stocks_to_monitor[target]['quantity'] -= quantity\n\t            else:\n\t                logging.debug(\n\t                    f'更新 stocks_to_monitor 【DATA】: {action} {target}')\n\t                self.stocks_to_monitor[target] = data\n", "        # New, Cover\n\t        else:\n\t            if target in self.futures_to_monitor and self.futures_to_monitor[target]:\n\t                logging.debug(\n\t                    f'更新 futures_to_monitor 【QUANTITY】: {action} {target}')\n\t                quantity = data['order']['quantity']\n\t                self.futures_to_monitor[target]['order']['quantity'] -= quantity\n\t            else:\n\t                logging.debug(\n\t                    f'更新 futures_to_monitor 【DATA】: {action} {target}')\n", "                self.futures_to_monitor[target] = data\n\t    def _update_futures_deal_list(self, target, octype):\n\t        '''更新期貨下單暫存清單'''\n\t        if octype == 'New' and target not in self.futures_opened:\n\t            self.futures_opened.append(target)\n\t        if octype == 'Cover' and target not in self.futures_closed:\n\t            self.futures_closed.append(target)\n\t    def merge_buy_sell_lists(self, stocks_pool: Dict[str, str], market='Stocks'):\n\t        '''合併進出場清單: 將庫存與選股清單，合併'''\n\t        if market == 'Stocks' and self.stocks.shape[0]:\n", "            sells = self.stocks.code.values\n\t        elif market == 'Futures' and self.futures.shape[0]:\n\t            sells = self.futures.Code.values\n\t        else:\n\t            sells = []\n\t        all = sells.copy()\n\t        for ids in stocks_pool.values():\n\t            all = np.append(all, ids)\n\t        return np.unique(all)\n\t    def monitor_stocks(self, target: str, strategies: Dict[str, str]):\n", "        if target in self.Quotes.NowTargets and self.Quotes.NowIndex:\n\t            inputs = self.Quotes.NowTargets[target].copy()\n\t            data = self.stocks_to_monitor[target]\n\t            strategy = strategies[target]\n\t            isLongStrategy = self.StrategySet.isLong(strategy)\n\t            isDTStrategy = self.StrategySet.isDayTrade(strategy)\n\t            isSell = (\n\t                # long selling\n\t                (data and 'action' in data and data['action'] == 'Buy') or\n\t                # short selling\n", "                (not data and self.can_sell and not isLongStrategy)\n\t            )\n\t            # new position\n\t            if data is None:\n\t                mode = 'short' if isSell else 'long'\n\t                actionType = 'Open'\n\t                pos_balance = 100\n\t                order_cond = self.check_order_cond(target, mode)\n\t                quantity = self.get_quantity(target, strategy, order_cond)\n\t                enoughOpen = self.check_enough(target, quantity, mode)\n", "            # in-stock position\n\t            else:\n\t                actionType = 'Close'\n\t                pos_balance = data['position']\n\t                order_cond = data['order_cond']\n\t                quantity = data['quantity']\n\t                enoughOpen = False\n\t            inStocks = target in self.stocks.code.values\n\t            inDeal = target in self.stock_bought + self.stock_sold\n\t            is_day_trade = isDTStrategy and inDeal and (not inStocks)\n", "            isOpen = actionType == 'Open' and enoughOpen\n\t            isClose = (\n\t                (not isDTStrategy) and (not inDeal) and inStocks and\n\t                (actionType == 'Close')\n\t            )\n\t            isDTClose = (is_day_trade and (actionType == 'Close'))\n\t            if quantity and (isOpen or isClose or isDTClose):\n\t                tradeType = '當沖' if is_day_trade else '非當沖'\n\t                func = self.StrategySet.mapFunction(\n\t                    actionType, tradeType, strategy)\n", "                if data:\n\t                    inputs.update(data)\n\t                actionInfo = func(\n\t                    inputs=inputs,\n\t                    kbars=self.KBars,\n\t                    Quotes=self.Quotes,\n\t                    pct_chg_DowJones=self.pct_chg_DowJones\n\t                )\n\t                if actionInfo.position:\n\t                    infos = dict(\n", "                        action_type=actionType,\n\t                        action='Sell' if isSell else 'Buy',\n\t                        target=target,\n\t                        quantity=quantity,\n\t                        order_cond=self.day_trade_cond[order_cond] if is_day_trade else order_cond,\n\t                        pos_target=actionInfo.position,\n\t                        pos_balance=pos_balance,\n\t                        reason=actionInfo.msg,\n\t                    )\n\t                    self._log_and_notify(actionInfo.msg)\n", "                    return self.OrderInfo(**infos)\n\t        return self.OrderInfo(target=target)\n\t    def monitor_futures(self, target: str, strategies: Dict[str, str]):\n\t        '''檢查期貨是否符合賣出條件，回傳賣出部位(%)'''\n\t        if target in self.Quotes.NowTargets and self.N_FUTURES_LIMIT != 0:\n\t            inputs = self.Quotes.NowTargets[target].copy()\n\t            data = self.futures_to_monitor[target]\n\t            strategy = strategies[target]\n\t            isLongStrategy = self.StrategySet.isLong(strategy)\n\t            # 建倉\n", "            if data is None:\n\t                octype = 'New'\n\t                actionType = 'Open'\n\t                quantity = self.get_open_slot(target, strategy)\n\t                enoughOpen = self._check_enough_open(target, quantity)\n\t                pos_balance = 100\n\t                action = 'Buy' if isLongStrategy else 'Sell'\n\t            # 庫存\n\t            else:\n\t                octype = 'Cover'\n", "                actionType = 'Close'\n\t                enoughOpen = False\n\t                pos_balance = data['position']\n\t                if target in self.futures_opened:\n\t                    quantity = data['order']['quantity']\n\t                    action = data['order']['action']\n\t                else:\n\t                    quantity = data['Volume']\n\t                    action = data['OrderBS']\n\t            if target in self.futures_transferred:\n", "                msg = f'{target} 轉倉-New'\n\t                infos = dict(\n\t                    action_type=actionType,\n\t                    action=action,\n\t                    target=target,\n\t                    quantity=self.futures_transferred[target],\n\t                    octype=octype,\n\t                    pos_target=100,\n\t                    pos_balance=0,\n\t                    reason=msg\n", "                )\n\t                self._log_and_notify(msg)\n\t                self.futures_transferred.pop(target)\n\t                return self.OrderInfo(**infos)\n\t            c1 = octype == 'New' and enoughOpen and not self.is_not_trade_day(\n\t                inputs['datetime'])\n\t            c2 = octype == 'Cover'\n\t            if quantity and (c1 or c2):\n\t                is_day_trade = self.StrategySet.isDayTrade(strategy)\n\t                tradeType = '當沖' if is_day_trade else '非當沖'\n", "                isTransfer = (\n\t                    actionType == 'Close') and 'isDue' in data and data['isDue']\n\t                if isTransfer:\n\t                    func = self.StrategySet.transfer_position\n\t                else:\n\t                    func = self.StrategySet.mapFunction(\n\t                        actionType, tradeType, strategy)\n\t                if data:\n\t                    inputs.update(data)\n\t                actionInfo = func(\n", "                    inputs=inputs,\n\t                    kbars=self.KBars,\n\t                    Quotes=self.Quotes,\n\t                    pct_chg_DowJones=self.pct_chg_DowJones\n\t                )\n\t                if actionInfo.position:\n\t                    if isTransfer:\n\t                        new_target = f'{target[:3]}{self.GetDueMonth(TODAY)}'\n\t                        self.futures_transferred.update({new_target: quantity})\n\t                    infos = dict(\n", "                        action_type=actionType,\n\t                        action=action,\n\t                        target=target,\n\t                        quantity=quantity,\n\t                        octype=octype,\n\t                        pos_target=actionInfo.position,\n\t                        pos_balance=pos_balance,\n\t                        reason=actionInfo.msg\n\t                    )\n\t                    self._log_and_notify(actionInfo.msg)\n", "                    return self.OrderInfo(**infos)\n\t        return self.OrderInfo(target=target)\n\t    def _place_order(self, content: namedtuple, market='Stocks'):\n\t        logging.debug(f'【content: {content}】')\n\t        target = content.target\n\t        contract = get_contract(target)\n\t        if target in self.BidAsk:\n\t            quantity = self.get_sell_quantity(content, market)\n\t            price_type = 'MKT'\n\t            price = 0\n", "            order_lot = 'IntradayOdd' if content.quantity < 1000 and market == 'Stocks' else 'Common'\n\t            if market == 'Stocks':\n\t                bid_ask = self.BidAsk[target]\n\t                bid_ask = bid_ask.bid_price if content.action == 'Sell' else bid_ask.ask_price\n\t                # 零股交易\n\t                if 0 < content.quantity < 1000:\n\t                    price_type = 'LMT'\n\t                    price = bid_ask[1]\n\t                # 整股交易\n\t                else:\n", "                    if datetime.now() >= TTry:\n\t                        price_type = 'LMT'\n\t                        price = bid_ask[1]\n\t                    elif target in self.punish_list:\n\t                        price_type = 'LMT'\n\t                        price = bid_ask[3]\n\t                    elif contract.exchange == 'OES':\n\t                        price_type = 'LMT'\n\t                        price = self.Quotes.NowTargets[target]['price']\n\t                log_msg = f\"【{target}下單內容: price={price}, quantity={quantity}, action={content.action}, price_type={price_type}, order_cond={content.order_cond}, order_lot={order_lot}】\"\n", "            else:\n\t                log_msg = f\"【{target}下單內容: price={price}, quantity={quantity}, action={content.action}, price_type={price_type}, order_cond={content.octype}, order_lot={order_lot}】\"\n\t            # 下單\n\t            logging.debug(log_msg)\n\t            if self.simulation and market == 'Stocks':\n\t                price = self.Quotes.NowTargets[target]['price']\n\t                quantity *= 1000\n\t                leverage = self.check_leverage(target, content.order_cond)\n\t                if content.action == 'Sell':\n\t                    self.stock_sold.append(target)\n", "                    cost_price = self.get_cost_price(\n\t                        target, price, content.order_cond)\n\t                    amount = -(price - cost_price*leverage) * \\\n\t                        quantity*(1 - FEE_RATE)\n\t                else:\n\t                    self.stock_bought.append(target)\n\t                    amount = self.get_stock_amount(\n\t                        target, price, quantity, content.order_cond)\n\t                sign = -1 if content.action == 'Sell' else 1\n\t                order_data = {\n", "                    'Time': datetime.now(),\n\t                    'market': market,\n\t                    'code': target,\n\t                    'action': content.action,\n\t                    'price': price*sign,\n\t                    'quantity': quantity,\n\t                    'amount': amount,\n\t                    'order_cond': content.order_cond if market == 'Stocks' else 'Cash',\n\t                    'order_lot': order_lot,\n\t                    'leverage': leverage,\n", "                    'account_id': f'simulate-{self.ACCOUNT_NAME}',\n\t                    'msg': content.reason\n\t                }\n\t                self.appendOrder(order_data)\n\t                # 更新監控庫存\n\t                order_data.update({\n\t                    'position': content.pos_target,\n\t                    'yd_quantity': 0,\n\t                    'bst': datetime.now(),\n\t                    'cost_price': abs(order_data['price'])\n", "                })\n\t                self.update_monitor_lists(content.action, order_data)\n\t                logging.debug('Place simulate order complete.')\n\t                notifier.post(log_msg, msgType='Order')\n\t            elif self.simulation and market == 'Futures':\n\t                price = self.Quotes.NowTargets[target]['price']\n\t                sign = -1 if content.action == 'Sell' else 1\n\t                order_data = {\n\t                    'Time': datetime.now(),\n\t                    'market': market,\n", "                    'code': target,\n\t                    'action': content.action,\n\t                    'price': price*sign,\n\t                    'quantity': quantity,\n\t                    'amount': self.get_open_margin(target, quantity)*sign,\n\t                    'op_type': content.octype,\n\t                    'account_id': f'simulate-{self.ACCOUNT_NAME}',\n\t                    'msg': content.reason\n\t                }\n\t                self.appendOrder(order_data)\n", "                self._update_futures_deal_list(target, content.octype)\n\t                # 更新監控庫存\n\t                bsh = self.Quotes.AllTargets[target]['price']\n\t                bsh = max(bsh) if bsh else price\n\t                order_data.update({\n\t                    'symbol': target,\n\t                    'cost_price': price,\n\t                    'bsh': bsh,\n\t                    'bst': datetime.now(),\n\t                    'position': content.pos_target,\n", "                    'order': {\n\t                        'quantity': quantity,\n\t                        'action': content.action\n\t                    }\n\t                })\n\t                self.update_monitor_lists(content.octype, order_data)\n\t                logging.debug('Place simulate order complete.')\n\t                notifier.post(log_msg, msgType='Order')\n\t            else:\n\t                # #ff0000 批次下單的張數 (股票>1000股的單位為【張】) #ff0000\n", "                q = 5 if order_lot == 'Common' else quantity\n\t                if market == 'Stocks':\n\t                    target_ = self.desposal_money\n\t                else:\n\t                    target_ = self.desposal_margin\n\t                enough_to_place = self.checkEnoughToPlace(market, target_)\n\t                while quantity > 0 and enough_to_place:\n\t                    order = API.Order(\n\t                        # 價格 (市價單 = 0)\n\t                        price=price,\n", "                        # 數量 (最小1張; 零股最小50股 or 全部庫存)\n\t                        quantity=min(quantity, q),\n\t                        # 動作: 買進/賣出\n\t                        action=content.action,\n\t                        # 市價單/限價單\n\t                        price_type=price_type,\n\t                        # ROD:當天都可成交\n\t                        order_type=constant.OrderType.ROD,\n\t                        # 委託類型: 現股/融資\n\t                        order_cond=content.order_cond if market == 'Stocks' else 'Cash',\n", "                        # 整張或零股\n\t                        order_lot=order_lot,\n\t                        # {Auto, New, Cover, DayTrade}(自動、新倉、平倉、當沖)\n\t                        octype='Auto' if market == 'Stocks' else content.octype,\n\t                        account=API.stock_account if market == 'Stocks' else API.futopt_account,\n\t                        # 先賣後買: True, False\n\t                        daytrade_short=content.daytrade_short,\n\t                    )\n\t                    result = API.place_order(contract, order)\n\t                    self.check_order_status(result)\n", "                    quantity -= q\n\t    def get_securityInfo(self, market='Stocks'):\n\t        '''取得證券庫存清單'''\n\t        if self.simulation:\n\t            df_default = {\n\t                'Stocks': self.df_securityInfo,\n\t                'Futures': self.df_futuresInfo\n\t            }\n\t            try:\n\t                if db.HAS_DB and market == 'Stocks':\n", "                    df = db.query(\n\t                        SecurityInfoStocks,\n\t                        SecurityInfoStocks.account == self.ACCOUNT_NAME\n\t                    )\n\t                elif db.HAS_DB and market == 'Futures':\n\t                    df = db.query(\n\t                        SecurityInfoFutures,\n\t                        SecurityInfoFutures.Account == self.ACCOUNT_NAME\n\t                    )\n\t                else:\n", "                    df = file_handler.read_table(\n\t                        f'{PATH}/stock_pool/simulation_{market.lower()}_{self.ACCOUNT_NAME}.pkl',\n\t                        df_default=df_default[market]\n\t                    )\n\t            except:\n\t                df = df_default[market]\n\t            df['account_id'] = 'simulate'\n\t        else:\n\t            if market == 'Stocks':\n\t                df = self.securityInfo()\n", "                return df[df.code.apply(len) == 4]\n\t            df = self.get_openpositions()\n\t        return df\n\t    def get_margin_table(self):\n\t        '''取得保證金清單'''\n\t        df = self.read_table('./lib/indexMarging.csv').reset_index()\n\t        df.columns = list(df.iloc[0, :])\n\t        df = df.iloc[1:, :-2]\n\t        df.原始保證金 = df.原始保證金.astype(int)\n\t        codes = [[f.code, f.symbol, f.name]\n", "                 for m in API.Contracts.Futures for f in m]\n\t        codes = pd.DataFrame(codes, columns=['code', 'symbol', 'name'])\n\t        codes = codes.set_index('name').symbol.to_dict()\n\t        month = str((datetime.now() + timedelta(days=30)).month).zfill(2)\n\t        df['code'] = (df.商品別 + month).map(codes)\n\t        return df.dropna().set_index('code')\n\t    def get_stock_pool(self):\n\t        '''\n\t        取得股票選股池\n\t        pools = {\n", "            'stockid':'strategy',\n\t        }\n\t        '''\n\t        pools = {}\n\t        df = picker.get_selection_files()\n\t        if df.shape[0]:\n\t            # 排除不交易的股票\n\t            # ### 全額交割股不買\n\t            day_filter_out = crawler2.get_CashSettle()\n\t            df = df[~df.code.isin(day_filter_out.股票代碼.values)]\n", "            df = df[~df.code.isin(self.FILTER_OUT)]\n\t            # 排除高價股\n\t            df = df[df.Close <= self.PRICE_THRESHOLD]\n\t            df = df.sort_values('Close')\n\t            # 建立族群清單\n\t            n_category = df.groupby('category').code.count().to_dict()\n\t            df['n_category'] = df.category.map(n_category)\n\t            self.n_categories = (\n\t                df.sort_values('n_category', ascending=False)\n\t                .set_index('code').n_category.to_dict())\n", "            # 族群清單按照策略權重 & pc_ratio 決定\n\t            # 權重大的先加入，避免重複\n\t            if self.StrategySet.pc_ratio >= 115:\n\t                sort_order = ['long_weight', 'short_weight']\n\t            else:\n\t                sort_order = ['short_weight', 'long_weight']\n\t            strategies = self.StrategySet.STRATEGIES.sort_values(\n\t                sort_order, ascending=False).name.to_list()\n\t            for s in strategies:\n\t                if s in df.Strategy.values and s in self.STRATEGY_STOCK:\n", "                    stockids = df[df.Strategy == s].code\n\t                    pools.update({stock: s for stock in stockids})\n\t                    df = df[~df.code.isin(stockids)]\n\t        return pools\n\t    def get_futures_pool(self):\n\t        '''取得期權目標商品清單'''\n\t        pools = {}\n\t        due_year_month = self.GetDueMonth(TODAY)\n\t        indexes = {\n\t            '放空小台': [f'MXF{due_year_month}'],\n", "            '做多小台': [f'MXF{due_year_month}'],\n\t            '放空大台': [f'TXF{due_year_month}'],\n\t            '做多大台': [f'TXF{due_year_month}'],\n\t        }\n\t        pools.update({\n\t            symbol: st for st in self.STRATEGY_FUTURES for symbol in indexes[st]\n\t        })\n\t        return pools\n\t    def get_quantity(self, target: str, strategy: str, order_cond: str):\n\t        '''計算進場股數'''\n", "        if self.BUY_UNIT_TYPE == 'constant':\n\t            return 1000*self.BUY_UNIT\n\t        quantityFunc = self.StrategySet.mapQuantities(strategy)\n\t        inputs = self.Quotes.NowTargets[target]\n\t        quantity, quantity_limit = quantityFunc(\n\t            inputs=inputs, kbars=self.KBars)\n\t        leverage = self.check_leverage(target, order_cond)\n\t        quantity = int(min(quantity, quantity_limit)/(1 - leverage))\n\t        quantity = min(quantity, 499)\n\t        contract = get_contract(target)\n", "        if order_cond == 'MarginTrading':\n\t            quantity = min(contract.margin_trading_balance, quantity)\n\t        elif order_cond == 'ShortSelling':\n\t            quantity = min(contract.short_selling_balance, quantity)\n\t        return 1000*quantity\n\t    def get_stock_amount(self, target: str, price: float, quantity: int, mode='long'):\n\t        '''計算股票委託金額'''\n\t        leverage = self.check_leverage(target, mode)\n\t        fee = max(price*quantity*FEE_RATE, 20)\n\t        return price*quantity*(1 - leverage) + fee\n", "    def get_open_slot(self, target: str, strategy: str):\n\t        '''計算買進口數'''\n\t        if self.N_SLOT_TYPE == 'constant':\n\t            return self.N_SLOT\n\t        quantityFunc = self.StrategySet.mapQuantities(strategy)\n\t        inputs = self.Quotes.NowTargets[target]\n\t        slot, quantity_limit = quantityFunc(inputs=inputs, kbars=self.KBars)\n\t        slot = int(min(slot, quantity_limit))\n\t        slot = min(slot, 499)\n\t        return slot\n", "    def get_open_margin(self, target: str, quantity: int):\n\t        '''計算期貨保證金額'''\n\t        if target in self.Quotes.NowTargets and self.margin_table and target in self.margin_table:\n\t            fee = 100\n\t            return self.margin_table[target]*quantity + fee\n\t        return 0\n\t    def get_pct_chg_DowJones(self):\n\t        '''取得道瓊指數前一天的漲跌幅'''\n\t        start = self._strf_timedelta(TODAY, 30)\n\t        dj = crawler2.DowJones(start, TODAY_STR)\n", "        if 'c' in dj and len(dj['c']):\n\t            dj = dj['c']\n\t            return 100*round(dj[0]/dj[1] - 1, 4)\n\t        return 0\n\t    def get_cost_price(self, target: str, price: float, order_cond: str):\n\t        '''取得股票的進場價'''\n\t        if order_cond == 'ShortSelling':\n\t            return price\n\t        cost_price = self.stocks.set_index('code').cost_price.to_dict()\n\t        if target in cost_price:\n", "            return cost_price[target]\n\t        return 0\n\t    def check_leverage(self, target: str, mode='long'):\n\t        '''取得個股的融資/融券成數'''\n\t        if mode in ['long', 'MarginTrading'] and target in self.LEVERAGE_LONG:\n\t            return self.LEVERAGE_LONG[target]\n\t        elif mode in ['short', 'ShortSelling'] and target in self.LEVERAGE_SHORT:\n\t            return 1 - self.LEVERAGE_SHORT[target]\n\t        return 0\n\t    def check_order_cond(self, target: str, mode='long'):\n", "        '''檢查個股可否融資'''\n\t        contract = get_contract(target)\n\t        if mode == 'long':\n\t            if self.ORDER_COND1 != 'Cash' and (self.LEVERAGE_LONG[target] == 0 or contract.margin_trading_balance == 0):\n\t                return 'Cash'\n\t            return self.ORDER_COND1\n\t        else:\n\t            if self.ORDER_COND2 != 'Cash' and (self.LEVERAGE_SHORT[target] == 1 or contract.short_selling_balance == 0):\n\t                return 'Cash'\n\t            return self.ORDER_COND2\n", "    def check_enough(self, target: str, quantity: int, mode='long'):\n\t        '''計算可買進的股票數量 & 金額'''\n\t        if target not in self.Quotes.NowTargets:\n\t            return False\n\t        # 更新可買進的股票額度 TODO: buy_deals, sell_deals會合計多空股票數，使quota1, quota2無法精準\n\t        buy_deals = len([s for s in self.stock_bought if len(s) == 4])\n\t        sell_deals = len([s for s in self.stock_sold if len(s) == 4])\n\t        quota1 = abs(self.N_LIMIT_LS) - self.n_stocks_long - \\\n\t            buy_deals + sell_deals\n\t        quota2 = abs(self.N_LIMIT_SS) - self.n_stocks_short + \\\n", "            buy_deals - sell_deals\n\t        # 更新已委託金額\n\t        df = self.filterOrderTable('Stocks')\n\t        df = df[df.code.apply(len) == 4]\n\t        amount1 = df.amount.sum()\n\t        amount2 = df[df.price > 0].amount.abs().sum()\n\t        amount3 = df[df.price < 0].amount.abs().sum()\n\t        cost_price = self.Quotes.NowTargets[target]['price']\n\t        target_amount = self.get_stock_amount(\n\t            target, cost_price, quantity, mode)\n", "        # under day limit condition\n\t        # 1. 不可超過可交割金額\n\t        # 2. 不可大於帳戶可委託金額上限\n\t        # 3. 不可超過股票數上限\n\t        if mode == 'long':\n\t            return (\n\t                (amount1 + target_amount <= self.desposal_money) &\n\t                (amount2 + target_amount <= self.POSITION_LIMIT_LONG) &\n\t                (quota1 > 0)\n\t            )\n", "        return (\n\t            (amount1 + target_amount <= self.desposal_money) &\n\t            (amount2 + target_amount <= self.POSITION_LIMIT_LONG) &\n\t            # 4. 不可超過可信用交易額度上限\n\t            (amount3 + target_amount <= self.POSITION_LIMIT_SHORT) &\n\t            (quota2 > 0)\n\t        )\n\t    def _check_enough_open(self, target: str, quantity: int):\n\t        '''計算可開倉的期貨口數 & 金額'''\n\t        # 更新可開倉的期貨標的數\n", "        open_deals = len(self.futures_opened)\n\t        close_deals = len(self.futures_closed)\n\t        quota = abs(self.N_FUTURES_LIMIT) - \\\n\t            self.n_futures - open_deals + close_deals\n\t        # 更新已委託金額\n\t        df = self.filterOrderTable('Futures')\n\t        amount1 = df.amount.sum()\n\t        amount2 = df[df.price > 0].amount.sum()\n\t        # under day limit condition\n\t        # 1. 不可超過可交割保證金\n", "        # 2. 不可大於帳戶可委託保證金上限\n\t        # 3. 不可超過股票數上限\n\t        target_amount = self.get_open_margin(target, quantity)\n\t        return (\n\t            (amount1 + target_amount <= self.desposal_margin) &\n\t            (amount2 + target_amount <= self.MARGIN_LIMIT) &\n\t            (quota > 0)\n\t        )\n\t    def is_not_trade_day(self, now: datetime):\n\t        '''檢查是否為非交易時段'''\n", "        is_holiday = TODAY in holidays\n\t        if self.can_futures:\n\t            close1 = (\n\t                (now > TimeEndFuturesNight) and\n\t                (now < TimeStartFuturesDay + timedelta(days=1))\n\t            )\n\t            close2 = now > TimeEndFuturesDay and now < TimeStartFuturesNight\n\t            if self.TRADING_PERIOD != 'Day':\n\t                # trader only closes during 05:00 ~ 08:45\n\t                close2 = False\n", "            return is_holiday or close1 or close2\n\t        return is_holiday or not (now <= TEnd)\n\t    def remove_stock_monitor_list(self, target: str):\n\t        logging.debug(f'Remove【{target}】from stocks_to_monitor.')\n\t        self.stocks_to_monitor.pop(target, None)\n\t        if target in self.stocks.code.values:\n\t            logging.debug(f'Remove【{target}】from self.stocks.')\n\t            self.stocks = self.stocks[self.stocks.code != target]\n\t            if self.simulation and db.HAS_DB:\n\t                db.delete(\n", "                    SecurityInfoStocks,\n\t                    SecurityInfoStocks.code == target,\n\t                    SecurityInfoStocks.account == self.ACCOUNT_NAME\n\t                )\n\t    def remove_futures_monitor_list(self, target: str):\n\t        '''Remove futures from futures_to_monitor'''\n\t        logging.debug(f'Remove【{target}】from futures_to_monitor.')\n\t        self.futures_to_monitor.pop(target, None)\n\t        if target in self.futures.CodeName.values:\n\t            logging.debug(f'Remove【{target}】from self.futures.')\n", "            self.futures = self.futures[self.futures.CodeName != target]\n\t            if self.simulation and db.HAS_DB:\n\t                db.delete(\n\t                    SecurityInfoFutures,\n\t                    SecurityInfoFutures.CodeName == target,\n\t                    SecurityInfoFutures.Account == self.ACCOUNT_NAME\n\t                )\n\t    def run(self):\n\t        '''執行自動交易'''\n\t        strategy_s, all_stocks = self.init_stocks()\n", "        strategy_f, all_futures = self.init_futures()\n\t        usage = round(API.usage().bytes/2**20, 2)\n\t        self.subscribe_all(all_stocks+all_futures)\n\t        logging.info(f\"Current data usage: {usage}\")\n\t        logging.info(f\"Today's punish lis: {self.punish_list}\")\n\t        logging.info(f\"Stocks Ex-dividend: {self.StrategySet.dividends}\")\n\t        logging.info(f\"Previous Put/Call ratio: {self.StrategySet.pc_ratio}\")\n\t        logging.info(f'Start to monitor, basic settings:')\n\t        logging.info(f'Mode:{self.MODE}, Strategy: {self.STRATEGY_STOCK}')\n\t        logging.info(f'[Stock Strategy] {strategy_s}')\n", "        logging.info(f'[Stock Position] Long: {self.n_stocks_long}')\n\t        logging.info(f'[Stock Position] Short: {self.n_stocks_short}')\n\t        logging.info(f'[Stock Portfolio Limit] Long: {self.N_LIMIT_LS}')\n\t        logging.info(f'[Stock Portfolio Limit] Short: {self.N_LIMIT_SS}')\n\t        logging.info(\n\t            f'[Stock Position Limit] Long: {self.POSITION_LIMIT_LONG}')\n\t        logging.info(\n\t            f'[Stock Position Limit] Short: {self.POSITION_LIMIT_SHORT}')\n\t        logging.info(f'[Futures Strategy] {strategy_f}')\n\t        logging.info(f'[Futures position] {self.n_futures}')\n", "        logging.info(f'[Futures portfolio Limit] {self.N_FUTURES_LIMIT}')\n\t        text = f\"\\n【開始監控】{self.ACCOUNT_NAME} 啟動完成({__version__})\"\n\t        text += f\"\\n【操盤模式】{self.MODE}\\n【操盤策略】{self.STRATEGY_STOCK}\"\n\t        text += f\"\\n【前日行情】Put/Call: {self.StrategySet.pc_ratio}\"\n\t        text += f\"\\n【美股行情】道瓊({self.pct_chg_DowJones}%)\"\n\t        text += f\"\\n【數據用量】{usage}MB\"\n\t        notifier.post(text, msgType='Monitor')\n\t        # 開始監控\n\t        while True:\n\t            now = datetime.now()\n", "            if self.is_not_trade_day(now):\n\t                logging.info('Non-trading time, stop monitoring')\n\t                self.updateKBars('2T')\n\t                self.updateKBars('5T')\n\t                self.updateKBars('15T')\n\t                self.updateKBars('30T')\n\t                self.updateKBars('60T')\n\t                break\n\t            elif all(x == 0 for x in [\n\t                self.n_stocks_long, self.n_stocks_short,\n", "                self.N_LIMIT_LS, self.N_LIMIT_SS,\n\t                self.N_FUTURES_LIMIT, self.n_futures\n\t            ]):\n\t                self._log_and_notify(f\"【停止監控】{self.ACCOUNT_NAME} 無可監控清單\")\n\t                break\n\t            # update K-bar data\n\t            is_trading_time = (\n\t                (self.can_futures and now > TimeStartFuturesDay + timedelta(seconds=30)) or\n\t                (self.can_stock and now > TimeStartStock + timedelta(seconds=30))\n\t            )\n", "            if is_trading_time and now.second < 5:\n\t                self._update_K1(self.StrategySet.dividends, quotes=self.Quotes)\n\t                self._set_target_quote_default(all_stocks+all_futures)\n\t                self._set_index_quote_default()\n\t                self.StrategySet.update_indicators(now, self.KBars)\n\t                if now.minute % 2 == 0:\n\t                    self.updateKBars('2T')\n\t                if now.minute % 5 == 0:\n\t                    self.updateKBars('5T')\n\t                    self.balance(mode='debug')  # 防止斷線用 TODO:待永豐更新後刪除\n", "                if now.minute % 15 == 0:\n\t                    self.updateKBars('15T')\n\t                if now.minute % 30 == 0:\n\t                    self.updateKBars('30T')\n\t                if now.minute == 0:\n\t                    self.updateKBars('60T')\n\t            # TODO: merge stocks_to_monitor & futures_to_monitor\n\t            for target in list(self.stocks_to_monitor):\n\t                order = self.monitor_stocks(target, strategy_s)\n\t                if order.pos_target:\n", "                    self._place_order(order, market='Stocks')\n\t                    self._update_position(order, strategy_s)\n\t            for target in list(self.futures_to_monitor):\n\t                order = self.monitor_futures(target, strategy_f)\n\t                if order.pos_target:\n\t                    self._place_order(order, market='Futures')\n\t                    self._update_position(order, strategy_f)\n\t            time.sleep(max(5 - (datetime.now() - now).total_seconds(), 0))\n\t        time.sleep(10)\n\t        self.unsubscribe_all(all_stocks+all_futures)\n", "    def simulator_update_securityInfo(self, df: pd.DataFrame, table):\n\t        market = 'stocks' if 'stocks' in table.__tablename__ else 'futures'\n\t        if db.HAS_DB:\n\t            if market == 'stocks':\n\t                match_account = table.account == self.ACCOUNT_NAME\n\t                codes = db.query(table.code, match_account).code.values\n\t                tb = df[~df.code.isin(codes)]\n\t                update_values = df[df.code.isin(codes)].set_index('code')\n\t            else:\n\t                match_account = table.Account == self.ACCOUNT_NAME\n", "                codes = db.query(table.Code, match_account).Code.values\n\t                tb = df[~df.Code.isin(codes)]\n\t                update_values = df[df.Code.isin(codes)].set_index('Code')\n\t            # add new stocks\n\t            db.dataframe_to_DB(tb, table)\n\t            # update in-stocks\n\t            update_values = update_values.to_dict('index')\n\t            for target, values in update_values.items():\n\t                if market == 'stocks':\n\t                    condition = table.code == target, match_account\n", "                else:\n\t                    condition = table.Code == target, match_account\n\t                db.update(table, values, *condition)\n\t        else:\n\t            self.save_table(\n\t                df=df,\n\t                filename=f'{PATH}/stock_pool/simulation_{market}_{self.ACCOUNT_NAME}.pkl'\n\t            )\n\t    def __save_simulate_securityInfo(self):\n\t        '''儲存模擬交易模式下的股票庫存表'''\n", "        if self.simulation:\n\t            # 儲存庫存\n\t            logging.debug(f'stocks_to_monitor: {self.stocks_to_monitor}')\n\t            logging.debug(\n\t                f'stocks shape: {self.stocks.shape}; watchlist shape: {self.watchlist.shape}')\n\t            df = {k: v for k, v in self.stocks_to_monitor.items() if v}\n\t            df = pd.DataFrame(df).T\n\t            if df.shape[0]:\n\t                df = df[df.account_id == f'simulate-{self.ACCOUNT_NAME}']\n\t                df = df.sort_values('code').reset_index()\n", "                df['last_price'] = df.code.map(\n\t                    {s: self.Quotes.NowTargets[s]['price'] for s in df.code})\n\t                df['pnl'] = df.action.apply(lambda x: 1 if x == 'Buy' else -1)\n\t                df['pnl'] = df.pnl*(df.last_price - df.cost_price)*df.quantity\n\t                df.yd_quantity = df.quantity\n\t                df['account'] = self.ACCOUNT_NAME\n\t                df = df[self.df_securityInfo.columns]\n\t            else:\n\t                df = self.df_securityInfo\n\t            logging.debug(\n", "                f'stocks shape: {df.shape}; watchlist shape: {self.watchlist.shape}')\n\t            if df.shape[0]:\n\t                self.simulator_update_securityInfo(df, SecurityInfoStocks)\n\t    def __save_simulate_futuresInfo(self):\n\t        '''儲存模擬交易模式下的期貨庫存表'''\n\t        if self.simulation:\n\t            # 儲存庫存\n\t            logging.debug(f'futures_to_monitor: {self.futures_to_monitor}')\n\t            df = {k: v for k, v in self.futures_to_monitor.items() if v}\n\t            df = pd.DataFrame(df).T\n", "            if df.shape[0]:\n\t                df = df[df.account_id == f'simulate-{self.ACCOUNT_NAME}']\n\t                df = df.reset_index(drop=True)\n\t                df = df.rename(columns={\n\t                    'account_id': 'Account',\n\t                    'market': 'Market',\n\t                    'bst': 'Date',\n\t                    'symbol': 'CodeName',\n\t                    'action': 'OrderBS',\n\t                    'quantity': 'Volume',\n", "                    'cost_price': 'ContractAverPrice',\n\t                    'price': 'RealPrice',\n\t                })\n\t                df['Code'] = df.CodeName.apply(lambda x: get_contract(x).code)\n\t                df.Account = self.ACCOUNT_NAME\n\t                for c in self.df_futuresInfo.columns:\n\t                    if c not in df.columns:\n\t                        if c in [\n\t                            'ContractAverPrice', 'SettlePrice',\n\t                            'RealPrice', 'FlowProfitLoss',\n", "                            'SettleProfitLoss', 'OTAMT', 'MTAMT'\n\t                        ]:\n\t                            df[c] = 0\n\t                        else:\n\t                            df[c] = ''\n\t                df = df[self.df_futuresInfo.columns]\n\t            else:\n\t                df = self.df_futuresInfo\n\t            if df.shape[0]:\n\t                self.simulator_update_securityInfo(df, SecurityInfoFutures)\n", "    def output_files(self):\n\t        '''停止交易時，輸出庫存資料 & 交易明細'''\n\t        if 'position' in self.stocks.columns and not self.simulation:\n\t            codeList = self.get_securityInfo('Stocks').code.to_list()\n\t            self.update_watchlist(codeList)\n\t        self.save_watchlist(self.watchlist)\n\t        self.output_statement(\n\t            f'{PATH}/stock_pool/statement_{self.ACCOUNT_NAME}.csv')\n\t        if (datetime.now().weekday() not in [5, 6]):\n\t            for freq, df in self.KBars.items():\n", "                if freq != '1D':\n\t                    filename = f'{PATH}/Kbars/k{freq[:-1]}min_{self.ACCOUNT_NAME}.csv'\n\t                    self.save_table(df, filename)\n\t        if self.can_stock:\n\t            self.__save_simulate_securityInfo()\n\t        if self.can_futures:\n\t            self.__save_simulate_futuresInfo()\n\t        time.sleep(5)\n"]}
{"filename": "trader/__init__.py", "chunked_list": ["from concurrent.futures import ThreadPoolExecutor\n\tfrom .config import PATH\n\tfrom .utils.file import FileHandler\n\tfrom .utils.select import SelectStock\n\tfrom .utils.kbar import TickDataProcesser\n\tfrom .utils.notify import Notification\n\tfrom .utils.crawler import CrawlStockData, CrawlFromHTML\n\t__version__ = '1.9.21'\n\texecutor = ThreadPoolExecutor(max_workers=5)\n\tfile_handler = FileHandler()\n", "notifier = Notification()\n\tpicker = SelectStock()\n\tcrawler1 = CrawlStockData()\n\tcrawler2 = CrawlFromHTML()\n\ttdp = TickDataProcesser()\n\tfor f in [PATH, './logs']:\n\t    file_handler.create_folder(f)\n\tfor f in ['daily_info', 'Kbars', 'ticks', 'selections', 'stock_pool']:\n\t    file_handler.create_folder(f'{PATH}/{f}')\n\tfor f in ['1D', '60T', '30T', '1T']:\n", "    file_handler.create_folder(f'{PATH}/Kbars/{f}')\n\tfile_handler.create_folder(f'{PATH}/ticks/stocks')\n\tfile_handler.create_folder(f'{PATH}/ticks/futures')\n\tfile_handler.create_folder(f'{PATH}/selections/history')\n"]}
{"filename": "trader/utils/crawler.py", "chunked_list": ["import io\n\timport os\n\timport re\n\timport time\n\timport json\n\timport logging\n\timport zipfile\n\timport requests\n\timport numpy as np\n\timport pandas as pd\n", "from typing import Union\n\tfrom sqlalchemy import text\n\tfrom bs4 import BeautifulSoup\n\tfrom datetime import datetime, timedelta\n\tfrom ..config import API, PATH, TODAY_STR, TODAY\n\tfrom . import progress_bar, create_queue\n\tfrom .kbar import KBarTool\n\tfrom .time import TimeTool\n\tfrom .file import FileHandler\n\tfrom .database import db, KBarTables\n", "from .database.tables import KBarData1T, SecurityList, PutCallRatioList, ExDividendTable\n\tdef readStockList(markets=['OTC', 'TSE']):\n\t    if db.HAS_DB:\n\t        df = db.query(\n\t            SecurityList,\n\t            SecurityList.exchange.in_(markets)\n\t        )\n\t    else:\n\t        df = FileHandler().read_table(\n\t            f'{PATH}/selections/stock_list.xlsx',\n", "            df_default=pd.DataFrame(columns=['code', 'exchange'])\n\t        )\n\t        df.code = df.code.astype(int).astype(str)\n\t        df = df[df.exchange.isin(markets)]\n\t    return df\n\tclass CrawlStockData(FileHandler):\n\t    def __init__(self, folder_path: str = f'{PATH}/Kbars/1T/{TODAY_STR}', scale='1D'):\n\t        self.folder_path = folder_path\n\t        self.timetool = TimeTool()\n\t        self.kbartool = KBarTool()\n", "        self.filename = 'company_stock_data'\n\t        self.tempFile = f'{self.folder_path}/crawled_list.pkl'\n\t        self.scale = scale\n\t        self.StockData = []\n\t    def get_security_list(self, stock_only: bool = True):\n\t        '''\n\t        自 Shioaji 取得股票清單\n\t        只保留普通股股票且不需要權證: stock_only = True \n\t        '''\n\t        stock_list = [\n", "            {**stock} for exchange in API.Contracts.Stocks for stock in exchange]\n\t        df = pd.DataFrame(stock_list)\n\t        df = df[(df.update_date == df.update_date.max())]\n\t        if stock_only:\n\t            df.update_date = pd.to_datetime(df.update_date)\n\t            df = df[\n\t                ~(df.category.isin(['00', '  '])) & (df.code.apply(len) == 4)]\n\t        return df\n\t    def export_security_list(self, df: pd.DataFrame):\n\t        '''Export security data either to local or to DB'''\n", "        if db.HAS_DB:\n\t            codes = db.query(SecurityList.code).code.values\n\t            # add new data\n\t            tb = df[~df.code.isin(codes)].copy()\n\t            db.dataframe_to_DB(tb, SecurityList)\n\t            # delete old data\n\t            code1 = list(set(codes) - set(df.code))\n\t            condition = SecurityList.code.in_(code1)\n\t            db.delete(SecurityList, condition)\n\t        else:\n", "            self.save_table(df, f'{PATH}/selections/stock_list.xlsx')\n\t    def export_kbar_data(self, df: pd.DataFrame, scale: str):\n\t        '''Export kbar data either to local or to DB'''\n\t        if db.HAS_DB:\n\t            db.dataframe_to_DB(df, KBarTables[scale])\n\t        df.Volume = df.Volume.astype('int32')\n\t        filename = f'{PATH}/Kbars/{scale}/{TODAY_STR}-stocks-{scale}.pkl'\n\t        self.save_table(df, filename)\n\t        return df\n\t    def _load_data_into_queue(self, stockids: list):\n", "        '''創建股票待爬清單(queue)'''\n\t        # get stock id list\n\t        if type(stockids) == str and stockids == 'all':\n\t            stockids = readStockList().code.values\n\t        elif type(stockids) == str:\n\t            stockids = stockids.split(',')\n\t        logging.info(f\"Target list size: {len(stockids)}\")\n\t        # get crawled list\n\t        df_default = pd.DataFrame({'stockid': []})\n\t        self.crawled_list = self.read_table(self.tempFile, df_default)\n", "        logging.info(f\"Crawled size: {self.crawled_list.shape[0]}\")\n\t        return create_queue(stockids, self.crawled_list.stockid.values)\n\t    def crawl_from_sinopac(self, stockids: Union[str, list] = 'all', update=False, start=None, end=None):\n\t        self.create_folder(self.folder_path)\n\t        q = self._load_data_into_queue(stockids)\n\t        if isinstance(stockids, str) and stockids == 'all':\n\t            q.put('TSE001')\n\t            q.put('OTC101')\n\t        N = q.qsize()\n\t        if not start:\n", "            if update:\n\t                if db.HAS_DB:\n\t                    dates = db.query(KBarTables[self.scale].Time)\n\t                    if dates.shape[0]:\n\t                        last_end = dates.Time.max()\n\t                    else:\n\t                        last_end = self.timetool.last_business_day()\n\t                else:\n\t                    filename = f'{PATH}/Kbars/{self.filename}_{self.scale}.pkl'\n\t                    ref = self.timetool.last_business_day()\n", "                    last_end = self.read_table(\n\t                        filename=filename,\n\t                        df_default=pd.DataFrame({'Time': [ref]})\n\t                    ).Time.max()\n\t                start = self.timetool._strf_timedelta(last_end, -1)\n\t            else:\n\t                start = '2017-01-01'\n\t        self.StockData = np.array([None]*N)\n\t        while True:\n\t            if q.empty():\n", "                os.remove(self.tempFile)\n\t                logging.info(\"Queue is deleted successfully\")\n\t                break\n\t            i = N-q.qsize()\n\t            stockid = q.get()\n\t            tStart = time.time()\n\t            try:\n\t                df = self.kbartool.tbKBar(stockid, start, end)\n\t                if df is not None:\n\t                    self.StockData[i] = df\n", "                    # back-up queue\n\t                    self.crawled_list = pd.concat([\n\t                        self.crawled_list,\n\t                        pd.DataFrame([{'stockid': stockid}])\n\t                    ])\n\t                    self.save_table(self.crawled_list, filename=self.tempFile)\n\t            except:\n\t                logging.exception(f\"Put back into queue: {stockid}\")\n\t                q.put(stockid)\n\t            progress_bar(\n", "                N,\n\t                N-q.qsize()-1,\n\t                status=f'Getting {stockid} done ({round(time.time() - tStart, 2)}s)'\n\t            )\n\t            time.sleep(0.1)\n\t    def merge_stockinfo(self):\n\t        '''\n\t        爬蟲爬下來的資料是按公司股票代號分別存成CSV檔\n\t        此程式用來將全部的公司股票資料合併成一個\n\t        '''\n", "        logging.info(\"Merge stockinfo\")\n\t        if len(self.StockData):\n\t            df = pd.concat(self.StockData)\n\t            df.Time = pd.to_datetime(df.Time)\n\t            df.name = df.name.astype(int).astype(str)\n\t            self.StockData = df\n\t        else:\n\t            df = self.read_tables_in_folder(self.folder_path, pattern='.csv')\n\t            if df.shape[0]:\n\t                if 'Time' in df.columns:\n", "                    df['Time'] = pd.to_datetime(df['Time'])\n\t                df.name = df.name.astype(int)\n\t            self.remove_files(self.folder_path, pattern='.csv')\n\t        df = df.sort_values(['name', 'Time']).reset_index(drop=True)\n\t        df = self.export_kbar_data(df, '1T')\n\t        os.rmdir(self.folder_path)\n\t    def add_new_data(self, scale: str, save=True, start=None, end=None):\n\t        '''加入新資料到舊K棒資料中'''\n\t        if isinstance(self.StockData, pd.DataFrame) and self.StockData.shape[0]:\n\t            df = self.StockData.copy()\n", "        elif db.HAS_DB:\n\t            condition1 = KBarData1T.Time >= text(\n\t                start) if start else text('1901-01-01')\n\t            condition2 = KBarData1T.Time <= text(\n\t                end) if end else text(TODAY_STR)\n\t            df = db.query(KBarData1T, condition1, condition2)\n\t        else:\n\t            folders = self.listdir(f'{PATH}/Kbars/1T')\n\t            folders = [fd for fd in folders if '.' not in fd]\n\t            if start:\n", "                folders = [fd for fd in folders if fd >= start]\n\t            if end:\n\t                folders = [fd for fd in folders if fd <= end]\n\t            N = len(folders)\n\t            df = np.array([None]*N)\n\t            for i, fd in enumerate(folders):\n\t                filename = f'{PATH}/Kbars/1T/{fd}-stock_data_1T.pkl'\n\t                tb = self.read_table(filename)\n\t                tb = tb.sort_values(['name', 'Time'])\n\t                if tb.shape[0]:\n", "                    if 'Time' in tb.columns:\n\t                        tb['Time'] = pd.to_datetime(tb['Time'])\n\t                    tb.name = tb.name.astype(int)\n\t                df[i] = tb\n\t            df = pd.concat(df)\n\t            df = df.sort_values(['name', 'Time'])\n\t            df = df.reset_index(drop=True)\n\t            df.name = df.name.astype(int).astype(str)\n\t        if scale != '1T':\n\t            logging.info(f'Converting data scale to {scale}...')\n", "            df = self.kbartool.convert_kbar(df, scale=scale).dropna()\n\t        if save:\n\t            df = self.export_kbar_data(df, scale)\n\t        return df\n\t    def merge_daily_data(self, day: datetime, scale: str, save=True):\n\t        '''\n\t        This function merges daily kbar data at the 1st trading-day of \n\t        each month\n\t        '''\n\t        if not isinstance(day, datetime):\n", "            day = pd.to_datetime(day)\n\t        last_day = self.timetool.last_business_day(day)\n\t        if last_day.month != day.month:\n\t            dir_path = f'{PATH}/Kbars/{scale}'\n\t            year_month = self.timetool.datetime_to_str(last_day)[:-3]\n\t            df = self.read_tables_in_folder(dir_path, pattern=year_month)\n\t            df = df.sort_values(['name', 'Time'])\n\t            df = df.reset_index(drop=True)\n\t            if save:\n\t                filename = f'{dir_path}/{year_month}-stocks-{scale}.pkl'\n", "                self.remove_files(dir_path, pattern=year_month)\n\t                self.save_table(df, filename)\n\tclass CrawlFromHTML(TimeTool, FileHandler):\n\t    headers = {\n\t        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n\t    }\n\t    url_pc_ratio = 'https://www.taifex.com.tw/cht/3/pcRatio'\n\t    url_ex_dividend = 'https://www.twse.com.tw/rwd/zh/exRight/TWT48U?response=csv'\n\t    url_futures_tick = 'https://www.taifex.com.tw/file/taifex/Dailydownload/DailydownloadCSV'\n\t    url_cash_settle = 'https://www.sinotrade.com.tw/Stock/Stock_3_8_3'\n", "    def above_one_url(self, pageName: str, date: str, stockid: str):\n\t        '''產生豹投資網站資料的URL'''\n\t        domain1 = 'https://www.above.one/cdn/TProStk'\n\t        domain2 = 'https://www.above.one/cdn/TProStkChips'\n\t        token = 'HVtjdOMP4f'\n\t        URLs = {\n\t            # 1. K線Header資訊\n\t            'HeaderInfo': f'{domain1}/{pageName}/HVtjdOMP4f.json?day={date}&sym={stockid}&',\n\t            # 2. 股懂券商排行榜\n\t            'SymbolWinBroker': f'{domain2}/{pageName}/{token}.json?dateRange=20&day={date}&sym={stockid}&s=ProfitLoss:d',\n", "            # 3. 分價量表\n\t            'SymbolPeriodPriceAccumVol': f'{domain2}/{pageName}/{token}.json?day={date}&pastNDays=1&sym={stockid}&',\n\t            # 4. 主力透視圖\n\t            'DayMajorPriceNetVol': f'{domain2}/{pageName}/{token}.json?day={date}&sym={stockid}&',\n\t            # 5. 外本比與投本比\n\t            'FgnItrustRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&',\n\t            # 6. 三大法人成交比\n\t            'ExternalRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n\t            # 7. 融資融券\n\t            'MarginOffsetRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n", "            # 8. 借券賣出餘額\n\t            'MgnSBLRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n\t            # 9. 區間週轉率\n\t            'RangeTurnover': f'{domain2}/{pageName}/{token}.json?ed={date}&pastNDays=5&sd=2022-07-15&sym={stockid}&',\n\t            # 10. 當日沖銷\n\t            'DayTrade': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n\t            # 11. 大戶與羊群持股\n\t            'LambsAndMajorHold': f'{domain2}/{pageName}/{token}.json?ed={date}&holdVolMajor=15&kfreq=day&sd=2021-11-23&sym={stockid}&s=Date:d',\n\t            # 12. 集保戶數\n\t            'TdccCount': f'{domain2}/{pageName}/{token}.json?day={date}&sym={stockid}&',\n", "            # 13. 大股東持股變動\n\t            'ShareBalChg': f'{domain2}/{pageName}/{token}.json?holdVolMajor=12&sym={stockid}&s=Date:d',\n\t            # 14. 券商買超統計\n\t            'BrkBuyNet': f'{domain2}/{pageName}/{token}.html?ed={date}&sd={date}&sym={stockid}&s=BuyNetVol:d&sno=0',\n\t            # 15. 券商賣超統計\n\t            'BrkSellNet': f'{domain2}/{pageName}/{token}.html?ed={date}&sd={date}&sym={stockid}&s=SellNetVol:d&sno=0',\n\t            # 16. 內部人持股比率\n\t            'ShareHoldRatio': f'{domain2}/{pageName}/{token}.json?ed=2022-08-31&sd=2015-03-31&sym={stockid}&s=YearMonth:d',\n\t            # 17. 董監大股東持股\n\t            'ShareBal': f'{domain2}/{pageName}/{token}.html?sym={stockid}&ym=2022%2F8&sno=0',\n", "            # 18. 券商買超統計\n\t            'BrkBuyNet_InputRadio': f'{domain2}/{pageName}/{token}.html?ed={date}&sd={date}&sym={stockid}&s=BuyNetVol:d&sno=0',\n\t            # 19. 股懂券商\n\t            'SymbolWinBroker_InputRadio': f'{domain2}/{pageName}/{token}.html?dateRange=20&day={date}&sym={stockid}&s=ProfitLoss:d&sno=0'\n\t        }\n\t        return URLs[pageName]\n\t    def get_leverage(self, stockid: str):\n\t        '''取得個股融資成數'''\n\t        url = f'https://www.sinotrade.com.tw/Stock/Stock_3_8_6?code={stockid}'\n\t        tb = pd.read_html(url)[-1]\n", "        if tb.shape[0] == 0:\n\t            return {'融資成數': 0, '融券成數': 100}\n\t        return tb.to_dict('records')[0]\n\t    def get_punish_list(self):\n\t        '''取得上市櫃處置股票清單(證券代號、名稱、處置起訖日)'''\n\t        def get(url, period):\n\t            df_default = pd.DataFrame(columns=['證券代號', '證券名稱', 'period'])\n\t            n = 0\n\t            while n < 10:\n\t                try:\n", "                    df = requests.get(url, headers=self.headers).text\n\t                    df = pd.read_html(df)[0]\n\t                    df = df.dropna().rename(\n\t                        columns={period: 'period'}).iloc[:-1, :]\n\t                    return df\n\t                except:\n\t                    logging.exception('Catch an exception (get_punish_list):')\n\t                    n += 1\n\t                    time.sleep(1)\n\t            return df_default\n", "        # 上市處置公告\n\t        start = self._strf_timedelta(TODAY, 30).replace('-', '')\n\t        url = f'https://www.twse.com.tw/announcement/punish?response=html&startDate={start}&endDate='\n\t        df1 = get(url, '處置起迄時間')\n\t        df1 = df1[['證券代號', '證券名稱', 'period']]\n\t        # 上櫃處置公告\n\t        start = self._strf_timedelta(TODAY, 30).replace('-', '/')\n\t        start = start.replace(start[:4], str(int(start[:4])-1911))\n\t        url = f'https://www.tpex.org.tw/web/bulletin/disposal_information/disposal_information_print.php?l=zh-tw&sd={start}'\n\t        df2 = get(url, '處置起訖時間')\n", "        df2 = df2[['證券代號', '證券名稱', 'period']]\n\t        # 合併\n\t        df = pd.concat([df1, df2])\n\t        df.period = df.period.apply(lambda x: re.findall('[\\d+/]+', x))\n\t        df.證券代號 = df.證券代號.astype(str)\n\t        df['startDate'] = df.period.apply(\n\t            lambda x: x[0].replace(x[0][:3], str(int(x[0][:3])+1911)))\n\t        df['startDate'] = pd.to_datetime(df['startDate'])\n\t        df['endDate'] = df.period.apply(\n\t            lambda x: x[1].replace(x[1][:3], str(int(x[1][:3])+1911)))\n", "        df['endDate'] = pd.to_datetime(df['endDate'])\n\t        df = df.sort_values('startDate')\n\t        df = df.drop_duplicates('證券代號', keep='last').drop('period', axis=1)\n\t        df = df[df.endDate >= TODAY_STR]\n\t        return df\n\t    def put_call_ratio(self, start: str = '', end: str = ''):\n\t        if not start:\n\t            start = TODAY_STR.replace('-', '/')\n\t        if not end:\n\t            end = TODAY_STR.replace('-', '/')\n", "        df = pd.DataFrame()\n\t        s = start\n\t        while True:\n\t            e = str(\n\t                (pd.to_datetime(s) + timedelta(days=30)).date()).replace('-', '/')\n\t            logging.info(f'Period: {s} - {e}')\n\t            url = f'{self.url_pc_ratio}?queryStartDate={s}&queryEndDate={e}'\n\t            tb = pd.read_html(url)[3]\n\t            df = pd.concat([df, tb])\n\t            if pd.to_datetime(e) >= pd.to_datetime(end):\n", "                break\n\t            s = str(\n\t                (pd.to_datetime(e) + timedelta(days=1)).date()).replace('-', '/')\n\t            time.sleep(10)\n\t        df = df.rename(columns={\n\t            '日期': 'Date',\n\t            '賣權成交量': 'PutVolume',\n\t            '買權成交量': 'CallVolume',\n\t            '買賣權成交量比率%': 'PutCallVolumeRatio',\n\t            '賣權未平倉量': 'PutOpenInterest',\n", "            '買權未平倉量': 'CallOpenInterest',\n\t            '買賣權未平倉量比率%': 'PutCallRatio'\n\t        })\n\t        df.Date = pd.to_datetime(df.Date)\n\t        return df.sort_values('Date').reset_index(drop=True)\n\t    def export_put_call_ratio(self, df: pd.DataFrame):\n\t        if db.HAS_DB:\n\t            dates = db.query(PutCallRatioList.Date).Date\n\t            db.dataframe_to_DB(df[~df.Date.isin(dates)], PutCallRatioList)\n\t        else:\n", "            filename = f'{PATH}/put_call_ratio.csv'\n\t            df_pcr = self.read_and_concat(filename, df)\n\t            self.save_table(df_pcr, f'{PATH}/put_call_ratio.csv')\n\t    def export_futures_kbar(self, df: pd.DataFrame):\n\t        if db.HAS_DB:\n\t            db.dataframe_to_DB(df, KBarData1T)\n\t        year_month = TODAY_STR[:-3]\n\t        filename = f'{PATH}/Kbars/1T/{year_month}-futures-1T.pkl'\n\t        df.Volume = df.Volume.astype('int32')\n\t        df = self.read_and_concat(filename, df)\n", "        self.save_table(df, filename)\n\t    def export_ex_dividend_list(self, df: pd.DataFrame):\n\t        if db.HAS_DB:\n\t            df_old = db.query(ExDividendTable)\n\t            df = df[df.Date > df_old.Date.max()].copy()\n\t            db.dataframe_to_DB(df, ExDividendTable)\n\t        else:\n\t            self.save_table(df, f'{PATH}/exdividends.csv')\n\t    def ex_dividend_list(self):\n\t        '''爬蟲:證交所除權息公告表'''\n", "        try:\n\t            df = pd.read_csv(\n\t                self.url_ex_dividend, encoding='cp950', on_bad_lines='skip')\n\t        except:\n\t            df = pd.read_csv(\n\t                self.url_ex_dividend, encoding='big5', on_bad_lines='skip')\n\t        df = df.reset_index()\n\t        df.columns = df.iloc[0, :]\n\t        df = df.rename(columns={\n\t            '除權除息日期': 'Date',\n", "            '股票代號': 'Code',\n\t            '名稱': 'Name',\n\t            '除權息': 'DividendType',\n\t            '無償配股率': 'DividendRate',\n\t            '現金增資配股率': 'CashCapitalRate',\n\t            '現金增資認購價': 'CashCapitalPrice',\n\t            '現金股利': 'CashDividend',\n\t            '詳細資料': 'Details',\n\t            '參考價試算': 'Reference',\n\t            '最近一次申報資料 季別/日期': 'Quarter',\n", "            '最近一次申報每股 (單位)淨值': 'NetValue',\n\t            '最近一次申報每股 (單位)盈餘': 'EPS'\n\t        })\n\t        df = df.iloc[1:, :-1]\n\t        df = df[df.Code.notnull()]\n\t        df = df[(df.Code.apply(len) == 4)]\n\t        df.Date = df.Date.apply(self.convert_date_format)\n\t        df.Date = pd.to_datetime(df.Date)\n\t        df.CashDividend = df.CashDividend.astype(float)\n\t        df.CashCapitalPrice = df.CashCapitalPrice.replace('尚未公告', -1)\n", "        return df.sort_values('Date')\n\t    def DowJones(self, start: datetime, end: datetime):\n\t        '''鉅亨網道瓊報價'''\n\t        url_dow_jones = 'https://ws.api.cnyes.com/ws/api/v1/charting/history'\n\t        start = self.date_2_mktime(start)\n\t        end = self.date_2_mktime(end)\n\t        params = f'?resolution=D&symbol=GI:DJI:INDEX&from={end}&to={start}'\n\t        try:\n\t            result = requests.get(url_dow_jones+params)\n\t            result = json.loads(result.text)\n", "            if 'data' not in result:\n\t                result['data'] = {}\n\t        except requests.exceptions.ConnectionError as e:\n\t            logging.warning(e)\n\t            result = {'data': {}}\n\t        except:\n\t            logging.exception('【Error】DowJones:')\n\t            result = {'data': {}}\n\t        return result['data']\n\t    def get_SymbolWinBroker_InputRadio(self, date: str, stockid: str):\n", "        '''股懂券商'''\n\t        url = self.above_one_url('SymbolWinBroker_InputRadio', date, stockid)\n\t        content = requests.get(url, headers=self.headers)\n\t        soup = BeautifulSoup(content.text, \"lxml\")\n\t        soup = soup.find(\n\t            \"table\", {\"class\": \"TProStkChips/SymbolWinBroker_InputRadio_css\"})\n\t        soup = soup.find_all('td')\n\t        soup = [td.text.replace('▼➀', '').replace('%', '')\n\t                for td in soup if len(td.text)]\n\t        columns = soup[:3]\n", "        soup = np.reshape(soup[3:], (int(len(soup[3:])/3), 3))\n\t        df = pd.DataFrame(soup, columns=columns)\n\t        df['損益(百萬)'] = df['損益(百萬)'].astype(float)\n\t        df.分點報酬率 = df.分點報酬率.astype(float)\n\t        df = df.sort_values('分點報酬率', ascending=False).reset_index(drop=True)\n\t        return df\n\t    def get_SymbolWinBroker(self, date: str, stockid: str):\n\t        '''股懂券商排行榜'''\n\t        url = self.above_one_url('SymbolWinBroker', date, stockid)\n\t        result = requests.get(url, headers=self.headers)\n", "        result = json.loads(result.text)['result']\n\t        df = pd.DataFrame(result['data'], columns=result['cheaders'])\n\t        df = df.sort_values('分點報酬率', ascending=False).reset_index(drop=True)\n\t        return df\n\t    def get_SymbolBrkNetVol(self, df_brokers: pd.DataFrame, stockid: str, topN=2):\n\t        '''查分點報酬前N高的券商買賣超'''\n\t        brokers = df_brokers.head(topN).券商代號.values\n\t        domain = 'https://www.above.one/cdn/TProStk'\n\t        pageName = 'SymbolBrkNetVol'\n\t        krange2 = 'OneYear'\n", "        tb = pd.DataFrame(columns=['日期', 'Code'])\n\t        for brkId in brokers:\n\t            url = f'{domain}/AuxData/RpNpJBcMvT.json?s=Date:a&aux={pageName}&auxParams=brkId_{brkId}&kfreq=day&krange2={krange2}&sym={stockid}&country=Tw'\n\t            result = requests.get(url, headers=self.headers)\n\t            result = json.loads(result.text)['result']\n\t            df = pd.DataFrame(result['data'], columns=result['cheaders'])\n\t            df.日期 = pd.to_datetime(df.日期)\n\t            df = df.sort_values('日期').rename(columns={'買超股數': f'{brkId}'})\n\t            df.insert(1, 'Code', stockid)\n\t            tb = tb.merge(df, how='outer', on=['日期', 'Code'])\n", "            time.sleep(.5)\n\t        tb['TotalBuy'] = tb.iloc[:, 2:].sum(axis=1)  # .cumsum()\n\t        return tb\n\t    def get_FuturesTickData(self, date: str):\n\t        '''前30個交易日期貨每筆成交資料'''\n\t        try:\n\t            year = date.split('-')[0]\n\t            month = date.split('-')[1]\n\t            date = date.replace('-', '_')\n\t            result = requests.get(f\"{self.url_futures_tick}/Daily_{date}.zip\")\n", "            z = zipfile.ZipFile(io.BytesIO(result.content))\n\t            z.extractall(f'{PATH}/ticks/futures/{year}/Daily_{year}_{month}')\n\t        except zipfile.BadZipFile:\n\t            logging.error('輸入的日期非交易日')\n\t        except:\n\t            logging.exception('Catch an exception (get_FuturesTickData):')\n\t    def get_CashSettle(self):\n\t        '''取得交易當日全額交割股清單'''\n\t        try:\n\t            df = pd.read_html(self.url_cash_settle)\n", "            return df[0]\n\t        except:\n\t            logging.warning('查無全額交割股清單')\n\t            return pd.DataFrame(columns=['股票代碼'])\n"]}
{"filename": "trader/utils/subscribe.py", "chunked_list": ["import numpy as np\n\tfrom typing import Union\n\tfrom ..config import API\n\tfrom . import get_contract\n\tclass Quotes:\n\t    AllIndex = {'TSE001': [], 'OTC101': []}\n\t    NowIndex = {}\n\t    AllTargets = {}\n\t    NowTargets = {}\n\tclass Subscriber:\n", "    def __init__(self):\n\t        # 即時成交資料, 所有成交資料, 下單資料\n\t        self.BidAsk = {}\n\t        self.Quotes = Quotes()\n\t    def _set_target_quote_default(self, targets: str):\n\t        '''初始化股票/期權盤中資訊'''\n\t        keys = [\n\t            'price', 'amount', 'total_amount',\n\t            'volume', 'total_volume', 'tick_type'\n\t        ]\n", "        self.Quotes.AllTargets = {s: {k: [] for k in keys} for s in targets}\n\t    def _set_index_quote_default(self):\n\t        '''初始化指數盤中資訊'''\n\t        self.Quotes.AllIndex = {'TSE001': [], 'OTC101': []}\n\t    def index_v0(self, quote: dict):\n\t        if quote['Code'] == '001':\n\t            self.Quotes.NowIndex['TSE001'] = quote\n\t            self.Quotes.AllIndex['TSE001'].append(quote)\n\t        elif quote['Code'] == '101':\n\t            self.Quotes.NowIndex['OTC101'] = quote\n", "            self.Quotes.AllIndex['OTC101'].append(quote)\n\t    def stk_quote_v1(self, tick):\n\t        '''處理股票即時成交資料'''\n\t        tick_data = dict(tick)\n\t        for k in [\n\t            'open', 'close', 'high', 'low', 'amount', 'total_amount', 'total_volume',\n\t            'avg_price', 'price_chg', 'pct_chg'\n\t        ]:\n\t            tick_data[k] = float(tick_data[k])\n\t        tick_data['price'] = tick_data['close']\n", "        for k in ['price', 'amount', 'total_amount', 'volume', 'total_volume', 'tick_type']:\n\t            self.Quotes.AllTargets[tick.code][k].append(tick_data[k])\n\t        self.Quotes.NowTargets[tick.code] = tick_data\n\t        return tick_data\n\t    def fop_quote_v1(self, symbol: str, tick):\n\t        '''處理期權即時成交資料'''\n\t        tick_data = dict(tick)\n\t        for k in [\n\t            'open', 'close', 'high', 'low', 'amount', 'total_amount',\n\t            'underlying_price', 'avg_price', 'price_chg', 'pct_chg'\n", "        ]:\n\t            tick_data[k] = float(tick_data[k])\n\t        tick_data['price'] = tick_data['close']\n\t        tick_data['symbol'] = symbol\n\t        for k in ['price', 'amount', 'total_amount', 'volume', 'total_volume', 'tick_type']:\n\t            self.Quotes.AllTargets[symbol][k].append(tick_data[k])\n\t        self.Quotes.NowTargets[symbol] = tick_data\n\t        return tick_data\n\t    def subscribe_index(self):\n\t        '''訂閱指數盤中資訊'''\n", "        API.quote.subscribe(API.Contracts.Indexs.TSE.TSE001, quote_type='tick')\n\t        API.quote.subscribe(API.Contracts.Indexs.OTC.OTC101, quote_type='tick')\n\t        self._set_index_quote_default()\n\t    def unsubscribe_index(self):\n\t        '''取消訂閱指數盤中資訊'''\n\t        API.quote.unsubscribe(\n\t            API.Contracts.Indexs.TSE.TSE001, quote_type='tick')\n\t        API.quote.unsubscribe(\n\t            API.Contracts.Indexs.OTC.OTC101, quote_type='tick')\n\t    def subscribe_targets(self, targets: list, quote_type: str = 'tick'):\n", "        '''訂閱股票/期貨盤中資訊'''\n\t        for t in targets:\n\t            target = get_contract(t)\n\t            API.quote.subscribe(target, quote_type=quote_type, version='v1')\n\t    def unsubscribe_targets(self, targets: str, quote_type: str = 'tick'):\n\t        '''取消訂閱股票盤中資訊'''\n\t        for t in targets:\n\t            target = get_contract(t)\n\t            API.quote.unsubscribe(target, quote_type=quote_type, version='v1')\n\t    def subscribe_all(self, targetLists: Union[list, np.array]):\n", "        '''訂閱指數、tick、bidask資料'''\n\t        self.subscribe_index()\n\t        self.subscribe_targets(targetLists, 'tick')\n\t        self.subscribe_targets(targetLists, 'bidask')\n\t        self._set_target_quote_default(targetLists)\n\t    def unsubscribe_all(self, targetLists: Union[list, np.array]):\n\t        '''取消訂閱指數、tick、bidask資料'''\n\t        self.unsubscribe_index()\n\t        self.unsubscribe_targets(targetLists, 'tick')\n\t        self.unsubscribe_targets(targetLists, 'bidask')\n"]}
{"filename": "trader/utils/accounts.py", "chunked_list": ["import time\n\timport logging\n\timport pandas as pd\n\timport shioaji as sj\n\tfrom datetime import datetime\n\tfrom shioaji.account import StockAccount\n\tfrom .. import crawler2\n\tfrom ..config import API, PATH, TODAY, TODAY_STR\n\tfrom .time import TimeTool\n\tfrom .file import FileHandler\n", "class AccountInfo(TimeTool, FileHandler):\n\t    def __init__(self):\n\t        self.filename = f'{TODAY.year}_股票帳務資訊.xlsx'\n\t        self.DEFAULT_TABLE = pd.DataFrame(\n\t            columns=[\n\t                '交易日期',\n\t                'T日交割金額',\n\t                'T日帳戶餘額',\n\t                'T+1日交割金額',\n\t                'T+1日帳戶餘額',\n", "                'T+2日交割金額',\n\t                'T+2日帳戶餘額',\n\t                '庫存總成本',\n\t                '庫存現值',\n\t                '融資金額',\n\t                '融券金額',\n\t                '未實現損益',\n\t                '已實現損益',\n\t                '當日新增庫存未實現損益',\n\t                '總部位現值(含融資金額)',\n", "                '總部位現值(不含融資金額)',\n\t                '結算現值'\n\t            ])\n\t        self.HAS_FUTOPT_ACCOUNT = False\n\t        self.desposal_margin = 0\n\t        self.ProfitAccCount = 0  # 權益總值\n\t        self.df_securityInfo = pd.DataFrame(\n\t            columns=[\n\t                'account', 'market',\n\t                'code', 'order_cond', 'action', 'pnl',\n", "                'cost_price', 'quantity', 'yd_quantity', 'last_price'\n\t            ]\n\t        )\n\t        self.df_futuresInfo = pd.DataFrame(\n\t            columns=[\n\t                'Account', 'Market', 'Date', 'Code', 'CodeName', 'OrderNum',\n\t                'OrderBS', 'OrderType', 'Currency', 'paddingByte', 'Volume',\n\t                'ContractAverPrice', 'SettlePrice', 'RealPrice', 'FlowProfitLoss', 'SettleProfitLoss',\n\t                'StartSecurity', 'UpKeepSecurity', 'OTAMT', 'MTAMT'\n\t            ]\n", "        )\n\t    def _login(self, API_KEY, SECRET_KEY, account_name):\n\t        n = 0\n\t        while n < 5:\n\t            try:\n\t                API.login(\n\t                    api_key=API_KEY,\n\t                    secret_key=SECRET_KEY,\n\t                    contracts_timeout=10000\n\t                )\n", "                break\n\t            except TimeoutError as e:\n\t                logging.warning(f'{e}')\n\t                n += 1\n\t                time.sleep(5)\n\t        nth_account = int(account_name[-1])\n\t        if nth_account > 1:\n\t            accounts = API.list_accounts()\n\t            accounts = [a for a in accounts if isinstance(a, StockAccount)]\n\t            if len(accounts) > 1:\n", "                API.set_default_account(accounts[nth_account-1])\n\t            else:\n\t                logging.warning('此ID只有一個證券戶')\n\t        self.account_name = account_name\n\t        if API.futopt_account:\n\t            self.HAS_FUTOPT_ACCOUNT = True\n\t        time.sleep(0.05)\n\t        logging.info(f'【{account_name}】log-in successful!')\n\t    def _list_settlements(self):\n\t        '''取得交割資訊'''\n", "        n = 0\n\t        while True:\n\t            try:\n\t                return API.settlements(API.stock_account)\n\t            except:\n\t                logging.warning('無法取得交割資訊，重試中')\n\t                n += 1\n\t                if n >= 60:\n\t                    return 0\n\t                time.sleep(1)\n", "    def _obj_2_df(self, objects: list):\n\t        '''把自API查詢得到的物件轉為DataFrame'''\n\t        try:\n\t            return pd.DataFrame([o.__dict__ for o in objects])\n\t        except:\n\t            return pd.DataFrame([{o[0]:o[1] for o in objects}])\n\t    def create_info_table(self):\n\t        if self.is_in_dir(self.filename, f'{PATH}/daily_info/'):\n\t            return pd.ExcelFile(f'{PATH}/daily_info/{self.filename}')\n\t        else:\n", "            return self.DEFAULT_TABLE\n\t    def balance(self, mode='info'):\n\t        '''查帳戶餘額'''\n\t        n = 0\n\t        while n < 5:\n\t            try:\n\t                df = self._obj_2_df(API.account_balance())\n\t                df.date = pd.to_datetime(df.date).dt.date.astype(str)\n\t                balance = df[df.date == df.date.max()].acc_balance.values[0]\n\t                if mode == 'info':\n", "                    logging.debug(f'Account balance = {balance}')\n\t            except:\n\t                logging.exception('Catch an exception (balance):')\n\t                balance = None\n\t            if balance != None:\n\t                return balance\n\t            time.sleep(1)\n\t            n += 1\n\t        logging.debug('【Query account balance failed】')\n\t        return -1\n", "    def get_stock_name(self, stockid: str):\n\t        '''以股票代號查詢公司名稱'''\n\t        stockname = API.Contracts.Stocks[stockid]\n\t        if (stockname is not None):\n\t            return stockname.name\n\t        return stockname\n\t    def securityInfo(self):\n\t        '''查庫存明細'''\n\t        while True:\n\t            try:\n", "                stocks = API.list_positions(\n\t                    API.stock_account,\n\t                    unit=sj.constant.Unit.Share\n\t                )\n\t                stocks = self._obj_2_df(stocks)\n\t                break\n\t            except:\n\t                logging.warning('無法取得庫存，重試中')\n\t                time.sleep(1)\n\t        stocks = stocks.rename(\n", "            columns={\n\t                'cond': 'order_cond',\n\t                'direction': 'action',\n\t                'price': 'cost_price',\n\t            }\n\t        )\n\t        if stocks.shape[0]:\n\t            stocks.pnl = stocks.pnl.astype(int)  # 未實現損益\n\t            stocks.order_cond = stocks.order_cond.astype(str)  # 交易別\n\t            stocks.insert(1, 'name', stocks.code.apply(self.get_stock_name))\n", "            stocks[['account', 'market']] = [self.account_name, 'Stocks']\n\t            return stocks\n\t        return self.df_securityInfo\n\t    def get_profit_loss(self, start: str, end: str):\n\t        '''查詢已實現損益'''\n\t        profitloss = API.list_profit_loss(API.stock_account, start, end)\n\t        return self._obj_2_df(profitloss)\n\t    def query_close(self, stockid: str, date: str):\n\t        '''查證券收盤價'''\n\t        ticks = API.ticks(API.Contracts.Stocks[stockid], date)\n", "        df = pd.DataFrame({**ticks})\n\t        df.ts = pd.to_datetime(df.ts)\n\t        try:\n\t            return df.close.values[-1]\n\t        except:\n\t            return -1\n\t    def realized_profit(self, start: str = None, end: str = None):\n\t        '''\n\t        計算已實現損益\n\t        start:開始日期, 預設為最近一個營業日(查詢當日)\n", "        end: 結束日期, 預設為最近一個營業日(查詢當日)\n\t        '''\n\t        i = 0\n\t        while i < 5:\n\t            try:\n\t                day = self._strf_timedelta(TODAY, i)\n\t                if not start:\n\t                    start_ = day\n\t                if not end:\n\t                    end_ = day\n", "                profitloss = self.get_profit_loss(start_, end_)\n\t                if profitloss.shape[0]:\n\t                    return profitloss.pnl.sum()\n\t                return 0\n\t            except:\n\t                # 遇休市則往前一天查詢, 直到查到資料為止\n\t                print(f\"查無 {day} 已實現損益, 改查詢前一天\\n\")\n\t                i += 1\n\t                time.sleep(2)\n\t                if i == 5:\n", "                    return 0\n\t    def settle_info(self, mode='info'):\n\t        '''查詢 T ~ T+2 日的交割金額'''\n\t        df_fail = pd.DataFrame(columns=['date', 'amount', 'T'])\n\t        now = datetime.now()\n\t        if 18 <= now.hour <= 19:\n\t            logging.debug('Settle info temporary not accessable.')\n\t            return df_fail\n\t        n = 0\n\t        while n < 5:\n", "            try:\n\t                settlement = self._list_settlements()\n\t                df = self._obj_2_df(settlement)\n\t                if mode == 'info':\n\t                    logging.debug(f\"Settlements:{df.to_dict('records')}\")\n\t                return df\n\t            except:\n\t                logging.exception('Catch an exception (settle_info):')\n\t            time.sleep(1)\n\t            n += 1\n", "        return df_fail\n\t    def compute_total_cost(self, stocks: pd.DataFrame):\n\t        '''總成本合計'''\n\t        if stocks.shape[0]:\n\t            return (stocks.cost_price*stocks.quantity).sum()\n\t        return 0\n\t    def compute_total_unrealized_profit(self, stocks: pd.DataFrame):\n\t        '''未實現損益合計'''\n\t        if stocks.shape[0]:\n\t            return stocks.pnl.sum()\n", "        return 0\n\t    def compute_margin_amount(self, stocks: pd.DataFrame):\n\t        '''計算融資/融券金額'''\n\t        if stocks.shape[0]:\n\t            is_leverage = (\n\t                'MarginTrading' == stocks.order_cond.apply(lambda x: x._value_))\n\t            leverages = [\n\t                crawler2.get_leverage(s)['融資成數']/100 for s in stocks.code]\n\t            return sum(is_leverage*stocks.cost_price*stocks.quantity*leverages)\n\t        return 0\n", "    def compute_today_unrealized_profit(self, stocks: pd.DataFrame):\n\t        '今日新增庫存未實現損益合計'\n\t        if stocks.shape[0]:\n\t            return stocks[stocks.yd_quantity == 0].pnl.sum()\n\t        return 0\n\t    def query_all(self):\n\t        # 庫存明細(股)\n\t        stocks = self.securityInfo()\n\t        # 已實現損益\n\t        profit = self.realized_profit()\n", "        if not stocks.shape[0] and profit == 0:\n\t            logging.info('目前無庫存')\n\t            return None\n\t        if stocks.shape[0]:\n\t            print(f'\\n{stocks}\\n')\n\t        # 庫存成本 & 現值\n\t        total_cost = self.compute_total_cost(stocks)\n\t        unrealized_profit = self.compute_total_unrealized_profit(stocks)\n\t        total_market_value = total_cost + unrealized_profit\n\t        # 融資金額\n", "        margin_amount = self.compute_margin_amount(stocks)\n\t        # 帳戶餘額\n\t        balance = self.balance()\n\t        if balance < 0:\n\t            logging.error(f'Balance = {balance}, get balance from local')\n\t            balance = pd.read_excel(\n\t                f'{PATH}/daily_info/{self.filename}', sheet_name=self.account_name)\n\t            balance = balance['T+1日帳戶餘額'].values[-1]\n\t        # 今日新增庫存未實現損益\n\t        today_unrealized_profit = self.compute_today_unrealized_profit(stocks)\n", "        # 帳務交割資訊\n\t        settle_info = self.settle_info()\n\t        settles = settle_info.amount[1:].sum()\n\t        # 總現值 = 帳戶餘額 + T+1日交割金額 + T+2日交割金額 + 庫存現值\n\t        total_value = int(balance + total_market_value + settles)\n\t        now = int(total_value - margin_amount - unrealized_profit)\n\t        settle_t1 = settle_info.values[1, 1]\n\t        settle_t2 = settle_info.values[2, 1]\n\t        row = {\n\t            '交易日期': TODAY_STR,\n", "            'T日交割金額': settle_info.values[0, 1],\n\t            'T日帳戶餘額': int(balance),\n\t            'T+1日交割金額': settle_t1,\n\t            'T+1日帳戶餘額': balance + settle_t1,\n\t            'T+2日交割金額': settle_t2,\n\t            'T+2日帳戶餘額': balance + settle_t1 + settle_t2,\n\t            '庫存總成本': int(total_cost),\n\t            '庫存現值': int(total_market_value),\n\t            '融資金額': int(margin_amount),\n\t            '融券金額': 0,\n", "            '未實現損益': int(unrealized_profit),\n\t            '已實現損益': int(profit),\n\t            '當日新增庫存未實現損益': int(today_unrealized_profit),\n\t            '總部位現值(含融資金額)': int(total_value),\n\t            '總部位現值(不含融資金額)': int(total_value - margin_amount),\n\t            '結算現值': now\n\t        }\n\t        return row\n\t    def update_info(self, df, row):\n\t        tb = pd.read_excel(df, sheet_name='dentist_1')\n", "        tb = pd.concat([\n\t            tb,\n\t            pd.DataFrame([row])\n\t        ]).reset_index(drop=True)\n\t        return tb\n\t    def get_account_margin(self):\n\t        '''期權保證金資訊'''\n\t        n = 0\n\t        while n < 5 and API.futopt_account.signed:\n\t            try:\n", "                margin = API.margin(API.futopt_account)\n\t            except:\n\t                logging.exception('Catch an exception (get_account_margin):')\n\t                margin = None\n\t            if margin:\n\t                self.desposal_margin = margin.available_margin\n\t                self.ProfitAccCount = margin.equity\n\t                break\n\t            time.sleep(1)\n\t            n += 1\n", "    def get_openpositions(self):\n\t        '''查看期權帳戶持有部位'''\n\t        positions = API.list_positions(API.futopt_account)\n\t        if not positions:\n\t            return self.df_futuresInfo\n\t        df = self._obj_2_df(positions)\n\t        if df.shape[0]:\n\t            df[['Account', 'Market']] = [self.account_name, 'Futures']\n\t            return df\n\t        return self.df_futuresInfo\n", "    def get_settle_profitloss(self, start_date: str, end_date: str):\n\t        '''查看期權帳戶(已實現)損益'''\n\t        # TODO: 1.0.0 list_profit_loss_detail(*api.futopt_account*), list_profit_loss_summary(*api.futopt_account*)\n\t        if start_date:\n\t            start_date = start_date.replace('-', '')\n\t        if end_date:\n\t            end_date = end_date.replace('-', '')\n\t        settle_profitloss = API.get_account_settle_profitloss(\n\t            summary='Y', start_date=start_date, end_date=end_date)\n\t        df_profitloss = pd.DataFrame(settle_profitloss.data())\n", "        return df_profitloss\n\t    def dataUsage(self):\n\t        return round(API.usage().bytes/2**20, 2)\n"]}
{"filename": "trader/utils/notify.py", "chunked_list": ["import logging\n\timport requests\n\timport pandas as pd\n\tfrom ..config import API, TOKEN_INFO, TOKEN_MONITOR\n\tclass Notification:\n\t    NotifyURL = \"https://notify-api.line.me/api/notify\"\n\t    order_cond = {\n\t        'Cash': '現股',\n\t        'MarginTrading': '融資',\n\t        'ShortSelling': '融券'\n", "    }\n\t    order_lot = {\n\t        'Common': '張',\n\t        'IntradayOdd': '股'\n\t    }\n\t    oc_type = {\n\t        'New': '新倉',\n\t        'Cover': '平倉'\n\t    }\n\t    def headers(self, msgType: str):\n", "        '''LINE notify推播header設定'''\n\t        if msgType in ['Order', 'Deal', 'AccountInfo', 'Monitor', 'Tasker', 'Crawler']:\n\t            return {\"Authorization\": f\"Bearer {TOKEN_MONITOR}\"} if TOKEN_MONITOR else {}\n\t        return {\"Authorization\": f\"Bearer {TOKEN_INFO}\"} if TOKEN_INFO else {}\n\t    def post(self, message: str, image_name=None, msgType: str = 'price'):\n\t        '''Line Notify 推播，可傳送文字或圖片訊息'''\n\t        data = {'message': message}\n\t        headers = self.headers(msgType)\n\t        if not headers:\n\t            return\n", "        if image_name:\n\t            image = open(image_name, 'rb')\n\t            files = {'imageFile': image}\n\t            requests.post(\n\t                self.NotifyURL,\n\t                headers=headers,\n\t                data=data,\n\t                files=files\n\t            )\n\t        else:\n", "            requests.post(self.NotifyURL, headers=headers, data=data)\n\t    def post_tftOrder(self, stat, msg: dict):\n\t        '''發送推播-股票委託'''\n\t        logging.debug(f'[{stat}][{msg}]')\n\t        stock = msg['contract']['code']\n\t        name = API.Contracts.Stocks[stock].name\n\t        order = msg['order']\n\t        account = order['account']['account_id']\n\t        cond = self.order_cond[order['order_cond']]\n\t        lot = self.order_lot[order['order_lot']]\n", "        operation = msg['operation']\n\t        if operation['op_code'] == '00' or operation['op_msg'] == '':\n\t            text = f\"\\n【委託成功】{name}-{stock}\\n【帳號】{account}\\n【{cond}】{order['action']} {order['quantity']}{lot}\"\n\t            self.post(text, msgType='Order')\n\t        if operation['op_code'] == '88':\n\t            text = f\"\\n【委託失敗】{name}-{stock}\\n【帳號】{account}\\n【{operation['op_msg']}】\"\n\t            self.post(text, msgType='Order')\n\t        if operation['op_type'] == 'Cancel':\n\t            text = f\"\\n【刪單成功】{name}-{stock}\\n【帳號】{account}\\n【{cond}】{order['action']} {order['quantity']}{lot}\"\n\t            self.post(text, msgType='Order')\n", "    def post_tftDeal(self, stat, msg: dict):\n\t        '''發送推播-股票成交'''\n\t        logging.debug(f'[{stat}][{msg}]')\n\t        stock = msg['code']\n\t        name = API.Contracts.Stocks[stock].name\n\t        account = msg['account_id']\n\t        cond = self.order_cond[msg['order_cond']]\n\t        lot = self.order_lot[msg['order_lot']]\n\t        price = msg['price']\n\t        text = f\"\\n【成交】{name}-{stock}\\n【帳號】{account}\\n【{cond}】{msg['action']} {msg['quantity']}{lot} {price}元\"\n", "        self.post(text, msgType='Deal')\n\t    def post_fOrder(self, stat, msg: dict):\n\t        '''發送推播-期貨委託'''\n\t        logging.debug(f'[{stat}][{msg}]')\n\t        code = msg['contract']['code']\n\t        delivery_month = msg['contract']['delivery_month']\n\t        name = API.Contracts['Futures'][code][code+delivery_month].name\n\t        order = msg['order']\n\t        account = order['account']['account_id']\n\t        oc_type = self.oc_type[order['oc_type']]\n", "        quantity = order['quantity']\n\t        operation = msg['operation']\n\t        if operation['op_code'] == '00' or operation['op_msg'] == '':\n\t            text = f\"\\n【委託成功】{name}({code+delivery_month})\\n【帳號】{account}\\n【{oc_type}】{order['action']} {quantity}口\"\n\t            self.post(text, msgType='Order')\n\t        if operation['op_code'] != '00':\n\t            text = f\"\\n【委託失敗】{name}({code+delivery_month})\\n【帳號】{account}\\n【{operation['op_msg']}】\"\n\t            self.post(text, msgType='Order')\n\t    def post_fDeal(self, stat, msg: dict):\n\t        '''發送推播-期貨成交'''\n", "        logging.debug(f'[{stat}][{msg}]')\n\t        code = msg['code']\n\t        delivery_month = msg['delivery_month']\n\t        name = API.Contracts['Futures'][code][code+delivery_month].name\n\t        account = msg['account_id']\n\t        price = msg['price']\n\t        quantity = msg['quantity']\n\t        text = f\"\\n【成交】{name}({code+delivery_month})\\n【帳號】{account}\\n【{msg['action']}】{quantity}口 {price}元\"\n\t        self.post(text, msgType='Deal')\n\t    def post_put_call_ratio(self, df_pcr: pd.DataFrame):\n", "        '''發送推播-Put/Call Ratio'''\n\t        if df_pcr.shape[0]:\n\t            put_call_ratio = df_pcr.PutCallRatio.values[0]\n\t        else:\n\t            put_call_ratio = '查無資料'\n\t        text = f\"\\n【本日Put/Call Ratio】 {put_call_ratio}\"\n\t        self.post(text, msgType='Msg')\n\t    def post_account_info(self, account_id: str, info: dict):\n\t        '''發送推播-每日帳務'''\n\t        if info:\n", "            text = f'\\n帳號: {account_id}'\n\t            for k, i in info.items():\n\t                text += f'\\n{k}: {i}'\n\t        else:\n\t            text = '查無資訊'\n\t        text = f\"\\n【盤後帳務資訊】{text}\"\n\t        self.post(text, msgType='AccountInfo')\n\t    def post_stock_selection(self, df: pd.DataFrame):\n\t        '''發送推播-每日選股清單'''\n\t        if df.shape[0]:\n", "            strategies = df.Strategy.unique()\n\t            text = ''\n\t            for s in strategies:\n\t                temp = df[df.Strategy == s]\n\t                temp = temp.set_index('company_name').code.to_dict()\n\t                _text = ''\n\t                for k, v in temp.items():\n\t                    _text += f'\\n{k}({v}), '\n\t                text += f\"\\n----------{s}----------{_text.rstrip(', ')}\\n\"\n\t            text = text.rstrip('\\n')\n", "        else:\n\t            text = '無'\n\t        text = f\"\\n【本日選股清單】{text}\"\n\t        self.post(text, msgType='StockSelect')\n"]}
{"filename": "trader/utils/select.py", "chunked_list": ["import logging\n\timport numpy as np\n\timport pandas as pd\n\tfrom datetime import timedelta\n\tfrom ..config import PATH, TODAY_STR, TODAY, SelectMethods\n\tfrom .time import TimeTool\n\tfrom .file import FileHandler\n\tfrom .crawler import readStockList\n\tfrom .database import db, KBarTables\n\tfrom .database.tables import SelectedStocks\n", "try:\n\t    from ..scripts.conditions import SelectConditions\n\texcept:\n\t    logging.warning('Cannot import select scripts from package.')\n\t    SelectConditions = None\n\ttry:\n\t    from ..scripts.features import FeaturesSelect\n\texcept:\n\t    logging.warning('Cannot import feature scripts from package.')\n\t    FeaturesSelect = None\n", "class SelectStock(TimeTool, FileHandler):\n\t    def __init__(self, scale='1D'):\n\t        self.set_select_scripts(SelectConditions, FeaturesSelect)\n\t        self.scale = scale\n\t        self.categories = {\n\t            1: '水泥工業',\n\t            2: '食品工業',\n\t            3: '塑膠工業',\n\t            4: '紡織纖維',\n\t            5: '電機機械',\n", "            6: '電器電纜',\n\t            21: '化學工業',\n\t            22: '生技醫療業',\n\t            8: '玻璃陶瓷',\n\t            9: '造紙工業',\n\t            10: '鋼鐵工業',\n\t            11: '橡膠工業',\n\t            12: '汽車工業',\n\t            24: '半導體業',\n\t            25: '電腦及週邊設備業',\n", "            26: '光電業',\n\t            27: '通信網路業',\n\t            28: '電子零組件業',\n\t            29: '電子通路業',\n\t            30: '資訊服務業',\n\t            31: '其他電子業',\n\t            14: '建材營造',\n\t            15: '航運業',\n\t            16: '觀光事業',\n\t            17: '金融業',\n", "            18: '貿易百貨',\n\t            23: '油電燃氣業',\n\t            19: '綜合',\n\t            20: '其他',\n\t            32: '文化創意業',\n\t            33: '農業科技業',\n\t            34: '電子商務',\n\t            80: '管理股票'\n\t        }\n\t    def set_select_scripts(self, select_scripts: object = None, feature_scripts: object = None):\n", "        '''Set preprocess & stock selection scripts'''\n\t        if select_scripts and feature_scripts:\n\t            feature_scripts = feature_scripts()\n\t            self.Preprocess = {\n\t                m: getattr(feature_scripts, f'preprocess_{m}') for m in SelectMethods}\n\t            if hasattr(feature_scripts, 'preprocess_common'):\n\t                self.Preprocess.update({\n\t                    'preprocess_common': feature_scripts.preprocess_common})\n\t            select_scripts = select_scripts()\n\t            self.METHODS = {\n", "                m: getattr(select_scripts, f'condition_{m}') for m in SelectMethods}\n\t        else:\n\t            self.Preprocess = {}\n\t            self.METHODS = {}\n\t    def load_and_merge(self, targets):\n\t        if db.HAS_DB:\n\t            start = TODAY - timedelta(days=365*2)\n\t            condition1 = KBarTables[self.scale].Time >= start\n\t            condition2 = KBarTables[self.scale].name.in_(targets)\n\t            df = db.query(KBarTables[self.scale], condition1, condition2)\n", "        else:\n\t            dir_path = f'{PATH}/Kbars/{self.scale}'\n\t            df = self.read_tables_in_folder(dir_path, pattern='stocks')\n\t        df = df.drop_duplicates(['name', 'Time'], keep='last')\n\t        df = df.sort_values(['name', 'Time'])\n\t        return df\n\t    def preprocess(self, df: pd.DataFrame):\n\t        df = df.groupby('name').tail(365).reset_index(drop=True)\n\t        df.name = df.name.astype(int).astype(str)\n\t        df.Close = df.Close.replace(0, np.nan).fillna(method='ffill')\n", "        for col in ['Open', 'High', 'Low', 'Close']:\n\t            df.loc[\n\t                (df.name == '8070') & (df.Time < '2020-08-17'), col] /= 10\n\t            df.loc[\n\t                (df.name == '6548') & (df.Time < '2019-09-09'), col] /= 10\n\t        if 'preprocess_common' in self.Preprocess:\n\t            df = self.Preprocess['preprocess_common'](df)\n\t        return df\n\t    def pick(self, *args):\n\t        stockids = readStockList()\n", "        df = self.load_and_merge(stockids.code.tolist() + ['1', '101'])\n\t        df = self.preprocess(df)\n\t        for m, func in self.Preprocess.items():\n\t            if m != 'preprocess_common':\n\t                df = func(df)\n\t        for i, (m, func) in enumerate(self.METHODS.items()):\n\t            df.insert(i+2, m, func(df, *args))\n\t        # insert columns\n\t        stockids.category = stockids.category.astype(int)\n\t        stockids = stockids.set_index('code')\n", "        df.insert(1, 'company_name', df.name.map(stockids.name.to_dict()))\n\t        df.insert(2, 'category', df.name.map(\n\t            stockids.category.to_dict()).map(self.categories))\n\t        return df\n\t    def melt_table(self, df: pd.DataFrame, columns=[]):\n\t        '''Melt the \"strategy\" columns into values of a table'''\n\t        if not columns:\n\t            columns = [\n\t                'name', 'company_name', 'category', 'Time',\n\t                'Open', 'High', 'Low', 'Close', 'Volume', 'Amount',\n", "            ]\n\t        select_methods = list(self.METHODS)\n\t        df = df[columns + select_methods]\n\t        df = df.melt(\n\t            id_vars=columns,\n\t            value_vars=select_methods,\n\t            var_name='Strategy',\n\t            value_name='isMatch'\n\t        )\n\t        df.Strategy *= df.isMatch\n", "        df = df[df.Strategy != '']\n\t        df = df.reset_index(drop=True).drop('isMatch', axis=1)\n\t        df = df.rename(columns={'name': 'code'})\n\t        df = df.sort_values(['Strategy', 'code'])\n\t        return df\n\t    def export(self, df: pd.DataFrame):\n\t        if db.HAS_DB:\n\t            db.dataframe_to_DB(df, SelectedStocks)\n\t        else:\n\t            self.save_table(df, f'{PATH}/selections/all.csv')\n", "            self.save_table(\n\t                df, f'{PATH}/selections/history/{TODAY_STR}-all.csv')\n\t    def get_selection_files(self):\n\t        '''取得選股清單'''\n\t        day = self.last_business_day()\n\t        if db.HAS_DB:\n\t            df = db.query(SelectedStocks, SelectedStocks.Time == day)\n\t        else:\n\t            df = self.read_table(\n\t                filename=f'{PATH}/selections/all.csv',\n", "                df_default=pd.DataFrame(columns=[\n\t                    'code', 'company_name', 'category', 'Time',\n\t                    'Open', 'High', 'Low', 'Close',\n\t                    'Volume', 'Amount', 'Strategy'\n\t                ])\n\t            )\n\t            df.Time = pd.to_datetime(df.Time)\n\t            df.code = df.code.astype(str)\n\t            df = df[df.Time == day]\n\t        return df\n"]}
{"filename": "trader/utils/time.py", "chunked_list": ["import re\n\timport time\n\timport pandas as pd\n\tfrom typing import Union\n\tfrom datetime import datetime, timedelta\n\tfrom ..config import TODAY_STR, holidays\n\tclass TimeTool:\n\t    DueDays = {\n\t        (d.year, d.month): d for d in pd.date_range('2001-01-01', '2030-12-31', freq='WOM-3WED')}\n\t    def datetime_to_str(self, date: datetime):\n", "        '''將datetime時間轉為字串, 輸出格式:YYYY-MM-DD'''\n\t        return date.strftime(\"%Y-%m-%d\")\n\t    def str_to_datetime(self, date: str):\n\t        '''將字串時間轉為datetime, 輸入格式:YYYY-MM-DD'''\n\t        return datetime.strptime(date, \"%Y-%m-%d\")\n\t    def now_str(self):\n\t        '''取得當下時間戳的字串格式'''\n\t        return datetime.now().strftime('%Y-%m-%d %a %H:%M:%S.%f')\n\t    def now_for_log(self):\n\t        return f\"【{self.now_str()}】\"\n", "    def _strf_timedelta(self, date: Union[str, datetime], delta: int):\n\t        '''計算前N日的日期(str)'''\n\t        if isinstance(date, str):\n\t            date = self.str_to_datetime(date)\n\t        return self.datetime_to_str(date - timedelta(days=delta))\n\t    def get_buyday(self, day: datetime):\n\t        '''計算進場日'''\n\t        n = self.nday_diff(day) + 1\n\t        return self._strf_timedelta(day, n)\n\t    def nday_diff(self, date: datetime):\n", "        '''\n\t        遇假日的日數判斷\n\t        若今日為星期一, 往前推算2天\n\t        若今日為星期天, 往前推算1天\n\t        其餘日子只要前一天為交易日則不須往前推算\n\t        '''\n\t        if (date.weekday() == 0):\n\t            return 2\n\t        elif (date.weekday() == 6):\n\t            return 1\n", "        return 0\n\t    def date_diff(self, day1: Union[str, datetime], day2: Union[str, datetime]):\n\t        '''計算兩個日期之間的天數'''\n\t        if isinstance(day1, str):\n\t            day1 = pd.to_datetime(day1)\n\t        if isinstance(day2, str):\n\t            day2 = pd.to_datetime(day2)\n\t        return (day1 - day2).days\n\t    def is_pass_time(self, time_target: Union[str, datetime]):\n\t        '''檢查當下時間是否已過想檢查的目標時間'''\n", "        if isinstance(time_target, str):\n\t            time_target = pd.to_datetime(time_target)\n\t        return datetime.now() >= time_target\n\t    def count_n_kbars(self, start: datetime, end: datetime, scale: int):\n\t        '''\n\t        計算K棒數量\n\t        scale單位: min\n\t        '''\n\t        # TODO: 扣除國定假日不開盤 & 收盤期間\n\t        if isinstance(start, str):\n", "            start = pd.to_datetime(start)\n\t        if isinstance(end, str):\n\t            end = pd.to_datetime(end)\n\t        m1 = start.minute - (start.minute % scale)\n\t        start = start.replace(minute=m1, second=0, microsecond=0)\n\t        m2 = end.minute - (end.minute % scale)\n\t        end = end.replace(minute=m2, second=0, microsecond=0)\n\t        n_kbar = (end - start).total_seconds()/60/scale\n\t        if start.weekday() == 4 and end.weekday() == 0:\n\t            n_kbar -= 1440*2/scale\n", "        return n_kbar\n\t    def convert_date_format(self, x: str):\n\t        '''轉換民國格式為西元格式'''\n\t        x = re.findall('\\d+', x)\n\t        year = int(x[0])\n\t        if year < 1911:\n\t            x[0] = str(year + 1911)\n\t        return '-'.join(x)\n\t    def date_2_mktime(self, date: str):\n\t        '''將日期轉為浮點數格式'''\n", "        date = date.replace('-', '').replace('/', '')\n\t        date = date.replace(' ', '').replace(':', '')\n\t        date = datetime(int(date[:4]), int(date[4:6]), int(date[6:8]), 8)\n\t        return int(time.mktime(date.timetuple()))\n\t    def utcfromtimestamp_(self, timestamp):\n\t        '''將浮點格式時間戳轉為datetime格式'''\n\t        return datetime.utcfromtimestamp(timestamp)\n\t    def last_business_day(self, date: datetime = None):\n\t        '''取得最近一個交易日，遇假日, 連假, or補班日則往前推算'''\n\t        if not date:\n", "            date = TODAY_STR\n\t        d = 1\n\t        while True:\n\t            day = pd.to_datetime(date) - timedelta(days=d)\n\t            if day not in holidays and day.weekday() not in [5, 6]:\n\t                return day\n\t            d += 1\n\t    def GetDueMonth(self, sourcedate: datetime, months: int = 1):\n\t        '''推算交割月份，在交割日之前的日期，交割月為當月，交割日之後為次月'''\n\t        dueday = self.DueDays[(sourcedate.year, sourcedate.month)]\n", "        if pd.to_datetime(sourcedate) < dueday:\n\t            return str(sourcedate.year) + str(sourcedate.month).zfill(2)\n\t        month = sourcedate.month - 1 + months\n\t        year = sourcedate.year + month // 12\n\t        month = month % 12 + 1\n\t        return str(year) + str(month).zfill(2)\n\t    def CountDown(self, target: Union[int, datetime]):\n\t        '''倒數計時'''\n\t        if isinstance(target, int):\n\t            N = target\n", "        else:\n\t            now = datetime.now()\n\t            N = int((target - now).total_seconds())\n\t        for i in range(N, 0, -1):\n\t            print(\n\t                f\"Time remaining: {int(i/60)}min {i % 60}s\", end=\"\\r\", flush=True)\n\t            time.sleep(1)\n\t        print(\"Time remaining: 0min 0s\", end=\"\\r\", flush=True)\n"]}
{"filename": "trader/utils/__init__.py", "chunked_list": ["import queue\n\timport logging\n\timport numpy as np\n\tfrom ..config import API\n\tdef reduce_mem_usage(df, verbose=True):\n\t    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n\t    start_mem = df.memory_usage().sum() / 1024**2\n\t    for col in df.columns:\n\t        col_type = df[col].dtypes\n\t        if col_type in numerics:\n", "            c_min = df[col].min()\n\t            c_max = df[col].max()\n\t            if str(col_type)[:3] == 'int':\n\t                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n\t                    df[col] = df[col].astype(np.int8)\n\t                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n\t                    df[col] = df[col].astype(np.int16)\n\t                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n\t                    df[col] = df[col].astype(np.int32)\n\t                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n", "                    df[col] = df[col].astype(np.int64)\n\t            else:\n\t                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n\t                    df[col] = df[col].astype(np.float16)\n\t                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n\t                    df[col] = df[col].astype(np.float32)\n\t                else:\n\t                    df[col] = df[col].astype(np.float64)\n\t    end_mem = df.memory_usage().sum() / 1024**2\n\t    if verbose:\n", "        print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(\n\t            end_mem, 100 * (start_mem - end_mem) / start_mem))\n\t    return df\n\tdef progress_bar(N, i, status=''):\n\t    n = i+1\n\t    progress = f\"\\r{status} |{'█'*int(n*50/N)}{' '*(50-int(n*50/N))} | {n}/{N} ({round(n/N*100, 2)}%)\"\n\t    print(progress, end='')\n\tdef create_queue(target_list, crawled_list=[]):\n\t    '''put candidate companies not crawled into queue'''\n\t    logging.info(\"Put targets in queue...\")\n", "    q = queue.Queue(0)\n\t    target_list = list(set(target_list)-set(crawled_list))\n\t    N = len(target_list)\n\t    for i, company in enumerate(target_list):\n\t        q.put(company)\n\t        progress_bar(N, i)\n\t    logging.info(f\"Targets in queue: {q.qsize()}\")\n\t    return (q)\n\tdef get_contract(target: str):\n\t    if target[:3] in API.Contracts.Indexs.__dict__:\n", "        return API.Contracts.Indexs[target[:3]][target]\n\t    elif target[:3] in API.Contracts.Futures.__dict__:\n\t        return API.Contracts.Futures[target[:3]][target]\n\t    elif target[:3] in API.Contracts.Options.__dict__:\n\t        return API.Contracts.Options[target[:3]][target]\n\t    return API.Contracts.Stocks[target]\n"]}
{"filename": "trader/utils/watchlist.py", "chunked_list": ["import pandas as pd\n\tfrom datetime import datetime\n\tfrom collections import namedtuple\n\tfrom ..config import PATH\n\tfrom . import get_contract\n\tfrom .time import TimeTool\n\tfrom .file import FileHandler\n\tfrom .database import db\n\tfrom .database.tables import Watchlist\n\tclass WatchListTool(TimeTool, FileHandler):\n", "    def __init__(self, account_name):\n\t        self.account_name = account_name\n\t        self.MatchAccount = Watchlist.account == self.account_name\n\t        self.watchlist_file = f'watchlist_{account_name}'\n\t        self.watchlist = self.get_watchlist()\n\t    def get_watchlist(self):\n\t        \"\"\"Load watchlist data\"\"\"\n\t        if db.HAS_DB:\n\t            df = db.query(Watchlist, Watchlist.account == self.account_name)\n\t            return df\n", "        df = self.read_table(\n\t            filename=f'{PATH}/stock_pool/{self.watchlist_file}.csv',\n\t            df_default=pd.DataFrame(columns=[\n\t                'account', 'market', 'code', 'buyday',\n\t                'bsh', 'position', 'strategy'\n\t            ])\n\t        )\n\t        df.code = df.code.astype(str)\n\t        df.buyday = pd.to_datetime(df.buyday.astype(str))\n\t        df.position = df.position.fillna(100)\n", "        df.strategy = df.strategy.fillna('Unknown')\n\t        return df\n\t    def _append_watchlist(self, market: str, orderinfo: namedtuple, quotes: dict, strategy_pool: dict = None):\n\t        '''Add new stock data to watchlist'''\n\t        if isinstance(orderinfo, str):\n\t            # Manual trading\n\t            target = orderinfo\n\t            position = 100\n\t            cost_price = quotes\n\t            check_quantity = True\n", "        else:\n\t            # Auto trading\n\t            target = orderinfo.target\n\t            position = abs(orderinfo.pos_target)\n\t            cost_price = quotes.NowTargets[target]['price']\n\t            check_quantity = orderinfo.quantity != 0\n\t        if target not in self.watchlist.code.values and check_quantity:\n\t            data = {\n\t                'account': self.account_name,\n\t                'market': market,\n", "                'code': target,\n\t                'buyday': datetime.now(),\n\t                'bsh': cost_price,\n\t                'position': position,\n\t                'strategy': strategy_pool[target] if strategy_pool and target in strategy_pool else 'unknown'\n\t            }\n\t            self.watchlist = pd.concat([self.watchlist, pd.DataFrame([data])])\n\t            if db.HAS_DB:\n\t                db.add_data(Watchlist, **data)\n\t    def init_watchlist(self, stocks: pd.DataFrame, strategy_pool: dict):\n", "        stocks = stocks[~stocks.code.isin(self.watchlist.code)].code.values\n\t        # Add stocks to watchlist if it is empty.\n\t        if not self.watchlist.shape[0] and stocks.shape[0]:\n\t            for stock in stocks:\n\t                cost_price = get_contract(stock).reference\n\t                self._append_watchlist(\n\t                    'Stocks', stock, cost_price, strategy_pool)\n\t    def update_watchlist(self, codeList: list):\n\t        '''Update watchlist data when trading time is closed'''\n\t        # Update watchlist position if there's any stock both exists\n", "        # in stock account and watchlist but position <= 0.\n\t        condi1 = self.watchlist.code.isin(codeList)\n\t        condi2 = (self.watchlist.position <= 0)\n\t        self.watchlist.loc[~condi1 | condi2, 'position'] = 0\n\t        self.watchlist.loc[condi1 & condi2, 'position'] = 100\n\t        if db.HAS_DB:\n\t            code1 = self.watchlist[~condi1 | condi2].code.values\n\t            condition = Watchlist.code.in_(code1), self.MatchAccount\n\t            db.update(Watchlist, {'position': 0}, *condition)\n\t            code2 = self.watchlist[condi1 & condi2].code.values\n", "            condition = Watchlist.code.in_(code2), self.MatchAccount\n\t            db.update(Watchlist, {'position': 100}, condition)\n\t        self.remove_from_watchlist()\n\t    def remove_from_watchlist(self):\n\t        '''Delete Watchlist data where position <= 0.'''\n\t        self.watchlist = self.watchlist[self.watchlist.position > 0]\n\t        if db.HAS_DB:\n\t            db.delete(Watchlist, Watchlist.position <= 0, self.MatchAccount)\n\t    def update_watchlist_position(self, order: namedtuple, quotes: dict, strategy_pool: dict = None):\n\t        target = order.target\n", "        position = order.pos_target\n\t        if target in self.watchlist.code.values:\n\t            condition = self.watchlist.code == target\n\t            if order.action_type == 'Open':\n\t                self.watchlist.loc[condition, 'position'] += position\n\t            else:\n\t                self.watchlist.loc[condition, 'position'] -= position\n\t            if db.HAS_DB and condition.sum():\n\t                position = self.watchlist.loc[condition, 'position'].values[0]\n\t                condition = Watchlist.code.in_([target]), self.MatchAccount\n", "                db.update(Watchlist, {'position': position}, *condition)\n\t            self.remove_from_watchlist()\n\t        else:\n\t            market = 'Stocks' if not order.octype else 'Futures'\n\t            self._append_watchlist(market, order, quotes, strategy_pool)\n\t    def save_watchlist(self, df: pd.DataFrame):\n\t        if db.HAS_DB:\n\t            codes = db.query(Watchlist.code, self.MatchAccount).code.values\n\t            tb = df[~df.code.isin(codes)]\n\t            db.dataframe_to_DB(tb, Watchlist)\n", "        else:\n\t            self.save_table(\n\t                df=df,\n\t                filename=f'{PATH}/stock_pool/{self.watchlist_file}.csv',\n\t                saveEmpty=True\n\t            )\n"]}
{"filename": "trader/utils/orders.py", "chunked_list": ["import time\n\timport logging\n\timport pandas as pd\n\tfrom collections import namedtuple\n\tfrom ..config import API, PATH\n\tfrom .file import FileHandler\n\tfrom .database import db\n\tfrom .database.tables import TradingStatement\n\tclass OrderTool(FileHandler):\n\t    OrderInfo = namedtuple(\n", "        typename=\"OrderInfo\",\n\t        field_names=[\n\t            'action_type',\n\t            'action', 'target', 'quantity',\n\t            'order_cond', 'octype', 'pos_target',\n\t            'pos_balance', 'daytrade_short', 'reason'\n\t        ],\n\t        defaults=['', '', '', 0, '', '', 0, 0, False, '']\n\t    )\n\t    MsgOrder = namedtuple(\n", "        typename='MsgOrder',\n\t        field_names=['operation', 'order', 'status', 'contract']\n\t    )\n\t    OrderTable = pd.DataFrame(columns=[\n\t        'Time', 'market', 'code', 'action',\n\t        'price', 'quantity', 'amount',\n\t        'order_cond', 'order_lot', 'leverage',\n\t        'op_type', 'account_id', 'msg',\n\t    ])\n\t    def get_sell_quantity(self, content: namedtuple, market: str = 'Stocks'):\n", "        '''根據庫存, 剩餘部位比例, 賣出比例，反推賣出量(張)'''\n\t        if market == 'Stocks':\n\t            q_before = int(content.quantity/1000)\n\t            condition = content.pos_balance > 0 and content.quantity >= 1000\n\t        else:\n\t            q_before = content.quantity\n\t            condition = content.pos_balance > 0 and content.quantity != 0\n\t        if condition:\n\t            quantity = int(q_before/content.pos_balance *\n\t                           abs(content.pos_target))\n", "            quantity = 1000*max(min(quantity, q_before), 1)\n\t            return max(round(quantity/1000), 1)\n\t        return q_before\n\t    def check_order_status(self, order_result):\n\t        '''確認委託狀態'''\n\t        time.sleep(0.1)\n\t        API.update_status(API.stock_account)\n\t        status = order_result.status.status\n\t        if status not in ['PreSubmitted', 'Filled']:\n\t            logging.warning('order not submitted/filled')\n", "    def appendOrder(self, order_data: dict):\n\t        '''Add new order data to OrderTable'''\n\t        self.OrderTable = pd.concat([\n\t            self.OrderTable,\n\t            pd.DataFrame([order_data])\n\t        ])\n\t    def deleteOrder(self, code: str):\n\t        '''Delete order data from OrderTable'''\n\t        self.OrderTable = self.OrderTable[self.OrderTable.code != code]\n\t    def checkEnoughToPlace(self, market: str, target: str):\n", "        '''Check if current placed amount is under target limit.'''\n\t        df = self.OrderTable[self.OrderTable.market == market]\n\t        return df.amount.sum() < target\n\t    def filterOrderTable(self, market: str):\n\t        '''Filter OrderTable by market'''\n\t        return self.OrderTable[self.OrderTable.market == market].copy()\n\t    def output_statement(self, filename: str = ''):\n\t        '''Export trading statement'''\n\t        if db.HAS_DB:\n\t            self.OrderTable.order_cond.fillna('', inplace=True)\n", "            self.OrderTable.order_lot.fillna('', inplace=True)\n\t            self.OrderTable.leverage.fillna(-1, inplace=True)\n\t            self.OrderTable.op_type.fillna('', inplace=True)\n\t            db.dataframe_to_DB(self.OrderTable, TradingStatement)\n\t        else:\n\t            statement = self.read_and_concat(filename, self.OrderTable)\n\t            self.save_table(statement, filename)\n\t    def read_statement(self, account: str = ''):\n\t        '''Import trading statement'''\n\t        if db.HAS_DB:\n", "            df = db.query(\n\t                TradingStatement,\n\t                TradingStatement.account_id == account\n\t            )\n\t        else:\n\t            filename = f\"{PATH}/stock_pool/statement_{account.split('-')[-1]}.csv\"\n\t            df = self.read_table(filename, df_default=self.OrderTable)\n\t            df = df[df.account_id == account]\n\t            df = df.astype({\n\t                'price': float,\n", "                'quantity': float,\n\t                'amount': float,\n\t                'leverage': float\n\t            })\n\t            df.Time = pd.to_datetime(df.Time)\n\t        df = df.drop_duplicates()\n\t        return df\n"]}
{"filename": "trader/utils/file.py", "chunked_list": ["import os\n\timport numpy as np\n\timport pandas as pd\n\tfrom io import BytesIO\n\tfrom zipfile import ZipFile\n\tfrom datetime import datetime\n\tfrom . import progress_bar\n\tfrom ..config import PATH, TODAY\n\tclass FileHandler:\n\t    def create_folder(self, path):\n", "        if not os.path.exists(path):\n\t            os.makedirs(path)\n\t    def listdir(self, dir_path: str, pattern: str = '', filter_out: list = ['desktop.ini']):\n\t        if pattern:\n\t            result = [f for f in os.listdir(dir_path) if pattern in f]\n\t        else:\n\t            result = os.listdir(dir_path)\n\t        return [f for f in result if f not in filter_out]\n\t    def list_files(self, dir_path: str, pattern: str = '', filter_out: list = ['desktop.ini']):\n\t        file_list = []\n", "        for root, _, files in os.walk(dir_path):\n\t            for file in files:\n\t                if pattern in file and file not in filter_out:\n\t                    file_list.append(os.path.join(root, file))\n\t        return file_list\n\t    def is_in_dir(self, filename: str, dir_path: str):\n\t        '''Check if a filename is in dir_path.'''\n\t        return filename in os.listdir(dir_path)\n\t    def rpt_2_df(self, file: str):\n\t        '''Conver .rpt file to Pandas DataFrame'''\n", "        f = file.readlines()\n\t        f = [\n\t            t.decode('big5').rstrip('\\r\\n') if isinstance(t, bytes) else t.rstrip('\\n') for t in f]\n\t        f = [t.replace(' ', '').split(',') for t in f]\n\t        return pd.DataFrame(f[1:], columns=f[0])\n\t    def unzip_file(self, filename: str, filters: list = [], filepath=''):\n\t        '''解壓縮檔案並匯出'''\n\t        if isinstance(filename, BytesIO):\n\t            folders = ZipFile(filename)\n\t        else:\n", "            folders = ZipFile(f'{filename}.zip')\n\t        names = folders.namelist()\n\t        N = len(names)\n\t        if N > 1 and isinstance(filename, str):\n\t            self.create_folder(filename)\n\t        for i, folder in enumerate(names):\n\t            if any(f in filters for f in [folder, folder.rstrip('/'), folder[:4]]):\n\t                continue\n\t            if '.zip' in folder:\n\t                folderPath = f\"{filename}/{folder.replace('.zip', '')}\"\n", "                print(f\"\\n{folder.replace('.zip', '')}\")\n\t                self.create_folder(folderPath)\n\t                zfiledata = BytesIO(folders.read(folder))\n\t                self.unzip_file(zfiledata, filepath=folderPath)\n\t            elif '.rpt' in folder:\n\t                file = BytesIO(folders.read(folder))\n\t                file = self.rpt_2_df(file)\n\t                folderPath = filepath if filepath else (filename if N > 1 else '.')\n\t                self.save_table(file, f\"{folderPath}/{folder.replace('.rpt', '.csv')}\")\n\t                progress_bar(N, i)\n", "    def remove_files(self, dirpath: str, files: list = None, pattern: str = ''):\n\t        if not files:\n\t            files = self.listdir(dirpath, pattern=pattern)\n\t        for f in files:\n\t            os.remove(f'{dirpath}/{f}')\n\t    def save_table(self, df: pd.DataFrame, filename: str, saveEmpty=False):\n\t        if df.shape[0] or saveEmpty:\n\t            if '.csv' in filename:\n\t                df.to_csv(filename, index=False, encoding='utf-8-sig')\n\t            elif '.xlsx' in filename:\n", "                df.to_excel(filename, index=False, encoding='utf-8-sig')\n\t            else:\n\t                df.to_pickle(filename)\n\t    def read_table(self, filename: str, df_default: pd.DataFrame = None):\n\t        if os.path.exists(filename):\n\t            if '.pkl' in filename:\n\t                tb = pd.read_pickle(filename)\n\t            elif '.xlsx' in filename:\n\t                tb = pd.read_excel(filename)\n\t            else:\n", "                try:\n\t                    tb = pd.read_csv(filename)\n\t                except:\n\t                    tb = pd.read_csv(\n\t                        filename, low_memory=False, encoding='big5')\n\t        elif isinstance(df_default, pd.DataFrame):\n\t            tb = df_default\n\t        else:\n\t            tb = pd.DataFrame()\n\t        return tb\n", "    def read_and_concat(self, filename: str, df: pd.DataFrame):\n\t        tb = self.read_table(filename)\n\t        tb = pd.concat([tb, df]).reset_index(drop=True)\n\t        return tb\n\t    def read_tables_in_folder(self, dir_path: str, pattern: str = None, **kwargs):\n\t        files = self.listdir(dir_path, pattern=pattern)\n\t        # filter files by time interval\n\t        start = kwargs.get('start')\n\t        if start:\n\t            if not isinstance(start, pd.Timestamp):\n", "                start = pd.to_datetime(start)\n\t            y1, m1 = start.year, start.month\n\t            files = [\n\t                f for f in files if int(f[:4]) >= y1 and int(f[5:7]) >= m1]\n\t        end = kwargs.get('end')\n\t        if end:\n\t            if not isinstance(end, pd.Timestamp):\n\t                end = pd.to_datetime(end)\n\t            y2, m2 = end.year, end.month\n\t            files = [\n", "                f for f in files if int(f[:4]) <= y2 and int(f[5:7]) <= m2]\n\t        # read tables\n\t        N = len(files)\n\t        if N:\n\t            df = np.array([None]*N)\n\t            for i, f in enumerate(files):\n\t                df[i] = self.read_table(f'{dir_path}/{f}')\n\t                progress_bar(N, i, status=f'[{f}]')\n\t            df = pd.concat(df).reset_index(drop=True)\n\t            return df\n", "        return pd.DataFrame()\n\t    def read_tick_data(self, market: str, **kwargs):\n\t        '''\n\t        合併逐筆交易明細表。以year為主，合併該年度的資料，可另外指定要合併的區間\n\t        '''\n\t        dir_path = f'{PATH}/ticks/{market.lower()}'\n\t        files = self.list_files(dir_path)\n\t        # Filter files by time interval\n\t        start = kwargs.get('start')\n\t        if start:\n", "            if not isinstance(start, pd.Timestamp):\n\t                start = pd.to_datetime(start)\n\t        else:\n\t            start = pd.to_datetime('1970-01-01')\n\t        end = kwargs.get('end')\n\t        if end:\n\t            if not isinstance(end, pd.Timestamp):\n\t                end = pd.to_datetime(end)\n\t        else:\n\t            end = TODAY\n", "        df = []\n\t        for f in files:\n\t            date = f.split('\\\\')[-1][:-4].split('_')[1:]\n\t            date = datetime(*(int(d) for d in date))\n\t            if start <= date <= end:\n\t                df.append(f)\n\t        N = len(df)\n\t        for i, f in enumerate(df):\n\t            df[i] = self.read_table(f)\n\t            status = f.split('\\\\')[-1]\n", "            progress_bar(N, i, status=f'[{status}]')\n\t        df = pd.concat(df)\n\t        return df\n"]}
{"filename": "trader/utils/kbar.py", "chunked_list": ["import re\n\timport logging\n\timport pandas as pd\n\tfrom typing import List, Dict\n\tfrom datetime import datetime, timedelta\n\tfrom ..config import API, PATH, TODAY, TODAY_STR, TimeStartStock, TimeEndStock\n\tfrom ..config import KbarFeatures\n\tfrom ..indicators.signals import TechnicalSignals\n\tfrom . import get_contract\n\tfrom .time import TimeTool\n", "from .file import FileHandler\n\ttry:\n\t    from ..scripts.features import KBarFeatureTool\n\texcept:\n\t    logging.warning('Cannot import KBar Scripts from package.')\n\t    KBarFeatureTool = None\n\tclass KBarTool(TechnicalSignals, TimeTool, FileHandler):\n\t    def __init__(self, kbar_start_day=''):\n\t        self.set_kbar_scripts(KBarFeatureTool)\n\t        self.daysdata = self.__set_daysdata(kbar_start_day)\n", "        self.maps = {\n\t            'name': 'first',\n\t            'Open': 'first',\n\t            'High': 'max',\n\t            'Low': 'min',\n\t            'Close': 'last',\n\t            'Volume': 'sum',\n\t            'Amount': 'sum'\n\t        }\n\t        self.kbar_columns = [\n", "            'name', 'Time',\n\t            'Open', 'High', 'Low', 'Close', 'Volume', 'Amount'\n\t        ]\n\t        self.featureFuncs = {\n\t            '1T': self.add_K1min_feature,\n\t            '2T': self.add_K2min_feature,\n\t            '5T': self.add_K5min_feature,\n\t            '15T': self.add_K15min_feature,\n\t            '30T': self.add_K30min_feature,\n\t            '60T': self.add_K60min_feature,\n", "            '1D': self.add_KDay_feature,\n\t        }\n\t        self.KBars = {\n\t            freq: pd.DataFrame(columns=self.kbar_columns) for freq in self.featureFuncs\n\t        }\n\t    def __set_daysdata(self, kbar_start_day):\n\t        '''\n\t        設定觀察K棒數(N個交易日)\n\t        若有設定最近崩盤日, 則觀察K棒數 = 上次崩盤日開始算N個交易日\n\t        若沒有設最近崩盤日, 則觀察K棒數 = 35\n", "        參數 - kbar_start_day: 觀察起始日，格式為 yyyy-mm-dd\n\t        '''\n\t        if not kbar_start_day or TODAY < kbar_start_day:\n\t            return 35\n\t        return max((TODAY - kbar_start_day).days, 35)\n\t    def add_KDay_feature(self, df: pd.DataFrame):\n\t        return df\n\t    def add_K60min_feature(self, df: pd.DataFrame):\n\t        return df\n\t    def add_K30min_feature(self, df: pd.DataFrame):\n", "        return df\n\t    def add_K15min_feature(self, df: pd.DataFrame):\n\t        return df\n\t    def add_K5min_feature(self, df: pd.DataFrame):\n\t        return df\n\t    def add_K2min_feature(self, df: pd.DataFrame):\n\t        return df\n\t    def add_K1min_feature(self, df: pd.DataFrame):\n\t        return df\n\t    def on_set_feature_function(self, kbar_scripts, attrName):\n", "        def wrapper(func):\n\t            if hasattr(kbar_scripts, attrName):\n\t                setattr(self, attrName, func)\n\t            return func\n\t        return wrapper\n\t    def set_kbar_scripts(self, kbar_scripts: object = None):\n\t        '''設定K線特徵腳本'''\n\t        if kbar_scripts:\n\t            kbar_scripts = kbar_scripts()\n\t            @self.on_set_feature_function(kbar_scripts, 'add_K1min_feature')\n", "            def _add_K1min_feature(df):\n\t                return kbar_scripts.add_K1min_feature(df)\n\t            @self.on_set_feature_function(kbar_scripts, 'add_K2min_feature')\n\t            def _add_K2min_feature(df):\n\t                return kbar_scripts.add_K2min_feature(df)\n\t            @self.on_set_feature_function(kbar_scripts, 'add_K5min_feature')\n\t            def _add_K5min_feature(df):\n\t                return kbar_scripts.add_K5min_feature(df)\n\t            @self.on_set_feature_function(kbar_scripts, 'add_K15min_feature')\n\t            def _add_K15min_feature(df):\n", "                return kbar_scripts.add_K15min_feature(df)\n\t            @self.on_set_feature_function(kbar_scripts, 'add_K30min_feature')\n\t            def _add_K30min_feature(df):\n\t                return kbar_scripts.add_K30min_feature(df)\n\t            @self.on_set_feature_function(kbar_scripts, 'add_K60min_feature')\n\t            def _add_K60min_feature(df):\n\t                return kbar_scripts.add_K60min_feature(df)\n\t            @self.on_set_feature_function(kbar_scripts, 'add_KDay_feature')\n\t            def _add_KDay_feature(df):\n\t                return kbar_scripts.add_KDay_feature(df)\n", "    def _scale_converter(self, scale: str):\n\t        '''Convert scale format from str to int'''\n\t        return int(re.findall('\\d+', scale)[0])\n\t    def tbKBar(self, stockid: str, start: str, end: str = None):\n\t        '''取得k棒資料'''\n\t        if not end:\n\t            end = TODAY_STR\n\t        contract = get_contract(stockid)\n\t        # TODO: fix AttributeError\n\t        try:\n", "            kbars = API.kbars(contract, start=start, end=end, timeout=60000)\n\t        except AttributeError:\n\t            logging.exception(f'tbKBar({stockid}) Catch an Exception:')\n\t            kbars = {'ts': []}\n\t        tb = pd.DataFrame({**kbars})\n\t        tb.ts = pd.to_datetime(tb.ts)\n\t        tb.insert(0, 'name', stockid)\n\t        tb.name = tb.name.replace('OTC101', '101').replace('TSE001', '001')\n\t        tb = tb.rename(columns={'ts': 'Time'})\n\t        return tb\n", "    def history_kbars(self, stockids: List[str], daysdata: int = 0):\n\t        '''Get history kbar data'''\n\t        now = datetime.now()\n\t        ndays = daysdata if daysdata else self.daysdata\n\t        for stockid in stockids:\n\t            tb = self.tbKBar(stockid, self._strf_timedelta(TODAY, ndays))\n\t            for scale in self.featureFuncs:\n\t                kbar = self.convert_kbar(tb, scale)\n\t                if scale == '1D':\n\t                    kbar = kbar[kbar.Time.dt.date.astype(str) != TODAY_STR]\n", "                else:\n\t                    scale_ = self._scale_converter(scale)\n\t                    n = self.count_n_kbars(TimeStartStock, now, scale_)\n\t                    time_ = TimeStartStock + timedelta(minutes=scale_*n)\n\t                    kbar = kbar[kbar.Time < time_]\n\t                self.KBars[scale] = self.concatKBars(self.KBars[scale], kbar)\n\t        for scale, kbar in self.KBars.items():\n\t            kbar = self.featureFuncs[scale](kbar)\n\t            self.KBars[scale] = kbar\n\t    def convert_kbar(self, tb: pd.DataFrame, scale='60T'):\n", "        '''將1分K轉換成其他週期K線資料'''\n\t        if tb.shape[0]:\n\t            return (\n\t                tb.set_index('Time')\n\t                .groupby('name')\n\t                .resample(scale, closed='left', label='left')\n\t                .apply(self.maps)\n\t                .reset_index(level='Time')\n\t                .reset_index(drop=True)\n\t                .dropna()\n", "            )\n\t        return tb\n\t    def revert_dividend_price(self, df: pd.DataFrame, dividends: Dict[str, float]):\n\t        '''還原除權息股價'''\n\t        if df.shape[0]:\n\t            has_dividend = df.name.isin(dividends.keys())\n\t            if has_dividend.sum():\n\t                _dividends = df[has_dividend].name.map(dividends)\n\t                for col in ['Open', 'High', 'Low', 'Close']:\n\t                    df.loc[has_dividend, col] += _dividends\n", "        return df\n\t    def tick_to_df_targets(self, q_all: dict, q_now: dict):\n\t        '''將個股tick資料轉為K棒'''\n\t        if not q_all and not q_now:\n\t            return pd.DataFrame()\n\t        if any([] in q_all[s].values() for s in q_all):\n\t            q_all = {s: q_all[s] for s in q_all if [] not in q_all[s].values()}\n\t            q_all.update(\n\t                {s: {k: [v] for k, v in q_now[s].items()} for s in q_now if s not in q_all})\n\t        tb = pd.DataFrame(q_all).T\n", "        if not tb.shape[1]:\n\t            return pd.DataFrame()\n\t        tb['Time'] = pd.to_datetime(datetime.now())\n\t        tb['Open'] = tb.price.apply(lambda x: x[0])\n\t        tb['High'] = tb.price.apply(max)\n\t        tb['Low'] = tb.price.apply(min)\n\t        tb['Close'] = tb.price.apply(lambda x: x[-1])\n\t        tb.volume = tb.volume.apply(sum)\n\t        tb['Amount'] = tb.amount.apply(lambda x: x[-1])\n\t        tb = tb.reset_index().rename(\n", "            columns={'index': 'name', 'volume': 'Volume'})\n\t        return tb[self.kbar_columns]\n\t    def tick_to_df_index(self, quotes: list):\n\t        '''將指數tick資料轉為K棒'''\n\t        if not quotes:\n\t            return pd.DataFrame()\n\t        try:\n\t            tb = pd.DataFrame(quotes)\n\t            tb = tb.rename(columns={'Code': 'name', 'Date': 'date'})\n\t            tb['Time'] = pd.to_datetime(datetime.now())\n", "            tb['Open'] = tb.Close.values[0]\n\t            tb['High'] = tb.Close.max()\n\t            tb['Low'] = tb.Close.min()\n\t            tb['Close'] = tb.Close.values[-1]\n\t            tb.Volume = tb.Volume.sum()\n\t            tb['Amount'] = tb.Amount.sum()\n\t            tb = tb[self.kbar_columns]\n\t            return tb.drop_duplicates(['name', 'Time'])\n\t        except:\n\t            return pd.DataFrame()\n", "    def concatKBars(self, df1: pd.DataFrame, df2: pd.DataFrame):\n\t        '''合併K棒資料表'''\n\t        return pd.concat([df1, df2]).sort_values(['name', 'Time']).reset_index(drop=True)\n\t    def updateKBars(self, scale: str):\n\t        '''檢查並更新K棒資料表'''\n\t        _scale = self._scale_converter(scale)\n\t        t1 = datetime.now()\n\t        t2 = t1 - timedelta(minutes=_scale + .5)\n\t        if not self.KBars[scale][self.KBars[scale].Time >= t2].shape[0]:\n\t            tb = self.KBars['1T'].copy()\n", "            tb = tb[(tb.Time >= t2) & (tb.Time < t1)]\n\t            if tb.shape[0]:\n\t                tb = self.convert_kbar(tb, scale=scale)\n\t                for col in KbarFeatures[scale]:\n\t                    tb[col] = None\n\t                kbar = self.concatKBars(self.KBars[scale], tb)\n\t                self.KBars[scale] = self.featureFuncs[scale](kbar)\n\t    def _update_K1(self, dividends: dict, quotes):\n\t        '''每隔1分鐘更新1分K'''\n\t        def concat_df(df):\n", "            if df.shape[0]:\n\t                self.KBars['1T'] = pd.concat(\n\t                    [self.KBars['1T'], df]).sort_values(['name', 'Time']).reset_index(drop=True)\n\t        if TimeStartStock <= datetime.now() <= TimeEndStock:\n\t            for i in quotes.AllIndex:\n\t                tb = self.tick_to_df_index(quotes.AllIndex[i])\n\t                concat_df(tb)\n\t        df = self.tick_to_df_targets(quotes.AllTargets, quotes.NowTargets)\n\t        df = self.revert_dividend_price(df, dividends)\n\t        concat_df(df)\n", "class TickDataProcesser(TimeTool, FileHandler):\n\t    '''轉換期貨逐筆交易'''\n\t    def convert_daily_tick(self, date: str, scale: str):\n\t        ymd = date.split('-')\n\t        m = f'Daily_{ymd[0]}_{ymd[1]}'\n\t        folder = f'{PATH}/ticks/futures/{ymd[0]}/{m}'\n\t        df = self.read_table(f'{folder}/{m}_{ymd[2]}.csv')\n\t        if df.shape[0]:\n\t            df = self.preprocess_futures_tick(df)\n\t            df = self.convert_tick_2_kbar(df, scale, period='all')\n", "        return df\n\t    def preprocess_futures_tick(self, df, underlying='TX'):\n\t        df = df.rename(columns={\n\t            '商品代號': 'name',\n\t            '成交價格': 'Price',\n\t            '成交數量(B+S)': 'Quantity',\n\t            '開盤集合競價 ': 'Simtrade',\n\t            '近月價格': 'PriceOld',\n\t            '遠月價格': 'PriceNew',\n\t            '到期月份(週別)': 'DueMonth'\n", "        })\n\t        df.name = df.name.apply(lambda x: x.replace(' ', ''))\n\t        df.DueMonth = df.DueMonth.apply(\n\t            lambda x: x.replace(' ', '').split('/'))\n\t        df.PriceOld = df.PriceOld.replace('-', 0).astype(float)\n\t        df.PriceNew = df.PriceNew.replace('-', 0).astype(float)\n\t        if underlying != 'all':\n\t            df = df[df.name == underlying].reset_index(drop=True)\n\t        df['Time'] = pd.to_datetime(df.成交日期.astype(\n\t            str) + df.成交時間.astype(str).str.zfill(6))\n", "        df['date'] = pd.to_datetime(df.Time.dt.date)\n\t        df.Simtrade = df.Simtrade.apply(lambda x: True if x == '*' else False)\n\t        df['DueMonthOld'] = df.DueMonth.apply(lambda x: x[0])\n\t        df['DueMonthNew'] = df.DueMonth.apply(lambda x: x[-1])\n\t        df['period'] = 2\n\t        df.loc[df.Time.dt.hour.isin(range(8, 14)), 'period'] = 1\n\t        # 處理跨月委託交易(轉倉)\n\t        # df['DueMonth'] = df['DueMonth'].apply(lambda x: x.split('/'))\n\t        # df.Price += df.PriceOld\n\t        # df = df.explode(['DueMonth'])\n", "        df = df.drop(['成交日期', '成交時間', 'date', 'DueMonth'], axis=1)\n\t        return df\n\t    def convert_tick_2_kbar(self, df, scale, period='day_only'):\n\t        '''將逐筆資料轉為K線資料。period = day_only(日盤), night_only(夜盤), all(日盤+夜盤)'''\n\t        df['Open'] = df['High'] = df['Low'] = df['Close'] = df.Price\n\t        df['Volume'] = df['Quantity']/2\n\t        df['Amount'] = df.Close*df.Volume\n\t        due_month = pd.to_datetime(df.Time.dt.date).apply(self.GetDueMonth)\n\t        df = df[\n\t            (df.DueMonthOld == df.DueMonthNew) &\n", "            (df.DueMonthOld == due_month)\n\t        ]\n\t        if period == 'day_only':\n\t            df = df[df.period == 1]\n\t        df = KBarTool().convert_kbar(df, scale=scale)\n\t        return df\n"]}
{"filename": "trader/utils/cipher.py", "chunked_list": ["from cryptography.hazmat.primitives.asymmetric import padding\n\tfrom cryptography.hazmat.primitives import hashes\n\tfrom cryptography.hazmat.backends import default_backend\n\tfrom cryptography.hazmat.primitives import serialization\n\t# ssh-keygen -P \"\" -t rsa -b 4096 -m pem -f sinopac\n\t# ssh-keygen - f sinopac.pub -e -m pem > sinopac_public_key.pem\n\tclass CipherTool:\n\t    def __init__(self, decrypt: bool = True, encrypt: bool = True, **kwargs):\n\t        self.DECRYPT = decrypt\n\t        self.ENCRYPT = encrypt\n", "        self.__load_keys(**kwargs)\n\t    def __load_keys(self, **kwargs):\n\t        key_path = kwargs['key_path'] if 'key_path' in kwargs else \"./lib/ckey\"\n\t        if self.ENCRYPT:\n\t            try:\n\t                with open(f\"{key_path}/sinopac_public.pem\", \"rb\") as f:\n\t                    self._PUBLICKEY_ = serialization.load_pem_public_key(\n\t                        f.read(), backend=default_backend()\n\t                    )\n\t            except FileNotFoundError:\n", "                print(\n\t                    f'FileNotFoundError: {key_path}/sinopac_public.pem. Texts will not be encrypted.')\n\t                self._PUBLICKEY_ = None\n\t        if self.DECRYPT:\n\t            try:\n\t                with open(f\"{key_path}/sinopac_private.pem\", \"rb\") as f:\n\t                    self._PRIVATEKEY_ = serialization.load_pem_private_key(\n\t                        f.read(), None, backend=default_backend()\n\t                    )\n\t            except FileNotFoundError:\n", "                print(\n\t                    f'FileNotFoundError: {key_path}/sinopac_private.pem. Texts will not be decrypted.')\n\t                self._PRIVATEKEY_ = None\n\t    def encrypt(self, msg: str):\n\t        '''Encrypt text messages.'''\n\t        if self.ENCRYPT and self._PUBLICKEY_:\n\t            return self._PUBLICKEY_.encrypt(\n\t                msg.encode(),\n\t                padding.OAEP(\n\t                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n", "                    algorithm=hashes.SHA256(),\n\t                    label=None\n\t                )\n\t            ).hex()\n\t        print(\"Can't encrypt without public key\")\n\t        return msg\n\t    def decrypt(self, msg: str):\n\t        '''Decrypt text messages.'''\n\t        if self.DECRYPT and self._PRIVATEKEY_:\n\t            if not isinstance(msg, bytes):\n", "                msg = bytes.fromhex(msg)\n\t            return self._PRIVATEKEY_.decrypt(\n\t                msg,\n\t                padding.OAEP(\n\t                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n\t                    algorithm=hashes.SHA256(),\n\t                    label=None\n\t                )\n\t            ).decode()\n\t        print(\"Can't decrypt without private key\")\n", "        return msg\n\tif __name__ == \"__main__\":\n\t    ct = CipherTool()\n\t    msg = 'Hello World'\n\t    encrypted = ct.encrypt(msg)\n\t    print(encrypted)\n"]}
{"filename": "trader/utils/strategy.py", "chunked_list": ["import logging\n\timport pandas as pd\n\tfrom datetime import datetime\n\tfrom collections import namedtuple\n\tfrom .. import file_handler\n\tfrom ..config import PATH, TODAY_STR, TimeTransferFutures, StrategyList\n\tfrom ..utils.database import db\n\tfrom ..utils.database.tables import PutCallRatioList, ExDividendTable\n\tclass StrategyTool:\n\t    def __init__(self, **kwargs):\n", "        self.set_config(**kwargs)\n\t        self.Action = namedtuple(\n\t            typename=\"Action\",\n\t            field_names=['position', 'reason', 'msg', 'price'],\n\t            defaults=[0, '', '', 0]\n\t        )\n\t        self.pc_ratio = self.get_put_call_ratio()\n\t        self.dividends = self.get_ex_dividends_list()\n\t        self.STRATEGIES = pd.DataFrame(\n\t            columns=['name', 'long_weight', 'short_weight']\n", "        )\n\t        self.Funcs = {\n\t            'Open': {  # action\n\t                '當沖': {},  # tradeType\n\t                '非當沖': {}\n\t            },\n\t            'Close': {\n\t                '當沖': {},\n\t                '非當沖': {}\n\t            }\n", "        }\n\t        self.QuantityFunc = {}\n\t    def set_config(self, **kwargs):\n\t        self.account_name = kwargs.get('account_name', 'unknown')\n\t        self.hold_day = kwargs.get('hold_day', 20)\n\t        self.is_simulation = kwargs.get('is_simulation', True)\n\t        self.stock_limit_type = kwargs.get('stock_limit_type', 'Constant')\n\t        self.futures_limit_type = kwargs.get('futures_limit_type', 'Constant')\n\t        self.stock_limit_long = kwargs.get('stock_limit_long', 0)\n\t        self.stock_limit_short = kwargs.get('stock_limit_short', 0)\n", "        self.futures_limit = kwargs.get('futures_limit', 0)\n\t    def mapFunction(self, action: str, tradeType: str, strategy: str):\n\t        has_action = action in self.Funcs\n\t        has_tradeType = tradeType in self.Funcs[action]\n\t        has_strategy = strategy in self.Funcs[action][tradeType]\n\t        if has_action and has_tradeType and has_strategy:\n\t            return self.Funcs[action][tradeType][strategy]\n\t        return self.__DoNothing__\n\t    def mapQuantities(self, strategy: str):\n\t        def default_quantity(**kwargs):\n", "            return 1, 499\n\t        if strategy in self.QuantityFunc:\n\t            return self.QuantityFunc[strategy]\n\t        return default_quantity\n\t    def __DoNothing__(self, **kwargs):\n\t        return self.Action()\n\t    def update_indicators(self, now: datetime, kbars: dict):\n\t        pass\n\t    def setNStockLimitLong(self, KBars: dict = None):\n\t        '''\n", "        Set the number limit of securities of a portfolio can hold \n\t        for a long strategy\n\t        '''\n\t        if self.is_simulation:\n\t            return 3000\n\t        elif self.stock_limit_type != 'constant':\n\t            return self.stock_limit_long\n\t        return self.stock_limit_long\n\t    def setNStockLimitShort(self, KBars: dict = None):\n\t        '''\n", "        Set the number limit of securities of a portfolio can hold \n\t        for a short strategy\n\t        '''\n\t        if self.is_simulation:\n\t            return 3000\n\t        elif self.stock_limit_type != 'constant':\n\t            return self.stock_limit_short\n\t        return self.stock_limit_short\n\t    def setNFuturesLimit(self, KBars: dict = None):\n\t        '''Set the number limit of securities of a portfolio can hold'''\n", "        return 0\n\t    def _get_value(self, data: pd.DataFrame, stockid: str, col: str):\n\t        if isinstance(data, pd.DataFrame):\n\t            tb = data[data.name == stockid]\n\t            if tb.shape[0]:\n\t                return tb[col].values[-1]\n\t            return 0\n\t        return data[stockid].get(col)\n\t    def get_ex_dividends_list(self):\n\t        '''取得當日除權息股票清單'''\n", "        if db.HAS_DB:\n\t            df = db.query(ExDividendTable)\n\t            return df[df.Date == TODAY_STR].set_index('Code').CashDividend.to_dict()\n\t        try:\n\t            df = file_handler.read_table(f'{PATH}/exdividends.csv')\n\t            df.Code = df.Code.astype(str).str.zfill(4)\n\t            return df[df.Date == TODAY_STR].set_index('Code').CashDividend.to_dict()\n\t        except:\n\t            logging.warning('==========exdividends.csv不存在，無除權息股票清單==========')\n\t            return {}\n", "    def get_put_call_ratio(self):\n\t        '''取得前一個交易日收盤後的Put-Call ratio'''\n\t        if db.HAS_DB:\n\t            pc_ratio = db.query(PutCallRatioList.PutCallRatio)\n\t            if pc_ratio.shape[0]:\n\t                return pc_ratio.PutCallRatio.values[-1]\n\t            return 100\n\t        try:\n\t            pc_ratio = file_handler.read_table(f'{PATH}/put_call_ratio.csv')\n\t            pc_ratio = pc_ratio.sort_values('Date')\n", "            return pc_ratio.PutCallRatio.values[-1]\n\t        except:\n\t            logging.warning(\n\t                '==========put_call_ratio.csv不存在，無前一交易日的Put/Call Ratio==========')\n\t            return 100\n\t    def transfer_position(self, inputs: dict, kbars: dict, **kwargs):\n\t        target = inputs['symbol']\n\t        now = datetime.now()\n\t        if now > TimeTransferFutures:\n\t            return self.Action(100, '轉倉', f'{target} 轉倉-Cover')\n", "        return self.Action()\n\t    def isLong(self, strategy: str):\n\t        '''Check if a strategy is a long strategy.'''\n\t        return strategy in StrategyList.Long\n\t    def isShort(self, strategy: str):\n\t        '''Check if a strategy is a short strategy.'''\n\t        return strategy in StrategyList.Short\n\t    def isDayTrade(self, strategy: str):\n\t        '''Check if a strategy is a day-trade strategy.'''\n\t        return strategy in StrategyList.DayTrade\n"]}
{"filename": "trader/utils/database/__init__.py", "chunked_list": ["import logging\n\tfrom sqlalchemy import create_engine\n\tfrom .sql import SQLDatabase\n\tfrom .redis import RedisTools\n\tfrom .tables import *\n\tfrom ...config import DB_NAME, DB_URL\n\tdef create_schema(schemaName):\n\t    engine = create_engine(f'mysql+pymysql://{DB_URL}')\n\t    conn = engine.connect()\n\t    if schemaName.lower() not in conn.dialect.get_schema_names(conn):\n", "        logging.warning(f'Schema {schemaName} not exist, create {schemaName}.')\n\t        engine.execute(f\"CREATE SCHEMA {schemaName}\")\n\t        conn.close()\n\t        logging.warning(f'Done creating schema {schemaName}')\n\t    # disconnect database\n\t    engine.dispose()\n\tdb = SQLDatabase()\n\tredis_tick = RedisTools(redisKey='TickData')\n\tif db.HAS_DB:\n\t    create_schema(DB_NAME)\n", "    Base.metadata.create_all(db.engine)\n\t    KBarTables = {\n\t        '1D': KBarData1D,\n\t        '1T': KBarData1T,\n\t        '30T': KBarData30T,\n\t        '60T': KBarData60T\n\t    }\n\telse:\n\t    KBarTables = {}\n"]}
{"filename": "trader/utils/database/tables.py", "chunked_list": ["from sqlalchemy import Column, Integer, FLOAT, String, text, BigInteger\n\tfrom sqlalchemy.dialects.mysql import TIMESTAMP\n\tfrom .sql import Base\n\ttime_default = text(\"CURRENT_TIMESTAMP(6)\")\n\tcollation = 'utf8mb4_unicode_ci'\n\tclass SecurityInfoStocks(Base):\n\t    __tablename__ = 'security_info_stocks'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    account = Column(String(50, collation), nullable=False, comment='帳戶代號')\n", "    market = Column(String(10, collation), nullable=False, comment='市場別')\n\t    code = Column(String(10, collation), nullable=False, comment='證券代號')\n\t    order_cond = Column(String(50, collation), nullable=False, comment='委託類型')\n\t    action = Column(String(10, collation), nullable=False, comment='買賣別')\n\t    pnl = Column(Integer, comment='未實現損益')\n\t    cost_price = Column(FLOAT(2), nullable=False, comment='成本價')\n\t    quantity = Column(Integer, nullable=False, comment='今日庫存量')\n\t    yd_quantity = Column(Integer, comment='昨日庫存量')\n\t    last_price = Column(FLOAT(2), nullable=False, comment='前一日收盤價')\n\t    create_time = Column(\n", "        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass SecurityInfoFutures(Base):\n\t    __tablename__ = 'security_info_futures'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    Account = Column(String(50, collation), nullable=False, comment='帳戶代號')\n\t    Market = Column(String(10, collation), nullable=False, comment='市場別')\n", "    Date = Column(\n\t        TIMESTAMP(fsp=6), server_default=time_default, nullable=False, comment='日期')\n\t    Code = Column(String(10, collation), nullable=False, comment='證券代號')\n\t    CodeName = Column(String(50, collation), comment='標的名稱')\n\t    OrderNum = Column(String(50, collation), comment='委託編號')\n\t    OrderBS = Column(String(50, collation), comment='買賣別')\n\t    OrderType = Column(String(50, collation), comment='委託類型')\n\t    Currency = Column(String(50, collation), comment='幣別')\n\t    paddingByte = Column(String(50, collation), comment='unknown')\n\t    Volume = Column(FLOAT(2), comment='成交量')\n", "    ContractAverPrice = Column(FLOAT(2), comment='平均合約價')\n\t    SettlePrice = Column(FLOAT(2), comment='履約價')\n\t    RealPrice = Column(FLOAT(2), comment='unknown')\n\t    FlowProfitLoss = Column(FLOAT(2), comment='unknown')\n\t    SettleProfitLoss = Column(FLOAT(2), comment='unknown')\n\t    StartSecurity = Column(String(50, collation), comment='unknown')\n\t    UpKeepSecurity = Column(String(50, collation), comment='unknown')\n\t    OTAMT = Column(FLOAT(2), comment='unknown')\n\t    MTAMT = Column(FLOAT(2), comment='unknown')\n\t    create_time = Column(\n", "        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass Watchlist(Base):\n\t    __tablename__ = 'watchlist'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    account = Column(String(50, collation), nullable=False)\n\t    market = Column(String(10, collation), nullable=False)\n", "    code = Column(String(10, collation), nullable=False)\n\t    buyday = Column(TIMESTAMP(fsp=6), server_default=time_default)\n\t    bsh = Column(FLOAT(2), nullable=False)\n\t    position = Column(Integer, nullable=False)\n\t    strategy = Column(String(50, collation), server_default='unknown')\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n", "class SecurityList(Base):\n\t    __tablename__ = 'security_list'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    underlying_kind = Column(String(50, collation))\n\t    update_date = Column(TIMESTAMP(fsp=6), server_default=time_default)\n\t    target_code = Column(String(10, collation))\n\t    reference = Column(FLOAT(2), nullable=False)\n\t    delivery_date = Column(String(10, collation))\n\t    exchange = Column(String(3, collation))\n", "    delivery_month = Column(String(6, collation))\n\t    name = Column(String(50, collation), default='unknown')\n\t    short_selling_balance = Column(Integer)\n\t    option_right = Column(String(50, collation))\n\t    strike_price = Column(FLOAT(2))\n\t    underlying_code = Column(String(10, collation))\n\t    margin_trading_balance = Column(Integer)\n\t    limit_up = Column(FLOAT(2), nullable=False)\n\t    limit_down = Column(FLOAT(2), nullable=False)\n\t    symbol = Column(String(10, collation))\n", "    category = Column(String(3, collation))\n\t    multiplier = Column(FLOAT(2), default=0)\n\t    currency = Column(String(3, collation), default='TWD')\n\t    day_trade = Column(String(7, collation), default='No')\n\t    code = Column(String(10, collation), nullable=False)\n\t    unit = Column(Integer)\n\t    security_type = Column(String(3, collation))\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n", "        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass KBarData1T(Base):\n\t    __tablename__ = 'kbar_data_1T'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    name = Column(String(10, collation), nullable=False)\n\t    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n\t    Open = Column(FLOAT(2), default=0)\n\t    High = Column(FLOAT(2), default=0)\n", "    Low = Column(FLOAT(2), default=0)\n\t    Close = Column(FLOAT(2), default=0)\n\t    Volume = Column(FLOAT(2), default=0)\n\t    Amount = Column(FLOAT(2), default=0)\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass KBarData30T(Base):\n", "    __tablename__ = 'kbar_data_30T'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    name = Column(String(10, collation), nullable=False)\n\t    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n\t    Open = Column(FLOAT(2), default=0)\n\t    High = Column(FLOAT(2), default=0)\n\t    Low = Column(FLOAT(2), default=0)\n\t    Close = Column(FLOAT(2), default=0)\n\t    Volume = Column(FLOAT(2), default=0)\n", "    Amount = Column(FLOAT(2), default=0)\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass KBarData60T(Base):\n\t    __tablename__ = 'kbar_data_60T'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n", "    name = Column(String(10, collation), nullable=False)\n\t    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n\t    Open = Column(FLOAT(2), default=0)\n\t    High = Column(FLOAT(2), default=0)\n\t    Low = Column(FLOAT(2), default=0)\n\t    Close = Column(FLOAT(2), default=0)\n\t    Volume = Column(FLOAT(2), default=0)\n\t    Amount = Column(FLOAT(2), default=0)\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n", "    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass KBarData1D(Base):\n\t    __tablename__ = 'kbar_data_1D'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    name = Column(String(10, collation), nullable=False)\n\t    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n\t    Open = Column(FLOAT(2), default=0)\n", "    High = Column(FLOAT(2), default=0)\n\t    Low = Column(FLOAT(2), default=0)\n\t    Close = Column(FLOAT(2), default=0)\n\t    Volume = Column(FLOAT(2), default=0)\n\t    Amount = Column(FLOAT(2), default=0)\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n", "class PutCallRatioList(Base):\n\t    __tablename__ = 'put_call_ratio'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    Date = Column(TIMESTAMP(fsp=6), server_default=time_default, comment='日期')\n\t    PutVolume = Column(FLOAT(2), default=0, comment='賣權成交量')\n\t    CallVolume = Column(FLOAT(2), default=0, comment='買權成交量')\n\t    PutCallVolumeRatio = Column(FLOAT(2), default=0, comment='買賣權成交量比率%')\n\t    PutOpenInterest = Column(FLOAT(2), default=0, comment='賣權未平倉')\n\t    CallOpenInterest = Column(FLOAT(2), default=0, comment='買權未平倉')\n", "    PutCallRatio = Column(FLOAT(2), default=0, comment='買賣權未平倉量比率%')\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass ExDividendTable(Base):\n\t    __tablename__ = 'ex_dividend_table'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n", "    Date = Column(\n\t        TIMESTAMP(fsp=6), server_default=time_default, comment='除權除息日期')\n\t    Code = Column(String(10, collation), nullable=False, comment='股票代號')\n\t    Name = Column(String(50, collation), default='unknown', comment='名稱')\n\t    DividendType = Column(String(5, collation), comment='除權息')\n\t    DividendRate = Column(FLOAT(2), default=0, comment='無償配股率')\n\t    CashCapitalRate = Column(FLOAT(2), default=0, comment='現金增資配股率')\n\t    CashCapitalPrice = Column(FLOAT(2), default=0, comment='現金增資認購價')\n\t    CashDividend = Column(FLOAT(2), default=0, comment='現金股利')\n\t    Details = Column(String(10, collation), comment='詳細資料')\n", "    Reference = Column(String(10, collation), comment='參考價試算')\n\t    Quarter = Column(String(10, collation), comment='最近一次申報資料 季別/日期')\n\t    NetValue = Column(FLOAT(2), default=0, comment='最近一次申報每股 (單位)淨值')\n\t    EPS = Column(FLOAT(2), default=0, comment='最近一次申報每股 (單位)盈餘')\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass TradingStatement(Base):\n", "    __tablename__ = 'trading_statement'\n\t    pk_id = Column(\n\t        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    Time = Column(\n\t        TIMESTAMP(fsp=6), server_default=time_default, comment='交易日期')\n\t    market = Column(String(10, collation), nullable=False, comment='市場別')\n\t    account_id = Column(\n\t        String(50, collation), default='unknown', comment='帳號別')\n\t    code = Column(String(10, collation), nullable=False, comment='證券代號')\n\t    action = Column(String(50, collation), default='unknown', comment='買賣別')\n", "    price = Column(FLOAT(2), default=0, comment='成交價')\n\t    quantity = Column(FLOAT(2), default=0, comment='成交數量')\n\t    amount = Column(FLOAT(2), default=0, comment='成交金額')\n\t    order_cond = Column(\n\t        String(50, collation), default='unknown', comment='現股或融資')\n\t    order_lot = Column(\n\t        String(50, collation), default='unknown', comment='整張或零股')\n\t    op_type = Column(\n\t        String(50, collation), default='unknown', comment='期權委託類型')\n\t    leverage = Column(FLOAT(2), default=1, comment='槓桿比例')\n", "    msg = Column(\n\t        String(200, collation), default='unknown', comment='進出場訊息')\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n\tclass SelectedStocks(Base):\n\t    __tablename__ = 'selected_stocks'\n\t    pk_id = Column(\n", "        Integer, primary_key=True, autoincrement=True, nullable=False)\n\t    code = Column(String(10, collation), nullable=False, comment='證券代號')\n\t    company_name = Column(String(10, collation), comment='證券名稱')\n\t    category = Column(String(50, collation), comment='產業類別')\n\t    Time = Column(\n\t        TIMESTAMP(fsp=6), server_default=time_default, comment='選股日期')\n\t    Open = Column(FLOAT(2), nullable=False, comment='開盤價')\n\t    High = Column(FLOAT(2), nullable=False, comment='最高價')\n\t    Low = Column(FLOAT(2), nullable=False, comment='最低價')\n\t    Close = Column(FLOAT(2), nullable=False, comment='收盤價')\n", "    Volume = Column(Integer, comment='成交量')\n\t    Amount = Column(BigInteger, comment='成交額')\n\t    Strategy = Column(String(10, collation), nullable=False, comment='選股策略')\n\t    create_time = Column(\n\t        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\t    def __init__(self, **kwargs):\n\t        for property, value in kwargs.items():\n\t            setattr(self, property, value)\n"]}
{"filename": "trader/utils/database/sql.py", "chunked_list": ["import logging\n\timport numpy as np\n\timport pandas as pd\n\tfrom sqlalchemy import update\n\tfrom sqlalchemy.pool import QueuePool\n\tfrom sqlalchemy import asc, desc, create_engine\n\tfrom sqlalchemy.ext.declarative import declarative_base\n\tfrom sqlalchemy.orm import sessionmaker, scoped_session, load_only\n\tfrom ...config import HAS_DB, DB_NAME, DB_URL\n\tfrom ..file import FileHandler\n", "Base = declarative_base()\n\tclass SQLDatabase(FileHandler):\n\t    def __init__(self):\n\t        self.HAS_DB = HAS_DB\n\t        if self.HAS_DB:\n\t            self.sql_connect = f\"mysql+pymysql://{DB_URL}/{DB_NAME}?charset=utf8mb4&binary_prefix=true\"\n\t            self.engine = create_engine(\n\t                self.sql_connect,\n\t                pool_size=50,\n\t                # max_overflow=max_overflow,\n", "                pool_recycle=10,\n\t                pool_timeout=10,\n\t                pool_pre_ping=True,\n\t                poolclass=QueuePool,\n\t                pool_use_lifo=True,\n\t                echo=False\n\t            )\n\t            self.sessionmaker_ = sessionmaker(bind=self.engine)\n\t    def get_session(self):\n\t        return scoped_session(self.sessionmaker_)\n", "    def create_table(self, table):\n\t        engine = create_engine(self.sql_connect)\n\t        table\n\t        Base.metadata.create_all(engine)\n\t    def query(self, table, *filterBy, **conditions):\n\t        '''Get data from DB'''\n\t        session = self.get_session()\n\t        query = session.query(table).filter(*filterBy)\n\t        if conditions.get('orderBy'):\n\t            if conditions['orderBy'] == 'asc':\n", "                query = query.order_by(asc(conditions['orderTarget']))\n\t            else:\n\t                query = query.order_by(desc(conditions['orderTarget']))\n\t        if conditions.get('limit'):\n\t            query = query.limit(conditions['limit'])\n\t        if conditions.get('fields'):\n\t            query = query.options(load_only(*conditions['fields']))\n\t        result = pd.read_sql(query.statement, session.bind)\n\t        session.close()\n\t        for c in ['pk_id', 'create_time']:\n", "            if c in result.columns:\n\t                result = result.drop(['pk_id', 'create_time'], axis=1)\n\t        return result\n\t    def update(self, table, update_content: dict, *filterBy):\n\t        '''Update data in table'''\n\t        session = self.get_session()\n\t        session.execute(\n\t            update(table).where(*filterBy).values(update_content)\n\t        )\n\t        session.commit()\n", "        session.close()\n\t    def delete(self, table, *args):\n\t        '''Delete data in table'''\n\t        session = self.get_session()\n\t        query_data = session.query(table).filter(*args).all()\n\t        for row in query_data:\n\t            session.delete(row)\n\t            session.commit()\n\t        session.close()\n\t    def check_exist(self, table, **kwargs):\n", "        '''Check if data exists in table'''\n\t        session = self.get_session()\n\t        q = session.query(table).filter_by(**kwargs)\n\t        check_result = session.query(q.exists()).scalar()\n\t        session.close()\n\t        return check_result\n\t    def dataframe_to_DB(self, df: pd.DataFrame, table):\n\t        '''Import dataframe to DB'''\n\t        # 轉換時間格式\n\t        for col in df.columns:\n", "            if df[col].dtype == pd._libs.tslibs.timestamps.Timestamp:\n\t                df[col] = df[col].astype(str).apply(\n\t                    lambda x: None if x == 'NaT' else x)\n\t        # 補空值\n\t        if df.isnull().sum().sum():\n\t            df = df.where(pd.notnull(df), '')\n\t        datarows = np.array(df.to_dict('records'))\n\t        alldata = np.array([table(**row) for row in datarows])\n\t        # upload data\n\t        session = self.get_session()\n", "        session.add_all(alldata)\n\t        session.commit()\n\t        session.close()\n\t    def add_data(self, table, **input_data):\n\t        try:\n\t            session = self.get_session()\n\t            data = table(**input_data)\n\t            session.add(data)\n\t            session.commit()\n\t        except:\n", "            session.rollback()\n\t            logging.error(\n\t                f\"Save data into {table.__tablename__} failed\")\n\t        finally:\n\t            session.close()\n\t    def export_table(self, table, filename, *filterBy, **conditions):\n\t        '''Export DB data'''\n\t        df = self.query(table, *filterBy, **conditions)\n\t        self.save_table(df, filename)\n"]}
{"filename": "trader/utils/database/redis.py", "chunked_list": ["import time\n\timport redis\n\timport pickle\n\timport logging\n\tfrom typing import Iterable\n\tfrom ...config import HAS_REDIS, REDIS_HOST, REDIS_PORT, REDIS_PWD\n\tfrom .. import progress_bar\n\tclass RedisTools:\n\t    def __init__(self, redisKey):\n\t        self.HAS_REDIS = HAS_REDIS\n", "        self.REDIS_KEY = redisKey\n\t        self.redis_client = self.init_client()\n\t    def init_client(self):\n\t        '''Initialize Redis by config settings'''\n\t        if self.HAS_REDIS:\n\t            return redis.Redis(\n\t                host=REDIS_HOST,\n\t                port=REDIS_PORT,\n\t                password=REDIS_PWD,\n\t                decode_responses=False\n", "            )\n\t    def _data2byte(self, data: Iterable):\n\t        return pickle.dumps(data)\n\t    def to_redis(self, data: dict):\n\t        '''insert data to Redis at a time'''\n\t        N = len(data)\n\t        if N > 1:\n\t            pipe = self.redis_client.pipeline()\n\t            for i, c in enumerate(data):\n\t                pipe.set(f'{self.REDIS_KEY}:{c}', self._data2byte(data[c]))\n", "                progress_bar(N, i)\n\t            pipe.execute()\n\t        else:\n\t            for k, v in data.items():\n\t                self.redis_client.set(\n\t                    f'{self.REDIS_KEY}:{k}', self._data2byte(v))\n\t    def query(self, key: str):\n\t        '''query data from redis'''\n\t        n = 0\n\t        while n < 5:\n", "            try:\n\t                data = self.redis_client.get(f\"{self.REDIS_KEY}:{key}\")\n\t                break\n\t            except:\n\t                n += 1\n\t                logging.error(\n\t                    f\"Cannot connect to {REDIS_HOST}, reconnect ({n}/5).\")\n\t                self.redis_client = self.init_client()\n\t                time.sleep(1)\n\t        if n == 5:\n", "            return 'Redis ConnectionError'\n\t        try:\n\t            return pickle.loads(data)\n\t        except TypeError:\n\t            return None\n\t    def query_keys(self, keys: str = None, match: str = None):\n\t        if not keys and not match:\n\t            keys = self.redis_client.keys()\n\t        elif match:\n\t            _, keys = self.redis_client.scan(match=match)\n", "        data = self.redis_client.mget(keys)\n\t        return [pickle.loads(d) for d in data if d]\n\t    def delete_keys(self, keys: list):\n\t        '''delete data stored in Redis by key'''\n\t        for k in keys:\n\t            self.redis_client.delete(f'{self.REDIS_KEY}:{k}')\n\t    def clear_all(self):\n\t        '''delete all data stored in Redis'''\n\t        self.redis_client.delete(*self.redis_client.keys())\n\t    def memory_usage(self):\n", "        '''check Redis memory usage'''\n\t        used_memory = self.redis_client.info()['total_system_memory_human']\n\t        print(f'Total keys = {len(self.redis_client.keys())}')\n\t        print(f\"Used_memory of {REDIS_HOST}:{REDIS_PORT} = {used_memory}\")\n"]}
{"filename": "trader/indicators/signals.py", "chunked_list": ["import pandas as pd\n\tclass ChipAnalysis:\n\t    '''籌碼分析'''\n\t    def __init__(self, df, target):\n\t        self.df = df\n\t        self.target = target\n\t        self.group = df.groupby('stockid')[self.target]\n\t    def change(self):\n\t        # 漲跌\n\t        return self.group.transform('diff')\n", "    def changepercent(self):\n\t        # 漲跌幅\n\t        return 100*self.df.quotechange/self.group.transform('shift')\n\t    def dailychange(self):\n\t        # 當日高低價差\n\t        return self.df.high - self.df.low\n\t    def dailychangepercent(self):\n\t        # 當日震幅\n\t        return 100*self.df.dailychange/self.group.transform('shift')\n\t    def MA(self, d):\n", "        # 移動平均\n\t        return self.group.transform(lambda x: x.rolling(d).mean())\n\t    def short_margin(self):\n\t        # 券資比 = 融券餘額 / 融資餘額\n\t        shortMarginPercent = self.df.shortRemaining/self.df.marginRemaining\n\t        return shortMarginPercent\n\t    def close_short_index(self):\n\t        # 券補力道 = 融券餘額 / 5 日成交均量\n\t        V_1D_5_MA = self.df.groupby('stockid').volume.transform(\n\t            lambda x: x.rolling(5).mean())\n", "        closeShortIndex = self.df.shortRemaining/V_1D_5_MA\n\t        return closeShortIndex\n\tclass TechnicalSignals:\n\t    def _MA(self, df: pd.DataFrame, col: str, n=7, shift=0):\n\t        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).mean())\n\t    def _STD(self, df: pd.DataFrame, col: str, n=7, shift=0):\n\t        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).std())\n\t    def _MAX(self, df: pd.DataFrame, col: str, n=7, shift=0):\n\t        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).max())\n\t    def _MIN(self, df: pd.DataFrame, col: str, n=7, shift=0):\n", "        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).min())\n\t    def MACD(self, tb, d1=12, d2=26, dma=9):\n\t        group = tb.groupby('name').Close\n\t        # # 股價與交易量/MACD背離\n\t        # cond1 = (tb.quotechange > 0) & (tb.ema_diff < 0)\n\t        # cond2 = (tb.quotechange < 0) & (tb.ema_diff > 0)\n\t        # tb['diverge_MACD'] = (cond1 | cond2).astype(int)\n\t        # DIFF (快線) = EMA (收盤價, 12) - EMA (收盤價, 26)\n\t        tb[f'ema_{d1}'] = group.transform(\n\t            lambda x: x.ewm(span=d1, adjust=False).mean())\n", "        tb[f'ema_{d2}'] = group.transform(\n\t            lambda x: x.ewm(span=d2, adjust=False).mean())\n\t        tb['ema_diff'] = tb[f'ema_{d1}'] - tb[f'ema_{d2}']\n\t        # DEA(慢線) = EMA (DIFF, 9)\n\t        tb['MACD'] = tb.groupby('name').ema_diff.transform(\n\t            lambda x: x.ewm(span=dma, adjust=False).mean())\n\t        # MACD紅綠柱狀體 = DIFF - DEA\n\t        tb['diff_MACD'] = tb.ema_diff - tb.MACD\n\t        return tb\n\t    def check_MACD_dev(self, df: pd.DataFrame):\n", "        '''背離(MACD)'''\n\t        close_diff = df.groupby('name').Close.transform('diff').fillna(0)\n\t        diff_MACD_diff = df.groupby(\n\t            'name').diff_MACD.transform('diff').fillna(0)\n\t        return ((close_diff >= 0) & (diff_MACD_diff <= 0)) | ((close_diff <= 0) & (diff_MACD_diff >= 0))\n\t    def RSI(self, change, period=12):\n\t        '''\n\t        change: stock close price daily quote change\n\t        RSI = RS/(1+RS), where RS = Up/Down\n\t        # Up = d day mean of previous change ups\n", "        # Down = d day mean of previous change downs\n\t        '''\n\t        ups = pd.Series(index=change.index, data=change[change > 0])\n\t        downs = pd.Series(index=change.index, data=-change[change < 0])\n\t        # 計算d日平均漲跌\n\t        mean_u = ups.fillna(0).rolling(period).mean()\n\t        mean_d = downs.fillna(0).rolling(period).mean()\n\t        # 計算 RSI\n\t        rsi = 100*mean_u/(mean_u + mean_d)\n\t        return rsi\n", "    def RSV(self, tb, d=9):\n\t        d_min = tb.groupby('name').Close.transform(\n\t            lambda x: x.rolling(d).min())\n\t        d_max = tb.groupby('name').Close.transform(\n\t            lambda x: x.rolling(d).max())\n\t        try:\n\t            (100*(tb.Close - d_min)/(d_max - d_min)).fillna(-1)\n\t        except:\n\t            tb['d_min'] = d_min\n\t            tb['d_max'] = d_max\n", "        return (100*(tb.Close - d_min)/(d_max - d_min)).fillna(-1)\n\t    def KD(self, tb):\n\t        '''\n\t        Reference: https://medium.com/%E5%8F%B0%E8%82%A1etf%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8-%E7%A8%8B%E5%BC%8F%E9%A1%9E/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80-%E8%87%AA%E5%BB%BAkd%E5%80%BC-819d6fd707c8\n\t        一、 要算出KD值，必先算出RSV強弱值，以下以 9 天為計算基準。\n\t            RSV=( 收盤 - 9日內的最低 ) / ( 9日內的最高 - 9日內的最低 ) * 100\n\t        二、 再以平滑移動平均法，來計算KD值。\n\t            期初:K= 50，D= 50\n\t            當日K值=前一日K值 * 2/3 + 當日RSV * 1/3\n\t            當日D值=前一日D值 * 2/3 + 當日K值 * 1/3\n", "        '''\n\t        def _getK(rsv):\n\t            K = []\n\t            for r in rsv:\n\t                if r == -1:\n\t                    K.append(50)\n\t                else:\n\t                    K.append(K[-1]*2/3 + r/3)\n\t            return K\n\t        def _getD(k):\n", "            D = []\n\t            for i, k in enumerate(k):\n\t                if i == 0:\n\t                    D.append(50)\n\t                else:\n\t                    D.append(D[-1] * 2/3 + k/3)\n\t            return D\n\t        tb['K'] = tb.groupby('name').RSV.transform(_getK)\n\t        tb['D'] = tb.groupby('name').K.transform(_getD)\n\t        return tb\n"]}
{"filename": "trader/create_env/__init__.py", "chunked_list": ["from flask import Flask, request, render_template\n\tfrom trader import file_handler\n\tdef _create_env(inputs):\n\t    modes = {\n\t        '作多只賣出': 'LongSell',\n\t        '作多只買進': 'LongBuy',\n\t        '作多買進&賣出': 'LongBoth',\n\t        '作空只賣出': 'ShortSell',\n\t        '作空只買進': 'ShortBuy',\n\t        '作空買進&賣出': 'ShortBoth',\n", "        '作多且做空, 且可買進也可賣出': 'All',\n\t        '模擬': 'Simulation'\n\t    }\n\t    markets = {\n\t        '只有股票': 'stock',\n\t        '只有期貨': 'futures',\n\t        '股票 & 期貨': 'stock and futures',\n\t    }\n\t    account_name = inputs['ACCOUNT_NAME']\n\t    users = file_handler.listdir('./lib/envs', account_name)\n", "    if users:\n\t        nth_account = max(users) + 1\n\t    else:\n\t        nth_account = 1\n\t    account_name = f'{account_name}_{nth_account}'\n\t    myBat = open(f\"./lib/envs/{account_name}.env\", 'w+', encoding='utf-8')\n\t    content = f\"\"\"# 使用者資訊\n\t        ACCOUNT_NAME={account_name}\n\t        API_KEY = {inputs['API_KEY']}\n\t        SECRET_KEY = {inputs['SECRET_KEY']}\n", "        ACCOUNT_ID = {inputs['ACCOUNT_ID']}\n\t        CA_PASSWD = {inputs['CA_PASSWD']}\n\t        # 崩盤日\n\t        KBAR_START_DAYay=\n\t        # 多空模式 (英文)\n\t        # 作多: LongSell(只賣出), LongBuy(只買進), LongBoth(買進&賣出)\n\t        # 作空: ShortSell(只賣出), ShortBuy(只買進), ShortBoth(買進&賣出)\n\t        # All: 作多且做空, 且可買進也可賣出\n\t        # Simulation: 可做策略監控(多 or 空 or 多策略), 但不下單\n\t        MODE={modes[inputs['MODE']]}\n", "        # 市場類型:stock/futures/stock and futures\n\t        MARKET={markets[inputs['MARKET']]}\n\t        # 過濾掉不監控股票的清單，沒有等號後面空白\n\t        FILTER_OUT={inputs['FILTER_OUT']}\n\t        # 股票要執行的策略\n\t        STRATEGY_STOCK={inputs['STRATEGY_STOCK']}\n\t        # 高價股門檻\n\t        PRICE_THRESHOLD=99999\n\t        # 起始部位\n\t        INIT_POSITION=100000\n", "        # 部位上限/可委託金額上限\n\t        POSITION_LIMIT_LONG={inputs['POSITION_LIMIT_LONG']}\n\t        POSITION_LIMIT_SHORT={inputs['POSITION_LIMIT_SHORT']}\n\t        # 投資組合股票數上限\n\t        N_LIMIT_LS={inputs['N_LIMIT_LS']}\n\t        N_LIMIT_SS={inputs['N_LIMIT_SS']}\n\t        # 投資組合股票數上限類型: 固定(constant)/隨大盤環境波動(float)\n\t        N_STOCK_LIMIT_TYPE={inputs['N_STOCK_LIMIT_TYPE']}\n\t        # 每次買進的單位(張)\n\t        BUY_UNIT={inputs['BUY_UNIT']}\n", "        # 買進的單位數類型: 固定(constant)/隨淨值等比例增加(float)\n\t        BUY_UNIT_TYPE={inputs['BUY_UNIT_TYPE']}\n\t        # 現股/融資 (Cash/MarginTrading/ShortSelling)\n\t        ORDER_COND1={inputs['ORDER_COND1']}\n\t        ORDER_COND2={inputs['ORDER_COND2']}\n\t        # 最長持有天數(含六日)\n\t        HOLD_DAY={inputs['HOLD_DAY']}\n\t        # ----------------------------------- 期貨設定 ----------------------------------- #\n\t        # 交易時段(Day/Night/Both)\n\t        TRADING_PERIOD={inputs['TRADING_PERIOD']}\n", "        # 期貨要執行的策略\n\t        STRATEGY_FUTURES={inputs['STRATEGY_FUTURES']}\n\t        # 可下單的保證金額上限\n\t        MARGIN_LIMIT = {inputs['MARGIN_LIMIT']}\n\t        # 投資組合期權數上限\n\t        N_FUTURES_LIMIT={inputs['N_FUTURES_LIMIT']}\n\t        # 期權投資組合期權數上限類型: 固定(constant)/隨大盤環境波動(float)\n\t        N_FUTURES_LIMIT_TYPE={inputs['N_FUTURES_LIMIT_TYPE']}\n\t        # 每次期權建倉的單位(口)\n\t        N_SLOT={inputs['N_SLOT']}\n", "        # 建倉的口數類型: 固定(constant)/隨淨值等比例增加(float)\n\t        N_SLOT_TYPE={inputs['N_SLOT_TYPE']}\n\t        \"\"\".replace('        ', '')\n\t    myBat.write(content)\n\t    myBat.close()\n\t    return {account_name: content}\n\tdef _create_bat(account_name):\n\t    myBat = open(f'./lib/schedules/auto_trader_{account_name}.bat', 'w+')\n\t    myBat.write(\n\t        f\"\"\"call C:/Users/%username%/anaconda3/Scripts/activate.bat\n", "        cd /d %~dp0/../..\n\t        set SJ_LOG_PATH=%~dp0/../../logs/shioaji.log\n\t        python run.py -TASK auto_trader -ACCT {account_name}\n\t        \"\"\".replace('        ', ''))\n\t    myBat.close()\n\tdef bat_add_script(name):\n\t    filename = './lib/schedules/auto_trader_all.bat'\n\t    myBat = open(filename, 'r')\n\t    contents = myBat.readlines()\n\t    command_line = f'start /min cmd /c %~dp0/auto_trader_{name}.bat'\n", "    if command_line not in contents:\n\t        contents.append(f'''\\n\\n{command_line}''')\n\t    myBat = open(filename, 'w')\n\t    myBat.write(\"\".join(contents))\n\t    myBat.close()\n\tapp = Flask(__name__)\n\t# Homepage\n\t@ app.route(\"/\", methods=['GET'])\n\tdef account():\n\t    return render_template('index.html')\n", "@ app.route(\"/account-result\", methods=['POST'])\n\tdef account_result():\n\t    data = request.form\n\t    result = _create_env(data)\n\t    # # 新增個人bat檔\n\t    account_name = list(result)[0]\n\t    _create_bat(account_name)\n\t    # # 加入個人bat檔執行指令\n\t    # bat_add_script(name)\n\t    result = {'msg': '新增成功'}\n", "    return render_template('account_result.html', result=result)\n"]}
{"filename": "trader/performance/base.py", "chunked_list": ["import numpy as np\n\timport pandas as pd\n\tfrom ..config import StrategyList\n\tdef AccountingNumber(number: float):\n\t    return f\"{'{:,}'.format(number)}\"\n\tdef convert_statement(df, mode='trading', **kwargs):\n\t    def extract_strategy(msg):\n\t        for s in StrategyList.All:\n\t            if s in msg:\n\t                return s\n", "        return 'Unknown'\n\t    if not df.shape[0]:\n\t        return df\n\t    init_position = kwargs.get('init_position', 1000000)\n\t    if mode == 'trading':\n\t        df = df.rename(columns={\n\t            'code': 'Code',\n\t            'price': 'Price',\n\t            'quantity': 'Quantity',\n\t            'msg': 'Reason',\n", "            'amount': 'Amount'\n\t        })\n\t        df['Strategy'] = df.Reason.apply(extract_strategy)\n\t        df['isLong'] = df.Strategy.apply(lambda x: x in StrategyList.Long)\n\t        df['isShort'] = df.isLong == False\n\t        df['isOpen'] = (\n\t            ((df.isLong == True) & (df.action == 'Buy')) |\n\t            ((df.isShort == True) & (df.action == 'Sell'))\n\t        )\n\t        target_columns1 = ['Strategy', 'Code', 'isLong', 'isShort']\n", "        target_columns2 = ['Time', 'Price', 'Quantity', 'Amount', 'Reason']\n\t        tb1 = df[df.isOpen == True][target_columns1 + target_columns2]\n\t        tb1.columns = target_columns1 + ['Open' + c for c in target_columns2]\n\t        tb2 = df[df.isOpen == False][target_columns1 + target_columns2]\n\t        tb2.columns = target_columns1 + ['Close' + c for c in target_columns2]\n\t        tb = pd.concat([tb1, tb2]).sort_index()\n\t        tb.CloseAmount = tb.CloseAmount.abs()\n\t        tb.OpenQuantity = tb.OpenQuantity.fillna(tb.CloseQuantity)\n\t        for c in ['Time', 'Price', 'Amount', 'Reason']:\n\t            col = f'Open{c}'\n", "            tb[col] = tb.groupby('Code')[col].fillna(method='ffill')\n\t        tb['OpenAmount'] = (tb.OpenPrice*tb.OpenQuantity).abs()\n\t        tb['CloseAmount'] = (tb.ClosePrice*tb.CloseQuantity).abs()\n\t        tb['profit'] = (tb.CloseAmount - tb.OpenAmount)*(tb.isShort*(-2)+1)\n\t        tb['returns'] = 100*(tb.profit/tb.OpenAmount).round(4)\n\t        tb['balance'] = init_position + tb.profit.cumsum()\n\t        tb = tb.dropna().reset_index(drop=True)\n\t        for index, row in tb.iterrows():\n\t            sub_string = f'【{row.Code}】{row.Strategy}'\n\t            tb.at[index, 'OpenReason'] = row.OpenReason.replace(\n", "                sub_string, '').replace('-', '')\n\t            tb.at[index, 'CloseReason'] = row.CloseReason.replace(\n\t                sub_string, '').replace('-', '')\n\t        return tb\n\t    else:\n\t        df.OpenAmount = df.OpenAmount.astype('int64')\n\t        df.CloseAmount = df.CloseAmount.astype('int64')\n\t        df.ClosePrice = df.ClosePrice.round(2)\n\t        if kwargs['market'] == 'Stocks':\n\t            netOpenAmount = (df.OpenAmount + df.OpenFee)\n", "            netCloseAmount = (df.CloseAmount - df.CloseFee - df.Tax)\n\t            df['profit'] = (netCloseAmount - netOpenAmount).astype('int64')\n\t            df['returns'] = (\n\t                100*(df.CloseAmount/df.OpenAmount - 1)).round(2)\n\t        else:\n\t            sign = 1 if kwargs['isLong'] else -1\n\t            df['profit'] = (df.ClosePrice - df.OpenPrice)*df.CloseQuantity\n\t            totalExpense = (df.OpenFee + df.CloseFee + df.Tax)*sign\n\t            df.profit = df.profit*kwargs['multipler'] - totalExpense\n\t            df['returns'] = (\n", "                sign*100*((df.ClosePrice/df.OpenPrice)**sign - 1)).round(2)\n\t        df.profit = df.profit.round()\n\t        df['iswin'] = df.profit > 0\n\t        if not kwargs['isLong']:\n\t            df.profit *= -1\n\t            df.returns *= -1\n\t        df['balance'] = init_position + df.profit.cumsum()\n\t        return df\n\tdef compute_profits(tb):\n\t    total_profit = tb.profit.sum()\n", "    df_profit = tb[tb.profit > 0]\n\t    df_loss = tb[tb.profit <= 0]\n\t    has_profits = df_profit.shape[0]\n\t    has_loss = df_loss.shape[0]\n\t    # 毛利/毛損\n\t    gross_profit = df_profit.profit.sum() if has_profits else 0\n\t    gross_loss = df_loss.profit.sum() if has_loss else 0\n\t    profit_factor = round(\n\t        abs(gross_profit/gross_loss), 2) if gross_loss else np.inf\n\t    if total_profit < 0:\n", "        profit_factor *= -1\n\t    # 平均獲利/虧損金額\n\t    mean_profit = df_profit.profit.mean() if has_profits else 0\n\t    mean_loss = df_loss.profit.mean() if has_loss else 0\n\t    max_profit = df_profit.profit.max() if has_profits else 0\n\t    max_loss = df_loss.profit.min() if has_loss else 0\n\t    ratio1 = round(abs(mean_profit/mean_loss), 4) if mean_loss else np.inf\n\t    profits = {\n\t        'TotalProfit': round(total_profit),\n\t        'GrossProfit': round(gross_profit),\n", "        'GrossLoss': round(gross_loss),\n\t        'MeanProfit': round(mean_profit if mean_profit else 0),\n\t        'MeanLoss': round(mean_loss if mean_loss else 0),\n\t        'MaxProfit': max_profit,\n\t        'MaxLoss': max_loss,\n\t        'ProfitFactor': profit_factor,\n\t        'ProfitRatio': ratio1\n\t    }\n\t    if 'KRun' in tb.columns:\n\t        profits.update({\n", "            'KRunProfit': round(df_profit.KRun.mean(), 1) if has_profits else 0,\n\t            'KRunLoss': round(df_loss.KRun.mean(), 1) if has_loss else 0\n\t        })\n\t    else:\n\t        profits.update({\n\t            'KRunProfit': None,\n\t            'KRunLoss': None\n\t        })\n\t    return profits\n\tdef computeReturn(df, target1, target2):\n", "    if df.shape[0] and target1 in df.columns and target2 in df.columns:\n\t        start = df[target1].values[0]\n\t        end = df[target2].values[-1]\n\t        return 100*round(end/start - 1, 2)\n\t    return 0\n\tdef computeWinLoss(df: pd.DataFrame):\n\t    '''Count wins and losses'''\n\t    win_loss = (df.profit > 0).value_counts().to_dict()\n\t    if True not in win_loss:\n\t        win_loss[True] = 0\n", "    if False not in win_loss:\n\t        win_loss[False] = 0\n\t    return win_loss\n"]}
{"filename": "trader/performance/backtest.py", "chunked_list": ["import time\n\timport numpy as np\n\timport pandas as pd\n\tfrom typing import Union\n\tfrom datetime import datetime\n\tfrom collections import namedtuple\n\tfrom .base import (\n\t    AccountingNumber,\n\t    compute_profits,\n\t    computeReturn,\n", "    computeWinLoss,\n\t    convert_statement\n\t)\n\tfrom .. import file_handler\n\tfrom ..config import PATH, TODAY_STR\n\tfrom ..utils import progress_bar\n\tfrom ..utils.time import TimeTool\n\tfrom ..utils.file import FileHandler\n\tfrom ..utils.kbar import KBarTool\n\tfrom ..utils.crawler import readStockList\n", "from ..utils.database import db, KBarTables\n\tclass BacktestPerformance(FileHandler):\n\t    def __init__(self, config) -> None:\n\t        self.Market = config.market\n\t        self.scale = config.scale\n\t        self.LEVERAGE_INTEREST = 0.075*(config.leverage != 1)\n\t        self.leverage = 1/config.leverage\n\t        self.margin = config.margin\n\t        self.multipler = config.multipler\n\t        self.mode = config.mode.lower()\n", "        self.DATAPATH = f'{PATH}/backtest'\n\t        self.ResultInfo = namedtuple(\n\t            typename=\"TestResult\",\n\t            field_names=['Configuration', 'Summary', 'Statement', 'DailyInfo'],\n\t            defaults=[None]*4\n\t        )\n\t    def process_daily_info(self, df: pd.DataFrame, **result):\n\t        '''update daily info table'''\n\t        profit = df.groupby('CloseTime').profit.sum().to_dict()\n\t        nOpen = df.groupby('OpenTime').Code.count().to_dict()\n", "        daily_info = result['daily_info'].copy()\n\t        init_position = result.get('init_position', 1000000)\n\t        profit = pd.Series(daily_info.index).map(profit).fillna(0).cumsum()\n\t        daily_info['balance'] = init_position + profit.values\n\t        daily_info['nOpen'] = daily_info.index.map(nOpen).fillna(0)\n\t        daily_info = daily_info.dropna()\n\t        if self.Market != 'Stocks':\n\t            for c in ['TSEopen', 'TSEclose', 'OTCopen', 'OTCclose']:\n\t                daily_info[c] = 1\n\t        return daily_info\n", "    def getMDD(self, df: pd.DataFrame):\n\t        tb = df[['CloseTime', 'balance']].copy()\n\t        tb.set_index(pd.to_datetime(tb['CloseTime']), inplace=True)\n\t        tb.drop('CloseTime', axis=1, inplace=True)\n\t        # Reference:\n\t        # https://github.com/pyinvest/quant_basic_toturial/blob/master/quant/16_Max_drawdown.ipynb\n\t        dr = tb.pct_change(1)\n\t        r = dr.add(1).cumprod()\n\t        dd = r.div(r.cummax()).sub(1)\n\t        if dd.shape[0] > 1:\n", "            mdd = dd.min()\n\t            end = dd.idxmin()\n\t            start = r.loc[:end[0]].idxmax()\n\t            days = end - start\n\t            result = {\n\t                'MDD': mdd[0],\n\t                'Start': start[0],\n\t                'End': end[0],\n\t                'Days': days[0],\n\t                'TotalLoss': df[(df.CloseTime >= start[0]) & (df.CloseTime <= end[0])].profit.sum()\n", "            }\n\t            return result\n\t        return {}\n\t    def get_max_profit_loss_days(self, statement: pd.DataFrame):\n\t        '''\n\t        計算最大連續獲利/損失天數\n\t        參數:\n\t        statement - 回測交易明細\n\t        scale - 回測的k棒頻率\n\t        '''\n", "        def count_profits(is_profit):\n\t            condition = profits.is_profit == is_profit\n\t            counts = profits[condition].groupby('labels').profit.count()\n\t            if not counts.shape[0]:\n\t                return {\n\t                    'start': '1900-01-01',\n\t                    'end': '1900-01-01',\n\t                    'n': 0,\n\t                    'amount': 0\n\t                }\n", "            count_max = counts[counts == counts.max()].index[0]\n\t            result = profits[profits.labels == count_max]\n\t            return {\n\t                'start': str(result.CloseTime.min()).split(' ')[0],\n\t                'end': str(result.CloseTime.max()).split(' ')[0],\n\t                'n': result.shape[0],\n\t                'amount': result.profit.sum().astype(int)\n\t            }\n\t        profits = statement.copy()\n\t        if self.scale != '1D':\n", "            profits.CloseTime = profits.CloseTime.dt.date\n\t        profits = profits.groupby('CloseTime').profit.sum().reset_index()\n\t        profits['is_profit'] = (profits.profit > 0).astype(int)\n\t        isprofit = profits.is_profit.values\n\t        labels = []\n\t        n = 1\n\t        for i, p in enumerate(isprofit):\n\t            if i != 0 and p != isprofit[i-1]:\n\t                n = n + 1\n\t            labels.append(n)\n", "        profits['labels'] = labels\n\t        max_positives = count_profits(is_profit=1)\n\t        max_negagives = count_profits(is_profit=0)\n\t        return max_positives, max_negagives\n\t    def get_backtest_result(self, **result):\n\t        '''取得回測報告'''\n\t        init_position = result.get('init_position', 1000000)\n\t        configs = {\n\t            '起始資金': AccountingNumber(init_position),\n\t            '做多/做空': self.mode,\n", "            '槓桿倍數': self.leverage,\n\t            '進場順序': result.get('buyOrder', 'Close')\n\t        }\n\t        if isinstance(result['statement'], list):\n\t            df = pd.DataFrame(result['statement'])\n\t            df = convert_statement(\n\t                df,\n\t                mode='backtest',\n\t                **result,\n\t                market=self.Market,\n", "                multipler=self.multipler\n\t            )\n\t        else:\n\t            df = result['statement'].copy()\n\t            df['KRun'] = -1  # TODO\n\t        if df.shape[0]:\n\t            start = str(df.OpenTime.min().date())\n\t            end = str(df.CloseTime.max().date())\n\t            win_loss = computeWinLoss(df)\n\t            if 'daily_info' in result:\n", "                Kbars = result.get('Kbars')\n\t                result['daily_info'] = self.process_daily_info(df, **result)\n\t                # TSE 漲跌幅\n\t                tse_return = computeReturn(Kbars['1D'], 'TSEopen', 'TSEclose')\n\t                # OTC 漲跌幅\n\t                otc_return = computeReturn(Kbars['1D'], 'OTCopen', 'OTCclose')\n\t            else:\n\t                result['daily_info'] = None\n\t                if db.HAS_DB:\n\t                    table = KBarTables[self.scale]\n", "                    table = db.query(\n\t                        table,\n\t                        table.Time >= df.OpenTime.min(),\n\t                        table.Time <= df.CloseTime.max(),\n\t                    )\n\t                else:\n\t                    dir_path = f'{PATH}/KBars/{self.scale}'\n\t                    table = self.read_tables_in_folder(dir_path)\n\t                    table = table[\n\t                        (table.Time >= df.OpenTime.min()) &\n", "                        (table.Time <= df.CloseTime.max())\n\t                    ]\n\t                df_TSE = table[table.name == '1']\n\t                df_OTC = table[table.name == '101']\n\t                tse_return = computeReturn(df_TSE, 'Open', 'Close')\n\t                otc_return = computeReturn(df_OTC, 'Open', 'Close')\n\t            # 總報酬率\n\t            profits = compute_profits(df)\n\t            balance = init_position + profits['TotalProfit']\n\t            total_return = balance/init_position\n", "            # 年化報酬率\n\t            days = (df.CloseTime.max() - df.OpenTime.min()).days\n\t            if days:\n\t                anaualized_return = 100*round(total_return**(365/days) - 1, 2)\n\t            else:\n\t                anaualized_return = 0\n\t            if df.shape[0] >= 5:\n\t                std = df.balance.rolling(5).std().median()\n\t            else:\n\t                std = 0\n", "            mdd_data = self.getMDD(df)\n\t            if mdd_data:\n\t                mdd = f\"{AccountingNumber(mdd_data['TotalLoss'])}({100*round(mdd_data['MDD'], 6)}%)\"\n\t                mddTimes = f\"{mdd_data['Start']} ~ {mdd_data['End']}，共{mdd_data['Days']}天\"\n\t            else:\n\t                mdd = 0\n\t                mddTimes = '無'\n\t            # 摘要\n\t            summary = pd.DataFrame([{\n\t                '期末資金': AccountingNumber(round(balance)),\n", "                '毛利': AccountingNumber(profits['GrossProfit']),\n\t                '毛損': AccountingNumber(profits['GrossLoss']),\n\t                '淨利': AccountingNumber(profits['TotalProfit']),\n\t                '平均獲利': AccountingNumber(profits['MeanProfit']),\n\t                '平均虧損': AccountingNumber(profits['MeanLoss']),\n\t                '淨值波動度': AccountingNumber(round(std)),\n\t                '總報酬(與大盤比較)': f\"{round(100*(total_return - 1), 2)}%\",\n\t                '指數報酬(TSE/OTC)': f\"{tse_return}%/{otc_return}%\",\n\t                '年化報酬率': f\"{AccountingNumber(anaualized_return)}%\",\n\t                '最大單筆獲利': AccountingNumber(profits['MaxProfit']),\n", "                '最大單筆虧損': AccountingNumber(profits['MaxLoss']),\n\t                'MDD': mdd,\n\t                'MDD期間': mddTimes,\n\t                '全部平均持倉K線數': round(df.KRun.mean(), 1),\n\t                '獲利平均持倉K線數': profits['KRunProfit'],\n\t                '虧損平均持倉K線數': profits['KRunLoss'],\n\t                '獲利交易筆數': win_loss[True],\n\t                '虧損交易筆數': win_loss[False],\n\t                '總交易筆數': df.shape[0],\n\t                '勝率': f\"{round(100*win_loss[True]/df.shape[0], 2)}%\",\n", "                '獲利因子': profits['ProfitFactor'],\n\t                '盈虧比': profits['ProfitRatio'],\n\t            }]).T.reset_index()\n\t            summary.columns = ['Content', 'Description']\n\t        else:\n\t            print('無交易紀錄')\n\t            start = str(result['startDate'].date())\n\t            end = str(result['endDate'].date())\n\t            summary, df = None, None\n\t        configs.update({'交易開始日': start, '交易結束日': end})\n", "        configs = pd.DataFrame([configs]).T.reset_index()\n\t        configs.columns = ['Content', 'Description']\n\t        return self.ResultInfo(configs, summary, df, result['daily_info'])\n\t    def generate_tb_reasons(self, statement):\n\t        '''進出場原因統計表'''\n\t        aggs = {'Code': 'count', 'iswin': 'sum', 'profit': ['sum', 'mean']}\n\t        df = statement.groupby(['OpenReason', 'CloseReason']).agg(aggs)\n\t        df = df.unstack(0).reset_index()\n\t        df = df.T.reset_index(level=[0, 1], drop=True).T\n\t        openReasons = list(np.unique(list(df.columns[1:])))\n", "        p = len(openReasons)\n\t        df.insert(p+1, 'total_count', df.fillna(0).iloc[:, 1:p+1].sum(axis=1))\n\t        df.insert(\n\t            2*p+2, 'total_win', df.fillna(0).iloc[:, p+2:2*p+2].sum(axis=1))\n\t        for i in range(p):\n\t            df.insert(\n\t                2*p+3+i, f'win_{openReasons[i]}', 100*df.iloc[:, p+2+i]/df.iloc[:, 1+i])\n\t        df = df.fillna(0)\n\t        sums = df.sum().values\n\t        for i in range(p):\n", "            sums[2*p+3+i] = round(100*sums[p+2+i]/sums[1+i], 2)\n\t            sums[4*p+3+i] = round(sums[3*p+3+i]/sums[1+i])\n\t        df = pd.concat([df, pd.DataFrame(sums, index=df.columns).T])\n\t        for i in range(1, df.shape[1]):\n\t            if 0 < i - 2*(p+1) <= p:\n\t                df.iloc[:, i] = df.iloc[:, i].astype(float).round(2)\n\t            else:\n\t                df.iloc[:, i] = df.iloc[:, i].astype(int)\n\t        columns1 = ['OpenReason'] + (openReasons + ['加總'])*2 + openReasons*3\n\t        columns2 = ['CloseReason'] + ['筆數']*(p+1) + ['獲利筆數'] * \\\n", "            (p+1) + ['勝率']*p + ['總獲利']*p + ['平均獲利']*p\n\t        df.columns = pd.MultiIndex.from_arrays([columns1, columns2])\n\t        df.iloc[-1, 0] = 'Total'\n\t        return df\n\t    def generate_win_rates(self, statement):\n\t        '''個股勝率統計'''\n\t        group = statement.groupby('Code')\n\t        win_rates = group.iswin.sum().reset_index()\n\t        win_rates['total_deals'] = group.Code.count().values\n\t        win_rates['win_rate'] = win_rates.iswin/win_rates.total_deals\n", "        return win_rates\n\t    def save_result(self, TestResult):\n\t        '''儲存回測報告'''\n\t        win_rates = self.generate_win_rates(TestResult.Statement)\n\t        reasons = self.generate_tb_reasons(TestResult.Statement)\n\t        writer = pd.ExcelWriter(\n\t            f'{self.DATAPATH}/{TODAY_STR}-backtest.xlsx', engine='xlsxwriter')\n\t        TestResult.Configuration.to_excel(\n\t            writer, index=False, sheet_name='Backtest Settings')\n\t        TestResult.Summary.to_excel(\n", "            writer, index=False, sheet_name='Summary')\n\t        TestResult.Statement.to_excel(\n\t            writer, index=False,  sheet_name='Transaction Detail')\n\t        reasons.to_excel(writer, sheet_name='Transaction Reasons')\n\t        win_rates.to_excel(writer, index=False, sheet_name='Win Rate')\n\t        writer.save()\n\tclass BackTester(BacktestPerformance, TimeTool):\n\t    def __init__(self, script=None):\n\t        self.set_scripts(script)\n\t        self.isLong = True\n", "        self.sign = 1\n\t        self.FEE_RATE = .001425*.65\n\t        self.TAX_RATE_STOCK = .003\n\t        self.TAX_RATE_FUTURES = .00002\n\t        self.TimeCol = 'Time'\n\t        self.indexes = ['1', '101']\n\t        self.nStocksLimit = 0\n\t        self.nStocks_high = 20\n\t        self.day_trades = []\n\t        self.statements = []\n", "        self.stocks = {}\n\t        self.daily_info = {}\n\t        self.init_balance = 1000000\n\t        self.balance = self.init_balance\n\t        self.market_value = self.init_balance\n\t        self.buyOrder = 'Close'\n\t        self.Action = namedtuple(\n\t            typename=\"Action\",\n\t            field_names=['position', 'reason', 'msg', 'price'],\n\t            defaults=[0, '', '', 0]\n", "        )\n\t    def load_datasets(self, start='', end='', dataPath=''):\n\t        market = self.Script.market\n\t        if market == 'Stocks':\n\t            codes = readStockList().code.to_list()\n\t        else:\n\t            codes = ['TX']\n\t        codes += self.indexes\n\t        if not start:\n\t            start = '2018-07-01'\n", "        if not end:\n\t            end = TODAY_STR\n\t        dir_path = f'{dataPath if dataPath else PATH}/Kbars/'\n\t        scales = file_handler.listdir(dir_path)\n\t        Kbars = {scale: None for scale in self.Script.kbarScales}\n\t        Kbars['1D'] = None\n\t        for scale in Kbars:\n\t            scale_ = scale if market == 'Stocks' and scale in scales else '1T'\n\t            if db.HAS_DB:\n\t                df = db.query(\n", "                    KBarTables[scale_],\n\t                    KBarTables[scale_].Time >= start,\n\t                    KBarTables[scale_].Time <= end,\n\t                    KBarTables[scale_].name.in_(codes)\n\t                )\n\t            else:\n\t                df = file_handler.read_tables_in_folder(\n\t                    f'{dir_path}/{scale_}',\n\t                    pattern=market.lower(),\n\t                    start=start,\n", "                    end=end\n\t                )\n\t                df = df[\n\t                    (df.Time >= start) &\n\t                    (df.Time <= end) &\n\t                    df.name.isin(codes)\n\t                ]\n\t            df = df.sort_values(['name', 'Time']).reset_index(drop=True)\n\t            if market == 'Futures' or scale not in scales:\n\t                df = KBarTool().convert_kbar(df, scale=scale)\n", "            df['date'] = df.Time.dt.date.astype(str)\n\t            Kbars[scale] = df\n\t        if hasattr(self.Script, 'extraData'):\n\t            for dataname, func in self.Script.extraData.items():\n\t                Kbars[dataname] = func(start=start, end=end, dataPath=dataPath)\n\t        return Kbars\n\t    def addFeatures(self, Kbars: dict):\n\t        return Kbars\n\t    def selectStocks(self, Kbars: dict):\n\t        '''依照策略選股條件挑出可進場的股票，必須新增一個\"isIn\"欄位'''\n", "        return Kbars\n\t    def examineOpen(self, inputs: dict, kbars: dict, **kwargs):\n\t        '''檢查進場條件'''\n\t        return self.Action(100, '進場', 'msg', kbars['1D']['Open'])\n\t    def examineClose(self, inputs: dict, kbars: dict, **kwargs):\n\t        '''檢查出場條件'''\n\t        if inputs['low'] < inputs['open']:\n\t            closePrice = inputs['open']\n\t            return self.Action(100, '出場', 'msg', closePrice)\n\t        return self.Action()\n", "    def computeOpenLimit(self, Kbars: dict, **kwargs):\n\t        '''計算每日買進股票上限(可做幾支)'''\n\t        return 2000\n\t    def computeOpenUnit(self, Kbars: dict):\n\t        '''\n\t        計算買進股數\n\t        參數:\n\t        inputs - 交易判斷當下的股票資料(開高低收等)\n\t        '''\n\t        return 5\n", "    def setVolumeProp(self, market_value: float):\n\t        '''根據成交量比例設定進場張數'''\n\t        return 0.025\n\t    def on_set_script_function(self, testScript, attrName):\n\t        def wrapper(func):\n\t            if hasattr(testScript, attrName):\n\t                setattr(self, attrName, func)\n\t            return func\n\t        return wrapper\n\t    def set_scripts(self, testScript: object = None):\n", "        '''設定回測腳本'''\n\t        if not testScript:\n\t            return\n\t        BacktestPerformance.__init__(self, testScript)\n\t        self.Script = testScript\n\t        self.isLong = testScript.mode == 'long'\n\t        self.sign = 1 if self.isLong else -1\n\t        @self.on_set_script_function(testScript, 'addFeatures')\n\t        def func1(df):\n\t            return testScript.addFeatures(df)\n", "        @self.on_set_script_function(testScript, 'selectStocks')\n\t        def func2(df):\n\t            return testScript.selectStocks(df)\n\t        @self.on_set_script_function(testScript, 'examineOpen')\n\t        def func3(inputs, kbars, **kwargs):\n\t            return testScript.examineOpen(inputs, kbars, **kwargs)\n\t        @self.on_set_script_function(testScript, 'examineClose')\n\t        def func4(inputs, kbars, **kwargs):\n\t            return testScript.examineClose(inputs, kbars, **kwargs)\n\t        @self.on_set_script_function(testScript, 'computeOpenLimit')\n", "        def func5(Kbars, **kwargs):\n\t            return testScript.computeOpenLimit(Kbars, **kwargs)\n\t        @self.on_set_script_function(testScript, 'computeOpenUnit')\n\t        def func6(inputs):\n\t            return testScript.computeOpenUnit(inputs)\n\t        @self.on_set_script_function(testScript, 'setVolumeProp')\n\t        def func7(market_value):\n\t            return testScript.setVolumeProp(market_value)\n\t    def updateMarketValue(self):\n\t        '''更新庫存市值'''\n", "        if self.stocks:\n\t            amount = sum([\n\t                self.computeCloseAmount(\n\t                    s['openPrice'], s['price'], s['quantity'])[1]\n\t                for s in self.stocks.values()\n\t            ])\n\t        else:\n\t            amount = 0\n\t        self.market_value = self.balance + amount\n\t    def _updateStatement(self, **kwargs):\n", "        '''更新交易紀錄'''\n\t        price = kwargs['price']\n\t        quantity = kwargs['quantity']\n\t        data = self.stocks[kwargs['stockid']]\n\t        openPrice = data['openPrice']\n\t        openamount, amount = self.computeCloseAmount(\n\t            openPrice, price, quantity)\n\t        openfee = self.computeFee(openamount)\n\t        closefee = self.computeFee(amount)\n\t        interest = self.computeLeverageInterest(\n", "            kwargs['day'], data['day'], openamount)\n\t        tax = self.computeTax(openPrice, price, quantity)\n\t        if self.isLong:\n\t            return_ = data['cum_max_min']/openPrice\n\t        else:\n\t            return_ = openPrice/data['cum_max_min']\n\t        self.balance += (amount - closefee - interest - tax)\n\t        self.statements.append({\n\t            'Code': kwargs['stockid'],\n\t            'OpenTime': data['day'],\n", "            'OpenReason': data['openReason'],\n\t            'OpenPrice': openPrice,\n\t            'OpenQuantity': quantity,\n\t            'OpenAmount': openamount,\n\t            'OpenFee': openfee,\n\t            'CloseTime': kwargs['day'],\n\t            'CloseReason': kwargs['reason'],\n\t            'ClosePrice': price,\n\t            'CloseQuantity': quantity,\n\t            'CloseAmount': amount,\n", "            'CloseFee': closefee,\n\t            'Tax': tax,\n\t            'KRun': data['krun'],\n\t            'PotentialReturn': 100*round(return_ - 1, 4)\n\t        })\n\t    def execute(self, trans_type: str, **kwargs):\n\t        '''\n\t        新增/更新庫存明細\n\t        trans_type: 'Open' or 'Close'\n\t        '''\n", "        stockid = kwargs['stockid']\n\t        day = kwargs['day']\n\t        price = kwargs['price']\n\t        if trans_type == 'Open':\n\t            quantity = kwargs['quantity']\n\t            amount = kwargs['amount']\n\t            self.balance -= amount\n\t            if stockid not in self.stocks:\n\t                self.stocks.update({\n\t                    stockid: {\n", "                        'day': day,\n\t                        'openPrice': price,\n\t                        'quantity': quantity,\n\t                        'position': 100,\n\t                        'price': price,\n\t                        'profit': 1,\n\t                        'amount': amount,\n\t                        'openReason': kwargs['reason'],\n\t                        'krun': 0,\n\t                        'cum_max_min': kwargs['cum_max_min'],\n", "                        'bsh': kwargs['bsh']\n\t                    }\n\t                })\n\t            else:\n\t                self.computeAveragePrice(quantity, price)\n\t        else:\n\t            quantity = self.computeCloseUnit(stockid, kwargs['position'])\n\t            kwargs['quantity'] = quantity\n\t            self._updateStatement(**kwargs)\n\t            if quantity <= self.stocks[stockid]['quantity']:\n", "                self.stocks[stockid]['quantity'] -= quantity\n\t                self.stocks[stockid]['position'] -= kwargs['position']\n\t            if self.stocks[stockid]['quantity'] <= 0:\n\t                self.stocks.pop(stockid, None)\n\t                self.nClose += 1\n\t    def get_tick_delta(self, stock_price: float):\n\t        if stock_price < 10:\n\t            return 0.01\n\t        elif stock_price < 50:\n\t            return 0.05\n", "        elif stock_price < 100:\n\t            return 0.1\n\t        elif stock_price < 500:\n\t            return 0.5\n\t        elif stock_price < 1000:\n\t            return 1\n\t        return 5\n\t    def computePriceByDev(self, stock_price: float, dev: float):\n\t        '''計算真實股價(By tick price)'''\n\t        tick_delta = self.get_tick_delta(stock_price)\n", "        return round(int(stock_price*dev/tick_delta)*tick_delta + tick_delta, 2)\n\t    def computeOpenAmount(self, price: float, quantity: int):\n\t        if self.Market == 'Stocks':\n\t            return quantity*price*self.leverage\n\t        return quantity*self.margin\n\t    def computeCloseAmount(self, openPrice: float, closePrice: float, quantity: int):\n\t        openAmount = self.computeOpenAmount(openPrice, quantity)\n\t        profit = (closePrice - openPrice)*quantity\n\t        if self.Market == 'Stocks' and self.leverage == 1:\n\t            closeAmount = closePrice*quantity\n", "        elif self.Market == 'Stocks' and self.leverage != 1:\n\t            closeAmount = openAmount + profit\n\t        else:\n\t            closeAmount = openAmount + profit*self.multipler*self.sign\n\t        return openAmount, closeAmount\n\t    def computeCloseUnit(self, stockid: str, prop: float):\n\t        '''從出場的比例%推算出場量(張/口)'''\n\t        q_balance = self.stocks[stockid]['quantity']\n\t        position_now = self.stocks[stockid]['position']\n\t        if prop != 100 and position_now != prop and q_balance > 1000:\n", "            q_target = q_balance/1000\n\t            q_target = int(q_target*prop/100)\n\t            if q_target == 0:\n\t                return 1000\n\t            return min(1000*q_target, q_balance)\n\t        return q_balance\n\t    def computeFee(self, amount: float):\n\t        return max(round(amount*self.FEE_RATE), 20)\n\t    def computeAveragePrice(self, stockid: str, quantity: int, price: float):\n\t        # 加碼後更新\n", "        data = self.stocks[stockid]\n\t        total_quantity = data['quantity'] + quantity\n\t        total_amount = data['openPrice']*data['quantity'] + price*quantity\n\t        average_price = round(total_amount/total_quantity, 2)\n\t        self.stocks[stockid].update({\n\t            'openPrice': average_price,\n\t            'quantity': total_quantity,\n\t            'openReason': data['openReason'] + f'<br>{quantity}'\n\t        })\n\t    def computeTax(self, openPrice: float, closePrice: float, quantity: int):\n", "        if self.Market == 'Stocks':\n\t            return round((openPrice*quantity)*self.TAX_RATE_STOCK)\n\t        return round(closePrice*quantity*self.multipler*self.TAX_RATE_FUTURES)\n\t    def computeLeverageInterest(self, day1: Union[str, datetime], day2: Union[str, datetime], amount: float):\n\t        if self.leverage == 1:\n\t            return 0\n\t        d = self.date_diff(day1, day2)\n\t        return amount*(1 - self.leverage)*self.LEVERAGE_INTEREST*d/365\n\t    def checkOpenUnitLimit(self, unit: float, volume_ma: float):\n\t        unit = max(round(unit), 0)\n", "        unit_limit = max(volume_ma*self.volume_prop, 10)\n\t        unit = int(min(unit, unit_limit)/self.leverage)\n\t        return min(unit, 2000)  # 上限 2000 張\n\t    def checkOpen(self, inputs: dict):\n\t        '''\n\t        買進條件判斷\n\t        參數:\n\t        day - 交易日(時間)\n\t        inputs - 交易判斷當下的股票資料(開高低收等)\n\t        '''\n", "        unit = self.computeOpenUnit(inputs)\n\t        # if 'volume_ma' in inputs:\n\t        #     unit = self.checkOpenUnitLimit(unit, inputs['volume_ma'])\n\t        openInfo = self.examineOpen(\n\t            None,\n\t            kbars=inputs,\n\t            market_value=self.market_value,\n\t            day_trades=self.day_trades\n\t        )\n\t        if openInfo.price > 0 and unit > 0:\n", "            name = inputs['name']\n\t            data = inputs[self.Script.scale][name]\n\t            if name in self.stocks:\n\t                # 加碼部位\n\t                quantity = 1000*(self.stocks[name]['quantity']/1000)/3\n\t            elif self.Market == 'Stocks':\n\t                quantity = 1000*unit\n\t            else:\n\t                quantity = unit\n\t            amount = self.computeOpenAmount(openInfo.price, quantity)\n", "            fee = self.computeFee(amount)\n\t            if self.balance >= amount+fee and len(self.stocks) < self.nStocksLimit:\n\t                self.execute(\n\t                    trans_type='Open',\n\t                    day=data['Time'],\n\t                    stockid=name,\n\t                    price=openInfo.price,\n\t                    quantity=quantity,\n\t                    position=None,\n\t                    amount=amount,\n", "                    cum_max_min=data['High'] if self.isLong else data['Low'],\n\t                    reason=openInfo.reason,\n\t                    bsh=data['High']\n\t                )\n\t                self.day_trades.append(name)\n\t    def checkMarginCall(self, name: str, closePrice: float):\n\t        if self.leverage == 1:\n\t            return False\n\t        openPrice = self.stocks[name]['openPrice']\n\t        margin = closePrice/(openPrice*(1 - self.leverage))\n", "        return margin < 1.35\n\t    def checkClose(self, inputs: dict, stocksClosed: dict):\n\t        name = inputs['name']\n\t        data = inputs[self.Script.scale][name]\n\t        value = data['High'] if self.isLong else data['Low']\n\t        cum_max_min = min(self.stocks[name]['cum_max_min'], value)\n\t        self.stocks[name].update({\n\t            'price': data['Close'],\n\t            'krun': self.stocks[name]['krun'] + 1,\n\t            'cum_max_min': cum_max_min\n", "        })\n\t        closeInfo = self.examineClose(\n\t            inputs=self.stocks,\n\t            kbars=inputs,\n\t            stocksClosed=stocksClosed\n\t        )\n\t        margin_call = self.checkMarginCall(name, closeInfo.price)\n\t        if closeInfo.position or margin_call:\n\t            self.execute(\n\t                trans_type='Close',\n", "                day=data['Time'],\n\t                stockid=name,\n\t                price=closeInfo.price,\n\t                quantity=None,\n\t                position=100 if margin_call else closeInfo.position,\n\t                reason='維持率<133%' if margin_call else closeInfo.reason\n\t            )\n\t    def set_open_order(self, df: pd.DataFrame):\n\t        # by 成交值\n\t        if self.buyOrder == 'z_totalamount':\n", "            df = df.sort_values('z_totalamount')\n\t        # by 族群＆成交值\n\t        elif self.buyOrder == 'category':\n\t            name_count = df[df.isIn == True].groupby('category').name.count()\n\t            name_count = name_count.to_dict()\n\t            df['n_category'] = df.category.map(name_count).fillna(0)\n\t            df = df.sort_values(['n_category'], ascending=False)\n\t        else:\n\t            df = df.sort_values('Close')\n\t        return df\n", "    def set_params(self, **params):\n\t        '''參數設定'''\n\t        init_position = params.get('init_position', 1000000)\n\t        self.balance = self.init_balance = self.market_value = init_position\n\t        self.buyOrder = params.get('buyOrder', None)\n\t        self.Kbars = {}\n\t        self.day_trades = []\n\t        self.statements = []\n\t        self.stocks = {}\n\t        self.daily_info = {}\n", "    def run(self, Kbars: dict, **params):\n\t        '''\n\t        回測\n\t        參數:\n\t        Kbars - 歷史資料表\n\t        '''\n\t        self.set_params(**params)\n\t        stocksClosed = {}\n\t        if hasattr(self, 'Script'):\n\t            print(f\"Strategy: {self.Script.strategy}{self.Script.scale}\")\n", "        t1 = time.time()\n\t        df = Kbars[self.Script.scale].sort_values('Time')\n\t        group = df.groupby('Time')\n\t        N = len(group)\n\t        for i, (time_, rows) in enumerate(group):\n\t            self.nClose = 0\n\t            self.volume_prop = self.setVolumeProp(self.market_value)\n\t            # 進場順序\n\t            stockids = list(self.stocks) + self.indexes\n\t            rows = rows[(rows.isIn == 1) | (rows.name.isin(stockids))]\n", "            if rows.name.nunique() == 2:\n\t                continue\n\t            # 取出當天(或某小時)所有股票資訊\n\t            chance = rows.isIn.sum()\n\t            if rows.nth_bar.min() == 1:\n\t                day = str(pd.to_datetime(time_).date())\n\t                tb = Kbars['1D'][Kbars['1D'].date == day]\n\t                self.Kbars['1D'] = tb.set_index('name').to_dict('index')\n\t                del tb\n\t                self.nStocksLimit = self.computeOpenLimit(\n", "                    self.Kbars, day=time_)\n\t                self.day_trades = []\n\t            # 檢查進場 & 出場\n\t            rows = self.set_open_order(rows)\n\t            rows = rows.set_index('name').to_dict('index')\n\t            for name, row in rows.items():\n\t                if name in self.indexes:\n\t                    continue\n\t                inputs = Kbars.copy()\n\t                temp = {name: row}\n", "                temp.update({k: rows[k] for k in self.indexes if k in rows})\n\t                inputs[self.Script.scale] = temp\n\t                inputs['name'] = name\n\t                if '1D' in Kbars:\n\t                    inputs['1D'] = self.Kbars['1D']\n\t                if name in self.stocks:\n\t                    self.checkClose(inputs, stocksClosed)\n\t                else:\n\t                    self.checkOpen(inputs)\n\t            # 更新交易明細數據\n", "            self.daily_info[time_] = {\n\t                'chance': chance,\n\t                'n_stock_limit': self.nStocksLimit,\n\t                'n_stocks': len(self.stocks),\n\t                'nClose': self.nClose\n\t            }\n\t            self.updateMarketValue()\n\t            progress_bar(N, i)\n\t        t2 = time.time()\n\t        print(f\"\\nBacktest time: {round(t2-t1, 2)}s\")\n", "        # 清空剩餘庫存\n\t        for name in list(self.stocks):\n\t            self.execute(\n\t                trans_type='Close',\n\t                day=time_,\n\t                stockid=name,\n\t                price=self.stocks[name]['price'],\n\t                quantity=None,\n\t                position=100,\n\t                reason='清空庫存'\n", "            )\n\t        self.daily_info.update({time_: {'nClose': self.nClose}})\n\t        result = self.get_backtest_result(\n\t            **params,\n\t            statement=self.statements,\n\t            startDate=df.Time.min(),\n\t            endDate=df.Time.max(),\n\t            daily_info=pd.DataFrame(self.daily_info).T,\n\t            isLong=self.isLong,\n\t            Kbars=Kbars\n", "        )\n\t        del df, rows\n\t        return result\n"]}
{"filename": "trader/performance/__init__.py", "chunked_list": ["import os\n\timport sys\n\tfrom ..config import PATH\n\tfrom .. import file_handler\n\tsys.path.append(os.path.abspath(os.path.join('./', os.pardir)))\n\tfile_handler.create_folder(f'{PATH}/backtest')\n"]}
{"filename": "trader/performance/charts.py", "chunked_list": ["import pandas as pd\n\timport plotly.graph_objects as go\n\tfrom plotly.subplots import make_subplots\n\tdef convert_encodings(filename):\n\t    try:\n\t        f = open(filename, \"r+\")\n\t        fstr = f.read()\n\t        ffilter = 'utf-8'\n\t        fposition = fstr.find(ffilter)\n\t        f.seek(fposition, 0)\n", "        f.write('  Big5  ')\n\t        f.close()\n\t    except:\n\t        print(\"\\nCan't convert encoding to Big5\")\n\tdef export_figure(fig, filename):\n\t    if '.html' in fig:\n\t        fig.write_html(filename)\n\t    fig.write_image(filename, scale=5)\n\tclass SuplotHandler:\n\t    def add_table(self, fig: make_subplots, df: pd.DataFrame, row: int, col: int, **cellargs):\n", "        '''Subplot add table'''\n\t        fig.add_trace(\n\t            go.Table(\n\t                header=dict(\n\t                    values=list(df.columns),\n\t                    font=dict(size=15),\n\t                    align=\"center\"\n\t                ),\n\t                cells=dict(\n\t                    values=[df[k].tolist() for k in df.columns],\n", "                    align=\"center\",\n\t                    font=dict(size=13),\n\t                    **cellargs\n\t                )\n\t            ),\n\t            row=row,\n\t            col=col\n\t        )\n\t        return fig\n\t    def add_candlestick(self, fig, df, row, col):\n", "        if not df.shape[0]:\n\t            return fig\n\t        title = {'1': 'TWSE', '101': 'OTC'}\n\t        name = df.name.unique()[0]\n\t        name = title[name] if name in title else name\n\t        # plot candlestick\n\t        fig.add_trace(\n\t            go.Candlestick(\n\t                x=df.Time,\n\t                open=df.Open,\n", "                high=df.High,\n\t                low=df.Low,\n\t                close=df.Close,\n\t                name=name,\n\t                increasing=dict(line=dict(color='#e63746')),\n\t                decreasing=dict(line=dict(color='#42dd31')),\n\t            ),\n\t            row=row,\n\t            col=col,\n\t            secondary_y=True\n", "        )\n\t        # plot MA\n\t        for c, d in [('#447a9c', 5), ('#E377C2', 10)]:\n\t            ma = df.Close.rolling(d).mean().values\n\t            fig.add_trace(\n\t                go.Scatter(\n\t                    x=df.Time,\n\t                    y=ma,\n\t                    mode='lines+text',\n\t                    marker_color=c,\n", "                    name=f'{d}MA',\n\t                    text=[\n\t                        f'{d}MA' if i == d else '' for i, _ in enumerate(ma)],\n\t                    textfont=dict(color=c),\n\t                    textposition='bottom right',\n\t                ),\n\t                row=row,\n\t                col=col,\n\t                secondary_y=True\n\t            )\n", "        # plot volume\n\t        colors = [\n\t            '#d3efd2' if o >= c else '#efd2d8' for o, c in zip(df.Open, df.Close)\n\t        ]\n\t        fig.add_trace(\n\t            go.Bar(\n\t                x=df.Time,\n\t                y=df.Volume,\n\t                marker_color=colors,\n\t                name='Volume',\n", "            ),\n\t            row=row,\n\t            col=col,\n\t            secondary_y=False\n\t        )\n\t        # update axes settings\n\t        fig.update_xaxes(\n\t            rangeslider=dict(visible=False),\n\t            rangebreaks=[\n\t                dict(bounds=[\"sat\", \"mon\"]),\n", "                # dict(bounds=[14, 8], pattern=\"hour\"),\n\t            ],\n\t            row=row,\n\t            col=col,\n\t        )\n\t        fig.update_yaxes(\n\t            title=name,\n\t            secondary_y=True,\n\t            showgrid=True,\n\t            tickformat=\".0f\",\n", "            row=row,\n\t            col=col\n\t        )\n\t        fig.update_yaxes(\n\t            title=\"Volume\",\n\t            secondary_y=False,\n\t            showgrid=False,\n\t            row=row,\n\t            col=col\n\t        )\n", "        return fig\n\t    def add_line(self, fig: make_subplots, df: pd.DataFrame, row: int, col: int, settings: dict, **kwargs):\n\t        fig.add_trace(\n\t            go.Scatter(\n\t                x=df.index,\n\t                y=df[settings['y']],\n\t                mode='lines',\n\t                name=settings['name'],\n\t                marker_color=settings['marker_color'],\n\t                **kwargs\n", "            ),\n\t            row=row,\n\t            col=col\n\t        )\n\t        return fig\n"]}
{"filename": "trader/performance/reports.py", "chunked_list": ["import logging\n\timport numpy as np\n\timport pandas as pd\n\tfrom datetime import timedelta\n\tfrom collections import namedtuple\n\timport plotly.graph_objects as go\n\tfrom plotly.subplots import make_subplots\n\tfrom ..config import PATH, TODAY, TODAY_STR, SelectMethods, StrategyNameList\n\tfrom ..utils import progress_bar\n\tfrom ..utils.time import TimeTool\n", "from ..utils.file import FileHandler\n\tfrom ..utils.orders import OrderTool\n\tfrom ..utils.database import db, KBarTables\n\tfrom ..utils.database.tables import SelectedStocks\n\tfrom .base import convert_statement\n\tfrom .backtest import BacktestPerformance\n\tfrom .charts import export_figure, convert_encodings, SuplotHandler\n\ttry:\n\t    from ..scripts import backtest_config\n\texcept:\n", "    logging.warning('Cannot import test scripts from package.')\n\t    backtest_config = None\n\tclass FiguresSet:\n\t    pass\n\tclass PerformanceReport(SuplotHandler, OrderTool, TimeTool, FileHandler):\n\t    def __init__(self, account: str):\n\t        self.set_report_scripts(backtest_config)\n\t        self.account = account\n\t        self.TablesFile = f'{PATH}/daily_info/{TODAY_STR[:-3]}-performance-{account}.xlsx'\n\t        self.Tables = namedtuple(\n", "            typename='Tables',\n\t            field_names=['Configuration', 'Summary', 'Statement', 'Selection'],\n\t            defaults=[None]*4\n\t        )\n\t        self.strategies = []\n\t    def set_report_scripts(self, report_scripts: object = None):\n\t        if report_scripts:\n\t            bts = report_scripts.__dict__\n\t            self.Scripts = {\n\t                k[:-3]: v for k, v in bts.items()\n", "                if ('T' in k or 'D' in k) and (k[:-3] in SelectMethods)\n\t            }\n\t        else:\n\t            self.Scripts = {}\n\t    def getStrategyList(self, df: pd.DataFrame):\n\t        '''Get strategy list in code order'''\n\t        strategies = pd.DataFrame([StrategyNameList.Code]).T.reset_index()\n\t        strategies.columns = ['name', 'code']\n\t        strategies = strategies[strategies.name.isin(df.Strategy)].name.values\n\t        return strategies\n", "    def getTables(self, config, start=None, end=None):\n\t        def concat_strategy_table(results: dict, table_name: str):\n\t            df = pd.DataFrame()\n\t            for k, v in results.items():\n\t                if table_name == 'Configuration':\n\t                    temp = v.Configuration\n\t                else:\n\t                    temp = v.Summary\n\t                temp = temp.rename(\n\t                    columns={'Description': k}).set_index('Content')\n", "                df = pd.concat([df, temp], axis=1)\n\t            return df.reset_index()\n\t        init_position = int(config['INIT_POSITION'])\n\t        df = self.read_statement(f'simulate-{self.account}')\n\t        if not df.shape[0]:\n\t            return None\n\t        df = convert_statement(df, init_position=init_position)\n\t        # filter data\n\t        if start is None and end is None:\n\t            df = df[df.CloseTime.dt.month == TODAY.month]\n", "        else:\n\t            if not start:\n\t                start = TODAY_STR[:-2] + '01'\n\t            if not end:\n\t                end = TODAY_STR\n\t            df = df[(df.CloseTime >= str(start)) & (df.CloseTime <= str(end))]\n\t        self.strategies = self.getStrategyList(df)\n\t        results = {}\n\t        for stra in self.strategies:\n\t            backtest_config = self.Scripts[stra]\n", "            bp = BacktestPerformance(backtest_config)\n\t            statement = df[df.Strategy == stra]\n\t            result = dict(\n\t                init_position=init_position,\n\t                unit=int(init_position/100000),\n\t                buyOrder='Close',\n\t                statement=statement,\n\t            )\n\t            performance = bp.get_backtest_result(**result)\n\t            results[stra] = performance\n", "        df_config = concat_strategy_table(results, 'Configuration')\n\t        df_summary = concat_strategy_table(results, 'Summary')\n\t        return self.Tables(df_config, df_summary, df)\n\t    def save_tables(self, Tables: namedtuple):\n\t        writer = pd.ExcelWriter(self.TablesFile, engine='xlsxwriter')\n\t        Tables.Configuration.to_excel(\n\t            writer, encoding='utf-8-sig', index=False, sheet_name='Configuration')\n\t        Tables.Summary.to_excel(\n\t            writer, encoding='utf-8-sig', index=False, sheet_name='Summary')\n\t        Tables.Statement.to_excel(\n", "            writer, encoding='utf-8-sig', index=False, sheet_name='Statement')\n\t        writer.save()\n\t    def getSelections(self, statement):\n\t        start = self.last_business_day(statement.OpenTime.values[0])\n\t        if db.HAS_DB:\n\t            df = db.query(\n\t                SelectedStocks,\n\t                SelectedStocks.Time >= start\n\t            )\n\t        else:\n", "            dir_path = f'{PATH}/selections/history'\n\t            df = self.read_tables_in_folder(dir_path)\n\t        df = df[\n\t            df.Strategy.isin(statement.Strategy) &\n\t            (df.Time >= start)\n\t        ]\n\t        df['isLong'] = df.Strategy.map(\n\t            statement.set_index('Strategy').isLong.to_dict()\n\t        )\n\t        return df\n", "    def getKbarTable(self, df_select: pd.DataFrame):\n\t        start = df_select.Time.min()\n\t        end = df_select.Time.max() + timedelta(days=20)\n\t        names = df_select.code.to_list() + ['1', '101']\n\t        if db.HAS_DB:\n\t            df = KBarTables['1D']\n\t            df = db.query(\n\t                df,\n\t                df.Time >= start,\n\t                df.Time <= end,\n", "                df.name.in_(names)\n\t            )\n\t        else:\n\t            dir_path = f'{PATH}/KBars/1D'\n\t            df = self.read_tables_in_folder(dir_path)\n\t            df = df[\n\t                (df.Time >= start) &\n\t                (df.Time <= end) &\n\t                df.name.isin(names)\n\t            ]\n", "        df = df.sort_values(['name', 'Time']).reset_index(drop=True)\n\t        return df\n\t    def plot_performance_report(self, Tables: namedtuple = None, save=True):\n\t        if Tables is None:\n\t            df = pd.read_excel(self.TablesFile, sheet_name='Statement')\n\t            df_config = pd.read_excel(\n\t                self.TablesFile, sheet_name='Configuration')\n\t            df_summary = pd.read_excel(self.TablesFile, sheet_name='Summary')\n\t            df_summary.iloc[22, 1:] = df_summary.iloc[22, 1:].apply(\n\t                lambda x: float(x.replace('%', '')))\n", "        else:\n\t            df = Tables.Statement\n\t            df_config = Tables.Configuration\n\t            df_summary = Tables.Summary\n\t        if not df.shape[0]:\n\t            return None\n\t        df.OpenTime = df.OpenTime.dt.date\n\t        df.CloseTime = df.CloseTime.dt.date\n\t        df_select = self.getSelections(df)\n\t        table = self.getKbarTable(df_select)\n", "        tb = df_select.drop_duplicates(['code', 'Time', 'isLong'])\n\t        profits = np.array([0.0]*tb.shape[0])\n\t        for i, (code, day, is_long) in enumerate(zip(tb.code, tb.Time, tb.isLong)):\n\t            temp = table[(table.name == code) & (table.Time >= day)].head(5)\n\t            v1 = temp.Open.values[0]\n\t            v2 = temp.Close.values[-1]\n\t            m = 1 if is_long else -1\n\t            profits[i] = 100*m*(v2-v1)/v1\n\t        tb['profit'] = profits.round(4)\n\t        tb['profit'].sum()\n", "        # Make Plots\n\t        subplot_titles = (\n\t            \"TWSE\",\n\t            \"OTC\",\n\t            'Number of Daily Selections',\n\t            'Accumulated Profits',\n\t            '5-day Percentage Change After Selection',\n\t            'Actual Trading Profits',\n\t            \"Trading Volume\",\n\t            \"Profit Factor/Profit Ratio\",\n", "        )\n\t        specs = [[{'secondary_y': True}]*2] + [[{}, {}]]*3\n\t        fig = make_subplots(\n\t            rows=4, cols=2, subplot_titles=subplot_titles, specs=specs)\n\t        if self.strategies == []:\n\t            self.strategies = self.getStrategyList(df)\n\t        colors = [\n\t            'rgb(22, 65, 192)',\n\t            'rgb(16, 154, 246)',\n\t            'rgb(49, 220, 246)',\n", "            'rgb(49, 92, 246)',\n\t            'rgb(49, 122, 246)',\n\t            'rgb(28, 157, 212)',\n\t            'rgb(89, 213, 238)',\n\t            'rgb(49, 246, 240)',\n\t            'rgb(128, 229, 249)',\n\t            'rgb(139, 186, 234)',\n\t        ][:len(self.strategies)]\n\t        # Candlesticks\n\t        for name, col in [['1', 1], ['101', 2]]:\n", "            temp = table[table.name == name]\n\t            fig = self.add_candlestick(fig, temp, 1, col)\n\t        for stra, color in zip(self.strategies, colors):\n\t            name = StrategyNameList.Code[stra]\n\t            # 每日選股數\n\t            tb1 = df_select[df_select.Strategy == stra]\n\t            tb1 = tb1.groupby(['Time', 'Strategy']).code.count()\n\t            tb1 = tb1.reset_index()\n\t            max_point = tb1.code.max()\n\t            fig.add_trace(\n", "                go.Scatter(\n\t                    x=tb1.Time,\n\t                    y=tb1.code,\n\t                    name=name,\n\t                    showlegend=False,\n\t                    marker_color=color,\n\t                    mode='lines+text',\n\t                    fill='tonexty',\n\t                    stackgroup='one',\n\t                    text=[name if x == max_point else '' for x in tb1.code],\n", "                    textfont=dict(color='rgb(157, 42, 44)'),\n\t                    textposition='top center',\n\t                ),\n\t                row=2,\n\t                col=1\n\t            )\n\t            # 選股後5天漲幅(%)\n\t            fig.add_trace(\n\t                go.Histogram(\n\t                    x=tb[tb.Strategy == stra].profit,\n", "                    name=name,\n\t                    showlegend=False,\n\t                    marker_color=color,\n\t                    nbinsx=50,\n\t                ),\n\t                row=3,\n\t                col=1\n\t            )\n\t            # 實際交易獲利(%)\n\t            tb2 = df[df.Strategy == stra].copy()\n", "            fig.add_trace(\n\t                go.Scatter(\n\t                    x=tb2.returns,\n\t                    y=tb2.profit,\n\t                    name=name,\n\t                    showlegend=False,\n\t                    marker_color=color,\n\t                    mode='markers',\n\t                ),\n\t                row=3,\n", "                col=2\n\t            )\n\t            # 累積獲利\n\t            init_position = int(df_config.loc[0, stra].replace(',', ''))\n\t            tb2 = tb2.groupby('CloseTime').profit.sum().reset_index()\n\t            tb2['cumsum_profit'] = 100*(tb2.profit.cumsum()/init_position)\n\t            max_point = tb2.cumsum_profit.max()\n\t            fig.add_trace(\n\t                go.Scatter(\n\t                    x=tb2.CloseTime,\n", "                    y=tb2.cumsum_profit,\n\t                    name=name,\n\t                    showlegend=False,\n\t                    marker_color=color,\n\t                    mode='lines+text',\n\t                    fill='tozeroy',\n\t                    text=[name if x == max_point else '' for x in tb2.cumsum_profit],\n\t                    textfont=dict(color='rgb(157, 42, 44)'),\n\t                    textposition='top left',\n\t                ),\n", "                row=2,\n\t                col=2\n\t            )\n\t        # 交易量 & 獲利因子/盈虧比\n\t        colors = [\n\t            'rgb(252, 193, 74)',\n\t            'hsl(51, 55%, 82%)',\n\t            'rgb(245, 126, 0)',\n\t            'rgb(17, 76, 95)',\n\t            'rgb(16, 154, 246)'\n", "        ]\n\t        for c, i in zip(colors, [17, 18, 19, 21, 22]):\n\t            tb3 = df_summary.iloc[i, :]\n\t            fig.add_trace(\n\t                go.Bar(\n\t                    x=[StrategyNameList.Code[s] for s in tb3[1:].index],\n\t                    y=tb3[1:],\n\t                    showlegend=False,\n\t                    marker_color=c,\n\t                ),\n", "                row=4,\n\t                col=1 if i < 22 else 2\n\t            )\n\t        start = df.OpenTime.min()\n\t        end = df.CloseTime.max()\n\t        title = f'{start} ~ {end} Trading Performance'\n\t        fig.update_layout(\n\t            title=title,\n\t            title_x=0.5,\n\t            title_font=dict(size=23),\n", "            bargap=0.15,\n\t            height=1500,\n\t            width=1000\n\t        )\n\t        fig.update_yaxes(title='Profit(%)', row=2, col=2)\n\t        fig.update_xaxes(title='Return(%)', row=3, col=1)\n\t        fig.update_yaxes(title='Count', row=3, col=1)\n\t        fig.update_xaxes(title='Return(%)', row=3, col=2)\n\t        fig.update_yaxes(title='Profit', tickvals=[0], row=3, col=2)\n\t        if save:\n", "            export_figure(fig, self.TablesFile.replace('xlsx', 'jpg'))\n\t        return fig\n\tclass BacktestReport(SuplotHandler, FileHandler):\n\t    def __init__(self, backtestScript) -> None:\n\t        self.Figures = FiguresSet\n\t        self.Script = backtestScript\n\t        self.DATAPATH = f'{PATH}/backtest'\n\t        self.col_maps = {\n\t            'chance': 'first',\n\t            'n_stock_limit': 'first',\n", "            'n_stocks': 'last',\n\t            'nClose': 'sum',\n\t            'balance': 'last',\n\t            'nOpen': 'sum',\n\t            'profit': 'sum',\n\t        }\n\t        self.Titles = (\n\t            # tables\n\t            'Backtest Settings', '',\n\t            'Summary', '',\n", "            'Transaction Detail', '',\n\t            # candles\n\t            'TWSE', 'OTC',\n\t            # lines/scatters\n\t            'Put/Call Ratio', 'Changes in Opens & Closes',\n\t            'Balance', 'Accumulated Profit/Loss',\n\t            'Changes in Portfolio Control', ''\n\t        )\n\t    def _replaceString(self, x: str):\n\t        return str(x).replace(' ', '<br>').replace('00.000000000', '00')\n", "    def _daily_info_processor(self, TestResult: object):\n\t        profit = TestResult.Statement.groupby('CloseTime').profit.sum()\n\t        profit = profit.to_dict()\n\t        df = TestResult.DailyInfo\n\t        df['profit'] = df.index.map(profit).fillna(0).values\n\t        df = df.resample('1D', closed='left', label='left').apply(self.col_maps)\n\t        df = df.dropna()\n\t        df['profits'] = (df.profit*(df.profit > 0)).cumsum()\n\t        df['losses'] = (df.profit*(df.profit <= 0)).cumsum()\n\t        return df\n", "    def plot_backtest_result(self, TestResult: object, Kbars: dict, title=\"Backtest Report\"):\n\t        '''將回測結果畫成圖表'''\n\t        if TestResult.Statement is None:\n\t            return self.Figures\n\t        statement = TestResult.Statement.copy()\n\t        statement.OpenTime = statement.OpenTime.apply(self._replaceString)\n\t        statement.CloseTime = statement.CloseTime.apply(self._replaceString)\n\t        daily_info = self._daily_info_processor(TestResult)\n\t        N = 7\n\t        n_tables = 3\n", "        spec1 = [[{\"type\": \"table\", \"colspan\": 2}, {}]]*n_tables  # 3張表\n\t        spec2 = [[{'secondary_y': True}]*2]  # TSE & OTC K線圖\n\t        spec3 = [[{\"type\": \"scatter\"}]*2]*(N-n_tables-1)  # 其餘折線走勢圖\n\t        fig = make_subplots(\n\t            rows=N,\n\t            cols=2,\n\t            vertical_spacing=0.02,\n\t            subplot_titles=list(self.Titles),\n\t            specs=spec1 + spec2 + spec3,\n\t            row_heights=[0.1, 0.15, 0.15] + [0.6/(N-n_tables)]*(N-n_tables)\n", "        )\n\t        fig = self.add_table(fig, TestResult.Configuration, row=1, col=1)\n\t        fig = self.add_table(fig, TestResult.Summary, row=2, col=1)\n\t        fig = self.add_table(fig, statement, row=3, col=1, height=40)\n\t        # TSE/OTC candlesticks\n\t        if self.Script.market == 'Stocks':\n\t            for col, (a, b) in enumerate([('1', 'TWSE'), ('101', 'OTC')]):\n\t                temp = Kbars['1D'].copy()\n\t                temp = temp[temp.name == a].sort_values('Time')\n\t                temp['name'] = b\n", "                fig = self.add_candlestick(fig, temp, row=4, col=col+1)\n\t        else:\n\t            fig = self.add_candlestick(fig, Kbars['1D'], row=4, col=1)\n\t        # Put/Call Ratio\n\t        if 'put_call_ratio' in Kbars:\n\t            df_pcr = pd.DataFrame(Kbars['put_call_ratio']).T\n\t            df_pcr['pc115'] = 115\n\t            for args in [\n\t                dict(y='PutCallRatio', name='Put/Call Ratio',\n\t                     marker_color='#ff9f1a'),\n", "                dict(y='pc115', name='多空分界', marker_color='#68c035'),\n\t            ]:\n\t                fig = self.add_line(\n\t                    fig,\n\t                    df_pcr,\n\t                    row=5,\n\t                    col=1,\n\t                    settings=args\n\t                )\n\t        # Changes in Opens & Closes\n", "        for args in [\n\t            dict(y='nOpen', name='Opens', marker_color='#48b2ef'),\n\t            dict(y='nClose', name='Closes', marker_color='#7F7F7F'),\n\t            dict(y='n_stocks', name='in-stock', marker_color='#ef488e')\n\t        ]:\n\t            fig = self.add_line(fig, daily_info, row=5, col=2, settings=args)\n\t        # Accumulated Balance\n\t        args = dict(y='balance', name='Accumulated Balance',\n\t                    marker_color='#d3503c')\n\t        fig = self.add_line(fig, daily_info, row=6, col=1, settings=args)\n", "        # Accumulated Profit/Loss\n\t        for args in [\n\t            dict(y='profits', name=\"Accumulated Profit\", marker_color='#c25656'),\n\t            dict(y='losses', name=\"Accumulated Loss\", marker_color='#9ad37e')\n\t        ]:\n\t            fig = self.add_line(\n\t                fig, daily_info, row=6, col=2, settings=args, fill='tozeroy')\n\t        # Changes in Portfolio Control\n\t        for args in [\n\t            dict(y='chance', name='Opens Available', marker_color='#48efec'),\n", "            dict(y='n_stock_limit', name='Opens Limit', marker_color='#b1487f')\n\t        ]:\n\t            fig = self.add_line(fig, daily_info, row=7, col=1, settings=args)\n\t        # figure layouts\n\t        fig.update_layout(height=2400, width=1700, title_text=title)\n\t        setattr(self.Figures, 'BacktestResult', fig)\n\t        return self.Figures\n\t    def plot_Ins_Outs(self, df: pd.DataFrame, testResult: object):\n\t        '''畫圖: 個股進出場位置'''\n\t        cols = ['name', 'Time', 'Open', 'High', 'Low', 'Close']\n", "        statement = testResult.Statement\n\t        statement['start'] = statement.groupby(\n\t            'stock').OpenTime.transform(lambda x: x.min() - timedelta(days=5))\n\t        statement['end'] = statement.groupby(\n\t            'stock').CloseTime.transform(lambda x: x.max() + timedelta(days=5))\n\t        tb = df[cols][\n\t            (df.Time >= statement.start.min()) & (df.Time <= statement.end.max())]\n\t        stocks = statement.stock.unique()\n\t        N = stocks.shape[0]\n\t        for i, s in enumerate(stocks):\n", "            df1 = statement[statement.stock == s].copy()\n\t            start = df1.start.values[0]\n\t            end = df1.end.values[0]\n\t            df2 = tb[(tb.name == s) & (tb.Time >= start) & (tb.Time <= end)]\n\t            ins = df2[df2.Time.isin(df1.OpenTime)]\n\t            ins = ins.set_index('Time').Low.to_dict()\n\t            df1['Ins'] = df1.OpenTime.map(ins)\n\t            outs = df2[df2.Time.isin(df1.CloseTime)]\n\t            outs = outs.set_index('Time').High.to_dict()\n\t            df1['Outs'] = df1.CloseTime.map(outs)\n", "            fig = go.Figure(\n\t                data=[\n\t                    go.Candlestick(\n\t                        x=df2.Time,\n\t                        open=df2['Open'],\n\t                        high=df2['High'],\n\t                        low=df2['Low'],\n\t                        close=df2['Close'],\n\t                        name=f'{s}進出場點位',\n\t                        increasing=dict(line=dict(color='Crimson')),\n", "                        decreasing=dict(line=dict(color='LimeGreen'))\n\t                    ),\n\t                    go.Scatter(\n\t                        x=df1.OpenTime,\n\t                        y=df1.Ins*0.96,\n\t                        customdata=np.stack(\n\t                            (df1.OpenReason, df1.Ins),\n\t                            axis=-1\n\t                        ),\n\t                        hovertemplate='%{x} <br>%{customdata[0]} <br>%{customdata[1]} 進場',\n", "                        name='進場',\n\t                        mode='markers',\n\t                        marker=dict(\n\t                            symbol='star-triangle-up',\n\t                            color='MediumBlue',\n\t                            size=10,\n\t                            line=dict(color='MediumPurple', width=1)\n\t                        ),\n\t                    ),\n\t                    go.Scatter(\n", "                        x=df1.CloseTime,\n\t                        y=df1.Outs*1.04,\n\t                        customdata=df1[\n\t                            ['CloseReason', 'Outs', 'profit', 'returns']].values,\n\t                        hovertemplate='%{x} <br>%{customdata[0]} <br>出場: %{customdata[1]} <br>獲利: %{customdata[2]} (%{customdata[3]}%)',\n\t                        name='出場',\n\t                        mode='markers',\n\t                        marker=dict(\n\t                            symbol='star-triangle-down',\n\t                            color='#17BECF',\n", "                            size=10,\n\t                            line=dict(color='MediumPurple', width=1)\n\t                        ),\n\t                    )\n\t                ],\n\t                # 設定 XY 顯示格式\n\t                layout=go.Layout(\n\t                    xaxis=go.layout.XAxis(tickformat='%Y-%m-%d %H:%M'),\n\t                    yaxis=go.layout.YAxis(tickformat='.2f')\n\t                )\n", "            )\n\t            fig.update_xaxes(\n\t                rangebreaks=[\n\t                    dict(bounds=[\"sat\", \"mon\"]),\n\t                    dict(bounds=[14, 8], pattern=\"hour\"),\n\t                ]\n\t            )\n\t            setattr(self.Figures, f'fig{s}', fig)\n\t            progress_bar(N, i)\n\t        return self.Figures\n", "    def save_figure(self, fig: object, filename='回測圖表'):\n\t        '''輸出回測圖表'''\n\t        folder_path = f'{self.DATAPATH}/回測報告/{TODAY_STR}-{filename}'\n\t        self.create_folder(folder_path)\n\t        export_figure(fig.BacktestResult, f'{folder_path}/回測結果.html')\n\t        figures = [f for f in fig.__dict__ if 'fig' in f]\n\t        for f in figures:\n\t            export_figure(fig.__dict__[f], f'{folder_path}/{f}.html')\n\t        files = self.listdir(folder_path, pattern='.html')\n\t        for file in files:\n", "            convert_encodings(f'{folder_path}/{file}')\n"]}
{"filename": "docs/script samples/StrategySet.py", "chunked_list": ["import pandas as pd\n\tfrom datetime import datetime\n\tfrom trader.utils.strategy import StrategyTool\n\tclass StrategySet(StrategyTool):\n\t    '''\n\t    ===================================================================\n\t    StrategySet is a set of strategy class for AutoTradingPlatform, it \n\t    inherits the StrategyTool Object for the use of common functions.\n\t    *****\n\t    The attributes in the __init__ are all necessary, itestablishes the \n", "    Funcs attribute when the system starts.\n\t    *****\n\t    After preparing the script, set the target script to be executed \n\t    in self.Funcs in init. For example, if buyStrategy1 belongs to \n\t    Strategy1 and is a 非當沖 buying strategy, then buyStrategy1 \n\t    should be classified into \n\t    self.Funcs['Open']['非當沖']['Strategy1'], where Open means \n\t    opening a position, whereas Close is to close a position.\n\t    ===================================================================\n\t    '''\n", "    def __init__(self, **kwargs):\n\t        StrategyTool.__init__(self, **kwargs)\n\t        # customized settings\n\t        self.STRATEGIES = pd.DataFrame(\n\t            # table of strategy set, recording each strategy name and its\n\t            # weight of long/short perspective. If a strategy is a long\n\t            # strategy, give an integer to its long_weight and 0 to its\n\t            # short_weight; and vice versa.\n\t            [\n\t                ['Strategy1', 1, 0],\n", "                ['Strategy2', 2, 0],\n\t                ['Strategy3', 3, 0],\n\t                ['Strategy4', 0, 1],\n\t            ],\n\t            columns=['name', 'long_weight', 'short_weight']\n\t        )\n\t        self.Funcs = {\n\t            'Open': {\n\t                '當沖': {},\n\t                '非當沖': {\n", "                    'Strategy1': self.open_Strategy1,\n\t                    'Strategy2': self.open_Strategy2,\n\t                }\n\t            },\n\t            'Close': {\n\t                '當沖': {},\n\t                '非當沖': {\n\t                    'Strategy1': self.close_Strategy1,\n\t                    'Strategy2': self.close_Strategy2,\n\t                }\n", "            }\n\t        }\n\t        self.QuantityFunc = {\n\t            'Strategy1': self.quantity_Strategy1\n\t        }\n\t    def update_indicators(self, now: datetime, kbars: dict):\n\t        '''\n\t        ===================================================================\n\t        *****OPTIONAL*****\n\t        Functions of updating indicators for all strategies. Any new\n", "        indicator data can be created as an attribute in this module.This \n\t        function is OPTIONAL to use, which means if not determine this func, \n\t        the system will not be affected.\n\t        ===================================================================\n\t        '''\n\t        pass\n\t    def setNStockLimitLong(self, KBars: dict = None):\n\t        '''\n\t        ===================================================================\n\t        *****OPTIONAL*****\n", "        Functions of setting the number of STOCK limit to trade for all \n\t        LONG strategies. This function is OPTIONAL to use, which means \n\t        if not determine this func, the system will automatically return \n\t        the value of self.stock_limit_long for further operations.\n\t        ===================================================================\n\t        '''\n\t        if self.is_simulation:\n\t            return 3000\n\t        elif self.stock_limit_type != 'constant':\n\t            return self.stock_limit_long\n", "        return self.stock_limit_long\n\t    def setNStockLimitShort(self, KBars: dict = None):\n\t        '''\n\t        ===================================================================\n\t        *****OPTIONAL*****\n\t        Functions of setting the number of STOCK limit to trade for all \n\t        SHORT strategies. This function is OPTIONAL to use, which means \n\t        if not determine this func, the system will automatically return \n\t        the value of self.stock_limit_short for further operations.\n\t        ===================================================================\n", "        '''\n\t        if self.is_simulation:\n\t            return 3000\n\t        elif self.stock_limit_type != 'constant':\n\t            return self.stock_limit_short\n\t        return self.stock_limit_short\n\t    def setNFuturesLimit(self, KBars: dict = None):\n\t        '''\n\t        ===================================================================\n\t        *****OPTIONAL*****\n", "        Functions of setting the number of FUTURES limit to trade for all \n\t        futures strategies. This function is OPTIONAL to use, which means \n\t        if not determine this func, the system will automatically return \n\t        the value of self.futures_limit for further operations.\n\t        ===================================================================\n\t        '''\n\t        if self.futures_limit_type != 'constant':\n\t            return self.futures_limit\n\t        return self.futures_limit\n\t    def quantity_Strategy1(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n", "        '''\n\t        ===================================================================\n\t        *****OPTIONAL*****\n\t        Functions of calculating quantity of opening stock positions. It \n\t        returns 2 values: quantity & quantity_limit, where quantity is \n\t        determined by your strategy and quantity_limit is set to default \n\t        1.   This function is OPTIONAL to use, which means if not deter-\n\t        mine this func, the system will automatically return 1, 499 for\n\t        further operations.\n\t        ===================================================================\n", "        '''\n\t        quantity = 1\n\t        quantity_limit = 499\n\t        return quantity, quantity_limit\n\t    def open_Strategy1(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n\t        '''\n\t        ===================================================================\n\t        Functions of determining if the system can open a LONG stock \n\t        position.\n\t        Arguments:\n", "        inputs: daily quote data of a stock/futures security, including, \n\t        open, high, low, close, volume, ..., etc\n\t        kbars: Kbar data for condition checking, supported kbar frequencies\n\t        are 1D, 60T, 30T, 15T, 5T, 1T.\n\t        Supported key-word arguments:\n\t        Quotes: current and history (for the past 1-min period) tick data.\n\t        pct_chg_DowJones: the percentage change of the previous trade-day\n\t        Dow-Jones index.\n\t        The function returns a namedtuple Object, including position(%), \n\t        reason, and msg.\n", "        ===================================================================\n\t        '''\n\t        buy_condition = inputs['price'] > inputs['open']\n\t        if buy_condition == True:\n\t            buy_position = 100\n\t            return self.Action(buy_position, 'buy_reason', 'buy_message')\n\t        return self.Action()\n\t    def close_Strategy1(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n\t        '''\n\t        ===================================================================\n", "        Functions of determining if the system can close a LONG stock \n\t        position.\n\t        Arguments:\n\t        inputs: daily quote data of a stock/futures security, including, \n\t        open, high, low, close, price, volume, ..., etc\n\t        kbars: Kbar data for condition checking, supported kbar frequencies\n\t        are 1D, 60T, 30T, 15T, 5T, 1T.\n\t        Supported key-word arguments:\n\t        Quotes: current and history (for the past 1-min period) tick data.\n\t        pct_chg_DowJones: the percentage change of the previous trade-day\n", "        Dow-Jones index.\n\t        The function returns a namedtuple Object, including position(%), \n\t        reason, and msg.\n\t        ===================================================================\n\t        '''\n\t        sell_condition = inputs['price'] < inputs['open']\n\t        if sell_condition == True:\n\t            sell_position = 100\n\t            return self.Action(sell_position, 'sell_reason', 'sell_message')\n\t        return self.Action()\n", "    def open_Strategy2(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n\t        '''\n\t        ===================================================================\n\t        Functions of determining if the system can open a SHORT stock \n\t        position.\n\t        Arguments:\n\t        inputs: daily quote data of a stock/futures security, including, \n\t        open, high, low, close, price, volume, ..., etc\n\t        kbars: Kbar data for condition checking, supported kbar frequencies\n\t        are 1D, 60T, 30T, 15T, 5T, 1T.\n", "        Supported key-word arguments:\n\t        Quotes: current and history (for the past 1-min period) tick data.\n\t        pct_chg_DowJones: the percentage change of the previous trade-day\n\t        Dow-Jones index.\n\t        The function returns a namedtuple Object, including position(%), \n\t        reason, and msg.\n\t        ===================================================================\n\t        '''\n\t        sell_condition = inputs['price'] < inputs['open']\n\t        if sell_condition == True:\n", "            sell_position = 100\n\t            return self.Action(sell_position, 'sell_reason', 'sell_message')\n\t        return self.Action()\n\t    def close_Strategy2(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n\t        '''\n\t        ===================================================================\n\t        Functions of determining if the system can close a SHORT stock \n\t        position.\n\t        Arguments:\n\t        inputs: daily quote data of a stock/futures security, including, \n", "        open, high, low, close, volume, ..., etc\n\t        kbars: Kbar data for condition checking, supported kbar frequencies\n\t        are 1D, 60T, 30T, 15T, 5T, 1T.\n\t        Supported key-word arguments:\n\t        Quotes: current and history (for the past 1-min period) tick data.\n\t        pct_chg_DowJones: the percentage change of the previous trade-day\n\t        Dow-Jones index.\n\t        The function returns a namedtuple Object, including position(%), \n\t        reason, and msg.\n\t        ===================================================================\n", "        '''\n\t        buy_condition = inputs['price'] > inputs['open']\n\t        if buy_condition == True:\n\t            buy_position = 100\n\t            return self.Action(buy_position, 'buy_reason', 'buy_message')\n\t        return self.Action()\n"]}
{"filename": "docs/script samples/backtest_sample.py", "chunked_list": ["import os\n\timport pandas as pd\n\tfrom datetime import timedelta\n\tfrom trader.config import TODAY_STR\n\tfrom trader.performance.backtest import BackTester\n\tfrom trader.performance.reports import BacktestReport\n\tfrom trader.scripts.conditions import SelectConditions\n\tfrom trader.scripts.StrategySet import StrategySet\n\tfrom trader.scripts.features import FeatureTrading, FeaturesSelect\n\tdef dats_source(start='', end=''):\n", "    if not start:\n\t        start = '2000-01-01'\n\t    if not end:\n\t        end = TODAY_STR\n\t    df = pd.read_csv('your_data_path')\n\t    df = df[(df.Time >= start) & (df.Time <= end)]\n\t    return df\n\tclass SampleScript(StrategySet, FeaturesSelect, FeatureTrading, SelectConditions):\n\t    '''\n\t    ===================================================================\n", "    This is a sample of formating a backtest script.\n\t    The following attributes are required:\n\t    1. strategy\n\t    2. market\n\t    3. margin\n\t    4. multipler\n\t    5. mode\n\t    6. scale\n\t    7. kbarScales\n\t    8. raiseQuota\n", "    9. leverage\n\t    10. extraData\n\t    ===================================================================\n\t    '''\n\t    # strategy name\n\t    strategy = 'LongStrategy'\n\t    # Stocks/Futures market\n\t    market = 'Stocks'\n\t    # futures trading margin\n\t    margin = 0\n", "    # futures trading multipler for computing profits\n\t    multipler = 1\n\t    # Define whether its a long or short strategy\n\t    mode = 'long'\n\t    # Kbar MAIN scale for backtesting\n\t    scale = '5T'\n\t    # Kbar scales to generate indicators for backtesting\n\t    kbarScales = ['1D', '5T']\n\t    # whether raise trading quota after opening a position\n\t    raiseQuota = False\n", "    # trading leverage\n\t    leverage = 1\n\t    # Optional: add this attribute if your strategy needs more datssets.\n\t    extraData = dict(dats_source=dats_source)\n\t    def addFeatures_1D(self, df: pd.DataFrame):\n\t        '''\n\t        ===================================================================\n\t        *****OPTIONAL*****\n\t        Function of adding \"Day-frequency\" features. Add this function if\n\t        your backtest strategy needs multi-scale kbar datasets.\n", "        ===================================================================\n\t        '''\n\t        df = self.preprocess_common(df)\n\t        df = getattr(self, f'preprocess_{self.strategy}')(df)\n\t        df = getattr(self, f'addFeatures_1D_{self.strategy}')(df, 'backtest')\n\t        return df\n\t    def addFeatures_T(self, df: pd.DataFrame, scale: str):\n\t        '''\n\t        ===================================================================\n\t        Functions of adding \"other-frequency\" features.\n", "        ===================================================================\n\t        '''\n\t        func = getattr(self, f'addFeatures_{scale}_{self.strategy}')\n\t        df = func(df, 'backtest')\n\t        return df\n\t    def addFeatures(self, Kbars: dict):\n\t        for scale in self.kbarScales:\n\t            if scale == '1D':\n\t                Kbars[scale] = self.addFeatures_1D(Kbars[scale])\n\t            else:\n", "                Kbars[scale] = self.addFeatures_T(Kbars[scale], scale)\n\t        return Kbars\n\t    def selectStocks(self, Kbars: dict, *args):\n\t        '''\n\t        ===================================================================\n\t        Set conditions to select stocks.\n\t        ===================================================================\n\t        '''\n\t        df = Kbars['1D']\n\t        df['isIn'] = getattr(self, f'condition_{self.strategy}')(df, *args)\n", "        df.isIn = df.groupby('name').isIn.shift(1).fillna(False)\n\t        Kbars['1D'] = df\n\t        if len(self.kbarScales) > 1:\n\t            df = Kbars[self.scale]\n\t            isIn = Kbars['1D'][['date', 'name', 'isIn']]\n\t            df = df.merge(isIn, how='left', on=['date', 'name'])\n\t            Kbars[self.scale] = df\n\t        return Kbars\n\t    def setVolumeProp(self, market_value):\n\t        return self.get_volume_prop(self.strategy, market_value)\n", "    def computeOpenLimit(self, KBars: dict, **kwargs):\n\t        '''\n\t        ===================================================================\n\t        Determine the daily limit to open a position.\n\t        ===================================================================\n\t        '''\n\t        if not hasattr(self, f'openLimit_{self.strategy}'):\n\t            return 2000\n\t        func = getattr(self, f'openLimit_{self.strategy}')\n\t        return func(KBars, 'backtest')\n", "    def computeOpenUnit(self, kbars: dict):\n\t        if not hasattr(self, f'quantity_{self.strategy}'):\n\t            return 5\n\t        func = getattr(self, f'quantity_{self.strategy}')\n\t        quantity, _ = func(None, kbars, 'backtest')\n\t        return quantity\n\t    def examineOpen(self, inputs: dict, kbars: dict, **kwargs):\n\t        '''\n\t        ===================================================================\n\t        Set conditions to open a position.\n", "        ===================================================================\n\t        '''\n\t        func = self.mapFunction('Open', self.tradeType, self.strategy)\n\t        return func(inputs=inputs, kbars=kbars, mode='backtest', **kwargs)\n\t    def examineClose(self, inputs: dict, kbars: dict, **kwargs):\n\t        '''\n\t        ===================================================================\n\t        Set conditions to close a position.\n\t        ===================================================================\n\t        '''\n", "        func = self.mapFunction('Close', self.tradeType, self.strategy)\n\t        return func(inputs=inputs, kbars=kbars, mode='backtest', **kwargs)\n\ttester = BackTester()\n\tbacktestScript = SampleScript()\n\ttester.set_scripts(backtestScript)\n\t# Load & Merge datasets\n\tKbars = tester.load_datasets(\n\t    start=pd.to_datetime(TODAY_STR) - timedelta(days=365),\n\t    end='',\n\t    dataPath=f'{os.getcwd()}/data'\n", ")\n\t# Add backtest features and select stocks\n\tKbars = tester.addFeatures(Kbars)\n\tKbars = tester.selectStocks(Kbars)\n\t# Run backtest\n\tinit_position = 1000000\n\tparams = dict(init_position=init_position, buyOrder='Close')\n\tTestResult = tester.run(Kbars, **params)\n\tif TestResult.Summary is not None:\n\t    print(TestResult.Summary)\n", "# Plot figures\n\tbr = BacktestReport(backtestScript)\n\tfig = br.plot_backtest_result(TestResult)\n\t# Output backtest results\n\ttester.save_result(TestResult)\n\tbr.save_figure(fig, 'Backtest Result')\n"]}
{"filename": "docs/script samples/conditions.py", "chunked_list": ["import pandas as pd\n\tclass SelectConditions:\n\t    '''\n\t    ===================================================================\n\t    This module is created for stock selection. The function name format \n\t    is condition_{your_strategy_name} where \"your_strategy_name\" is the \n\t    same as your strategy name defined in StrategySet.py. The \n\t    SelectStock module will automatically set the preprocess and \n\t    condition functions when the program initializes.\n\t    ===================================================================\n", "    '''\n\t    def condition_strategy1(self, df: pd.DataFrame, *args):\n\t        '''\n\t        ===================================================================\n\t        Functions of selection conditions for the strategy.\n\t        ===================================================================\n\t        '''\n\t        b1 = df.Close/df.yClose > 1.05\n\t        b2 = df.Volume > 10000\n\t        b3 = df.Close > df.Open\n", "        return b1 & b2 & b3\n"]}
{"filename": "docs/script samples/features.py", "chunked_list": ["import pandas as pd\n\tfrom trader.indicators.signals import TechnicalSignals\n\tclass FeaturesSelect:\n\t    '''\n\t    ===================================================================\n\t    This module is created for stock selection. The function name format \n\t    is preprocess_{your_strategy_name} where \"your_strategy_name\" is the \n\t    same as your strategy name defined in StrategySet.py. The \n\t    SelectStock module will automatically set the preprocess and \n\t    condition functions when the program initializes.\n", "    ===================================================================\n\t    '''\n\t    def preprocess_strategy1(self, df: pd.DataFrame):\n\t        '''\n\t        ===================================================================\n\t        Functions of preprocessing data for the strategy.\n\t        ===================================================================\n\t        '''\n\t        group = df.groupby('name')\n\t        df['yClose'] = group.Close.transform('shift')\n", "        return df\n\tclass KBarFeatureTool(TechnicalSignals):\n\t    '''\n\t    ===================================================================\n\t    This module is created for adding KBar features. There is a name \n\t    format for function names: add_K{kbar_frequency}_feature, where\n\t    \"kbar_frequency\" can be Day, 60min, 30min, 15min, 5min, or 1min. Each\n\t    function is designed to add features with respect to its frequency\n\t    data.\n\t    ===================================================================\n", "    '''\n\t    def add_KDay_feature(self, KDay: pd.DataFrame):\n\t        '''\n\t        ===================================================================\n\t        Functions of adding Day-frequency features.\n\t        ===================================================================\n\t        '''\n\t        KDay['date'] = pd.to_datetime(KDay['date'])\n\t        KDay['ma_1D_5'] = self._MA(KDay, 'Close', 5)\n\t        return KDay\n", "    def add_K60min_feature(self, K60min: pd.DataFrame):\n\t        '''\n\t        ===================================================================\n\t        Functions of adding 60min-frequency features.\n\t        ===================================================================\n\t        '''\n\t        K60min['ma_60T_10'] = self._MA(K60min, 'Close', 10)\n\t        return K60min\n\t    def add_K30min_feature(self, K30min: pd.DataFrame):\n\t        '''\n", "        ===================================================================\n\t        Functions of adding 30min-frequency features.\n\t        ===================================================================\n\t        '''\n\t        K30min['ma_30T_10'] = self._MA(K30min, 'Close', 10)\n\t        return K30min\n"]}
