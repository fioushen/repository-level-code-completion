{"filename": "setup.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t#\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"The setup.py file for Python Pain001.\"\"\"\n\tfrom setuptools import setup\n\twith open(\"README.md\") as f:\n\t    LONG_DESCRIPTION = f.read()\n\tSHORT_DESCRIPTION = \"\"\"\n", "Pain001, A Python Library for Automating ISO 20022-Compliant Payment Files\n\tUsing CSV Or SQlite Data Files.\n\t\"\"\".strip()\n\tDEPENDENCIES = [\n\t    \"click==8.1.3\",\n\t    \"defusedxml==0.7.1\",\n\t    \"rich==13.4.2\",\n\t    \"xmlschema==2.3.1\",\n\t]\n\tTEST_DEPENDENCIES = [\n", "    \"pytest>=7.3.2\",\n\t]\n\tNAME = \"pain001\"\n\tURL = \"https://github.com/sebastienrousseau/pain001\"\n\tVERSION = \"0.0.22\"\n\tsetup(\n\t    name=NAME,\n\t    version=VERSION,\n\t    description=SHORT_DESCRIPTION,\n\t    long_description=LONG_DESCRIPTION,\n", "    long_description_content_type=\"text/markdown\",\n\t    url=URL,\n\t    author=\"Sebastien Rousseau\",\n\t    author_email=\"sebastian.rousseau@gmail.com\",\n\t    license=\"Apache Software License\",\n\t    classifiers=[\n\t        \"Development Status :: 4 - Beta\",\n\t        \"Intended Audience :: Developers\",\n\t        \"Intended Audience :: Financial and Insurance Industry\",\n\t        \"License :: OSI Approved :: Apache Software License\",\n", "        \"Operating System :: MacOS\",\n\t        \"Operating System :: OS Independent\",\n\t        \"Operating System :: POSIX\",\n\t        \"Operating System :: Unix\",\n\t        \"Programming Language :: Python :: 3.10\",\n\t        \"Programming Language :: Python :: 3.11\",\n\t        \"Programming Language :: Python :: 3.9\",\n\t        \"Programming Language :: Python\",\n\t        \"Topic :: Software Development :: Libraries :: Python Modules\",\n\t    ],\n", "    keywords=\"\"\"\n\t    pain001,iso20022,payment-processing,automate-payments,sepa,financial,banking-payments,csv,sqlite\n\t    \"\"\",\n\t    packages=[\"pain001\"],\n\t    install_requires=DEPENDENCIES,\n\t    tests_require=TEST_DEPENDENCIES,\n\t)\n"]}
{"filename": "pain001/__main__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# pylint: disable=invalid-name\n\t\"\"\"\n\tEnables use of Python Pain001 as a \"main\" function (i.e.\n\t\"python3 -m pain001\n\t<xml_message_type> <xml_template_file_path> <xsd_schema_file_path>\n\t<data_file_path>\").\n", "This allows using Pain001 with third-party libraries without modifying\n\ttheir code.\n\t\"\"\"\n\timport os\n\timport sys\n\timport click\n\tfrom pain001.constants.constants import valid_xml_types\n\tfrom pain001.context.context import Context\n\tfrom pain001.core.core import process_files\n\t# from pain001.xml.validate_via_xsd import validate_via_xsd\n", "from rich.console import Console\n\tfrom rich.table import Table\n\tfrom rich import box\n\tconsole = Console()\n\tdescription = \"\"\"\n\tA powerful Python library that enables you to create\n\tISO 20022-compliant payment files directly from CSV or SQLite Data files.\\n\n\thttps://pain001.com\n\t\"\"\"\n\ttitle = \"Pain001\"\n", "table = Table(\n\t    box=box.ROUNDED,\n\t    safe_box=True,\n\t    show_header=False,\n\t    title=title,\n\t)\n\ttable.add_column(justify=\"center\", no_wrap=False, vertical=\"middle\")\n\ttable.add_row(description)\n\ttable.width = 80\n\tconsole.print(table)\n", "@click.command(\n\t    help=(\n\t        \"To use Pain001, you must specify the following options:\\n\\n\"\n\t    ),\n\t    context_settings=dict(help_option_names=[\"-h\", \"--help\"]),\n\t)\n\t@click.option(\n\t    \"-t\",\n\t    \"--xml_message_type\",\n\t    default=None,\n", "    help=\"Type of XML message (required)\",\n\t)\n\t@click.option(\n\t    \"-m\",\n\t    \"--xml_template_file_path\",\n\t    default=None,\n\t    type=click.Path(),\n\t    help=\"Path to XML template file (required)\",\n\t)\n\t@click.option(\n", "    \"-s\",\n\t    \"--xsd_schema_file_path\",\n\t    default=None,\n\t    type=click.Path(),\n\t    help=\"Path to XSD template file (required)\",\n\t)\n\t@click.option(\n\t    \"-d\",\n\t    \"--data_file_path\",\n\t    default=None,\n", "    type=click.Path(),\n\t    help=\"Path to data file (CSV or SQLite) (required)\",\n\t)\n\tdef main(\n\t    xml_message_type,\n\t    xml_template_file_path,\n\t    xsd_schema_file_path,\n\t    data_file_path,\n\t):\n\t    \"\"\"Initialize the context and log a message.\"\"\"\n", "    logger = Context.get_instance().get_logger()\n\t    # print(\"Inside main function\")\n\t    def check_variable(variable, name):\n\t        if variable is None:\n\t            print(f\"Error: {name} is required.\")\n\t            sys.exit(1)\n\t    # Check that xml_message_type is provided\n\t    check_variable(xml_message_type, \"xml_message_type\")\n\t    # Check that xsd_schema_file_path is provided\n\t    check_variable(xsd_schema_file_path, \"xsd_schema_file_path\")\n", "    # Check that data_file_path is provided\n\t    check_variable(data_file_path, \"data_file_path\")\n\t    # Check that xml_template_file_path is not invalid\n\t    if not os.path.isfile(xml_template_file_path):\n\t        print(\n\t            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n\t        )\n\t        sys.exit(1)\n\t    # Check that xsd_schema_file_path is not invalid\n\t    if not os.path.isfile(xsd_schema_file_path):\n", "        print(\n\t            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n\t        )\n\t        sys.exit(1)\n\t    # Check that data_file_path is not invalid\n\t    if not os.path.isfile(data_file_path):\n\t        print(f\"The data file '{data_file_path}' does not exist.\")\n\t        sys.exit(1)\n\t    # Check that other necessary arguments are provided\n\t    if (\n", "        xml_template_file_path is None\n\t        or xsd_schema_file_path is None\n\t        or data_file_path is None\n\t    ):\n\t        print(click.get_current_context().get_help())\n\t        sys.exit(1)\n\t    \"\"\"\n\t    Entrypoint for pain001 when invoked as a module with\n\t    python3 -m pain001 <xml_message_type> <xml_template_file_path>\n\t    <xsd_schema_file_path> <data_file_path>.\n", "    \"\"\"\n\t    logger = Context.get_instance().get_logger()\n\t    logger.info(\"Parsing command line arguments.\")\n\t    # Check that the XML message type is valid\n\t    if xml_message_type not in valid_xml_types:\n\t        logger.info(f\"Invalid XML message type: {xml_message_type}.\")\n\t        print(f\"Invalid XML message type: {xml_message_type}.\")\n\t        sys.exit(1)\n\t    if not os.path.isfile(xml_template_file_path):\n\t        logger.info(\n", "            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n\t        )\n\t        print(\n\t            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n\t        )\n\t        sys.exit(1)\n\t    if not os.path.isfile(xsd_schema_file_path):\n\t        logger.info(\n\t            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n\t        )\n", "        print(\n\t            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n\t        )\n\t        sys.exit(1)\n\t    if not os.path.isfile(data_file_path):\n\t        logger.info(f\"The data file '{data_file_path}' does not exist.\")\n\t        print(f\"The data file '{data_file_path}' does not exist.\")\n\t        sys.exit(1)\n\t    process_files(\n\t        xml_message_type,\n", "        xml_template_file_path,\n\t        xsd_schema_file_path,\n\t        data_file_path,\n\t    )\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "pain001/__init__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"The Python pain001 module.\"\"\"\n\t__all__ = [\"pain001\"]\n\t__version__ = \"0.0.22\"\n"]}
{"filename": "pain001/context/context.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\tclass Context:\n\t    \"\"\"A class that can be used to manage logging.\n\t    Methods:\n\t        __init__(self): Initializes the class and creates a logger.\n\t        get_instance(): Returns the singleton instance of the class.\n", "        get_logger(self): Returns the logger.\n\t        init_logger(self): Initializes the logger.\n\t        set_log_level(self, log_level): Sets the log level of the logger.\n\t        set_name(self, name): Sets the name of the logger.\n\t    \"\"\"\n\t    instance = None\n\t    name = \"\"\n\t    log_level = logging.INFO\n\t    logger = None\n\t    @staticmethod\n", "    def get_instance():\n\t        \"\"\"Returns the singleton instance of the class.\n\t        Returns:\n\t            A Context instance.\n\t        \"\"\"\n\t        if Context.instance is None:\n\t            Context()\n\t        return Context.instance\n\t    def __init__(self):\n\t        \"\"\"Initializes the class and creates a logger.\n", "        Raises:\n\t            Exception: If the class is already initialized.\n\t        \"\"\"\n\t        if Context.instance is not None:\n\t            raise Exception(\"This class is a singleton!\")\n\t        else:\n\t            Context.instance = self\n\t            self.logger = logging.getLogger(self.name)\n\t            self.logger.setLevel(self.log_level)\n\t            self.logger.info(\"Context initialized\")\n", "    def set_name(self, name):\n\t        \"\"\"Sets the name of the logger.\n\t        Args:\n\t            name: The name of the logger.\n\t        \"\"\"\n\t        self.name = name\n\t    def set_log_level(self, log_level):\n\t        \"\"\"Sets the log level of the logger.\n\t        Args:\n\t            log_level: The log level of the logger.\n", "        Raises:\n\t            Exception: If the log level is invalid.\n\t        \"\"\"\n\t        valid_log_levels = {\n\t            \"DEBUG\": logging.DEBUG,\n\t            \"INFO\": logging.INFO,\n\t            \"WARNING\": logging.WARNING,\n\t            \"ERROR\": logging.ERROR,\n\t            \"CRITICAL\": logging.CRITICAL,\n\t        }\n", "        if isinstance(\n\t            log_level, int\n\t        ):  # Check if log_level is an integer\n\t            if log_level in valid_log_levels.values():\n\t                self.log_level = log_level\n\t            else:\n\t                raise Exception(\"Invalid log level\")\n\t        else:\n\t            log_level = (\n\t                log_level.strip().upper()\n", "            )  # Strip and convert to uppercase\n\t            if log_level in valid_log_levels:\n\t                self.log_level = valid_log_levels[log_level]\n\t            else:\n\t                raise Exception(\"Invalid log level\")\n\t        if self.logger:\n\t            self.logger.setLevel(self.log_level)\n\t    def init_logger(self):\n\t        \"\"\"Initializes the logger.\n\t        Raises:\n", "            Exception: If the logger has already been initialized.\n\t        \"\"\"\n\t        if self.logger is not None:\n\t            raise Exception(\"Logger has already been initialized\")\n\t        self.logger = logging.getLogger(self.name)\n\t        console_handler = logging.StreamHandler()\n\t        self.logger.setLevel(self.log_level)\n\t        log_format = logging.Formatter(\n\t            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n\t        )\n", "        console_handler.setFormatter(log_format)\n\t        if not self.logger.handlers:\n\t            self.logger.addHandler(console_handler)\n\t        self.logger.info(\"Logging initialized\")\n\t    def get_logger(self):\n\t        \"\"\"Returns the logger.\n\t        Returns:\n\t            A Logger instance.\n\t        \"\"\"\n\t        if self.logger is None:\n", "            self.init_logger()\n\t        return self.logger\n"]}
{"filename": "pain001/context/__init__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "pain001/db/load_db_data.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport sqlite3\n\timport os\n\t# Load the SQLite database into a list of dictionaries with the column names as\n\t# keys\n\tdef load_db_data(data_file_path, table_name):\n\t    if not os.path.exists(data_file_path):\n", "        raise FileNotFoundError(\n\t            f\"SQLite file '{data_file_path}' does not exist.\"\n\t        )\n\t    conn = sqlite3.connect(data_file_path)\n\t    cursor = conn.cursor()\n\t    # Fetch column names from the table\n\t    cursor.execute(f\"PRAGMA table_info({table_name})\")\n\t    columns = [column[1] for column in cursor.fetchall()]\n\t    # Fetch data from the table\n\t    cursor.execute(f\"SELECT * FROM {table_name}\")\n", "    rows = cursor.fetchall()\n\t    # Create a list of dictionaries with column names as keys\n\t    data = []\n\t    for row in rows:\n\t        row_dict = {}\n\t        for i, value in enumerate(row):\n\t            row_dict[columns[i]] = value\n\t        data.append(row_dict)\n\t    conn.close()\n\t    return data\n"]}
{"filename": "pain001/db/validate_db_data.py", "chunked_list": ["def validate_db_data(data):\n\t    \"\"\"Validate the SQLite data before processing it.\n\t    Args:\n\t        data (list): A list of dictionaries containing the SQLite data.\n\t    Returns:\n\t        bool: True if the data is valid, False otherwise.\n\t    \"\"\"\n\t    required_columns = {\n\t        \"id\": int,\n\t        \"date\": str,\n", "        \"nb_of_txs\": int,\n\t        \"initiator_name\": str,\n\t        \"payment_information_id\": str,\n\t        \"payment_method\": str,\n\t        \"batch_booking\": bool,\n\t        \"control_sum\": int,\n\t        \"service_level_code\": str,\n\t        \"requested_execution_date\": str,\n\t        \"debtor_name\": str,\n\t        \"debtor_account_IBAN\": str,\n", "        \"debtor_agent_BIC\": str,\n\t        \"forwarding_agent_BIC\": str,\n\t        \"charge_bearer\": str,\n\t        \"payment_id\": str,\n\t        \"payment_amount\": float,\n\t        \"currency\": str,\n\t        \"creditor_agent_BIC\": str,\n\t        \"creditor_name\": str,\n\t        \"creditor_account_IBAN\": str,\n\t        \"remittance_information\": str,\n", "    }\n\t    for row in data:\n\t        for column, data_type in required_columns.items():\n\t            value = row.get(column)\n\t            if value is None or str(value).strip() == \"\":\n\t                print(\n\t                    f\"Error: Missing value for column '{column}' \"\n\t                    f\"in row: {row}\"\n\t                )\n\t                return False\n", "            try:\n\t                if data_type == int:\n\t                    int(value)\n\t                elif data_type == float:\n\t                    float(value)\n\t                elif data_type == bool:\n\t                    if str(value).lower() not in [\"true\", \"false\"]:\n\t                        raise ValueError\n\t                else:\n\t                    str(value)\n", "            except ValueError:\n\t                print(\n\t                    f\"Error: Invalid data type for column '{column}', \"\n\t                    f\"expected {data_type.__name__} in row: {row}\"\n\t                )\n\t                return False\n\t    return True\n"]}
{"filename": "pain001/constants/__init__.py", "chunked_list": []}
{"filename": "pain001/constants/constants.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# Defines the valid XML types for the ISO 20022 Payment Initiation\n\t# message types that are supported by the pain001 library.\n\tvalid_xml_types = [\n\t    \"pain.001.001.03\",  # Customer Credit Transfer Initiation\n\t    \"pain.001.001.04\",  # Customer Direct Debit Initiation\n\t    \"pain.001.001.05\",  # Request for Payment Status\n", "    \"pain.001.001.06\",  # Notification of Payment Status\n\t    \"pain.001.001.07\",  # Request for Reversal\n\t    \"pain.001.001.08\",  # Notification of Reversal\n\t    \"pain.001.001.09\",  # Request for Amendment\n\t    \"pain.001.001.10\"   # Notification of Amendment\n\t    \"pain.001.001.11\"   # Request for Cancellation\n\t]\n"]}
{"filename": "pain001/core/__init__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "pain001/core/core.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t#\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# Import the standard libraries\n\timport sys\n\timport os\n\t# Import the pain001 library functions\n\tfrom pain001.constants.constants import valid_xml_types\n", "from pain001.context.context import Context\n\tfrom pain001.csv.load_csv_data import load_csv_data\n\tfrom pain001.csv.validate_csv_data import validate_csv_data\n\tfrom pain001.db.load_db_data import load_db_data\n\tfrom pain001.db.validate_db_data import validate_db_data\n\tfrom pain001.xml.register_namespaces import register_namespaces\n\tfrom pain001.xml.xml_generator import xml_generator\n\tdef process_files(\n\t    xml_message_type,\n\t    xml_template_file_path,\n", "    xsd_schema_file_path,\n\t    data_file_path,\n\t):\n\t    \"\"\"\n\t    This function generates an ISO 20022 payment message from a CSV or SQLite\n\t    file containing the payment data.\n\t    Args:\n\t        xml_message_type (str): The type of XML message to generate. Valid\n\t        options are 'pain.001.001.03' and 'pain.001.001.09'.\n\t        xml_template_file_path (str): The path of the XML template file.\n", "        xsd_schema_file_path (str): The path of the XSD schema file.\n\t        data_file_path (str): The path of the CSV or SQLite file containing the\n\t        payment data.\n\t    Returns:\n\t        None\n\t    Raises:\n\t        ValueError: If the XML message type is not supported.\n\t        FileNotFoundError: If the XML template file does not exist.\n\t        FileNotFoundError: If the XSD schema file does not exist.\n\t        FileNotFoundError: If the Data file does not exist.\n", "    \"\"\"\n\t    # Initialize the context and log a message.\n\t    logger = Context.get_instance().get_logger()\n\t    # Loop through the payment initiation message types and check if the XML\n\t    # message type is supported.\n\t    if xml_message_type not in valid_xml_types:\n\t        error_message = (\n\t            f\"Error: Invalid XML message type: '{xml_message_type}'.\"\n\t        )\n\t        logger.error(error_message)\n", "        raise ValueError(error_message)\n\t    # Check if the XML template file exists\n\t    if not os.path.exists(xml_template_file_path):\n\t        error_message = (\n\t            f\"Error: XML template '{xml_template_file_path}' \"\n\t            f\"does not exist.\"\n\t        )\n\t        logger.error(error_message)\n\t        raise FileNotFoundError(error_message)\n\t    # Check if the XSD schema file exists\n", "    if not os.path.exists(xsd_schema_file_path):\n\t        error_message = (\n\t            f\"Error: XSD schema file '{xsd_schema_file_path}' \"\n\t            f\"does not exist.\"\n\t        )\n\t        logger.error(error_message)\n\t        raise FileNotFoundError(error_message)\n\t    # Sanitize the path to the data file.\n\t    data_file_path = os.path.normpath(data_file_path)\n\t    # Check if the data file exists\n", "    if not os.path.exists(data_file_path):\n\t        error_message = (\n\t            f\"Error: Data file '{data_file_path}' does not exist.\"\n\t        )\n\t        logger.error(error_message)\n\t        raise FileNotFoundError(error_message)\n\t    # Define mapping dictionary between XML element tags and CSV column names\n\t    mapping = {\n\t        \"MsgId\": \"id\",\n\t        \"CreDtTm\": \"date\",\n", "        \"NbOfTxs\": \"nb_of_txs\",\n\t        \"Nm\": \"initiator_name\",\n\t        \"PmtInfId\": \"payment_information_id\",\n\t        \"PmtMtd\": \"payment_method\",\n\t    }\n\t    # Determine the type of data file (CSV or SQLite)\n\t    is_csv = data_file_path.endswith(\".csv\")\n\t    is_sqlite = data_file_path.endswith(\".db\")\n\t    # Load data into a list of dictionaries based on the file type\n\t    if is_csv:\n", "        data = load_csv_data(data_file_path)\n\t        if not validate_csv_data(data):\n\t            error_message = \"Error: Invalid CSV data.\"\n\t            logger.error(error_message)\n\t            raise ValueError(error_message)\n\t    elif is_sqlite:\n\t        data = load_db_data(data_file_path, table_name=\"pain001\")\n\t        if not validate_db_data(data):\n\t            error_message = \"Error: Invalid SQLite data.\"\n\t            logger.error(error_message)\n", "            raise ValueError(error_message)\n\t    else:\n\t        error_message = \"Error: Unsupported data file type.\"\n\t        logger.error(error_message)\n\t        raise ValueError(error_message)\n\t    # Register the namespace prefixes and URIs for the XML message type\n\t    register_namespaces(xml_message_type)\n\t    # Generate the updated XML file path\n\t    xml_generator(\n\t        data,\n", "        mapping,\n\t        xml_message_type,\n\t        xml_template_file_path,\n\t        xsd_schema_file_path,\n\t    )\n\t    # Confirm the XML file has been created\n\t    if os.path.exists(xml_template_file_path):\n\t        logger.info(\n\t            f\"Successfully generated XML file '{xml_template_file_path}'\"\n\t        )\n", "    else:\n\t        logger.error(\n\t            f\"Failed to generate XML file at '{xml_template_file_path}'\"\n\t        )\n\tif __name__ == \"__main__\":\n\t    if len(sys.argv) < 5:\n\t        print(\n\t            \"Usage: python3 -m pain001 \"\n\t            + \" \".join(\n\t                [\n", "                    \"<xml_message_type>\",\n\t                    \"<xml_template_file_path>\",\n\t                    \"<xsd_schema_file_path>\",\n\t                    \"<data_file_path>\",\n\t                ]\n\t            )\n\t        )\n\t        sys.exit(1)\n\t    process_files(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4])\n"]}
{"filename": "pain001/xml/generate_xml.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# Import the XML libraries\n\timport xml.etree.ElementTree as ET\n\t# Import the datetime library\n\tfrom datetime import datetime\n\t# Import the functions from the other modules\n\tfrom .create_xml_element import create_xml_element\n", "def create_common_elements(parent, row, mapping):\n\t    \"\"\"Create common elements \"PmtInfId\" and \"PmtMtd\" in the XML tree using\n\t    data from the CSV or SQLite Data Files.\n\t    Parameters\n\t    ----------\n\t    parent : xml.etree.ElementTree.Element\n\t        Parent element in the XML tree.\n\t    row : list\n\t        List of strings, each string is a row of the Data file.\n\t    mapping : dict\n", "        Dictionary with the mapping between XML tags and Data columns.\n\t    \"\"\"\n\t    for xml_tag, csv_column in mapping.items():\n\t        if xml_tag in [\"PmtInfId\", \"PmtMtd\"]:\n\t            create_xml_element(parent, xml_tag, row[csv_column])\n\tdef create_xml_v3(root, data, mapping):\n\t    \"\"\"Create the XML tree for the pain.001.001.03 schema.\n\t    Args:\n\t        root (ElementTree.Element): The root element of the XML tree.\n\t        data (list): A list of dictionaries containing the data to be added\n", "        to the XML document.\n\t        mapping (dict): A dictionary mapping the Data column names to the XML\n\t        element names.\n\t    Returns:\n\t        The root element of the XML tree.\n\t    \"\"\"\n\t    # Create CstmrCdtTrfInitn element\n\t    cstmr_cdt_trf_initn_element = ET.Element(\"CstmrCdtTrfInitn\")\n\t    root.append(cstmr_cdt_trf_initn_element)\n\t    # Create GrpHdr element and append it to CstmrCdtTrfInitn\n", "    GrpHdr_element = ET.Element(\"GrpHdr\")\n\t    cstmr_cdt_trf_initn_element.append(GrpHdr_element)\n\t    # Add the MsgId, CreDtTm, and NbOfTxs elements to the GrpHdr element\n\t    for xml_tag, csv_column in mapping.items():\n\t        if xml_tag in [\"MsgId\"]:\n\t            create_xml_element(\n\t                GrpHdr_element, xml_tag, data[0][csv_column]\n\t            )\n\t    # Calculate CreDtTm\n\t    time_and_date_str = str(datetime.now())\n", "    CreDtTm_value = time_and_date_str[0:10] + \"T\" + time_and_date_str[11:19]\n\t    # Add CreDtTm Element in the XML tree\n\t    create_xml_element(GrpHdr_element, \"CreDtTm\", CreDtTm_value)\n\t    # Calculate NbOfTxs\n\t    NbOfTxs = 0\n\t    for row in data:\n\t        NbOfTxs = NbOfTxs + 1\n\t    # Add NbOfTxs to the XML tree\n\t    create_xml_element(GrpHdr_element, \"NbOfTxs\", str(NbOfTxs))\n\t    # Calculate CtrlSum Element from the CSV file\n", "    totalSum = 0\n\t    for row in data:\n\t        totalSum += float(row[\"payment_amount\"])\n\t    # Add CtrlSum Element in the XML tree\n\t    create_xml_element(GrpHdr_element, \"CtrlSum\", str(round(totalSum, 2)))\n\t    # Create new \"InitgPty\" element in the XML tree using data from the\n\t    # CSV file\n\t    InitgPty_element = ET.Element(\"InitgPty\")\n\t    create_xml_element(\n\t        InitgPty_element, \"Nm\", data[0][\"initiator_name\"]\n", "    )\n\t    GrpHdr_element.append(InitgPty_element)\n\t    for row in data:\n\t        # Create new \"PmtInf\" element in the XML tree using data from\n\t        # the CSV file\n\t        PmtInf_element = ET.Element(\"PmtInf\")\n\t        create_common_elements(PmtInf_element, row, mapping)\n\t        # Create new \"BtchBookg\" element in the XML tree using data\n\t        # from the Data file\n\t        create_xml_element(\n", "            PmtInf_element, \"BtchBookg\", row[\"batch_booking\"].lower()\n\t        )\n\t        # Create new \"NbOfTxs\" element in the XML tree using data from\n\t        # the Data file\n\t        # create_xml_element(PmtInf_element, \"NbOfTxs\", row[\"nb_of_txs\"])\n\t        # Create new \"CtrlSum\" element in the XML tree using data from\n\t        # the Data file\n\t        # create_xml_element(\n\t        # PmtInf_element, \"CtrlSum\", f\"{row['control_sum']}\")\n\t        # Create new \"PmtTpInf\" element in the XML tree using data from\n", "        # the Data file\n\t        PmtTpInf_element = ET.Element(\"PmtTpInf\")\n\t        child_element = ET.Element(\"SvcLvl\")\n\t        child_element2 = ET.Element(\"Cd\")\n\t        child_element2.text = row[\"service_level_code\"]\n\t        child_element.append(child_element2)\n\t        PmtTpInf_element.append(child_element)\n\t        PmtInf_element.append(PmtTpInf_element)\n\t        # Create new \"ReqdExctnDt\" element in the XML tree using data\n\t        # from the Data file\n", "        create_xml_element(\n\t            PmtInf_element,\n\t            \"ReqdExctnDt\",\n\t            row[\"requested_execution_date\"],\n\t        )\n\t        # Create new \"Dbtr\" element in the XML tree using data from\n\t        # the Data file\n\t        Dbtr_element = ET.Element(\"Dbtr\")\n\t        child_element = ET.Element(\"Nm\")\n\t        child_element.text = row[\"debtor_name\"]\n", "        Dbtr_element.append(child_element)\n\t        PmtInf_element.append(Dbtr_element)\n\t        # Create new \"DbtrAcct\" element in the XML tree using data\n\t        # from the Data file\n\t        DbtrAcct_element = ET.Element(\"DbtrAcct\")\n\t        child_element = ET.Element(\"Id\")\n\t        child_element2 = ET.Element(\"IBAN\")\n\t        # replace with the appropriate value\n\t        child_element2.text = row[\"debtor_account_IBAN\"]\n\t        child_element.append(child_element2)\n", "        # Create CCy Element\n\t        CCy_element = ET.Element(\"Ccy\")\n\t        CCy_element.text = row[\"currency\"]\n\t        # Add Both Elements to Parents\n\t        DbtrAcct_element.append(child_element)\n\t        DbtrAcct_element.append(CCy_element)\n\t        PmtInf_element.append(DbtrAcct_element)\n\t        # Create new \"DbtrAgt\" element in the XML tree using data\n\t        # from the Data file\n\t        DbtrAgt_element = ET.Element(\"DbtrAgt\")\n", "        child_element = ET.Element(\"FinInstnId\")\n\t        child_element2 = ET.Element(\"BIC\")\n\t        # replace with the appropriate value\n\t        child_element2.text = row[\"debtor_agent_BIC\"]\n\t        child_element.append(child_element2)\n\t        DbtrAgt_element.append(child_element)\n\t        PmtInf_element.append(DbtrAgt_element)\n\t        # Create new \"CdtTrfTxInf\" element in the XML tree using data\n\t        # from the Data file\n\t        CdtTrfTxInf_element = ET.Element(\"CdtTrfTxInf\")\n", "        # Create new \"PmtId\" element in the XML tree using data\n\t        # from the Data file\n\t        PmtId_element = ET.Element(\"PmtId\")\n\t        InstrId_element = ET.Element(\"InstrId\")\n\t        child_element = ET.Element(\"EndToEndId\")\n\t        InstrId_element.text = row[\"payment_id\"]\n\t        child_element.text = row[\"payment_id\"]\n\t        PmtId_element.append(InstrId_element)\n\t        PmtId_element.append(child_element)\n\t        CdtTrfTxInf_element.append(PmtId_element)\n", "        # Create new \"Amt\" element in the XML tree using data\n\t        # from the Data file\n\t        Amt_element = ET.Element(\"Amt\")\n\t        child_element = ET.Element(\"InstdAmt\")\n\t        child_element.text = row[\"payment_amount\"]\n\t        child_element.set(\"Ccy\", row[\"currency\"])\n\t        Amt_element.append(child_element)\n\t        CdtTrfTxInf_element.append(Amt_element)\n\t        # Create new \"ChrgBr\" element in the XML tree using data\n\t        # from the Data file\n", "        ChrgBr_element = ET.Element(\"ChrgBr\")\n\t        # replace with the appropriate value\n\t        ChrgBr_element.text = row[\"charge_bearer\"]\n\t        PmtInf_element.append(ChrgBr_element)\n\t        # Create new \"CdtrAgt\" element in the XML tree using data\n\t        # from the Data file\n\t        CdtrAgt_element = ET.Element(\"CdtrAgt\")\n\t        child_element = ET.Element(\"FinInstnId\")\n\t        child_element2 = ET.Element(\"BIC\")\n\t        child_element2.text = row[\"creditor_agent_BIC\"]\n", "        child_element.append(child_element2)\n\t        CdtrAgt_element.append(child_element)\n\t        CdtTrfTxInf_element.append(CdtrAgt_element)\n\t        # Create new \"Cdtr\" element in the XML tree using data\n\t        # from the Data file\n\t        Cdtr_element = ET.Element(\"Cdtr\")\n\t        child_element = ET.Element(\"Nm\")\n\t        child_element.text = row[\"creditor_name\"]\n\t        Cdtr_element.append(child_element)\n\t        CdtTrfTxInf_element.append(Cdtr_element)\n", "        # Create new \"CdtrAcct\" element in the XML tree using data\n\t        # from the CSV file\n\t        CdtrAcct_element = ET.Element(\"CdtrAcct\")\n\t        Id_element = ET.Element(\"Id\")\n\t        IBAN_element = ET.Element(\"IBAN\")\n\t        IBAN_element.text = row[\"creditor_account_IBAN\"]\n\t        Id_element.append(IBAN_element)\n\t        CdtrAcct_element.append(Id_element)\n\t        CdtTrfTxInf_element.append(CdtrAcct_element)\n\t        # Create new \"RmtInf\" element in the XML tree using data\n", "        # from the Data file\n\t        RmtInf_element = ET.Element(\"RmtInf\")\n\t        child_element = ET.Element(\"Ustrd\")\n\t        child_element.text = row[\"remittance_information\"]\n\t        RmtInf_element.append(child_element)\n\t        CdtTrfTxInf_element.append(RmtInf_element)\n\t        # Append the new CdtTrfTxInf element to the PmtInf element\n\t        PmtInf_element.append(CdtTrfTxInf_element)\n\t        # Append the new PmtInf element to the CstmrCdtTrfInitn element\n\t        cstmr_cdt_trf_initn_element.append(PmtInf_element)\n", "def create_xml_v4(root, data, mapping):\n\t    \"\"\"Creates an XML document for the pain.001.001.04 format.\n\t    Args:\n\t        root: The root element of the XML document.\n\t        data: A list of dictionaries containing the payment data.\n\t        mapping: A dictionary that maps XML element names to Data column names.\n\t    Returns:\n\t        The root element of the XML document.\n\t    \"\"\"\n\t    # Create new \"CstmrCdtTrfInitn\" element in the XML tree\n", "    cstmr_cdt_trf_initn_element = ET.Element(\"CstmrCdtTrfInitn\")\n\t    root.append(cstmr_cdt_trf_initn_element)\n\t    # Create new \"GrpHdr\" element in the XML tree\n\t    GrpHdr_element = ET.Element(\"GrpHdr\")\n\t    cstmr_cdt_trf_initn_element.append(GrpHdr_element)\n\t    # Loop through the first row of the Data file and create new\n\t    # \"MsgId\", \"CreDtTm\" and \"NbOfTxs\" elements in the XML tree\n\t    for xml_tag, csv_column in mapping.items():\n\t        if xml_tag in [\"MsgId\", \"CreDtTm\", \"NbOfTxs\"]:\n\t            create_xml_element(\n", "                GrpHdr_element, xml_tag, data[0][csv_column]\n\t            )\n\t    # Create new \"InitgPty\" element in the XML tree using data\n\t    InitgPty_element = ET.Element(\"InitgPty\")\n\t    create_xml_element(\n\t        InitgPty_element, \"Nm\", data[0][\"initiator_name\"]\n\t    )\n\t    GrpHdr_element.append(InitgPty_element)\n\t    # Loop through the Data file and create new \"PmtInf\" elements\n\t    for row in data:\n", "        PmtInf_element = ET.Element(\"PmtInf\")\n\t        cstmr_cdt_trf_initn_element.append(PmtInf_element)\n\t        create_common_elements(PmtInf_element, row, mapping)\n\t        create_xml_element(\n\t            PmtInf_element, \"BtchBookg\", row[\"batch_booking\"].lower()\n\t        )\n\t        create_xml_element(PmtInf_element, \"NbOfTxs\", row[\"nb_of_txs\"])\n\t        create_xml_element(\n\t            PmtInf_element, \"CtrlSum\", f\"{row['control_sum']}\"\n\t        )\n", "        PmtTpInf_element = ET.Element(\"PmtTpInf\")\n\t        SvcLvl_element = ET.Element(\"SvcLvl\")\n\t        Cd_element = ET.Element(\"Cd\")\n\t        Cd_element.text = row[\"service_level_code\"]\n\t        SvcLvl_element.append(Cd_element)\n\t        PmtTpInf_element.append(SvcLvl_element)\n\t        PmtInf_element.append(PmtTpInf_element)\n\t        create_xml_element(\n\t            PmtInf_element,\n\t            \"ReqdExctnDt\",\n", "            row[\"requested_execution_date\"],\n\t        )\n\t        Dbtr_element = ET.Element(\"Dbtr\")\n\t        Nm_element = ET.Element(\"Nm\")\n\t        Nm_element.text = row[\"debtor_name\"]\n\t        Dbtr_element.append(Nm_element)\n\t        PmtInf_element.append(Dbtr_element)\n\t        DbtrAcct_element = ET.Element(\"DbtrAcct\")\n\t        Id_element = ET.Element(\"Id\")\n\t        IBAN_element = ET.Element(\"IBAN\")\n", "        IBAN_element.text = row[\"debtor_account_IBAN\"]\n\t        Id_element.append(IBAN_element)\n\t        DbtrAcct_element.append(Id_element)\n\t        PmtInf_element.append(DbtrAcct_element)\n\t        DbtrAgt_element = ET.Element(\"DbtrAgt\")\n\t        FinInstnId_element = ET.Element(\"FinInstnId\")\n\t        BIC_element = ET.Element(\"BICFI\")\n\t        BIC_element.text = row[\"debtor_agent_BIC\"]\n\t        FinInstnId_element.append(BIC_element)\n\t        DbtrAgt_element.append(FinInstnId_element)\n", "        PmtInf_element.append(DbtrAgt_element)\n\t        CdtTrfTxInf_element = ET.Element(\"CdtTrfTxInf\")\n\t        PmtId_element = ET.Element(\"PmtId\")\n\t        EndToEndId_element = ET.Element(\"EndToEndId\")\n\t        EndToEndId_element.text = row[\"payment_id\"]\n\t        PmtId_element.append(EndToEndId_element)\n\t        CdtTrfTxInf_element.append(PmtId_element)\n\t        Amt_element = ET.Element(\"Amt\")\n\t        InstdAmt_element = ET.Element(\"InstdAmt\")\n\t        InstdAmt_element.text = row[\"payment_amount\"]\n", "        InstdAmt_element.set(\"Ccy\", row[\"currency\"])\n\t        Amt_element.append(InstdAmt_element)\n\t        CdtTrfTxInf_element.append(Amt_element)\n\t        CdtrAgt_element = ET.Element(\"CdtrAgt\")\n\t        FinInstnId_element = ET.Element(\"FinInstnId\")\n\t        BIC_element = ET.Element(\"BICFI\")\n\t        BIC_element.text = row[\"creditor_agent_BIC\"]\n\t        FinInstnId_element.append(BIC_element)\n\t        CdtrAgt_element.append(FinInstnId_element)\n\t        CdtTrfTxInf_element.append(CdtrAgt_element)\n", "        Cdtr_element = ET.Element(\"Cdtr\")\n\t        Nm_element = ET.Element(\"Nm\")\n\t        Nm_element.text = row[\"creditor_name\"]\n\t        Cdtr_element.append(Nm_element)\n\t        CdtTrfTxInf_element.append(Cdtr_element)\n\t        CdtrAcct_element = ET.Element(\"CdtrAcct\")\n\t        Id_element = ET.Element(\"Id\")\n\t        IBAN_element = ET.Element(\"IBAN\")\n\t        IBAN_element.text = row[\"creditor_account_IBAN\"]\n\t        Id_element.append(IBAN_element)\n", "        CdtrAcct_element.append(Id_element)\n\t        CdtTrfTxInf_element.append(CdtrAcct_element)\n\t        RmtInf_element = ET.Element(\"RmtInf\")\n\t        Ustrd_element = ET.Element(\"Ustrd\")\n\t        Ustrd_element.text = row[\"remittance_information\"]\n\t        RmtInf_element.append(Ustrd_element)\n\t        CdtTrfTxInf_element.append(RmtInf_element)\n\t        PmtInf_element.append(CdtTrfTxInf_element)\n\tdef create_xml_v9(root, data, mapping):\n\t    \"\"\"Creates an XML document for the pain.001.001.09 schema.\n", "    Args:\n\t        root (ElementTree.Element): The root element of the XML tree.\n\t        data (list): A list of dictionaries containing the data to be added\n\t        to the XML document.\n\t        mapping (dict): A dictionary mapping the Data column names to the XML\n\t        element names.\n\t    Returns:\n\t        The root element of the XML tree.\n\t    \"\"\"\n\t    # Create CstmrCdtTrfInitn element\n", "    cstmr_cdt_trf_initn_element = ET.Element(\"CstmrCdtTrfInitn\")\n\t    root.append(cstmr_cdt_trf_initn_element)\n\t    # Create GrpHdr element and append it to CstmrCdtTrfInitn\n\t    GrpHdr_element = ET.Element(\"GrpHdr\")\n\t    cstmr_cdt_trf_initn_element.append(GrpHdr_element)\n\t    # Add the MsgId, CreDtTm, and NbOfTxs elements to the GrpHdr element\n\t    for xml_tag, csv_column in mapping.items():\n\t        if xml_tag in [\"MsgId\", \"CreDtTm\", \"NbOfTxs\"]:\n\t            create_xml_element(\n\t                GrpHdr_element, xml_tag, data[0][csv_column]\n", "            )\n\t    # Create new \"InitgPty\" element in the XML tree using data from the\n\t    # Data file\n\t    InitgPty_element = ET.Element(\"InitgPty\")\n\t    create_xml_element(\n\t        InitgPty_element, \"Nm\", data[0][\"initiator_name\"]\n\t    )\n\t    GrpHdr_element.append(InitgPty_element)\n\t    for row in data:\n\t        # Create new \"PmtInf\" element in the XML tree using data from\n", "        # the Data file\n\t        PmtInf_element = ET.Element(\"PmtInf\")\n\t        cstmr_cdt_trf_initn_element.append(PmtInf_element)\n\t        create_common_elements(PmtInf_element, row, mapping)\n\t        Dbtr_element = ET.Element(\"ReqdExctnDt\")\n\t        child_element = ET.Element(\"Dt\")\n\t        child_element.text = row[\"requested_execution_date\"]\n\t        Dbtr_element.append(child_element)\n\t        PmtInf_element.append(Dbtr_element)\n\t        # Create new \"Dbtr\" element in the XML tree using data from\n", "        # the Data file\n\t        Dbtr_element = ET.Element(\"Dbtr\")\n\t        child_element = ET.Element(\"Nm\")\n\t        child_element.text = row[\"debtor_name\"]\n\t        Dbtr_element.append(child_element)\n\t        PmtInf_element.append(Dbtr_element)\n\t        # Create new \"DbtrAcct\" element in the XML tree using data\n\t        # from the Data file\n\t        DbtrAcct_element = ET.Element(\"DbtrAcct\")\n\t        child_element = ET.Element(\"Id\")\n", "        child_element2 = ET.Element(\"IBAN\")\n\t        # replace with the appropriate value\n\t        child_element2.text = row[\"debtor_account_IBAN\"]\n\t        child_element.append(child_element2)\n\t        DbtrAcct_element.append(child_element)\n\t        PmtInf_element.append(DbtrAcct_element)\n\t        # Create new \"DbtrAgt\" element in the XML tree using data\n\t        # from the Data file\n\t        DbtrAgt_element = ET.Element(\"DbtrAgt\")\n\t        child_element = ET.Element(\"FinInstnId\")\n", "        child_element2 = ET.Element(\"BICFI\")\n\t        # replace with the appropriate value\n\t        child_element2.text = row[\"debtor_agent_BIC\"]\n\t        child_element2.set(\n\t            \"xmlns\", \"urn:iso:std:iso:20022:tech:xsd:pain.001.001.09\"\n\t        )\n\t        child_element.append(child_element2)\n\t        DbtrAgt_element.append(child_element)\n\t        PmtInf_element.append(DbtrAgt_element)\n\t        # Create new \"ChrgBr\" element in the XML tree using data\n", "        # from the Data file\n\t        child_element = ET.Element(\"ChrgBr\")\n\t        # replace with the appropriate value\n\t        child_element.text = row[\"charge_bearer\"]\n\t        PmtInf_element.append(child_element)\n\t        # Create new \"CdtTrfTxInf\" element in the XML tree using data\n\t        # from the Data file\n\t        CdtTrfTxInf_element = ET.Element(\"CdtTrfTxInf\")\n\t        # Create new \"PmtId\" element in the XML tree using data\n\t        # from the Data file\n", "        PmtId_element = ET.Element(\"PmtId\")\n\t        child_element = ET.Element(\"EndToEndId\")\n\t        child_element.text = row[\"payment_id\"]\n\t        PmtId_element.append(child_element)\n\t        CdtTrfTxInf_element.append(PmtId_element)\n\t        # Create new \"Amt\" element in the XML tree using data\n\t        # from the Data file\n\t        Amt_element = ET.Element(\"Amt\")\n\t        child_element = ET.Element(\"InstdAmt\")\n\t        child_element.text = row[\"payment_amount\"]\n", "        child_element.set(\"Ccy\", row[\"currency\"])\n\t        Amt_element.append(child_element)\n\t        CdtTrfTxInf_element.append(Amt_element)\n\t        # Create new \"CdtrAgt\" element in the XML tree using data\n\t        # from the Data file\n\t        CdtrAgt_element = ET.Element(\"CdtrAgt\")\n\t        child_element = ET.Element(\"FinInstnId\")\n\t        child_element2 = ET.Element(\"BICFI\")\n\t        # replace with the appropriate value\n\t        child_element2.text = row[\"creditor_agent_BIC\"]\n", "        child_element2.set(\n\t            \"xmlns\", \"urn:iso:std:iso:20022:tech:xsd:pain.001.001.09\"\n\t        )\n\t        child_element.append(child_element2)\n\t        CdtrAgt_element.append(child_element)\n\t        CdtTrfTxInf_element.append(CdtrAgt_element)\n\t        # Create new \"Cdtr\" element in the XML tree using data\n\t        # from the Data file\n\t        Cdtr_element = ET.Element(\"Cdtr\")\n\t        child_element = ET.Element(\"Nm\")\n", "        child_element.text = row[\"creditor_name\"]\n\t        Cdtr_element.append(child_element)\n\t        CdtTrfTxInf_element.append(Cdtr_element)\n\t        # Create new \"CdtrAcct\" element in the XML tree using data\n\t        # from the CSV file\n\t        CdtrAcct_element = ET.Element(\"CdtrAcct\")\n\t        child_element = ET.Element(\"Id\")\n\t        child_element2 = ET.Element(\"IBAN\")\n\t        child_element2.text = row[\"creditor_agent_BIC\"]\n\t        child_element.append(child_element2)\n", "        CdtrAcct_element.append(child_element)\n\t        CdtTrfTxInf_element.append(CdtrAcct_element)\n\t        # Create new \"RmtInf\" element in the XML tree using data\n\t        # from the Data file\n\t        RmtInf_element = ET.Element(\"RmtInf\")\n\t        child_element = ET.Element(\"Ustrd\")\n\t        child_element.text = row[\"remittance_information\"]\n\t        RmtInf_element.append(child_element)\n\t        CdtTrfTxInf_element.append(RmtInf_element)\n\t        # Append the new CdtTrfTxInf element to the PmtInf element\n", "        PmtInf_element.append(CdtTrfTxInf_element)\n\t        # Append the new PmtInf element to the CstmrCdtTrfInitn element\n\t        cstmr_cdt_trf_initn_element.append(PmtInf_element)\n\t        # Create new \"SplmtryData\" elements in the XML tree using data\n\t        # from the Data file\"\n\t        # Create the main elements\n\t        SplmtryData_element = ET.Element(\"SplmtryData\")\n\t        Envlp_element = ET.SubElement(SplmtryData_element, \"Envlp\")\n\t        child_element = ET.SubElement(Envlp_element, \"WC\")\n\t        CdtTrfTxInf_element.append(SplmtryData_element)\n"]}
{"filename": "pain001/xml/validate_via_xsd.py", "chunked_list": ["import xmlschema\n\t# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport defusedxml.ElementTree as ET\n\tdef validate_via_xsd(xml_file_path, xsd_file_path):\n\t    \"\"\"\n\t    Validates an XML file against an XSD schema.\n\t    Args:\n", "        xml_file_path (str): Path to the XML file to validate.\n\t        xsd_file_path (str): Path to the XSD schema file.\n\t    Returns:\n\t        bool: True if the XML file is valid, False otherwise.\n\t    \"\"\"\n\t    # Load XML file into an ElementTree object.\n\t    try:\n\t        xml_tree = ET.parse(xml_file_path)\n\t    except Exception as e:\n\t        print(f\"Error: {e}\")\n", "        return False\n\t    # Load XSD schema into an XMLSchema object.\n\t    xsd = xmlschema.XMLSchema(xsd_file_path)\n\t    # Validate XML file against XSD schema.\n\t    try:\n\t        is_valid = xsd.is_valid(xml_tree)\n\t    except Exception as e:\n\t        print(f\"Error: {e}\")\n\t        return False\n\t    # Return True if XML file is valid, False otherwise.\n", "    return is_valid\n"]}
{"filename": "pain001/xml/create_root_element.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport xml.etree.ElementTree as ET\n\t# Create the root element and set its attributes (XML tags and CSV\n\t# columns mapping)\n\tdef create_root_element(payment_initiation_message_type):\n\t    # Create the namespace for the payment initiation message type.\n\t    namespace = (\n", "        \"urn:iso:std:iso:20022:tech:xsd:\"\n\t        + payment_initiation_message_type\n\t    )\n\t    # Create the root element.\n\t    root = ET.Element(\"Document\")\n\t    root.set(\"xmlns\", namespace)\n\t    root.set(\"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\")\n\t    # Set the schema location.\n\t    schema_location = (\n\t        namespace + \" \" + payment_initiation_message_type + \".xsd\"\n", "    )\n\t    root.set(\"xsi:schemaLocation\", schema_location)\n\t    for elem in root.iter():\n\t        elem.tag = elem.tag.split(\"}\", 1)[-1]\n\t    return root\n"]}
{"filename": "pain001/xml/xml_generator.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# XML generator function that creates the XML file from the CSV data\n\t# and the mapping dictionary between XML tags and CSV columns names and\n\t# writes it to a file in the same directory as the CSV file\n\timport sys\n\tfrom pain001.xml.create_root_element import create_root_element\n\tfrom pain001.xml.generate_updated_xml_file_path import (\n", "    generate_updated_xml_file_path,\n\t)\n\tfrom pain001.xml.generate_xml import (\n\t    create_xml_v3,\n\t    create_xml_v4,\n\t    create_xml_v9,\n\t)\n\tfrom pain001.xml.validate_via_xsd import validate_via_xsd\n\tfrom pain001.xml.write_xml_to_file import write_xml_to_file\n\tdef xml_generator(\n", "    data,\n\t    mapping,\n\t    payment_initiation_message_type,\n\t    xml_file_path,\n\t    xsd_file_path,\n\t):\n\t    # Create the root element and set its attributes\n\t    root = create_root_element(payment_initiation_message_type)\n\t    # Define a mapping between the XML types and the XML generators\n\t    xml_generators = {\n", "        \"pain.001.001.03\": create_xml_v3,\n\t        \"pain.001.001.04\": create_xml_v4,\n\t        \"pain.001.001.09\": create_xml_v9,\n\t    }\n\t    # Check if the provided payment_initiation_message_type exists in\n\t    # the mapping\n\t    if payment_initiation_message_type in xml_generators:\n\t        # Get the corresponding XML generation function for the XML type\n\t        xml_generator = xml_generators[payment_initiation_message_type]\n\t        # Check if data is not empty\n", "        if not data:\n\t            print(\"Error: No data to process.\")\n\t            sys.exit(1)\n\t        # Generate the XML file for the XML type and set its attributes\n\t        xml_generator(\n\t            root, data, mapping\n\t        )  # Pass root, data, and mapping as arguments to the xml_generator\n\t        # Generate updated XML file path\n\t        updated_xml_file_path = generate_updated_xml_file_path(\n\t            xml_file_path, payment_initiation_message_type\n", "        )\n\t        # Write the updated XML tree to a file\n\t        write_xml_to_file(updated_xml_file_path, root)\n\t        print(\n\t            f\"A new XML file has been created at {updated_xml_file_path}\"\n\t        )\n\t        print(updated_xml_file_path)\n\t        # Validate the updated XML file against the XSD schema\n\t        is_valid = validate_via_xsd(\n\t            updated_xml_file_path, xsd_file_path\n", "        )\n\t        if not is_valid:\n\t            print(\"Error: Invalid XML data.\")\n\t            sys.exit(1)\n\t        else:\n\t            print(f\"The XML has been validated against {xsd_file_path}\")\n\t    else:\n\t        # Handle the case when the payment_initiation_message_type is\n\t        # not valid\n\t        print(\n", "            \"Error: Invalid XML message type:\",\n\t            payment_initiation_message_type,\n\t        )\n\t        sys.exit(1)\n"]}
{"filename": "pain001/xml/write_xml_to_file.py", "chunked_list": ["import xml.etree.ElementTree as ET\n\t# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom defusedxml.minidom import parseString\n\t# Write XML to file with pretty formatting (indentation)\n\tdef write_xml_to_file(xml_file_path, root):\n\t    with open(xml_file_path, \"w\") as f:\n\t        xml_string = ET.tostring(root, encoding=\"utf-8\")\n", "        xml_declaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n\t        xml_string = xml_declaration + xml_string.decode(\"utf-8\")\n\t        dom = parseString(xml_string)\n\t        f.write(dom.toprettyxml())\n"]}
{"filename": "pain001/xml/register_namespaces.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport xml.etree.ElementTree as ET\n\t# Register the namespace prefixes with the ElementTree module so that\n\t# they are automatically added to the XML tags when the XML elements\n\t# are created (XML tags and CSV columns mapping)\n\tdef register_namespaces(payment_initiation_message_type):\n\t    \"\"\"This function registers the namespaces for the payment initiation\n", "    message type.\n\t    Args:\n\t        payment_initiation_message_type (str):\n\t        The payment initiation message type.\n\t    Returns:\n\t        None.\n\t    \"\"\"\n\t    # Create the namespace for the payment initiation message type.\n\t    namespace = (\n\t        \"urn:iso:std:iso:20022:tech:xsd:\"\n", "        + payment_initiation_message_type\n\t    )\n\t    # Register the namespaces.\n\t    ET.register_namespace(\"\", namespace)\n\t    ET.register_namespace(\n\t        \"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"\n\t    )\n"]}
{"filename": "pain001/xml/create_xml_element.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport xml.etree.ElementTree as ET\n\t# Create an XML element with the specified tag, text, and attributes,\n\t# and append it to the given parent element (XML tags and CSV columns\n\t# mapping)\n\tdef create_xml_element(parent, tag, text=None, attributes=None):\n\t    \"\"\"\n", "    Create an XML element with the specified tag, text, and\n\t    attributes, and append it to the given parent element.\n\t    Args:\n\t        parent (Element): The parent element to append the new element\n\t        to.\n\t        tag (str): The tag name of the new element.\n\t        text (str, optional): The text content of the new element.\n\t        attributes (dict, optional): A dictionary of attribute names\n\t        and values for the new element.\n\t    Returns:\n", "        Element: The created XML element.\n\t    \"\"\"\n\t    element = ET.Element(tag)\n\t    if text is not None:\n\t        element.text = text\n\t    if attributes is not None:\n\t        for key, value in attributes.items():\n\t            element.set(key, value)\n\t    parent.append(element)\n\t    return element\n"]}
{"filename": "pain001/xml/generate_updated_xml_file_path.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport os\n\t# Generate the path to the updated XML file based on the path to the\n\t# original XML file\n\tdef generate_updated_xml_file_path(\n\t    xml_file_path, payment_initiation_message_type\n\t):\n", "    # print(os.path.splitext(xml_file_path)[0])\n\t    base_directory = os.path.dirname(xml_file_path)\n\t    base_name = os.path.basename(xml_file_path)\n\t    file_name, _ = os.path.splitext(base_name)\n\t    new_file_name = payment_initiation_message_type + \".xml\"\n\t    new_file_path = os.path.join(base_directory, new_file_name)\n\t    return new_file_path\n"]}
{"filename": "pain001/csv/validate_csv_data.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# Validate the CSV data before processing it. The CSV data must contain\n\t# the following columns:\n\t#\n\t# - id (int) - unique identifier\n\t# - date (str) - date of the payment\n\t# - nb_of_txs (int) - number of transactions\n", "# - initiator_name (str) - name of the initiator\n\t# - payment_information_id (str) - payment information identifier\n\t# - payment_method (str) - payment method\n\t# - batch_booking (bool) - batch booking\n\t# - control_sum (int) - control sum\n\t# - service_level_code (str) - service level code\n\t# - requested_execution_date (str) - requested execution date\n\t# - debtor_name (str) - debtor name\n\t# - debtor_account_IBAN (str) - debtor account IBAN\n\t# - debtor_agent_BIC (str) - debtor agent BIC\n", "# - forwarding_agent_BIC (str) - forwarding agent BIC\n\t# - charge_bearer (str) - charge bearer\n\t# - payment_id (str) - payment identifier\n\t# - payment_amount (str) - payment amount\n\t# - currency (str) - currency\n\t# - creditor_agent_BIC (str) - creditor agent BIC\n\t# - creditor_name (str) - creditor name\n\t# - creditor_account_IBAN (str) - creditor account IBAN\n\t# - remittance_information (str) - remittance information\n\tdef validate_csv_data(data):\n", "    \"\"\"Validate the CSV data before processing it.\n\t    Args:\n\t        data (list): A list of dictionaries containing the CSV data.\n\t    Returns:\n\t        bool: True if the data is valid, False otherwise.\n\t    \"\"\"\n\t    required_columns = {\n\t        \"id\": int,\n\t        \"date\": str,\n\t        \"nb_of_txs\": int,\n", "        \"initiator_name\": str,\n\t        \"payment_information_id\": str,\n\t        \"payment_method\": str,\n\t        \"batch_booking\": bool,\n\t        \"control_sum\": int,\n\t        \"service_level_code\": str,\n\t        \"requested_execution_date\": str,\n\t        \"debtor_name\": str,\n\t        \"debtor_account_IBAN\": str,\n\t        \"debtor_agent_BIC\": str,\n", "        \"forwarding_agent_BIC\": str,\n\t        \"charge_bearer\": str,\n\t        \"payment_id\": str,\n\t        \"payment_amount\": float,\n\t        \"currency\": str,\n\t        \"creditor_agent_BIC\": str,\n\t        \"creditor_name\": str,\n\t        \"creditor_account_IBAN\": str,\n\t        \"remittance_information\": str,\n\t    }\n", "    for row in data:\n\t        for column, data_type in required_columns.items():\n\t            value = row.get(column)\n\t            if value is None or value.strip() == \"\":\n\t                print(\n\t                    f\"Error: Missing value for column '{column}' \"\n\t                    f\"in row: {row}\"\n\t                )\n\t                return False\n\t            try:\n", "                if data_type == int:\n\t                    int(value)\n\t                elif data_type == float:\n\t                    float(value)\n\t                elif data_type == bool:\n\t                    if value.lower() not in [\"true\", \"false\"]:\n\t                        raise ValueError\n\t                else:\n\t                    str(value)\n\t            except ValueError:\n", "                print(\n\t                    f\"Error: Invalid data type for column '{column}', \"\n\t                    f\"expected {data_type.__name__} in row: {row}\"\n\t                )\n\t                return False\n\t    return True\n"]}
{"filename": "pain001/csv/load_csv_data.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n\t# implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport csv\n\timport os\n\t# Load the CSV file into a list of dictionaries with the column names as\n\t# keys\n\tdef load_csv_data(csv_file_path):\n\t    if not os.path.exists(csv_file_path):\n", "        raise FileNotFoundError(\n\t            f\"CSV file '{csv_file_path}' does not exist.\"\n\t        )\n\t    data = []\n\t    with open(csv_file_path, \"r\") as csv_file:\n\t        reader = csv.DictReader(csv_file)\n\t        for row in reader:\n\t            data.append(row)\n\t    return data\n"]}
{"filename": "tests/test_main.py", "chunked_list": ["from click.testing import CliRunner\n\tfrom pain001.__main__ import main\n\tclass TestMain:\n\t    def setup_method(self):\n\t        self.runner = CliRunner()\n\t        self.xml_message_type = \"pain.001.001.03\"\n\t        self.xml_file = \"tests/data/template.xml\"\n\t        self.xsd_file = \"tests/data/template.xsd\"\n\t        self.csv_file = \"tests/data/template.csv\"\n\t    def test_main_with_valid_files(self):\n", "        result = self.runner.invoke(\n\t            main,\n\t            [\n\t                \"--xml_message_type\",\n\t                self.xml_message_type,\n\t                \"--xml_template_file_path\",\n\t                self.xml_file,\n\t                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t                \"--data_file_path\",\n", "                self.csv_file,\n\t            ],\n\t        )\n\t        assert (\n\t            \"The XML has been validated against tests/data/template.xsd\\n\"\n\t            in result.output\n\t        )\n\t        assert result.exit_code == 0\n\t    def test_main_with_missing_xml_message_type(self):\n\t        result = self.runner.invoke(\n", "            main,\n\t            [\n\t                \"--xml_template_file_path\",\n\t                self.xml_file,\n\t                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t                \"--data_file_path\",\n\t                self.csv_file,\n\t            ],\n\t        )\n", "        assert result.exit_code == 1\n\t        assert \"Error: xml_message_type is required.\" in result.output\n\t    def test_main_with_missing_xsd_template_file(self):\n\t        result = self.runner.invoke(\n\t            main,\n\t            [\n\t                \"--xml_message_type\",\n\t                self.xml_message_type,\n\t                \"--xml_template_file_path\",\n\t                self.xml_file,\n", "                \"--data_file_path\",\n\t                self.csv_file,\n\t            ],\n\t        )\n\t        assert result.exit_code == 1\n\t        assert (\n\t            \"Error: xsd_schema_file_path is required.\" in result.output\n\t        )\n\t    def test_main_with_missing_data_file(self):\n\t        result = self.runner.invoke(\n", "            main,\n\t            [\n\t                \"--xml_message_type\",\n\t                self.xml_message_type,\n\t                \"--xml_template_file_path\",\n\t                self.xml_file,\n\t                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t            ],\n\t        )\n", "        assert result.exit_code == 1\n\t        assert \"Error: data_file_path is required.\" in result.output\n\t    def test_main_with_invalid_xml_message_type(self):\n\t        result = self.runner.invoke(\n\t            main,\n\t            [\n\t                \"--xml_message_type\",\n\t                \"invalid\",\n\t                \"--xml_template_file_path\",\n\t                self.xml_file,\n", "                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t                \"--data_file_path\",\n\t                self.csv_file,\n\t            ],\n\t        )\n\t        assert result.exit_code == 1\n\t        assert \"Invalid XML message type: invalid.\" in result.output\n\t    def test_main_with_invalid_xml_template_file(self):\n\t        result = self.runner.invoke(\n", "            main,\n\t            [\n\t                \"--xml_message_type\",\n\t                self.xml_message_type,\n\t                \"--xml_template_file_path\",\n\t                \"invalid\",\n\t                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t                \"--data_file_path\",\n\t                self.csv_file,\n", "            ],\n\t        )\n\t        assert result.exit_code == 1\n\t        assert (\n\t            \"The XML template file 'invalid' does not exist.\"\n\t            in result.output\n\t        )\n\t    def test_main_with_invalid_xsd_template_file(self):\n\t        result = self.runner.invoke(\n\t            main,\n", "            [\n\t                \"--xml_message_type\",\n\t                self.xml_message_type,\n\t                \"--xml_template_file_path\",\n\t                self.xml_file,\n\t                \"--xsd_schema_file_path\",\n\t                \"invalid\",\n\t                \"--data_file_path\",\n\t                self.csv_file,\n\t            ],\n", "        )\n\t        assert result.exit_code == 1\n\t        assert (\n\t            \"The XSD template file 'invalid' does not exist.\"\n\t            in result.output\n\t        )\n\t    def test_main_with_invalid_data_file(self):\n\t        result = self.runner.invoke(\n\t            main,\n\t            [\n", "                \"--xml_message_type\",\n\t                self.xml_message_type,\n\t                \"--xml_template_file_path\",\n\t                self.xml_file,\n\t                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t                \"--data_file_path\",\n\t                \"invalid\",\n\t            ],\n\t        )\n", "        assert result.exit_code == 1\n\t        assert (\n\t            \"The data file 'invalid' does not exist.\" in result.output\n\t        )\n\t    def test_invalid_xml_template_file_path(self):\n\t        \"\"\"\n\t        Test that the `print(click.get_current_context().get_help())` line is\n\t        executed when the `xml_template_file_path` argument is set to an\n\t        invalid value.\n\t        \"\"\"\n", "        result = self.runner.invoke(\n\t            main,\n\t            [\n\t                \"--xml_message_type\",\n\t                \"pain.001.001.03\",\n\t                \"--xml_template_file_path\",\n\t                \"invalid\",\n\t                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t                \"--data_file_path\",\n", "                self.csv_file,\n\t            ],\n\t        )\n\t        assert result.exit_code == 1\n\t        assert (\n\t            \"The XML template file 'invalid' does not exist.\"\n\t            in result.output\n\t        )\n\t        assert (\n\t            \"The XML template file 'invalid' does not exist.\"\n", "            in result.output\n\t        )\n\t    def test_non_existent_xml_template_file_path(self):\n\t        \"\"\"\n\t        Test that the `logger.info()` and `print()` lines are executed\n\t        when the `xml_template_file_path` argument is set to a non-existent\n\t        file path.\n\t        \"\"\"\n\t        result = self.runner.invoke(\n\t            main,\n", "            [\n\t                \"--xml_message_type\",\n\t                \"pain.001.001.03\",\n\t                \"--xml_template_file_path\",\n\t                \"non_existent_file.xml\",\n\t                \"--xsd_schema_file_path\",\n\t                self.xsd_file,\n\t                \"--data_file_path\",\n\t                self.csv_file,\n\t            ],\n", "        )\n\t        assert result.exit_code == 1\n\t        assert (\n\t            \"The XML template file 'non_existent_file.xml' does not exist.\"\n\t            in result.output\n\t        )\n"]}
{"filename": "tests/test_generate_updated_xml_file_path.py", "chunked_list": ["from pain001.xml.generate_updated_xml_file_path import (\n\t    generate_updated_xml_file_path,\n\t)\n\t# Test if the updated XML file path is generated correctly\n\tdef test_generate_updated_xml_file_path():\n\t    # Test with a file path that has an extension\n\t    xml_file_path = \"tests/data/template.xml\"\n\t    payment_initiation_message_type = \"pain.001.001.03\"\n\t    expected_output = \"tests/data/pain.001.001.03.xml\"\n\t    assert generate_updated_xml_file_path(\n", "        xml_file_path,\n\t        payment_initiation_message_type\n\t    ) == expected_output\n"]}
{"filename": "tests/test_validate_via_xsd.py", "chunked_list": ["import unittest\n\timport os\n\tfrom pain001.xml.validate_via_xsd import validate_via_xsd\n\t# Test if the XML file is validated correctly against the XSD schema\n\tclass TestValidateViaXsd(unittest.TestCase):\n\t    def setUp(self):\n\t        \"\"\"\n\t        Test case setup method.\n\t        \"\"\"\n\t        self.valid_xml_file = \"valid_test.xml\"\n", "        self.invalid_xml_file = \"invalid_test.xml\"\n\t        self.xsd_file = \"test_schema.xsd\"\n\t        # Create valid XML test file\n\t        with open(self.valid_xml_file, \"w\") as f:\n\t            f.write(\n\t                \"\"\"<root>\n\t                            <element>Valid data</element>\n\t                        </root>\"\"\"\n\t            )\n\t        # Create invalid XML test file\n", "        with open(self.invalid_xml_file, \"w\") as f:\n\t            f.write(\n\t                \"\"\"\n\t            <root>\n\t                <invalidElement>Invalid data</invalidElement>\n\t            </root>\n\t            \"\"\"\n\t            )\n\t        # Create test XSD schema file\n\t        with open(self.xsd_file, \"w\") as f:\n", "            f.write(\n\t                \"\"\"\n\t            <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n\t                <xs:element name=\"root\">\n\t                    <xs:complexType>\n\t                        <xs:sequence>\n\t                            <xs:element name=\"element\">\n\t                                <xs:simpleType>\n\t                                    <xs:restriction base=\"xs:string\"/>\n\t                                </xs:simpleType>\n", "                            </xs:element>\n\t                        </xs:sequence>\n\t                    </xs:complexType>\n\t                </xs:element>\n\t            </xs:schema>\n\t            \"\"\"\n\t            )\n\t    def tearDown(self):\n\t        \"\"\"\n\t        Test case tear down method.\n", "        \"\"\"\n\t        os.remove(self.valid_xml_file)\n\t        os.remove(self.invalid_xml_file)\n\t        os.remove(self.xsd_file)\n\t    def test_valid_xml(self):\n\t        \"\"\"\n\t        Test case for validating a valid XML file against an XSD schema.\n\t        \"\"\"\n\t        assert validate_via_xsd(self.valid_xml_file, self.xsd_file)\n\t    def test_invalid_xml(self):\n", "        \"\"\"\n\t        Test case for validating an invalid XML file against an XSD schema.\n\t        \"\"\"\n\t        assert not validate_via_xsd(\n\t            self.invalid_xml_file, self.xsd_file\n\t        )\n\t        assert not validate_via_xsd(\n\t            self.invalid_xml_file, self.xsd_file\n\t        )\n"]}
{"filename": "tests/test_create_root_element.py", "chunked_list": ["from pain001.xml.create_root_element import create_root_element\n\timport xml.etree.ElementTree as ET\n\t# Test if the root element is created correctly\n\tdef test_create_root_element():\n\t    # Define the XML message type\n\t    payment_initiation_message_type = \"pain.001.001.03\"\n\t    # Create the root element\n\t    root = create_root_element(payment_initiation_message_type)\n\t    # Check if root element has correct tag\n\t    assert root.tag == 'Document'\n", "    # Check if xmlns attribute is set correctly\n\t    xmlns_attr = 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03'\n\t    assert root.attrib['xmlns'] == xmlns_attr\n\t    # Check if xmlns:xsi attribute is set correctly\n\t    xsi_attr = 'http://www.w3.org/2001/XMLSchema-instance'\n\t    assert root.attrib['xmlns:xsi'] == xsi_attr\n\t    # Check if xsi:schemaLocation attribute is set correctly\n\t    schema_location = (\n\t        'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03 '\n\t        'pain.001.001.03.xsd'\n", "    )\n\t    assert root.attrib['xsi:schemaLocation'] == schema_location\n\tdef test_create_root_element_returns_element_object():\n\t    # Define the XML message type\n\t    payment_initiation_message_type = \"pain.001.001.03\"\n\t    # Create the root element\n\t    root = create_root_element(payment_initiation_message_type)\n\t    # Check if root element is an instance of Element\n\t    assert isinstance(root, ET.Element)\n\tdef test_create_root_element_does_not_raise_exception():\n", "    try:\n\t        # Define the XML message type\n\t        payment_initiation_message_type = \"pain.001.001.03\"\n\t        # Create the root element\n\t        create_root_element(payment_initiation_message_type)\n\t    except Exception:\n\t        error_msg = 'create_root_element unexpected exception'\n\t        assert False, error_msg\n\tdef test_create_root_element_handles_empty_input_gracefully():\n\t    # Test that the function does not raise an exception when\n", "    # called with no input\n\t    try:\n\t        # Define the XML message type\n\t        payment_initiation_message_type = \"pain.001.001.03\"\n\t        # Create the root element\n\t        create_root_element(payment_initiation_message_type)\n\t    except Exception:\n\t        error_msg = 'create_root_element unexpected exception'\n\t        assert False, error_msg\n\tdef test_create_root_element_sets_all_expected_attributes_correctly():\n", "    # Define the XML message type\n\t    payment_initiation_message_type = \"pain.001.001.03\"\n\t    # Create the root element\n\t    root = create_root_element(payment_initiation_message_type)\n\t    # Check if required attributes are set correctly\n\t    assert root.tag == 'Document'\n\t    # Check if xmlns attribute is set correctly\n\t    expected_xmlns = 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03'\n\t    assert root.attrib['xmlns'] == expected_xmlns\n\t    # Check if xmlns:xsi attribute is set correctly\n", "    expected_xsi = 'http://www.w3.org/2001/XMLSchema-instance'\n\t    assert root.attrib['xmlns:xsi'] == expected_xsi\n\t    # Check if xsi:schemaLocation attribute is set correctly\n\t    assert root.attrib['xsi:schemaLocation'] == (\n\t        'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03 '\n\t        'pain.001.001.03.xsd'\n\t    )\n\t    # Check if optional attributes are set correctly\n\t    root_with_optional_attrs = create_root_element(\n\t        payment_initiation_message_type\n", "    )\n\t    assert 'xmlns:xs' not in root_with_optional_attrs.attrib.keys()\n\t    root = create_root_element(payment_initiation_message_type)\n\t    # Check that optional attributes are not set by default\n\t    assert 'xmlns:xs' not in root.attrib.keys()\n\t    assert 'xmlns:foo' not in root.attrib.keys()\n\t    # Set optional attributes and check that they are set correctly\n\t    root.set('xmlns:xs', 'http://www.w3.org/2001/XMLSchema')\n\t    root.set('xmlns:foo', 'http://example.com/foo')\n\t    assert root.attrib['xmlns:xs'] == 'http://www.w3.org/2001/XMLSchema'\n", "    assert root.attrib['xmlns:foo'] == 'http://example.com/foo'\n"]}
{"filename": "tests/test_validate_csv_data.py", "chunked_list": ["import unittest\n\tfrom pain001.csv.validate_csv_data import validate_csv_data\n\t# Test if the CSV data is validated correctly\n\tclass TestValidateCsvData(unittest.TestCase):\n\t    def test_valid_data(self):\n\t        # Test valid data\n\t        data = [\n\t            {\n\t                'id': '1',\n\t                'date': '2022-01-01',\n", "                'nb_of_txs': '1',\n\t                'initiator_name': 'John Doe',\n\t                'payment_information_id': '12345',\n\t                'payment_method': 'TRF',\n\t                'batch_booking': 'false',\n\t                'control_sum': '100',\n\t                'service_level_code': 'SEPA',\n\t                'requested_execution_date': '2022-01-01',\n\t                'debtor_name': 'John Doe',\n\t                'debtor_account_IBAN': 'DE89370400440532013000',\n", "                'debtor_agent_BIC': 'DEUTDEDBFRA',\n\t                'forwarding_agent_BIC': 'FORWARD',\n\t                'charge_bearer': 'SHA',\n\t                'payment_id': '12345',\n\t                'payment_amount': '100.00',\n\t                'currency': 'EUR',\n\t                'creditor_agent_BIC': 'DABADEHHXXX',\n\t                'creditor_name': 'Jane Doe',\n\t                'creditor_account_IBAN': 'DE89370400440532013001',\n\t                'remittance_information': 'Invoice 1234'\n", "            },\n\t            {\n\t                'id': '2',\n\t                'date': '2022-01-02',\n\t                'nb_of_txs': '1',\n\t                'initiator_name': 'Jane Doe',\n\t                'payment_information_id': '67890',\n\t                'payment_method': 'TRF',\n\t                'batch_booking': 'false',\n\t                'control_sum': '200',\n", "                'service_level_code': 'SEPA',\n\t                'requested_execution_date': '2022-01-02',\n\t                'debtor_name': 'Jane Doe',\n\t                'debtor_account_IBAN': 'DE89370400440532013001',\n\t                'debtor_agent_BIC': 'DEUTDEDBFRA',\n\t                'forwarding_agent_BIC': 'FORWARD2',\n\t                'charge_bearer': 'SHA',\n\t                'payment_id': '67890',\n\t                'payment_amount': '200.00',\n\t                'currency': 'EUR',\n", "                'creditor_agent_BIC': 'DABADEHHXXX',\n\t                'creditor_name': 'John Doe',\n\t                'creditor_account_IBAN': 'DE89370400440532013000',\n\t                'remittance_information': 'Invoice 5678'\n\t            }\n\t        ]\n\t        assert validate_csv_data(data) is True\n\t    def test_missing_required_columns(self):\n\t        # Test missing required columns\n\t        data = [\n", "            {\n\t                'id': '1',\n\t                'date': '2022-01-01',\n\t                'nb_of_txs': '1',\n\t                'payment_information_id': '12345',\n\t                'payment_method': 'TRF',\n\t                'batch_booking': 'false',\n\t                'control_sum': '100',\n\t                'service_level_code': 'SEPA',\n\t                'requested_execution_date': '2022-01-01',\n", "                'debtor_name': 'John Doe',\n\t                'debtor_account_IBAN': 'DE89370400440532013000',\n\t                'debtor_agent_BIC': 'DEUTDEDBFRA',\n\t                'forwarding_agent_BIC': 'FORWARD',\n\t                'charge_bearer': 'SHA',\n\t                'payment_id': '12345',\n\t                'payment_amount': '100.00',\n\t                'currency': 'EUR',\n\t                'creditor_agent_BIC': 'DABADEHHXXX',\n\t                'creditor_name': 'Jane Doe',\n", "                'creditor_account_IBAN': 'DE89370400440532013001',\n\t                'remittance_information': 'Invoice 1234'\n\t            },\n\t            {\n\t                'id': '2',\n\t                'date': '2022-01-02',\n\t                'nb_of_txs': '1',\n\t                'initiator_name': 'Jane Doe',\n\t                'payment_information_id': '67890',\n\t                'payment_method': 'TRF',\n", "                'batch_booking': 'false',\n\t                'control_sum': '200',\n\t                'service_level_code': 'SEPA',\n\t                'requested_execution_date': '2022-01-02',\n\t                'debtor_name': 'Jane Doe',\n\t                'debtor_account_IBAN': 'DE89370400440532013001',\n\t                'debtor_agent_BIC': 'DEUTDEDBFRA',\n\t                'forwarding_agent_BIC': 'FORWARD',\n\t                'charge_bearer': 'SHA',\n\t                'payment_id': '67890',\n", "                'payment_amount': '200.00',\n\t                'currency': 'EUR',\n\t                'creditor_agent_BIC': 'DABADEHHXXX',\n\t                'creditor_name': 'John Doe',\n\t                'creditor_account_IBAN': 'DE89370400440532013000',\n\t                'remittance_information': 'Invoice 5678'\n\t            }\n\t        ]\n\t        assert not validate_csv_data(data)\n"]}
{"filename": "tests/test_context.py", "chunked_list": ["import logging\n\timport unittest\n\tfrom pain001.context.context import Context\n\tclass TestContext(unittest.TestCase):\n\t    \"\"\"Unit tests for the Context class.\"\"\"\n\t    def setUp(self):\n\t        \"\"\"Set up the test fixture.\"\"\"\n\t        Context.instance = None\n\t    def tearDown(self):\n\t        \"\"\"Tear down the test fixture.\"\"\"\n", "        if Context.instance:\n\t            Context.instance.logger = None\n\t        Context.instance = None\n\t    def test_singleton(self):\n\t        \"\"\"Test that Context is a singleton.\"\"\"\n\t        context1 = Context()\n\t        context2 = Context.get_instance()\n\t        self.assertEqual(context1, context2)\n\t        with self.assertRaises(Exception):\n\t            Context()\n", "    def test_set_name(self):\n\t        \"\"\"Test that set_name() sets the name of the logger.\"\"\"\n\t        context = Context.get_instance()\n\t        context.set_name(\"my_context\")\n\t        self.assertEqual(context.name, \"my_context\")\n\t    def test_set_log_level(self):\n\t        \"\"\"Test that set_log_level() sets the log level of the logger\"\"\"\n\t        context = Context.get_instance()\n\t        \"\"\"Test all valid log levels\"\"\"\n\t        valid_log_levels = {\n", "            \"DEBUG\": logging.DEBUG,\n\t            \"INFO\": logging.INFO,\n\t            \"WARNING\": logging.WARNING,\n\t            \"ERROR\": logging.ERROR,\n\t            \"CRITICAL\": logging.CRITICAL,\n\t        }\n\t        for level_str, level_int in valid_log_levels.items():\n\t            context.set_log_level(level_str)\n\t            self.assertEqual(context.log_level, level_int)\n\t            context.set_log_level(level_int)\n", "            self.assertEqual(context.log_level, level_int)\n\t        \"\"\"\n\t        Test that set_log_level() raises an exception if the log level is\n\t        invalid.\n\t        \"\"\"\n\t        with self.assertRaises(Exception):\n\t            context.set_log_level(\"INVALID\")\n\t        with self.assertRaises(Exception):\n\t            context.set_log_level(12345)  # some invalid int\n\t    def test_init_logger(self):\n", "        \"\"\"Test that init_logger() initializes the logger.\"\"\"\n\t        context = Context.get_instance()\n\t        \"\"\"Ensure the logger is not initialized\"\"\"\n\t        context.logger = None\n\t        context.init_logger()\n\t        self.assertIsNotNone(context.logger)\n\t        \"\"\"Test that init_logger() raises an exception if called again.\"\"\"\n\t        with self.assertRaises(Exception):\n\t            context.init_logger()\n\t    def test_get_logger(self):\n", "        \"\"\"Test that get_logger() returns the logger.\"\"\"\n\t        context = Context.get_instance()\n\t        logger = context.get_logger()\n\t        self.assertIsNotNone(logger)\n\t        self.assertEqual(logger, context.logger)\n\t        \"\"\"Test that get_logger() can initialize the logger.\"\"\"\n\t        context.logger = None\n\t        logger = context.get_logger()\n\t        self.assertIsNotNone(logger)\n\t        self.assertEqual(logger, context.logger)\n", "    def test_log_level_propagation(self):\n\t        \"\"\"Test that the log level is correctly propagated to the logger.\"\"\"\n\t        context = Context.get_instance()\n\t        context.set_log_level(logging.DEBUG)\n\t        self.assertEqual(context.logger.level, logging.DEBUG)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_create_xml_element.py", "chunked_list": ["import unittest\n\timport xml.etree.ElementTree as ET\n\tfrom pain001.xml.create_xml_element import create_xml_element\n\t# Test if the XML element is created correctly\n\tclass TestCreateXmlElement(unittest.TestCase):\n\t    def test_create_element_with_tag_only(self):\n\t        \"\"\"\n\t        Test if the XML element is created correctly with a tag only.\n\t        \"\"\"\n\t        root = ET.Element(\"root\")\n", "        elem = create_xml_element(root, \"test\")\n\t        self.assertEqual(elem.tag, \"test\")\n\t        self.assertIsNone(elem.text)\n\t        self.assertEqual(root.find(\"test\"), elem)\n\t    def test_create_element_with_tag_and_text(self):\n\t        \"\"\"\n\t        Test if the XML element is created correctly with a tag and text.\n\t        \"\"\"\n\t        root = ET.Element(\"root\")\n\t        elem = create_xml_element(root, \"test\", text=\"Hello, world!\")\n", "        self.assertEqual(elem.tag, \"test\")\n\t        self.assertEqual(elem.text, \"Hello, world!\")\n\t        self.assertEqual(root.find(\"test\"), elem)\n\t    def test_create_element_with_tag_and_attributes(self):\n\t        \"\"\"\n\t        Test if the XML element is created correctly with a tag and attributes.\n\t        \"\"\"\n\t        root = ET.Element(\"root\")\n\t        attributes = {\"attr1\": \"value1\", \"attr2\": \"value2\"}\n\t        elem = create_xml_element(root, \"test\", attributes=attributes)\n", "        self.assertEqual(elem.tag, \"test\")\n\t        self.assertIsNone(elem.text)\n\t        self.assertEqual(elem.attrib, attributes)\n\t        self.assertEqual(root.find(\"test\"), elem)\n\t    def test_create_element_with_tag_text_and_attributes(self):\n\t        \"\"\"\n\t        Test if the XML element is created correctly with a tag, text and\n\t        attributes.\n\t        \"\"\"\n\t        root = ET.Element(\"root\")\n", "        attributes = {\"attr1\": \"value1\", \"attr2\": \"value2\"}\n\t        elem = create_xml_element(\n\t            root, \"test\", text=\"Hello, world!\", attributes=attributes\n\t        )\n\t        self.assertEqual(elem.tag, \"test\")\n\t        self.assertEqual(elem.text, \"Hello, world!\")\n\t        self.assertEqual(elem.attrib, attributes)\n\t        self.assertEqual(root.find(\"test\"), elem)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/test_core.py", "chunked_list": ["import pytest\n\timport sys\n\tfrom contextlib import contextmanager\n\tfrom io import StringIO\n\tfrom pain001.core.core import process_files\n\t@contextmanager\n\tdef catch_stdout():\n\t    try:\n\t        old_out, sys.stdout = sys.stdout, StringIO()\n\t        yield sys.stdout\n", "    finally:\n\t        sys.stdout = old_out\n\tclass TestProcessFiles:\n\t    def test_invalid_csv_data(self):\n\t        \"\"\"\n\t        Test case for processing files with invalid CSV data.\n\t        \"\"\"\n\t        with catch_stdout():\n\t            with pytest.raises(SystemExit) as exc_info:\n\t                process_files(\n", "                    \"pain.001.001.03\",\n\t                    \"tests/data/template.xml\",\n\t                    \"tests/data/template.xsd\",\n\t                    \"tests/data/invalid.csv\",\n\t                )\n\t        assert exc_info.value.code == 1\n\t    def test_invalid_xml_message_type(self):\n\t        \"\"\"\n\t        Test case for processing files with an invalid XML message type.\n\t        \"\"\"\n", "        with pytest.raises(ValueError) as exc_info:\n\t            process_files(\n\t                \"invalid\",\n\t                \"tests/data/template.xml\",\n\t                \"tests/data/template.xsd\",\n\t                \"tests/data/template.csv\",\n\t            )\n\t        error_message = str(exc_info.value)\n\t        expected_error_message = (\n\t            \"Error: Invalid XML message type: 'invalid'.\"\n", "        )\n\t        assert error_message == expected_error_message\n\t    def test_nonexistent_data_file_path(self):\n\t        \"\"\"\n\t        Test case for processing files with a non-existent data file path.\n\t        \"\"\"\n\t        with pytest.raises(FileNotFoundError) as exc_info:\n\t            process_files(\n\t                \"pain.001.001.03\",\n\t                \"tests/data/template.xml\",\n", "                \"tests/data/template.xsd\",\n\t                \"tests/data/nonexistent.csv\",\n\t            )\n\t        assert (\n\t            str(exc_info.value)\n\t            == \"Error: Data file 'tests/data/nonexistent.csv' does not exist.\"\n\t        )\n\t    def test_nonexistent_xml_file_path(self):\n\t        \"\"\"\n\t        Test case for processing files with a non-existent XML file path.\n", "        \"\"\"\n\t        with pytest.raises(FileNotFoundError):\n\t            process_files(\n\t                \"pain.001.001.03\",\n\t                \"tests/data/nonexistent.xml\",\n\t                \"tests/data/template.xsd\",\n\t                \"tests/data/template.csv\",\n\t            )\n\t        # assert exc_info.value.code == 1\n\t    def test_nonexistent_xsd_file_path(self):\n", "        \"\"\"\n\t        Test case for processing files with a non-existent XSD file path.\n\t        \"\"\"\n\t        with pytest.raises(FileNotFoundError):\n\t            process_files(\n\t                \"pain.001.001.03\",\n\t                \"tests/data/template.xml\",\n\t                \"tests/data/nonexistent.xsd\",\n\t                \"tests/data/template.csv\",\n\t            )\n", "        # assert exc_info.value.code == 1\n\t    def test_successful_execution(self):\n\t        \"\"\"\n\t        Test case for successful execution of file processing.\n\t        \"\"\"\n\t        process_files(\n\t            \"pain.001.001.03\",\n\t            \"tests/data/template.xml\",\n\t            \"tests/data/template.xsd\",\n\t            \"tests/data/template.csv\",\n", "        )\n\t    def test_unsupported_data_file_type(self):\n\t        \"\"\"\n\t        Test case for processing files with an unsupported data file type.\n\t        \"\"\"\n\t        with pytest.raises(ValueError) as exc_info:\n\t            process_files(\n\t                \"pain.001.001.03\",\n\t                \"tests/data/template.xml\",\n\t                \"tests/data/template.xsd\",\n", "                \"tests/data/invalid.rtf\",\n\t            )\n\t        assert (\n\t            str(exc_info.value) == \"Error: Unsupported data file type.\"\n\t        )\n\t    def test_uses_sqlite_database(self):\n\t        \"\"\"\n\t        Test case for processing files using an SQLite database.\n\t        \"\"\"\n\t        xml_message_type = \"pain.001.001.03\"\n", "        xml_file_path = \"tests/data/template.xml\"\n\t        xsd_file_path = \"tests/data/template.xsd\"\n\t        data_file_path = \"tests/data/template.db\"\n\t        process_files(\n\t            xml_message_type,\n\t            xml_file_path,\n\t            xsd_file_path,\n\t            data_file_path,\n\t        )\n\t    def test_valid_xml_message_type(self):\n", "        \"\"\"\n\t        Test case for processing files with a valid XML message type.\n\t        \"\"\"\n\t        process_files(\n\t            \"pain.001.001.03\",\n\t            \"tests/data/template.xml\",\n\t            \"tests/data/template.xsd\",\n\t            \"tests/data/template.csv\",\n\t        )\n"]}
{"filename": "tests/test_generate_xml.py", "chunked_list": ["import unittest\n\timport xml.etree.ElementTree as ET\n\tfrom pain001.xml.generate_xml import (\n\t    create_common_elements,\n\t    create_xml_v3,\n\t    create_xml_v9,\n\t)\n\tclass TestXMLCreation(unittest.TestCase):\n\t    def setUp(self):\n\t        \"\"\"\n", "        Test setup\n\t        \"\"\"\n\t        self.root = ET.Element(\"Root\")\n\t        self.row = {\n\t            \"initiator_name\": \"Initiator\",\n\t            \"batch_booking\": \"true\",\n\t            \"nb_of_txs\": \"2\",\n\t            \"control_sum\": \"3000\",\n\t            \"service_level_code\": \"Code\",\n\t            \"requested_execution_date\": \"2023-05-21\",\n", "            \"debtor_name\": \"Debtor\",\n\t            \"debtor_account_IBAN\": \"DE123456789\",\n\t            \"debtor_agent_BIC\": \"DEUTDEFF\",\n\t            \"charge_bearer\": \"Bearer\",\n\t            \"payment_id\": \"PID123\",\n\t            \"payment_amount\": \"1500\",\n\t            \"payment_method\": \"pain.001.001.09\",\n\t            \"currency\": \"EUR\",\n\t            \"creditor_agent_BIC\": \"NOLADE21KIE\",\n\t            \"creditor_name\": \"Creditor\",\n", "            \"creditor_account_IBAN\": \"DE26500700100096773701\",\n\t            \"remittance_information\": \"Invoice 123\",\n\t        }\n\t        self.mapping = {\n\t            \"MsgId\": \"payment_id\",\n\t            \"CreDtTm\": \"requested_execution_date\",\n\t            \"NbOfTxs\": \"nb_of_txs\",\n\t            \"PmtInfId\": \"payment_id\",\n\t            \"PmtMtd\": \"payment_method\",\n\t        }\n", "    def test_create_common_elements(self):\n\t        \"\"\"\n\t        Test create_common_elements\n\t        \"\"\"\n\t        create_common_elements(self.root, self.row, self.mapping)\n\t        self.assertEqual(len(self.root), 2)\n\t        self.assertEqual(self.root[0].tag, \"PmtInfId\")\n\t        self.assertEqual(self.root[0].text, \"PID123\")\n\t        self.assertEqual(self.root[1].tag, \"PmtMtd\")\n\t        self.assertEqual(self.root[1].text, \"pain.001.001.09\")\n", "    def test_create_xml_v3(self):\n\t        \"\"\"\n\t        Test create_xml_v3\n\t        \"\"\"\n\t        create_xml_v3(self.root, [self.row], self.mapping)\n\t        cstmr_cdt_trf_initn_element = self.root[0]\n\t        self.assertEqual(\n\t            cstmr_cdt_trf_initn_element.tag, \"CstmrCdtTrfInitn\"\n\t        )\n\t        # You can continue to assert more conditions based on your expectations\n", "    def test_create_xml_v9(self):\n\t        \"\"\"\n\t        Test create_xml_v9\n\t        \"\"\"\n\t        create_xml_v9(self.root, [self.row], self.mapping)\n\t        cstmr_cdt_trf_initn_element = self.root[0]\n\t        self.assertEqual(\n\t            cstmr_cdt_trf_initn_element.tag, \"CstmrCdtTrfInitn\"\n\t        )\n\t        # You can continue to assert more conditions based on your expectations\n", "if __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/test_xml_generator.py", "chunked_list": ["import unittest\n\tfrom pain001.xml.xml_generator import xml_generator\n\tclass TestXmlGenerator(unittest.TestCase):\n\t    def test_xml_generator_with_invalid_input(self):\n\t        \"\"\"\n\t        Test if the XML generator exits with a non-zero exit code when\n\t        invalid input is provided.\n\t        \"\"\"\n\t        # Arrange\n\t        data = {\n", "            \"amount\": \"100.00\",\n\t            \"currency\": \"USD\",\n\t            \"beneficiary_bic\": \"ABCDE123\",\n\t            \"beneficiary_iban\": \"DE8937060198000001234567\",\n\t            \"creditor_bic\": \"DEFGH456\",\n\t            \"creditor_iban\": \"DE893706019800000234567\",\n\t        }\n\t        mapping = {\n\t            \"amount\": \"Amount\",\n\t            \"currency\": \"Currency\",\n", "            \"beneficiary_bic\": \"BeneficiaryBIC\",\n\t            \"beneficiary_iban\": \"BeneficiaryIBAN\",\n\t            \"creditor_bic\": \"CreditorBIC\",\n\t            \"creditor_iban\": \"CreditorIBAN\",\n\t        }\n\t        payment_initiation_message_type = \"invalid_message_type\"\n\t        xml_file_path = \"test.xml\"\n\t        xsd_file_path = \"schema.xsd\"\n\t        # Act\n\t        with self.assertRaises(SystemExit):\n", "            xml_generator(\n\t                data,\n\t                mapping,\n\t                payment_initiation_message_type,\n\t                xml_file_path,\n\t                xsd_file_path,\n\t            )\n\t        # Assert\n\t        # self.assertEqual(sys.exitcode, 1)\n\tif __name__ == \"__main__\":\n", "    unittest.main()\n"]}
{"filename": "tests/test_load_csv_data.py", "chunked_list": ["import csv\n\tfrom pain001.csv.load_csv_data import load_csv_data\n\t# Test if the CSV data is loaded correctly\n\tdef test_load_csv_data():\n\t    # Test with an existing CSV file\n\t    csv_file_path = \"tests/data/existing_file.csv\"\n\t    expected_output = [\n\t        {\"col1\": \"val1\", \"col2\": \"val2\", \"col3\": \"val3\"},\n\t        {\"col1\": \"val4\", \"col2\": \"val5\", \"col3\": \"val6\"},\n\t        {\"col1\": \"val7\", \"col2\": \"val8\", \"col3\": \"val9\"},\n", "    ]\n\t    with open(csv_file_path, \"w\", newline=\"\") as csv_file:\n\t        writer = csv.DictWriter(\n\t            csv_file, fieldnames=[\"col1\", \"col2\", \"col3\"]\n\t        )\n\t        writer.writeheader()\n\t        writer.writerows(expected_output)\n\t    assert load_csv_data(csv_file_path) == expected_output\n\t    # Test with a non-existing CSV file\n\t    csv_file_path = \"path/to/non_existing_file.csv\"\n", "    try:\n\t        load_csv_data(csv_file_path)\n\t    except FileNotFoundError as e:\n\t        assert str(e) == f\"CSV file '{csv_file_path}' does not exist.\"\n\t    else:\n\t        assert False, \"Expected FileNotFoundError not raised.\"\n"]}
