{"filename": "setup.py", "chunked_list": ["import pathlib\n\timport re\n\tfrom setuptools import setup\n\tROOT = pathlib.Path(__file__).parent\n\twith open('adapt/__init__.py', 'r') as f:\n\t    content = f.read()\n\t    def extract_magic_value(name: str, *, default: str | None = None) -> str:\n\t        try:\n\t            return re.search(rf'^__{name}__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', content, re.MULTILINE).group(1)\n\t        except AttributeError:\n", "            if default is None:\n\t                raise RuntimeError(f'Unable to find {name} string')\n\t            return default\n\t    version = extract_magic_value('version')\n\t    author = extract_magic_value('author', default='jay3332')\n\t    license_ = extract_magic_value('license', default='MIT')\n\twith open(ROOT / 'README.md', encoding='utf-8') as f:\n\t    readme = f.read()\n\twith open(ROOT / 'requirements.txt', encoding='utf-8') as f:\n\t    requirements = f.readlines()\n", "setup(\n\t    name=\"adapt.py\",\n\t    author=author,\n\t    url=\"https://github.com/AdaptChat/adapt.py\",\n\t    project_urls={\n\t        \"Issue tracker\": \"https://github.com/AdaptChat/adapt.py/issues/new\",\n\t        \"Documentation\": \"https://adaptpy.readthedocs.io/en/latest/\",\n\t        \"Discord server\": \"https://discord.gg/5BUFNBPG\",\n\t    },\n\t    version=version,\n", "    packages=[\"adapt\", \"adapt.models\", \"adapt.types\"],\n\t    license=license_,\n\t    description=\"Official wrapper around Adapt's API for Python.\",\n\t    long_description=readme,\n\t    long_description_content_type=\"text/markdown\",\n\t    include_package_data=True,\n\t    install_requires=requirements,\n\t    extras_require={\n\t        \"docs\": [\n\t            \"sphinx>=4.1.1\",\n", "            # \"sphinx-material\",\n\t            # 'sphinx-copybutton',\n\t            # 'readthedocs-sphinx-search',\n\t            'furo',\n\t        ],\n\t        \"performance\": [\"aiohttp[speedups]\", \"msgpack\"],\n\t    },\n\t    python_requires=\">=3.8.0\",\n\t    classifiers=[\n\t        'Development Status :: 4 - Beta',\n", "        'License :: OSI Approved :: MIT License',\n\t        'Intended Audience :: Developers',\n\t        'Natural Language :: English',\n\t        'Operating System :: OS Independent',\n\t        'Programming Language :: Python :: 3.8',\n\t        'Programming Language :: Python :: 3.9',\n\t        'Programming Language :: Python :: 3.10',\n\t        'Programming Language :: Python :: 3.11',\n\t        'Topic :: Internet',\n\t        'Topic :: Software Development :: Libraries',\n", "        'Topic :: Software Development :: Libraries :: Python Modules',\n\t        'Topic :: Utilities',\n\t        'Typing :: Typed',\n\t    ],\n\t)\n"]}
{"filename": "adapt/websocket.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\timport json\n\timport time\n\tfrom typing import TYPE_CHECKING\n\tfrom aiohttp import WSMsgType\n\tfrom .server import AdaptServer\n\tfrom .util import MISSING\n\tif TYPE_CHECKING:\n\t    from asyncio import Task\n", "    from typing import Any, Callable, TypedDict, TypeAlias, Final\n\t    from aiohttp import ClientWebSocketResponse\n\t    from .connection import Connection\n\t    from .models.enums import Status\n\t    from .types.ws import InboundMessage\n\t    Dispatcher: TypeAlias = Callable[..., Task[list[Any]]]\n\ttry:\n\t    import msgpack\n\texcept ModuleNotFoundError:\n\t    HAS_MSGPACK = False\n", "else:\n\t    HAS_MSGPACK = True\n\tDEFAULT_WS_URL: Final[str] = AdaptServer.production().harmony\n\tclass HeartbeatManager:\n\t    \"\"\"Manages and acks heartbeats from and to harmony.\"\"\"\n\t    __slots__ = (\n\t        '_ws',\n\t        '_connection',\n\t        'acked',\n\t        '_is_active',\n", "        '_task',\n\t        '_last_heartbeat',\n\t        '_last_heartbeat_ack',\n\t        '_heartbeat_interval',\n\t        '_heartbeat_timeout',\n\t    )\n\t    def __init__(\n\t        self,\n\t        ws: WebSocket,\n\t        /,\n", "        *,\n\t        heartbeat_interval: float = 15.0,\n\t        heartbeat_timeout: float = 3.0,\n\t    ) -> None:\n\t        self._ws = ws\n\t        self._connection = ws._connection\n\t        self.acked = self._connection.loop.create_future()\n\t        self._is_active = False\n\t        self._heartbeat_interval = heartbeat_interval\n\t        self._heartbeat_timeout = heartbeat_timeout\n", "        self._last_heartbeat: int | None = None\n\t        self._last_heartbeat_ack: int | None = None\n\t    @property\n\t    def is_active(self) -> bool:\n\t        return self._is_active\n\t    @property\n\t    def loop(self) -> asyncio.AbstractEventLoop:\n\t        return self._connection.loop\n\t    @property\n\t    def latency_ns(self) -> int | None:\n", "        if self._last_heartbeat is None or self._last_heartbeat_ack is None:\n\t            return None\n\t        return self._last_heartbeat_ack - self._last_heartbeat\n\t    def start(self) -> None:\n\t        if self.is_active:\n\t            return\n\t        self.acked = self.loop.create_future()\n\t        self._task = self.loop.create_task(self.heartbeat_task())\n\t        self._is_active = True\n\t    def ack(self) -> None:\n", "        self._last_heartbeat_ack = time.perf_counter_ns()\n\t        self.acked.set_result(True)\n\t        self.acked = self.loop.create_future()\n\t    async def stop(self) -> None:\n\t        if not self.is_active:\n\t            return\n\t        self._task.cancel()\n\t        try:\n\t            await self._task\n\t        except asyncio.CancelledError:\n", "            pass\n\t        finally:\n\t            self._is_active = False\n\t    async def heartbeat(self) -> None:\n\t        await self._ws.send({\"op\": \"ping\"})\n\t        self._last_heartbeat = time.perf_counter_ns()\n\t    async def heartbeat_task(self) -> None:\n\t        while not self._ws.closed:\n\t            await self.heartbeat()\n\t            try:\n", "                await asyncio.wait_for(self.acked, timeout=self._heartbeat_timeout)\n\t            except asyncio.TimeoutError:\n\t                await self.stop()\n\t                raise AttemptReconnect\n\t            await asyncio.sleep(self._heartbeat_interval)\n\tclass AttemptReconnect(Exception):\n\t    pass\n\tclass WebSocket:\n\t    \"\"\"The WebSocket client used to interact with Adapt's websocket, harmony.\"\"\"\n\t    __slots__ = (\n", "        '_connection',\n\t        '_loop',\n\t        '_session',\n\t        '_dispatch',\n\t        '_token',\n\t        '_msgpack',\n\t        '_heartbeat_manager',\n\t        'ws_url',\n\t        'ws',\n\t    )\n", "    ws: ClientWebSocketResponse | None\n\t    def __init__(\n\t        self,\n\t        connection: Connection,\n\t        *,\n\t        prefer_msgpack: bool = True,\n\t        ws_url: str = DEFAULT_WS_URL,\n\t        heartbeat_interval: float = 15.0,\n\t        heartbeat_timeout: float = 3.0,\n\t    ) -> None:\n", "        self._connection = connection\n\t        self._loop = connection.loop\n\t        http = connection.http\n\t        self._session = http.session\n\t        self._dispatch = connection.dispatch\n\t        self._token = http.token\n\t        self._msgpack = prefer_msgpack and HAS_MSGPACK\n\t        self._heartbeat_manager = HeartbeatManager(\n\t            self,\n\t            heartbeat_interval=heartbeat_interval,\n", "            heartbeat_timeout=heartbeat_timeout,\n\t        )\n\t        self.ws_url = ws_url\n\t        self.ws = None\n\t        if prefer_msgpack:\n\t            self.ws_url += '?format=msgpack'\n\t    @property\n\t    def closed(self) -> bool:\n\t        return self.ws is None or self.ws.closed\n\t    @property\n", "    def latency(self) -> float | None:\n\t        return self.latency_ns and self.latency_ns / 1_000_000_000\n\t    @property\n\t    def latency_ns(self) -> int | None:\n\t        return self._heartbeat_manager.latency_ns\n\t    async def send(self, data: dict[Any, Any] | TypedDict) -> None:\n\t        if self._msgpack:\n\t            r = msgpack.packb(data)\n\t            await self.ws.send_bytes(r)\n\t        else:\n", "            r = json.dumps(data)\n\t            await self.ws.send_str(r)\n\t    async def process_message(self, data: str | bytes) -> None:\n\t        if self._msgpack and type(data) is bytes:\n\t            msg: InboundMessage = msgpack.unpackb(data)\n\t        else:\n\t            msg: InboundMessage = json.loads(data)\n\t        assert isinstance(msg, dict) and 'event' in msg, 'Received invalid message from websocket'\n\t        event = msg['event']\n\t        args = ()\n", "        if data := msg.get('data'):\n\t            args = (data,)\n\t        self._dispatch('raw_' + event, *args)\n\t        if event == 'hello':\n\t            self._heartbeat_manager.start()\n\t        elif event == 'pong':\n\t            self._heartbeat_manager.ack()\n\t        self._connection.process_event(msg)\n\t    async def poll(self) -> None:\n\t        msg = await self.ws.receive()\n", "        if msg.type is WSMsgType.BINARY or msg.type is WSMsgType.TEXT:\n\t            await self.process_message(msg.data)\n\t        elif msg.type is WSMsgType.ERROR:\n\t            raise msg.data\n\t        else:\n\t            raise AttemptReconnect\n\t    async def connect(self, *, reconnect: bool = False) -> None:\n\t        self.ws = await self._session.ws_connect(self.ws_url)\n\t        await self.poll()\n\t        await self.send({\n", "            \"op\": \"identify\",\n\t            \"token\": self._token,\n\t            \"status\": self._connection._connect_status.value,\n\t            \"device\": \"desktop\",\n\t        })\n\t        self._dispatch(\"reconnect\" if reconnect else \"connect\")\n\t    async def update_presence(self, *, status: Status = MISSING) -> None:\n\t        payload = {\"op\": \"update_presence\"}\n\t        if status is not MISSING:\n\t            payload[\"status\"] = status.value\n", "        await self.send(payload)\n\t    async def start(self) -> None:\n\t        await self.connect()\n\t        while True:\n\t            try:\n\t                await self.poll()\n\t            except AttemptReconnect:\n\t                await self.connect(reconnect=True)\n\t                continue\n\t            except Exception:\n", "                if not self.ws.closed:\n\t                    await self.ws.close()\n\t                    self._dispatch(\"disconnect\")\n\t                    await self._heartbeat_manager.stop()\n\t                raise\n\t    async def close(self) -> bool:\n\t        await self._heartbeat_manager.stop()\n\t        if self.ws is not None:\n\t            return await self.ws.close(code=1000)\n\t        return False\n"]}
{"filename": "adapt/client.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\timport time\n\tfrom typing import Awaitable, Callable, Generic, ParamSpec, TypeVar, TYPE_CHECKING\n\timport aiohttp\n\tfrom .connection import Connection\n\tfrom .http import HTTPClient\n\tfrom .models.enums import Status\n\tfrom .models.guild import PartialGuild\n\tfrom .models.user import PartialUser\n", "from .polyfill import removeprefix\n\tfrom .server import AdaptServer\n\tfrom .util import maybe_coro, IS_DOCUMENTING, MISSING\n\tfrom .websocket import WebSocket\n\tif TYPE_CHECKING:\n\t    from typing import Any, Generator, Iterable, Self, ValuesView, TypeAlias\n\t    from .models.message import Message\n\t    from .models.ready import ReadyEvent\n\t    from .models.guild import Guild\n\t    from .models.user import ClientUser, Relationship, User\n", "    from .types.user import TokenRetrievalMethod\n\t    from .util import IOSource\n\tP = ParamSpec('P')\n\tR = TypeVar('R')\n\tClientT = TypeVar('ClientT', bound='Client')\n\tEventListener: TypeAlias = Callable[P, Awaitable[R] | R]\n\tclass _CoroutineWrapper(Generic[ClientT]):\n\t    __slots__ = ('coro', '_client')\n\t    def __init__(self, coro: Awaitable[ClientT]) -> None:\n\t        self.coro = coro\n", "        self._client: ClientT | None = None\n\t    def __await__(self) -> Generator[Any, None, ClientT]:\n\t        return self.coro.__await__()\n\t    async def __aenter__(self) -> ClientT:\n\t        client = self._client = await self.coro\n\t        return await client.__aenter__()\n\t    async def __aexit__(self, exc_type: Any, exc: Any, tb: Any) -> None:\n\t        if self._client is not None:\n\t            return await self._client.__aexit__(exc_type, exc, tb)\n\tclass WeakEventRegistry(Generic[P, R]):\n", "    \"\"\"Receives events until the specified limit or timeout.\n\t    Parameters\n\t    ----------\n\t    event_check: (str) -> bool\n\t        The predicate performed on event names.\n\t    check: (*P.args, **P.kwargs) -> bool\n\t        The predicate performed on the event.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n", "        registry: list[Self],\n\t        callback: EventListener[P, R],\n\t        *,\n\t        event_check: Callable[[str], bool | Awaitable[bool]] | None = None,\n\t        check: Callable[P, bool | Awaitable[bool]] | None = None,\n\t        timeout: float | None = None,\n\t        limit: int | None = None,\n\t    ) -> None:\n\t        self._registry = registry\n\t        self._event_check = event_check\n", "        self._destroy = timeout and time.perf_counter() + timeout\n\t        self.check = check\n\t        self.callback = callback\n\t        self.remaining = limit\n\t    def destroy(self) -> None:\n\t        \"\"\"Destroys this listener.\"\"\"\n\t        try:\n\t            self._registry.remove(self)\n\t        except ValueError:\n\t            pass\n", "    async def dispatch(self, event: str, *args: P.args, **kwargs: P.kwargs) -> None:\n\t        \"\"\"|coro|\n\t        Dispatches an event with the given arguments.\n\t        \"\"\"\n\t        if getattr(self.callback, '__adapt_call_once__', False):\n\t            self.destroy()\n\t        if self._destroy and time.perf_counter() >= self._destroy:\n\t            return self.destroy()\n\t        if self._event_check and not self._event_check(event):\n\t            return\n", "        if self.check and not await maybe_coro(self.check, *args, **kwargs):\n\t            return\n\t        if self.remaining is not None:\n\t            self.remaining -= 1\n\t            if self.remaining < 0:\n\t                return self.destroy()\n\t        await maybe_coro(self.callback, *args, **kwargs)\n\tclass EventDispatcher:\n\t    \"\"\"Base class for receiving events and then dispatching them to event handlers registered on the client.\"\"\"\n\t    if TYPE_CHECKING or IS_DOCUMENTING:\n", "        async def on_event(self, event: str, *args: Any, **kwargs: Any) -> None:\n\t            \"\"\"|coro|\n\t            A \"catch all\" event handler for all events.\n\t            Parameters\n\t            ----------\n\t            event: :class:`str`\n\t                The name of the event.\n\t            *args: Any\n\t                The positional arguments for the event.\n\t            **kwargs: Any\n", "                The keyword arguments for the event.\n\t            \"\"\"\n\t        async def on_start(self) -> None:\n\t            \"\"\"|coro|\n\t            Called when the client starts to connect. This can be used to perform any necessary setup.\n\t            \"\"\"\n\t        async def on_connect(self) -> None:\n\t            \"\"\"|coro|\n\t            Called when the client establishes a connection with the websocket.\n\t            \"\"\"\n", "        async def on_ready(self, ready: ReadyEvent) -> None:\n\t            \"\"\"|coro|\n\t            Called when the client is connected and ready to receive events from the websocket.\n\t            Parameters\n\t            ----------\n\t            ready: :class:`.ReadyEvent`\n\t                Data received with the ready event.\n\t            \"\"\"\n\t        async def on_guild_create(self, guild: Guild) -> None:\n\t            \"\"\"|coro|\n", "            Called when a guild is created.\n\t            Parameters\n\t            ----------\n\t            guild: :class:`.Guild`\n\t                The guild that was created.\n\t            \"\"\"\n\t        async def on_message(self, message: Message) -> None:\n\t            \"\"\"|coro|\n\t            Called when a message is created.\n\t            Parameters\n", "            ----------\n\t            message: :class:`.Message`\n\t                The message that was created.\n\t            \"\"\"\n\t    def __init__(self) -> None:\n\t        self._weak_listeners: list[WeakEventRegistry] = []\n\t    def event(self, callback: EventListener[P, R]) -> EventListener[P, R]:\n\t        \"\"\"Registers an event listener on the client. This overrides any previous listeners for that event.\"\"\"\n\t        event = callback.__name__\n\t        if not event.startswith('on_'):\n", "            event = 'on_' + event\n\t        setattr(self, event, callback)\n\t        return callback\n\t    def listen(\n\t        self,\n\t        *events: str,\n\t        check: Callable[P, bool | Awaitable[bool]] | None = None,\n\t        timeout: float | None = None,\n\t        limit: int | None = None,\n\t    ) -> Callable[[EventListener[P, R]], EventListener[P, R]]:\n", "        \"\"\"Registers a weak listener for the given events. You may register as many of these as you want.\n\t        Parameters\n\t        ----------\n\t        *events: :class:`str`\n\t            The events to listen for.\n\t        check: ((*P.args, **P.kwargs) -> :class:`bool`) | None\n\t            An event check for when to call the callback. Leave empty to not have a check.\n\t        timeout: :class:`float` | None\n\t            The amount of seconds before this listener should expire. Leave empty to not have a timeout.\n\t        limit: :class:`int` | None\n", "            The amount of times the callback should be called before this listener should expire.\n\t            Leave empty to not have a limit.\n\t        \"\"\"\n\t        def decorator(callback: EventListener[P, R]) -> EventListener[P, R]:\n\t            nonlocal events\n\t            events = events or (callback.__name__,)\n\t            events = tuple(removeprefix(event.lower(), 'on_') for event in events)\n\t            def event_check(event: str) -> bool:\n\t                return removeprefix(event, 'on_') in events\n\t            self._weak_listeners.append(WeakEventRegistry(\n", "                self._weak_listeners,\n\t                callback,  # type: ignore\n\t                event_check=event_check,\n\t                check=check,\n\t                timeout=timeout,\n\t                limit=limit,\n\t            ))\n\t            return callback\n\t        return decorator\n\t    def _dispatch_event(self, event: str, *args, **kwargs) -> asyncio.Task[list[Any]]:\n", "        coros = []\n\t        if callback := getattr(self, 'on_' + event, None):\n\t            assert callable(callback), f'Event listener for {event} is not callable'\n\t            if getattr(callback, '__adapt_call_once__', False):\n\t                setattr(self, 'on_' + event, None)\n\t            coros.append(maybe_coro(callback, *args, **kwargs))\n\t        coros.extend(listener.dispatch(event, *args, **kwargs) for listener in self._weak_listeners)\n\t        return asyncio.ensure_future(asyncio.gather(*coros))\n\t    def dispatch(self, event: str, *args, **kwargs) -> asyncio.Task[list[Any]]:\n\t        \"\"\"Dispatches an event to its registered listeners.\n", "        Parameters\n\t        ----------\n\t        event: :class:`str`\n\t            The event to dispatch to.\n\t        *args\n\t            Positional arguments to pass into event handlers.\n\t        **kwargs\n\t            Keyword arguments to pass into event handlers.\n\t        \"\"\"\n\t        self._dispatch_event('event', event, *args, **kwargs)\n", "        return self._dispatch_event(event, *args, **kwargs)\n\t    async def wait_for(\n\t        self,\n\t        *events: str,\n\t        check: Callable[P, bool | Awaitable[bool]] | None = None,\n\t        timeout: float | None = None,\n\t    ) -> P.args:\n\t        \"\"\"|coro|\n\t        Waits for an event to be dispatched.\n\t        Parameters\n", "        ----------\n\t        *events: :class:`str`\n\t            The events to listen for.\n\t        check: ((*P.args, **P.kwargs) -> :class:`bool`) | None\n\t            An event check for when to call the callback. Leave empty to not have a check.\n\t        timeout: :class:`float` | None\n\t            The amount of seconds before this listener should expire. Leave empty to not have a timeout.\n\t        Raises\n\t        ------\n\t        :exc:`asyncio.TimeoutError`\n", "            The event was not dispatched within the given timeout.\n\t        Returns\n\t        -------\n\t        *P.args\n\t            The positional arguments of the dispatched event.\n\t        \"\"\"\n\t        params = asyncio.Future()\n\t        @self.listen(*events, check=check, timeout=timeout)\n\t        @once\n\t        def callback(*c_args, **c_kwargs):\n", "            params.set_result((c_args, c_kwargs))\n\t        try:\n\t            result = await asyncio.wait_for(params, timeout=timeout)\n\t        except asyncio.TimeoutError:\n\t            raise\n\t        else:\n\t            args, kwargs = result\n\t            if args and kwargs:\n\t                return result\n\t            elif args:\n", "                return args[0] if len(args) == 1 else args\n\t            elif kwargs:\n\t                return kwargs\n\tclass Client(EventDispatcher):\n\t    \"\"\"Represents a client that interacts with Adapt.\n\t    This class inherits from :class:`~.client.EventDispatcher`. See the documentation for that class for documentation\n\t    on event listeners.\n\t    Attributes\n\t    ----------\n\t    loop: :class:`asyncio.AbstractEventLoop`\n", "        The asyncio event loop the client uses.\n\t    http: :class:`~.http.HTTPClient`\n\t        The HTTP client utilized by this client that interacts with Adapt HTTP requests.\n\t    ws: :class:`~.ws.WebSocket`\n\t        The websocket client utilized by this client that interacts with Adapt websocket events.\n\t    Parameters\n\t    ----------\n\t    loop: :class:`asyncio.AbstractEventLoop`\n\t        The event loop the client should use. Defaults to what is returned by calling :func:`asyncio.get_event_loop`.\n\t    session: :class:`aiohttp.ClientSession`\n", "        The aiohttp client session to use for the created HTTP client. If not provided, one is created for you.\n\t    server: :class:`.AdaptServer`\n\t        The urls of the backend server. Defaults to the production server found at `adapt.chat`.\n\t    token: :class:`str`\n\t        The token to run the client with. Leave blank to delay specification of the token.\n\t    status: :class:`.Status`\n\t        The status to set the client to when it connects to harmony. Defaults to :attr:`.Status.online`.\n\t    \"\"\"\n\t    if TYPE_CHECKING:\n\t        ws: WebSocket | None\n", "        _connection: Connection\n\t    def __init__(\n\t        self,\n\t        *,\n\t        loop: asyncio.AbstractEventLoop | None = None,\n\t        session: aiohttp.ClientSession | None = None,\n\t        server: AdaptServer = AdaptServer.production(),\n\t        token: str | None = None,\n\t        status: Status = Status.online,\n\t    ) -> None:\n", "        self._server = server\n\t        self.loop = loop or asyncio.get_event_loop()\n\t        self.http = HTTPClient(loop=self.loop, session=session, server_url=server.api, token=token)\n\t        self._prepare_client(status=status)\n\t        super().__init__()\n\t    def _prepare_client(self, **options: Any) -> None:\n\t        self.ws = None\n\t        self._connection = Connection(\n\t            http=self.http,\n\t            server=self._server,\n", "            loop=self.loop,\n\t            dispatch=self.dispatch,\n\t            **options,\n\t        )\n\t    @property\n\t    def server(self) -> AdaptServer:\n\t        \"\"\"The server the client retrieves all Adapt URLs from.\"\"\"\n\t        return self._server\n\t    @server.setter\n\t    def server(self, value: AdaptServer) -> None:\n", "        self._server = value\n\t        self.http.server_url = value.api\n\t        if self.ws is not None:\n\t            self.ws.ws_url = value.harmony\n\t    @property\n\t    def connection(self) -> Connection:\n\t        \"\"\":class:`~.connection.Connection`: The connection object that manages the connection to Adapt and cached models.\"\"\"\n\t        return self._connection\n\t    @property\n\t    def latency(self) -> float | None:\n", "        \"\"\":class:`float`: The amount of time in seconds it took for the previous heartbeat to harmony (the websocket)\n\t        to be acknowledged.\n\t        This is ``None`` if:\n\t        - The client is not logged in.\n\t        - The client has not yet sent a heartbeat to harmony.\n\t        - The client has not yet received a heartbeat acknowledgement from harmony.\n\t        \"\"\"\n\t        return self.ws and self.ws.latency\n\t    @property\n\t    def latency_ns(self) -> int | None:\n", "        \"\"\":class:`int`: The equivalent of :attr:`.latency` but in nanoseconds. This could yield more accurate\n\t        measurements due to floating point precision errors in :attr:`.latency`.\n\t        See Also\n\t        --------\n\t        :attr:`.latency`\n\t            The equivalent of this property in seconds. See this for more information.\n\t        \"\"\"\n\t        return self.ws and self.ws.latency_ns\n\t    @property\n\t    def user(self) -> ClientUser | None:\n", "        \"\"\":class:`.ClientUser` | None: The user object that represents the user account the client is logged into.\n\t        This is ``None`` if the client is not logged in.\n\t        \"\"\"\n\t        return self._connection.user\n\t    @property\n\t    def users(self) -> ValuesView[User]:\n\t        \"\"\"Iterable[:class:`.User`]: An iterable of users that the client has cached.\"\"\"\n\t        return self._connection._users.values()\n\t    @property\n\t    def guilds(self) -> ValuesView[Guild]:\n", "        \"\"\"Iterable[:class:`.Guild`]: An iterable of guilds that the client has cached.\"\"\"\n\t        return self._connection._guilds.values()\n\t    @property\n\t    def relationships(self) -> ValuesView[Relationship]:\n\t        \"\"\"Iterable[:class:`.Relationship`]: An iterable of relationships that the client has cached.\"\"\"\n\t        return self._connection._relationships.values()\n\t    @property\n\t    def is_ready(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the client has received the ready event from harmony yet.\"\"\"\n\t        return self._connection._is_ready.done()\n", "    async def wait_until_ready(self) -> ReadyEvent:\n\t        \"\"\"|coro|\n\t        Blocks the event loop until the client receives the ready event from harmony.\n\t        Returns\n\t        -------\n\t        :class:`.ReadyEvent`\n\t            The ready event that was dispatched.\n\t        \"\"\"\n\t        return await self._connection._is_ready\n\t    def get_user(self, user_id: int) -> User | None:\n", "        \"\"\"Retrieves a user from the cache.\n\t        Parameters\n\t        ----------\n\t        user_id: :class:`int`\n\t            The user ID to retrieve.\n\t        Returns\n\t        -------\n\t        :class:`.User` | None\n\t            The user object that was retrieved, or ``None`` if no user was found.\n\t        \"\"\"\n", "        return self._connection.get_user(user_id)\n\t    def get_partial_user(self, user_id: int) -> PartialUser:\n\t        \"\"\"Creates a usable partial user object that operates with only its ID.\n\t        This is useful for when you want to perform actions on a user without having to ensure they are cached\n\t        or fetch unnecessary user data.\n\t        Parameters\n\t        ----------\n\t        user_id: :class:`int`\n\t            The user ID to create the partial user with.\n\t        Returns\n", "        -------\n\t        :class:`.PartialUser`\n\t            The partial user object that was created.\n\t        \"\"\"\n\t        return PartialUser(connection=self._connection, id=user_id)\n\t    async def fetch_user(self, user_id: int, *, respect_cache: bool = False) -> User:\n\t        \"\"\"|coro|\n\t        Fetches a user directly from the API.\n\t        Parameters\n\t        ----------\n", "        user_id: :class:`int`\n\t            The user ID to fetch.\n\t        respect_cache: :class:`bool`\n\t            If ``True``, if the user is found in the cache, it will be returned instead of fetching from the API.\n\t        Returns\n\t        -------\n\t        :class:`.User` | None\n\t            The user object that was fetched, or ``None`` if no user was found.\n\t        \"\"\"\n\t        if cached := respect_cache and self.get_user(user_id):\n", "            return cached\n\t        return self._connection.add_raw_user(await self.http.get_user(user_id))\n\t    def get_relationship(self, user_id: int) -> Relationship | None:\n\t        \"\"\"Retrieves the relationship between the client and the user with the given ID from the cache.\n\t        Parameters\n\t        ----------\n\t        user_id: :class:`int`\n\t            The user ID to retrieve.\n\t        Returns\n\t        -------\n", "        :class:`.Relationship`\n\t            The relationship object that was retrieved, or ``None`` if no relationship was found.\n\t        \"\"\"\n\t        return self._connection.get_relationship(user_id)\n\t    async def fetch_relationships(self) -> Iterable[Relationship]:\n\t        \"\"\"|coro|\n\t        Fetches all relationships between the client and other users directly from the API.\n\t        Returns\n\t        -------\n\t        Iterable[:class:`.Relationship`]\n", "            An iterable of relationship objects that were fetched. This is a generator that lazily resolves the\n\t            relationships into :class:`.Relationship` objects.\n\t        \"\"\"\n\t        relationships = await self.http.get_relationships()\n\t        return map(self._connection.update_raw_relationship, relationships)\n\t    def get_guild(self, guild_id: int) -> Guild | None:\n\t        \"\"\"Retrieves a guild from the cache.\n\t        Parameters\n\t        ----------\n\t        guild_id: :class:`int`\n", "            The guild ID to retrieve.\n\t        Returns\n\t        -------\n\t        :class:`.Guild` | None\n\t            The guild object that was retrieved, or ``None`` if no guild was found.\n\t        \"\"\"\n\t        return self._connection.get_guild(guild_id)\n\t    def get_partial_guild(self, guild_id: int) -> PartialGuild:\n\t        \"\"\"Creates a usable partial guild object that operates with only its ID.\n\t        This is useful for when you want to perform actions on a guild without having to ensure it is cached\n", "        or fetch unnecessary guild data.\n\t        Parameters\n\t        ----------\n\t        guild_id: :class:`int`\n\t            The guild ID to create the partial guild with.\n\t        Returns\n\t        -------\n\t        :class:`.PartialGuild`\n\t            The partial guild object that was created.\n\t        \"\"\"\n", "        return PartialGuild(connection=self._connection, id=guild_id)\n\t    async def fetch_guild(\n\t        self,\n\t        guild_id: int,\n\t        *,\n\t        respect_cache: bool = False,\n\t        channels: bool = False,\n\t        members: bool = False,\n\t        roles: bool = False,\n\t    ) -> Guild:\n", "        \"\"\"|coro|\n\t        Fetches a guild directly from the API.\n\t        Parameters\n\t        ----------\n\t        guild_id: :class:`int`\n\t            The guild ID to fetch.\n\t        respect_cache: :class:`bool`\n\t            If ``True``, if the guild is found in the cache, it will be returned instead of fetching from the API.\n\t            This will also mean the ``members``, ``roles``, and ``channels`` parameters will be ignored.\n\t        channels: :class:`bool`\n", "            If ``True``, the guild's channels will be fetched.\n\t        members: :class:`bool`\n\t            If ``True``, the guild's members will be fetched.\n\t        roles: :class:`bool`\n\t            If ``True``, the guild's roles will be fetched.\n\t        Returns\n\t        -------\n\t        :class:`.Guild`\n\t            The guild object that was fetched.\n\t        \"\"\"\n", "        if cached := respect_cache and self.get_guild(guild_id):\n\t            return cached\n\t        return self._connection.add_raw_guild(\n\t            await self.http.get_guild(guild_id, channels=channels, members=members, roles=roles),\n\t        )\n\t    async def fetch_guilds(\n\t        self, *, channels: bool = False, members: bool = False, roles: bool = False,\n\t    ) -> Iterable[Guild]:\n\t        \"\"\"|coro|\n\t        Fetches all guilds that the client is a member of.\n", "        .. warning::\n\t            This is an expensive process and has high ratelimits, so it should be used sparingly.\n\t            Guild data is returned by the ready event, so it is usually unnecessary to call this method.\n\t        Parameters\n\t        ----------\n\t        channels: :class:`bool`\n\t            If ``True``, channel data will be fetched for each guild.\n\t        members: :class:`bool`\n\t            If ``True``, member data will be fetched for each guild.\n\t        roles: :class:`bool`\n", "            If ``True``, role data will be fetched for each guild.\n\t        Returns\n\t        -------\n\t        Iterable[:class:`.Guild`]\n\t            An iterable of guild objects that were fetched. This is a generator that lazily resolves the\n\t            guilds into :class:`.Guild` objects.\n\t        \"\"\"\n\t        guilds = await self.http.get_guilds(channels=channels, members=members, roles=roles)\n\t        return map(self._connection.add_raw_guild, guilds)\n\t    async def create_guild(\n", "        self,\n\t        *,\n\t        name: str,\n\t        description: str | None = None,\n\t        icon: IOSource | None = None,\n\t        banner: IOSource | None = None,\n\t        public: bool = False,\n\t        nonce: str | None = None,\n\t    ) -> Guild:\n\t        \"\"\"|coro|\n", "        Creates a new guild.\n\t        Parameters\n\t        ----------\n\t        name: :class:`str`\n\t            The name of the guild.\n\t        description: :class:`str`\n\t            The description of the guild. This is optional.\n\t        icon: :class:`bytes`, path-like object, file-like object, or ``None``\n\t            The icon of the guild. This is optional.\n\t        banner: :class:`bytes`, path-like object, file-like object, or ``None``\n", "            The banner of the guild. This is optional.\n\t        public: :class:`bool`\n\t            Whether the guild should be public. Defaults to ``False``.\n\t        nonce: :class:`str`\n\t            An optional nonce for integrity. When the guild creation event is received through the websocket, the nonce\n\t            will be included in the payload. This can be used to verify that the guild was created successfully.\n\t        Returns\n\t        -------\n\t        :class:`.Guild`\n\t            The guild that was created.\n", "        \"\"\"\n\t        data = await self.http.create_guild(\n\t            name=name,\n\t            description=description,\n\t            icon=icon,\n\t            banner=banner,\n\t            public=public,\n\t            nonce=nonce,\n\t        )\n\t        return self._connection.add_raw_guild(data)\n", "    async def update_presence(self, *, status: Status = MISSING) -> None:\n\t        \"\"\"|coro|\n\t        Updates the client's presence.\n\t        Parameters\n\t        ----------\n\t        status: :class:`.Status`\n\t            The new status to update the client's presence with. Leave blank to keep the current status.\n\t        \"\"\"\n\t        await self.ws.update_presence(status=status)\n\t    @classmethod\n", "    def from_http(cls, http: HTTPClient, *, server: AdaptServer | None = None, **kwargs: Any) -> Self:\n\t        \"\"\"Creates a client from an HTTP client. This is used internally.\n\t        Parameters\n\t        ----------\n\t        http: :class:`~.http.HTTPClient`\n\t            The HTTP client to create the client object with.\n\t        server: :class:`.AdaptServer`\n\t            The urls of the backend server. Defaults to the production server found at `adapt.chat`.\n\t        **kwargs\n\t            Additional keyword arguments to pass into the client constructor.\n", "        Returns\n\t        -------\n\t        :class:`~.Client`\n\t            The created client object.\n\t        \"\"\"\n\t        self = cls.__new__(cls)\n\t        self.loop = http.loop\n\t        self.http = http\n\t        self._server = server or AdaptServer.production().copy_with(api=http.server_url)\n\t        self._prepare_client(**kwargs)\n", "        super(Client, self).__init__()\n\t        return self\n\t    @classmethod\n\t    def from_login(\n\t        cls,\n\t        *,\n\t        email: str,\n\t        password: str,\n\t        method: TokenRetrievalMethod = 'reuse',\n\t        server: AdaptServer = AdaptServer.production(),\n", "        **options: Any,\n\t    ) -> _CoroutineWrapper[Self]:\n\t        \"\"\"|coro|\n\t        Logs in with the specified credentials, then returns a client to interact with that account.\n\t        When using this in a context manager, ``async with await`` is unnecessary ::\n\t            # Recommended:\n\t            async with Client.from_login(...) as client:\n\t                await client.start(TOKEN)\n\t            # Unnecessary:\n\t            async with await Client.from_login(...) as client:\n", "                await client.start(TOKEN)\n\t        Otherwise, this should be treated as a coroutine: ::\n\t            client = await Client.from_login(...)\n\t            client.run(TOKEN)\n\t        Parameters\n\t        ----------\n\t        email: :class:`str`\n\t            The email of the account.\n\t        password: :class:`str`\n\t            The password of the account.\n", "        method: Literal['new', 'revoke', 'reuse']\n\t            The method to use to retrieve the token. Defaults to `'reuse'`.\n\t        server: :class:`.AdaptServer`\n\t            The urls of the backend server. Defaults to the production server found at `adapt.chat`.\n\t        **options\n\t            Additional keyword-arguments to pass in when constructing the HTTP client\n\t            (i.e. `loop`, `session`)\n\t        Returns\n\t        -------\n\t        :class:`~.Client`\n", "            The created client object.\n\t        \"\"\"\n\t        async def coro() -> Self:\n\t            http = HTTPClient(**options, server_url=server.api)\n\t            await http.login(email=email, password=password, method=method)\n\t            return cls.from_http(http, server=server)\n\t        return _CoroutineWrapper(coro())\n\t    @classmethod\n\t    def create_user(\n\t        cls,\n", "        *,\n\t        username: str,\n\t        email: str,\n\t        password: str,\n\t        server: AdaptServer = AdaptServer.production(),\n\t        **options: Any,\n\t    ) -> _CoroutineWrapper[Self]:\n\t        \"\"\"|coro|\n\t        Registers a new user account, and returns a new client created to interact with that account.\n\t        When using this in a context manager, ``async with await`` is unnecessary ::\n", "            # Recommended:\n\t            async with Client.create_user(...) as client:\n\t                await client.start(TOKEN)\n\t            # Unnecessary:\n\t            async with await Client.create_user(...) as client:\n\t                await client.start(TOKEN)\n\t        Otherwise, this should be treated as a coroutine: ::\n\t            client = await Client.create_user(...)\n\t            client.run(TOKEN)\n\t        Parameters\n", "        ----------\n\t        username: :class:`str`\n\t            The username of the new account.\n\t        email: :class:`str`\n\t            The email of the new account.\n\t        password: :class:`str`\n\t            The password of the new account.\n\t        server: :class:`.AdaptServer`\n\t            The urls of the backend server. Defaults to the production server found at `adapt.chat`.\n\t        **options\n", "            Additional keyword-arguments to pass in when constructing the HTTP client\n\t            (i.e. `loop`, `session`)\n\t        Returns\n\t        -------\n\t        :class:`~.Client`\n\t            The created client object.\n\t        \"\"\"\n\t        async def coro() -> Self:\n\t            http = HTTPClient(**options, server_url=server.api)\n\t            await http.create_user(username=username, email=email, password=password)\n", "            return cls.from_http(http, server=server)\n\t        return _CoroutineWrapper(coro())\n\t    async def start(self, token: str | None = None) -> None:\n\t        \"\"\"|coro|\n\t        Starts the client, logging in with the provided token and connecting to harmony.\n\t        Parameters\n\t        ----------\n\t        token: :class:`str`\n\t            The token to log in with. If not provided, the token specified in the constructor is used.\n\t        \"\"\"\n", "        self.http.token = token or self.http.token\n\t        if not self.http.token:\n\t            raise ValueError('No token provided to start the client with')\n\t        self.dispatch('start')\n\t        self.ws = WebSocket(self.connection, ws_url=self.server.harmony)\n\t        await self.ws.start()\n\t    def run(self, token: str | None = None) -> None:\n\t        \"\"\"Runs the client, logging in with the provided token and connecting to harmony. This is a blocking call.\n\t        Parameters\n\t        ----------\n", "        token: :class:`str`\n\t            The token to log in with. If not provided, the token specified in the constructor is used.\n\t        \"\"\"\n\t        async def runner() -> None:\n\t            async with self:\n\t                await self.start(token)\n\t        try:\n\t            self.loop.run_until_complete(runner())\n\t        except KeyboardInterrupt:\n\t            pass\n", "    async def close(self) -> None:\n\t        \"\"\"|coro|\n\t        Closes the client, freeing up resources the client might have used.\n\t        This is automatically called if you use :meth:`~.Client.run`.\n\t        \"\"\"\n\t        await self.http.close()\n\t        if self.ws is not None:\n\t            await self.ws.close()\n\t    async def __aenter__(self) -> Self:\n\t        return self\n", "    async def __aexit__(self, *_: Any) -> None:\n\t        await self.close()\n\tdef once(func: EventListener[P, R]) -> EventListener[P, R]:\n\t    \"\"\"A decorator that registers an event listener to be called only once before being destroyed.\n\t    This can be used within the client class.\n\t    Usage: ::\n\t        from adapt import Client, ReadyEvent, once\n\t        class MyClient(Client):\n\t            @once\n\t            async def on_ready(self, _event: ReadyEvent):\n", "                print('Ready!')\n\t    Parameters\n\t    ----------\n\t    func: (*P.args, **P.kwargs) -> Any\n\t        The event listener.\n\t    Returns\n\t    -------\n\t    (*P.args, **P.kwargs) -> Any\n\t        The event listener that will be called only once.\n\t    \"\"\"\n", "    func.__adapt_call_once__ = True\n\t    return func\n"]}
{"filename": "adapt/polyfill.py", "chunked_list": ["from sys import version_info\n\tif version_info < (3, 9):\n\t    def removeprefix(self: str, prefix: str, /) -> str:\n\t        if self.startswith(prefix):\n\t            return self[len(prefix):]\n\t        return self\n\t    def removesuffix(self: str, suffix: str, /) -> str:\n\t        if self.endswith(suffix):\n\t            return self[:-len(suffix)]\n\t        return self\n", "else:\n\t    removeprefix = str.removeprefix\n\t    removesuffix = str.removesuffix\n"]}
{"filename": "adapt/__init__.py", "chunked_list": ["__title__ = 'adapt'\n\t__author__ = 'jay3332'\n\t__license__ = 'MIT'\n\t__copyright__ = 'Copyright 2023-present jay3332'\n\t__version__ = '0.1.0-alpha'\n\tfrom . import client, http, models, util\n\tfrom .client import Client, once\n\tfrom .models import *\n\tfrom .server import AdaptServer\n"]}
{"filename": "adapt/util.py", "chunked_list": ["from __future__ import annotations\n\timport warnings\n\tfrom base64 import b64encode, urlsafe_b64decode\n\tfrom datetime import datetime\n\tfrom functools import wraps\n\tfrom inspect import isawaitable\n\tfrom io import BufferedIOBase\n\tfrom os import getenv\n\tfrom typing import (\n\t    Any,\n", "    Awaitable,\n\t    Callable,\n\t    Final,\n\t    ParamSpec,\n\t    TypeVar,\n\t    TYPE_CHECKING,\n\t)\n\tfrom .models.enums import ModelType\n\tif TYPE_CHECKING:\n\t    from os import PathLike\n", "    from typing import Iterable, Literal, TypeAlias\n\t    IOSource: TypeAlias = str | bytes | PathLike[Any] | BufferedIOBase\n\t    IS_DOCUMENTING: Literal[False] = False\n\telse:\n\t    IS_DOCUMENTING: bool = getenv('READTHEDOCS', False)\n\t__all__ = (\n\t    'ADAPT_EPOCH_MILLIS',\n\t    'Ratelimiter',\n\t    'maybe_coro',\n\t    'extract_user_id_from_token',\n", "    'snowflake_model_type',\n\t    'snowflake_time',\n\t    'find',\n\t)\n\tT = TypeVar('T')\n\tP = ParamSpec('P')\n\tR = TypeVar('R')\n\tADAPT_EPOCH_MILLIS: Final[int] = 1_671_926_400_000\n\tclass _Missing:\n\t    __slots__ = ()\n", "    def __eq__(self, other: Any) -> bool:\n\t        return False\n\t    def __bool__(self) -> bool:\n\t        return False\n\t    def __hash__(self) -> int:\n\t        return 0\n\t    def __repr__(self) -> str:\n\t        return '...'\n\tMISSING: Any = _Missing()\n\t# FIXME: Replace when Ratelimiter exists\n", "class Ratelimiter:\n\t    ...\n\tasync def maybe_coro(func: Callable[P, Awaitable[R] | R], /, *args: P.args, **kwargs: P.kwargs) -> R:\n\t    res = func(*args, **kwargs)\n\t    if isawaitable(res):\n\t        return await res\n\t    return res  # type: ignore\n\tdef _get_mimetype(data: bytes) -> str:\n\t    if data.startswith(b'\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A'):\n\t        return 'image/png'\n", "    elif data[0:3] == b'\\xff\\xd8\\xff' or data[6:10] in (b'JFIF', b'Exif'):\n\t        return 'image/jpeg'\n\t    elif data.startswith((b'\\x47\\x49\\x46\\x38\\x37\\x61', b'\\x47\\x49\\x46\\x38\\x39\\x61')):\n\t        return 'image/gif'\n\t    elif data.startswith(b'RIFF') and data[8:12] == b'WEBP':\n\t        return 'image/webp'\n\t    raise ValueError('unsupported image format')\n\tdef _bytes_to_image_data(data: bytes, /) -> str:\n\t    mimetype = _get_mimetype(data)\n\t    result = b64encode(data).decode('ascii')\n", "    return f'data:{mimetype};base64,{result}'\n\tdef resolve_image(src: IOSource, /) -> str:\n\t    if isinstance(src, bytes):\n\t        data = src\n\t    elif isinstance(src, BufferedIOBase):\n\t        data = src.read()\n\t    else:\n\t        with open(src, 'rb') as f:\n\t            data = f.read()\n\t    return _bytes_to_image_data(data)\n", "def deprecated(\n\t    *,\n\t    since: str = MISSING,\n\t    removed_in: str = MISSING,\n\t    use: str,\n\t    reason: str = MISSING,\n\t) -> Callable[[Callable[P, T]], Callable[P, T]]:\n\t    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n\t        @wraps(func)\n\t        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n", "            warnings.simplefilter('always', DeprecationWarning)\n\t            fmt = (\n\t                '{0.__qualname__} is deprecated'\n\t                if since is MISSING\n\t                else '{0.__qualname__} was deprecated since v{since}'\n\t            )\n\t            if removed_in is not MISSING:\n\t                fmt += ' and will be removed in v{removed_in}'\n\t            fmt += '. Use {use} instead.'\n\t            if reason is not MISSING:\n", "                fmt += ' {reason}'\n\t            message = fmt.format(func, since=since, removed_in=removed_in, use=use, reason=reason)\n\t            warnings.warn(message, DeprecationWarning, stacklevel=3)\n\t            return func(*args, **kwargs)\n\t        return wrapper\n\t    return decorator\n\tdef parse_datetime(iso: str, /) -> datetime:\n\t    # fromisoformat does not support the Z timezone with fractional seconds\n\t    return datetime.fromisoformat(iso.replace('Z', '+00:00'))\n\tdef extract_user_id_from_token(token: str, /) -> int:\n", "    \"\"\"Extracts the user ID associated with the given authentication token.\n\t    Parameters\n\t    ----------\n\t    token: :class:`str`\n\t        The token to parse.\n\t    Returns\n\t    -------\n\t    :class:`int`\n\t        The snowflake ID of the associated user.\n\t    Raises\n", "    ------\n\t    ValueError\n\t        Received a malformed token.\n\t    \"\"\"\n\t    return int(urlsafe_b64decode(token.split('.', maxsplit=1)[0]))\n\tdef snowflake_time(snowflake: int, /) -> datetime:\n\t    \"\"\"Converts an Adapt snowflake to a datetime object.\n\t    Parameters\n\t    ----------\n\t    snowflake: :class:`int`\n", "        The snowflake to convert.\n\t    Returns\n\t    -------\n\t    :class:`datetime.datetime`\n\t        The datetime object representing the snowflake's creation time.\n\t    \"\"\"\n\t    return datetime.utcfromtimestamp(((snowflake >> 18) + ADAPT_EPOCH_MILLIS) / 1000)\n\tdef snowflake_model_type(snowflake: int, /) -> ModelType:\n\t    \"\"\"Extracts the model type of the given Adapt snowflake.\n\t    Parameters\n", "    ----------\n\t    snowflake: :class:`int`\n\t        The snowflake to extract the model type from.\n\t    Returns\n\t    -------\n\t    :class:`ModelType`\n\t        The model type associated with the snowflake.\n\t    \"\"\"\n\t    return ModelType((snowflake >> 13) & 0b11111)\n\tdef find(iterable: Iterable[T], predicate: Callable[[T], bool]) -> T | None:\n", "    \"\"\"Finds the first element in an iterable that satisfies the given predicate.\n\t    Parameters\n\t    ----------\n\t    iterable: Iterable[T]\n\t        The iterable to search through.\n\t    predicate: (item: T) -> :class:`bool`\n\t        The predicate to use to find the element.\n\t    Returns\n\t    -------\n\t    T | None\n", "        The first element that satisfies the predicate, or ``None`` if no such element is found.\n\t    \"\"\"\n\t    for item in iterable:\n\t        if predicate(item):\n\t            return item\n\t    return None\n"]}
{"filename": "adapt/http.py", "chunked_list": ["from __future__ import annotations\n\timport aiohttp\n\timport asyncio\n\tfrom typing import Literal, TYPE_CHECKING\n\tfrom .polyfill import removeprefix, removesuffix\n\tfrom .server import AdaptServer\n\tfrom .util import extract_user_id_from_token, resolve_image, MISSING\n\tif TYPE_CHECKING:\n\t    from typing import Any, Final, TypeAlias, Self\n\t    from .types.channel import (\n", "        Channel,\n\t        DMChannel,\n\t        GuildChannel,\n\t        GuildChannelType,\n\t        CreateGuildChannelPayload,\n\t        CreateDMChannelPayload,\n\t    )\n\t    from .types.guild import (\n\t        Guild,\n\t        PartialGuild,\n", "        CreateGuildPayload,\n\t        EditGuildPayload,\n\t        DeleteGuildPayload,\n\t        Member,\n\t        EditMemberPayload,\n\t    )\n\t    from .types.message import (\n\t        Message,\n\t        CreateMessagePayload,\n\t        EditMessagePayload,\n", "        MessageHistoryQuery,\n\t    )\n\t    from .types.user import (\n\t        CreateUserPayload,\n\t        CreateUserResponse,\n\t        EditUserPayload,\n\t        SendFriendRequestPayload,\n\t        LoginRequest,\n\t        LoginResponse,\n\t        TokenRetrievalMethod,\n", "        ClientUser,\n\t        User,\n\t        Relationship,\n\t    )\n\t    from .util import IOSource\n\tDEFAULT_API_URL: Final[str] = AdaptServer.production().api\n\tRequestMethod: TypeAlias = Literal['GET', 'POST', 'PATCH', 'PUT', 'DELETE']\n\tclass HTTPClient:\n\t    \"\"\"Represents an HTTP client that makes requests to Adapt over HTTP.\"\"\"\n\t    __slots__ = ('loop', 'session', 'client_id', 'server_url', '_token')\n", "    def __init__(\n\t        self,\n\t        *,\n\t        loop: asyncio.AbstractEventLoop | None = None,\n\t        session: aiohttp.ClientSession | None = None,\n\t        server_url: str = DEFAULT_API_URL,\n\t        token: str | None = None,\n\t        **kwargs,\n\t    ) -> None:\n\t        self.loop = loop or asyncio.get_event_loop()\n", "        self.session = session or aiohttp.ClientSession(**kwargs, loop=self.loop)\n\t        self.client_id: int | None = extract_user_id_from_token(token) if token is not None else None\n\t        self.server_url: str = removesuffix(server_url, '/')\n\t        self._token: str | None = token\n\t    @property\n\t    def token(self) -> str | None:\n\t        \"\"\"The token used to authenticate requests.\"\"\"\n\t        return self._token\n\t    @token.setter\n\t    def token(self, value: str | None) -> None:\n", "        self._token = value\n\t        self.client_id = extract_user_id_from_token(value) if value is not None else None\n\t    @token.deleter\n\t    def token(self) -> None:\n\t        self._token = None\n\t        self.client_id = None\n\t    async def request(\n\t        self,\n\t        method: RequestMethod,\n\t        endpoint: str,\n", "        *,\n\t        headers: dict[str, Any] | None = None,\n\t        params: dict[str, Any] | None = None,\n\t        json: Any = None,\n\t    ) -> Any:\n\t        headers = headers or {}\n\t        if self.token is not None:\n\t            headers['Authorization'] = self.token\n\t        if json is not None:\n\t            headers['Content-Type'] = 'application/json'\n", "        endpoint = '/' + removeprefix(endpoint, '/')\n\t        async with self.session.request(\n\t            method,\n\t            self.server_url + endpoint,\n\t            headers=headers,\n\t            params=params,\n\t            json=json,\n\t        ) as response:\n\t            # TODO: Proper ratelimit handling and error handling\n\t            response.raise_for_status()\n", "            return await response.json()\n\t    # Auth\n\t    async def login(self, *, email: str, password: str, method: TokenRetrievalMethod = 'reuse') -> LoginResponse:\n\t        payload: LoginRequest = {\n\t            'email': email,\n\t            'password': password,\n\t            'method': method,\n\t        }\n\t        response: LoginResponse = await self.request('POST', '/login', json=payload)\n\t        self.client_id = response['user_id']\n", "        self.token = response['token']\n\t        return response\n\t    # Users\n\t    async def create_user(self, *, username: str, email: str, password: str) -> CreateUserResponse:\n\t        payload: CreateUserPayload = {\n\t            'username': username,\n\t            'email': email,\n\t            'password': password,\n\t        }\n\t        response: CreateUserResponse = await self.request('POST', '/users', json=payload)\n", "        self.client_id = response['id']\n\t        self.token = response['token']\n\t        return response\n\t    async def get_user(self, user_id: int) -> User:\n\t        return await self.request('GET', f'/users/{user_id}')\n\t    async def get_authenticated_user(self) -> ClientUser:\n\t        return await self.request('GET', '/users/me')\n\t    async def edit_authenticated_user(\n\t        self,\n\t        *,\n", "        username: str = MISSING,\n\t        avatar: IOSource | None = MISSING,\n\t        banner: IOSource | None = MISSING,\n\t        bio: str | None = MISSING,\n\t    ) -> ClientUser:\n\t        payload: EditUserPayload = {'username': username}\n\t        if avatar is not MISSING:\n\t            payload['avatar'] = resolve_image(avatar)\n\t        if banner is not MISSING:\n\t            payload['banner'] = resolve_image(banner)\n", "        if bio is not MISSING:\n\t            payload['bio'] = bio\n\t        return await self.request('PATCH', '/users/me', json=payload)\n\t    async def delete_authenticated_user(self, *, password: str) -> None:\n\t        await self.request('DELETE', '/users/me', json={'password': password})\n\t    async def get_relationships(self) -> list[Relationship]:\n\t        return await self.request('GET', '/relationships')\n\t    async def send_friend_request(self, *, username: str, discriminator: int) -> Relationship:\n\t        payload: SendFriendRequestPayload = {\n\t            'username': username,\n", "            'discriminator': discriminator,\n\t        }\n\t        return await self.request('POST', '/relationships/friends', json=payload)\n\t    async def accept_friend_request(self, user_id: int) -> Relationship:\n\t        return await self.request('PUT', f'/relationships/friends/{user_id}')\n\t    async def block_user(self, user_id: int) -> Relationship:\n\t        return await self.request('PUT', f'/relationships/blocks/{user_id}')\n\t    async def delete_relationship(self, user_id: int) -> None:\n\t        await self.request('DELETE', f'/relationships/{user_id}')\n\t    # Channels\n", "    async def get_channel(self, channel_id: int) -> Channel:\n\t        return await self.request('GET', f'/channels/{channel_id}')\n\t    # TODO async def edit_channel\n\t    async def delete_channel(self, channel_id: int) -> None:\n\t        await self.request('DELETE', f'/channels/{channel_id}')\n\t    async def get_guild_channels(self, guild_id: int) -> list[GuildChannel]:\n\t        return await self.request('GET', f'/guilds/{guild_id}/channels')\n\t    # TODO async def create_guild_channel\n\t    async def get_dm_channels(self) -> list[DMChannel]:\n\t        return await self.request('GET', '/users/me/channels')\n", "    async def create_user_dm_channel(self, recipient_id: int) -> DMChannel:\n\t        payload: CreateDMChannelPayload = {\n\t            'type': 'dm',\n\t            'recipient_id': recipient_id,\n\t        }\n\t        return await self.request('POST', '/users/me/channels', json=payload)\n\t    async def create_group_dm_channel(self, *, name: str, recipient_ids: list[int]) -> DMChannel:\n\t        payload: CreateDMChannelPayload = {\n\t            'type': 'group',\n\t            'name': name,\n", "            'recipient_ids': recipient_ids,\n\t        }\n\t        return await self.request('POST', '/users/me/channels', json=payload)\n\t    # Messages\n\t    async def get_message_history(\n\t        self,\n\t        channel_id: int,\n\t        *,\n\t        before: int | None = None,\n\t        after: int | None = None,\n", "        limit: int = 100,\n\t        user_id: int | None = None,\n\t        oldest_first: bool = False,\n\t    ) -> list[Message]:\n\t        params: MessageHistoryQuery = {'oldest_first': oldest_first}\n\t        if before is not None:\n\t            params['before'] = before\n\t        if after is not None:\n\t            params['after'] = after\n\t        if limit is not None:\n", "            params['limit'] = limit\n\t        if user_id is not None:\n\t            params['user_id'] = user_id\n\t        return await self.request('GET', f'/channels/{channel_id}/messages', params=params)\n\t    async def get_message(self, channel_id: int, message_id: int) -> Message:\n\t        return await self.request('GET', f'/channels/{channel_id}/messages/{message_id}')\n\t    async def create_message(\n\t        self,\n\t        channel_id: int,\n\t        *,\n", "        content: str | None = None,\n\t        nonce: str | None = None,\n\t    ) -> Message:\n\t        payload: CreateMessagePayload = {\n\t            'content': content,\n\t            'nonce': nonce,\n\t        }\n\t        return await self.request('POST', f'/channels/{channel_id}/messages', json=payload)\n\t    async def edit_message(\n\t        self,\n", "        channel_id: int,\n\t        message_id: int,\n\t        *,\n\t        content: str | None = MISSING,\n\t    ) -> Message:\n\t        payload: EditMessagePayload = {}\n\t        if content is not MISSING:\n\t            payload['content'] = content\n\t        return await self.request('PATCH', f'/channels/{channel_id}/messages/{message_id}', json=payload)\n\t    async def delete_message(self, channel_id: int, message_id: int) -> None:\n", "        await self.request('DELETE', f'/channels/{channel_id}/messages/{message_id}')\n\t    # Guilds\n\t    async def get_guilds(self, *, channels: bool = False, members: bool = False, roles: bool = False) -> list[Guild]:\n\t        return await self.request('GET', '/guilds', params={'channels': channels, 'members': members, 'roles': roles})\n\t    async def get_guild(\n\t        self,\n\t        guild_id: int,\n\t        *,\n\t        channels: bool = False,\n\t        members: bool = False,\n", "        roles: bool = False,\n\t    ) -> Guild:\n\t        return await self.request(\n\t            'GET',\n\t            f'/guilds/{guild_id}',\n\t            params={'channels': channels, 'members': members, 'roles': roles},\n\t        )\n\t    async def create_guild(\n\t        self,\n\t        *,\n", "        name: str,\n\t        description: str | None = None,\n\t        icon: IOSource | None = None,\n\t        banner: IOSource | None = None,\n\t        public: bool = False,\n\t        nonce: str | None = None,\n\t    ) -> Guild:\n\t        payload: CreateGuildPayload = {\n\t            'name': name,\n\t            'description': description,\n", "            'public': public,\n\t            'nonce': nonce,\n\t        }\n\t        if icon is not None:\n\t            payload['icon'] = resolve_image(icon)\n\t        if banner is not None:\n\t            payload['banner'] = resolve_image(banner)\n\t        return await self.request('POST', '/guilds', json=payload)\n\t    async def edit_guild(\n\t        self,\n", "        guild_id: int,\n\t        *,\n\t        name: str = MISSING,\n\t        description: str | None = MISSING,\n\t        icon: IOSource | None = MISSING,\n\t        banner: IOSource | None = MISSING,\n\t        public: bool = MISSING,\n\t    ) -> PartialGuild:\n\t        payload: EditGuildPayload = {}\n\t        if name is not MISSING:\n", "            payload['name'] = name\n\t        if description is not MISSING:\n\t            payload['description'] = description\n\t        if icon is not MISSING:\n\t            payload['icon'] = resolve_image(icon)\n\t        if banner is not MISSING:\n\t            payload['banner'] = resolve_image(banner)\n\t        if public is not MISSING:\n\t            payload['public'] = public\n\t        return await self.request('PATCH', f'/guilds/{guild_id}', json=payload)\n", "    async def delete_guild(self, guild_id: int, *, password: str = MISSING) -> None:\n\t        payload: DeleteGuildPayload | None = None if password is MISSING else {'password': password}\n\t        await self.request('DELETE', f'/guilds/{guild_id}', json=payload)\n\t    # Members\n\t    async def get_members(self, guild_id: int) -> list[Member]:\n\t        return await self.request('GET', f'/guilds/{guild_id}/members')\n\t    async def get_member(self, guild_id: int, member_id: int) -> Member:\n\t        return await self.request('GET', f'/guilds/{guild_id}/members/{member_id}')\n\t    async def get_own_member(self, guild_id: int) -> Member:\n\t        return await self.request('GET', f'/guilds/{guild_id}/members/me')\n", "    async def edit_own_member(self, guild_id: int, *, nick: str | None = MISSING) -> Member:\n\t        return await self.request('PATCH', f'/guilds/{guild_id}/members/me', json={'nick': nick})\n\t    async def edit_member(\n\t        self,\n\t        guild_id: int,\n\t        member_id: int,\n\t        *,\n\t        nick: str | None = MISSING,\n\t        roles: list[int] = MISSING,\n\t    ) -> Member:\n", "        payload: EditMemberPayload = {}\n\t        if nick is not MISSING:\n\t            payload['nick'] = nick\n\t        if roles is not MISSING:\n\t            payload['roles'] = roles\n\t        return await self.request('PATCH', f'/guilds/{guild_id}/members/{member_id}', json=payload)\n\t    async def kick_member(self, guild_id: int, member_id: int) -> None:\n\t        await self.request('DELETE', f'/guilds/{guild_id}/members/{member_id}')\n\t    async def leave_guild(self, guild_id: int) -> None:\n\t        await self.request('DELETE', f'/guilds/{guild_id}/members/me')\n", "    async def close(self) -> None:\n\t        await self.session.close()\n\t    async def __aenter__(self) -> Self:\n\t        return self\n\t    async def __aexit__(self, *_: Any) -> None:\n\t        await self.close()\n"]}
{"filename": "adapt/connection.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\tfrom typing import TYPE_CHECKING\n\tfrom .models.channel import DMChannel\n\tfrom .models.enums import RelationshipType, Status\n\tfrom .models.guild import Guild\n\tfrom .models.message import Message\n\tfrom .models.ready import ReadyEvent\n\tfrom .models.user import ClientUser, Relationship, User\n\tfrom .server import AdaptServer\n", "if TYPE_CHECKING:\n\t    from typing import Any\n\t    from .http import HTTPClient\n\t    from .types.channel import DMChannel as RawDMChannel\n\t    from .types.guild import Guild as RawGuild\n\t    from .types.user import User as RawUser, Relationship as RawRelationship\n\t    from .types.ws import (\n\t        InboundMessage,\n\t        ReadyEvent as RawReadyEvent,\n\t        UserUpdateEvent,\n", "        GuildCreateEvent,\n\t        GuildUpdateEvent,\n\t        MessageCreateEvent,\n\t    )\n\t    from .websocket import Dispatcher\n\t__all__ = ('Connection',)\n\tclass Connection:\n\t    \"\"\"Represents a connection state to the Adapt API.\"\"\"\n\t    __slots__ = (\n\t        'http',\n", "        'server',\n\t        'loop',\n\t        'user',\n\t        'dispatch',\n\t        '_connect_status',\n\t        '_is_ready',\n\t        '_token',\n\t        '_max_message_count',\n\t        '_users',\n\t        '_relationships',\n", "        '_dm_channels',\n\t        '_guilds',\n\t    )\n\t    if TYPE_CHECKING:\n\t        _users: dict[int, User]\n\t        _relationships: dict[int, Relationship]\n\t        _dm_channels: dict[int, DMChannel]  # TODO DMChannel\n\t        _guilds: dict[int, Guild]\n\t    def __init__(\n\t        self,\n", "        *,\n\t        http: HTTPClient,\n\t        server: AdaptServer = AdaptServer.production(),\n\t        loop: asyncio.AbstractEventLoop | None = None,\n\t        dispatch: Dispatcher,\n\t        max_message_count: int = 1000,\n\t        status: Status = Status.online,\n\t    ) -> None:\n\t        self.http = http\n\t        self.server = server\n", "        self.loop = loop or http.loop\n\t        self.user: ClientUser | None = None\n\t        self.dispatch = dispatch\n\t        self._connect_status: Status = status\n\t        self._is_ready: asyncio.Future[ReadyEvent] = loop.create_future()\n\t        self._token: str | None = None\n\t        self._max_message_count = max_message_count\n\t        self._users = {}\n\t        self._relationships = {}\n\t        self._dm_channels = {}\n", "        self._guilds = {}\n\t    def invalidate_caches(self) -> None:\n\t        \"\"\"Clears the internal caches of the connection.\"\"\"\n\t        self._users.clear()\n\t        self._relationships.clear()\n\t        self._dm_channels.clear()\n\t        self._guilds.clear()\n\t    def get_user(self, user_id: int) -> User | None:\n\t        return self._users.get(user_id)\n\t    def add_user(self, user: User) -> User:\n", "        self._users[user.id] = user\n\t        return user\n\t    def add_raw_user(self, data: RawUser) -> User:\n\t        if user := self.get_user(data['id']):\n\t            user._update(data)\n\t            return user\n\t        return self.add_user(User(connection=self, data=data))\n\t    def get_relationship(self, user_id: int) -> Relationship | None:\n\t        return self._relationships.get(user_id)\n\t    def update_relationship(self, *, user_id: int, type: RelationshipType) -> Relationship:\n", "        if relationship := self.get_relationship(user_id):\n\t            relationship._type = type\n\t            return relationship\n\t        self._relationships[user_id] = new = Relationship(connection=self, user_id=user_id, type=type)\n\t        return new\n\t    def update_raw_relationship(self, data: RawRelationship) -> Relationship:\n\t        self.add_raw_user(user := data['user'])\n\t        return self.update_relationship(user_id=user['id'], type=RelationshipType(data['type']))\n\t    def get_guild(self, guild_id: int) -> Guild | None:\n\t        return self._guilds.get(guild_id)\n", "    def add_guild(self, guild: Guild) -> Guild:\n\t        self._guilds[guild.id] = guild\n\t        return guild\n\t    def add_raw_guild(self, data: RawGuild) -> Guild:\n\t        if guild := self.get_guild(data['id']):\n\t            guild._update(data)\n\t            return guild\n\t        return self.add_guild(Guild(connection=self, data=data))\n\t    def get_dm_channel(self, channel_id: int) -> DMChannel | None:\n\t        return self._dm_channels.get(channel_id)\n", "    def add_dm_channel(self, channel: DMChannel) -> DMChannel:\n\t        self._dm_channels[channel.id] = channel\n\t        return channel\n\t    def add_raw_dm_channel(self, data: RawDMChannel) -> DMChannel:\n\t        if channel := self.get_dm_channel(data['id']):\n\t            channel._update(data)\n\t            return channel\n\t        return self.add_dm_channel(DMChannel(connection=self, data=data))\n\t    def process_event(self, data: InboundMessage) -> None:\n\t        event: str = data['event']\n", "        data: dict[str, Any] = data.get('data')\n\t        if handler := getattr(self, '_handle_' + event, None):\n\t            handler(data)\n\t    def _handle_ready(self, data: RawReadyEvent) -> None:\n\t        ready = ReadyEvent(connection=self, data=data)\n\t        if not self._is_ready.done():\n\t            self._is_ready.set_result(ready)\n\t        self.dispatch('ready', ready)\n\t    def _handle_user_update(self, data: UserUpdateEvent) -> None:\n\t        before = User(connection=self, data=data['before'])\n", "        user = self.add_raw_user(data['after'])\n\t        self.dispatch('user_update', before, user)\n\t    def _handle_guild_create(self, data: GuildCreateEvent) -> None:\n\t        guild = self.add_raw_guild(data['guild'])\n\t        self.dispatch('guild_create', guild)  # TODO: dispatch nonce\n\t    def _handle_guild_update(self, data: GuildUpdateEvent) -> None:\n\t        before = Guild(connection=self, data=data['before'])\n\t        if guild := self._guilds.get(before.id):\n\t            guild._update(data['after'])\n\t        self.dispatch('guild_update', before, guild)\n", "    def _handle_message_create(self, data: MessageCreateEvent) -> None:\n\t        message = data['message']\n\t        if guild_id := message['author'].get('guild_id'):\n\t            guild = self.get_guild(guild_id)\n\t            channel = guild.get_channel(message['channel_id'])\n\t        else:\n\t            channel = self.get_dm_channel(message['channel_id'])\n\t        message = Message(channel=channel, data=message)\n\t        self.dispatch('message', message)  # TODO: dispatch nonce\n"]}
{"filename": "adapt/server.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import NamedTuple, TYPE_CHECKING\n\tfrom .util import IS_DOCUMENTING\n\tif TYPE_CHECKING:\n\t    from typing import Self\n\tclass AdaptServer(NamedTuple):\n\t    \"\"\"Represents connection URLs or locations of the Adapt API server.\n\t    Parameters\n\t    ----------\n\t    api: :class:`str`\n", "        The URL of the HTTP REST API. (e.g. https://api.adapt.chat)\n\t    harmony: :class:`str`\n\t        The URL of the websocket API. (e.g. wss://harmony.adapt.chat)\n\t    convey: :class:`str`\n\t        The URL of the file upload and CDN API. (e.g. https://convey.adapt.chat)\n\t    \"\"\"\n\t    api: str\n\t    harmony: str\n\t    convey: str\n\t    @classmethod\n", "    def production(cls) -> Self:\n\t        \"\"\"A :class:`AdaptServer` instance representing the production Adapt API server (`adapt.chat`).\n\t        This is the default server used by the library.\n\t        \"\"\"\n\t        return cls(\n\t            api='https://api.adapt.chat',\n\t            harmony='wss://harmony.adapt.chat',\n\t            convey='https://convey.adapt.chat',\n\t        )\n\t    @classmethod\n", "    def local(cls) -> Self:\n\t        \"\"\"A :class:`AdaptServer` instance representing a local Adapt API server with default ports extracted from\n\t        Adapt's source code.\n\t        This is useful for testing.\n\t        \"\"\"\n\t        return cls(\n\t            api='http://localhost:8077',\n\t            harmony='ws://localhost:8076',\n\t            convey='http://localhost:8078',\n\t        )\n", "    def copy_with(self, *, api: str | None = None, harmony: str | None = None, convey: str | None = None) -> Self:\n\t        \"\"\"Create a copy of this :class:`AdaptServer` with the specified parameters replaced.\n\t        Parameters\n\t        ----------\n\t        api: :class:`str`\n\t            The URL of the HTTP REST API. (e.g. https://api.adapt.chat)\n\t        harmony: :class:`str`\n\t            The URL of the websocket API. (e.g. wss://harmony.adapt.chat)\n\t        convey: :class:`str`\n\t            The URL of the file upload and CDN API. (e.g. https://convey.adapt.chat)\n", "        \"\"\"\n\t        return AdaptServer(\n\t            api=api or self.api,\n\t            harmony=harmony or self.harmony,\n\t            convey=convey or self.convey,\n\t        )\n\t    if IS_DOCUMENTING:\n\t        def __repr__(self) -> str:\n\t            return 'AdaptServer.production()'\n"]}
{"filename": "adapt/models/channel.py", "chunked_list": ["from __future__ import annotations\n\tfrom abc import ABC, abstractmethod\n\tfrom typing import TYPE_CHECKING\n\tfrom .enums import ChannelType\n\tfrom .message import Message\n\tfrom .object import AdaptObject\n\tif TYPE_CHECKING:\n\t    from typing import Self, TypeAlias\n\t    from .guild import Guild\n\t    from .user import User\n", "    from ..connection import Connection\n\t    from ..types.channel import GuildChannel as RawGuildChannel, DMChannel as RawDMChannel\n\t__all__ = (\n\t    'Messageable',\n\t    'PartialMessageable',\n\t    'GuildChannel',\n\t    'TextChannel',\n\t    'AnnouncementChannel',\n\t    'PrivateChannel',\n\t    'DMChannel',\n", ")\n\tclass Messageable(ABC):\n\t    \"\"\"Represents a channel or model that can be a medium for text-based communication.\"\"\"\n\t    __slots__ = ()\n\t    _connection: Connection\n\t    @abstractmethod\n\t    async def _get_channel(self) -> MessageableChannel:\n\t        raise NotImplementedError\n\t    async def fetch_message(self, message_id: int) -> Message:\n\t        \"\"\"|coro|\n", "        Fetches a message from the channel.\n\t        Parameters\n\t        ----------\n\t        message_id: :class:`int`\n\t            The ID of the message to fetch.\n\t        Returns\n\t        -------\n\t        :class:`.Message`\n\t            The message that was fetched.\n\t        \"\"\"\n", "        channel = await self._get_channel()\n\t        return Message(channel=channel, data=await self._connection.http.get_message(channel.id, message_id))\n\t    async def send(self, content: str | None = None, *, nonce: str | None = None) -> Message:\n\t        \"\"\"|coro|\n\t        Sends a message to the channel.\n\t        Parameters\n\t        ----------\n\t        content: :class:`str`\n\t            The content of the message to send.\n\t        nonce: :class:`str`\n", "            An optional nonce for integrity. When this message is received through the websocket, the nonce will be\n\t            included in the message payload. This can be used to verify that the message was sent successfully.\n\t        Returns\n\t        -------\n\t        :class:`.Message`\n\t            The message that was sent.\n\t        \"\"\"\n\t        channel = await self._get_channel()\n\t        return Message(\n\t            channel=channel,\n", "            data=await self._connection.http.create_message(channel.id, content=content, nonce=nonce),\n\t        )\n\tclass PartialMessageable(Messageable):\n\t    \"\"\"Represents a channel tha t can be a medium for text-based communication that operates with only its channel ID.\n\t    This is useful for performing messaging operations on channels without having to fetch them first or guarantee\n\t    that they are cached.\n\t    Attributes\n\t    ----------\n\t    channel_id: :class:`int`\n\t        The ID of the channel.\n", "    \"\"\"\n\t    __slots__ = ('_connection', 'channel_id')\n\t    def __init__(self, *, connection: Connection, channel_id: int) -> None:\n\t        self._connection = connection\n\t        self.channel_id = channel_id\n\t    async def _get_channel(self) -> Self:\n\t        return self\n\tclass GuildChannel(AdaptObject, ABC):\n\t    \"\"\"Represents a guild channel in Adapt.\n\t    This is the base class for all types of guild channels, and should not be used directly.\n", "    Channels are the primary way to communicate with other users in Adapt. They can be either text-based, voice-based,\n\t    or a category of channels.\n\t    Attributes\n\t    ----------\n\t    type: :class:`.ChannelType`\n\t        The type of the channel. :attr:`.ChannelType.is_guild` for this value will always be ``True``.\n\t    guild: :class:`.Guild`\n\t        The guild that the channel belongs to.\n\t    parent_id: :class:`int` | None\n\t        The ID of the parent category that the channel belongs to, if any.\n", "    name: :class:`str`\n\t        The name of the channel.\n\t    position: :class:`int`\n\t        The position of the channel in the channel list. See the\n\t        `essence documentation <https://github.com/AdaptChat/essence/blob/main/src/models/channel.rs#L183-L204>`_\n\t        for more information.\n\t    \"\"\"\n\t    # TODO: channel overwrites and permission checks\n\t    __slots__ = (\n\t        'type',\n", "        'guild',\n\t        'parent_id',\n\t        'name',\n\t        'position',\n\t    )\n\t    _connection: Connection\n\t    if TYPE_CHECKING:\n\t        type: ChannelType\n\t        guild: Guild\n\t        parent_id: int | None\n", "        name: str\n\t        position: int\n\t    def _update(self, data: RawGuildChannel) -> None:\n\t        self._id = data['id']\n\t        self.type = ChannelType(data['type'])\n\t        self.parent_id = data['parent_id']\n\t        self.name = data['name']\n\t        self.position = data['position']\n\t    async def delete(self) -> None:\n\t        \"\"\"|coro|\n", "        Deletes the channel. You must have the :attr:`~.Permissions.manage_channels` permission to do this.\n\t        \"\"\"\n\t        await self._connection.http.delete_channel(self.id)\n\tclass TextChannel(GuildChannel, Messageable):\n\t    \"\"\"Represents a text-based guild channel in Adapt.\n\t    Attributes\n\t    ----------\n\t    topic: :class:`str` | None\n\t        The topic of the channel, if any.\n\t    nsfw: :class:`bool`\n", "        Whether the channel is NSFW.\n\t    locked: :class:`bool`\n\t        Whether the channel is locked. Only people with the :attr:`~.Permissions.manage_channels` permission can send\n\t        messages in locked channels.\n\t    \"\"\"\n\t    __slots__ = ('_connection', 'topic', 'nsfw', 'locked', '_slowmode')\n\t    if TYPE_CHECKING:\n\t        _connection: Connection\n\t        topic: str | None\n\t        nsfw: bool\n", "        locked: bool\n\t        _slowmode: int\n\t    def __init__(self, *, guild: Guild, data: RawGuildChannel) -> None:\n\t        self._connection = guild._connection\n\t        self.guild = guild\n\t        self._update(data)\n\t    def _update(self, data: RawGuildChannel) -> None:\n\t        super()._update(data)\n\t        self.topic = data['topic']\n\t        self.nsfw = data['nsfw']\n", "        self.locked = data['locked']\n\t        self._slowmode = data['slowmode']\n\t    @property\n\t    def slowmode(self) -> float:\n\t        \"\"\":class:`float`: The slowmode of the channel, in seconds. This is ``0.0`` if the channel has no slowmode.\"\"\"\n\t        return self._slowmode / 1000.0\n\t    @property\n\t    def slowmode_ms(self) -> int:\n\t        \"\"\":class:`int`: The slowmode of the channel, in milliseconds. This is ``0`` if the channel has no slowmode.\"\"\"\n\t        return self._slowmode\n", "    @property\n\t    def is_nsfw(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the channel is NSFW.\n\t        This is an alias for :attr:`~.TextBasedGuildChannel.nsfw`. and is provided for consistency.\n\t        \"\"\"\n\t        return self.nsfw\n\t    @property\n\t    def is_locked(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the channel is locked.\n\t        This is an alias for :attr:`~.TextBasedGuildChannel.locked`. and is provided for consistency.\n", "        \"\"\"\n\t        return self.locked\n\t    @property\n\t    def mention(self) -> str:\n\t        \"\"\":class:`str`: A string that allows you to mention the channel.\"\"\"\n\t        return f'<#{self.id}>'\n\t    async def _get_channel(self) -> Self:\n\t        return self\n\t    def __str__(self) -> str:\n\t        return self.name\n", "    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} id={self.id} name={self.name!r}>'\n\tclass AnnouncementChannel(TextChannel):\n\t    \"\"\"Represents an announcement channel in a guild in Adapt.\"\"\"\n\t    __slots__ = ()\n\tdef _guild_channel_factory(*, guild: Guild, data: RawGuildChannel) -> GuildChannel:\n\t    channel_type = ChannelType(data['type'])\n\t    if channel_type is ChannelType.text:\n\t        factory = TextChannel\n\t    elif channel_type is ChannelType.announcement:\n", "        factory = AnnouncementChannel\n\t    else:\n\t        # TODO\n\t        factory = GuildChannel\n\t    return factory(guild=guild, data=data)\n\tclass PrivateChannel(AdaptObject, ABC):\n\t    \"\"\"Represents a DM or group channel in Adapt.\n\t    This is the base class for all types of private channels, and should not be used directly.\n\t    Attributes\n\t    ----------\n", "    type: :class:`.ChannelType`\n\t        The type of the channel. Can be either :attr:`~.ChannelType.dm` or :attr:`~.ChannelType.group`.\n\t        :attr:`.ChannelType.is_dm` for this value will always be ``True``.\n\t    \"\"\"\n\t    __slots__ = ('type', 'recipient_ids')\n\t    _connection: Connection\n\t    if TYPE_CHECKING:\n\t        type: ChannelType\n\t        me: User\n\t        recipient_ids: list[int]\n", "    def _update(self, data: RawDMChannel) -> None:\n\t        self._id = data['id']\n\t        self.type = ChannelType(data['type'])\n\t        self.recipient_ids = data['recipient_ids']\n\t    @property\n\t    @abstractmethod\n\t    def can_manage(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the client can manage the channel.\"\"\"\n\t        raise NotImplementedError\n\t    @property\n", "    def recipients(self) -> list[User]:\n\t        \"\"\":class:`list`[:class:`.User`]: The recipients of the channel, including yourself.\n\t        This is a shortcut for calling :meth:`.Connection.get_user` with each ID in :attr:`~.PrivateChannel.recipient_ids`.\n\t        Users that are not cached will be excluded from the list.\n\t        \"\"\"\n\t        return [user for user in map(self._connection.get_user, self.recipient_ids) if user is not None]\n\t    async def delete(self) -> None:\n\t        \"\"\"|coro|\n\t        Deletes the channel.\n\t        \"\"\"\n", "        if not self.can_manage:\n\t            raise Exception('oregon')  # TODO: raise Forbidden error\n\t        await self._connection.http.delete_channel(self.id)\n\tclass DMChannel(PrivateChannel, Messageable):\n\t    \"\"\"Represents a DM channel in Adapt.\n\t    Attributes\n\t    ----------\n\t    type: :class:`.ChannelType`\n\t        The type of the channel. :attr:`~.ChannelType.is_dm` for this value will always be ``True``.\n\t    \"\"\"\n", "    __slots__ = ('_connection',)\n\t    def __init__(self, *, connection: Connection, data: RawDMChannel) -> None:\n\t        self._connection = connection\n\t        self._update(data)\n\t    @property\n\t    def can_manage(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the client can manage the channel.\n\t        This will always be ``True`` for DM channels.\n\t        \"\"\"\n\t        return True\n", "    @property\n\t    def recipient_id(self) -> int:\n\t        \"\"\":class:`int`: The ID of the other recipient of this DM channel.\"\"\"\n\t        self_id = self._connection.http.client_id\n\t        return next(id for id in self.recipient_ids if id != self_id)\n\t    @property\n\t    def recipient(self) -> User | None:\n\t        \"\"\":class:`.User`: The other recipient of this DM channel.\n\t        This is a shortcut for calling :meth:`.Connection.get_user` with :attr:`~.DMChannel.recipient_id`. If the user\n\t        is not cached, this will return ``None``.\n", "        \"\"\"\n\t        return self._connection.get_user(self.recipient_id)\n\t    async def _get_channel(self) -> Self:\n\t        return self\n\t    def __repr__(self) -> str:\n\t        return f'<DMChannel id={self.id} recipient_id={self.recipient_id}>'\n\tif TYPE_CHECKING:\n\t    MessageableChannel: TypeAlias = TextChannel | PrivateChannel | PartialMessageable\n"]}
{"filename": "adapt/models/asset.py", "chunked_list": ["from __future__ import annotations\n\tfrom io import BufferedIOBase\n\tfrom typing import overload, TYPE_CHECKING\n\tif TYPE_CHECKING:\n\t    from typing import Any, Literal, Self\n\t    from ..connection import Connection\n\t    from ..util import IOSource\n\t__all__ = ('Asset',)\n\tclass AssetLike:\n\t    \"\"\"Represents any CDN entry from convey, Adapt's CDN server.\"\"\"\n", "    __slots__ = ('_connection', 'url', '_cached')\n\t    def __init__(self, *, connection: Connection | None, url: str) -> None:\n\t        self._connection = connection\n\t        self.url = url\n\t        self._cached: bytes | None = None\n\t    async def read(self, *, cache: bool = True) -> bytes:\n\t        \"\"\"|coro|\n\t        Downloads the asset's contents into raw bytes. This cannot be used if the asset is stateless.\n\t        .. note::\n\t            For assets that are cached, the cache is held on the **asset object** and not the connection. This means\n", "            that two different asset objects may not share the same cache.\n\t        Parameters\n\t        ----------\n\t        cache: :class:`bool`\n\t            Whether to cache the asset. Defaults to ``True``. If this is enabled, future calls to ``read``\n\t            will return the cached bytes instead of downloading the asset again.\n\t        Returns\n\t        -------\n\t        bytes\n\t            The raw bytes of the asset.\n", "        Raises\n\t        ------\n\t        TypeError\n\t            If the asset is stateless.\n\t        \"\"\"\n\t        if not self._connection:\n\t            raise TypeError('Cannot read stateless asset')\n\t        if cache and self._cached is not None:\n\t            return self._cached\n\t        async with self._connection.http.session.get(self.url) as response:\n", "            data = await response.read()\n\t            if cache:\n\t                self._cached = data\n\t            return data\n\t    async def save(self, fp: IOSource, *, cache: bool = True, seek_begin: bool = True) -> int:\n\t        \"\"\"|coro|\n\t        Downloads the asset's contents and saves it to a file. This cannot be used if the asset is stateless.\n\t        .. note::\n\t            For assets that are cached, the cache is held on the **asset object** and not the connection. This means\n\t            that two different asset objects may not share the same cache.\n", "        Parameters\n\t        ----------\n\t        fp: :class:`str`, :class:`pathlib.Path`, or file-like object\n\t            The file path or file-like object to save the asset to.\n\t        cache: :class:`bool`\n\t            Whether to cache the asset. Defaults to ``True``. If this is enabled, future calls to ``save``\n\t            will not download the asset again.\n\t        seek_begin: :class:`bool`\n\t            Whether to seek to the beginning of the file after writing. Defaults to ``True``.\n\t        Returns\n", "        -------\n\t        int\n\t            The number of bytes written to the file.\n\t        Raises\n\t        ------\n\t        :exc:`TypeError`\n\t            - If the file-like object does not support the ``write`` method.\n\t            - If the asset is stateless.\n\t        \"\"\"\n\t        data = await self.read(cache=cache)\n", "        if isinstance(fp, BufferedIOBase):\n\t            written = fp.write(data)\n\t            if seek_begin:\n\t                fp.seek(0)\n\t            return written\n\t        with open(fp, 'wb') as f:\n\t            return f.write(data)\n\t    def __bytes__(self) -> bytes:\n\t        return self._cached or b''\n\t    def __str__(self) -> str:\n", "        return self.url\n\t    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} route={self.url!r}>'\n\t    @overload\n\t    def __eq__(self, other: Self) -> bool:\n\t        ...\n\t    @overload\n\t    def __eq__(self, other: Any) -> Literal[False]:\n\t        ...\n\t    def __eq__(self, other: Any) -> bool:\n", "        return isinstance(other, self.__class__) and self.url == other.url\n\t    def __ne__(self, other: Any) -> bool:\n\t        return not self.__eq__(other)\n\t    def __hash__(self) -> int:\n\t        return hash(self.url)\n\tclass Asset(AssetLike):\n\t    \"\"\"Represents an asset from Adapt's CDN, convey.\n\t    Attributes\n\t    ----------\n\t    url: :class:`str`\n", "        The URL of the asset.\n\t    \"\"\"\n"]}
{"filename": "adapt/models/guild.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .asset import Asset\n\tfrom .bitflags import GuildFlags\n\tfrom .channel import TextChannel, _guild_channel_factory\n\tfrom .object import AdaptObject\n\tfrom ..util import MISSING\n\tif TYPE_CHECKING:\n\t    from typing import Generator, ValuesView, Self\n\t    from .channel import GuildChannel\n", "    from .member import Member, PartialMember\n\t    from .object import ObjectLike\n\t    from ..connection import Connection\n\t    from ..types.channel import GuildChannel as RawGuildChannel\n\t    from ..types.guild import PartialGuild as RawPartialGuild, Guild as RawGuild, Member as RawMember\n\t    from ..util import IOSource\n\t__all__ = ('PartialGuild', 'Guild')\n\tclass PartialGuild(AdaptObject):\n\t    \"\"\"A partial guild object which operates with only an ID.\n\t    This is useful for performing operations on guilds without having to fetch them first.\n", "    .. note::\n\t        Unlike a full :class:`.Guild`, partial guilds will not perform any permission checks locally and will instead\n\t        rely on the API to perform them. This could result in more unnecessary API calls being made.\n\t    .. note::\n\t        This is not to be confused with the official ``PartialGuild`` model in the Adapt API protocol, which is a\n\t        guild without member, channel, and role data. This is a guild object that only operates with an ID.\n\t    \"\"\"\n\t    __slots__ = ('_connection',)\n\t    def __init__(self, *, connection: Connection, id: int) -> None:\n\t        self._id = id\n", "        self._connection = connection\n\t    def _update(self, data: dict) -> None:\n\t        if id := data.get('id'):\n\t            self._id = id\n\t    def get_partial_member(self, member_id: int) -> PartialMember:\n\t        \"\"\"Creates a usable partial member object that operates with only its ID.\n\t        This is useful for when you want to perform actions on a member without having to ensure it is cached\n\t        or fetch unnecessary guild or member data.\n\t        Parameters\n\t        ----------\n", "        member_id: :class:`int`\n\t            The user ID to create the partial member with.\n\t        Returns\n\t        -------\n\t        :class:`.PartialMember`\n\t            The partial member object that was created.\n\t        \"\"\"\n\t        from .member import PartialMember\n\t        return PartialMember(guild=self, id=member_id)\n\t    async def _perform_edit(self, **kwargs) -> RawPartialGuild:\n", "        return await self._connection.http.edit_guild(self.id, **kwargs)\n\t    async def edit(\n\t        self,\n\t        *,\n\t        name: str = MISSING,\n\t        description: str | None = MISSING,\n\t        icon: IOSource | None = MISSING,\n\t        banner: IOSource | None = MISSING,\n\t        public: bool = MISSING,\n\t    ) -> None:\n", "        \"\"\"|coro|\n\t        Edits the properties for the guild. Only the parameters passed will be updated.\n\t        .. note::\n\t            Nothing is returned from this method. If you wish to get the updated guild object, perform the edit on a\n\t            full :class:`.Guild` object instead.\n\t        Parameters\n\t        ----------\n\t        name: :class:`str`\n\t            The new name for the guild.\n\t        description: :class:`str`\n", "            The new description for the guild. Set to ``None`` to remove the description.\n\t        icon: :class:`bytes`, path-like object, file-like object, or ``None``\n\t            The new icon for the guild. Set to ``None`` to remove the icon.\n\t        banner: :class:`bytes`, path-like object, file-like object, or ``None``\n\t            The new banner for the guild. Set to ``None`` to remove the banner.\n\t        public: :class:`bool`\n\t            Whether the guild is public or not.\n\t        \"\"\"\n\t        await self._perform_edit(\n\t            name=name, description=description, icon=icon, banner=banner, public=public,\n", "        )\n\t    async def delete(self, *, password: str = MISSING) -> None:\n\t        \"\"\"|coro|\n\t        Deletes the guild.\n\t        Parameters\n\t        ----------\n\t        password: :class:`str`\n\t            Your account password. This **must** be specified when deleting user accounts for security purposes.\n\t            This should not be specified when deleting bot accounts.\n\t        \"\"\"\n", "        await self._connection.http.delete_guild(self.id, password=password)\n\t    async def leave(self) -> None:\n\t        \"\"\"|coro|\n\t        Leaves the guild.\n\t        \"\"\"\n\t        await self._connection.http.leave_guild(self.id)\n\t    async def kick(self, member: ObjectLike) -> None:\n\t        \"\"\"|coro|\n\t        Kicks the member from the guild. You must have the :attr:`.Permissions.kick_members` permission to do this.\n\t        Parameters\n", "        ----------\n\t        member: :class:`.Member`-like\n\t            The member to kick.\n\t        \"\"\"\n\t        await self._connection.http.kick_member(self.id, member.id)\n\t    def __repr__(self) -> str:\n\t        return f'<PartialGuild id={self.id}>'\n\tclass _GuildCacheIntegrity:\n\t    __slots__ = ('_members', '_roles', '_channels')\n\t    def __init__(self) -> None:\n", "        self._members: bool = False\n\t        self._roles: bool = False\n\t        self._channels: bool = False\n\t    @property\n\t    def members(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the guild's members are cached.\"\"\"\n\t        return self._members\n\t    @property\n\t    def roles(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the guild's roles are cached.\"\"\"\n", "        return self._roles\n\t    @property\n\t    def channels(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the guild's channels are cached.\"\"\"\n\t        return self._channels\n\tclass Guild(PartialGuild):\n\t    \"\"\"Represents a guild in Adapt.\n\t    Attributes\n\t    ----------\n\t    name: :class:`str`\n", "        The name of the guild.\n\t    description: :class:`str` | None\n\t        The description of the guild.\n\t    owner_id: :class:`int`\n\t        The ID of the user that owns the guild.\n\t    vanity_code: :class:`str` | None\n\t        The vanity URL code of the guild. This solely includes the code, not the full URL.\n\t        This is ``None`` if the guild does not have a vanity URL.\n\t    \"\"\"\n\t    __slots__ = (\n", "        'name',\n\t        'description',\n\t        '_icon',\n\t        '_banner',\n\t        'owner_id',\n\t        '_flags',\n\t        'vanity_code',\n\t        '_members',\n\t        '_roles',\n\t        '_channels',\n", "        '_integrity',\n\t    )\n\t    def __init__(self, *, connection: Connection, data: RawPartialGuild | RawGuild) -> None:\n\t        self._members: dict[int, Member] = {}\n\t        self._roles: dict[int, Role] = {}\n\t        self._channels: dict[int, GuildChannel] = {}\n\t        self._integrity = _GuildCacheIntegrity()\n\t        super().__init__(connection=connection, id=data['id'])\n\t        self._update(data)\n\t    def _update(self, data: RawPartialGuild | RawGuild) -> None:\n", "        super()._update(data)\n\t        self.name = data['name']\n\t        self.description = data['description']\n\t        self._icon = data['icon']\n\t        self._banner = data['banner']\n\t        self.owner_id = data['owner_id']\n\t        self._flags = data['flags']\n\t        self.vanity_code = data['vanity_url']\n\t        if members := data.get('members'):\n\t            for member in members:\n", "                self._add_raw_member(member)\n\t            self._integrity._members = True\n\t        if channels := data.get('channels'):\n\t            for channel in channels:\n\t                self._add_raw_channel(channel)\n\t            self._integrity._channels = True\n\t    def _add_member(self, member: Member) -> Member:\n\t        self._members[member.id] = member\n\t        return member\n\t    def _add_raw_member(self, data: RawMember) -> Member:\n", "        from .member import Member\n\t        if member := self._members.get(data['id']):\n\t            member._update(data)\n\t            return member\n\t        member = Member(guild=self, data=data)\n\t        self._connection.add_raw_user(data)\n\t        return self._add_member(member)\n\t    def _add_channel(self, channel: GuildChannel) -> GuildChannel:\n\t        self._channels[channel.id] = channel\n\t        return channel\n", "    def _add_raw_channel(self, data: RawGuildChannel) -> GuildChannel:\n\t        if channel := self._channels.get(data['id']):\n\t            channel._update(data)\n\t            return channel\n\t        channel = _guild_channel_factory(guild=self, data=data)\n\t        return self._add_channel(channel)\n\t    @property\n\t    def members(self) -> ValuesView[Member]:\n\t        \"\"\"Iterable[:class:`.Member`]: An iterable of the guild's members.\"\"\"\n\t        return self._members.values()\n", "    def get_member(self, member_id: int) -> Member | None:\n\t        \"\"\"Returns the member with the given ID, resolved from the cache.\n\t        Parameters\n\t        ----------\n\t        member_id: :class:`int`\n\t            The ID of the member to get.\n\t        Returns\n\t        -------\n\t        :class:`.Member` | None\n\t            The member with the given ID, or ``None`` if not found in the cache.\n", "        \"\"\"\n\t        return self._members.get(member_id)\n\t    async def fetch_member(self, member_id: int, *, respect_cache: bool = True) -> Member:\n\t        \"\"\"|coro|\n\t        Fetches the member with the given ID from the API.\n\t        Parameters\n\t        ----------\n\t        member_id: :class:`int`\n\t            The ID of the member to fetch.\n\t        respect_cache: :class:`bool`\n", "            Whether to respect the cache or not. If ``True``, the cache will be checked first.\n\t        Returns\n\t        -------\n\t        :class:`.Member`\n\t            The member with the given ID.\n\t        \"\"\"\n\t        if member := respect_cache and self.get_member(member_id):\n\t            return member\n\t        data = await self._connection.http.get_member(self.id, member_id)\n\t        return self._add_raw_member(data)\n", "    @property\n\t    def channels(self) -> ValuesView[GuildChannel]:\n\t        \"\"\"Iterable[:class:`.GuildChannel`]: An iterable of the guild's channels.\"\"\"\n\t        return self._channels.values()\n\t    @property\n\t    def text_channels(self) -> Generator[TextChannel, None, None]:\n\t        \"\"\"Iteratable[:class:`.TextBasedGuildChannel`]: An iterator of the guild's text-based channels.\"\"\"\n\t        return (channel for channel in self.channels if isinstance(channel, TextChannel))\n\t    def get_channel(self, channel_id: int) -> GuildChannel | None:\n\t        \"\"\"Returns the channel with the given ID, resolved from the cache.\n", "        Parameters\n\t        ----------\n\t        channel_id: :class:`int`\n\t            The ID of the channel to get.\n\t        Returns\n\t        -------\n\t        :class:`.GuildChannel` | None\n\t            The channel with the given ID, or ``None`` if not found in the cache.\n\t        \"\"\"\n\t        return self._channels.get(channel_id)\n", "    async def fetch_channel(self, channel_id: int, *, respect_cache: bool = True) -> GuildChannel:\n\t        \"\"\"|coro|\n\t        Fetches the channel with the given ID from the API.\n\t        Parameters\n\t        ----------\n\t        channel_id: :class:`int`\n\t            The ID of the channel to fetch.\n\t        respect_cache: :class:`bool`\n\t            Whether to respect the cache or not. If ``True``, the cache will be checked first.\n\t        Returns\n", "        -------\n\t        :class:`.GuildChannel`\n\t            The channel with the given ID.\n\t        \"\"\"\n\t        if channel := respect_cache and self.get_channel(channel_id):\n\t            return channel\n\t        data = await self._connection.http.get_channel(channel_id)\n\t        return self._add_raw_channel(data)\n\t    @property\n\t    def cache_integrity(self) -> _GuildCacheIntegrity:\n", "        \"\"\"Returns the integrity of the guild's cache.\n\t        This is a :class:`.NamedTuple` with the following boolean attributes:\n\t        - ``members``: Whether the guild's members are cached.\n\t        - ``roles``: Whether the guild's roles are cached.\n\t        - ``channels``: Whether the guild's channels are cached.\n\t        \"\"\"\n\t        return self._integrity\n\t    @property\n\t    def me(self) -> Member | None:\n\t        \"\"\":class:`.Member`: The member that represents the client in the guild, if available in cache.\n", "        This is equivalent to ``guild.get_member(client.user.id)``.\n\t        \"\"\"\n\t        return self.get_member(self._connection.user.id)\n\t    @property\n\t    def icon(self) -> Asset:\n\t        \"\"\":class:`.Asset`: The guild's icon.\"\"\"\n\t        return Asset(connection=self._connection, url=self._icon)\n\t    @property\n\t    def banner(self) -> Asset:\n\t        \"\"\":class:`.Asset`: The guild's banner.\"\"\"\n", "        return Asset(connection=self._connection, url=self._banner)\n\t    @property\n\t    def flags(self) -> GuildFlags:\n\t        \"\"\":class:`.GuildFlags`: Special properties and features about the guild.\"\"\"\n\t        return GuildFlags(self._flags)\n\t    @property\n\t    def public(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the guild is public.\"\"\"\n\t        return self.flags.public\n\t    @property\n", "    def verified(self) -> bool:\n\t        \"\"\":class:`bool`: Whether the guild is verified.\"\"\"\n\t        return self.flags.verified\n\t    @property\n\t    def owner(self) -> Member | None:\n\t        \"\"\":class:`.Member` | None: The resolved member object of the guild owner, if available in cache.\"\"\"\n\t        return self.get_member(self.owner_id)\n\t    async def edit(\n\t        self,\n\t        *,\n", "        name: str = MISSING,\n\t        description: str | None = MISSING,\n\t        icon: IOSource | None = MISSING,\n\t        banner: IOSource | None = MISSING,\n\t        public: bool = MISSING,\n\t    ) -> Self:\n\t        \"\"\"|coro|\n\t        Edits the properties for the guild. Only the parameters passed will be updated.\n\t        Parameters\n\t        ----------\n", "        name: :class:`str`\n\t            The new name for the guild.\n\t        description: :class:`str`\n\t            The new description for the guild. Set to ``None`` to remove the description.\n\t        icon: :class:`bytes`, path-like object, file-like object, or ``None``\n\t            The new icon for the guild. Set to ``None`` to remove the icon.\n\t        banner: :class:`bytes`, path-like object, file-like object, or ``None``\n\t            The new banner for the guild. Set to ``None`` to remove the banner.\n\t        public: :class:`bool`\n\t            Whether the guild is public or not.\n", "        Returns\n\t        -------\n\t        :class:`.Guild`\n\t            The updated guild object.\n\t        \"\"\"\n\t        self._update(await self._perform_edit(\n\t            name=name, description=description, icon=icon, banner=banner, public=public,\n\t        ))\n\t        return self\n\t    def __str__(self) -> str:\n", "        return self.name\n\t    def __repr__(self) -> str:\n\t        return f'<Guild id={self.id} name={self.name!r}>'\n"]}
{"filename": "adapt/models/message.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .bitflags import MessageFlags\n\tfrom .enums import MessageType\n\tfrom .object import AdaptObject\n\tfrom ..util import MISSING\n\tif TYPE_CHECKING:\n\t    from typing import Self\n\t    from .channel import MessageableChannel\n\t    from .guild import Guild\n", "    from .member import Member\n\t    from .user import User\n\t    from ..connection import Connection\n\t    from ..types.message import Message as RawMessage\n\t__all__ = ('PartialMessage', 'Message')\n\tclass PartialMessage(AdaptObject):\n\t    \"\"\"Represents a message in Adapt that only operates with a channel, message ID, and potentially a revision ID.\n\t    This is useful for performing operations on messages without having to fetch them first.\n\t    Attributes\n\t    ----------\n", "    channel: :class:`.TextChannel` | :class:`.PrivateChannel` | :class:`.PartialMessageable`\n\t        The channel that the message belongs to.\n\t    \"\"\"\n\t    __slots__ = ('channel', '_revision_id')\n\t    def __init__(self, *, channel: MessageableChannel, id: int) -> None:\n\t        self.channel = channel\n\t        self._id = id\n\t    def _update(self, data: RawMessage) -> None:\n\t        self._id = data['id']\n\t        self._revision_id = data['revision_id']\n", "    @property\n\t    def _connection(self) -> Connection:\n\t        return self.channel._connection\n\t    async def edit(self, *, content: str | None = MISSING) -> Self:\n\t        \"\"\"|coro|\n\t        Edits the message.\n\t        Parameters\n\t        ----------\n\t        content: :class:`str`\n\t            The new content of the message.\n", "        Returns\n\t        -------\n\t        :class:`.Message`\n\t            The edited message.\n\t        \"\"\"\n\t        self._update(await self._connection.http.edit_message(self.channel.id, self.id, content=content))\n\t        return self\n\t    async def delete(self) -> None:\n\t        \"\"\"|coro|\n\t        Deletes the message.\n", "        \"\"\"\n\t        await self._connection.http.delete_message(self.channel.id, self.id)\n\t    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} id={self.id} channel_id={self.channel.id}>'\n\tclass Message(PartialMessage):\n\t    \"\"\"Represents a message in Adapt.\n\t    Attributes\n\t    ----------\n\t    content: :class:`str`\n\t        The content of the message. If no content exists, an empty string is returned.\n", "    type: :class:`.MessageType`\n\t        The type of the message.\n\t    flags: :class:`.MessageFlags`\n\t        Special properties about the message.\n\t    stars: :class:`int`\n\t        The number of stars the message has accumulated.\n\t    \"\"\"\n\t    __slots__ = (\n\t        'content',\n\t        '_author',\n", "        'type',\n\t        'flags',\n\t        'stars',\n\t    )\n\t    def __init__(self, *, channel: MessageableChannel, data: RawMessage) -> None:\n\t        super().__init__(channel=channel, id=0)  # ID is set in _update\n\t        self._update(data)\n\t    def _update(self, data: RawMessage) -> None:\n\t        self.content = data['content']\n\t        if author := data['author']:\n", "            # Try upgrading the author to a member if possible\n\t            if (guild_id := author.get('guild_id')) and (guild := self._connection.get_guild(guild_id)):\n\t                self._author = guild._add_raw_member(author)\n\t            else:\n\t                self._author = self._connection.add_raw_user(author)\n\t        else:\n\t            self._author = data['author_id']\n\t        self.type = MessageType(data['type'])\n\t        self.flags = MessageFlags(data['flags'])\n\t        self.stars = data['stars']\n", "        super()._update(data)\n\t    @property\n\t    def author(self) -> User | Member | None:\n\t        \"\"\":class:`.User` | :class:`.Member` | None: The author of the message.\n\t        If an author is not applicable, or resolved author data was not provided and the author is not cached,\n\t        this will be ``None``.\n\t        Otherwise, if the message was sent in a guild, this will be a :class:`.Member`. If it was sent in a private\n\t        channel, this will be a :class:`.User`.\n\t        \"\"\"\n\t        if self._author is None:\n", "            return None\n\t        elif isinstance(self._author, int):\n\t            return self._connection.get_user(self._author)\n\t        return self._author\n\t    @property\n\t    def guild(self) -> Guild | None:\n\t        \"\"\":class:`.Guild` | None: The guild that the message was sent in, if applicable.\"\"\"\n\t        return self.channel.guild\n\t    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} id={self.id} channel_id={self.channel.id} author_id={self.author.id}>'\n"]}
{"filename": "adapt/models/object.py", "chunked_list": ["from __future__ import annotations\n\tfrom abc import ABC\n\tfrom collections.abc import Hashable\n\tfrom datetime import datetime\n\tfrom typing import Protocol, TYPE_CHECKING\n\tfrom .enums import ModelType\n\tfrom ..util import snowflake_model_type, snowflake_time\n\tif TYPE_CHECKING:\n\t    from typing import Self\n\t__all__ = (\n", "    'BaseObject',\n\t    'AdaptObject',\n\t    'Object',\n\t)\n\tclass ObjectLike(Protocol):\n\t    __slots__ = ()\n\t    @property\n\t    def id(self) -> int:\n\t        ...\n\t    def __eq__(self, other: Self) -> bool:\n", "        ...\n\t    def __hash__(self) -> int:\n\t        ...\n\tclass BaseObject(Hashable, ABC):\n\t    \"\"\"An abstract base class for all objects that have an ID.\"\"\"\n\t    __slots__ = ('_id',)\n\t    _id: int\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"The ID of the object.\"\"\"\n", "        raise NotImplementedError\n\t    def __eq__(self, other: Self) -> bool:\n\t        return isinstance(other, self.__class__) and self.id == other.id\n\t    def __ne__(self, other: Self) -> bool:\n\t        return not self.__eq__(other)\n\t    def __hash__(self) -> int:\n\t        return hash(self.id)\n\t    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} id={self.id}>'\n\tclass AdaptObject(BaseObject, ABC):\n", "    \"\"\"The base class that all Adapt objects inherit from.\"\"\"\n\t    __slots__ = ()\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"The ID of the object.\"\"\"\n\t        return self._id\n\t    @property\n\t    def created_at(self) -> datetime:\n\t        \"\"\"The time the object was created.\"\"\"\n\t        return snowflake_time(self.id)\n", "class Object(AdaptObject):\n\t    \"\"\"A generic Adapt object that has an ID.\n\t    Parameters\n\t    ----------\n\t    id: :class:`int`\n\t        The ID of the object.\n\t    model_type: :class:`ModelType`\n\t        The type of model the object is. If not provided, the model type will be calculated from the ID.\n\t        If it is provided, the ID will be **modified** to match the provided model type.\n\t    \"\"\"\n", "    __slots__ = ('_id',)\n\t    def __init__(self, id: int, *, model_type: ModelType | None = None) -> None:\n\t        self._id = id\n\t        if model_type is not None:\n\t            self.model_type = model_type\n\t    @property\n\t    def model_type(self) -> ModelType:\n\t        \"\"\"The type of model the object is.\"\"\"\n\t        return snowflake_model_type(self.id)\n\t    @model_type.setter\n", "    def model_type(self, value: ModelType) -> None:\n\t        self._id = (self._id & ~(0b11111 << 13)) | (value.value << 13)\n\t    def __repr__(self) -> str:\n\t        return f'<Object id={self.id} model_type={self.model_type}>'\n"]}
{"filename": "adapt/models/enums.py", "chunked_list": ["from __future__ import annotations\n\tfrom enum import Enum\n\tfrom typing import TYPE_CHECKING\n\tif TYPE_CHECKING:\n\t    from typing import Self\n\t__all__ = (\n\t    'ModelType',\n\t    'Status',\n\t    'RelationshipType',\n\t    'ChannelType',\n", "    'MessageType',\n\t)\n\tclass ModelType(Enum):\n\t    \"\"\"|enum|\n\t    Enumeration of model types.\n\t    Attributes\n\t    ----------\n\t    guild\n\t        The model is a :class:`Guild`.\n\t    user\n", "        The model is a :class:`User`.\n\t    channel\n\t        The model is a :class:`Channel`.\n\t    message\n\t        The model is a :class:`Message`.\n\t    attachment\n\t        The model is an :class:`Attachment`.\n\t    role\n\t        The model is a :class:`Role`.\n\t    internal\n", "        The model is an internal model.\n\t    unknown\n\t        The model type is unknown.\n\t    \"\"\"\n\t    guild = 0\n\t    user = 1\n\t    channel = 2\n\t    message = 3\n\t    attachment = 4\n\t    role = 5\n", "    internal = 6\n\t    unknown = 31\n\t    @classmethod\n\t    def _missing_(cls, value: Self) -> Self:\n\t        return cls.unknown\n\tclass Status(Enum):\n\t    \"\"\"|enum|\n\t    The status of a user's presence.\n\t    Attributes\n\t    ----------\n", "    online\n\t        The user is online.\n\t    idle\n\t        The user is idle.\n\t    dnd\n\t        The user is has enabled Do Not Disturb.\n\t    offline\n\t        The user is offline.\n\t    \"\"\"\n\t    online = 'online'\n", "    idle = 'idle'\n\t    dnd = 'dnd'\n\t    offline = 'offline'\n\tclass RelationshipType(Enum):\n\t    \"\"\"|enum|\n\t    The type of a relationship.\n\t    Attributes\n\t    ----------\n\t    friend\n\t        The user is your friend.\n", "    outgoing_request\n\t        You have sent a friend request to the user.\n\t    incoming_request\n\t        You have received a friend request from the user.\n\t    blocked\n\t        You have blocked the user.\n\t    \"\"\"\n\t    friend = 'friend'\n\t    outgoing_request = 'outgoing_request'\n\t    incoming_request = 'incoming_request'\n", "    blocked = 'blocked'\n\t    # Aliases\n\t    outgoing = outgoing_request\n\t    incoming = incoming_request\n\tclass ChannelType(Enum):\n\t    \"\"\"|enum|\n\t    The type of a channel.\n\t    Attributes\n\t    ----------\n\t    text\n", "        The channel is a text channel.\n\t    announcement\n\t        The channel is an announcement channel.\n\t    voice\n\t        The channel is a voice channel.\n\t    category\n\t        The channel is a category channel.\n\t    dm\n\t        The channel is a DM channel.\n\t    group\n", "        The channel is a group DM channel.\n\t    \"\"\"\n\t    text = 'text'\n\t    announcement = 'announcement'\n\t    voice = 'voice'\n\t    category = 'category'\n\t    dm = 'dm'\n\t    group = 'group'\n\t    @property\n\t    def is_guild(self) -> bool:\n", "        return self in (self.text, self.announcement, self.voice, self.category)\n\t    @property\n\t    def is_dm(self) -> bool:\n\t        return self in (self.dm, self.group)\n\t    @property\n\t    def is_text_based(self) -> bool:\n\t        return self in (self.text, self.announcement, self.dm, self.group)\n\t    @property\n\t    def is_voice_based(self) -> bool:\n\t        return self is self.voice\n", "class MessageType(Enum):\n\t    \"\"\"|enum|\n\t    default\n\t        A normal message.\n\t    join\n\t        A join message, sent when a user joins either a group DM or a guild.\n\t    leave\n\t        A leave message, sent when a user leaves either a group DM or a guild.\n\t    pin\n\t        A message that indicates another message has been pinned.\n", "    \"\"\"\n\t    default = 'default'\n\t    join = 'join'\n\t    leave = 'leave'\n\t    pin = 'pin'\n"]}
{"filename": "adapt/models/__init__.py", "chunked_list": ["from . import asset, bitflags, channel, enums, guild, member, message, object, ready, user\n\tfrom .asset import *\n\tfrom .bitflags import *\n\tfrom .channel import *\n\tfrom .enums import *\n\tfrom .guild import *\n\tfrom .member import *\n\tfrom .message import *\n\tfrom .object import *\n\tfrom .ready import *\n", "from .user import *\n"]}
{"filename": "adapt/models/bitflags.py", "chunked_list": ["from __future__ import annotations\n\tfrom functools import reduce\n\tfrom operator import or_\n\tfrom typing import TYPE_CHECKING, cast\n\tfrom ..util import MISSING\n\tif TYPE_CHECKING:\n\t    from typing import Any, ClassVar, Iterator, Self\n\t__all__ = (\n\t    'Bitflags',\n\t    'UserFlags',\n", "    'PrivacyConfiguration',\n\t    'GuildFlags',\n\t    'MessageFlags',\n\t    'RoleFlags',\n\t    'Permissions',\n\t)\n\t_ = lambda value: cast(bool, value)\n\tdef _create_property(member: int) -> property:\n\t    def _has(self: Bitflags) -> bool:\n\t        return self.value & member == member\n", "    def _set(self: Bitflags, value: bool):\n\t        if value:\n\t            self.value |= member\n\t        else:\n\t            self.value &= ~member\n\t    def _del(self: Bitflags):\n\t        self.value &= ~member\n\t    return property(_has, _set, _del)\n\tclass Bitflags:\n\t    \"\"\"The base class that all bitflag classes inherit from. This class is not meant to be used directly.\n", "    Bitflags are a way to represent multiple boolean values in a single integer. This class provides a way to easily\n\t    read and manipulate these boolean values.\n\t    Parameters\n\t    ----------\n\t    value: :class:`int`\n\t        The initial bits. If not provided, the default value will be used (typically ``0`` unless specified).\n\t    **flags: :class:`bool`\n\t        The overrides for each flag. If a flag is not provided, it will be set to ``False``.\n\t    Attributes\n\t    ----------\n", "    value: :class:`int`\n\t        The current bits.\n\t    Examples\n\t    --------\n\t    We will use the :class:`Permissions` class as an example.\n\t    Create a new permissions instance with specific flags: ::\n\t        permissions = Permissions(view_channel=True, send_messages=True)\n\t    Create a new permissions instance with a specific value: ::\n\t        permissions = Permissions(5)  # Equivalent to Permissions(view_channel=True, send_messages=True)\n\t    Read the value of a specific flag: ::\n", "        permissions.view_channel  # True\n\t        permissions.add_reactions  # False\n\t    Set the value of a specific flag: ::\n\t        permissions.view_channel = False\n\t        permissions.view_channel  # False\n\t        # Using the `del` keyword will set the flag to False\n\t        del permissions.view_channel  # Equivalent to permissions.view_channel = False\n\t    Create a new permissions instance from another: ::\n\t        permissions = Permissions(view_channel=True, send_messages=True)\n\t        modified = permissions.copy_with(send_messages=False)\n", "        permissions.send_messages  # True\n\t        modified.send_messages  # False\n\t    Helper methods are also provided to make it easier to work with bitflags: ::\n\t        no_permissions = Permissions.none()  # Equivalent to Permissions(0)\n\t        all_permissions = Permissions.all()  # Enable all flags\n\t        default_permissions = Permissions.default()  # Use the default value\n\t    Turn a permissions instance into a dictionary: ::\n\t        permissions = Permissions(view_channel=True, send_messages=True)\n\t        dict(permissions)  # {'view_channel': True, 'send_messages': True, 'add_reactions': False, ...}\n\t        # Turn it into a list of enabled flags\n", "        [name for name, value in permissions if value]  # ['view_channel', 'send_messages']\n\t    \"\"\"\n\t    value: int\n\t    __valid_flags__: ClassVar[dict[str, int]]\n\t    __default_value__: ClassVar[int] = 0\n\t    __all_value__: ClassVar[int]\n\t    __slots__ = ('value',)\n\t    def __init_subclass__(cls, **kwargs: Any) -> None:\n\t        valid_flags = {}\n\t        for base in cls.__mro__:\n", "            for name, member in base.__dict__.items():\n\t                if isinstance(member, int) and not name.startswith('_'):\n\t                    valid_flags[name] = member\n\t                    setattr(cls, name, _create_property(member))\n\t        cls.__valid_flags__ = valid_flags\n\t        cls.__all_value__ = reduce(or_, valid_flags.values())\n\t    def __init__(self, value: int = MISSING, **flags: bool):\n\t        self.value = value or self.__default_value__\n\t        for name, value in flags.items():\n\t            try:\n", "                setattr(self, name, value)\n\t            except AttributeError:\n\t                raise ValueError(f'Invalid flag: {name}')\n\t    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} value={self.value}>'\n\t    def __iter__(self) -> Iterator[tuple[str, bool]]:\n\t        for name in self.__valid_flags__:\n\t            yield name, getattr(self, name)\n\t    def __bool__(self) -> bool:\n\t        return bool(self.value)\n", "    def __or__(self, other: Self) -> Self:\n\t        return self.__class__(self.value | other.value)\n\t    def __and__(self, other: Self) -> Self:\n\t        return self.__class__(self.value & other.value)\n\t    def __xor__(self, other: Self) -> Self:\n\t        return self.__class__(self.value ^ other.value)\n\t    def __invert__(self) -> Self:\n\t        return self.__class__(self.__all_value__ ^ self.value)\n\t    def __ior__(self, other: Self) -> Self:\n\t        self.value |= other.value\n", "        return self\n\t    def __iand__(self, other: Self) -> Self:\n\t        self.value &= other.value\n\t        return self\n\t    def __ixor__(self, other: Self) -> Self:\n\t        self.value ^= other.value\n\t        return self\n\t    def __eq__(self, other: Any) -> bool:\n\t        return isinstance(other, self.__class__) and self.value == other.value\n\t    def __ne__(self, other: Any) -> bool:\n", "        return not self == other\n\t    def __hash__(self) -> int:\n\t        return hash(self.value)\n\t    @classmethod\n\t    def none(cls) -> Self:\n\t        \"\"\"Creates a new instance with all flags set to ``False``.\n\t        Returns\n\t        -------\n\t        :class:`Bitflags`\n\t            The new instance.\n", "        \"\"\"\n\t        return cls(0)\n\t    @classmethod\n\t    def all(cls) -> Self:\n\t        \"\"\"Creates a new instance with all flags set to ``True``.\n\t        Returns\n\t        -------\n\t        :class:`Bitflags`\n\t            The new instance.\n\t        \"\"\"\n", "        return cls(cls.__all_value__)\n\t    @classmethod\n\t    def default(cls) -> Self:\n\t        \"\"\"Creates a new instance with the default flags.\n\t        Returns\n\t        -------\n\t        :class:`Bitflags`\n\t            The new instance.\n\t        \"\"\"\n\t        return cls(cls.__default_value__)\n", "    def copy_with(self, **overrides: bool) -> Self:\n\t        \"\"\"Returns a copy of this instance with the given flag overrides applied.\n\t        Parameters\n\t        ----------\n\t        **overrides: :class:`bool`\n\t            The flags to override.\n\t        Returns\n\t        -------\n\t        :class:`Bitflags`\n\t            The new instance.\n", "        \"\"\"\n\t        return self.__class__(self.value, **overrides)\n\tclass UserFlags(Bitflags):\n\t    \"\"\"|bitflags|\n\t    Represents special properties about a user.\n\t    Attributes\n\t    ----------\n\t    bot: :class:`bool`\n\t        Whether the user is a bot.\n\t    \"\"\"\n", "    bot = _(1 << 0)\n\tclass PrivacyConfiguration(Bitflags):\n\t    \"\"\"|bitflags|\n\t    Represents the privacy configuration of a user.\n\t    Attributes\n\t    ----------\n\t    friends: :class:`bool`\n\t        This configuration is public for friends.\n\t    mutual_friends: :class:`bool`\n\t        This configuration is public for mutual friends (friends of friends).\n", "    guild_members: :class:`bool`\n\t        This configuration is public for users who share a guild with you.\n\t    everyone: :class:`bool`\n\t        This configuration is public for everyone. This overrides all other configurations.\n\t    \"\"\"\n\t    friends = _(1 << 0)\n\t    mutual_friends = _(1 << 1)\n\t    guild_members = _(1 << 2)\n\t    everyone = _(1 << 3)\n\t    # Aliases\n", "    default_dm_privacy = friends | mutual_friends | guild_members\n\t    default_group_dm_privacy = friends\n\t    default_friend_request_privacy = everyone\n\tclass GuildFlags(Bitflags):\n\t    \"\"\"|bitflags|\n\t    Represents extra properties and features about a guild.\n\t    Attributes\n\t    ----------\n\t    public: :class:`bool`\n\t        The guild is a public guild.\n", "    verified: :class:`bool`\n\t        The guild is verified or official guild.\n\t    vanity_url: :class:`bool`\n\t        The guild has a vanity invite URL.\n\t    \"\"\"\n\t    public = _(1 << 0)\n\t    verified = _(1 << 1)\n\t    vanity_url = _(1 << 2)\n\tclass MessageFlags(Bitflags):\n\t    \"\"\"|bitflags|\n", "    Represents extra properties and features about a message.\n\t    Attributes\n\t    ----------\n\t    pinned: :class:`bool`\n\t        The message is pinned.\n\t    system: :class:`bool`\n\t        The message is a system message.\n\t    crosspost: :class:`bool`\n\t        The message is a subscribed crosspost from an announcement channel.\n\t    published: :class:`bool`\n", "        This message has been published to subscribed channels in an announcement channel.\n\t    \"\"\"\n\t    pinned = _(1 << 0)\n\t    system = _(1 << 1)\n\t    crosspost = _(1 << 2)\n\t    published = _(1 << 3)\n\tclass RoleFlags(Bitflags):\n\t    \"\"\"|bitflags|\n\t    Represents extra properties and features about a role.\n\t    Attributes\n", "    ----------\n\t    hoisted: :class:`bool`\n\t         Whether the role is hoisted, or shown separately, in the members list.\n\t    managed: :class:`bool`\n\t        Whether the role is managed. Managed roles cannot be edited or deleted.\n\t    mentionable: :class:`bool`\n\t        Whether the role is mentionable.\n\t    default_role: :class:`bool`\n\t        Whether the role is the default role for everyone.\n\t    \"\"\"\n", "    hoisted = _(1 << 0)\n\t    managed = _(1 << 1)\n\t    mentionable = _(1 << 2)\n\t    default_role = _(1 << 3)\n\tclass Permissions(Bitflags):\n\t    \"\"\"|bitflags|\n\t    Represents a set of permissions.\n\t    Attributes\n\t    ----------\n\t    view_channel: :class:`bool`\n", "        People with this permission can view channels and receive events from them.\n\t    view_message_history: :class:`bool`\n\t        People with this permission can view the message history of channels. The\n\t        `view_channel` permission is not necessarily required to view the message history,\n\t        however it means you cannot receive or send new messages in the channel.\n\t    send_messages: :class:`bool`\n\t        People with this permission can send messages in channels. The `view_channel`\n\t        permission *is* required to send messages.\n\t    manage_messages: :class:`bool`\n\t        People with this permission can manage messages sent by other people. This allows\n", "        for the following:\n\t        * Deleting messages sent by others\n\t        * Deleting attachments or embeds sent by others\n\t        * Removing reactions of others\n\t        * Unpublishing messages sent by others (Announcement channels only)\n\t        Note that anyone can still delete their own messages.\n\t    attach_files: :class:`bool`\n\t        People with this permission can attach files to messages.\n\t    send_embeds: :class:`bool`\n\t        People with this permission can send rich embeds or have embed links automatically\n", "        appear.\n\t    add_reactions: :class:`bool`\n\t        People with this permission can add new reactions to messages. Note that users\n\t        without this permission can still react to already existing reactions.\n\t    pin_messages: :class:`bool`\n\t        People with this permission can pin *and* unpin messages.\n\t    star_messages: :class:`bool`\n\t        People with this permission can star and unstar messages.\n\t    publish_messages: :class:`bool`\n\t        People with this permission can publish messages to the announcement feed.\n", "    modify_channels: :class:`bool`\n\t        People with this permission can manage settings of channels.\n\t    manage_channels: :class:`bool`\n\t        People with this permission can manage channels.\n\t    manage_webhooks: :class:`bool`\n\t        People with this permission can create, edit, and delete webhooks.\n\t    manage_emojis: :class:`bool`\n\t        People with this permission can create, edit, and delete emojis.\n\t    manage_starboard: :class:`bool`\n\t        People with this permission can delete starboard posts, or disable the starboard completely.\n", "    manage_guild: :class:`bool`\n\t        People with this permission can manage the guild's settings.\n\t    manage_roles: :class:`bool`\n\t        People with this permission can manage the guild's roles. They will be able to\n\t        change the permissions of any roles below their top role, and they will be forbidden to\n\t        grant or deny any permissions they do not have themselves. They can also assign and\n\t        remove any roles to other members, as long as the target role is below their top role.\n\t    create_invites: :class:`bool`\n\t        People with this permission can create invites to the guild.\n\t    manage_invites: :class:`bool`\n", "        People with this permission can revoke or pause invites of any channel in the guild.\n\t        This does not take into account the `create_invites` permission, meaning they can revoke\n\t        invites even if they cannot create them.\n\t    use_external_emojis: :class:`bool`\n\t        People with this permission can use emojis found in other servers.\n\t    change_nickname: :class:`bool`\n\t        People with this permission can change their own nickname.\n\t    manage_nicknames: :class:`bool`\n\t        People with this permission can change the nickname of other people.\n\t    timeout_members: :class:`bool`\n", "        People with this permission can timeout and untimeout members that are lower than\n\t        them in role hierarchy.\n\t    kick_members: :class:`bool`\n\t        People with this permission can kick members that are lower than them in role\n\t        hierarchy.\n\t    ban_members: :class:`bool`\n\t        People with this permission can ban and unban members that are lower than them in\n\t        role hierarchy.\n\t    bulk_delete_messages: :class:`bool`\n\t        People with this permission can delete or purge messages in bulk.\n", "        Unlike Discord, the API allows for up to any number of messages to be deleted at a time.\n\t    view_audit_log: :class:`bool`\n\t        People with this permission can view an audit log of past moderation or other\n\t        privileged actions.\n\t    privileged_mentions: :class:`bool`\n\t        People with this permission can mention large groups of people. This means\n\t        mentioning everyone under a non-mentionable role or mentioning everyone.\n\t    connect: :class:`bool`\n\t        People with this permission can connect to a voice channel.\n\t    speak: :class:`bool`\n", "        People with this permission can speak in a voice channel.\n\t    mute_members: :class:`bool`\n\t        People with this permission can mute other members in a voice channel.\n\t    deafen_members: :class:`bool`\n\t        People with this permission can deafen other members in a voice channel.\n\t    administrator: :class:`bool`\n\t        People with this permission have the ability to override all permissions and any\n\t        channel. This means that despite any overwrites, they will have all permissions\n\t        throughout the entire guild.\n\t    \"\"\"\n", "    view_channel = _(1 << 0)\n\t    view_message_history = _(1 << 1)\n\t    send_messages = _(1 << 2)\n\t    manage_messages = _(1 << 3)\n\t    attach_files = _(1 << 4)\n\t    send_embeds = _(1 << 5)\n\t    add_reactions = _(1 << 6)\n\t    pin_messages = _(1 << 7)\n\t    star_messages = _(1 << 8)\n\t    publish_messages = _(1 << 9)\n", "    modify_channels = _(1 << 10)\n\t    manage_channels = _(1 << 11)\n\t    manage_webhooks = _(1 << 12)\n\t    manage_emojis = _(1 << 13)\n\t    manage_starboard = _(1 << 14)\n\t    manage_guild = _(1 << 15)\n\t    manage_roles = _(1 << 16)\n\t    create_invites = _(1 << 17)\n\t    manage_invites = _(1 << 18)\n\t    use_external_emojis = _(1 << 19)\n", "    change_nickname = _(1 << 20)\n\t    manage_nicknames = _(1 << 21)\n\t    timeout_members = _(1 << 22)\n\t    kick_members = _(1 << 23)\n\t    ban_members = _(1 << 24)\n\t    bulk_delete_messages = _(1 << 25)\n\t    view_audit_log = _(1 << 26)\n\t    privileged_mentions = _(1 << 27)\n\t    connect = _(1 << 28)\n\t    speak = _(1 << 29)\n", "    mute_members = _(1 << 30)\n\t    deafen_members = _(1 << 31)\n\t    administrator = _(1 << 32)\n\t    __default_value__ = (\n\t        view_channel\n\t        | view_message_history\n\t        | send_messages\n\t        | add_reactions\n\t        | star_messages\n\t        | attach_files\n", "        | send_embeds\n\t        | create_invites\n\t        | use_external_emojis\n\t        | change_nickname\n\t        | connect\n\t        | speak\n\t    )\n"]}
{"filename": "adapt/models/member.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .guild import Guild, PartialGuild\n\tfrom .user import PartialUser, User\n\tfrom ..util import parse_datetime\n\tif TYPE_CHECKING:\n\t    from datetime import datetime\n\t    from ..connection import Connection\n\t    from ..types.guild import Member as RawMember\n\t__all__ = ('PartialMember', 'Member')\n", "class PartialMemberMixin:\n\t    __slots__ = ()\n\t    if TYPE_CHECKING:\n\t        _connection: Connection\n\t        guild: PartialGuild\n\t        @property\n\t        def id(self) -> int:\n\t            ...\n\t    @property\n\t    def is_me(self) -> bool:\n", "        \"\"\"Whether this member is the client user.\"\"\"\n\t        return self.id == self._connection.user.id\n\t    async def kick(self) -> None:\n\t        \"\"\"|coro|\n\t        Kicks the member from the guild. You must have the :attr:`.Permissions.kick_members` permission to do this.\n\t        This is a shortcut for calling :meth:`.Guild.kick` with this member.\n\t        \"\"\"\n\t        await self._connection.http.kick_member(self.guild.id, self.id)\n\tclass PartialMember(PartialUser, PartialMemberMixin):\n\t    \"\"\"Represents a partial member of a guild.\n", "    This is useful for performing operations on members without having to fetch them first.\n\t    Attributes\n\t    ----------\n\t    guild: :class:`.PartialGuild`\n\t        The guild that the member is in. This *may* be a partial guild.\n\t    \"\"\"\n\t    __slots__ = ('guild',)\n\t    if TYPE_CHECKING:\n\t        guild: PartialGuild\n\t    def __init__(self, *, guild: PartialGuild, id: int) -> None:\n", "        super().__init__(connection=guild._connection, id=id)\n\t        self.guild = guild\n\t    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} id={self.id} guild_id={self.guild.id}>'\n\tclass Member(User, PartialMemberMixin):\n\t    \"\"\"Represents a member of a guild.\"\"\"\n\t    __slots__ = (\n\t        'guild',\n\t        'nick',\n\t        '_roles',\n", "        'joined_at',\n\t    )\n\t    if TYPE_CHECKING:\n\t        guild: Guild\n\t        nick: str | None\n\t        _roles: set[int]\n\t        joined_at: datetime\n\t    def __init__(self, *, guild: Guild, data: RawMember) -> None:\n\t        super().__init__(connection=guild._connection, data=data)\n\t        self.guild: Guild = guild\n", "    def _update(self, data: RawMember) -> None:\n\t        super()._update(data)\n\t        self.nick = data['nick']\n\t        self.joined_at = parse_datetime(data['joined_at'])\n\t        roles = data['roles']\n\t        if roles is not None:\n\t            self._roles = set(roles)\n\t    @property\n\t    def user(self) -> User:\n\t        \"\"\":class:`User`: The user that this member represents.\n", "        Although members are a subclass of users, this property is provided for completeness.\n\t        \"\"\"\n\t        return self._connection.get_user(self.id) or self\n\t    @property\n\t    def display_name(self) -> str:\n\t        \"\"\":class:`str`: The member's display name.\n\t        This is their nickname if they have one, otherwise it is their username.\n\t        \"\"\"\n\t        return self.nick or self.username\n\t    def __repr__(self) -> str:\n", "        return f'<{self.__class__.__name__} id={self.id} guild_id={self.guild.id}>'\n"]}
{"filename": "adapt/models/ready.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .channel import DMChannel\n\tfrom .enums import RelationshipType\n\tfrom .guild import Guild\n\tfrom .user import ClientUser, User, Relationship\n\tif TYPE_CHECKING:\n\t    from ..connection import Connection\n\t    from ..types.ws import ReadyEvent as RawReadyEvent\n\t__all__ = ('ReadyEvent',)\n", "class ReadyEvent:\n\t    \"\"\"Represents the ready event from the gateway. This event is sent when the client is ready to receive events.\n\t    .. note::\n\t        Just like all models, this class is not meant to be constructed by the user. However, if for some reason you\n\t        need to construct this class, it should be known that the constructor mutates the given connection state, which\n\t        could lead to unexpected behaviour.\n\t    Attributes\n\t    ----------\n\t    session_id: :class:`str`\n\t        The session ID used to identify the current websocket connection.\n", "    user: :class:`.ClientUser`\n\t        The client user object.\n\t    guilds: list[:class:`.Guild`]\n\t        A list of guilds the client is in.\n\t    dm_channels: list[:class:`.DMChannel`]\n\t        A list of DM channels the client is in.\n\t    presences: list[:class:`.Presence`]\n\t        A list of presences the client has.\n\t    relationships: list[:class:`.Relationship`]\n\t        A list of relationships the client has with other users.\n", "    \"\"\"\n\t    __slots__ = (\n\t        '_connection',\n\t        'session_id',\n\t        'user',\n\t        'guilds',\n\t        'dm_channels',\n\t        'presences',\n\t        'relationships',\n\t    )\n", "    _connection: Connection\n\t    session_id: str\n\t    user: ClientUser\n\t    guilds: list[Guild]\n\t    dm_channels: list[DMChannel]\n\t    relationships: list[Relationship]\n\t    # TODO\n\t    presences: list[Presence]\n\t    def __init__(self, *, connection: Connection, data: RawReadyEvent) -> None:\n\t        self._connection = connection\n", "        self.session_id = data['session_id']\n\t        self.user = connection.user = ClientUser(connection=connection, data=data['user'])\n\t        # Slight optimization to avoid unnecessary updates if users are already cached\n\t        relationships: list[Relationship] = []\n\t        seen: set[int] = set(connection._users)\n\t        for relationship in data['relationships']:\n\t            user_data = relationship['user']\n\t            user_id = user_data['id']\n\t            if user_id not in seen:\n\t                connection.add_user(User(connection=connection, data=user_data))\n", "                seen.add(user_id)\n\t            full = connection.update_relationship(user_id=user_id, type=RelationshipType(relationship['type']))\n\t            relationships.append(full)\n\t        self.relationships = relationships\n\t        self.guilds = [self._connection.add_raw_guild(guild) for guild in data['guilds']]\n\t        self.dm_channels = [self._connection.add_raw_dm_channel(dm) for dm in data['dm_channels']]\n\t    def __repr__(self) -> str:\n\t        return f'<ReadyEvent session_id={self.session_id!r} user={self.user!r}>'\n"]}
{"filename": "adapt/models/user.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .asset import Asset\n\tfrom .bitflags import UserFlags\n\tfrom .channel import Messageable\n\tfrom .enums import ChannelType\n\tfrom .object import AdaptObject\n\tfrom ..util import deprecated, find, MISSING\n\tif TYPE_CHECKING:\n\t    from typing import Any, Self\n", "    from .channel import DMChannel\n\t    from .enums import RelationshipType\n\t    from ..connection import Connection\n\t    from ..types.user import ClientUser as RawClientUser, User as RawUser\n\t    from ..util import IOSource\n\t__all__ = ('ClientUser', 'PartialUser', 'User', 'Relationship')\n\tclass BaseUser:\n\t    if TYPE_CHECKING:\n\t        _connection: Connection\n\t        username: str\n", "        discriminator: int\n\t        _avatar: str | None\n\t        _banner: str | None\n\t        bio: str | None\n\t        _flags: int\n\t    def _update(self, data: RawUser) -> None:\n\t        self.username = data['username']\n\t        self.discriminator = data['discriminator']\n\t        self._avatar = data['avatar']\n\t        self._banner = data['banner']\n", "        self.bio = data['bio']\n\t        self._flags = data['flags']\n\t    if TYPE_CHECKING:\n\t        @property\n\t        def id(self) -> int:\n\t            raise NotImplementedError\n\t    @property\n\t    @deprecated(\n\t        use='username',\n\t        reason='This property is officially named \"username\" and it is a good practice to use that instead of \"name\".',\n", "    )\n\t    def name(self) -> str:\n\t        \"\"\":class:`str`: The user's username. This is an alias for :attr:`username`.\n\t        .. deprecated:: 0.1.0\n\t            This property is officially named :attr:`username` and it is a good practice to use that instead of \"name\".\n\t        \"\"\"\n\t        return self.username\n\t    @property\n\t    def padded_discriminator(self) -> str:\n\t        \"\"\":class:`str`: The user's discriminator with leading zeros.\"\"\"\n", "        return f'{self.discriminator:0>4}'\n\t    @property\n\t    def tag(self) -> str:\n\t        \"\"\":class:`str`: The user's tag. (``username#discriminator``)\"\"\"\n\t        return f'{self.username}#{self.padded_discriminator}'\n\t    @property\n\t    def mention(self) -> str:\n\t        \"\"\":class:`str`: The string used to mention the user. (``<@id>``)\"\"\"\n\t        return f'<@{self.id}>'\n\t    @property\n", "    def display_name(self) -> str:\n\t        \"\"\":class:`str`: The name displayed to refer to the user.\n\t        This is the same as :attr:`username` for users. For members, this is overridden to return the member's nickname\n\t        (or username if the member has no nickname).\n\t        \"\"\"\n\t        return self.username\n\t    @property\n\t    def avatar(self) -> Asset:\n\t        \"\"\":class:`.Asset`: The user's avatar.\"\"\"\n\t        return Asset(connection=self._connection, url=self._avatar)\n", "    @property\n\t    def banner(self) -> Asset:\n\t        \"\"\":class:`.Asset`: The user's banner.\"\"\"\n\t        return Asset(connection=self._connection, url=self._banner)\n\t    @property\n\t    def flags(self) -> UserFlags:\n\t        \"\"\":class:`.UserFlags`: The user's flags.\"\"\"\n\t        return UserFlags(self._flags)\n\t    @property\n\t    def is_bot(self) -> bool:\n", "        \"\"\":class:`bool`: Whether the user is a bot account.\"\"\"\n\t        return self.flags.bot\n\t    def __str__(self) -> str:\n\t        return self.tag\n\t    def __repr__(self) -> str:\n\t        return (\n\t            f'<{self.__class__.__name__} id={self.id!r} username={self.username!r} '\n\t            f'discriminator={self.discriminator!r}>'\n\t        )\n\t    def __format__(self, format_spec: str) -> str:\n", "        if format_spec == 'd':\n\t            return self.display_name\n\t        elif format_spec == 'u':\n\t            return self.username\n\t        elif format_spec == '@':\n\t            return self.mention\n\t        return self.tag.__format__(format_spec)\n\tclass ClientUser(BaseUser, AdaptObject):\n\t    \"\"\"Represents the user object for the client user.\n\t    Attributes\n", "    ----------\n\t    username: :class:`str`\n\t        The user's username.\n\t    discriminator: :class:`int`\n\t        The user's discriminator.\n\t    bio: :class:`str`\n\t        The user's custom bio.\n\t    email: :class:`str`\n\t        The user's email.\n\t    \"\"\"\n", "    __slots__ = (\n\t        '_connection',\n\t        'username',\n\t        'discriminator',\n\t        '_avatar',\n\t        '_banner',\n\t        'bio',\n\t        '_flags',\n\t        'email',\n\t    )\n", "    if TYPE_CHECKING:\n\t        email: str\n\t    def __init__(self, *, connection: Connection, data: RawClientUser) -> None:\n\t        self._connection = connection\n\t        self._update(data)\n\t    def _update(self, data: RawClientUser) -> None:\n\t        super()._update(data)\n\t        self._id = data['id']\n\t        self.email = data['email']\n\t    async def edit(\n", "        self,\n\t        *,\n\t        username: str = MISSING,\n\t        avatar: IOSource | None = MISSING,\n\t        banner: IOSource | None = MISSING,\n\t        bio: IOSource | None = MISSING,\n\t    ) -> Self:\n\t        \"\"\"|coro|\n\t        Updates the client's user information. Only the parameters passed will be updated.\n\t        Parameters\n", "        ----------\n\t        username: :class:`str`\n\t            The new username to use.\n\t        avatar: :class:`bytes`, path-like object, file-like object, or ``None``\n\t            The new avatar to use. If ``None``, the avatar will be removed.\n\t        banner: :class:`bytes`, path-like object, file-like object, or ``None``\n\t            The new banner to use. If ``None``, the banner will be removed.\n\t        bio: :class:`str` or ``None``\n\t            The new bio to use. If ``None``, the bio will be removed.\n\t        Returns\n", "        -------\n\t        :class:`.ClientUser`\n\t            The updated client user.\n\t        \"\"\"\n\t        self._update(await self._connection.http.edit_authenticated_user(\n\t            username=username,\n\t            avatar=avatar,\n\t            banner=banner,\n\t            bio=bio,\n\t        ))\n", "        return self\n\t    async def delete(self, *, password: str) -> None:\n\t        \"\"\"|coro|\n\t        Deletes the client's user account. This is irreversible.\n\t        .. note::\n\t            The account must be a user account; if it is a bot account, the bot account can only be deleted by the\n\t            user account that owns it.\n\t        Parameters\n\t        ----------\n\t        password: :class:`str`\n", "            The password of the user, required for security purposes.\n\t        Raises\n\t        ------\n\t        TypeError\n\t            The client user is a bot account.\n\t        \"\"\"\n\t        if self.is_bot:\n\t            raise TypeError('Cannot delete a bot account.')\n\t        await self._connection.http.delete_authenticated_user(password=password)\n\tclass PartialUser(AdaptObject, Messageable):\n", "    \"\"\"A partial user object which operates with only an ID.\n\t    This is useful for performing operations on users without having to fetch them first.\n\t    \"\"\"\n\t    __slots__ = ('_connection', '_dm_channel')\n\t    def __init__(self, *, connection: Connection, id: int) -> None:\n\t        self._id = id\n\t        self._connection = connection\n\t        self._dm_channel: DMChannel | None = None\n\t    def _update(self, data: dict) -> None:\n\t        if id := data.get('id'):\n", "            self._id = id\n\t    @property\n\t    def dm_channel(self) -> DMChannel | None:\n\t        \"\"\":class:`.DMChannel`: The DM channel with this user, if it exists in the cache.\"\"\"\n\t        if channel := self._dm_channel:\n\t            return channel\n\t        if found := find(\n\t            self._connection._dm_channels.values(),\n\t            lambda dm: dm.type is ChannelType.dm and dm.recipient == self,\n\t        ):\n", "            self._dm_channel = found\n\t            return found\n\t    async def create_dm(self) -> DMChannel:\n\t        \"\"\"|coro|\n\t        Creates a DM channel with this user. This makes the API call despite whether a DM channel already exists.\n\t        Returns\n\t        -------\n\t        :class:`.DMChannel`\n\t            The DM channel created.\n\t        \"\"\"\n", "        channel = await self._connection.http.create_user_dm_channel(self.id)\n\t        self._dm_channel = resolved = self._connection.add_raw_dm_channel(channel)\n\t        return resolved\n\t    async def _get_channel(self) -> DMChannel:\n\t        if self.dm_channel is None:\n\t            await self.create_dm()\n\t        return self.dm_channel\n\t    @property\n\t    def relationship(self) -> Relationship | None:\n\t        \"\"\":class:`.Relationship`: The relationship between you and this user.\n", "        Returns ``None`` if no relationship exists.\n\t        \"\"\"\n\t        return self._connection.get_relationship(self.id)\n\t    async def accept_friend_request(self) -> Relationship:\n\t        \"\"\"|coro|\n\t        Accepts the incoming friend request from this user.\n\t        Returns\n\t        -------\n\t        :class:`.Relationship`\n\t            The relationship created from accepting the friend request.\n", "        Raises\n\t        ------\n\t        TypeError\n\t            If there is no incoming friend request from this user.\n\t        \"\"\"\n\t        if self.relationship.type is not RelationshipType.incoming:\n\t            raise TypeError('No incoming friend request from this user')\n\t        relationship = await self._connection.http.accept_friend_request(self.id)\n\t        return self._connection.update_raw_relationship(relationship)\n\t    async def block(self) -> Relationship:\n", "        \"\"\"|coro|\n\t        Blocks this user.\n\t        Returns\n\t        -------\n\t        :class:`.Relationship`\n\t            The relationship created from blocking the user.\n\t        \"\"\"\n\t        relationship = await self._connection.http.block_user(self.id)\n\t        return self._connection.update_raw_relationship(relationship)\n\t    async def _delete_relationship_if_of_type(self, type: RelationshipType) -> None:\n", "        if self.relationship is not None and self.relationship.type is type:\n\t            await self.relationship.delete()\n\t    async def unblock(self) -> None:\n\t        \"\"\"|coro|\n\t        Unblocks this user. This is a checked-equivalent of :meth:`.Relationship.delete`.\n\t        Raises\n\t        ------\n\t        TypeError\n\t            If this user is not blocked.\n\t        \"\"\"\n", "        await self._delete_relationship_if_of_type(RelationshipType.blocked)\n\t    async def revoke_friend_request(self) -> None:\n\t        \"\"\"|coro|\n\t        Revokes the outgoing friend request to this user. This is a checked-equivalent of\n\t        :meth:`.Relationship.delete`.\n\t        Raises\n\t        ------\n\t        TypeError\n\t            If there is no outgoing friend request to this user.\n\t        \"\"\"\n", "        await self._delete_relationship_if_of_type(RelationshipType.outgoing)\n\t    async def decline_friend_request(self) -> None:\n\t        \"\"\"|coro|\n\t        Declines the incoming friend request from this user. This is a checked-equivalent of\n\t        :meth:`.Relationship.delete`.\n\t        Raises\n\t        ------\n\t        TypeError\n\t            If there is no incoming friend request from this user.\n\t        \"\"\"\n", "        await self._delete_relationship_if_of_type(RelationshipType.incoming)\n\t    async def remove_friend(self) -> None:\n\t        \"\"\"|coro|\n\t        Removes this user as a friend. This is a checked-equivalent of :meth:`.Relationship.delete`.\n\t        Raises\n\t        ------\n\t        TypeError\n\t            If this user is not a friend.\n\t        \"\"\"\n\t        await self._delete_relationship_if_of_type(RelationshipType.friend)\n", "class User(BaseUser, PartialUser):\n\t    \"\"\"Represents an Adapt user.\n\t    Attributes\n\t    ----------\n\t    username: :class:`str`\n\t        The user's username.\n\t    discriminator: :class:`int`\n\t        The user's discriminator.\n\t    bio: :class:`str`\n\t        The user's custom bio.\n", "    \"\"\"\n\t    __slots__ = (\n\t        'username',\n\t        'discriminator',\n\t        '_avatar',\n\t        '_banner',\n\t        'bio',\n\t        '_flags',\n\t    )\n\t    def __init__(self, *, connection: Connection, data: RawUser) -> None:\n", "        super().__init__(connection=connection, id=data['id'])\n\t        self._update(data)\n\t    def _update(self, data: RawUser) -> None:\n\t        BaseUser._update(self, data)\n\t    async def send_friend_request(self) -> Relationship:\n\t        \"\"\"|coro|\n\t        Sends a friend request to this user.\n\t        Returns\n\t        -------\n\t        :class:`.Relationship`\n", "            The relationship created from sending the friend request.\n\t        \"\"\"\n\t        relationship = await self._connection.http.send_friend_request(\n\t            username=self.username,\n\t            discriminator=self.discriminator,\n\t        )\n\t        return self._connection.update_raw_relationship(relationship)\n\tclass Relationship:\n\t    \"\"\"Represents a relationship between you, the client user, and another user.\"\"\"\n\t    __slots__ = ('_connection', '_user_id', '_type')\n", "    def __init__(self, *, connection: Connection, user_id: int, type: RelationshipType) -> None:\n\t        self._connection = connection\n\t        self._user_id = user_id\n\t        self._type = type\n\t    @property\n\t    def user(self) -> User:\n\t        \"\"\":class:`.User`: The user that this relationship is with.\"\"\"\n\t        return self._connection.get_user(self._user_id)\n\t    @property\n\t    def type(self) -> RelationshipType:\n", "        \"\"\":class:`.RelationshipType`: The type of this relationship.\"\"\"\n\t        return self._type\n\t    async def delete(self) -> None:\n\t        \"\"\"|coro|\n\t        Deletes this relationship:\n\t        - If the relationship type is ``friend``, this will unfriend the user.\n\t        - If the relationship type is ``outgoing_request``, this will cancel the outgoing friend request.\n\t        - If the relationship type is ``incoming_request``, this will decline the incoming friend request.\n\t        - If the relationship type is ``blocked``, this will unblock the user.\n\t        \"\"\"\n", "        await self._connection.http.delete_relationship(self._user_id)\n\t    async def accept(self) -> Self:\n\t        \"\"\"|coro|\n\t        Accepts this relationship if it is an incoming friend request. This is equivalent to calling\n\t        :meth:`.User.accept_friend_request`.\n\t        Returns\n\t        -------\n\t        :class:`.Relationship`\n\t            The relationship created from accepting the friend request.\n\t        Raises\n", "        ------\n\t        TypeError\n\t            If the relationship type is not ``incoming_request``.\n\t        \"\"\"\n\t        return await self.user.accept_friend_request()\n\t    def __repr__(self) -> str:\n\t        return f'<{self.__class__.__name__} user={self.user!r} type={self.type!r}>'\n\t    @property\n\t    def _key(self) -> tuple[int, RelationshipType]:\n\t        return self._user_id, self._type\n", "    def __hash__(self) -> int:\n\t        return hash(self._key)\n\t    def __eq__(self, other: Any) -> bool:\n\t        return isinstance(other, self.__class__) and other._key == self._key\n"]}
{"filename": "adapt/types/role.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TypedDict\n\tfrom . import Snowflake\n\t__all__ = ('PermissionPair', 'Role')\n\tclass PermissionPair(TypedDict):\n\t    allow: int\n\t    deny: int\n\tclass Role(TypedDict):\n\t    id: Snowflake\n\t    guild_id: Snowflake\n", "    name: str\n\t    color: int | None\n\t    pemissions: PermissionPair\n\t    position: int\n\t    flags: int\n"]}
{"filename": "adapt/types/channel.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Literal, TypedDict, TypeAlias\n\tfrom . import Snowflake\n\tfrom .role import PermissionPair\n\t__all__ = (\n\t    'GuildChannelType',\n\t    'CreateGuildChannelPayload',\n\t    'CreateDMChannelPayload',\n\t    'DMChannelType',\n\t    'ChannelType',\n", "    'PermissionOverwrite',\n\t    'GuildChannel',\n\t    'DMChannel',\n\t    'Channel',\n\t)\n\tGuildChannelType: TypeAlias = Literal['text', 'announcement', 'voice', 'category']\n\tDMChannelType: TypeAlias = Literal['dm', 'group']\n\tChannelType: TypeAlias = GuildChannelType | DMChannelType\n\tclass _CreateGuildChannelPayloadRequired(TypedDict):\n\t    type: GuildChannelType\n", "    name: str\n\t    icon: str | None\n\t    parent_id: Snowflake | None\n\t    overwrites: list[PermissionOverwrite] | None\n\tclass CreateGuildChannelPayload(_CreateGuildChannelPayloadRequired, total=False):\n\t    # Text, Announcement\n\t    topic: str | None\n\t    icon: str | None\n\t    # Voice\n\t    user_limit: int\n", "class _GuildChannelRequired(TypedDict):\n\t    type: GuildChannelType\n\t    id: Snowflake\n\t    guild_id: Snowflake\n\t    name: str\n\t    position: int\n\t    overwrites: list[PermissionOverwrite]\n\t    parent_id: Snowflake | None\n\tclass GuildChannel(_GuildChannelRequired, total=False):\n\t    # TextBasedGuildChannelInfo\n", "    topic: str | None\n\t    nsfw: bool\n\t    locked: bool\n\t    slowmode: int\n\t    # GuildChannelInfo::Voice\n\t    user_limit: int\n\tclass PermissionOverwrite(PermissionPair):\n\t    id: Snowflake\n\tclass _CreateDMChannelPayloadRequired(TypedDict):\n\t    type: DMChannelType\n", "class CreateDMChannelPayload(_CreateDMChannelPayloadRequired, total=False):\n\t    # DM\n\t    recipient_id: Snowflake\n\t    # Group DM\n\t    name: str\n\t    recipient_ids: list[Snowflake]\n\tclass _DMChannelRequired(TypedDict):\n\t    type: DMChannelType\n\t    id: Snowflake\n\t    recipient_ids: list[Snowflake]\n", "class DMChannel(_DMChannelRequired, total=False):\n\t    # Group DM\n\t    name: str\n\t    topic: str | None\n\t    icon: str | None\n\t    owner_id: Snowflake\n\tChannel: TypeAlias = GuildChannel | DMChannel\n"]}
{"filename": "adapt/types/guild.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TypedDict\n\tfrom . import Snowflake, Timestamp\n\tfrom .channel import GuildChannel\n\tfrom .role import Role\n\tfrom .user import User\n\t__all__ = (\n\t    'Member',\n\t    'GuildMemberCount',\n\t    'PartialGuild',\n", "    'Guild',\n\t)\n\tclass Member(User):\n\t    guild_id: Snowflake\n\t    nick: str | None\n\t    roles: list[Snowflake] | None\n\t    joined_at: Timestamp\n\tclass GuildMemberCount(TypedDict):\n\t    total: int\n\t    online: int | None\n", "class EditOwnMemberPayload(TypedDict, total=False):\n\t    nick: str | None\n\tclass EditMemberPayload(TypedDict, total=False):\n\t    nick: str | None\n\t    roles: list[Snowflake] | None\n\tclass PartialGuild(TypedDict):\n\t    id: int\n\t    name: str\n\t    description: str | None\n\t    icon: str | None\n", "    banner: str | None\n\t    owner_id: int\n\t    flags: int\n\t    member_count: GuildMemberCount | None\n\t    vanity_url: str | None\n\tclass Guild(PartialGuild):\n\t    members: list[Member] | None\n\t    roles: list[Role] | None\n\t    channel: list[GuildChannel] | None\n\tclass _CreateGuildPayloadRequired(TypedDict):\n", "    name: str\n\tclass CreateGuildPayload(_CreateGuildPayloadRequired, total=False):\n\t    description: str | None\n\t    icon: str | None\n\t    banner: str | None\n\t    public: bool\n\t    nonce: str | None\n\tclass EditGuildPayload(TypedDict, total=False):\n\t    name: str | None\n\t    description: str | None\n", "    icon: str | None\n\t    banner: str | None\n\t    public: bool | None\n\tclass DeleteGuildPayload(TypedDict):\n\t    password: str\n"]}
{"filename": "adapt/types/message.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Literal, TypeAlias, TypedDict\n\tfrom . import Snowflake, Timestamp\n\tfrom .guild import Member\n\tfrom .user import User\n\t__all__ = (\n\t    'EmbedType',\n\t    'MessageEmbedFieldAlignment',\n\t    'EmbedAuthor',\n\t    'EmbedFooter',\n", "    'EmbedField',\n\t    'Embed',\n\t    'Attachment',\n\t    'MessageType',\n\t    'Message',\n\t    'CreateMessagePayload',\n\t    'EditMessagePayload',\n\t    'MessageHistoryQuery',\n\t)\n\tEmbedType: TypeAlias = Literal['rich', 'image', 'video', 'meta']\n", "MessageEmbedFieldAlignment: TypeAlias = Literal['left', 'center', 'right', 'inline']\n\tclass _EmbedAuthorRequired(TypedDict):\n\t    name: str\n\tclass EmbedAuthor(_EmbedAuthorRequired, total=False):\n\t    url: str | None\n\t    icon_url: str | None\n\tclass _EmbedFooterRequired(TypedDict):\n\t    text: str\n\tclass EmbedFooter(_EmbedFooterRequired, total=False):\n\t    icon_url: str | None\n", "class _EmbedFieldRequired(TypedDict):\n\t    name: str\n\t    value: str\n\tclass EmbedField(_EmbedFieldRequired, total=False):\n\t    align: MessageEmbedFieldAlignment\n\tclass _EmbedRequired(TypedDict):\n\t    type: EmbedType\n\tclass Embed(_EmbedRequired, total=False):\n\t    title: str | None\n\t    description: str | None\n", "    url: str | None\n\t    timestamp: Timestamp | None\n\t    color: int | None\n\t    hue: int | None\n\t    author: EmbedAuthor | None\n\t    footer: EmbedFooter | None\n\t    image: str | None\n\t    thumbnail: str | None\n\t    fields: list[EmbedField] | None\n\tclass _AttachmentRequired(TypedDict):\n", "    id: Snowflake\n\t    filename: str\n\t    size: int\n\t    url: str\n\tclass Attachment(_AttachmentRequired, total=False):\n\t    description: str | None\n\tMessageType: TypeAlias = Literal['default', 'join', 'leave', 'pin']\n\tclass _MessageRequired(TypedDict):\n\t    id: Snowflake\n\t    revision_id: Snowflake | None\n", "    channel_id: Snowflake\n\t    author_id: Snowflake | None\n\t    author: Member | User | None\n\t    type: MessageType\n\t    content: str | None\n\t    embeds: list[Embed]\n\t    attachments: list[Attachment]\n\t    flags: int\n\t    starts: int\n\tclass Message(_MessageRequired, total=False):\n", "    # Join, Leave\n\t    user_id: Snowflake\n\t    # Pin\n\t    pinned_message_id: Snowflake\n\t    pinned_by: Snowflake\n\tclass CreateMessagePayload(TypedDict, total=False):\n\t    content: str | None\n\t    embeds: list[Embed] | None\n\t    nonce: str | None\n\tclass EditMessagePayload(TypedDict, total=False):\n", "    content: str | None\n\t    embeds: list[Embed] | None\n\tclass MessageHistoryQuery(TypedDict, total=False):\n\t    before: int\n\t    after: int\n\t    limit: int\n\t    user_id: Snowflake\n\t    oldest_first: bool\n"]}
{"filename": "adapt/types/__init__.py", "chunked_list": ["from typing import TypeAlias\n\tfrom . import channel, guild, message, presence, role, user, ws\n\tSnowflake: TypeAlias = int\n\tTimestamp: TypeAlias = str\n\tdel TypeAlias\n"]}
{"filename": "adapt/types/ws.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Generic, Literal, TypedDict, TypeAlias, TypeVar\n\tfrom . import Snowflake\n\tfrom .channel import Channel, DMChannel\n\tfrom .guild import Guild, Member, PartialGuild\n\tfrom .message import Message\n\tfrom .presence import Presence\n\tfrom .role import Role\n\tfrom .user import ClientUser, User, Relationship\n\tE = TypeVar('E', bound=str)\n", "D = TypeVar('D', bound=TypedDict)\n\tT = TypeVar('T')\n\t__all__ = (\n\t    'ReadyEvent',\n\t    'UserUpdateEvent',\n\t    'GuildUpdateEvent',\n\t    'ChannelUpdateEvent',\n\t    'RoleUpdateEvent',\n\t    'MemberUpdateEvent',\n\t    'PresenceUpdateEvent',\n", "    'UserDeleteEvent',\n\t    'GuildCreateEvent',\n\t    'MemberRemoveType',\n\t    'GuildRemoveEvent',\n\t    'MessageCreateEvent',\n\t    'InboundMessage',\n\t)\n\tclass _InboundEvent(TypedDict, Generic[E]):\n\t    event: E\n\tclass _InboundEventWithData(_InboundEvent[E], Generic[E, D]):\n", "    data: D\n\tclass ReadyEvent(TypedDict):\n\t    session_id: str\n\t    user: ClientUser\n\t    guilds: list[Guild]\n\t    dm_channels: list[DMChannel]\n\t    presences: list[Presence]\n\t    relationships: list[Relationship]\n\tclass _UpdateEvent(TypedDict, Generic[T]):\n\t    before: T\n", "    after: T\n\tUserUpdateEvent: TypeAlias = _UpdateEvent[User]\n\tGuildUpdateEvent: TypeAlias = _UpdateEvent[PartialGuild]\n\tChannelUpdateEvent: TypeAlias = _UpdateEvent[Channel]\n\tRoleUpdateEvent: TypeAlias = _UpdateEvent[Role]\n\tMemberUpdateEvent: TypeAlias = _UpdateEvent[Member]\n\tPresenceUpdateEvent: TypeAlias = _UpdateEvent[Presence]\n\tclass UserDeleteEvent(TypedDict):\n\t    user_id: Snowflake\n\tclass GuildCreateEvent(TypedDict):\n", "    guild: Guild\n\t    nonce: str | None\n\tMemberRemoveType: TypeAlias = Literal['delete', 'leave', 'kick', 'ban']\n\tclass _MemberRemoveInfoRequired(TypedDict):\n\t    type: MemberRemoveType\n\tclass _MemberRemoveInfo(_MemberRemoveInfoRequired, total=False):\n\t    moderator_id: Snowflake\n\tclass GuildRemoveEvent(_MemberRemoveInfo):\n\t    guild_id: Snowflake\n\tclass MessageCreateEvent(TypedDict):\n", "    message: Message\n\t    nonce: str | None\n\t# harmony -> adapt.py, this is modeled as **OutboundMessage** in essence!\n\tInboundMessage: TypeAlias = (\n\t    _InboundEvent[Literal['hello', 'ping', 'pong']]\n\t    | _InboundEventWithData[Literal['ready'], ReadyEvent]\n\t    | _InboundEventWithData[Literal['user_update'], UserUpdateEvent]\n\t    | _InboundEventWithData[Literal['user_delete'], UserDeleteEvent]\n\t    | _InboundEventWithData[Literal['channel_update'], ChannelUpdateEvent]\n\t    | _InboundEventWithData[Literal['role_update'], RoleUpdateEvent]\n", "    | _InboundEventWithData[Literal['member_update'], MemberUpdateEvent]\n\t    | _InboundEventWithData[Literal['presence_update'], PresenceUpdateEvent]\n\t    | _InboundEventWithData[Literal['guild_create'], GuildCreateEvent]\n\t    | _InboundEventWithData[Literal['guild_update'], GuildUpdateEvent]\n\t    | _InboundEventWithData[Literal['guild_remove'], GuildRemoveEvent]\n\t    | _InboundEventWithData[Literal['message_create'], MessageCreateEvent]\n\t)\n"]}
{"filename": "adapt/types/presence.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Literal, TypedDict, TypeAlias\n\tfrom . import Snowflake, Timestamp\n\t__all__ = (\n\t    'PresenceStatus',\n\t    'Device',\n\t    'Presence',\n\t)\n\tPresenceStatus: TypeAlias = Literal['online', 'idle', 'dnd', 'offline']\n\tDevice: TypeAlias = Literal['desktop', 'mobile', 'web']\n", "class Presence(TypedDict):\n\t    user_id: Snowflake\n\t    status: PresenceStatus\n\t    custom_status: str | None\n\t    devices: int\n\t    online_since: Timestamp | None\n"]}
{"filename": "adapt/types/user.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Literal, TypedDict, TypeAlias\n\tfrom . import Snowflake\n\t__all__ = (\n\t    'TokenRetrievalMethod',\n\t    'RelationshipType',\n\t    'LoginRequest',\n\t    'LoginResponse',\n\t    'CreateUserPayload',\n\t    'CreateUserResponse',\n", "    'User',\n\t    'ClientUser',\n\t    'Relationship',\n\t)\n\tTokenRetrievalMethod: TypeAlias = Literal['new', 'revoke', 'reuse']\n\tclass _LoginRequestRequired(TypedDict):\n\t    email: str\n\t    password: str\n\tclass LoginRequest(_LoginRequestRequired, total=False):\n\t    method: TokenRetrievalMethod\n", "class LoginResponse(TypedDict):\n\t    user_id: Snowflake\n\t    token: str\n\tclass CreateUserPayload(TypedDict):\n\t    username: str\n\t    email: str\n\t    password: str\n\tclass CreateUserResponse(TypedDict):\n\t    id: Snowflake\n\t    token: str\n", "class _EditUserPayloadRequired(TypedDict):\n\t    username: str\n\tclass EditUserPayload(_EditUserPayloadRequired, total=False):\n\t    avatar: str | None\n\t    banner: str | None\n\t    bio: str | None\n\tclass SendFriendRequestPayload(TypedDict):\n\t    username: str\n\t    discriminator: int\n\tclass User(TypedDict):\n", "    id: Snowflake\n\t    username: str\n\t    discriminator: int\n\t    avatar: str | None\n\t    banner: str | None\n\t    bio: str | None\n\t    flags: int\n\tclass ClientUser(User):\n\t    email: str | None\n\t    dm_privacy: int\n", "    group_dm_privacy: int\n\t    friend_request_privacy: int\n\tRelationshipType: TypeAlias = Literal['friend', 'outgoing_request', 'incoming_request', 'blocked']\n\tclass Relationship(TypedDict):\n\t    user: User\n\t    type: RelationshipType\n"]}
{"filename": "examples/ping_pong.py", "chunked_list": ["\"\"\"Example of a simple bot that responds to any message that says \"ping\" with \"Pong!\".\"\"\"\n\timport adapt\n\tclient = adapt.Client()\n\t# Ready event handler. This is called when the client is ready to start receiving events.\n\t@adapt.once\n\t@client.event\n\tasync def on_ready(ready):\n\t    print(f'Ready as {ready.user}')\n\t# Message event handler. This is called when a message is received.\n\t@client.event\n", "async def on_message(message):\n\t    # Ignore messages sent by bots\n\t    if message.author.is_bot:\n\t        return\n\t    # If the message content is \"ping\", respond with \"Pong!\".\n\t    if message.content == 'ping':\n\t        await message.channel.send('Pong!')\n\t# Run the client with your bot token.\n\tclient.run('token')\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# This file only contains a selection of the most common options. For a full\n\t# list see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\t# -- Path setup --------------------------------------------------------------\n\t# If extensions (or modules to document with autodoc) are in another directory,\n\t# add these directories to sys.path here. If the directory is relative to the\n\t# documentation root, use os.path.abspath to make it absolute, like shown here.\n\t#\n", "import os\n\timport sys\n\tsys.path.insert(0, os.path.abspath('.'))\n\tsys.path.insert(0, os.path.abspath('..'))\n\t# -- Project information -----------------------------------------------------\n\tproject = 'adapt.py'\n\tcopyright = '2023, jay3332'\n\tauthor = 'jay3332'\n\t# The full version, including alpha/beta/rc tags\n\trelease = '0.0.0'\n", "# -- General configuration ---------------------------------------------------\n\t# Add any Sphinx extension module names here, as strings. They can be\n\t# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n\t# ones.\n\textensions = [\n\t    'sphinx.ext.autodoc',\n\t    'sphinx.ext.extlinks',\n\t    'sphinx.ext.intersphinx',\n\t    'sphinx.ext.napoleon',\n\t]\n", "autodoc_typehints = 'none'\n\tnapoleon_google_docstring = False\n\tnapoleon_numpy_docstring = True\n\t# Add any paths that contain templates here, relative to this directory.\n\ttemplates_path = []\n\trst_prolog = \"\"\"\n\t.. |coro| replace:: This function is a |coroutine_link|_.\n\t.. |enum| replace:: This is an |enum_link|_.\n\t.. |bitflags| replace:: This is represented using :class:`.Bitflags`.\n\t.. |coroutine_link| replace:: *coroutine*\n", ".. |enum_link| replace:: *enum*\n\t.. _coroutine_link: https://docs.python.org/3/library/asyncio-task.html#coroutine\n\t.. _enum_link: https://docs.python.org/3/library/enum.html#enum.Enum\n\t\"\"\"\n\tintersphinx_mapping = {\n\t    \"py\": (\"https://docs.python.org/3\", None),\n\t    \"aio\": ('https://docs.aiohttp.org/en/stable/', None),\n\t}\n\t# List of patterns, relative to source directory, that match files and\n\t# directories to ignore when looking for source files.\n", "# This pattern also affects html_static_path and html_extra_path.\n\texclude_patterns = []\n\tpygments_style = \"friendly\"\n\t# -- Options for HTML output -------------------------------------------------\n\t# The theme to use for HTML and HTML Help pages.  See the documentation for\n\t# a list of builtin themes.\n\t#\n\thtml_theme = 'furo'\n\thtml_theme_options = {}\n\t# Add any paths that contain custom static files (such as style sheets) here,\n", "# relative to this directory. They are copied after the builtin static files,\n\t# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n\t# html_static_path = [\"./_static\"]\n"]}
