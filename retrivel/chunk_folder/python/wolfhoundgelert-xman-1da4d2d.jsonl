{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\timport re\n\twith open('src/xman/__init__.py') as f:\n\t    version_match = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', f.read(), re.MULTILINE)\n\t    if version_match:\n\t        version = version_match.group(1)\n\t    else:\n\t        raise RuntimeError(\"Version not found!\")\n\twith open('src/requirements.txt') as f:\n\t    requirements = f.read().splitlines()\n", "setup(\n\t    name='xMan',\n\t    version=version,\n\t    packages=['xman'],\n\t    package_dir={'': 'src'},\n\t    url='https://github.com/wolfhoundgelert/xman',\n\t    license='BSD 3-clause',\n\t    author='Andrei Polkanov',\n\t    author_email='andrey.polkanoff@gmail.com',\n\t    description='xMan - Experiment Manager, python library for effective management and organising '\n", "                'experiments on thÐµ Google Colab platform with sharing and running in parallel '\n\t                'across different Colab accounts.',\n\t    install_requires=requirements,\n\t)\n\t# TODO https://github.com/pypi/support/issues/2738\n"]}
{"filename": "test/test_util.py", "chunked_list": ["import pytest\n\tfrom xman import util\n\tfrom xman.error import ArgumentsXManError\n\tdef test__check_has_value_in_class_public_constants():\n\t    class TestClass:\n\t        CONST1 = 'CONST1'\n\t        CONST2 = 'CONST2'\n\t    util.check_has_value_in_class_public_constants(TestClass.CONST1, TestClass)\n\t    util.check_has_value_in_class_public_constants(TestClass.CONST2, TestClass)\n\t    with pytest.raises(ArgumentsXManError, match=f\"Wrong value `{'CONST_THAT_DOES_NOT_EXISTS'}`\"):\n", "        util.check_has_value_in_class_public_constants('CONST_THAT_DOES_NOT_EXISTS', TestClass)\n"]}
{"filename": "test/test_filter.py", "chunked_list": ["# TODO filter.exps() and filter.groups()\n\tfrom xman import xman\n\timport helper\n\tdef test__sorted_exps():\n\t    helper.make_proj_from_nothing()\n\t    xman.make_group('G1', 'G1 descr')\n\t    e1 = xman.make_exp('G1', 'G1 E1', 'G1 E1 descr')\n\t    e2 = xman.make_exp('G1', 'G1 E2', 'G1 E2 descr')\n\t    xman.make_group('G2', 'G2 descr')\n\t    e3 = xman.make_exp('G2', 'G2 E1', 'G2 E1 descr')\n", "    e4 = xman.make_exp('G2', 'G2 E2', 'G2 E2 descr')\n\t    exps = xman.exps()\n\t    assert exps == [e1, e2, e3, e4]\n\tdef test__sorted_groups():\n\t    helper.make_proj_from_nothing()\n\t    g1 = xman.make_group('G1', 'G1 descr')\n\t    g2 = xman.make_group('G2', 'G2 descr')\n\t    groups = xman.groups()\n\t    assert groups == [g1, g2]\n"]}
{"filename": "test/test_api.py", "chunked_list": ["\"\"\"\n\tdef check_api(class_one, class_two, excluding_list=None, including_list=None) -> Tuple[List, List]:\n\t- Check only public methods and properties, that everything exists in both classes.\n\t- For each pair check that signatures are the same.\n\t- Excluding list for public methods and properties that not needed to check.\n\t- Including list for adding protected methods and properties for the check.\n\tReturns: absentee list and list with difference in signatures\n\t\"\"\"\n\timport inspect\n\tfrom typing import Tuple, List, Callable, Optional\n", "import re\n\timport pytest\n\tfrom xman import XManAPI\n\tfrom xman.api import ExpAPI, ExpStructAPI, ExpGroupAPI, ExpProjAPI\n\tfrom xman.error import ArgumentsXManError\n\tfrom xman.exp import Exp\n\tfrom xman.group import ExpGroup\n\tfrom xman.proj import ExpProj\n\tfrom xman.struct import ExpStruct\n\tdef get_public_members(cls) -> List[str]:\n", "    return [member for member in dir(cls) if not member.startswith(('_', '__'))]\n\tdef get_normalized_signature_str(member: Callable | property) -> str:\n\t    sig = str(inspect.signature(member))\n\t    sig = re.sub(r'\\bxman\\.\\w+\\.Exp', 'Exp', sig)\n\t    sig = re.sub(r'\\b(Exp\\w*)API\\b', r'\\1', sig)\n\t    sig = re.sub(r\"'\", '', sig)\n\t    return sig\n\tdef is_equal_signatures(member_one: Callable | property, member_two: Callable | property) -> bool:\n\t    one_exists = member_one is not None\n\t    two_exists = member_two is not None\n", "    if not one_exists and not two_exists:\n\t        raise ArgumentsXManError(\n\t            f\"Both `member_one` and `member_two` are None - shouldn't be like that!\")\n\t    if one_exists != two_exists:\n\t        return False\n\t    one_is_prop = isinstance(member_one, property)\n\t    two_is_prop = isinstance(member_two, property)\n\t    if one_is_prop != two_is_prop:\n\t        return False\n\t    if one_is_prop:\n", "        one_has_setter = member_one.fset is not None\n\t        two_has_setter = member_two.fset is not None\n\t        if one_has_setter != two_has_setter:\n\t            return False\n\t        if one_has_setter and \\\n\t                get_normalized_signature_str(member_one.fset) != \\\n\t                get_normalized_signature_str(member_two.fset):\n\t            return False\n\t        return get_normalized_signature_str(member_one.fget) == \\\n\t            get_normalized_signature_str(member_two.fget)\n", "    else:\n\t        return get_normalized_signature_str(member_one) == \\\n\t            get_normalized_signature_str(member_two)\n\t# TODO Add checking on annotation and returning value if returns smt\n\tdef check_api(class_one, class_two, excluding_list: List[str] = None,\n\t              including_list: List[str] = None) -> Optional[Tuple[str, List[str], List[str]]]:\n\t    one_set = set(get_public_members(class_one))\n\t    two_set = set(get_public_members(class_two))\n\t    excluding_set = set([] if excluding_list is None else excluding_list)\n\t    including_set = set([] if including_list is None else including_list)\n", "    if len(cross_set := excluding_set & including_set) > 0:\n\t        raise ArgumentsXManError(\n\t            f\"Members {cross_set} can't be in both `excluding_list` and `including_list\")\n\t    for member in (excluding_set | including_set) - (one_set | two_set):\n\t        if not hasattr(class_one, member) and not hasattr(class_two, member):\n\t            raise ArgumentsXManError(\n\t                f\"Member `{member}` doesn't exist neither in `{class_one}` or `{class_two}\")\n\t    existence_diff_set = (one_set ^ two_set) - excluding_set\n\t    common_set = (one_set & two_set) - excluding_set\n\t    for member in including_set:\n", "        one_has = hasattr(class_one, member)\n\t        two_has = hasattr(class_two, member)\n\t        if one_has == two_has == False:\n\t            raise ArgumentsXManError(\n\t                f\"`{member}` doesn't exist in either `class_one` or `class_two`!\")\n\t        elif one_has == two_has == True:\n\t            common_set.add(member)\n\t        else:\n\t            existence_diff_set.add(member)\n\t    signatures_diff_set = set()\n", "    for member in common_set:\n\t        is_equal = is_equal_signatures(getattr(class_one, member), getattr(class_two, member))\n\t        if not is_equal:\n\t            signatures_diff_set.add(member)\n\t    if len(existence_diff_set) or len(signatures_diff_set):\n\t        not_exist = []\n\t        for it in existence_diff_set:\n\t            it_str = f\"{(class_two if it in one_set else class_one).__name__}:{it}\"\n\t            not_exist.append(it_str)\n\t        signatures = list(signatures_diff_set)\n", "        info = f\"\\n\\nAPI CHECKING REPORT:\\nNot exist: {not_exist}\\n\" \\\n\t               f\"Different signatures: {signatures}\\n\"\n\t        return info, list(existence_diff_set), signatures\n\t    return None\n\tdef test__get_public_members():\n\t    class A:\n\t        @staticmethod\n\t        def sm(): pass\n\t        @staticmethod\n\t        def _sm(): pass\n", "        @staticmethod\n\t        def __sm(): pass\n\t        @property\n\t        def p(self): pass\n\t        @property\n\t        def _p(self): pass\n\t        @property\n\t        def __p(self): pass\n\t        def m(self): pass\n\t        def _m(self): pass\n", "        def __m(self): pass\n\t    lst = get_public_members(A)\n\t    assert len(lst) == 3 and set(lst) == set(['sm', 'p', 'm'])\n\tdef test__get_normalized_signature_str():\n\t    def foo(param1: ExpStructAPI, param2: ExpAPI) -> ExpGroupAPI: pass\n\t    def bar(param1: ExpStruct, param2: Exp) -> ExpGroup: pass\n\t    def biz(param1: ExpStructAPI, param2: ExpProjAPI) -> ExpGroupAPI: pass\n\t    assert get_normalized_signature_str(foo) == get_normalized_signature_str(bar)\n\t    assert get_normalized_signature_str(biz) != get_normalized_signature_str(bar)\n\tdef test__is_equal_signatures():\n", "    def a(): pass\n\t    def b(): pass\n\t    assert is_equal_signatures(a, b)\n\t    def a(): pass\n\t    def b() -> bool: pass\n\t    assert not is_equal_signatures(a, b)\n\t    def a(): pass\n\t    def b(foo: int): pass\n\t    assert not is_equal_signatures(a, b)\n\t    def a(bar: int): pass\n", "    def b(foo: int): pass\n\t    assert not is_equal_signatures(a, b)\n\t    def a(foo: int): pass\n\t    def b(foo: int): pass\n\t    assert is_equal_signatures(a, b)\n\t    class A:\n\t        @property\n\t        def foo(self): pass\n\t        @foo.setter\n\t        def foo(self, value): pass\n", "        @property\n\t        def bar(self): pass\n\t        @bar.setter\n\t        def bar(self, value): pass\n\t        @property\n\t        def biz(self): pass\n\t        @bar.setter\n\t        def biz(self, value): pass\n\t    class B:\n\t        @property\n", "        def foo(self): pass\n\t        @foo.setter\n\t        def foo(self, value): pass\n\t        @property\n\t        def bar(self): pass\n\t        @bar.setter\n\t        def bar(self, value) -> bool: pass\n\t        @property\n\t        def biz(self): pass\n\t    assert is_equal_signatures(A.foo, B.foo)\n", "    assert not is_equal_signatures(A.bar, B.bar)\n\t    assert not is_equal_signatures(A.biz, B.biz)\n\t    assert not is_equal_signatures(A.foo, None)\n\t    with pytest.raises(ArgumentsXManError, match=\"are None\"):\n\t        is_equal_signatures(None, None)\n\tdef test__check_api():\n\t    class A:\n\t        @staticmethod\n\t        def sm(): pass\n\t        @property\n", "        def p(self): pass\n\t        def m(self, param: int): pass\n\t        def foo(self): pass\n\t        def _bar(self) -> str: pass\n\t    class B:\n\t        @staticmethod\n\t        def sm(): pass\n\t        def m(self, param: str): pass\n\t        def _bar(self, param: bool) -> str: pass\n\t    info, existence_diff, signatures_diff = check_api(A, B, ['foo'], ['_bar'])\n", "    assert info is not None\n\t    assert set(existence_diff) == set(['p'])\n\t    assert set(signatures_diff) == set(['m', '_bar'])\n\tdef test__ExpStruct():\n\t    excludes = ['parent', 'api', 'info']\n\t    result = check_api(ExpStruct, ExpStructAPI, excludes)\n\t    if result is not None:\n\t        info, _, _ = result\n\t        print(info)\n\t        assert False\n", "def test__Exp():\n\t    excludes = ['parent', 'api', 'info']\n\t    result = check_api(Exp, ExpAPI, excludes)\n\t    if result is not None:\n\t        info, _, _ = result\n\t        print(info)\n\t        assert False\n\tdef test__ExpGroup():\n\t    excludes = ['parent', 'api', 'make_child', 'has_child', 'num_children', 'change_child_num',\n\t                'children_nums', 'child', 'children', 'delete_child', 'children_names', 'info']\n", "    result = check_api(ExpGroup, ExpGroupAPI, excludes)\n\t    if result is not None:\n\t        info, _, _ = result\n\t        print(info)\n\t        assert False\n\tdef test__ExpProj():\n\t    excludes = ['parent', 'api', 'make_child', 'has_child', 'num_children', 'change_child_num',\n\t                'children_nums', 'child', 'children', 'delete_child', 'children_names', 'info']\n\t    result = check_api(ExpProj, ExpProjAPI, excludes)\n\t    if result is not None:\n", "        info, _, _ = result\n\t        print(info)\n\t        assert False\n\tdef test__ExpProjAPI_vs_XManAPI():\n\t    excludes = ['move_exp', 'delete_dir', 'is_manual', 'name', 'make_dir', 'rename_or_move_dir',\n\t                'num_groups', 'descr', 'num_exps', 'note', 'dir_tree', 'make_proj', 'num',\n\t                'set_manual_status', 'groups_nums', 'result_viewer', 'load_proj', 'edit', 'fail',\n\t                'reload', 'exps_names', 'exps_nums', 'proj', 'status', 'success', 'tree',\n\t                'delete_manual_status', 'groups_names', 'change_group_num', 'result_stringifier']\n\t    result = check_api(ExpProjAPI, XManAPI, excludes)\n", "    if result is not None:\n\t        info, _, _ = result\n\t        print(info)\n\t        assert False\n"]}
{"filename": "test/test_.py", "chunked_list": ["import os\n\timport sys\n\timport pytest\n\t# def test__xman_init():  # Just for adding xman's `src` to paths and config `is_pytest` setting\n\t#     xman_path = os.path.abspath(os.path.join('src'))\n\t#     if xman_path not in sys.path:\n\t#         sys.path.insert(0, xman_path)\n\t#         # sys.path.remove(xman_path)\n\t#     config.set__is_pytest(True)\n\tfrom xman.error import AlreadyExistsXManError\n", "from xman.exp import Exp\n\tfrom xman.pipeline import CheckpointsMediator\n\tfrom xman import xman, filesystem\n\tfrom xman.filesystem import FileType\n\tfrom xman import config\n\timport helper\n\tdef test__config():\n\t    config.set__is_pytest(True)\n\t    assert config.is_pytest\n\t    assert config.confirm_off\n", "def test__change_exp_num():\n\t    exp = helper.make_exp_from_nothing()\n\t    group = exp.group\n\t    group.make_exp('New Exp', 'New exp descr')\n\t    with pytest.raises(AlreadyExistsXManError, match=\"is already taken by other child\"):\n\t        group.change_exp_num(1, 2)\n\t    group.change_exp_num(1, 3)\n\t    assert group.exp(3) is exp\n\tdef test__change_group_num():\n\t    group = helper.make_group_from_nothing()\n", "    proj = group.proj\n\t    proj.make_group('New Group', 'New group descr')\n\t    with pytest.raises(AlreadyExistsXManError, match=\"is already taken by other child\"):\n\t        proj.change_group_num(1, 2)\n\t    proj.change_group_num(1, 3)\n\t    assert proj.group(3) is group\n\tdef test__make_proj():\n\t    proj = helper.make_proj_from_nothing()\n\t    assert proj.name == 'Test Proj' and xman.proj.descr == 'Test proj descr'\n\tdef test__pipeline():\n", "    exp = helper.make_exp_from_nothing().make_pipeline(helper.train, helper.train_params, True).\\\n\t        start()\n\t    assert exp.result == helper.train_result\n\tdef test__pipeline_with_checkpoints():\n\t    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n\t        helper.train_with_mediator, helper.train_params, True).start()\n\t    assert exp.result == helper.train_result\n\t    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n\t        helper.train_with_mediator_replace, helper.train_params, True).start()\n\t    assert exp.result == helper.train_result\n", "    exp.delete_checkpoints(need_confirm=False)\n\t    assert not filesystem.has_checkpoints_dir(exp.location_dir)\n\t    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n\t        helper.train_with_mediator_custom_path, helper.train_params, True).start()\n\t    assert os.path.exists(os.path.join(exp.location_dir, 'custom/first.cp'))\n\t    assert os.path.exists(os.path.join(exp.location_dir, 'custom/second.cp'))\n\t    exp.delete_checkpoints(need_confirm=False, delete_custom_paths=False)\n\t    assert os.path.exists(os.path.join(exp.location_dir, 'custom/first.cp'))\n\t    assert os.path.exists(os.path.join(exp.location_dir, 'custom/second.cp'))\n\t    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n", "        helper.train_with_mediator_custom_path, helper.train_params, True).start()\n\t    exp.delete_checkpoints(need_confirm=False, delete_custom_paths=True)\n\t    assert not os.path.exists(os.path.join(exp.location_dir, 'custom/first.cp'))\n\t    assert not os.path.exists(os.path.join(exp.location_dir, 'custom/second.cp'))\n\tdef test__destroy_group():\n\t    config.set__is_pytest(True)\n\t    helper.make_exp_from_nothing()\n\t    xman.delete_group(1)\n\t    assert xman.proj.num_groups() == 0\n\tdef test__destroy_exp():\n", "    config.set__is_pytest(True)\n\t    helper.make_exp_from_nothing()\n\t    xman.group(1).delete_exp(1)\n\t    assert xman.group(1).num_exps() == 0\n\tdef test__destroy_exp_after_pipeline_done():\n\t    config.set__is_pytest(True)\n\t    helper.make_exp_from_nothing().make_pipeline(helper.train, helper.train_params, True).start()\n\t    xman.group(1).delete_exp(1)\n\t    assert xman.group(1).num_exps() == 0\n\tdef test__getting_exp():\n", "    exp = helper.make_exp_from_nothing(num=10)\n\t    assert exp.num == 10\n\t    assert xman.proj.exp(1, 10) is exp\n\t    assert xman.proj.group(1).exp(10) is exp\n\t    assert xman.exp(1, 10) is exp\n\t    assert xman.group(1).exp(10) is exp\n\t    exp = helper.make_exp_from_nothing(num=10)\n\t    assert xman.proj.exp('Test Group', 'Test Exp') is exp\n\t    assert xman.proj.group('Test Group').exp('Test Exp') is exp\n\t    assert xman.exp('Test Group', 'Test Exp') is exp\n", "def test__move_exp():\n\t    exp = helper.make_exp_from_nothing()\n\t    exp.proj.make_group('New Group', 'New group descr')\n\t    xman.proj.move_exp(1, 1, 2, 3)\n\t    assert not xman.group(1).has_exp(1) and xman.group(2).has_exp(3) and xman.group(2).exp(3) is exp\n\t# TODO add other params and separate on different tests (one for each param)\n\tdef test__filter_exps_in_group():\n\t    group = helper.make_group_from_nothing()\n\t    for i in range(3):\n\t        group.make_exp(f\"Exp {i + 1}\", \"Descr\")\n", "    exp = xman.exp(1, 2)\n\t    class MockExp(Exp):\n\t        is_ready_for_start = True\n\t    exp._obj.__class__ = MockExp\n\t    readies = group.filter_exps(is_ready_for_start=True)\n\t    assert len(readies) == 1 and readies[0] is exp\n\t    class MockExp(Exp):\n\t        is_active = True\n\t    exp._obj.__class__ = MockExp\n\t    actives = group.filter_exps(is_active=True)\n", "    assert len(actives) == 1 and actives[0] is exp\n\t    xman.exp(1, 1).set_manual_status('DONE', \"It's done.\")\n\t    manuals = xman.group(1).filter_exps(is_manual=True)\n\t    assert len(manuals) == 1 and manuals[0] is xman.exp(1, 1)\n\t    all_falses = xman.group(1).filter_exps(is_active=False, is_manual=False)\n\t    assert len(all_falses) == 1 and all_falses[0] is xman.exp(1, 3)\n\tdef test__filter_exps_in_proj():\n\t    pass  # TODO ChatGPT\n\t    # assert False\n\tdef test__filter_exps_in_xman():\n", "    pass  # TODO ChatGPT\n\t    # assert False\n\tdef test__result_stringifier():\n\t    exp = helper.make_exp_from_nothing()\n\t    exp.set_manual_result({'foo': 123, 'bar': 'asdf', 'biz': [1, 2]})\n\t    exp.result_stringifier = lambda x: f\"foo={x['foo']}, bar={x['bar']}\"\n\t    assert exp.stringify_result() == 'foo=123, bar=asdf'\n\tdef test__stringify_result():\n\t    exp = helper.make_exp_from_nothing()\n\t    exp.set_manual_result({'foo': 123, 'bar': 'asdf'})\n", "    exp.proj.result_stringifier = lambda x: f\"foo={x['foo']}\"\n\t    assert exp._obj.stringify_result() == 'foo=123'\n\t    exp.group.result_stringifier = lambda x: f\"bar={x['bar']}\"\n\t    assert exp._obj.stringify_result() == 'bar=asdf'\n\t    exp.result_stringifier = lambda x: f\"foo={x['foo']}, bar={x['bar']}\"\n\t    assert exp._obj.stringify_result() == 'foo=123, bar=asdf'\n\tdef test__result_viewer():\n\t    exp = helper.make_exp_from_nothing()\n\t    exp.set_manual_result({'foo': 123, 'bar': 'asdf', 'biz': [1, 2]})\n\t    rv_func = lambda result: print(f\"Result: {result}\")\n", "    exp.result_viewer = rv_func\n\t    assert exp.result_viewer == rv_func\n\t    exp.view_result()\n\tdef test__note():\n\t    config.set__is_pytest(True)\n\t    exp = helper.make_exp_from_nothing()\n\t    assert exp.note is not None\n\t    exp.note.pickle = 'Some object'\n\t    exp.note.clear()\n\t    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n", "    exp.note.pickle = 'Another object'\n\t    exp.clear()\n\t    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n\tdef test__note_txt():\n\t    exp = helper.make_exp_from_nothing()\n\t    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.TXT))\n\t    exp.note.txt = \"This is my note.\\nNew line.\"\n\t    assert filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.TXT))\n\t    assert exp.note.txt == \"This is my note.\\nNew line.\"\n\t    exp.note.txt = None\n", "    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.TXT))\n\t    assert exp.note.txt is None\n\t    assert len(exp.note.get_list()) == 0\n\t    assert not exp.note.has_any\n\t    exp.note.pickle = 1\n\t    exp.note.txt = 'hello'\n\t    assert len(exp.note.get_list()) == 2\n\t    assert exp.note.get_existence_str() == \"txt true, json false, pickle true\"\n\t    assert exp.note.has_any\n\t    exp.note.clear()\n", "    assert len(exp.note.get_list()) == 0\n\t    assert exp.note.get_existence_str() == \"txt false, json false, pickle false\"\n\t    assert not exp.note.has_any\n\tdef test__note_json():\n\t    exp = helper.make_exp_from_nothing()\n\t    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.JSON))\n\t    exp.note.json = {'name': 'Isaac', 'mood': 'apple'}\n\t    assert filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.JSON))\n\t    assert exp.note.json['mood'] == 'apple'\n\t    exp.note.json = None\n", "    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.JSON))\n\t    assert exp.note.json is None\n\tdef test__note_pickle():\n\t    exp = helper.make_exp_from_nothing()\n\t    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n\t    exp.note.pickle = CheckpointsMediator(exp.location_dir)\n\t    assert filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n\t    assert exp.note.pickle.exp_location_dir == exp.location_dir\n\t    exp.note.pickle = None\n\t    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n", "    assert exp.note.pickle is None\n"]}
{"filename": "test/helper.py", "chunked_list": ["import os\n\timport shutil\n\tfrom xman import xman\n\tfrom xman.api import ExpProjAPI, ExpGroupAPI, ExpAPI\n\tfrom xman.pipeline import CheckpointsMediator\n\tdef make_proj_from_nothing(proj_dir=None, name=None, descr=None) -> ExpProjAPI:\n\t    if proj_dir is None:\n\t        # proj_dir = './gitignore/testproj'  # if running by `pytest` in terminal\n\t        proj_dir = '../gitignore/testproj'\n\t    if name is None:\n", "        name = 'Test Proj'\n\t    if descr is None:\n\t        descr = 'Test proj descr'\n\t    if os.path.exists(proj_dir):\n\t        shutil.rmtree(proj_dir)\n\t    return xman.make_proj(proj_dir, name, descr)\n\tdef make_group_from_nothing(name=None, descr=None, num=None) -> ExpGroupAPI:\n\t    if name is None:\n\t        name = 'Test Group'\n\t    if descr is None:\n", "        descr = 'Test group descr'\n\t    return make_proj_from_nothing().make_group(name, descr, num)\n\tdef make_exp_from_nothing(name=None, descr=None, num=None) -> ExpAPI:\n\t    if name is None:\n\t        name = 'Test Exp'\n\t    if descr is None:\n\t        descr = 'Test exp descr'\n\t    return make_group_from_nothing().make_exp(name, descr, num)\n\tdef train(p1, p2, np1=None, np2=None):\n\t    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n", "    return result\n\tdef train_with_mediator(mediator: CheckpointsMediator, p1, p2, np1=None, np2=None):\n\t    mediator.save_checkpoint('first checkpoint', False)\n\t    mediator.save_checkpoint('second checkpoint', False)\n\t    cp_list = mediator.get_checkpoint_paths_list()\n\t    assert len(cp_list) == 2\n\t    assert mediator.load_checkpoint(cp_list[0]) == 'first checkpoint'\n\t    assert mediator.load_checkpoint(cp_list[1]) == 'second checkpoint'\n\t    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n\t    return result\n", "def train_with_mediator_replace(mediator: CheckpointsMediator, p1, p2, np1=None, np2=None):\n\t    mediator.save_checkpoint('first checkpoint', True)\n\t    mediator.save_checkpoint('second checkpoint', True)\n\t    cp_list = mediator.get_checkpoint_paths_list()\n\t    assert len(cp_list) == 1\n\t    assert mediator.load_checkpoint(cp_list[0]) == 'second checkpoint'\n\t    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n\t    return result\n\tdef train_with_mediator_custom_path(mediator: CheckpointsMediator, p1, p2, np1=None, np2=None):\n\t    custom_path = os.path.join(mediator.exp_location_dir, 'custom/first.cp')\n", "    mediator.save_checkpoint('first checkpoint', False, custom_path)\n\t    custom_path = os.path.join(mediator.exp_location_dir, 'custom/second.cp')\n\t    mediator.save_checkpoint('second checkpoint', False, custom_path)\n\t    cp_list = mediator.get_checkpoint_paths_list()\n\t    assert len(cp_list) == 2\n\t    assert mediator.load_checkpoint(cp_list[0]) == 'first checkpoint'\n\t    assert mediator.load_checkpoint(cp_list[1]) == 'second checkpoint'\n\t    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n\t    return result\n\ttrain_params = {'p1': 1, 'p2': 2, 'np1': 3, 'np2': 4}\n", "train_result = f\"p1={train_params['p1']}, p2={train_params['p2']}, np1={train_params['np1']}, \" \\\n\t               f\"np2={train_params['np2']}\"\n"]}
{"filename": "test/test_bug.py", "chunked_list": ["import pytest\n\tfrom xman import xman\n\tfrom xman.error import ArgumentsXManError\n\timport helper\n\tdef test__exp_broken_after_setting_wrong_status():\n\t    exp = helper.make_exp_from_nothing()\n\t    with pytest.raises(ArgumentsXManError, match=\"Wrong value\"):\n\t        exp.set_manual_status('FAILED', \"There's no `FAILED` status - should be `FAIL`\")\n\t    assert exp.status.status_str == 'EMPTY'\n\t    exp.set_manual_status('FAIL', \"Acceptable status\")\n", "    assert exp.status.status_str == 'FAIL'\n\tdef test__setting_status_after_wrong_one():\n\t    \"\"\"\n\t    Manual status setting for ExpStructBox doesn't work after setting a wrong one.\n\t    \"\"\"\n\t    exp = helper.make_exp_from_nothing()\n\t    try:\n\t        exp.set_manual_status('FAILED', \"There's no `FAILED` status - should be `FAIL`\")\n\t    except:\n\t        pass\n", "    xman.proj.set_manual_status('TO_DO', None)\n\t    assert xman.proj.status.status_str == 'TO_DO'\n\t    xman.proj.group(1).set_manual_status('TO_DO', None)\n\t    assert xman.proj.group(1).status.status_str == 'TO_DO'\n\tdef test__wrong_proj_status_when_new_exp():\n\t    exp = helper.make_exp_from_nothing()\n\t    exp.set_manual_status('SUCCESS', 'Success')\n\t    proj = xman.proj\n\t    group = proj.group(1)\n\t    group.make_exp('Lowercase', 'Lowercase input')\n", "    assert group.status.status_str == 'IN_PROGRESS'\n\t    assert proj.status.status_str == 'IN_PROGRESS'\n\tdef test__wrong_proj_status_when_new_group():\n\t    exp = helper.make_exp_from_nothing()\n\t    exp.set_manual_status('SUCCESS', 'Success')\n\t    proj = xman.proj\n\t    assert proj.status.status_str == 'SUCCESS'\n\t    proj.make_group('Lowercase', 'Lowercase input')\n\t    assert proj.status.status_str == 'IN_PROGRESS'\n"]}
{"filename": "test/test_filesystem.py", "chunked_list": ["import os\n\tfrom pathlib import Path\n\timport pytest\n\tfrom xman.error import IllegalOperationXManError\n\tfrom xman import xman, filesystem\n\tfrom xman import config\n\timport helper\n\tdef test__has_checkpoints_dir():\n\t    exp = helper.make_exp_from_nothing()\n\t    exp.make_pipeline_with_checkpoints(helper.train_with_mediator, helper.train_params)\n", "    xman.make_dir(os.path.join(exp.location_dir, 'checkpoints/'))\n\t    assert filesystem.has_checkpoints_dir(exp.location_dir)\n\t    with pytest.raises(IllegalOperationXManError, match=\"contains checkpoints folder\"):\n\t        exp.start()\n\tdef test__make_dir():\n\t    config.set__is_pytest(True)\n\t    test_dir = '../gitignore/fstest'\n\t    if os.path.exists(test_dir):\n\t        xman.delete_dir(test_dir)\n\t    xman.make_dir(test_dir)\n", "    assert os.path.exists(test_dir)\n\t    xman.delete_dir(test_dir)\n\tdef test__remove_dir():\n\t    config.set__is_pytest(True)\n\t    test_dir = '../gitignore/fstest'\n\t    if os.path.exists(test_dir):\n\t        xman.delete_dir(test_dir)\n\t        assert not os.path.exists(test_dir)\n\t    xman.make_dir(test_dir)\n\t    xman.make_dir('../gitignore/fstest/group1/exp1')\n", "    xman.delete_dir(test_dir)\n\t    assert not os.path.exists(test_dir)\n\tdef test__rename_or_move_dir():\n\t    config.set__is_pytest(True)\n\t    test_dir = '../gitignore/fstest'\n\t    if os.path.exists(test_dir):\n\t        xman.delete_dir(test_dir)\n\t    path1 = '../gitignore/fstest/group1/exp1'\n\t    xman.make_dir(path1)\n\t    path2 = '../gitignore/fstest/group2/exp1'\n", "    xman.rename_or_move_dir(path1, path2)\n\t    assert not os.path.exists(path1) and os.path.exists(path2)\n\t    xman.delete_dir(test_dir)\n\tdef test__change_exp_num_in_path():\n\t    path = '../gitignore/testproj/group1/exp1'\n\t    new_path = '../gitignore/testproj/group1/exp2'\n\t    assert filesystem.change_exp_num_in_path(path, 2) == new_path\n\t    path = '../gitignore/testproj/group1/exp1/.data'\n\t    new_path = '../gitignore/testproj/group1/exp2/.data'\n\t    assert filesystem.change_exp_num_in_path(path, 2) == new_path\n", "    path = '../gitignore/testproj/group1/exp42'\n\t    new_path = '../gitignore/testproj/group1/exp24'\n\t    assert filesystem.change_exp_num_in_path(path, 24) == new_path\n\t    path = '../gitignore/testproj/group1/exp42/.data'\n\t    new_path = '../gitignore/testproj/group1/exp24/.data'\n\t    assert filesystem.change_exp_num_in_path(path, 24) == new_path\n\tdef test__change_group_num_in_path():\n\t    path = '../gitignore/testproj/group1'\n\t    new_path = '../gitignore/testproj/group2'\n\t    assert filesystem.change_group_num_in_path(path, 2) == new_path\n", "    path = '../gitignore/testproj/group1/exp1'\n\t    new_path = '../gitignore/testproj/group2/exp1'\n\t    assert filesystem.change_group_num_in_path(path, 2) == new_path\n\t    path = '../gitignore/testproj/group42'\n\t    new_path = '../gitignore/testproj/group24'\n\t    assert filesystem.change_group_num_in_path(path, 24) == new_path\n\t    path = '../gitignore/testproj/group42/exp1'\n\t    new_path = '../gitignore/testproj/group24/exp1'\n\t    assert filesystem.change_group_num_in_path(path, 24) == new_path\n"]}
{"filename": "src/tmptest.py", "chunked_list": ["import shutil\n\timport os\n\tfrom xman import xman\n\tPROJ_DIR = '../gitignore/experiments'\n\tcreate_new = True\n\tif create_new:\n\t    if os.path.exists(PROJ_DIR):\n\t        shutil.rmtree(PROJ_DIR)\n\t    xman.make_proj(PROJ_DIR, 'Test Project', \"Test project descr\")\n\t    xman.make_group(\"Test Group\", \"Test group descr\")\n", "    xman.make_exp(1, \"Test Exp\", \"Test exp descr\")\n\telse:\n\t    xman.load_proj(PROJ_DIR)\n\txman.exp(1, 1).info()\n"]}
{"filename": "src/xman/struct.py", "chunked_list": ["import os\n\tfrom typing import Optional, Type, Callable, Any, Tuple\n\tfrom copy import deepcopy\n\tfrom .error import NotExistsXManError, ArgumentsXManError, AlreadyExistsXManError, \\\n\t    IllegalOperationXManError\n\tfrom . import util, filesystem, tree, confirm\n\tfrom .note import Note\n\tclass ExpStructData:\n\t    def __init__(self, name: str, descr: str):\n\t        self.name: str = name\n", "        self.descr: str = descr\n\t        self.manual_status: str = None\n\t        self.manual_status_resolution: str = None\n\t        self.result_stringifier: Callable[[Any], str] = None\n\t        self.result_viewer: Callable[[Any], None] = None\n\tclass ExpStructStatus:\n\t    EMPTY = 'EMPTY'\n\t    TO_DO = 'TO_DO'\n\t    IN_PROGRESS = 'IN_PROGRESS'\n\t    DONE = 'DONE'\n", "    ERROR = 'ERROR'\n\t    SUCCESS = 'SUCCESS'\n\t    FAIL = 'FAIL'\n\t    __WORKFLOW = (EMPTY, TO_DO, IN_PROGRESS, (DONE, ERROR), (SUCCESS, FAIL))\n\t    @staticmethod\n\t    def has_status(status_str: str):\n\t        return util.check_has_value_in_class_public_constants(status_str, ExpStructStatus)\n\t    @staticmethod\n\t    def _check(status_str, resolution):\n\t        ExpStructStatus.has_status(status_str)\n", "        if status_str in (ExpStructStatus.SUCCESS, ExpStructStatus.FAIL) and resolution is None:\n\t            raise ArgumentsXManError(f\"SUCCESS and FAIL manual statuses \"\n\t                                     f\"require setting resolutions!\")\n\t    @staticmethod\n\t    def _fit_parameters(status_obj, status_str, resolution, manual):\n\t        return status_obj is not None and status_obj.status_str == status_str \\\n\t                and status_obj.resolution == resolution and status_obj.manual == manual\n\t    @property\n\t    def status_str(self) -> str: return self.__status_str\n\t    @property\n", "    def resolution(self) -> str: return self.__resolution\n\t    @property\n\t    def manual(self) -> bool: return self.__manual\n\t    @property\n\t    def workflow(self) -> Tuple[str | Tuple[str, str]]: return deepcopy(ExpStructStatus.__WORKFLOW)\n\t    @property\n\t    def next(self) -> Optional[str]:\n\t        if ExpStructStatus.__WORKFLOW[-1] == self.status_str:\n\t            return None\n\t        for i, it in enumerate(ExpStructStatus.__WORKFLOW[:-1]):\n", "            if it == self.status_str or (type(it) is tuple and self.status_str in it):\n\t                return ExpStructStatus.__WORKFLOW[i + 1]\n\t    # Printing in jupyter notebook - https://stackoverflow.com/a/41454816/9751954\n\t    def _repr_pretty_(self, p, cycle):\n\t        p.text(str(self) if not cycle else '...')\n\t    def __init__(self, status: str, resolution: str = None, manual: bool = False):\n\t        ExpStructStatus._check(status, resolution)\n\t        self.__status_str = status\n\t        self.__resolution = resolution\n\t        self.__manual = manual\n", "    def __str__(self): return self.status_str + ' *' if self.manual else self.status_str\n\tclass ExpStruct:\n\t    _AUTO_STATUS_RESOLUTION = '-= auto status =-'\n\t    @property\n\t    def api(self): return self._api\n\t    @property\n\t    def location_dir(self) -> str: return self.__location_dir\n\t    @property\n\t    def parent(self) -> Type['ExpGroup | ExpProj']: return self._parent\n\t    @property\n", "    def num(self) -> int: return self.__num\n\t    @property\n\t    def name(self) -> str: return self._data.name\n\t    @property\n\t    def descr(self) -> str: return self._data.descr\n\t    @property\n\t    def status(self) -> ExpStructStatus: return self.__status\n\t    @property\n\t    def is_manual(self) -> bool: return self._data.manual_status is not None\n\t    @property\n", "    def result_stringifier(self) -> Callable[[Any], str]:\n\t        return self._data.result_stringifier\n\t    @result_stringifier.setter\n\t    def result_stringifier(self, value: Callable[[Any], str]):\n\t        self._data.result_stringifier = value\n\t        self._save()\n\t    @property\n\t    def result_viewer(self) -> Callable[[Any], None]: return self._data.result_viewer\n\t    @result_viewer.setter\n\t    def result_viewer(self, value: Callable[[Any], None]):\n", "        self._data.result_viewer = value\n\t        self._save()\n\t    @property\n\t    def note(self) -> Note:\n\t        if self.__note is None:\n\t            self.__note = Note(self.location_dir)\n\t        return self.__note\n\t    def tree(self, depth: int = None): tree.print_dir_tree(self.location_dir, depth)\n\t    def info(self) -> str:\n\t        text = str(self)\n", "        if self.status.resolution is not None:\n\t            text += util.tab(f\"\\nResolution: {self.status.resolution}\")\n\t        if self.note.has_any:\n\t            text += util.tab(f\"\\nNotes: {self.note.get_existence_str()}\")\n\t        return text\n\t    def set_manual_status(self, status: str, resolution: str) -> 'ExpStruct':\n\t        ExpStructStatus._check(status, resolution)\n\t        status_str = self.status.status_str\n\t        if status_str == ExpStructStatus.SUCCESS or status_str == ExpStructStatus.FAIL:\n\t            raise IllegalOperationXManError(f\"`{self}` was already finalised with status \"\n", "                                            f\"`{status_str}` - you need to delete it manually with \"\n\t                                            f\"`delete_manual_status()` method at first!\")\n\t        self._data.manual_status = status\n\t        self._data.manual_status_resolution = resolution\n\t        self._save()\n\t        return self\n\t    def success(self, resolution: str) -> Optional['ExpStruct']:\n\t        return self.set_manual_status(ExpStructStatus.SUCCESS, resolution)\n\t    def fail(self, resolution: str) -> Optional['ExpStruct']:\n\t        return self.set_manual_status(ExpStructStatus.FAIL, resolution)\n", "    def delete_manual_status(self, need_confirm: bool = True) -> Optional['ExpStruct']:\n\t        if not self.status.manual:\n\t            raise NotExistsXManError(f\"There's no manual status in the struct `{self}`\")\n\t        if confirm.request(need_confirm,\n\t                            f\"ATTENTION! Do you want to delete the manual status \"\n\t                            f\"`{self._data.manual_status}`\\nand its resolution \"\n\t                            f\"`{self._data.manual_status_resolution}`\\nof exp `{self}`?\"):\n\t            self._data.manual_status = None\n\t            self._data.manual_status_resolution = None\n\t            self._save()\n", "            return self\n\t        return None\n\t    def edit(self, name: str = None, descr: str = None):\n\t        need_save = False\n\t        if self.name != name:\n\t            if self._parent is not None and self._parent.has_child(name):\n\t                raise AlreadyExistsXManError(\n\t                    f\"There's another child with the name=`{name}` \"\n\t                    f\"in the parent `{self._parent}`\")\n\t            self._data.name = name\n", "            need_save = True\n\t        if self.descr != descr:\n\t            self._data.descr = descr\n\t            need_save = True\n\t        if need_save:\n\t            self._save()\n\t    def update(self):\n\t        if self.__updating:\n\t            return\n\t        self.__updating = True\n", "        self._data, self.__time = filesystem.load_fresh_data_and_time(self.location_dir,\n\t                                                                      self._data, self.__time)\n\t        # Status should be updated at the end of the inherited updating hierarchy\n\t        if type(self) == ExpStruct:\n\t            self._update_status()\n\t        self.__updating = False\n\t    def _change_location_dir(self, new_location_dir):\n\t        self.__location_dir = os.path.normpath(new_location_dir)\n\t        self.__num = filesystem.get_dir_num(new_location_dir)\n\t    def _update_status(self):\n", "        if self.is_manual:\n\t            status, resolution = self._data.manual_status, self._data.manual_status_resolution\n\t        else:\n\t            status, resolution = self._process_auto_status()\n\t        if not ExpStructStatus._fit_parameters(self.status, status, resolution, self.is_manual):\n\t            self.__status = ExpStructStatus(status, resolution, self.is_manual)\n\t    def _process_auto_status(self): util.override_it()\n\t    # Printing in jupyter notebook - https://stackoverflow.com/a/41454816/9751954\n\t    def _repr_pretty_(self, p, cycle): p.text(str(self) if not cycle else '...')\n\t    def _save(self): self.__time = filesystem.save_data_and_time(self.location_dir, self._data)\n", "    def _destroy(self):\n\t        self._api._obj = None\n\t        self._api = None\n\t        self._parent = None\n\t        self._data = None\n\t        self.__status = None\n\t    def __init__(self, location_dir, parent):\n\t        from .structbox import ExpStructBox\n\t        from .api import ExpStructAPI\n\t        self.__location_dir = None\n", "        self.__num = None\n\t        self._change_location_dir(location_dir)\n\t        self._parent: ExpStructBox = parent\n\t        self._data: ExpStructData = None\n\t        self.__time = None\n\t        self.__status = None\n\t        self.__note: Note = None\n\t        self.__updating = False\n\t        self.update()\n\t        self._api: ExpStructAPI = None\n", "    def __str__(self): util.override_it()\n"]}
{"filename": "src/xman/proj.py", "chunked_list": ["from typing import List, Optional, Callable\n\tfrom . import filesystem, filter, exp_helper\n\tfrom .error import NothingToDoXManError, NotExistsXManError, AlreadyExistsXManError, \\\n\t    ArgumentsXManError\n\tfrom .structbox import ExpStructBox\n\tfrom .group import ExpGroup\n\tfrom .exp import Exp\n\tclass ExpProj(ExpStructBox):\n\t    def info(self) -> str: return exp_helper.get_info_with_marked_exps(self)\n\t    def update(self):\n", "        if self.__updating:\n\t            return\n\t        self.__updating = True\n\t        super().update()\n\t        # Status should be updated at the end of the inherited updating hierarchy\n\t        if type(self) == ExpProj:\n\t            self._update_status()\n\t        self.__updating = False\n\t    def has_group(self, num_or_name: int | str) -> bool: return self.has_child(num_or_name)\n\t    def group(self, num_or_name: int | str) -> ExpGroup: return self.child(num_or_name)\n", "    def make_group(self, name: str, descr: str, num: int = None) -> ExpGroup:\n\t        return self.make_child(name, descr, num)\n\t    def delete_group(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n\t        self.group(num_or_name)._check_has_no_active_exps()\n\t        return self.delete_child(num_or_name, need_confirm)\n\t    def groups(self) -> List[ExpGroup]: return self.children()\n\t    def num_groups(self) -> int: return self.num_children()\n\t    def groups_nums(self) -> List[int]: return self.children_nums()\n\t    def groups_names(self) -> List[str]: return self.children_names()\n\t    def change_group_num(self, num_or_name: int | str, new_num: int):\n", "        self.group(num_or_name)._check_has_no_active_exps()\n\t        self.change_child_num(num_or_name, new_num)\n\t    def filter_groups(self,\n\t                      mode: str = 'AND',\n\t                      custom_filter: Callable[[ExpGroup], bool] = None,\n\t                      status_or_list: str | List[str] = None,\n\t                      not_status_or_list: str | List[str] = None,\n\t                      ) -> List[ExpGroup]:\n\t        return filter.groups(self.groups(), mode, custom_filter, status_or_list, not_status_or_list)\n\t    def has_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> bool:\n", "        return self.group(group_num_or_name).has_exp(exp_num_or_name)\n\t    def exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> Exp:\n\t        return self.group(group_num_or_name).exp(exp_num_or_name)\n\t    def make_exp(self, group_num_or_name: int | str, name: str, descr: str, num: int = None) -> Exp:\n\t        return self.group(group_num_or_name).make_exp(name, descr, num)\n\t    def delete_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n\t                   need_confirm: bool = True) -> bool:\n\t        return self.group(group_num_or_name).delete_exp(exp_num_or_name, need_confirm)\n\t    def exps(self, group_num_or_name: int | str = None) -> List[Exp]:\n\t        if group_num_or_name is not None:\n", "            return self.group(group_num_or_name).exps()\n\t        result = []\n\t        for it in self.groups():\n\t            result.extend(it.exps())\n\t        return result\n\t    def num_exps(self, group_num_or_name: int | str = None) -> int:\n\t        if group_num_or_name is not None:\n\t            return self.group(group_num_or_name).num_exps()\n\t        return len(self.exps())\n\t    def exps_nums(self, group_num_or_name: int | str = None) -> List[int]:\n", "        if group_num_or_name is not None:\n\t            return self.group(group_num_or_name).exps_nums()\n\t        return [x.num for x in self.exps()]\n\t    def exps_names(self, group_num_or_name: int | str = None) -> List[str]:\n\t        if group_num_or_name is not None:\n\t            return self.group(group_num_or_name).exps_names()\n\t        return [x.name for x in self.exps()]\n\t    def filter_exps(self,\n\t                    group_num_or_name: int | str = None,\n\t                    mode: str = 'AND',\n", "                    custom_filter: Callable[[Exp], bool] = None,\n\t                    is_active: bool = None,\n\t                    is_manual: bool = None,\n\t                    is_ready_for_start: bool = None,\n\t                    status_or_list: str | List[str] = None,\n\t                    not_status_or_list: str | List[str] = None,\n\t                    has_marker: bool = None,\n\t                    marker_or_list: str | List[str] = None,\n\t                    ) -> List[Exp]:\n\t        if group_num_or_name is not None:\n", "            return self.group(group_num_or_name).filter_exps(mode, custom_filter, is_active,\n\t                                is_manual, is_ready_for_start, status_or_list, not_status_or_list,\n\t                                has_marker, marker_or_list)\n\t        return filter.exps(self.exps(), mode, custom_filter, is_active, is_manual,\n\t                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\t    def get_exp_for_start(self, group_num_or_name: int | str = None) -> Optional[Exp]:\n\t        if group_num_or_name is not None:\n\t            return self.group(group_num_or_name).get_exp_for_start()\n\t        ready_list = filter.exps(self.exps(), is_ready_for_start=True)\n\t        return ready_list[0] if len(ready_list) else None\n", "    def start(self, group_num_or_name: int | str = None,\n\t              exp_num_or_name: int | str = None, autostart_next: bool = False):\n\t        exp = None\n\t        if group_num_or_name is None and exp_num_or_name is None:\n\t            exp = self.get_exp_for_start()\n\t        elif group_num_or_name is None and exp_num_or_name is not None:\n\t            raise ArgumentsXManError(f\"Need to specify `group_num_or_name` if `exp_num_or_name` is \"\n\t                                     f\"specified!\")\n\t        elif group_num_or_name is not None and exp_num_or_name is None:\n\t            exp = self.get_exp_for_start(group_num_or_name)\n", "        elif group_num_or_name is not None and exp_num_or_name is not None:\n\t            exp = self.exp(group_num_or_name, exp_num_or_name)\n\t        if exp is None:\n\t            raise NothingToDoXManError(f\"There's nothing to start!\")\n\t        exp.start()\n\t        if autostart_next:\n\t            self.start(autostart_next=True)\n\t    def move_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n\t                 new_group_num_or_name: int | str, new_exp_num: int):\n\t        exp = self.exp(group_num_or_name, exp_num_or_name)\n", "        exp._check_is_not_active()\n\t        group = self.group(group_num_or_name)\n\t        if not self.has_group(new_group_num_or_name):\n\t            raise NotExistsXManError(f\"There's no group with number or name \"\n\t                                     f\"`{new_group_num_or_name}`!\")\n\t        new_group = self.group(new_group_num_or_name)\n\t        if self.has_exp(new_group_num_or_name, new_exp_num):\n\t            raise AlreadyExistsXManError(f\"Can't move the experiment because another experiment\"\n\t                                    f\"already exist in the group number `{new_group_num_or_name}`!\")\n\t        dir_path = exp.location_dir\n", "        new_path = filesystem.change_group_num_in_path(dir_path, new_group.num)\n\t        new_path = filesystem.change_exp_num_in_path(new_path, new_exp_num)\n\t        filesystem.rename_or_move_dir(dir_path, new_path)\n\t        group._remove_child(exp)\n\t        # Also changes `num` as it's processing from the path:\n\t        exp._change_location_dir(new_path)\n\t        new_group._add_child(exp)\n\t    def __init__(self, location_dir):\n\t        from .api import ExpProjAPI\n\t        self.__updating = False\n", "        super().__init__(location_dir, None)\n\t        self._api = ExpProjAPI(self)\n\t    def __str__(self): return f\"Proj [{self.status}] {self.name} - {self.descr}\"\n"]}
{"filename": "src/xman/platform.py", "chunked_list": ["import sys\n\tis_colab = 'google.colab' in sys.modules\n\tis_jupyter_notebook = 'ipykernel' in sys.modules and not is_colab\n\tif is_colab:\n\t    import os\n\t    import re\n\t    from . import filesystem, confirm, maker\n\t    from . import util\n\t    def check_colab_forked_folders(exp_struct_box) -> bool:\n\t        \"\"\"\n", "        Issue with making folders under different Colab accounts in one Google Drive shared folder\n\t        produces folders with duplicated numbers (e.g. `group1` and `group1 (1)`, `exp2` and `exp2 (1)`.\n\t        It happens because there's a 20-second (or even more) lag in update the second account with the\n\t        information about the first one already created a folder with a such number. It can't be solved\n\t        for Colab, but user should be notified for solving the issue manually.\n\t        https://stackoverflow.com/questions/76106194/folders-created-with-python-code-from-2-colab-accounts-in-one-google-drive-share\n\t        Parameter:\n\t            exp_exp_struct_box (ExpStructBox): e.g. ExpProj or ExpGroup instances.\n\t        Returns:\n\t            (bool): `False` if forked folders were found and the response on the input was `No`, `True`\n", "                otherwise.\n\t        \"\"\"\n\t        dir_prefix = filesystem.dir_prefix(maker.get_child_class(exp_struct_box))\n\t        regex = fr'^{dir_prefix}\\d+ \\(\\d+\\)$'\n\t        folders = []\n\t        for entry in os.scandir(exp_struct_box.location_dir):\n\t            if entry.is_dir() and re.match(regex, entry.name):\n\t                folders.append(entry.name)\n\t        if len(folders):\n\t            loc = exp_struct_box.location_dir\n", "            message = (f\"\\nFound forked folders {folders} in the location `{loc}`.\"\n\t                       f\"\\nIt could be due to a delay in updating one account to the fact that a \"\n\t                       f\"Google Drive folder was created under a different account: \"\n\t                       f\"https://stackoverflow.com/questions/76106194/folders-created-with-python-code-\"\n\t                       f\"from-2-colab-accounts-in-one-google-drive-shareFound\"\n\t                       f\"\\nForked folders are not presented in the project and are essentially lost \"\n\t                       f\"experiments. You need to process (e.g. rename or delete) them manually.\"\n\t                       f\"\\nIn case of frequent occurrence of such a problem, try to take 1 minute \"\n\t                       f\"pauses between making experiments and groups of experiments under different \"\n\t                       f\"accounts. Or you can initially create new groups and experiments under only \"\n", "                       f\"one Colab account, then run and update experiments under different accounts.\")\n\t            util.warning(message)\n\t            if not confirm.request(True, f\"Leave it as is and proceed?\"):\n\t                return False\n\t        return True\n\telif is_jupyter_notebook:\n\t    import os\n\t    def check_jupyter_notebook_kernel_interrupted(): return os.getenv('KERNEL_INTERRUPTED') == '1'\n"]}
{"filename": "src/xman/config.py", "chunked_list": ["from xman import util\n\tclass PipelineConfig:\n\t    timer_interval = 2 * util.SECOND\n\t    active_buffer = 5 * util.SECOND\n\t    active_buffer_colab = util.MINUTE\n\tconfirm_off = False\n\tis_pytest = False\n\tdef set__is_pytest(value):\n\t    global is_pytest, confirm_off\n\t    is_pytest = value\n", "    confirm_off = is_pytest\n"]}
{"filename": "src/xman/structbox.py", "chunked_list": ["from typing import Optional, Type, List\n\tfrom .error import ArgumentsXManError, NotExistsXManError, AlreadyExistsXManError\n\tfrom .struct import ExpStruct, ExpStructStatus\n\tfrom . import util, confirm, maker, filesystem\n\tclass ExpStructBox(ExpStruct):\n\t    def info(self) -> str:\n\t        text = super().info()\n\t        for child in self.children():\n\t            text += util.tab(f\"\\n\\n{child.info()}\")\n\t        return text\n", "    def update(self):\n\t        if self.__updating:\n\t            return\n\t        self.__updating = True\n\t        super().update()\n\t        nums = filesystem.get_children_nums(self)\n\t        for num in nums:\n\t            if num not in self.__num_to_child:\n\t                child = maker.recreate_child(self, num)\n\t                self._add_child(child)\n", "        for child in self.children():\n\t            if child.num not in nums:\n\t                self._remove_child(child)\n\t        for name in list(self.__name_to_child.keys()):\n\t            del self.__name_to_child[name]\n\t        for child in self.children():\n\t            child.update()\n\t            self.__name_to_child[child._data.name] = child\n\t        # Status should be updated at the end of the inherited updating hierarchy\n\t        if type(self) == ExpStructBox:\n", "            self._update_status()\n\t        self.__updating = False\n\t    def has_child(self, num_or_name):\n\t        if util.is_num(num_or_name):\n\t            return num_or_name in self.__num_to_child\n\t        elif util.is_name(num_or_name):\n\t            return num_or_name in self.__name_to_child\n\t        else:\n\t            raise ArgumentsXManError(f\"`num_or_name` should be num >= 1 (int) or name (str), \"\n\t                                     f\"but `{num_or_name}` was given!\")\n", "    def child(self, num_or_name):\n\t        if util.is_num(num_or_name) and num_or_name in self.__num_to_child:\n\t            return self.__num_to_child[num_or_name]\n\t        elif util.is_name(num_or_name) and num_or_name in self.__name_to_child:\n\t            return self.__name_to_child[num_or_name]\n\t        raise NotExistsXManError(f\"There's no child with num or name `{num_or_name}` \"\n\t                                 f\"in the `{self}`!\")\n\t    def make_child(self, name, descr, num=None) -> Type['Exp | ExpGroup']:\n\t        util.check_num(num, True)\n\t        if self.has_child(name):\n", "            raise AlreadyExistsXManError(\n\t                f\"A child with the name `{name}` already exists in the `{self}`!\")\n\t        if num is not None:\n\t            if self.has_child(num):\n\t                raise AlreadyExistsXManError(\n\t                    f\"A child with the num `{num}` already exists in the `{self}`!\")\n\t        else:\n\t            nums = filesystem.get_children_nums(self)\n\t            max_num = max(nums) if len(nums) else 0\n\t            num = max_num + 1\n", "        child = maker.make_new_child(self, name, descr, num)\n\t        if child is not None:\n\t            self._add_child(child)\n\t        return child\n\t    def delete_child(self, num_or_name, need_confirm=True) -> bool:\n\t        child = self.child(num_or_name)\n\t        if confirm.delete_struct_and_all_its_content(child, need_confirm):\n\t            self._remove_child(child)\n\t            maker.delete_child(child, False)\n\t            return True\n", "        return False\n\t    def children(self) -> List['Exp | ExpGroup']: return list(self.__num_to_child.values())\n\t    def num_children(self) -> int: return len(self.__num_to_child)\n\t    def children_nums(self) -> List[int]: return list(self.__num_to_child.keys())\n\t    def children_names(self) -> List[str]: return list(self.__name_to_child.keys())\n\t    def change_child_num(self, num_or_name, new_num):\n\t        child = self.child(num_or_name)\n\t        if self.has_child(new_num):\n\t            raise AlreadyExistsXManError(f\"Can't change number to `{new_num}` for `{child}` - \"\n\t                                            f\"new number is already taken by other child!\")\n", "        dir_path = child.location_dir\n\t        child_dir_pattern = filesystem.dir_prefix(maker.get_child_class(self))\n\t        new_path = filesystem.change_num_in_path_by_pattern(dir_path, child_dir_pattern, new_num)\n\t        filesystem.rename_or_move_dir(dir_path, new_path)\n\t        self._remove_child(child)\n\t        # Also changes `num` as it's processing from the path:\n\t        child._change_location_dir(new_path)\n\t        self._add_child(child)\n\t    def _add_child(self, child):\n\t        self.__num_to_child[child.num] = child\n", "        self.__name_to_child[child._data.name] = child\n\t        child._parent = self\n\t    def _remove_child(self, child):\n\t        del self.__num_to_child[child.num]\n\t        del self.__name_to_child[child._data.name]\n\t        child._parent = None\n\t    def _process_auto_status(self):\n\t        resolution = ExpStruct._AUTO_STATUS_RESOLUTION\n\t        if self.__children_has_status(ExpStructStatus.ERROR, False):\n\t            status = ExpStructStatus.ERROR\n", "        elif self.__children_has_status(ExpStructStatus.IN_PROGRESS, False):\n\t            status = ExpStructStatus.IN_PROGRESS\n\t        elif self.__children_has_status(ExpStructStatus.EMPTY, True):\n\t            status = ExpStructStatus.EMPTY\n\t        elif self.__children_has_status(ExpStructStatus.TO_DO, True):\n\t            status = ExpStructStatus.TO_DO\n\t        elif self.__children_has_status(ExpStructStatus.DONE, True):\n\t            status = ExpStructStatus.DONE\n\t        elif self.__children_has_status(ExpStructStatus.SUCCESS, True):\n\t            status = ExpStructStatus.SUCCESS\n", "        elif self.__children_has_status(ExpStructStatus.FAIL, True):\n\t            status = ExpStructStatus.FAIL\n\t        elif self.__children_has_status([ExpStructStatus.EMPTY, ExpStructStatus.TO_DO], True):\n\t            status = ExpStructStatus.TO_DO\n\t        elif self.__children_has_status([ExpStructStatus.DONE, ExpStructStatus.SUCCESS,\n\t                                         ExpStructStatus.FAIL], True):\n\t            status = ExpStructStatus.DONE\n\t        else:\n\t            status = ExpStructStatus.IN_PROGRESS\n\t        return status, resolution\n", "    def _destroy(self):\n\t        for child in self.children():\n\t            child._destroy()\n\t        self.__num_to_child.clear()\n\t        self.__num_to_child = None\n\t        self.__name_to_child.clear()\n\t        self.__name_to_child = None\n\t        super()._destroy()\n\t    def __init__(self, location_dir, parent):\n\t        self.__num_to_child = {}\n", "        self.__name_to_child = {}\n\t        self.__updating = False\n\t        super().__init__(location_dir, parent)\n\t    def __children_has_status(self, status_str_or_list, all_children: bool):\n\t        sl = status_str_or_list if type(status_str_or_list) is list else [status_str_or_list]\n\t        for child in self.children():\n\t            s = child.status.status_str\n\t            if all_children:\n\t                if s not in sl:\n\t                    return False\n", "            else:\n\t                if s in sl:\n\t                    return True\n\t        return True if all_children else False\n"]}
{"filename": "src/xman/pipeline.py", "chunked_list": ["import os\n\timport threading\n\tfrom threading import Timer\n\tfrom typing import Any, Callable, Optional, List\n\tfrom . import filesystem, platform\n\tfrom .config import PipelineConfig\n\tfrom .error import get_error_str, get_error_stack_str, NotExistsXManError\n\tclass CheckpointsMediator:\n\t    @property\n\t    def exp_location_dir(self): return self.__exp_location_dir\n", "    @property\n\t    def default_checkpoints_dir(self): return self.__default_checkpoints_dir\n\t    def save_checkpoint(self, checkpoint: Any, replace: bool,\n\t                        custom_path: str = None) -> str:\n\t        # TODO Delete work plan or rework it to the docs\n\t        \"\"\"\n\t        + Saves all checkpoints placed inside the exp folder as relative to the folder.\n\t        + If a custom_path was placed outside the exp folder, the path will be saved as it was\n\t        provided.\n\t        + During loading the path will be tried first as a relative to the exp folder, then as it\n", "        is, if source via the relative path doesn't exist.\n\t        + If both paths aren't exist, then NotExist exception will be raised with mentioning of JSON\n\t        file which should be fixed manually or checkpoints folder should be deleted via special\n\t        method.\n\t        + Refine checkpoints on pipeline start\n\t        + Refine checkpoints on getting via mediator's method\n\t        \"\"\"\n\t        cp_list = self.get_checkpoint_paths_list(check_files_exist=True)\n\t        if replace and cp_list is not None:\n\t            for cp_path in cp_list:\n", "                filesystem.delete_checkpoint(self.__exp_location_dir, cp_path)\n\t            filesystem.delete_checkpoints_list(self.__exp_location_dir)\n\t            cp_list = None\n\t        if not filesystem.has_checkpoints_dir(self.__exp_location_dir):\n\t            filesystem.make_checkpoints_dir(self.__exp_location_dir)\n\t        cp_path = filesystem.save_checkpoint(self.__exp_location_dir, checkpoint, custom_path)\n\t        cp_list = [] if cp_list is None else cp_list\n\t        cp_list.append(cp_path)\n\t        filesystem.save_checkpoints_list(self.__exp_location_dir, cp_list)\n\t        return cp_path if custom_path is None else custom_path\n", "    def get_checkpoint_paths_list(self, check_files_exist: bool = True) -> Optional[List[str]]:\n\t        lst = filesystem.load_checkpoints_list(self.__exp_location_dir)\n\t        if lst is None or not check_files_exist:\n\t            return lst\n\t        missed = []\n\t        for it in lst:\n\t            path = filesystem.resolve_checkpoint_path(self.__exp_location_dir, it)\n\t            if path is None:\n\t                missed.append(it)\n\t        if len(missed):\n", "            json_path = filesystem.get_checkpoints_list_path(self.__exp_location_dir)\n\t            NotExistsXManError(f\"Can't resolve some checkpoints paths - {missed}! You can fix paths\"\n\t                               f\" right in the {json_path} or remove checkpoints via \"\n\t                               f\"`exp.delete_checkpoints()` method of the experiment structure.\")\n\t        return lst\n\t    def load_checkpoint(self, checkpoint_path: str) -> Optional[Any]:\n\t        path = filesystem.resolve_checkpoint_path(self.__exp_location_dir, checkpoint_path)\n\t        if path is None:\n\t            raise NotExistsXManError(f\"Can't find checkpoint by the path `{checkpoint_path}`!\")\n\t        return filesystem.load_checkpoint(path)\n", "    def __init__(self, exp_location_dir: str):\n\t        self.__exp_location_dir = exp_location_dir\n\t        self.__default_checkpoints_dir = filesystem.get_checkpoints_dir_path(exp_location_dir)\n\t        # Check checkpoints are ok (paths can be lost during files or folders moving:\n\t        self.get_checkpoint_paths_list(check_files_exist=True)\n\tclass PipelineData:  # Saved in exp._data.pipeline\n\t    def __init__(self):\n\t        self.started: bool = False\n\t        self.finished: bool = False\n\t        self.error: str = None\n", "        self.error_stack: str = None\n\tclass PipelineRunData:  # Saved in `.run` file, might be really heavy (several GB)\n\t    def __init__(self, run_func: Callable[..., Any] | Callable[[CheckpointsMediator, ...], Any],\n\t                 with_mediator: bool, params: dict):\n\t        self.run_func = run_func\n\t        self.with_mediator = with_mediator\n\t        self.params = params\n\tclass Pipeline:\n\t    def start(self):\n\t        data = self.__data\n", "        run_data = self.__run_data\n\t        error = None\n\t        self.__do_timestamp()\n\t        try:\n\t            if run_data.with_mediator:\n\t                self.__mediator = CheckpointsMediator(self.__location_dir)\n\t                result = run_data.run_func(self.__mediator, **run_data.params)\n\t            else:\n\t                result = run_data.run_func(**run_data.params)\n\t            filesystem.save_pipeline_result(self.__location_dir, result)\n", "            data.finished = True\n\t        except Exception as e:\n\t            error = e\n\t            self.__process_error(e)\n\t        if error is not None:\n\t            raise error\n\t    def _destroy(self):\n\t        filesystem.delete_pipeline_run_timestamp(self.__location_dir)\n\t        if self.__timer is not None:\n\t            self.__timer.cancel()\n", "            self.__timer = None\n\t        self.__mediator = None\n\t        self.__data = None\n\t        self.__run_data = None\n\t    def __init__(self, location_dir: str, data: PipelineData, run_data: PipelineRunData):\n\t        self.__location_dir = os.path.normpath(location_dir)\n\t        self.__data = data\n\t        self.__run_data = run_data\n\t        self.__mediator: CheckpointsMediator = None\n\t        self.__timer: Timer = None\n", "    def __process_error(self, error):\n\t        data = self.__data\n\t        data.error = get_error_str(error)\n\t        data.error_stack = get_error_stack_str(error)\n\t    def __do_timestamp(self):\n\t        if platform.is_jupyter_notebook and platform.check_jupyter_notebook_kernel_interrupted():\n\t            return\n\t        filesystem.save_pipeline_run_timestamp(self.__location_dir)\n\t        self.__timer = threading.Timer(PipelineConfig.timer_interval, self.__do_timestamp)\n\t        self.__timer.start()\n"]}
{"filename": "src/xman/tree.py", "chunked_list": ["import os\n\timport re\n\t__tab = '    '\n\t__regex = r'\\d+'\n\tdef __sort_by_number(name):\n\t    match = re.search(__regex, name)\n\t    return int(match.group()) if match else 0\n\tdef __sort_content_by_folders_and_files(target_dir, sort_numbers):\n\t    names = os.listdir(target_dir)\n\t    names = sorted(names, key=__sort_by_number) if sort_numbers else sorted(names)\n", "    dirs = []\n\t    files = []\n\t    for it in names:\n\t        p = os.path.join(target_dir, it)\n\t        if os.path.isdir(p):\n\t            dirs.append(it)\n\t        elif os.path.isfile(p):\n\t            files.append(it)\n\t        else:\n\t            continue\n", "    return dirs, files\n\tdef __dirs_part(\n\t        target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs):\n\t    for d in dirs:\n\t        p = os.path.join(target_dir, d)\n\t        __process_dir(p, depth, current_depth + 1, result, files_limit, files_first, sort_numbers)\n\tdef __files_part(target_dir, current_depth, result, files):\n\t    for f in files:\n\t        p = os.path.join(target_dir, f)\n\t        if f.startswith('...'):\n", "            result.append(f\"{__tab * (current_depth + 1)}{f}\")\n\t            continue\n\t        result.append(f\"{__tab * (current_depth + 1)}{os.path.basename(p)}\")\n\tdef __process_dir(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers):\n\t    if target_dir.endswith('/'):\n\t        target_dir = target_dir[:-1]\n\t    result.append(f\"{__tab * current_depth}{os.path.basename(target_dir) + '/'}\")\n\t    if depth is not None and current_depth > depth:\n\t        if len(os.listdir(target_dir)):\n\t            result[-1] += '...'\n", "        return\n\t    dirs, files = __sort_content_by_folders_and_files(target_dir, sort_numbers)\n\t    files_len = len(files)\n\t    if 0 < files_limit < files_len:\n\t        trimmed = files[:2]\n\t        trimmed.append(f\"... {files_len - 3} other files are hidden ... \")\n\t        trimmed.append(files[-1])\n\t        files = trimmed\n\t    if files_first:\n\t        __files_part(target_dir, current_depth, result, files)\n", "        __dirs_part(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs)\n\t    else:\n\t        __dirs_part(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs)\n\t        __files_part(target_dir, current_depth, result, files)\n\t# TODO Move prints to the API, rename to `dir_tree`\n\tdef print_dir_tree(target_dir: str, depth: int = None, files_limit: int = 10,\n\t                   files_first: bool = True, sort_numbers: bool = True):\n\t    print()\n\t    result = []\n\t    __process_dir(target_dir, depth, 0, result, files_limit, files_first, sort_numbers)\n", "    for it in result:\n\t        print(it)\n\t    print()\n"]}
{"filename": "src/xman/filter.py", "chunked_list": ["from typing import List, Callable\n\tfrom .error import ArgumentsXManError\n\tfrom .struct import ExpStructStatus\n\tdef intersect(*lists):\n\t    if not lists:\n\t        return []\n\t    intersection_set = set(lists[0])\n\t    for lst in lists[1:]:\n\t        intersection_set.intersection_update(lst)\n\t    return list(intersection_set)\n", "def unite(*lists):\n\t    merged_list = []\n\t    for lst in lists:\n\t        merged_list.extend(lst)\n\t    return list(set(merged_list))\n\tdef __check_and_get_status_list(status_or_list):\n\t    lst = status_or_list if type(status_or_list) == list else [status_or_list]\n\t    for status in lst:\n\t        if not ExpStructStatus.has_status(status):\n\t            raise ArgumentsXManError(\n", "                f\"Wrong `status_or_list` param - statuses should be from the workflow \"\n\t                f\"`{ExpStructStatus.workflow}`, but `{status_or_list}` was given!\")\n\t    return lst\n\tdef __exp_key(exp): return exp.group.num, exp.num\n\tdef __group_key(group): return group.num\n\tclass Mode:\n\t    AND = 'AND'\n\t    OR = 'OR'\n\t    @staticmethod\n\t    def _check_mode(mode):\n", "        if mode != Mode.AND and mode != Mode.OR:\n\t            ArgumentsXManError(\n\t                f\"`mode` should be 'AND' or 'OR' string, but `{mode}` was given!\")\n\tdef exps(\n\t        exps: List['Exp'],\n\t        mode: str = 'AND',\n\t        custom_filter: Callable[['Exp'], bool] = None,\n\t        is_active: bool = None,\n\t        is_manual: bool = None,\n\t        is_ready_for_start: bool = None,\n", "        status_or_list: str | List[str] = None,\n\t        not_status_or_list: str | List[str] = None,\n\t        has_marker: bool = None,\n\t        marker_or_list: str | List[str] = None,\n\t        # TODO ??? Implement:\n\t        # str_in_name: str = None,\n\t        # str_in_descr: str = None,\n\t        # str_in_resolution: str = None,\n\t        # has_pipeline: bool = None,\n\t        # pipeline_started: bool = None,\n", "        # pipeline_error: bool = None,\n\t        # pipeline_finished: bool = None,\n\t        # has_manual_result: bool = None,\n\t        # has_pipeline_result: bool = None,\n\t        # has_result: bool = None,\n\t) -> List['Exp']:\n\t    Mode._check_mode(mode)\n\t    results = []\n\t    if custom_filter is not None:\n\t        results.append([x for x in exps if custom_filter(x)])\n", "    if is_active is not None:\n\t        results.append([x for x in exps if x.is_active == is_active])\n\t    if is_manual is not None:\n\t        results.append([x for x in exps if x.is_manual == is_manual])\n\t    if is_ready_for_start is not None:\n\t        results.append([x for x in exps if x.is_ready_for_start == is_ready_for_start])\n\t    if status_or_list is not None:\n\t        status_list = __check_and_get_status_list(status_or_list)\n\t        results.append([x for x in exps if x.status_str in status_list])\n\t    if not_status_or_list is not None:\n", "        not_status_list = __check_and_get_status_list(not_status_or_list)\n\t        results.append([x for x in exps if x.status_str not in not_status_list])\n\t    if has_marker is not None:\n\t        results.append([x for x in exps if (x.marker is not None) == has_marker])\n\t    if marker_or_list is not None:\n\t        lst = marker_or_list if type(marker_or_list) == list else [marker_or_list]\n\t        results.append([x for x in exps if x.marker in lst])\n\t    result = intersect(*results) if mode == Mode.AND else unite(*results)\n\t    return sorted(result, key=__exp_key)\n\tdef groups(\n", "        groups: List['ExpGroup'],\n\t        mode: str = 'AND',\n\t        custom_filter: Callable[['ExpGroup'], bool] = None,\n\t        status_or_list: str | List[str] = None,\n\t        not_status_or_list: str | List[str] = None,\n\t) -> List['ExpGroup']:\n\t    Mode._check_mode(mode)\n\t    results = []\n\t    if custom_filter is not None:\n\t        results.append([x for x in groups if custom_filter(x)])\n", "    if status_or_list is not None:\n\t        status_list = __check_and_get_status_list(status_or_list)\n\t        results.append([x for x in groups if x.status_str in status_list])\n\t    if not_status_or_list is not None:\n\t        not_status_list = __check_and_get_status_list(not_status_or_list)\n\t        results.append([x for x in groups if x.status_str not in not_status_list])\n\t    result = intersect(*results) if mode == Mode.AND else unite(*results)\n\t    return sorted(result, key=__group_key)\n"]}
{"filename": "src/xman/api.py", "chunked_list": ["from typing import Any, Optional, Callable, List\n\tfrom . import tree, maker, filesystem\n\tfrom .error import NotImplementedXManError, IllegalOperationXManError\n\tfrom .group import ExpGroup\n\tfrom .note import Note\n\tfrom .pipeline import CheckpointsMediator\n\tfrom .exp import Exp\n\tfrom .proj import ExpProj\n\tfrom .struct import ExpStructStatus, ExpStruct\n\tdef _get_apis_from_list(objs: List[Exp | ExpGroup]) -> List['ExpAPI | ExpGroupAPI']:\n", "    return [x.api for x in objs]\n\tclass ExpStructAPI:\n\t    @property\n\t    def location_dir(self) -> str: return self._obj.location_dir\n\t    @property\n\t    def num(self) -> int: return self._obj.num\n\t    @property\n\t    def name(self) -> str:\n\t        self._obj.update()\n\t        return self._obj.name\n", "    @property\n\t    def descr(self) -> str:\n\t        self._obj.update()\n\t        return self._obj.descr\n\t    @property\n\t    def status(self) -> ExpStructStatus:\n\t        self._obj.update()\n\t        return self._obj.status\n\t    @property\n\t    def is_manual(self) -> bool:\n", "        self._obj.update()\n\t        return self._obj.is_manual\n\t    @property\n\t    def result_stringifier(self) -> Callable[[Any], str]:\n\t        self._obj.update()\n\t        return self._obj.result_stringifier\n\t    @result_stringifier.setter\n\t    def result_stringifier(self, value: Callable[[Any], str]):\n\t        self._obj.update()\n\t        self._obj.result_stringifier = value\n", "    @property\n\t    def result_viewer(self) -> Callable[[Any], None]:\n\t        self._obj.update()\n\t        return self._obj.result_viewer\n\t    @result_viewer.setter\n\t    def result_viewer(self, value: Callable[[Any], None]):\n\t        self._obj.update()\n\t        self._obj.result_viewer = value\n\t    @property\n\t    def note(self) -> Note:\n", "        # self._obj.update()  # No need to update\n\t        return self._obj.note\n\t    def tree(self, depth: int = None):\n\t        self._obj.update()\n\t        self._obj.tree(depth)\n\t    def info(self):\n\t        self._obj.update()\n\t        text = self._obj.info()\n\t        print(text)\n\t    def update(self):\n", "        self._obj.update()\n\t    def set_manual_status(self, status: str, resolution: str) -> 'ExpStructAPI':\n\t        self._obj.update()\n\t        self._obj.set_manual_status(status, resolution)\n\t        return self\n\t    def delete_manual_status(self, need_confirm: bool = True) -> Optional['ExpStructAPI']:\n\t        self._obj.update()\n\t        obj = self._obj.delete_manual_status(need_confirm)\n\t        return None if obj is None else self\n\t    def success(self, resolution: str) -> Optional['ExpStructAPI']:\n", "        self._obj.update()\n\t        self._obj.success(resolution)\n\t        return self\n\t    def fail(self, resolution: str) -> Optional['ExpStructAPI']:\n\t        self._obj.update()\n\t        self._obj.fail(resolution)\n\t        return self\n\t    def edit(self, name: str = None, descr: str = None):\n\t        # Need to update parent (and all its children) to check other children on the same name:\n\t        self._obj.update() if self._obj.parent is None else self._obj.parent.update()\n", "        self._obj.edit(name, descr)\n\t    # Printing in jupyter notebook - https://stackoverflow.com/a/41454816/9751954\n\t    def _repr_pretty_(self, p, cycle): p.text(str(self) if not cycle else '...')\n\t    def __init__(self, obj: ExpStruct): self._obj = obj  # for autocomplete\n\t    def __str__(self):\n\t        self._obj.update()\n\t        return str(self._obj)\n\tclass ExpAPI(ExpStructAPI):\n\t    @property\n\t    def group(self) -> 'ExpGroupAPI':\n", "        group = self._obj.group\n\t        group.update()\n\t        return group.api\n\t    @property\n\t    def proj(self) -> 'ExpProjAPI':\n\t        proj = self._obj.proj\n\t        proj.update()\n\t        return proj.api\n\t    @property\n\t    def is_active(self) -> bool:\n", "        self._obj.update()\n\t        return self._obj.is_active\n\t    @property\n\t    def is_ready_for_start(self) -> bool:\n\t        self._obj.update()\n\t        return self._obj.is_ready_for_start\n\t    @property\n\t    def state(self) -> str:\n\t        self._obj.update()\n\t        return self._obj.state\n", "    @property\n\t    def has_pipeline(self) -> bool:\n\t        self._obj.update()\n\t        return self._obj.has_pipeline\n\t    @property\n\t    def has_result(self) -> bool:\n\t        self._obj.update()\n\t        return self._obj.has_result\n\t    @property\n\t    def has_pipeline_result(self) -> bool:\n", "        self._obj.update()\n\t        return self._obj.has_pipeline_result\n\t    @property\n\t    def has_manual_result(self) -> bool:\n\t        self._obj.update()\n\t        return self._obj.has_manual_result\n\t    @property\n\t    def result(self) -> Optional[Any]:\n\t        self._obj.update()\n\t        return self._obj.result\n", "    @property\n\t    def error(self) -> Optional[str]:\n\t        self._obj.update()\n\t        return self._obj.error\n\t    @property\n\t    def error_stack(self) -> Optional[str]:\n\t        self._obj.update()\n\t        return self._obj.error_stack\n\t    @property\n\t    def checkpoints_mediator(self) -> CheckpointsMediator:\n", "        # self._obj.update()  # No need to update\n\t        return self._obj.checkpoints_mediator\n\t    @property\n\t    def marker(self) -> str:\n\t        self._obj.update()\n\t        return self._obj.marker\n\t    @marker.setter\n\t    def marker(self, value):\n\t        self._obj.update()\n\t        self._obj.marker = value\n", "    def stringify_result(self) -> str:\n\t        self._obj.update()\n\t        return self._obj.stringify_result()\n\t    def view_result(self):\n\t        self._obj.update()\n\t        self._obj.view_result()\n\t    def make_pipeline(self, run_func: Callable[..., Any],\n\t                      params: dict, save_on_storage: bool = False) -> 'ExpAPI':\n\t        self._obj.update()\n\t        self._obj.make_pipeline(run_func, params, save_on_storage)\n", "        return self\n\t    def make_pipeline_with_checkpoints(self,\n\t                               run_func_with_mediator: Callable[[CheckpointsMediator, ...], Any],\n\t                               params: dict, save_on_storage: bool = False) -> 'ExpAPI':\n\t        self._obj.update()\n\t        self._obj.make_pipeline_with_checkpoints(run_func_with_mediator, params, save_on_storage)\n\t        return self\n\t    def get_pipeline_result(self) -> Any:\n\t        self._obj.update()\n\t        return self._obj.get_pipeline_result()\n", "    def delete_pipeline(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n\t        self._obj.update()\n\t        obj = self._obj.delete_pipeline(need_confirm)\n\t        return None if obj is None else self\n\t    def delete_checkpoints(self, need_confirm: bool = True,\n\t                           delete_custom_paths: bool = False) -> Optional['ExpAPI']:\n\t        self._obj.update()\n\t        obj = self._obj.delete_checkpoints(need_confirm, delete_custom_paths)\n\t        return None if obj is None else self\n\t    def start(self, force_after_error: bool = False) -> 'ExpAPI':\n", "        self._obj.update()\n\t        self._obj.start(force_after_error=force_after_error)\n\t        return self\n\t    def get_manual_result(self) -> Any:\n\t        self._obj.update()\n\t        return self._obj.get_manual_result()\n\t    def set_manual_result(self, result: Any) -> 'ExpAPI':\n\t        self._obj.update()\n\t        obj = self._obj.set_manual_result(result)\n\t        return None if obj is None else self\n", "    def delete_manual_result(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n\t        self._obj.update()\n\t        obj = self._obj.delete_manual_result(need_confirm)\n\t        return None if obj is None else self\n\t    def delete_all_manual(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n\t        self._obj.update()\n\t        obj = self._obj.delete_all_manual(need_confirm)\n\t        return None if obj is None else self\n\t    def clear(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n\t        self._obj.update()\n", "        obj = self._obj.clear(need_confirm)\n\t        return None if obj is None else self\n\t    def __init__(self, obj: Exp): self._obj = obj  # for autocomplete\n\tclass ExpGroupAPI(ExpStructAPI):\n\t    @property\n\t    def proj(self) -> 'ExpProjAPI':\n\t        proj = self._obj.parent\n\t        proj.update()\n\t        return proj.api\n\t    def has_exp(self, num_or_name: int | str) -> bool:\n", "        self._obj.update()\n\t        return self._obj.has_exp(num_or_name)\n\t    def exp(self, num_or_name: int | str) -> ExpAPI:\n\t        self._obj.update()\n\t        exp = self._obj.exp(num_or_name)\n\t        return exp.api\n\t    def make_exp(self, name: str, descr: str, num: int = None) -> ExpAPI:\n\t        self._obj.update()\n\t        exp = self._obj.make_exp(name, descr, num)\n\t        return exp.api\n", "    def delete_exp(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n\t        self._obj.update()\n\t        return self._obj.delete_exp(num_or_name, need_confirm)\n\t    def exps(self) -> List[ExpAPI]:\n\t        self._obj.update()\n\t        exps = self._obj.exps()\n\t        return _get_apis_from_list(exps)\n\t    def num_exps(self) -> int:\n\t        self._obj.update()\n\t        return self._obj.num_exps()\n", "    def exps_nums(self) -> List[int]:\n\t        self._obj.update()\n\t        return self._obj.exps_nums()\n\t    def exps_names(self) -> List[str]:\n\t        self._obj.update()\n\t        return self._obj.exps_names()\n\t    def change_exp_num(self, num_or_name: int | str, new_num: int):\n\t        self._obj.update()\n\t        self._obj.change_exp_num(num_or_name, new_num)\n\t    def filter_exps(self,\n", "                    mode: str = 'AND',\n\t                    custom_filter: Callable[[Exp], bool] = None,\n\t                    is_active: bool = None,\n\t                    is_manual: bool = None,\n\t                    is_ready_for_start: bool = None,\n\t                    status_or_list: str | List[str] = None,\n\t                    not_status_or_list: str | List[str] = None,\n\t                    has_marker: bool = None,\n\t                    marker_or_list: str | List[str] = None,\n\t                    ) -> List[ExpAPI]:\n", "        self._obj.update()\n\t        exps = self._obj.filter_exps(mode, custom_filter, is_active, is_manual, is_ready_for_start,\n\t                                     status_or_list, not_status_or_list, has_marker, marker_or_list)\n\t        return _get_apis_from_list(exps)\n\t    def get_exp_for_start(self) -> Optional[ExpAPI]:\n\t        self._obj.update()\n\t        exp = self._obj.get_exp_for_start()\n\t        return None if exp is None else exp.api\n\t    def start(self, exp_num_or_name: int | str = None, autostart_next: bool = False):\n\t        self._obj.update()\n", "        self._obj.start(exp_num_or_name, autostart_next)\n\t    def __init__(self, obj: ExpGroup): self._obj = obj  # for autocomplete\n\tclass ExpProjAPI(ExpStructAPI):\n\t    @property\n\t    def num(self) -> int:\n\t        raise NotImplementedXManError(f\"`num` property isn't supported for a project!\")\n\t    def has_group(self, num_or_name: int | str) -> bool:\n\t        self._obj.update()\n\t        return self._obj.has_group(num_or_name)\n\t    def group(self, num_or_name: int | str) -> ExpGroupAPI:\n", "        self._obj.update()\n\t        group = self._obj.group(num_or_name)\n\t        return group.api\n\t    def make_group(self, name: str, descr: str, num: int = None) -> ExpGroupAPI:\n\t        self._obj.update()\n\t        group = self._obj.make_group(name, descr, num)\n\t        return group.api\n\t    def delete_group(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n\t        self._obj.update()\n\t        return self._obj.delete_group(num_or_name, need_confirm)\n", "    def groups(self) -> List[ExpGroupAPI]:\n\t        self._obj.update()\n\t        groups = self._obj.groups()\n\t        return _get_apis_from_list(groups)\n\t    def num_groups(self) -> int:\n\t        self._obj.update()\n\t        return self._obj.num_groups()\n\t    def groups_nums(self) -> List[int]:\n\t        self._obj.update()\n\t        return self._obj.groups_nums()\n", "    def groups_names(self) -> List[str]:\n\t        self._obj.update()\n\t        return self._obj.groups_names()\n\t    def change_group_num(self, num_or_name: int | str, new_num: int):\n\t        self._obj.update()\n\t        self._obj.change_group_num(num_or_name, new_num)\n\t    def filter_groups(self,\n\t                      mode: str = 'AND',\n\t                      custom_filter: Callable[[ExpGroup], bool] = None,\n\t                      status_or_list: str | List[str] = None,\n", "                      not_status_or_list: str | List[str] = None,\n\t                      ) -> List[ExpGroupAPI]:\n\t        self._obj.update()\n\t        groups = self._obj.filter_groups(mode, custom_filter, status_or_list, not_status_or_list)\n\t        return _get_apis_from_list(groups)\n\t    def has_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> bool:\n\t        self._obj.update()\n\t        return self._obj.has_exp(group_num_or_name, exp_num_or_name)\n\t    def exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> ExpAPI:\n\t        self._obj.update()\n", "        exp = self._obj.exp(group_num_or_name, exp_num_or_name)\n\t        return exp.api\n\t    def make_exp(self, group_num_or_name: int | str, name: str, descr: str, num: int = None) -> ExpAPI:\n\t        self._obj.update()\n\t        exp = self._obj.make_exp(group_num_or_name, name, descr, num)\n\t        return exp.api\n\t    def delete_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n\t                   need_confirm: bool = True) -> bool:\n\t        self._obj.update()\n\t        return self._obj.delete_exp(group_num_or_name, exp_num_or_name, need_confirm)\n", "    def exps(self, group_num_or_name: int | str = None) -> List[ExpAPI]:\n\t        self._obj.update()\n\t        exps = self._obj.exps(group_num_or_name)\n\t        return _get_apis_from_list(exps)\n\t    def num_exps(self, group_num_or_name: int | str = None) -> int:\n\t        self._obj.update()\n\t        return self._obj.num_exps(group_num_or_name)\n\t    def exps_nums(self, group_num_or_name: int | str = None) -> List[int]:\n\t        self._obj.update()\n\t        return self._obj.exps_nums(group_num_or_name)\n", "    def exps_names(self, group_num_or_name: int | str = None) -> List[str]:\n\t        self._obj.update()\n\t        return self._obj.exps_names(group_num_or_name)\n\t    def filter_exps(self,\n\t                    group_num_or_name: int | str = None,\n\t                    mode: str = 'AND',\n\t                    custom_filter: Callable[[Exp], bool] = None,\n\t                    is_active: bool = None,\n\t                    is_manual: bool = None,\n\t                    is_ready_for_start: bool = None,\n", "                    status_or_list: str | List[str] = None,\n\t                    not_status_or_list: str | List[str] = None,\n\t                    has_marker: bool = None,\n\t                    marker_or_list: str | List[str] = None,\n\t                    ) -> List[ExpAPI]:\n\t        self._obj.update()\n\t        exps = self._obj.filter_exps(group_num_or_name, mode, custom_filter, is_active, is_manual,\n\t                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\t        return _get_apis_from_list(exps)\n\t    def get_exp_for_start(self, group_num_or_name: int | str = None) -> Optional[ExpAPI]:\n", "        self._obj.update()\n\t        exp = self._obj.get_exp_for_start(group_num_or_name)\n\t        return None if exp is None else exp.api\n\t    def start(self, group_num_or_name: int | str = None,\n\t              exp_num_or_name: int | str = None, autostart_next: bool = False):\n\t        self._obj.update()\n\t        self._obj.start(group_num_or_name, exp_num_or_name, autostart_next)\n\t    def move_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n\t                 new_group_num_or_name: int | str, new_exp_num: int):\n\t        self._obj.update()\n", "        self._obj.move_exp(group_num_or_name, exp_num_or_name, new_group_num_or_name, new_exp_num)\n\t    def __init__(self, obj: ExpProj): self._obj = obj  # for autocomplete\n\tclass XManAPI:\n\t    @staticmethod\n\t    def dir_tree(target_dir: str, depth: int = 0, files_limit: int = 10,\n\t                 files_first: bool = True, sort_numbers: bool = True):\n\t        tree.print_dir_tree(target_dir, depth, files_limit, files_first, sort_numbers)\n\t    @staticmethod\n\t    def make_dir(dir_path: str, exist_ok: bool = True): filesystem.make_dir(dir_path, exist_ok)\n\t    @staticmethod\n", "    def delete_dir(dir_path: str, need_confirm: bool = True) -> bool:\n\t        return filesystem.delete_dir(dir_path, need_confirm)\n\t    @staticmethod\n\t    def rename_or_move_dir(dir_path: str, new_path: str):\n\t        filesystem.rename_or_move_dir(dir_path, new_path)\n\t    @property\n\t    def location_dir(self) -> str:\n\t        self.__check_proj()\n\t        return self.__proj.location_dir\n\t    @property\n", "    def proj(self) -> ExpProjAPI:\n\t        self.__check_proj()\n\t        self.__proj.update()\n\t        return self.__proj\n\t    def make_proj(self, location_dir: str, name: str, descr: str) -> ExpProjAPI:\n\t        self.__destroy_old_proj()\n\t        proj = maker.make_proj(location_dir, name, descr)\n\t        self.__proj = proj.api\n\t        return self.__proj\n\t    def load_proj(self, location_dir: str) -> ExpProjAPI:\n", "        self.__destroy_old_proj()\n\t        proj = maker.recreate_proj(location_dir)\n\t        self.__proj = proj.api\n\t        return self.__proj\n\t    def reload(self):\n\t        self.__check_proj()\n\t        self.load_proj(self.__proj.location_dir)\n\t    def info(self):\n\t        self.__check_proj()\n\t        self.__proj.info()\n", "    def update(self):\n\t        self.__check_proj()\n\t        self.__proj.update()\n\t    def has_group(self, num_or_name: int | str) -> bool:\n\t        self.__check_proj()\n\t        return self.__proj.has_group(num_or_name)\n\t    def group(self, num_or_name: int | str) -> ExpGroupAPI:\n\t        self.__check_proj()\n\t        return self.__proj.group(num_or_name)\n\t    def make_group(self, name: str, descr: str, num: int = None) -> ExpGroupAPI:\n", "        self.__check_proj()\n\t        return self.__proj.make_group(name, descr, num)\n\t    def delete_group(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n\t        self.__check_proj()\n\t        return self.__proj.delete_group(num_or_name, need_confirm)\n\t    def groups(self) -> List[ExpGroupAPI]:\n\t        self.__check_proj()\n\t        return self.__proj.groups()\n\t    def filter_groups(self,\n\t                      mode: str = 'AND',\n", "                      custom_filter: Callable[[ExpGroup], bool] = None,\n\t                      status_or_list: str | List[str] = None,\n\t                      not_status_or_list: str | List[str] = None,\n\t                      ) -> List[ExpGroupAPI]:\n\t        self.__check_proj()\n\t        return self.__proj.filter_groups(mode, custom_filter, status_or_list, not_status_or_list)\n\t    def has_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> bool:\n\t        self.__check_proj()\n\t        return self.__proj.has_exp(group_num_or_name, exp_num_or_name)\n\t    def exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> ExpAPI:\n", "        self.__check_proj()\n\t        return self.__proj.exp(group_num_or_name, exp_num_or_name)\n\t    def make_exp(self, group_num_or_name: int | str, name: str, descr: str, num: int = None) -> ExpAPI:\n\t        self.__check_proj()\n\t        return self.__proj.make_exp(group_num_or_name, name, descr, num)\n\t    def delete_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n\t                   need_confirm: bool = True) -> bool:\n\t        self.__check_proj()\n\t        return self.__proj.delete_exp(group_num_or_name, exp_num_or_name, need_confirm)\n\t    def exps(self, group_num_or_name: int | str = None) -> List[ExpAPI]:\n", "        self.__check_proj()\n\t        return self.__proj.exps(group_num_or_name)\n\t    def filter_exps(self,\n\t                    group_num_or_name: int | str = None,\n\t                    mode: str = 'AND',\n\t                    custom_filter: Callable[[Exp], bool] = None,\n\t                    is_active: bool = None,\n\t                    is_manual: bool = None,\n\t                    is_ready_for_start: bool = None,\n\t                    status_or_list: str | List[str] = None,\n", "                    not_status_or_list: str | List[str] = None,\n\t                    has_marker: bool = None,\n\t                    marker_or_list: str | List[str] = None,\n\t                    ) -> List[ExpAPI]:\n\t        self.__check_proj()\n\t        return self.__proj.filter_exps(group_num_or_name, mode, custom_filter, is_active, is_manual,\n\t                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\t    def get_exp_for_start(self, group_num_or_name: int | str = None) -> Optional[ExpAPI]:\n\t        self.__check_proj()\n\t        return self.__proj.get_exp_for_start(group_num_or_name)\n", "    def start(self, group_num_or_name: int | str = None,\n\t              exp_num_or_name: int | str = None, autostart_next: bool = False):\n\t        self.__check_proj()\n\t        self.__proj.start(group_num_or_name, exp_num_or_name, autostart_next)\n\t    def __init__(self): self.__proj: ExpProjAPI = None\n\t    def __check_proj(self):\n\t        if self.__proj is None:\n\t            raise IllegalOperationXManError(f\"There's no project - use `xman.make_proj(...)` or \"\n\t                                            f\"`xman.load_proj(...)` first!\")\n\t    def __destroy_old_proj(self):\n", "        if self.__proj is not None:\n\t            self.__proj._obj._destroy()\n\t            self.__proj = None\n"]}
{"filename": "src/xman/__init__.py", "chunked_list": ["__version__ = '0.2.1'\n\tfrom .api import XManAPI\n\txman = XManAPI()\n"]}
{"filename": "src/xman/exp_helper.py", "chunked_list": ["from . import util\n\tfrom .structbox import ExpStructBox\n\tdef get_info_with_marked_exps(box: ExpStructBox) -> str:\n\t    from .proj import ExpProj\n\t    text = super(type(box), box).info()\n\t    lst = box.filter_exps(has_marker=True)\n\t    mark_num = util.TAB_NUM_SPACES * (2 if isinstance(box, ExpProj) else 1) - 1\n\t    mark = '>' * mark_num\n\t    for exp in lst:\n\t        exp_str = str(exp)\n", "        lines = text.splitlines()\n\t        for i, line in enumerate(lines):\n\t            if exp_str in line:\n\t                lines[i] = mark + line[mark_num:]\n\t                break\n\t        text = '\\n'.join(lines)\n\t    return text\n"]}
{"filename": "src/xman/filesystem.py", "chunked_list": ["import json\n\timport os\n\timport shutil\n\timport time\n\timport re\n\tfrom enum import Enum\n\tfrom pathlib import Path\n\tfrom typing import Optional, Any\n\timport cloudpickle as pickle  # dill as pickle, cloudpickle as pickle, pickle\n\tfrom .error import ArgumentsXManError, IllegalOperationXManError, NotImplementedXManError, \\\n", "    NotExistsXManError\n\tfrom . import util, maker, confirm\n\tclass FileType(Enum):\n\t    TXT = '.txt'\n\t    JSON = '.json'\n\t    PICKLE = '.pickle'\n\tdef make_dir(dir_path, exist_ok=True): os.makedirs(dir_path, exist_ok=exist_ok)\n\tdef delete_dir(dir_path, need_confirm=True) -> bool:\n\t    if has(dir_path) and len(os.listdir(dir_path)) > 0 and not confirm.request(\n\t            need_confirm, f\"ATTENTION! Dir `{dir_path}`\\nisn't empty - delete anyway?\"):\n", "        return False\n\t    shutil.rmtree(dir_path, ignore_errors=True)\n\t    return True\n\tdef rename_or_move_dir(dir_path, new_path): shutil.move(dir_path, new_path)\n\tdef __get_data_path(location_dir): return os.path.join(location_dir, '.data')\n\tdef __get_time_path(location_dir): return os.path.join(location_dir, '.time')\n\tdef get_manual_result_path(location_dir): return os.path.join(location_dir, '.manual_result')\n\tdef __get_run_path(location_dir): return os.path.join(location_dir, '.run')\n\tdef __get_run_time_path(location_dir): return os.path.join(location_dir, '.run_time')\n\tdef get_pipeline_result_path(location_dir): return os.path.join(location_dir, '.pipeline_result')\n", "def get_checkpoints_dir_path(location_dir): return os.path.join(location_dir, 'checkpoints/')\n\tdef get_checkpoints_list_path(location_dir):\n\t    return os.path.join(get_checkpoints_dir_path(location_dir), 'list.json')\n\tdef __get_checkpoint_path(location_dir):\n\t    current_time_ns = time.time_ns()\n\t    current_time_s = current_time_ns // 10 ** 9  # Convert nanoseconds to seconds\n\t    formatted_time = time.strftime(\"%Y-%m-%d__%H_%M_%S\", time.gmtime(current_time_s))\n\t    fname = formatted_time + '--' + str(current_time_ns)[-9:] + '.cp'\n\t    return os.path.join(get_checkpoints_dir_path(location_dir), fname)\n\tdef get_note_path(location_dir, file_type: FileType):\n", "    return os.path.join(location_dir, 'note' + file_type.value)\n\tdef get_dir_num(dir_path):\n\t    match = re.search(r'[1-9][0-9]*$', dir_path)\n\t    return int(match.group()) if match else None\n\tdef change_num_in_path_by_pattern(path, pattern, new_num) -> str:\n\t    return re.sub(fr'\\b{pattern}[1-9][0-9]*\\b', f'{pattern}{new_num}', path)\n\tdef change_exp_num_in_path(path: str, new_exp_num: int) -> str:\n\t    return change_num_in_path_by_pattern(path, 'exp', new_exp_num)\n\tdef change_group_num_in_path(path: str, new_group_num: int) -> str:\n\t    return change_num_in_path_by_pattern(path, 'group', new_group_num)\n", "def __get_dir_nums_by_pattern(dir_path, dir_pattern):\n\t    regex = fr'^{dir_pattern}([1-9][0-9]*)$'\n\t    names = os.listdir(dir_path)\n\t    dirs = [x for x in names if os.path.isdir(os.path.join(dir_path, x))]\n\t    nums = []\n\t    for it in dirs:\n\t        match = re.match(regex, it)\n\t        if match:\n\t            nums.append(int(match.group(1)))\n\t    nums.sort()\n", "    return nums\n\tdef dir_prefix(struct_obj_or_cls):\n\t    from .exp import Exp\n\t    from .group import ExpGroup\n\t    from .proj import ExpProj\n\t    cls = util.get_cls(struct_obj_or_cls)\n\t    if cls == Exp:\n\t        return 'exp'\n\t    elif cls == ExpGroup:\n\t        return 'group'\n", "    elif cls == ExpProj:\n\t        raise NotImplementedXManError(f\"Isn't supported by logic!\")\n\t    else:\n\t        raise ArgumentsXManError(\n\t            f\"`struct_obj_or_cls` should be an instance of/or a final class inheriting ExpStruct - \"\n\t            f\"Exp, ExpGroup or ExpProj, but `{cls.__name__}` was given!\")\n\tdef get_child_dir(parent, child_num):\n\t    return os.path.join(parent.location_dir, dir_prefix(maker.get_child_class(parent)) +\n\t                        str(child_num))\n\tdef get_children_nums(parent):\n", "    child_class = maker.get_child_class(parent)\n\t    child_dir_prefix = dir_prefix(child_class)\n\t    return __get_dir_nums_by_pattern(parent.location_dir, child_dir_prefix)\n\tdef has(path) -> bool: return os.path.exists(path)\n\tdef prepare_dir(dir_path):\n\t    if has(dir_path):\n\t        if not os.path.isdir(dir_path):\n\t            raise ArgumentsXManError(f\"`{dir_path}` is not a directory!\")\n\t        elif len(os.listdir(dir_path)) > 0:\n\t            raise IllegalOperationXManError(f\"Directory `{dir_path}` should be empty!\")\n", "    else:\n\t        make_dir(dir_path)\n\tdef __save_to_file(obj, file_path, file_type: FileType):\n\t    make_dir(os.path.dirname(file_path))\n\t    if file_type is FileType.TXT:\n\t        with open(file_path, 'w') as f:\n\t            f.write(str(obj))\n\t    if file_type is FileType.JSON:\n\t        with open(file_path, 'w') as f:\n\t            json.dump(obj, f, indent=4)\n", "    if file_type is FileType.PICKLE:\n\t        with open(file_path, 'wb') as f:\n\t            pickle.dump(obj, f)\n\tdef __load_from_file(file_path, file_type: FileType) -> Optional[Any]:\n\t    if has(file_path):\n\t        if file_type is FileType.TXT:\n\t            with open(file_path, 'r') as f:\n\t                return f.read()\n\t        if file_type is FileType.JSON:\n\t            with open(file_path, 'r') as f:\n", "                return json.load(f)\n\t        if file_type is FileType.PICKLE:\n\t            with open(file_path, 'rb') as f:\n\t                return pickle.load(f)\n\t    return None\n\tdef __delete_file(file_path):\n\t    if has(file_path):\n\t        os.remove(file_path)\n\tdef save_data_and_time(location_dir, data) -> float:\n\t    __save_to_file(data, __get_data_path(location_dir), FileType.PICKLE)\n", "    t = time.time()\n\t    __save_to_file(t, __get_time_path(location_dir), FileType.PICKLE)\n\t    return t\n\tdef load_fresh_data_and_time(location_dir, last_data, last_time):\n\t    t = __load_from_file(__get_time_path(location_dir), FileType.PICKLE)\n\t    if last_time != t:\n\t        return __load_from_file(__get_data_path(location_dir), FileType.PICKLE), t\n\t    return last_data, last_time\n\tdef save_manual_result(location_dir, manual_result):\n\t    __save_to_file(manual_result, get_manual_result_path(location_dir), file_type=FileType.PICKLE)\n", "def load_manual_result(location_dir):\n\t    return __load_from_file(get_manual_result_path(location_dir), file_type=FileType.PICKLE)\n\tdef delete_manual_result(location_dir): __delete_file(get_manual_result_path(location_dir))\n\tdef save_pipeline_run_data(location_dir, run_data):\n\t    __save_to_file(run_data, __get_run_path(location_dir), FileType.PICKLE)\n\tdef load_pipeline_run_data(location_dir):\n\t    return __load_from_file(__get_run_path(location_dir), FileType.PICKLE)\n\tdef delete_pipeline_run_data(location_dir): __delete_file(__get_run_path(location_dir))\n\tdef save_pipeline_run_timestamp(location_dir):\n\t    __save_to_file(time.time(), __get_run_time_path(location_dir), FileType.PICKLE)\n", "def load_pipeline_run_timestamp(location_dir):\n\t    return __load_from_file(__get_run_time_path(location_dir), FileType.PICKLE)\n\tdef delete_pipeline_run_timestamp(location_dir): __delete_file(__get_run_time_path(location_dir))\n\tdef save_pipeline_result(location_dir, pipeline_result):\n\t    __save_to_file(pipeline_result, get_pipeline_result_path(location_dir),\n\t                   file_type=FileType.PICKLE)\n\tdef load_pipeline_result(location_dir):\n\t    return __load_from_file(get_pipeline_result_path(location_dir), file_type=FileType.PICKLE)\n\tdef delete_pipeline_result(location_dir): __delete_file(get_pipeline_result_path(location_dir))\n\tdef has_checkpoints_dir(location_dir): return has(get_checkpoints_dir_path(location_dir))\n", "def make_checkpoints_dir(location_dir): make_dir(get_checkpoints_dir_path(location_dir))\n\tdef delete_checkpoints_dir(location_dir, need_confirm=True) -> bool:\n\t    return delete_dir(get_checkpoints_dir_path(location_dir), need_confirm)\n\tdef save_checkpoint(location_dir, checkpoint, custom_path=None) -> str:\n\t    loc_dir = Path(location_dir).resolve()\n\t    if custom_path is not None:\n\t        __save_to_file(checkpoint, custom_path, FileType.PICKLE)\n\t        path = Path(custom_path).resolve()\n\t        if path.is_relative_to(loc_dir):\n\t            path = str(path.relative_to(loc_dir).as_posix())\n", "        else:\n\t            path = custom_path\n\t    else:\n\t        path = Path(__get_checkpoint_path(location_dir)).resolve()\n\t        __save_to_file(checkpoint, path, FileType.PICKLE)\n\t        path = str(path.relative_to(loc_dir).as_posix())\n\t    return path\n\tdef load_checkpoint(cp_path): return __load_from_file(cp_path, FileType.PICKLE)\n\tdef delete_checkpoint(location_dir, cp_path):\n\t    path = resolve_checkpoint_path(location_dir, cp_path)\n", "    if path is None:\n\t        raise NotExistsXManError(f\"Can't resolve checkpoint path `{cp_path}`!\")\n\t    __delete_file(path)\n\tdef save_checkpoints_list(location_dir, cp_list):\n\t    __save_to_file(cp_list, get_checkpoints_list_path(location_dir), FileType.JSON)\n\tdef load_checkpoints_list(location_dir) -> Optional[Any]:\n\t    return __load_from_file(get_checkpoints_list_path(location_dir), FileType.JSON)\n\tdef delete_checkpoints_list(location_dir): __delete_file(get_checkpoints_list_path(location_dir))\n\tdef resolve_checkpoint_path(location_dir: str, cp_path: str) -> Optional[str]:\n\t    cp_p = Path(cp_path)\n", "    ld_p = Path(location_dir)\n\t    path = ld_p / cp_p\n\t    if path.resolve().exists():\n\t        return str(path.as_posix())\n\t    if cp_p.resolve().exists():\n\t        return cp_path\n\t    return None\n\tdef save_note(location_dir, obj, file_type: FileType):\n\t    __save_to_file(obj, get_note_path(location_dir, file_type), file_type)\n\tdef load_note(location_dir, file_type: FileType):\n", "    return __load_from_file(get_note_path(location_dir, file_type), file_type)\n\tdef delete_note(location_dir, file_type): __delete_file(get_note_path(location_dir, file_type))\n"]}
{"filename": "src/xman/util.py", "chunked_list": ["from .error import OverrideXManError, ArgumentsXManError\n\tSECOND = 1\n\tMINUTE = 60 * SECOND\n\tHOUR = 60 * MINUTE\n\tDAY = 24 * HOUR\n\tTAB_NUM_SPACES = 4\n\tdef tab(text, deep=1):\n\t    t = ' ' * TAB_NUM_SPACES * deep\n\t    return text.replace('\\n', f'\\n{t}')\n\tdef is_num(num_or_name): return type(num_or_name) is int and num_or_name >= 1\n", "def is_name(num_or_name): return type(num_or_name) is str\n\tdef check_num(num, allow_none: bool):\n\t    if is_num(num):\n\t        return\n\t    if allow_none:\n\t        if num is None:\n\t            return\n\t        raise ArgumentsXManError(f\"num={num} should be None or an integer that greater or equal 1!\")\n\t    raise ArgumentsXManError(f\"num={num} should be an integer that greater or equal 1!\")\n\tdef get_cls(target_obj_or_cls):\n", "    t = type(target_obj_or_cls)\n\t    return target_obj_or_cls if t == type else t\n\tdef check_has_value_in_class_public_constants(value, instance_or_cls):\n\t    cls = get_cls(instance_or_cls)\n\t    constants = [v for it in vars(cls).items() if isinstance(v := it[1], str) and v.upper() == v\n\t                 and not v.startswith(('_', '__'))]\n\t    if value not in constants:\n\t        raise ArgumentsXManError(f\"Wrong value `{value}`, should be one of {constants}\")\n\tdef override_it(): raise OverrideXManError(\"Should be overriden!\")\n\tdef warning(message: str): print('\\nWARNING! ' + message + '\\n')\n"]}
{"filename": "src/xman/confirm.py", "chunked_list": ["from . import config\n\tfrom .struct import ExpStruct\n\tdef __response(question):\n\t    r = input(f\"{question} (y/n) \")\n\t    return r.lower() == \"y\"\n\tdef request(need_confirm, request):\n\t    if config.confirm_off:\n\t        return True\n\t    return __response(request) if need_confirm else True\n\tdef delete_struct_and_all_its_content(struct: ExpStruct, need_confirm):\n", "    p = struct.location_dir\n\t    return request(need_confirm,\n\t                    f\"ATTENTION! Remove `{struct}`\\nand its dir `{p}`\\nwith all its content?\")\n"]}
{"filename": "src/xman/note.py", "chunked_list": ["from typing import Any, List\n\tfrom . import filesystem\n\tclass Note:\n\t    @property\n\t    def txt(self) -> str:\n\t        return filesystem.load_note(self.__location_dir, filesystem.FileType.TXT)\n\t    @txt.setter\n\t    def txt(self, obj: Any):\n\t        file_type = filesystem.FileType.TXT\n\t        filesystem.delete_note(self.__location_dir, file_type) if obj is None \\\n", "            else filesystem.save_note(self.__location_dir, obj, file_type)\n\t    @property\n\t    def json(self) -> Any:\n\t        return filesystem.load_note(self.__location_dir, filesystem.FileType.JSON)\n\t    @json.setter\n\t    def json(self, obj: Any):\n\t        file_type = filesystem.FileType.JSON\n\t        filesystem.delete_note(self.__location_dir, file_type) if obj is None \\\n\t            else filesystem.save_note(self.__location_dir, obj, file_type)\n\t    @property\n", "    def pickle(self) -> Any:\n\t        return filesystem.load_note(self.__location_dir, filesystem.FileType.PICKLE)\n\t    @pickle.setter\n\t    def pickle(self, obj: Any):\n\t        file_type = filesystem.FileType.PICKLE\n\t        filesystem.delete_note(self.__location_dir, file_type) if obj is None \\\n\t            else filesystem.save_note(self.__location_dir, obj, file_type)\n\t    @property\n\t    def has_any(self):\n\t        for file_type in filesystem.FileType:\n", "            path = filesystem.get_note_path(self.__location_dir, file_type)\n\t            if filesystem.has(path):\n\t                return True\n\t        return False\n\t    def get_list(self) -> List[str]:\n\t        result = []\n\t        for file_type in filesystem.FileType:\n\t            path = filesystem.get_note_path(self.__location_dir, file_type)\n\t            if filesystem.has(path):\n\t                result.append(path)\n", "        return result\n\t    def get_existence_str(self) -> str:\n\t        result = ''\n\t        for file_type in filesystem.FileType:\n\t            path = filesystem.get_note_path(self.__location_dir, file_type)\n\t            result += f\"{file_type.name} {filesystem.has(path)}, \"\n\t        return result.removesuffix(', ').lower()\n\t    def clear(self):\n\t        filesystem.delete_note(self.__location_dir, filesystem.FileType.TXT)\n\t        filesystem.delete_note(self.__location_dir, filesystem.FileType.JSON)\n", "        filesystem.delete_note(self.__location_dir, filesystem.FileType.PICKLE)\n\t    def __init__(self, location_dir: str): self.__location_dir = location_dir\n\t    def __str__(self): return str(self.get_list())\n\t    def __call__(self, *args, **kwargs): print(self)\n"]}
{"filename": "src/xman/group.py", "chunked_list": ["from typing import Optional, List, Callable\n\tfrom . import filter, exp_helper\n\tfrom .error import NothingToDoXManError, IllegalOperationXManError\n\tfrom .structbox import ExpStructBox\n\tfrom .exp import Exp\n\tclass ExpGroup(ExpStructBox):\n\t    @property\n\t    def proj(self) -> 'ExpProj': return self.parent\n\t    def info(self) -> str: return exp_helper.get_info_with_marked_exps(self)\n\t    def update(self):\n", "        if self.__updating:\n\t            return\n\t        self.__updating = True\n\t        super().update()\n\t        # Status should be updated at the end of the inherited updating hierarchy\n\t        if type(self) == ExpGroup:\n\t            self._update_status()\n\t        self.__updating = False\n\t    def has_exp(self, num_or_name: int | str) -> bool: return self.has_child(num_or_name)\n\t    def exp(self, num_or_name: int | str) -> Exp: return self.child(num_or_name)\n", "    def make_exp(self, name: str, descr: str, num: int = None) -> Exp:\n\t        return self.make_child(name, descr, num)\n\t    def delete_exp(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n\t        self.exp(num_or_name)._check_is_not_active()\n\t        return self.delete_child(num_or_name, need_confirm)\n\t    def exps(self) -> List[Exp]: return self.children()\n\t    def num_exps(self) -> int: return self.num_children()\n\t    def exps_nums(self) -> List[int]: return self.children_nums()\n\t    def exps_names(self) -> List[str]: return self.children_names()\n\t    def change_exp_num(self, num_or_name: int | str, new_num: int):\n", "        self.exp(num_or_name)._check_is_not_active()\n\t        self.change_child_num(num_or_name, new_num)\n\t    def filter_exps(self,\n\t                    mode: str = 'AND',\n\t                    custom_filter: Callable[[Exp], bool] = None,\n\t                    is_active: bool = None,\n\t                    is_manual: bool = None,\n\t                    is_ready_for_start: bool = None,\n\t                    status_or_list: str | List[str] = None,\n\t                    not_status_or_list: str | List[str] = None,\n", "                    has_marker: bool = None,\n\t                    marker_or_list: str | List[str] = None,\n\t                    ) -> List[Exp]:\n\t        return filter.exps(self.exps(), mode, custom_filter, is_active, is_manual,\n\t                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\t    def get_exp_for_start(self) -> Optional[Exp]:\n\t        ready_list = self.filter_exps(is_ready_for_start=True)\n\t        return ready_list[0] if len(ready_list) else None\n\t    def start(self, exp_num_or_name: int | str = None, autostart_next: bool = False):\n\t        if exp_num_or_name is None:\n", "            exp = self.get_exp_for_start()\n\t            if exp is None:\n\t                raise NothingToDoXManError(f\"There's nothing to start in the group `{self}`!\")\n\t            exp.start()\n\t        else:\n\t            self.exp(exp_num_or_name).start()\n\t        if autostart_next:\n\t            self.start(autostart_next=True)\n\t    def _check_has_no_active_exps(self):\n\t        active_list = self.filter_exps(is_active=True)\n", "        if len(active_list):\n\t            raise IllegalOperationXManError(\n\t                f\"Illegal operation while there's any active experiment in the `{self}` - found:\"\n\t                f\"{active_list}!\")\n\t    def __init__(self, location_dir, parent):\n\t        from .api import ExpGroupAPI\n\t        self.__updating = False\n\t        super().__init__(location_dir, parent)\n\t        self._api = ExpGroupAPI(self)\n\t    def __str__(self):\n", "        return f\"Group {self.num} [{self.status}] {self.name} - {self.descr}\"\n"]}
{"filename": "src/xman/maker.py", "chunked_list": ["from typing import Optional\n\tfrom .error import AlreadyExistsXManError, ArgumentsXManError, IllegalOperationXManError\n\tfrom .exp import Exp, ExpData\n\tfrom .group import ExpGroup\n\tfrom .pipeline import PipelineData, PipelineRunData, Pipeline\n\tfrom . import util, filesystem, platform\n\tfrom .proj import ExpProj\n\tfrom .struct import ExpStruct, ExpStructData\n\tdef __get_data_class(obj_cls):\n\t    if obj_cls == Exp:\n", "        return ExpData\n\t    elif issubclass(obj_cls, ExpStruct):\n\t        return ExpStructData\n\t    else:\n\t        raise ArgumentsXManError(f\"`obj_cls` should inherit `ExpStruct`!\")\n\tdef make_proj(location_dir, name, descr) -> ExpProj:\n\t    make_and_save_struct_data(ExpProj, location_dir, name, descr)\n\t    return ExpProj(location_dir)\n\tdef recreate_proj(location_dir) -> Optional[ExpProj]:\n\t    proj = ExpProj(location_dir)\n", "    if platform.is_colab:\n\t        if not platform.check_colab_forked_folders(proj):\n\t            return None\n\t        for group in proj.groups():\n\t            if not platform.check_colab_forked_folders(group):\n\t                return None\n\t    return proj\n\tdef make_and_save_struct_data(struct_cls, location_dir, name, descr):\n\t    filesystem.prepare_dir(location_dir) if struct_cls == ExpProj else \\\n\t        filesystem.make_dir(location_dir, exist_ok=False)\n", "    data = __get_data_class(struct_cls)(name, descr)\n\t    filesystem.save_data_and_time(location_dir, data)\n\tdef get_child_class(parent_obj_or_cls):\n\t    cls = util.get_cls(parent_obj_or_cls)\n\t    if cls == ExpProj:\n\t        return ExpGroup\n\t    elif cls == ExpGroup:\n\t        return Exp\n\t    else:\n\t        raise ArgumentsXManError(f\"`parent_obj_or_cls` should be `ExpProj` or `ExpGroup`, but \"\n", "                                 f\"`{cls.__name__}` was given!\")\n\tdef make_new_child(parent, name, descr, child_num) -> Optional[Exp | ExpGroup]:\n\t    child_class = get_child_class(parent)\n\t    child_dir = filesystem.get_child_dir(parent, child_num)\n\t    make_and_save_struct_data(child_class, child_dir, name, descr)\n\t    child = child_class(child_dir, parent)\n\t    if platform.is_colab:\n\t        return child if platform.check_colab_forked_folders(parent) else None\n\t    return child\n\tdef recreate_child(parent, child_num):\n", "    location_dir = filesystem.get_child_dir(parent, child_num)\n\t    return get_child_class(parent)(location_dir, parent)\n\tdef delete_child(child: Exp | ExpGroup, need_confirm) -> bool:\n\t    if not filesystem.delete_dir(child.location_dir, need_confirm):\n\t        return False\n\t    child._destroy()\n\t    return True\n\tdef make_pipeline(exp, run_func, with_mediator, params, save_on_storage=False):\n\t    if exp._data.pipeline is not None:\n\t        raise AlreadyExistsXManError(f\"`{exp}` already has a pipeline!\")\n", "    exp._data.pipeline = PipelineData()\n\t    run_data = PipelineRunData(run_func, with_mediator, params)\n\t    if save_on_storage:\n\t        filesystem.save_pipeline_run_data(exp.location_dir, run_data)\n\t    return Pipeline(exp.location_dir, exp._data.pipeline, run_data)\n\tdef recreate_pipeline(exp):\n\t    run_data = filesystem.load_pipeline_run_data(exp.location_dir)\n\t    if run_data is None:\n\t        raise IllegalOperationXManError(f\"Can't recreate pipeline for exp `{exp}` - \"\n\t                                        f\"there's no `.run` data file! Use `save=True` for \"\n", "                                        f\"`make_pipeline()` method if you need to preserve \"\n\t                                        f\"`run_func` and `params` for other session.\")\n\t    return Pipeline(exp.location_dir, exp._data.pipeline, run_data)\n\tdef delete_pipeline(exp: Exp, pipeline: Pipeline):\n\t    filesystem.delete_pipeline_result(exp.location_dir)\n\t    exp.delete_checkpoints(need_confirm=False, delete_custom_paths=True)\n\t    filesystem.delete_pipeline_run_data(exp.location_dir)\n\t    filesystem.delete_pipeline_run_timestamp(exp.location_dir)\n\t    if pipeline is not None:\n\t        pipeline._destroy()\n", "    exp._data.pipeline = None\n"]}
{"filename": "src/xman/exp.py", "chunked_list": ["import time\n\tfrom typing import Any, Optional, Callable\n\tfrom .config import PipelineConfig\n\tfrom .error import NotExistsXManError, IllegalOperationXManError, AlreadyExistsXManError, \\\n\t    UnpredictableLogicXManError, NothingToDoXManError\n\tfrom .pipeline import PipelineData, CheckpointsMediator, Pipeline\n\tfrom .struct import ExpStructData, ExpStruct, ExpStructStatus\n\tfrom . import util, confirm, platform, filesystem\n\tfrom . import maker\n\tclass ExpData(ExpStructData):\n", "    def __init__(self, name, descr):\n\t        super().__init__(name, descr)\n\t        self.pipeline: PipelineData = None\n\t        self.marker: str = None\n\tclass ExpState:\n\t    # Is 'IN_PROGRESS' status and executing right now ( + some buffer for the lag on Colab platform)\n\t    ACTIVE = 'ACTIVE'\n\t    # Any experiments except not manual in `IN_PROGRESS` status and is executing right now.\n\t    IDLE = 'IDLE'\n\tclass Exp(ExpStruct):\n", "    @property\n\t    def group(self) -> 'ExpGroup': return self.parent\n\t    @property\n\t    def proj(self) -> 'ExpProj': return self.parent.parent\n\t    @property\n\t    def state(self) -> str: return self.__state\n\t    @property\n\t    def has_pipeline(self) -> bool: return self._data.pipeline is not None\n\t    @property\n\t    def has_result(self) -> bool: return self.has_pipeline_result or self.has_manual_result\n", "    @property\n\t    def has_pipeline_result(self) -> bool:\n\t        return filesystem.has(filesystem.get_pipeline_result_path(self.location_dir))\n\t    @property\n\t    def has_manual_result(self) -> bool:\n\t        return filesystem.has(filesystem.get_manual_result_path(self.location_dir))\n\t    @property\n\t    def result(self) -> Optional[Any]:\n\t        if self.has_manual_result and self.has_pipeline_result:\n\t            raise IllegalOperationXManError(f\"There are two results in the `{self}` - manual result\"\n", "                                            f\" and pipeline result! Use `get_manual_result()` or \"\n\t                                            f\"`get_pipeline_result()` for checking them and delete \"\n\t                                            f\"manual or pipeline result.\")\n\t        if self.has_manual_result:\n\t            return self.get_manual_result()\n\t        if self.has_pipeline_result:\n\t            return self.get_pipeline_result()\n\t        raise IllegalOperationXManError(f\"There's no any result in the `{self}`!\")\n\t    @property\n\t    def error(self) -> Optional[str]:\n", "        return None if self._data.pipeline is None else self._data.pipeline.error\n\t    @property\n\t    def error_stack(self) -> Optional[str]:\n\t        return None if self._data.pipeline is None else self._data.pipeline.error_stack\n\t    @property\n\t    def is_active(self) -> bool: return self.state == ExpState.ACTIVE\n\t    @property\n\t    def is_ready_for_start(self) -> bool:\n\t        if self.is_manual:\n\t            return False\n", "        return self.status.status_str == ExpStructStatus.TO_DO or \\\n\t            (self.status.status_str == ExpStructStatus.IN_PROGRESS and self.state == ExpState.IDLE)\n\t    @property\n\t    def checkpoints_mediator(self) -> CheckpointsMediator:\n\t        if self.__checkpoints_mediator is None:\n\t            self.__checkpoints_mediator = CheckpointsMediator(self.location_dir)\n\t        return self.__checkpoints_mediator\n\t    @property\n\t    def marker(self) -> str: return self._data.marker\n\t    @marker.setter\n", "    def marker(self, value):\n\t        self._data.marker = value\n\t        self._save()\n\t    def info(self) -> str:\n\t        text = super().info()\n\t        if self.has_result:\n\t            text += util.tab(f\"\\nResult:\\n{util.tab(self.stringify_result())}\")\n\t        return text\n\t    def stringify_result(self) -> str:\n\t        rs = self.result_stringifier\n", "        if rs is None:\n\t            rs = self.parent.result_stringifier\n\t            if rs is None:\n\t                rs = self.parent.parent.result_stringifier\n\t        return str(self.result) if rs is None else rs(self.result)\n\t    def view_result(self):\n\t        rv = self.result_viewer\n\t        if rv is None:\n\t            rv = self.parent.result_viewer\n\t            if rv is None:\n", "                rv = self.parent.parent.result_viewer\n\t        print(self.result) if rv is None else rv(self.result)\n\t    def make_pipeline(self, run_func: Callable[..., Any],\n\t                      params: dict, save_on_storage: bool = False) -> 'Exp':\n\t        return self.__make_pipeline(run_func, False, params, save_on_storage)\n\t    def make_pipeline_with_checkpoints(self,\n\t                               run_func_with_mediator: Callable[[CheckpointsMediator, ...], Any],\n\t                               params: dict, save_on_storage: bool = False) -> 'Exp':\n\t        return self.__make_pipeline(run_func_with_mediator, True, params, save_on_storage)\n\t    def delete_pipeline(self, need_confirm: bool = True) -> Optional['Exp']:\n", "        self._check_is_not_active()\n\t        if self._data.pipeline is None:\n\t            raise NotExistsXManError(f\"There's no pipeline in exp `{self}`!\")\n\t        if confirm.request(need_confirm, f\"ATTENTION! Remove the pipeline of exp `{self}`\\n\"\n\t                f\"(it will also delete the pipeline result, all checkpoints, and data)?\"):\n\t            maker.delete_pipeline(self, self.__pipeline)\n\t            self.__pipeline = None\n\t            self._save()\n\t            return self\n\t        return None\n", "    def delete_checkpoints(self, need_confirm: bool = True, delete_custom_paths: bool = False) -> Optional['Exp']:\n\t        self._check_is_not_active()\n\t        if not confirm.request(need_confirm,\n\t                               f\"ATTENTION! Do you want to delete `{self}` checkpoints?\"):\n\t            return None\n\t        if delete_custom_paths:\n\t            lst = self.checkpoints_mediator.get_checkpoint_paths_list(check_files_exist=True)\n\t            if lst is not None:\n\t                for cp_path in lst:\n\t                    filesystem.delete_checkpoint(self.location_dir, cp_path)\n", "        filesystem.delete_checkpoints_dir(self.location_dir, need_confirm=False)\n\t        return self\n\t    def start(self, force_after_error: bool = False) -> 'Exp':\n\t        if self.has_manual_result:\n\t            raise IllegalOperationXManError(f\"The `{self}` already has a manual result - delete it \"\n\t                                            f\"with `delete_manual_result()` method first!\")\n\t        pipeline_data = self._data.pipeline\n\t        if self.status.status_str == ExpStructStatus.ERROR and force_after_error:\n\t            pipeline_data.started = False\n\t            pipeline_data.error = None\n", "            pipeline_data.error_stack = None\n\t            self.update()\n\t        if self.is_ready_for_start:\n\t            if filesystem.has_checkpoints_dir(self.location_dir) and \\\n\t                    self.status.status_str == ExpStructStatus.TO_DO:\n\t                raise IllegalOperationXManError(f\"`{self}` contains checkpoints folder - delete it \"\n\t                                                f\"first with `delete_checkpoints()` method!\")\n\t            if self.__pipeline is None:\n\t                self.__pipeline = maker.recreate_pipeline(self)\n\t            pipeline_data.started = True\n", "            self._save()\n\t            try:\n\t                self.__pipeline.start()\n\t            finally:\n\t                self._save()\n\t                self.__pipeline._destroy()\n\t                self.__pipeline = None\n\t                if pipeline_data.finished:\n\t                    filesystem.delete_pipeline_run_data(self.location_dir)\n\t        else:\n", "            self._check_is_not_active()\n\t            if self.is_manual:\n\t                raise IllegalOperationXManError(f\"Can't start the `{self}` as it's manual - use \"\n\t                                                f\"`delete_manual_status()` method first!\")\n\t            if pipeline_data is None:  # status == 'EMPTY'\n\t                raise NotExistsXManError(f\"`The {self}` doesn't have a pipeline!\")\n\t            if pipeline_data.error:  # status == 'ERROR'\n\t                raise IllegalOperationXManError(\n\t                    f\"The `{self}` has an error during the previous start! You can use \"\n\t                    f\"`force_after_error=True` flag.\")\n", "            if pipeline_data.finished:  # status == 'DONE'\n\t                raise IllegalOperationXManError(f\"`The {self}` was already finished!\")\n\t        return self\n\t    def get_pipeline_result(self) -> Any:\n\t        if not self.has_pipeline_result:\n\t            raise IllegalOperationXManError(f\"There's no pipeline result in the `{self}`!\")\n\t        return filesystem.load_pipeline_result(self.location_dir)\n\t    def get_manual_result(self) -> Any:\n\t        if not self.has_manual_result:\n\t            raise IllegalOperationXManError(f\"There's no manual result in the `{self}`!\")\n", "        return filesystem.load_manual_result(self.location_dir)\n\t    def set_manual_result(self, result: Any) -> 'Exp':\n\t        if self.has_manual_result:\n\t            raise AlreadyExistsXManError(f\"Already has a manual result! Delete it first with \"\n\t                                         f\"`delete_manual_result()` method.\")\n\t        filesystem.save_manual_result(self.location_dir, result)\n\t        return self\n\t    def delete_manual_result(self, need_confirm: bool = True) -> Optional['Exp']:\n\t        if not self.has_manual_result:\n\t            raise NotExistsXManError(f\"There's no manual result in the `{self}`!\")\n", "        if not confirm.request(need_confirm,\n\t                f\"ATTENTION! The manual result for the `{self}\\nwill be deleted - proceed?\"):\n\t            return None\n\t        filesystem.delete_manual_result(self.location_dir)\n\t        return self\n\t    def delete_all_manual(self, need_confirm: bool = True) -> Optional['Exp']:\n\t        if not self.is_manual and not self.has_manual_result:\n\t            raise NothingToDoXManError(f\"There's nothing manual to delete in the `{self}`!\")\n\t        if not confirm.request(need_confirm, f\"ATTENTION! Manual status and resolution, and manual\"\n\t                                             f\"result will be deleted - proceed?\"):\n", "            return None\n\t        self._data.manual_status = None\n\t        self._data.manual_status_resolution = None\n\t        if self.has_manual_result:\n\t            filesystem.delete_manual_result(self.location_dir)\n\t        return self\n\t    def clear(self, need_confirm: bool = True) -> Optional['Exp']:\n\t        self._check_is_not_active()\n\t        if not confirm.request(need_confirm,\n\t                f\"ATTENTION! The `{self}`\\nwill be cleared as it just was created - proceed?\"):\n", "            return None\n\t        if self.has_pipeline:\n\t            self.delete_pipeline(need_confirm=False)\n\t        if self.has_pipeline_result:\n\t            filesystem.delete_pipeline_result(self.location_dir)\n\t        self.delete_checkpoints(need_confirm=False, delete_custom_paths=True)\n\t        self.__checkpoints_mediator = None\n\t        if self.has_manual_result:\n\t            filesystem.delete_manual_result(self.location_dir)\n\t        self._data.manual_status = None\n", "        self._data.manual_status_resolution = None\n\t        self.result_stringifier = None\n\t        self.result_viewer = None\n\t        self.note.clear()\n\t        self.__note = None\n\t        self._save()\n\t        return self\n\t    def update(self):\n\t        if self.__updating:\n\t            return\n", "        self.__updating = True\n\t        super().update()\n\t        # Status and state should be updated at the end of the inherited updating hierarchy\n\t        if type(self) == Exp:\n\t            self._update_status()\n\t            self.__update_state()\n\t        self.__updating = False\n\t    def _process_auto_status(self):\n\t        resolution = ExpStruct._AUTO_STATUS_RESOLUTION\n\t        pipeline_data = self._data.pipeline\n", "        if pipeline_data is None:\n\t            status = ExpStructStatus.EMPTY\n\t        elif not pipeline_data.started:\n\t            status = ExpStructStatus.TO_DO\n\t        elif pipeline_data.error is not None:\n\t            status = ExpStructStatus.ERROR\n\t            resolution = str(pipeline_data.error)\n\t        elif pipeline_data.finished:\n\t            status = ExpStructStatus.DONE\n\t        else:\n", "            status = ExpStructStatus.IN_PROGRESS\n\t        return status, resolution\n\t    def _check_is_not_active(self):\n\t        if self.is_active:\n\t            raise IllegalOperationXManError(f\"Illegal operation while the experiment is active - \"\n\t                                            f\"has a pipeline that is executing right now!\")\n\t    def _destroy(self):\n\t        if self.__pipeline is not None:\n\t            if self.is_active:\n\t                raise UnpredictableLogicXManError(f\"It shouldn't be, but if you're reading this... \"\n", "                        f\"So, something extraordinary has happened - congrats and my condolences!)\")\n\t            self.__pipeline._destroy()\n\t        self._data.pipeline = None\n\t        self._data = None\n\t        self.__checkpoints_mediator = None\n\t        super()._destroy()\n\t    def __init__(self, location_dir, parent):\n\t        from .api import ExpAPI\n\t        self._data: ExpData = None\n\t        self.__state = None\n", "        self.__pipeline: Pipeline = None\n\t        self.__checkpoints_mediator: CheckpointsMediator = None\n\t        self.__updating = False\n\t        super().__init__(location_dir, parent)\n\t        self._api = ExpAPI(self)\n\t    def __str__(self):\n\t        state = f\": {self.state}\" if self.status.status_str == ExpStructStatus.IN_PROGRESS else ''\n\t        marker = '' if self.marker is None or self.marker == '' else self.marker + ' '\n\t        return (f\"{marker}Exp {self.group.num}.{self.num} [{self.status}{state}] \"\n\t                f\"{self.name} - {self.descr}\")\n", "    def __is_active_by_time_delta(self):\n\t        run_timestamp = filesystem.load_pipeline_run_timestamp(self.location_dir)\n\t        if run_timestamp is None:\n\t            return False\n\t        active_buffer = PipelineConfig.active_buffer_colab if platform.is_colab \\\n\t            else PipelineConfig.active_buffer\n\t        return time.time() - run_timestamp < PipelineConfig.timer_interval + active_buffer\n\t    def __is_active(self):\n\t        p_data = self._data.pipeline\n\t        return p_data is not None and p_data.started and not p_data.finished and \\\n", "            p_data.error is None and self.__is_active_by_time_delta()\n\t    def __update_state(self):\n\t        self.__state = ExpState.ACTIVE if self.__is_active() else ExpState.IDLE\n\t    def __make_pipeline(self, run_func, with_mediator, params, save_on_storage):\n\t        if self._data.pipeline is not None:\n\t            raise AlreadyExistsXManError(f\"`{self}` already has a pipeline!\")\n\t        self.__pipeline = maker.make_pipeline(self, run_func, with_mediator, params,\n\t                                              save_on_storage)\n\t        self._save()\n\t        return self\n"]}
{"filename": "src/xman/error.py", "chunked_list": ["import traceback\n\tdef get_error_str(error: Exception) -> str:\n\t    return f\"{error.__class__.__name__}: {error.args[0] if len(error.args) == 1 else error.args}\"\n\tdef get_error_stack_str(error: Exception) -> str:\n\t    stack = 'Traceback (most recent call last):\\n'\n\t    stack += ''.join(traceback.format_tb(error.__traceback__))\n\t    stack += 'ERROR:\\n    ' + get_error_str(error)\n\t    return stack\n\tclass XManError(Exception):  # It's better not to use this generic error\n\t    pass\n", "class IllegalOperationXManError(XManError):\n\t    pass\n\tclass NotExistsXManError(XManError):\n\t    pass\n\tclass AlreadyExistsXManError(XManError):\n\t    pass\n\tclass ArgumentsXManError(XManError):\n\t    pass\n\tclass OverrideXManError(XManError):\n\t    pass\n", "class NothingToDoXManError(XManError):\n\t    pass\n\tclass NotImplementedXManError(XManError):\n\t    pass\n\tclass UnpredictableLogicXManError(XManError):\n\t    pass\n"]}
