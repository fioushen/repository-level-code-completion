{"filename": "tap_jquants/auth.py", "chunked_list": ["\"\"\"Authentication for tap-jquants.\"\"\"\n\tfrom __future__ import annotations\n\timport typing as t\n\timport requests\n\tfrom singer_sdk.authenticators import BearerTokenAuthenticator, SingletonMeta\n\tfrom .exceptions import JQuantsError\n\tif t.TYPE_CHECKING:\n\t    from .client import JQuantsStream\n\tclass JQuantsAuthenticator(BearerTokenAuthenticator, metaclass=SingletonMeta):\n\t    \"\"\"Authenticator class for J-Quants.\"\"\"\n", "    @classmethod\n\t    def _get_refresh_token(\n\t        cls: type[JQuantsAuthenticator],\n\t        stream: JQuantsStream,\n\t        session: requests.Session,\n\t    ) -> str:\n\t        \"\"\"Get a refresh token.\"\"\"\n\t        response = session.post(\n\t            url=f\"{stream.url_base}/token/auth_user\",\n\t            headers={\n", "                \"Content-Type\": \"application/json\",\n\t            },\n\t            json={\n\t                \"mailaddress\": stream.config[\"mail_address\"],\n\t                \"password\": stream.config[\"password\"],\n\t            },\n\t        )\n\t        if response.status_code != requests.codes.ok:\n\t            raise JQuantsError(response)\n\t        return response.json()[\"refreshToken\"]\n", "    @classmethod\n\t    def _get_id_token(\n\t        cls: type[JQuantsAuthenticator],\n\t        stream: JQuantsStream,\n\t        session: requests.Session,\n\t    ) -> str:\n\t        \"\"\"Get an id token.\"\"\"\n\t        refresh_token = cls._get_refresh_token(stream, session)\n\t        response = session.post(\n\t            url=f\"{stream.url_base}/token/auth_refresh?refreshtoken={refresh_token}\",\n", "            headers={\n\t                \"Content-Type\": \"application/json\",\n\t            },\n\t        )\n\t        if response.status_code != requests.codes.ok:\n\t            raise JQuantsError(response)\n\t        return response.json()[\"idToken\"]\n\t    @classmethod\n\t    def create_for_stream(\n\t        cls: type[JQuantsAuthenticator],\n", "        stream: JQuantsStream,\n\t    ) -> JQuantsAuthenticator:\n\t        \"\"\"Instantiate an authenticator for a specific Singer stream.\n\t        Args:\n\t            stream: The Singer stream instance.\n\t        Returns:\n\t            A new authenticator.\n\t        \"\"\"\n\t        with requests.Session() as session:\n\t            id_token = cls._get_id_token(stream, session)\n", "        return cls(\n\t            stream=stream,\n\t            token=id_token,\n\t        )\n"]}
{"filename": "tap_jquants/tap.py", "chunked_list": ["\"\"\"JQuants tap class.\"\"\"\n\tfrom __future__ import annotations\n\timport typing as t\n\tfrom singer_sdk import Tap\n\tfrom singer_sdk import typing as th  # JSON schema typing helpers\n\tfrom . import streams\n\tif t.TYPE_CHECKING:\n\t    from .client import JQuantsStream\n\tclass TapJQuants(Tap):\n\t    \"\"\"JQuants tap class.\"\"\"\n", "    name = \"tap-jquants\"\n\t    config_jsonschema = th.PropertiesList(\n\t        th.Property(\n\t            \"mail_address\",\n\t            th.StringType,\n\t            required=True,\n\t            description=\"The mail address to authenticate against J-Quants API\",\n\t        ),\n\t        th.Property(\n\t            \"password\",\n", "            th.StringType,\n\t            required=True,\n\t            secret=True,\n\t            description=\"The password to authenticate against J-Quants API\",\n\t        ),\n\t        th.Property(\n\t            \"start_date\",\n\t            th.DateTimeType,\n\t            description=\"The earliest record date to sync\",\n\t        ),\n", "    ).to_dict()\n\t    def discover_streams(self) -> list[JQuantsStream]:\n\t        \"\"\"Return a list of discovered streams.\n\t        Returns:\n\t            A list of discovered streams.\n\t        \"\"\"\n\t        return [\n\t            streams.AnnouncementStream(self),\n\t            streams.BreakdownStream(self),\n\t            streams.DailyQuotesStream(self),\n", "            streams.DividendStream(self),\n\t            streams.IndexOptionStream(self),\n\t            streams.TopixStream(self),\n\t            streams.ListedInfoStream(self),\n\t            streams.PricesAmStream(self),\n\t            streams.ShortSellingStream(self),\n\t            streams.StatementsStream(self),\n\t            streams.TradesSpecStream(self),\n\t            streams.TradingCalendarStream(self),\n\t            streams.WeeklyMarginInterestStream(self),\n", "        ]\n\tif __name__ == \"__main__\":\n\t    TapJQuants.cli()\n"]}
{"filename": "tap_jquants/pagination.py", "chunked_list": ["\"\"\"Generic paginator classes.\"\"\"\n\tfrom __future__ import annotations\n\timport re\n\timport typing as t\n\tfrom singer_sdk.helpers.jsonpath import extract_jsonpath\n\tfrom singer_sdk.pagination import BaseAPIPaginator\n\tif t.TYPE_CHECKING:\n\t    from requests import Response\n\tfrom .helpers import get_next_date\n\tT = t.TypeVar(\"T\")\n", "TPageToken = t.TypeVar(\"TPageToken\")\n\tPAGINATOR_JSONPATH = \"$.pagination_key[*]\"\n\tDATE_PAT = re.compile(r\"date=(\\d{4}-\\d{2}-\\d{2})\")\n\tclass JQuantsDatePaginator(BaseAPIPaginator[t.Optional[t.Tuple[str, str]]]):\n\t    \"\"\"Paginator class for APIs returning a pagination token in the response body.\"\"\"\n\t    def __init__(\n\t        self,\n\t        *args: t.Any,\n\t        **kwargs: t.Any,\n\t    ) -> None:\n", "        \"\"\"Create a new paginator.\n\t        Args:\n\t            args: Paginator positional arguments for base class.\n\t            kwargs: Paginator keyword arguments for base class.\n\t        \"\"\"\n\t        super().__init__(None, *args, **kwargs)\n\t    def get_next(self, response: Response) -> tuple[str, str | None] | None:\n\t        \"\"\"Get the next page token.\n\t        Args:\n\t            response: API response object.\n", "        Returns:\n\t            The next page token.\n\t        \"\"\"\n\t        date_key = re.search(  # type: ignore[union-attr]\n\t            DATE_PAT,\n\t            response.request.url,  # type: ignore[arg-type]\n\t        ).group(\n\t            1,\n\t        )\n\t        pagination_key = next(\n", "            extract_jsonpath(PAGINATOR_JSONPATH, response.json()),\n\t            None,\n\t        )\n\t        if pagination_key is not None:\n\t            return date_key, pagination_key\n\t        date_key = get_next_date(date_key)\n\t        if date_key is None:\n\t            return None\n\t        return date_key, None\n"]}
{"filename": "tap_jquants/client.py", "chunked_list": ["\"\"\"REST client handling, including JQuantsStream base class.\"\"\"\n\tfrom __future__ import annotations\n\timport sys\n\timport typing as t\n\tfrom pathlib import Path\n\tfrom typing import Any, Callable, Iterable\n\timport requests\n\tfrom singer_sdk.helpers.jsonpath import extract_jsonpath\n\tfrom singer_sdk.streams import RESTStream\n\tfrom tap_jquants.auth import JQuantsAuthenticator\n", "from tap_jquants.pagination import JQuantsDatePaginator\n\tif sys.version_info >= (3, 8):\n\t    from functools import cached_property\n\telse:\n\t    from cached_property import cached_property\n\tfrom .helpers import convert_json\n\tif t.TYPE_CHECKING:\n\t    from singer_sdk.pagination import BaseAPIPaginator\n\t_Auth = Callable[[requests.PreparedRequest], requests.PreparedRequest]\n\tSCHEMAS_DIR = Path(__file__).parent / Path(\"./schemas\")\n", "class JQuantsStream(RESTStream):\n\t    \"\"\"JQuants stream class.\"\"\"\n\t    @property\n\t    def url_base(self) -> str:\n\t        \"\"\"Return the API URL root, configurable via tap settings.\"\"\"\n\t        return \"https://api.jquants.com/v1\"\n\t    next_page_token_jsonpath = \"$.pagination_key\"  # noqa: S105\n\t    @cached_property\n\t    def authenticator(self) -> _Auth:\n\t        \"\"\"Return a new authenticator object.\n", "        Returns:\n\t            An authenticator instance.\n\t        \"\"\"\n\t        return JQuantsAuthenticator.create_for_stream(self)\n\t    @property\n\t    def http_headers(self) -> dict:\n\t        \"\"\"Return the http headers needed.\n\t        Returns:\n\t            A dictionary of HTTP headers.\n\t        \"\"\"\n", "        headers = {}\n\t        if \"user_agent\" in self.config:\n\t            headers[\"User-Agent\"] = self.config.get(\"user_agent\")\n\t        return headers\n\t    def get_url_params(\n\t        self,\n\t        _context: dict | None,\n\t        next_page_token: Any | None,\n\t    ) -> dict[str, Any]:\n\t        \"\"\"Return a dictionary of values to be used in URL parameterization.\n", "        Args:\n\t            context: The stream context.\n\t            next_page_token: The next page index or value.\n\t        Returns:\n\t            A dictionary of URL query parameters.\n\t        \"\"\"\n\t        params: dict = {}\n\t        if next_page_token:\n\t            params[\"pagination_key\"] = next_page_token\n\t        return params\n", "    def parse_response(self, response: requests.Response) -> Iterable[dict]:\n\t        \"\"\"Parse the response and return an iterator of result records.\n\t        Args:\n\t            response: The HTTP ``requests.Response`` object.\n\t        Yields:\n\t            Each record from the source.\n\t        \"\"\"\n\t        yield from extract_jsonpath(\n\t            self.records_jsonpath,\n\t            input=convert_json(response.json()),\n", "        )\n\tclass JQuantsDateStream(JQuantsStream):\n\t    \"\"\"JQuants incremental stream class based on date.\"\"\"\n\t    def get_new_paginator(self) -> BaseAPIPaginator:\n\t        \"\"\"Return a new paginator object.\"\"\"\n\t        return JQuantsDatePaginator()\n\t    def get_url_params(\n\t        self,\n\t        context: dict | None,\n\t        next_page_token: Any | None,\n", "    ) -> dict[str, Any]:\n\t        \"\"\"Return a dictionary of parameters to use in the URL.\"\"\"\n\t        params: dict = {}\n\t        if next_page_token is not None:\n\t            date_key, pagination_key = next_page_token\n\t            if pagination_key:\n\t                params[\"pagination_key\"] = next_page_token\n\t            params[\"date\"] = date_key\n\t        else:\n\t            starting_date = self.get_starting_timestamp(context)\n", "            if starting_date:\n\t                params[\"date\"] = starting_date.strftime(\"%Y-%m-%d\")\n\t        self.logger.info(\"URL params: %s\", params)\n\t        return params\n\tclass JQuantsFromStream(JQuantsStream):\n\t    \"\"\"JQuants incremental stream class based on from.\"\"\"\n\t    def get_url_params(\n\t        self,\n\t        context: dict | None,\n\t        next_page_token: Any | None,\n", "    ) -> dict[str, Any]:\n\t        \"\"\"Return a dictionary of parameters to use in the URL.\"\"\"\n\t        params: dict = {}\n\t        if next_page_token is not None:\n\t            pagination_key = next_page_token\n\t            if pagination_key:\n\t                params[\"pagination_key\"] = next_page_token\n\t        starting_date = self.get_starting_timestamp(context)\n\t        if starting_date:\n\t            params[\"from\"] = starting_date.strftime(\"%Y-%m-%d\")\n", "        self.logger.info(\"URL params: %s\", params)\n\t        return params\n"]}
{"filename": "tap_jquants/__init__.py", "chunked_list": ["\"\"\"Tap for JQuants.\"\"\"\n"]}
{"filename": "tap_jquants/exceptions.py", "chunked_list": ["\"\"\"Exceptions for tap-jquants.\"\"\"\n\tclass JQuantsError(Exception):\n\t    \"\"\"JQuants error.\"\"\"\n"]}
{"filename": "tap_jquants/helpers.py", "chunked_list": ["\"\"\"Helper functions for tap-jquants.\"\"\"\n\timport re\n\timport typing as t\n\tfrom datetime import datetime, timedelta, timezone\n\tdef convert_key(name: str) -> str:\n\t    \"\"\"Converts a CamelCased word to snake case.\"\"\"\n\t    name = re.sub(r\"\\(\", \"_\", name)\n\t    name = re.sub(r\"\\)\", \"\", name)\n\t    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name).lower()\n\tdef convert_obj(obj: object) -> object:\n", "    \"\"\"Convert keys in the given object from camel case to snake case.\"\"\"\n\t    if isinstance(obj, dict):\n\t        return convert_json(obj)\n\t    if isinstance(obj, list):\n\t        return convert_array(obj)\n\t    return obj\n\tdef convert_array(arr: t.List) -> t.List:\n\t    \"\"\"Convert keys in json array from camel case to snake case.\"\"\"\n\t    return [convert_obj(elem) for elem in arr]\n\tdef convert_json(data: t.Dict) -> t.Dict:\n", "    \"\"\"Convert keys in the given object from camel case to snake case.\"\"\"\n\t    return {convert_key(key): convert_obj(value) for key, value in data.items()}\n\tdef get_next_date(date: str) -> t.Optional[str]:\n\t    \"\"\"Returns the next date.\"\"\"\n\t    jst = timezone(timedelta(hours=9))\n\t    dt = datetime.strptime(date, \"%Y-%m-%d\").astimezone(tz=jst)\n\t    new_dt = dt + timedelta(days=1)\n\t    if new_dt > datetime.now(tz=jst):\n\t        return None\n\t    return new_dt.strftime(\"%Y-%m-%d\")\n"]}
{"filename": "tap_jquants/streams/weekly_margin_interest.py", "chunked_list": ["\"\"\"信用取引週末残高 (/markets/weekly_margin_interest).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/weekly_margin_interest\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass WeeklyMarginInterestStream(JQuantsDateStream):\n\t    \"\"\"the weekly_margin_interest stream.\"\"\"\n\t    name = \"weekly_margin_interest\"\n\t    path = \"/markets/weekly_margin_interest\"\n\t    primary_keys = [\"date\", \"code\"]\n", "    replication_key = \"date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"weekly_margin_interest.json\"\n\t    records_jsonpath = \"$.weekly_margin_interest[*]\"\n"]}
{"filename": "tap_jquants/streams/breakdown.py", "chunked_list": ["\"\"\"売買内訳データ (/markets/breakdown).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/breakdown\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass BreakdownStream(JQuantsDateStream):\n\t    \"\"\"the breakdown stream.\"\"\"\n\t    name = \"breakdown\"\n\t    path = \"/markets/breakdown\"\n\t    primary_keys = [\"date\", \"code\"]\n", "    replication_key = \"date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"breakdown.json\"\n\t    records_jsonpath = \"$.breakdown[*]\"\n"]}
{"filename": "tap_jquants/streams/trading_calendar.py", "chunked_list": ["\"\"\"取引カレンダー (/markets/trading_calendar).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/trading_calendar\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom typing import Any\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\tclass TradingCalendarStream(JQuantsStream):\n\t    \"\"\"the trading_calendar stream.\"\"\"\n\t    name = \"trading_calendar\"\n\t    path = \"/markets/trading_calendar\"\n", "    primary_keys = [\"date\"]\n\t    replication_key = None\n\t    schema_filepath = SCHEMAS_DIR / \"trading_calendar.json\"\n\t    records_jsonpath = \"$.trading_calendar[*]\"\n\t    def get_url_params(\n\t        self,\n\t        context: dict | None,\n\t        _next_page_token: Any | None,\n\t    ) -> dict[str, Any]:\n\t        \"\"\"Return a dictionary of parameters to use in the URL.\"\"\"\n", "        params: dict = {}\n\t        starting_date = self.get_starting_timestamp(context)\n\t        if starting_date:\n\t            params[\"from\"] = starting_date.strftime(\"%Y-%m-%d\")\n\t        return params\n"]}
{"filename": "tap_jquants/streams/topix.py", "chunked_list": ["\"\"\"TOPIX指数四本値 (/indices/topix).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/topix\n\t\"\"\"\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\tclass TopixStream(JQuantsStream):\n\t    \"\"\"the topix stream.\"\"\"\n\t    name = \"topix\"\n\t    path = \"/indices/topix\"\n\t    primary_keys = [\"date\"]\n\t    replication_key = None\n", "    schema_filepath = SCHEMAS_DIR / \"topix.json\"\n\t    records_jsonpath = \"$.topix[*]\"\n"]}
{"filename": "tap_jquants/streams/daily_quotes.py", "chunked_list": ["\"\"\"株価四本値 (/prices/daily_quotes).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/daily_quotes\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass DailyQuotesStream(JQuantsDateStream):\n\t    \"\"\"the daily_quotes stream.\"\"\"\n\t    name = \"daily_quotes\"\n\t    path = \"/prices/daily_quotes\"\n\t    primary_keys = [\"date\", \"code\"]\n", "    replication_key = \"date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"daily_quotes.json\"\n\t    records_jsonpath = \"$.daily_quotes[*]\"\n"]}
{"filename": "tap_jquants/streams/__init__.py", "chunked_list": ["\"\"\"Stream classes for tap-jquants.\"\"\"\n\tfrom tap_jquants.streams.announcement import AnnouncementStream\n\tfrom tap_jquants.streams.breakdown import BreakdownStream\n\tfrom tap_jquants.streams.daily_quotes import DailyQuotesStream\n\tfrom tap_jquants.streams.dividend import DividendStream\n\tfrom tap_jquants.streams.index_option import IndexOptionStream\n\tfrom tap_jquants.streams.listed_info import ListedInfoStream\n\tfrom tap_jquants.streams.prices_am import PricesAmStream\n\tfrom tap_jquants.streams.short_selling import ShortSellingStream\n\tfrom tap_jquants.streams.statements import StatementsStream\n", "from tap_jquants.streams.topix import TopixStream\n\tfrom tap_jquants.streams.trades_spec import TradesSpecStream\n\tfrom tap_jquants.streams.trading_calendar import TradingCalendarStream\n\tfrom tap_jquants.streams.weekly_margin_interest import WeeklyMarginInterestStream\n\t__all__ = [\n\t    \"AnnouncementStream\",\n\t    \"BreakdownStream\",\n\t    \"DailyQuotesStream\",\n\t    \"DividendStream\",\n\t    \"IndexOptionStream\",\n", "    \"TopixStream\",\n\t    \"ListedInfoStream\",\n\t    \"PricesAmStream\",\n\t    \"ShortSellingStream\",\n\t    \"StatementsStream\",\n\t    \"TradesSpecStream\",\n\t    \"TradingCalendarStream\",\n\t    \"WeeklyMarginInterestStream\",\n\t]\n"]}
{"filename": "tap_jquants/streams/listed_info.py", "chunked_list": ["\"\"\"上場銘柄一覧 (/listed/info).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/listed_info\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass ListedInfoStream(JQuantsDateStream):\n\t    \"\"\"the listed_info stream.\"\"\"\n\t    name = \"listed_info\"\n\t    path = \"/listed/info\"\n\t    primary_keys = [\"date\", \"code\"]\n", "    replication_key = \"date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"listed_info.json\"\n\t    records_jsonpath = \"$.info[*]\"\n"]}
{"filename": "tap_jquants/streams/index_option.py", "chunked_list": ["\"\"\"オプション四本値 (/option/index_option).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/index_option\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass IndexOptionStream(JQuantsDateStream):\n\t    \"\"\"the index_option stream.\"\"\"\n\t    name = \"index_option\"\n\t    path = \"/option/index_option\"\n\t    primary_keys = [\"date\", \"code\"]\n", "    replication_key = \"date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"index_option.json\"\n\t    records_jsonpath = \"$.index_option[*]\"\n\t    def post_process(\n\t        self,\n\t        row: dict,\n\t        _context: dict | None = None,\n\t    ) -> dict | None:\n\t        \"\"\"Fix empty string in some night session data to None.\"\"\"\n", "        if not row[\"night_session_open\"]:\n\t            row[\"night_session_open\"] = None\n\t            row[\"night_session_high\"] = None\n\t            row[\"night_session_low\"] = None\n\t            row[\"night_session_close\"] = None\n\t        return row\n"]}
{"filename": "tap_jquants/streams/trades_spec.py", "chunked_list": ["\"\"\"投資部門別情報 (/markets/trades_spec).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/trades_spec\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsFromStream\n\tclass TradesSpecStream(JQuantsFromStream):\n\t    \"\"\"the trades_spec stream.\"\"\"\n\t    name = \"trades_spec\"\n\t    path = \"/markets/trades_spec\"\n\t    primary_keys = [\"published_date\", \"section\"]\n", "    replication_key = \"published_date\"\n\t    schema_filepath = SCHEMAS_DIR / \"trades_spec.json\"\n\t    records_jsonpath = \"$.trades_spec[*]\"\n"]}
{"filename": "tap_jquants/streams/short_selling.py", "chunked_list": ["\"\"\"業種別空売り比率 (/markets/short_selling).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/short_selling\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass ShortSellingStream(JQuantsDateStream):\n\t    \"\"\"the short_selling stream.\"\"\"\n\t    name = \"short_selling\"\n\t    path = \"/markets/short_selling\"\n\t    primary_keys = [\"date\", \"sector33_code\"]\n", "    replication_key = \"date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"short_selling.json\"\n\t    records_jsonpath = \"$.short_selling[*]\"\n"]}
{"filename": "tap_jquants/streams/dividend.py", "chunked_list": ["\"\"\"配当金情報 (/fins/dividend).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/dividend\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass DividendStream(JQuantsDateStream):\n\t    \"\"\"the dividend stream.\"\"\"\n\t    name = \"dividend\"\n\t    path = \"/fins/dividend\"\n\t    primary_keys = [\"announcement_date\", \"announcement_time\", \"code\"]\n", "    replication_key = \"announcement_date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"dividend.json\"\n\t    records_jsonpath = \"$.dividend[*]\"\n\t    def post_process(\n\t        self,\n\t        row: dict,\n\t        _context: dict | None = None,\n\t    ) -> dict | None:\n\t        \"\"\"Converts number or string properties.\"\"\"\n", "        for key in [\n\t            \"gross_dividend_rate\",\n\t            \"distribution_amount\",\n\t            \"retained_earnings\",\n\t            \"deemed_dividend\",\n\t            \"deemed_capital_gains\",\n\t            \"net_asset_decrease_ratio\",\n\t            \"commemorative_dividend_rate\",\n\t            \"special_dividend_rate\",\n\t        ]:\n", "            num_key = f\"{key}_num\"\n\t            if key not in row:\n\t                continue\n\t            value = row[key]\n\t            if isinstance(value, str):\n\t                if value and value != \"-\":\n\t                    row[num_key] = float(value)\n\t            else:\n\t                row[key] = str(value)\n\t                row[num_key] = value\n", "        return row\n"]}
{"filename": "tap_jquants/streams/prices_am.py", "chunked_list": ["\"\"\"前場四本値 (/prices/prices_am).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/prices_am\n\t\"\"\"\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\tclass PricesAmStream(JQuantsStream):\n\t    \"\"\"the prices_am stream.\"\"\"\n\t    name = \"prices_am\"\n\t    path = \"/prices/prices_am\"\n\t    primary_keys = [\"date\", \"code\"]\n\t    replication_key = None\n", "    schema_filepath = SCHEMAS_DIR / \"prices_am.json\"\n\t    records_jsonpath = \"$.prices_am[*]\"\n"]}
{"filename": "tap_jquants/streams/announcement.py", "chunked_list": ["\"\"\"決算発表予定日 (/fins/announcement).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/announcement\n\t\"\"\"\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\tclass AnnouncementStream(JQuantsStream):\n\t    \"\"\"the announcement stream.\"\"\"\n\t    name = \"announcement\"\n\t    path = \"/fins/announcement\"\n\t    primary_keys = [\"date\", \"code\"]\n\t    replication_key = None\n", "    schema_filepath = SCHEMAS_DIR / \"announcement.json\"\n\t    records_jsonpath = \"$.announcement[*]\"\n"]}
{"filename": "tap_jquants/streams/statements.py", "chunked_list": ["\"\"\"財務情報 (/fins/statements).\n\thttps://jpx.gitbook.io/j-quants-ja/api-reference/statements\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\tclass StatementsStream(JQuantsDateStream):\n\t    \"\"\"the statements stream.\"\"\"\n\t    name = \"statements\"\n\t    path = \"/fins/statements\"\n\t    primary_keys = [\"disclosed_date\", \"local_code\"]\n", "    replication_key = \"disclosed_date\"\n\t    is_sorted = True\n\t    schema_filepath = SCHEMAS_DIR / \"statements.json\"\n\t    records_jsonpath = \"$.statements[*]\"\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["\"\"\"Test suite for tap-jquants.\"\"\"\n"]}
{"filename": "tests/test_core.py", "chunked_list": ["\"\"\"Tests standard tap features using the built-in SDK tests library.\"\"\"\n\t# We cannot test the tap without valid accounts, so we skip the tests by default.\n"]}
{"filename": "tests/test_helpers.py", "chunked_list": ["from datetime import datetime, timedelta, timezone\n\tfrom tap_jquants.helpers import convert_json, convert_key, get_next_date\n\tdef test_convert_key():\n\t    assert convert_key(\"CamelCase\") == \"camel_case\"\n\t    assert convert_key(\"MoreCamelCases\") == \"more_camel_cases\"\n\t    assert convert_key(\"Sector17CodeName\") == \"sector17_code_name\"\n\t    assert (\n\t        convert_key(\"CityBKsRegionalBKsEtcSales\") == \"city_bks_regional_bks_etc_sales\"\n\t    )\n\t    # 'Share2nd' is not converted to 'share_2nd'.\n", "    # The only way to do that is to use a dictionary.\n\t    assert (\n\t        convert_key(\"ResultDividendPerShare2ndQuarter\")\n\t        == \"result_dividend_per_share2nd_quarter\"\n\t    )\n\t    assert convert_key(\"DistributionsPerUnit(REIT)\") == \"distributions_per_unit_reit\"\n\t    assert convert_key(\n\t        \"NumberOfIssuedAndOutstandingSharesAtTheEndOfFiscalYearIncludingTreasuryStock\",\n\t    ) == (\n\t        \"number_of_issued_and_outstanding_shares_at_the_end_of_fiscal_year\"\n", "        \"_including_treasury_stock\"\n\t    )\n\t    assert convert_key(\"Volume(OnlyAuction)\") == \"volume_only_auction\"\n\tdef test_convert_json():\n\t    assert convert_json(\n\t        {\n\t            \"info\": [\n\t                {\n\t                    \"Date\": \"2022-11-11\",\n\t                    \"Code\": \"86970\",\n", "                    \"CompanyName\": \"日本取引所グループ\",\n\t                    \"CompanyNameEnglish\": \"Japan Exchange Group,Inc.\",\n\t                },\n\t            ],\n\t        },\n\t    ) == {\n\t        \"info\": [\n\t            {\n\t                \"date\": \"2022-11-11\",\n\t                \"code\": \"86970\",\n", "                \"company_name\": \"日本取引所グループ\",\n\t                \"company_name_english\": \"Japan Exchange Group,Inc.\",\n\t            },\n\t        ],\n\t    }\n\tdef test_gen_next_date():\n\t    assert get_next_date(\"2021-01-01\") == \"2021-01-02\"\n\t    assert get_next_date(\"2021-01-31\") == \"2021-02-01\"\n\t    assert get_next_date(\"2021-02-28\") == \"2021-03-01\"\n\t    assert get_next_date(\"2021-12-31\") == \"2022-01-01\"\n", "    assert (\n\t        get_next_date(\n\t            datetime.now(tz=timezone(timedelta(hours=9))).strftime(\"%Y-%m-%d\"),\n\t        )\n\t        is None\n\t    )\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["\"\"\"Test Configuration.\"\"\"\n\tpytest_plugins = (\"singer_sdk.testing.pytest_plugin\",)\n"]}
