{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/validation_test.py", "chunked_list": ["import pytest\n\tfrom checkr import validate\n\tfrom tests.fixtures import (\n\t    SampleRequestUsingArrayRules,\n\t    SampleRequest,\n\t    SampleRequestWithIncorrectRule,\n\t    SampleRejectedRequest,\n\t    SampleFailingRequest,\n\t)\n\tfrom checkr.exceptions import (\n", "    InvalidRuleException,\n\t    UnauthorizedRequestException,\n\t    ValidationError,\n\t)\n\tdef test_reject_request_if_unauthorized():\n\t    request = {}\n\t    validation_class = SampleRejectedRequest()\n\t    with pytest.raises(UnauthorizedRequestException):\n\t        validate(validation_class=validation_class, request_data=request)\n\tdef test_can_validate_array_of_rules():\n", "    request = {\"foo\": \"bar\"}\n\t    validation_class = SampleRequestUsingArrayRules()\n\t    assert validate(validation_class=validation_class, request_data=request) is True\n\tdef test_can_validate_string_of_rules():\n\t    request = {\"foo\": \"bar\"}\n\t    validation_class = SampleRequest()\n\t    assert validate(validation_class=validation_class, request_data=request) is True\n\tdef test_throws_correct_exception_when_rule_is_incorrect():\n\t    request = {}\n\t    validation_class = SampleRequestWithIncorrectRule()\n", "    with pytest.raises(InvalidRuleException):\n\t        validate(validation_class=validation_class, request_data=request)\n\tdef test_throws_correct_exception_when_validation_fails():\n\t    request = {}\n\t    validation_class = SampleFailingRequest()\n\t    with pytest.raises(ValidationError):\n\t        validate(validation_class=validation_class, request_data=request)\n"]}
{"filename": "tests/fixtures.py", "chunked_list": ["from typing import Dict\n\tfrom checkr.BaseRequest import BaseRequest\n\tclass SampleRequest(BaseRequest):\n\t    @staticmethod\n\t    def authorize() -> bool:\n\t        return True\n\t    @staticmethod\n\t    def rules() -> Dict:\n\t        return {\n\t            \"foo\": \"required\",\n", "        }\n\tclass SampleFailingRequest(BaseRequest):\n\t    @staticmethod\n\t    def authorize() -> bool:\n\t        return True\n\t    @staticmethod\n\t    def rules() -> Dict:\n\t        return {\n\t            \"foo\": \"required\",\n\t        }\n", "class SampleRequestUsingArrayRules(BaseRequest):\n\t    @staticmethod\n\t    def authorize() -> bool:\n\t        return True\n\t    @staticmethod\n\t    def rules() -> Dict:\n\t        return {\n\t            \"foo\": [\"required\", \"string\"],\n\t        }\n\tclass SampleRequestWithIncorrectRule(BaseRequest):\n", "    @staticmethod\n\t    def authorize() -> bool:\n\t        return True\n\t    @staticmethod\n\t    def rules() -> Dict:\n\t        return {\n\t            \"foo\": \"bar\",\n\t        }\n\tclass SampleRejectedRequest(BaseRequest):\n\t    @staticmethod\n", "    def authorize() -> bool:\n\t        return False\n\t    @staticmethod\n\t    def rules() -> Dict:\n\t        return {\n\t            \"foo\": \"bar\",\n\t        }\n"]}
{"filename": "tests/base_requests_test.py", "chunked_list": ["from tests.fixtures import SampleRequest\n\tdef test_set_data():\n\t    validation_class = SampleRequest()\n\t    validation_class.set_data(data={\"foo\": \"bar\"})\n\t    assert {\"foo\": \"bar\"} == validation_class.get_data()\n\tdef test_merge_data():\n\t    validation_class = SampleRequest()\n\t    validation_class.set_data(data={\"foo\": \"bar\"})\n\t    validation_class.merge(data_to_add={\"bar\": \"baz\"})\n\t    assert validation_class.get_data() == {\"foo\": \"bar\", \"bar\": \"baz\"}\n", "def test_extract_simple_rule_data():\n\t    validation_class = SampleRequest()\n\t    rule_data = validation_class.extract_rule_data(\"foo\")\n\t    assert rule_data[\"rule_name\"] == \"foo\"\n\t    assert rule_data[\"rule_payload\"] is None\n\tdef test_extract_compound_rule_data():\n\t    validation_class = SampleRequest()\n\t    first_rule_data = validation_class.extract_rule_data(\"foo:bar\")\n\t    second_rule_data = validation_class.extract_rule_data(\"eggs:bar,baz\")\n\t    assert first_rule_data[\"rule_name\"] == \"foo\"\n", "    assert first_rule_data[\"rule_payload\"] == \"bar\"\n\t    assert second_rule_data[\"rule_name\"] == \"eggs\"\n\t    assert len(second_rule_data[\"rule_payload\"]) == 2\n\t    assert second_rule_data[\"rule_payload\"] == [\"bar\", \"baz\"]\n"]}
{"filename": "checkr/BaseRequest.py", "chunked_list": ["from abc import ABCMeta\n\tfrom typing import Dict, Union, List, Any\n\tfrom .ErrorBag import ErrorBag\n\tfrom .exceptions import (\n\t    InvalidRuleException,\n\t    UnauthorizedRequestException,\n\t)\n\tfrom .rules_map import rules_to_objects_map\n\tclass BaseRequest(metaclass=ABCMeta):\n\t    __is_valid = False\n", "    __data = {}\n\t    __errors = {}\n\t    __rules_map = rules_to_objects_map\n\t    __user_provided_validation_messages = {}\n\t    __error_bag = ErrorBag()\n\t    @staticmethod\n\t    def authorize() -> bool:\n\t        raise NotImplementedError(\"Method `authorize` not implemented\")\n\t    @staticmethod\n\t    def rules() -> Dict:\n", "        \"\"\"Returns a dictionary of checkr rules for the request.\n\t        :raises NotImplementedError: The method is not implemented.\n\t        :return: A dictionary of checkr rules.\n\t        :rtype: dict\n\t        \"\"\"\n\t        raise NotImplementedError(\"Method `rules` not implemented\")\n\t    @classmethod\n\t    def prepare_for_validation(cls) -> None:\n\t        \"\"\"A hook that executes before starting the checkr process.\n\t        :return: Nothing\n", "        :rtype: None\n\t        \"\"\"\n\t        pass\n\t    @classmethod\n\t    def passed_validation(cls) -> None:\n\t        \"\"\"A hook that executes after the checkr succeeds and the data is valid.\n\t        :return: None\n\t        :rtype: None\n\t        \"\"\"\n\t        pass\n", "    @classmethod\n\t    def messages(cls) -> Dict:\n\t        pass\n\t    @classmethod\n\t    def set_data(cls, data: Dict) -> None:\n\t        \"\"\"Sets the request data for the class.\n\t        :param data: The data to set for the request.\n\t        :type data: dict\n\t        :return: None\n\t        :rtype: None\n", "        \"\"\"\n\t        cls.__data = data\n\t    @classmethod\n\t    def handle(cls) -> Union[bool, Dict]:\n\t        \"\"\"Handles checkr for the given rules and returns checkr result.\n\t        :return: A boolean value indicating whether the data passes the checkr or a dictionary containing error\n\t        messages.\n\t        :rtype: bool or dict\n\t        \"\"\"\n\t        cls.__user_provided_validation_messages = cls.messages() or {}\n", "        if cls.authorize():\n\t            fields = cls.rules()\n\t            for field in fields:\n\t                cls.__error_bag.set_current_field(field=field)\n\t                cls.__validate_field(\n\t                    rules_map=cls.__rules_map,\n\t                    attribute=field,\n\t                    rules=fields[field],\n\t                    value=cls.__data.get(field.split(\".\")[0]),\n\t                )\n", "            if cls.__error_bag.has_errors():\n\t                cls.__is_valid = False\n\t                return False\n\t            cls.__is_valid = True\n\t            return True\n\t        raise UnauthorizedRequestException(\"Request is not authorized.\")\n\t    @classmethod\n\t    def passes(cls) -> bool:\n\t        return cls.__is_valid\n\t    @classmethod\n", "    def merge(cls, data_to_add: Dict) -> None:\n\t        \"\"\"Merges the given dictionary of data into the existing request data.\n\t        :param data_to_add: The dictionary of data to merge.\n\t        :type data_to_add: dict\n\t        :return: None\n\t        :rtype: None\n\t        \"\"\"\n\t        cls.__data = {**cls.__data, **data_to_add}\n\t    @classmethod\n\t    def __validate_field(\n", "        cls, rules_map: Dict, attribute: str, rules: Union[str, List], value: Any\n\t    ) -> ErrorBag:\n\t        \"\"\"Validates a single field against the given rules.\n\t        :param attribute: The attribute being validated.\n\t        :type attribute: str\n\t        :param rules: The rules to validate against, as a list or a pipe-separated string.\n\t        :type rules: Union[list, str]\n\t        :param value: The value of the attribute being validated.\n\t        :type value: Any\n\t        :return: List\n", "        :rtype: List\n\t        \"\"\"\n\t        attribute = attribute.split(\".\")\n\t        cls.__error_bag.set_current_field(field=attribute)\n\t        validation_errors = cls.__validate_nested_field(\n\t            rules_map=rules_map,\n\t            attribute=attribute,\n\t            rules=rules,\n\t            value=value,\n\t        )\n", "        cls.__error_bag.reset_current_field()\n\t        return validation_errors\n\t    @classmethod\n\t    def __validate_single_field(\n\t        cls, rules_map: Dict, attribute: str, rules: Union[str, List], value: Any\n\t    ):\n\t        is_custom_rule = False\n\t        if isinstance(rules, str):\n\t            rules = rules.split(\"|\")\n\t        field_errors = []\n", "        extracted_rule_with_data = None\n\t        for rule in rules:\n\t            if isinstance(rule, str):\n\t                try:\n\t                    extracted_rule_with_data = cls.extract_rule_data(rule=rule)\n\t                    rule_object = rules_map[extracted_rule_with_data[\"rule_name\"]]()\n\t                    rule_object.set_validation_payload(\n\t                        payload=extracted_rule_with_data[\"rule_payload\"]\n\t                    )\n\t                except KeyError:\n", "                    raise InvalidRuleException(\n\t                        f\"Invalid validation rule: {extracted_rule_with_data['rule_name']}. \"\n\t                        f\"Check the provided rules dictionary.\"\n\t                    )\n\t            else:\n\t                rule_object = rule\n\t                is_custom_rule = True\n\t            try:\n\t                if not rule_object.validate(attribute=attribute, value=value):\n\t                    custom_validation_message = cls.__user_provided_validation_messages.get(\n", "                        f'{cls.__error_bag.get_current_field()[0]}.{extracted_rule_with_data[\"rule_name\"]}'\n\t                    )\n\t                    cls.__error_bag.add_error(\n\t                        rule_name=extracted_rule_with_data[\"rule_name\"]\n\t                        if not is_custom_rule\n\t                        else str(rule),\n\t                        error=custom_validation_message\n\t                        or rule_object.message(attribute=attribute[0]),\n\t                    )\n\t            except (ValueError, AttributeError):\n", "                raise InvalidRuleException(\n\t                    f\"Invalid validation rule: {extracted_rule_with_data['rule_name']}. \"\n\t                    f\"Check the provided rules dictionary.\"\n\t                )\n\t        return field_errors\n\t    @classmethod\n\t    def __validate_nested_field(\n\t        cls,\n\t        rules_map: Dict,\n\t        attribute: Union[str, List],\n", "        rules: Union[str, List],\n\t        value: Any,\n\t    ):\n\t        if len(attribute) == 1:\n\t            if attribute[0] == \"*\":\n\t                for key, single_value in enumerate(value):\n\t                    cls.__validate_single_field(\n\t                        rules_map=rules_map,\n\t                        attribute=attribute,\n\t                        rules=rules,\n", "                        value=single_value,\n\t                    )\n\t            else:\n\t                cls.__validate_single_field(\n\t                    rules_map=rules_map,\n\t                    attribute=attribute,\n\t                    rules=rules,\n\t                    value=value[attribute[0]] if isinstance(value, Dict) else value,\n\t                )\n\t        else:\n", "            if attribute[0] == \"*\":\n\t                try:\n\t                    for key, single_value in enumerate(value):\n\t                        cls.__validate_nested_field(\n\t                            rules_map=rules_map,\n\t                            attribute=attribute[1:],\n\t                            rules=rules,\n\t                            value=single_value.get(attribute[1]),\n\t                        )\n\t                except TypeError:\n", "                    custom_rule = cls.__user_provided_validation_messages.get(\n\t                        f\"{cls.__error_bag.get_current_field()[0]}.required\"\n\t                    )\n\t                    cls.__error_bag.add_error(\n\t                        rule_name=\"required\", error=custom_rule or \"Field is required\"\n\t                    )\n\t            else:\n\t                cls.__validate_nested_field(\n\t                    rules_map=rules_map,\n\t                    attribute=attribute[1:],\n", "                    rules=rules,\n\t                    value=value,\n\t                )\n\t        return cls.__error_bag\n\t    @classmethod\n\t    def get_errors(cls) -> ErrorBag:\n\t        \"\"\"Returns the checkr errors stored in the class.\n\t        :return: A dictionary containing errors resulting from the checkr process.\n\t        :rtype: dict\n\t        \"\"\"\n", "        return cls.__error_bag\n\t    @classmethod\n\t    def extract_rule_data(cls, rule: str) -> Dict:\n\t        rule_parts = rule.split(\":\", 1)\n\t        rule_name = rule_parts[0]\n\t        rule_payload = rule_parts[-1] if rule_parts[0] != rule_parts[-1] else None\n\t        return {\n\t            \"rule_name\": rule_name,\n\t            \"rule_payload\": (\n\t                cls.extract_rule_payload(rule_payload) if rule_payload else rule_payload\n", "            ),\n\t        }\n\t    @classmethod\n\t    def extract_rule_payload(cls, payload: str) -> Union[List, str]:\n\t        payload = payload.split(\",\")\n\t        return payload[0] if len(payload) == 1 else payload\n\t    def get_data(self) -> Dict:\n\t        return self.__data\n"]}
{"filename": "checkr/rules_map.py", "chunked_list": ["from .rules.Boolean import Boolean\n\tfrom .rules.Endswith import Endswith\n\tfrom .rules.Email import Email\n\tfrom .rules.NotInArray import NotInArray\n\tfrom .rules.Startswith import Startswith\n\tfrom .rules.Url import Url\n\tfrom .rules.Uuid import Uuid\n\tfrom .rules.Ulid import Ulid\n\tfrom .rules.Gte import Gte\n\tfrom .rules.Gt import Gt\n", "from .rules.DateAfter import DateAfter\n\tfrom .rules.DateAfterOrEqual import DateAfterOrEqual\n\tfrom .rules.ArrayOf import ArrayOf\n\tfrom .rules.DateBefore import DateBefore\n\tfrom .rules.DateBeforeOrEqual import DateBeforeOrEqual\n\tfrom .rules.Decimal import Decimal\n\tfrom .rules.InArray import InArray\n\tfrom .rules.Array import Array\n\tfrom .rules.Integer import Integer\n\tfrom .rules.Ip import Ip\n", "from .rules.Ipv4 import Ipv4\n\tfrom .rules.Ipv6 import Ipv6\n\tfrom .rules.Json import Json\n\tfrom .rules.Lowercase import Lowercase\n\tfrom .rules.Lt import Lt\n\tfrom .rules.Lte import Lte\n\tfrom .rules.MacAddress import MacAdress\n\tfrom .rules.Max import Max\n\tfrom .rules.MaxDigits import MaxDigits\n\tfrom .rules.Min import Min\n", "from .rules.MinDigits import MinDigits\n\tfrom .rules.Nullable import Nullable\n\tfrom .rules.String import String\n\tfrom .rules.Required import Required\n\tfrom .rules.Numeric import Numeric\n\tfrom .rules.Between import Between\n\tfrom .rules.Uppercase import Uppercase\n\trules_to_objects_map = {\n\t    \"between\": Between,\n\t    \"string\": String,\n", "    \"int\": Integer,\n\t    \"required\": Required,\n\t    \"numeric\": Numeric,\n\t    \"in_array\": InArray,\n\t    \"array\": Array,\n\t    \"array_of\": ArrayOf,\n\t    \"date_after\": DateAfter,\n\t    \"date_after_or_equal\": DateAfterOrEqual,\n\t    \"date_before\": DateBefore,\n\t    \"date_before_or_equal\": DateBeforeOrEqual,\n", "    \"min\": Min,\n\t    \"max\": Max,\n\t    \"max_digits\": MaxDigits,\n\t    \"min_digits\": MinDigits,\n\t    \"json\": Json,\n\t    \"nullable\": Nullable,\n\t    \"decimal\": Decimal,\n\t    \"gt\": Gt,\n\t    \"gte\": Gte,\n\t    \"lt\": Lt,\n", "    \"lte\": Lte,\n\t    \"ip\": Ip,\n\t    \"ipv4\": Ipv4,\n\t    \"ipv6\": Ipv6,\n\t    \"lowercase\": Lowercase,\n\t    \"uppercase\": Uppercase,\n\t    \"mac_address\": MacAdress,\n\t    \"uuid\": Uuid,\n\t    \"ulid\": Ulid,\n\t    \"url\": Url,\n", "    \"startswith\": Startswith,\n\t    \"endswith\": Endswith,\n\t    \"email\": Email,\n\t    \"not_in_array\": NotInArray,\n\t    \"bool\": Boolean,\n\t}\n"]}
{"filename": "checkr/__init__.py", "chunked_list": ["from typing import Dict\n\tfrom .exceptions import ValidationError\n\tdef validate(validation_class, request_data: Dict):\n\t    validation_class.set_data(data=request_data)\n\t    validation_class.prepare_for_validation()\n\t    validation_class.handle()\n\t    if not validation_class.passes():\n\t        raise ValidationError(\"Invalid data\", errors=validation_class.get_errors())\n\t    validation_class.passed_validation()\n\t    return True\n"]}
{"filename": "checkr/ErrorBag.py", "chunked_list": ["import json\n\tfrom typing import Union, List, Dict\n\tclass ErrorBag:\n\t    def __init__(self):\n\t        self.__cursor = 0\n\t        self.__errors: Dict = {}\n\t        self.__field: str = \"\"\n\t        self.__level: int = 0\n\t    def __str__(self):\n\t        return json.dumps(self.__errors)\n", "    def add_error(self, rule_name: str, error: Union[List, Dict, str]) -> None:\n\t        if len(error) > 0:\n\t            current_field = self.get_current_field()[0]\n\t            current_field_errors = self.__errors.get(current_field)\n\t            if current_field_errors:\n\t                self.__errors[current_field] = {\n\t                    **current_field_errors,\n\t                    **{rule_name: error},\n\t                }\n\t            else:\n", "                self.__errors[current_field] = {rule_name: error}\n\t    def has_errors(self) -> bool:\n\t        return len(self.__errors.values()) > 0\n\t    def get_current_field(self) -> str:\n\t        return self.__field\n\t    def set_current_field(self, field: Union[List, str]) -> None:\n\t        self.__field = field\n\t    def reset_current_field(self) -> None:\n\t        self.set_current_field(field=\"\")\n"]}
{"filename": "checkr/exceptions.py", "chunked_list": ["class InvalidRuleException(Exception):\n\t    pass\n\tclass ValidationError(Exception):\n\t    def __init__(self, message, errors):\n\t        super().__init__(message)\n\t        self.errors = errors\n\tclass UnauthorizedRequestException(Exception):\n\t    pass\n"]}
{"filename": "checkr/rules/Numeric.py", "chunked_list": ["from typing import Union, Any\n\tfrom .BaseRule import BaseRule\n\tclass Numeric(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            float(value)\n\t        except (ValueError, TypeError):\n\t            return False\n\t        return True\n\t    def message(self, attribute: str) -> str:\n", "        return f\"{attribute} is non-numeric\"\n"]}
{"filename": "checkr/rules/Accepted.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Accepted(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return value in [\"yes\", \"on\", 1, True]\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not accepted\"\n"]}
{"filename": "checkr/rules/DateAfter.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass DateAfter(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n\t        given_date = datetime.strptime(value, \"%Y-%m-%d\")\n\t        return given_date > specified_date\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not after {self.payload}\"\n"]}
{"filename": "checkr/rules/Max.py", "chunked_list": ["from typing import Any, Union\n\tfrom .BaseRule import BaseRule\n\tclass Max(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        if isinstance(value, Union[int, float]):\n\t            return value <= float(self.payload)\n\t        return len(value) <= float(self.payload)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} length is bigger than {self.payload}\"\n"]}
{"filename": "checkr/rules/Lowercase.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Lowercase(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return str(value).lower() == str(value)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not lowercased\"\n"]}
{"filename": "checkr/rules/Decimal.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Decimal(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        if self.payload:\n\t            return isinstance(value, float) and int(self.payload[0]) <= str(value)[\n\t                ::-1\n\t            ].find(\".\") <= int(self.payload[-1])\n\t        else:\n\t            return isinstance(value, float)\n", "    def message(self, attribute: str) -> str:\n\t        if self.payload:\n\t            return f\"{attribute} does not have the correct number of decimal places\"\n\t        return f\"'{attribute}' is not a decimal number.\"\n"]}
{"filename": "checkr/rules/Boolean.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Boolean(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return isinstance(value, bool)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not a boolean\"\n"]}
{"filename": "checkr/rules/MacAddress.py", "chunked_list": ["import re\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass MacAdress(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        is_valid_mac = re.match(\n\t            r\"([0-9A-F]{2}[:]){5}[0-9A-F]{2}|([0-9A-F]{2}[-]){5}[0-9A-F]{2}\",\n\t            string=value or \"\",\n\t            flags=re.IGNORECASE,\n\t        )\n", "        try:\n\t            return bool(is_valid_mac.group())\n\t        except AttributeError:\n\t            return False\n\t    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not a valid MAC address\"\n"]}
{"filename": "checkr/rules/MinDigits.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass MinDigits(BaseRule):\n\t    __message = None\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            return float(self.payload) <= len(str(value).replace(\".\", \"\"))\n\t        except ValueError:\n\t            self.__message = f\"{attribute[0]} value is not a valid float or int\"\n\t            return False\n", "    def message(self, attribute: str) -> str:\n\t        return (\n\t            f\"{attribute} number of digits is less than {self.payload}\"\n\t            if not self.__message\n\t            else self.__message\n\t        )\n"]}
{"filename": "checkr/rules/DateBefore.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass DateBefore(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n\t            given_date = datetime.strptime(value, \"%Y-%m-%d\")\n\t            return given_date < specified_date\n\t        except (TypeError, ValueError):\n", "            return False\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not before {self.payload}\"\n"]}
{"filename": "checkr/rules/DateBeforeOrEqual.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass DateBeforeOrEqual(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n\t            given_date = datetime.strptime(value, \"%Y-%m-%d\")\n\t            return given_date <= specified_date\n\t        except TypeError:\n", "            return False\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not at {self.payload} or before\"\n"]}
{"filename": "checkr/rules/Nullable.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Nullable(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return value is None\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not nullable\"\n"]}
{"filename": "checkr/rules/Gt.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Gt(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            return float(value) > float(self.payload)\n\t        except (TypeError, ValueError):\n\t            return False\n\t    def message(self, attribute: str) -> str:\n\t        try:\n", "            return f\"'{attribute}' is not greater than {self.payload}\"\n\t        except TypeError:\n\t            return \"You haven't specified any value for comparison\"\n"]}
{"filename": "checkr/rules/Declined.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Declined(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return value in [\"no\", \"off\", 0, False]\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not declined\"\n"]}
{"filename": "checkr/rules/Min.py", "chunked_list": ["from typing import Any, Union\n\tfrom .BaseRule import BaseRule\n\tclass Min(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        if isinstance(value, Union[int, float]):\n\t            return value >= float(self.payload)\n\t        return len(value) >= float(self.payload)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} length is smaller than {self.payload}\"\n"]}
{"filename": "checkr/rules/Lt.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Lt(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            return float(value) < float(self.payload)\n\t        except (TypeError, ValueError):\n\t            return False\n\t    def message(self, attribute: str) -> str:\n\t        try:\n", "            return f\"'{attribute}' is not less than {self.payload}\"\n\t        except TypeError:\n\t            return \"You haven't specified any value for comparison\"\n"]}
{"filename": "checkr/rules/Startswith.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Startswith(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return isinstance(value, str) and value.startswith(self.payload)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"`{attribute}` does not start with the `{self.payload}`\"\n"]}
{"filename": "checkr/rules/__init__.py", "chunked_list": []}
{"filename": "checkr/rules/Url.py", "chunked_list": ["import validators\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Url(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return validators.url(value or \"\")\n\t    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not a valid URL\"\n"]}
{"filename": "checkr/rules/Ip.py", "chunked_list": ["import ipaddress\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Ip(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            ipaddress.ip_address(value)\n\t            return True\n\t        except ValueError:\n\t            return False\n", "    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not a valid IP address\"\n"]}
{"filename": "checkr/rules/Uuid.py", "chunked_list": ["from uuid import UUID\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Uuid(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        version = self.payload or 4\n\t        try:\n\t            uuid_object = UUID(value, version=version)\n\t        except ValueError:\n\t            return False\n", "        return str(uuid_object) == value\n\t    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not a valid UUID\"\n"]}
{"filename": "checkr/rules/String.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass String(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return isinstance(value, str)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not a string\"\n"]}
{"filename": "checkr/rules/MaxDigits.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass MaxDigits(BaseRule):\n\t    __message = None\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            return float(self.payload) >= len(str(value).replace(\".\", \"\"))\n\t        except ValueError:\n\t            self.__message = f\"{attribute[0]} value is not a valid float or int\"\n\t            return False\n", "    def message(self, attribute: str) -> str:\n\t        return (\n\t            f\"{attribute} number of digits is more than {self.payload}\"\n\t            if not self.__message\n\t            else self.__message\n\t        )\n"]}
{"filename": "checkr/rules/Lte.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Lte(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            return float(value) <= float(self.payload)\n\t        except (TypeError, ValueError):\n\t            return False\n\t    def message(self, attribute: str) -> str:\n\t        try:\n", "            return f\"'{attribute}' is not less than or equal to {self.payload}\"\n\t        except TypeError:\n\t            return \"You haven't specified any value for comparison\"\n"]}
{"filename": "checkr/rules/DateAfterOrEqual.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass DateAfterOrEqual(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n\t        given_date = datetime.strptime(value, \"%Y-%m-%d\")\n\t        return given_date >= specified_date\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not at {self.payload} or after\"\n"]}
{"filename": "checkr/rules/Required.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Required(BaseRule):\n\t    def validate(self, attribute: str, value: Any = None) -> bool:\n\t        return value is not None\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} field is required\"\n"]}
{"filename": "checkr/rules/Email.py", "chunked_list": ["from typing import Any\n\timport validators\n\tfrom validators import ValidationFailure\n\tfrom .BaseRule import BaseRule\n\tclass Email(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            return validators.email(value)\n\t        except ValidationFailure:\n\t            return False\n", "    def message(self, attribute: str) -> str:\n\t        return f\"`{attribute}` does not start with the `{self.payload}`\"\n"]}
{"filename": "checkr/rules/Ulid.py", "chunked_list": ["import ulid\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Ulid(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            ulid.parse(value)\n\t        except ValueError:\n\t            return False\n\t        return True\n", "    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not a valid ULID\"\n"]}
{"filename": "checkr/rules/Endswith.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Endswith(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return isinstance(value, str) and value.endswith(self.payload)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"`{attribute}` does not end with the `{self.payload}`\"\n"]}
{"filename": "checkr/rules/Uppercase.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Uppercase(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return str(value).upper() == str(value)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not uppercased\"\n"]}
{"filename": "checkr/rules/ArrayOf.py", "chunked_list": ["from typing import Any, List, Dict, Tuple, Union\n\tfrom checkr.exceptions import InvalidRuleException\n\tfrom .BaseRule import BaseRule\n\tclass ArrayOf(BaseRule):\n\t    def __get_type_from_string(self, type_string):\n\t        types = {\n\t            \"int\": int,\n\t            \"float\": float,\n\t            \"complex\": complex,\n\t            \"string\": str,\n", "            \"bool\": bool,\n\t            \"dict\": Dict,\n\t            \"set\": set,\n\t            \"frozenset\": frozenset,\n\t            \"list\": List,\n\t            \"tuple\": Tuple,\n\t            \"range\": range,\n\t        }\n\t        return types[type_string]\n\t    def validate(self, attribute: str, value: Any) -> bool:\n", "        try:\n\t            requested_types = [\n\t                self.__get_type_from_string(type_string=type_string)\n\t                for type_string in self.payload\n\t            ]\n\t            return all(isinstance(v, Union[tuple(requested_types)]) for v in value)\n\t        except KeyError as e:\n\t            raise InvalidRuleException(\n\t                f\"Payload {e} is not allowed on current rule. check the payload name.\"\n\t            )\n", "    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not fully composed of one of these type: `{self.payload}`\"\n"]}
{"filename": "checkr/rules/BaseRule.py", "chunked_list": ["from abc import ABCMeta\n\tfrom typing import Any\n\tclass BaseRule(metaclass=ABCMeta):\n\t    payload = None\n\t    def __str__(self):\n\t        return __class__\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        raise NotImplementedError\n\t    def message(self, attribute: str) -> str:\n\t        pass\n", "    def set_validation_payload(self, payload):\n\t        self.payload = payload\n"]}
{"filename": "checkr/rules/NotInArray.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass NotInArray(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        if value:\n\t            return value not in self.payload\n\t        return True\n\t    def message(self, attribute: str) -> str:\n\t        return f\"`{attribute}` is in `{self.payload}`\"\n"]}
{"filename": "checkr/rules/Json.py", "chunked_list": ["import json\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Json(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            json.loads(value)\n\t        except (ValueError, TypeError):\n\t            return False\n\t        return True\n", "    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not a valid JSON\"\n"]}
{"filename": "checkr/rules/Gte.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Gte(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            return float(value) >= float(self.payload)\n\t        except (TypeError, ValueError):\n\t            return False\n\t    def message(self, attribute: str) -> str:\n\t        try:\n", "            return f\"'{attribute}' is not greater than or equal to {self.payload}\"\n\t        except TypeError:\n\t            return \"You haven't specified any value for comparison\"\n"]}
{"filename": "checkr/rules/InArray.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass InArray(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return value in self.payload\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not in the given list\"\n"]}
{"filename": "checkr/rules/Ipv6.py", "chunked_list": ["import ipaddress\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Ipv6(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            ip = ipaddress.ip_address(value)\n\t            return True if ip.version == 6 else False\n\t        except ValueError:\n\t            return False\n", "    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not a valid IPv6 address\"\n"]}
{"filename": "checkr/rules/Between.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Between(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        self.payload.sort()\n\t        try:\n\t            return (\n\t                float(self.payload[0]) <= float(value) <= float(self.payload[-1])\n\t                if value\n\t                else False\n", "            )\n\t        except ValueError:\n\t            return False\n\t    def message(self, attribute: str) -> str:\n\t        return f\"`{attribute}` is not in the specified range\"\n"]}
{"filename": "checkr/rules/Ipv4.py", "chunked_list": ["import ipaddress\n\tfrom typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Ipv4(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        try:\n\t            ip = ipaddress.ip_address(value)\n\t            return True if ip.version == 4 else False\n\t        except ValueError:\n\t            return False\n", "    def message(self, attribute: str) -> str:\n\t        return f\"'{attribute}' is not a valid IPv4 address\"\n"]}
{"filename": "checkr/rules/Array.py", "chunked_list": ["from typing import Any, List\n\tfrom .BaseRule import BaseRule\n\tclass Array(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return isinstance(value, List)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not an array\"\n"]}
{"filename": "checkr/rules/Integer.py", "chunked_list": ["from typing import Any\n\tfrom .BaseRule import BaseRule\n\tclass Integer(BaseRule):\n\t    def validate(self, attribute: str, value: Any) -> bool:\n\t        return isinstance(value, int)\n\t    def message(self, attribute: str) -> str:\n\t        return f\"{attribute} is not an integer\"\n"]}
