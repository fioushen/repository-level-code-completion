{"filename": "noxfile.py", "chunked_list": ["import nox\n\t@nox.session(python=[\"3.11\", \"3.10\"])\n\tdef tests(session):\n\t    session.install(\"pytest\", \".\")\n\t    session.run(\"pytest\")\n\t@nox.session(python=[\"3.11\", \"3.10\"])\n\tdef lint(session):\n\t    session.install(\"flake8\", \".\")\n\t    session.run(\"flake8\", \"blurry\", \"tests\")\n\t@nox.session(python=[\"3.11\", \"3.10\"])\n", "def typecheck(session):\n\t    session.install(\"pyright\", \".\")\n\t    session.run(\"pyright\")\n"]}
{"filename": "blurry/sitemap.py", "chunked_list": ["from pathlib import Path\n\tfrom blurry.settings import get_build_directory\n\tfrom blurry.types import MarkdownFileData\n\tSITEMAP_TEMPLATE = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<urlset\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9\n\t    http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\"\n\t    xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n\t>\n", "{urls}\n\t</urlset>\n\t\"\"\".strip()\n\tURL_TEMPLATE = \"    <url><loc>{url}</loc><lastmod>{lastmod}</lastmod></url>\"\n\tdef generate_sitemap_for_file_data_list(file_data_list: list[MarkdownFileData]) -> str:\n\t    sitemap_url_data = []\n\t    for file_data in file_data_list:\n\t        lastmod = file_data.front_matter.get(\n\t            \"dateModified\"\n\t        ) or file_data.front_matter.get(\"datePublished\")\n", "        url = file_data.front_matter.get(\"url\")\n\t        sitemap_url_data.append({\"lastmod\": lastmod, \"url\": url})\n\t    sitemap_url_content = \"\\n\".join(\n\t        URL_TEMPLATE.format(url=data[\"url\"], lastmod=data[\"lastmod\"])\n\t        for data in sitemap_url_data\n\t    )\n\t    return SITEMAP_TEMPLATE.format(urls=sitemap_url_content)\n\tasync def write_sitemap_file(\n\t    file_data_by_directory: dict[Path, list[MarkdownFileData]]\n\t):\n", "    BUILD_DIR = get_build_directory()\n\t    file_data = []\n\t    for file_data_list in file_data_by_directory.values():\n\t        file_data.extend(file_data_list)\n\t    sitemap = generate_sitemap_for_file_data_list(file_data)\n\t    sitemap_path = BUILD_DIR / \"sitemap.xml\"\n\t    sitemap_path.write_text(sitemap)\n"]}
{"filename": "blurry/images.py", "chunked_list": ["import asyncio\n\tfrom pathlib import Path\n\tfrom typing import Coroutine\n\tfrom typing import Optional\n\tfrom wand.image import Image\n\tfrom blurry.settings import get_build_directory\n\tfrom blurry.settings import get_content_directory\n\tfrom blurry.settings import SETTINGS\n\tCONTENT_DIR = get_content_directory()\n\tAVIF_COMPRESSION_QUALITY = SETTINGS[\"AVIF_COMPRESSION_QUALITY\"]\n", "IMAGE_WIDTHS = SETTINGS[\"IMAGE_WIDTHS\"]\n\tMAXIMUM_IMAGE_WIDTH = int(SETTINGS[\"MAXIMUM_IMAGE_WIDTH\"])\n\tTHUMBNAIL_WIDTH = int(SETTINGS[\"THUMBNAIL_WIDTH\"])\n\tTARGET_IMAGE_WIDTHS = [w for w in IMAGE_WIDTHS if w < MAXIMUM_IMAGE_WIDTH]\n\tTARGET_IMAGE_WIDTHS.append(MAXIMUM_IMAGE_WIDTH)\n\tif THUMBNAIL_WIDTH not in TARGET_IMAGE_WIDTHS:\n\t    TARGET_IMAGE_WIDTHS.append(THUMBNAIL_WIDTH)\n\tTARGET_IMAGE_WIDTHS.sort()\n\tdef add_image_width_to_path(image_path: Path, width: int) -> Path:\n\t    new_filename = str(image_path).replace(\n", "        image_path.suffix, f\"-{width}{image_path.suffix}\"\n\t    )\n\t    return Path(new_filename)\n\tasync def convert_image_to_avif(image_path: Path, target_path: Optional[Path] = None):\n\t    image_suffix = image_path.suffix\n\t    if image_suffix in [\".webp\", \".gif\"]:\n\t        return\n\t    avif_filepath = str(target_path or image_path).replace(image_suffix, \".avif\")\n\t    if Path(avif_filepath).exists():\n\t        return\n", "    with Image(filename=str(image_path)) as image:\n\t        image.format = \"avif\"\n\t        image.compression_quality = AVIF_COMPRESSION_QUALITY\n\t        image.save(filename=avif_filepath)\n\tasync def generate_images_for_srcset(image_path: Path):\n\t    BUILD_DIR = get_build_directory()\n\t    tasks: list[Coroutine] = []\n\t    if image_path.suffix in [\".webp\", \".gif\"]:\n\t        return\n\t    with Image(filename=str(image_path)) as img:\n", "        width = img.width\n\t        # Convert original image\n\t        build_path = BUILD_DIR / image_path.resolve().relative_to(CONTENT_DIR)\n\t        await convert_image_to_avif(image_path=image_path, target_path=build_path)\n\t        for target_width in get_widths_for_image_width(width):\n\t            new_filepath = add_image_width_to_path(image_path, target_width)\n\t            relative_filepath = new_filepath.resolve().relative_to(CONTENT_DIR)\n\t            build_filepath = BUILD_DIR / relative_filepath\n\t            if build_filepath.exists():\n\t                continue\n", "            with img.clone() as resized:\n\t                resized.transform(resize=str(target_width))\n\t                resized.save(filename=build_filepath)\n\t                tasks.append(convert_image_to_avif(build_filepath))\n\t        await asyncio.gather(*tasks)\n\tdef get_widths_for_image_width(image_width: int) -> list[int]:\n\t    widths = [tw for tw in TARGET_IMAGE_WIDTHS if tw < image_width]\n\t    if image_width < TARGET_IMAGE_WIDTHS[-1]:\n\t        widths.append(image_width)\n\t    return widths\n", "def generate_srcset_string(image_path: str, image_widths: list[int]) -> str:\n\t    srcset_entries = [\n\t        f\"{add_image_width_to_path(Path(image_path), w)} {w}w\" for w in image_widths\n\t    ]\n\t    return \", \".join(srcset_entries)\n\tdef generate_sizes_string(image_widths: list[int]) -> str:\n\t    if not image_widths:\n\t        return \"\"\n\t    # Ensure widths are in ascending order\n\t    image_widths.sort()\n", "    size_strings = []\n\t    for width in image_widths[0:-1]:\n\t        size_strings.append(f\"(max-width: {width}px) {width}px\")\n\t    largest_width = image_widths[-1]\n\t    size_strings.append(f\"{largest_width}px\")\n\t    return \", \".join(size_strings)\n"]}
{"filename": "blurry/settings.py", "chunked_list": ["from os import environ\n\tfrom typing import TypedDict\n\timport toml\n\tfrom blurry.constants import CURR_DIR\n\tfrom blurry.constants import ENV_VAR_PREFIX\n\tclass Settings(TypedDict):\n\t    AVIF_COMPRESSION_QUALITY: int\n\t    BUILD_DIRECTORY_NAME: str\n\t    CONTENT_DIRECTORY_NAME: str\n\t    TEMPLATES_DIRECTORY_NAME: str\n", "    TEMPLATE_SCHEMA_TYPES: dict[str, str]\n\t    DEV_HOST: str\n\t    DEV_PORT: int\n\t    DOMAIN: str\n\t    IMAGE_WIDTHS: list[int]\n\t    MAXIMUM_IMAGE_WIDTH: int\n\t    THUMBNAIL_WIDTH: int\n\t    VIDEO_EXTENSIONS: list[str]\n\t    USE_HTTP: bool\n\t    RUNSERVER: bool\n", "    FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX: str\n\tSETTINGS: Settings = {\n\t    \"AVIF_COMPRESSION_QUALITY\": 90,\n\t    \"BUILD_DIRECTORY_NAME\": \"dist\",\n\t    \"CONTENT_DIRECTORY_NAME\": \"content\",\n\t    \"TEMPLATES_DIRECTORY_NAME\": \"templates\",\n\t    \"DEV_HOST\": \"127.0.0.1\",\n\t    \"DEV_PORT\": 8000,\n\t    \"DOMAIN\": \"example.com\",\n\t    # Sizes adapted from: https://link.medium.com/UqzDeLKwyeb\n", "    \"IMAGE_WIDTHS\": [360, 640, 768, 1024, 1366, 1600, 1920],\n\t    \"MAXIMUM_IMAGE_WIDTH\": 1920,\n\t    \"THUMBNAIL_WIDTH\": 250,\n\t    \"VIDEO_EXTENSIONS\": [\"mp4\", \"webm\", \"mkv\"],\n\t    \"USE_HTTP\": False,\n\t    \"RUNSERVER\": False,\n\t    \"FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX\": \"~\",\n\t    \"TEMPLATE_SCHEMA_TYPES\": {},\n\t}\n\ttry:\n", "    blurry_config = toml.load(open(\"blurry.toml\"))\n\t    user_settings = blurry_config[\"blurry\"]\n\t    for setting, value in user_settings.items():\n\t        SETTINGS[setting.upper()] = value\n\texcept FileNotFoundError:\n\t    pass\n\tfor key, value in environ.items():\n\t    if not key.startswith(ENV_VAR_PREFIX):\n\t        continue\n\t    setting_name_start_index = len(ENV_VAR_PREFIX) - 1\n", "    settings_key = key[setting_name_start_index:]\n\t    SETTINGS[settings_key] = value\n\tdef get_build_directory():\n\t    is_dev_build = environ.get(f\"{ENV_VAR_PREFIX}BUILD_MODE\") == \"dev\"\n\t    if is_dev_build:\n\t        return CURR_DIR / \".blurry\" / SETTINGS[\"BUILD_DIRECTORY_NAME\"]\n\t    return CURR_DIR / SETTINGS[\"BUILD_DIRECTORY_NAME\"]\n\tdef get_content_directory():\n\t    return CURR_DIR / SETTINGS[\"CONTENT_DIRECTORY_NAME\"]\n\tdef get_templates_directory():\n", "    return CURR_DIR / SETTINGS[\"TEMPLATES_DIRECTORY_NAME\"]\n"]}
{"filename": "blurry/__main__.py", "chunked_list": ["from __future__ import absolute_import\n\tfrom blurry import main\n\tmain()\n"]}
{"filename": "blurry/types.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom enum import Enum\n\tfrom pathlib import Path\n\tfrom typing import Any\n\tfrom typing import TypeGuard\n\t@dataclass\n\tclass MarkdownFileData:\n\t    body: str\n\t    front_matter: dict[str, Any]\n\t    path: Path\n", "class SchemaType(Enum):\n\t    ARTICLE = \"Article\"\n\t    BLOG_POSTING = \"BlogPosting\"\n\t    NEWS_ARTICLE = \"NewsArticle\"\n\t    TECH_ARTICLE = \"TechArticle\"\n\t    BOOK = \"Book\"\n\t    AUDIOBOOK = \"Audiobook\"\n\t    LOCAL_BUSINESS = \"LocalBusiness\"\n\t    NEWS_MEDIA_ORGANIZATION = \"NewsMediaOrganization\"\n\t    ORGANIZATION = \"Organization\"\n", "    PERSON = \"Person\"\n\tDirectoryFileData = dict[Path, list[MarkdownFileData]]\n\tTemplateContext = dict[str, Any]\n\tdef is_str(value: Any) -> TypeGuard[str]:\n\t    if isinstance(value, str):\n\t        return True\n\t    return False\n"]}
{"filename": "blurry/async_typer.py", "chunked_list": ["import asyncio\n\tfrom functools import wraps\n\tfrom typer import Typer\n\tclass AsyncTyper(Typer):\n\t    def async_command(self, *args, **kwargs):\n\t        def decorator(async_func):\n\t            # Convert async function to synchronous\n\t            @wraps(async_func)\n\t            def sync_func(*_args, **_kwargs):\n\t                return asyncio.run(async_func(*_args, **_kwargs))\n", "            # Register synchronous function\n\t            self.command(*args, **kwargs)(sync_func)\n\t            return async_func\n\t        return decorator\n"]}
{"filename": "blurry/__init__.py", "chunked_list": ["import asyncio\n\timport dataclasses\n\timport json\n\timport os\n\timport shutil\n\tfrom datetime import datetime\n\tfrom mimetypes import guess_type\n\tfrom mimetypes import types_map\n\tfrom pathlib import Path\n\tfrom typing import Any\n", "from typing import Coroutine\n\tfrom jinja2 import Environment\n\tfrom jinja2 import FileSystemLoader\n\tfrom jinja2 import select_autoescape\n\tfrom livereload import Server\n\tfrom rich import print\n\tfrom blurry.async_typer import AsyncTyper\n\tfrom blurry.constants import ENV_VAR_PREFIX\n\tfrom blurry.images import generate_images_for_srcset\n\tfrom blurry.markdown import convert_markdown_file_to_html\n", "from blurry.open_graph import open_graph_meta_tags\n\tfrom blurry.plugins import discovered_html_plugins\n\tfrom blurry.plugins import discovered_markdown_plugins\n\tfrom blurry.settings import get_build_directory\n\tfrom blurry.settings import get_content_directory\n\tfrom blurry.settings import get_templates_directory\n\tfrom blurry.settings import SETTINGS\n\tfrom blurry.sitemap import write_sitemap_file\n\tfrom blurry.types import DirectoryFileData\n\tfrom blurry.types import MarkdownFileData\n", "from blurry.types import TemplateContext\n\tfrom blurry.utils import content_path_to_url\n\tfrom blurry.utils import convert_content_path_to_directory_in_build\n\tfrom blurry.utils import format_schema_data\n\tfrom blurry.utils import sort_directory_file_data_by_date\n\tfrom blurry.utils import write_index_file_creating_path\n\tdef json_converter_with_dates(item: Any) -> None | str:\n\t    if isinstance(item, datetime):\n\t        return item.strftime(\"%Y-%M-%D\")\n\tprint(\"Markdown plugins:\", [p.name for p in discovered_markdown_plugins])\n", "print(\"HTML plugins:\", [p.name for p in discovered_html_plugins])\n\tCONTENT_DIR = get_content_directory()\n\tTEMPLATE_DIR = get_templates_directory()\n\tapp = AsyncTyper()\n\tjinja_env = Environment(\n\t    loader=FileSystemLoader(TEMPLATE_DIR), autoescape=select_autoescape([\"html\", \"xml\"])\n\t)\n\tasync def process_non_markdown_file(filepath: Path):\n\t    mimetype, _ = guess_type(filepath, strict=False)\n\t    relative_filepath = filepath.relative_to(CONTENT_DIR)\n", "    build_filepath = get_build_directory() / relative_filepath\n\t    output_file = Path(build_filepath)\n\t    output_file.parent.mkdir(exist_ok=True, parents=True)\n\t    # Copy file to build directory\n\t    shutil.copyfile(filepath, build_filepath)\n\t    # Create srcset images\n\t    if mimetype in [types_map[\".jpg\"], types_map[\".png\"]]:\n\t        await generate_images_for_srcset(filepath)\n\tasync def write_html_file(\n\t    file_data: MarkdownFileData,\n", "    file_data_list: list[MarkdownFileData],\n\t    file_data_by_directory: dict[Path, list[MarkdownFileData]],\n\t    release: bool,\n\t):\n\t    extra_context: TemplateContext = {}\n\t    # Gather data from other files in this directory if this is an index file\n\t    if file_data.path.name == \"index.md\":\n\t        sibling_pages = [\n\t            {\n\t                \"url\": content_path_to_url(f.path),\n", "                **f.front_matter,\n\t            }\n\t            for f in file_data_list\n\t            if f.path != file_data.path\n\t        ]\n\t        extra_context[\"sibling_pages\"] = sibling_pages\n\t    folder_in_build = convert_content_path_to_directory_in_build(file_data.path)\n\t    schema_type = file_data.front_matter.get(\"@type\")\n\t    if not schema_type:\n\t        raise ValueError(\n", "            f\"Required @type value missing in file or TOML front matter invalid: \"\n\t            f\"{file_data.path}\"\n\t        )\n\t    template = jinja_env.get_template(f\"{schema_type}.html\")\n\t    # Map custom template name to Schema.org type\n\t    if mapped_schema_type := SETTINGS[\"TEMPLATE_SCHEMA_TYPES\"].get(schema_type):\n\t        file_data.front_matter[\"@type\"] = mapped_schema_type\n\t    # Include non-schema variables as top-level context values, removing them from\n\t    # front_matter\n\t    front_matter = file_data.front_matter\n", "    schema_variables: TemplateContext = {}\n\t    template_context: TemplateContext = {}\n\t    non_schema_variable_prefix = SETTINGS[\"FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX\"]\n\t    for key, value in front_matter.items():\n\t        if key.startswith(non_schema_variable_prefix):\n\t            template_context[key.replace(non_schema_variable_prefix, \"\", 1)] = value\n\t            continue\n\t        schema_variables[key] = value\n\t    schema_data = json.dumps(\n\t        format_schema_data(schema_variables),\n", "        default=json_converter_with_dates,\n\t    )\n\t    schema_type_tag = f'<script type=\"application/ld+json\">{schema_data}</script>'\n\t    template_context = {\n\t        \"body\": file_data.body,\n\t        \"schema_data\": schema_data,\n\t        \"schema_type_tag\": schema_type_tag,\n\t        \"open_graph_tags\": open_graph_meta_tags(file_data.front_matter),\n\t        \"build_path\": folder_in_build,\n\t        \"file_data_by_directory\": {\n", "            str(path): data for path, data in file_data_by_directory.items()\n\t        },\n\t        \"settings\": SETTINGS,\n\t        **schema_variables,\n\t        **extra_context,\n\t        **template_context,\n\t    }\n\t    html = template.render(dataclasses=dataclasses, **template_context)\n\t    for html_plugin in discovered_html_plugins:\n\t        try:\n", "            html = html_plugin.load()(html, template_context, release)\n\t        except Exception as err:\n\t            print(f\"Error initializing plugin {html_plugin}: {err}\")\n\t    # Write file\n\t    write_index_file_creating_path(folder_in_build, html)\n\t@app.async_command()\n\tasync def build(release=True):\n\t    \"\"\"Generates HTML content from Markdown files.\"\"\"\n\t    os.environ.setdefault(f\"{ENV_VAR_PREFIX}BUILD_MODE\", \"prod\" if release else \"dev\")\n\t    build_dir = get_build_directory()\n", "    start = datetime.now()\n\t    path = Path(CONTENT_DIR)\n\t    file_data_by_directory: DirectoryFileData = {}\n\t    if not build_dir.exists():\n\t        build_dir.mkdir(parents=True)\n\t    markdown_tasks: list[Coroutine] = []\n\t    non_markdown_tasks: list[Coroutine] = []\n\t    for filepath in path.glob(\"**/*.*\"):\n\t        # Handle images and other files\n\t        if filepath.suffix != \".md\":\n", "            non_markdown_tasks.append(process_non_markdown_file(filepath))\n\t            continue\n\t        # Handle Markdown files\n\t        # Extract filepath for storing context data and writing out\n\t        relative_filepath = filepath.relative_to(CONTENT_DIR)\n\t        directory = relative_filepath.parent\n\t        if directory not in file_data_by_directory:\n\t            file_data_by_directory[directory] = []\n\t        # Convert Markdown file to HTML\n\t        body, front_matter = convert_markdown_file_to_html(filepath)\n", "        file_data = MarkdownFileData(\n\t            body=body,\n\t            front_matter=front_matter,\n\t            path=relative_filepath,\n\t        )\n\t        file_data_by_directory[directory].append(file_data)\n\t    non_markdown_tasks.append(write_sitemap_file(file_data_by_directory))\n\t    # Sort file data by publishedDate/createdDate, descending, if present\n\t    file_data_by_directory = sort_directory_file_data_by_date(file_data_by_directory)\n\t    for file_data_list in file_data_by_directory.values():\n", "        for file_data in file_data_list:\n\t            markdown_tasks.append(\n\t                write_html_file(\n\t                    file_data, file_data_list, file_data_by_directory, release\n\t                )\n\t            )\n\t    task_count = len(markdown_tasks) + len(non_markdown_tasks)\n\t    print(f\"Gathered {task_count} tasks\")\n\t    await asyncio.gather(*markdown_tasks)\n\t    await asyncio.gather(*non_markdown_tasks)\n", "    end = datetime.now()\n\t    difference = end - start\n\t    print(f\"Built site in {difference.total_seconds()} seconds\")\n\tasync def build_development():\n\t    await build(release=False)\n\t@app.command()\n\tdef runserver():\n\t    \"\"\"Starts HTTP server with live reloading.\"\"\"\n\t    os.environ.setdefault(f\"{ENV_VAR_PREFIX}BUILD_MODE\", \"dev\")\n\t    SETTINGS[\"RUNSERVER\"] = True\n", "    event_loop = asyncio.get_event_loop()\n\t    event_loop.create_task(build_development())\n\t    livereload_server = Server()\n\t    livereload_server.watch(\n\t        \"content/**/*\", lambda: event_loop.create_task(build_development())\n\t    )\n\t    livereload_server.watch(\n\t        \"templates/**/*\", lambda: event_loop.create_task(build_development())\n\t    )\n\t    livereload_server.serve(\n", "        host=SETTINGS[\"DEV_HOST\"], port=SETTINGS[\"DEV_PORT\"], root=get_build_directory()\n\t    )\n\tdef main():\n\t    app()\n"]}
{"filename": "blurry/utils.py", "chunked_list": ["from pathlib import Path\n\tfrom selectolax.parser import HTMLParser\n\tfrom blurry.settings import get_build_directory\n\tfrom blurry.settings import get_content_directory\n\tfrom blurry.settings import SETTINGS\n\tfrom blurry.types import DirectoryFileData\n\tCONTENT_DIR = get_content_directory()\n\tdef get_domain_with_scheme():\n\t    if SETTINGS.get(\"RUNSERVER\"):\n\t        host = SETTINGS[\"DEV_HOST\"]\n", "        port = SETTINGS[\"DEV_PORT\"]\n\t        return f\"http://{host}:{port}\"\n\t    domain = SETTINGS[\"DOMAIN\"]\n\t    protocol = \"http\" if SETTINGS.get(\"USE_HTTP\") else \"https\"\n\t    return f\"{protocol}://{domain}\"\n\tdef convert_content_path_to_directory_in_build(path: Path) -> Path:\n\t    BUILD_DIR = get_build_directory()\n\t    if path.name == \"index.md\":\n\t        path = path.parent\n\t    else:\n", "        path = path.with_suffix(\"\")\n\t    return BUILD_DIR.joinpath(path)\n\tdef convert_relative_path_in_markdown_to_relative_build_path(relative_path: str) -> str:\n\t    if relative_path.startswith(\"./\"):\n\t        relative_path = relative_path[2:]\n\t    if relative_path.endswith(\"index.md\"):\n\t        relative_path = relative_path.replace(\"index.md\", \"\")\n\t    elif relative_path.endswith(\".md\"):\n\t        relative_path = relative_path.replace(\".md\", \"\") + \"/\"\n\t    return f\"../{relative_path}\"\n", "def resolve_relative_path_in_markdown(relative_path: str, markdown_file: Path) -> Path:\n\t    \"\"\"Converts a relative path in Markdown to an absolute path.\"\"\"\n\t    parent = markdown_file.parent\n\t    path = parent / Path(relative_path)\n\t    return path.resolve()\n\tdef path_to_url_pathname(path: Path) -> str:\n\t    url_pathname = \"/\" + str(path.relative_to(CONTENT_DIR))\n\t    return url_pathname\n\tdef write_index_file_creating_path(directory_path: Path, content: str):\n\t    directory_path.mkdir(parents=True, exist_ok=True)\n", "    filepath = directory_path.joinpath(\"index.html\")\n\t    filepath.write_text(content)\n\tdef content_path_to_url(path: Path) -> str:\n\t    BUILD_DIR = get_build_directory()\n\t    if path.suffix == \".md\":\n\t        build_directory = convert_content_path_to_directory_in_build(path)\n\t        relative_directory = build_directory.relative_to(BUILD_DIR)\n\t        # Handle root page\n\t        if str(relative_directory) == \".\":\n\t            return f\"{get_domain_with_scheme()}/\"\n", "        return f\"{get_domain_with_scheme()}/{relative_directory}/\"\n\t    return f\"{get_domain_with_scheme()}{path_to_url_pathname(path)}\"\n\tdef build_path_to_url(path: Path) -> str:\n\t    BUILD_DIR = get_build_directory()\n\t    pathname = \"/\" + str(path.relative_to(BUILD_DIR))\n\t    return f\"{get_domain_with_scheme()}{pathname}\"\n\tdef sort_directory_file_data_by_date(\n\t    directory_file_data: DirectoryFileData,\n\t) -> DirectoryFileData:\n\t    for path, file_data in directory_file_data.items():\n", "        file_data.sort(\n\t            key=lambda page: str(page.front_matter.get(\"datePublished\", \"\"))\n\t            or str(page.front_matter.get(\"dateCreated\", \"\"))\n\t            or \"0000-00-00\",\n\t            reverse=True,\n\t        )\n\t        directory_file_data[path] = file_data\n\t    return directory_file_data\n\tdef format_schema_data(schema_data: dict) -> dict:\n\t    formatted_schema_data = {\"@context\": \"https://schema.org\"}\n", "    formatted_schema_data.update(schema_data)\n\t    return formatted_schema_data\n\tdef remove_lazy_loading_from_first_image(html: str) -> str:\n\t    parser = HTMLParser(html, use_meta_tags=False)\n\t    first_img_tag = parser.css_first(\"img\")\n\t    if not first_img_tag:\n\t        return html\n\t    updated_tag = first_img_tag\n\t    del updated_tag.attrs[\"loading\"]  # type: ignore\n\t    first_img_tag.replace_with(HTMLParser(updated_tag.html).body.child)  # type: ignore\n", "    if not parser.body or not parser.body.html:\n\t        raise Exception(\"Could not parse HTML\")\n\t    return parser.body.html\n"]}
{"filename": "blurry/constants.py", "chunked_list": ["from pathlib import Path\n\tENV_VAR_PREFIX = \"BLURRY_\"\n\tCURR_DIR = Path.cwd()\n"]}
{"filename": "blurry/open_graph.py", "chunked_list": ["from typing import Any\n\tfrom typing import Literal\n\tfrom blurry.types import SchemaType\n\tMETA_TAG_TEMPLATE = '<meta property=\"og:{property}\" content=\"{content}\" />'\n\tOpenGraphType = Literal[\"article\", \"book\", \"profile\", \"website\"]\n\tschema_type_to_open_graph_type: dict[SchemaType, OpenGraphType] = {\n\t    SchemaType.ARTICLE: \"article\",\n\t    SchemaType.BLOG_POSTING: \"article\",\n\t    SchemaType.NEWS_ARTICLE: \"article\",\n\t    SchemaType.TECH_ARTICLE: \"article\",\n", "    SchemaType.BOOK: \"book\",\n\t    SchemaType.AUDIOBOOK: \"book\",\n\t    SchemaType.LOCAL_BUSINESS: \"profile\",\n\t    SchemaType.NEWS_MEDIA_ORGANIZATION: \"profile\",\n\t    SchemaType.ORGANIZATION: \"profile\",\n\t    SchemaType.PERSON: \"profile\",\n\t}\n\tdef open_graph_type_from_schema_type(schema_type_str: str) -> OpenGraphType:\n\t    try:\n\t        return schema_type_to_open_graph_type[SchemaType(schema_type_str)]\n", "    except ValueError:\n\t        return \"website\"\n\tdef open_graph_meta_tags(schema_data: dict[str, Any]) -> str:\n\t    open_graph_properties = {}\n\t    if type := schema_data.get(\"@type\"):\n\t        open_graph_properties[\"type\"] = open_graph_type_from_schema_type(type)\n\t    if headline := schema_data.get(\"headline\"):\n\t        open_graph_properties[\"title\"] = headline\n\t    if url := schema_data.get(\"url\"):\n\t        open_graph_properties[\"url\"] = url\n", "    if abstract := schema_data.get(\"abstract\"):\n\t        open_graph_properties[\"description\"] = abstract\n\t    if image := schema_data.get(\"image\"):\n\t        open_graph_properties[\"image\"] = image\n\t    if audio := schema_data.get(\"audio\"):\n\t        open_graph_properties[\"audio\"] = audio\n\t    if organization := schema_data.get(\"sourceOrganization\"):\n\t        if site_name := organization.get(\"name\"):\n\t            open_graph_properties[\"site_name\"] = site_name\n\t    if video := schema_data.get(\"video\"):\n", "        open_graph_properties[\"video\"] = video\n\t    return \"\\n\".join(\n\t        META_TAG_TEMPLATE.format(property=property, content=content)\n\t        for property, content in open_graph_properties.items()\n\t    )\n"]}
{"filename": "blurry/plugins/__init__.py", "chunked_list": ["from importlib.metadata import entry_points\n\tdiscovered_markdown_plugins = entry_points(group=\"blurry.markdown_plugins\")\n\tdiscovered_html_plugins = entry_points(group=\"blurry.html_plugins\")\n"]}
{"filename": "blurry/plugins/html_plugins/minify_html_plugin.py", "chunked_list": ["import re\n\timport htmlmin\n\tfrom selectolax.parser import HTMLParser\n\tfrom blurry.types import TemplateContext\n\tdef minify_css(css: str) -> str:\n\t    minified_css = css.strip()\n\t    characters_around_which_to_remove_whitespace = [\"}\", \"{\", \":\", \";\", \",\"]\n\t    for character in characters_around_which_to_remove_whitespace:\n\t        minified_css = re.sub(\n\t            rf\"\\s*{character}\\s*\", character, minified_css, flags=re.M\n", "        )\n\t    return minified_css\n\tdef minify_style_tags(html: str) -> str:\n\t    parser = HTMLParser(html, use_meta_tags=False)\n\t    style_tags = parser.css(\"style\")\n\t    for style_tag in style_tags:\n\t        css = style_tag.text()\n\t        minified_css = minify_css(css)\n\t        minified_style_tag = HTMLParser(\n\t            f\"<style>{minified_css}</style>\"\n", "        ).head.child  # type: ignore\n\t        style_tag.replace_with(minified_style_tag)  # type: ignore\n\t    return parser.html or html\n\tdef minify_html(html: str, _: TemplateContext, release: bool) -> str:\n\t    if release:\n\t        # Minify HTML and CSS\n\t        html = htmlmin.minify(html, remove_empty_space=True)\n\t        html = minify_style_tags(html)\n\t    return html\n"]}
{"filename": "blurry/plugins/html_plugins/__init__.py", "chunked_list": []}
{"filename": "blurry/plugins/markdown_plugins/python_code_plugin.py", "chunked_list": ["import importlib\n\timport inspect\n\timport re\n\tfrom mistune import BlockParser\n\tfrom mistune import BlockState\n\tfrom mistune import Markdown\n\tPYTHON_CODE_PATTERN = r\"[\\s]*@(?P<language>[a-z]+)<(?P<path>.+)>\"\n\tdef parse_python_code(_: BlockParser, match: re.Match, state: BlockState):\n\t    language = match.group(\"language\")\n\t    path = match.group(\"path\")\n", "    state.append_token(\n\t        {\n\t            \"type\": \"python_code\",\n\t            \"attrs\": {\"language\": language, \"path\": path},\n\t        }\n\t    )\n\t    return match.end() + 1\n\tdef render_python_code(_, language: str, path: str):\n\t    module, _, reference_name = path.rpartition(\".\")\n\t    module = importlib.import_module(module)\n", "    try:\n\t        # If path references a variable within a module\n\t        reference = getattr(module, reference_name)\n\t    except AttributeError:\n\t        # If path references a module\n\t        reference = importlib.import_module(path)\n\t    reference_source = inspect.getsource(reference)\n\t    return f'<pre><code class=\"language-{language}\">{reference_source}</code></pre>'\n\tdef python_code(md: Markdown):\n\t    \"\"\"A mistune plugin to insert Python code.\"\"\"\n", "    md.block.register(\n\t        \"python_code\", PYTHON_CODE_PATTERN, parse_python_code, before=\"list\"\n\t    )\n\t    if md.renderer and md.renderer.NAME == \"html\":\n\t        md.renderer.register(\"python_code\", render_python_code)\n\tdef python_code_in_list(md: Markdown):\n\t    \"\"\"Enable Python code plugin in list.\"\"\"\n\t    md.block.insert_rule(md.block.list_rules, \"python_code\", before=\"list\")\n"]}
{"filename": "blurry/plugins/markdown_plugins/container_plugin.py", "chunked_list": ["from mistune.directives import Admonition\n\tfrom mistune.directives import FencedDirective\n\tfrom mistune.directives.admonition import render_admonition_content\n\tclass Container(Admonition):\n\t    \"\"\"Custom admonition directive using an <aside> HTML element\"\"\"\n\t    SUPPORTED_NAMES = {\n\t        \"attention\",\n\t        \"caution\",\n\t        \"danger\",\n\t        \"error\",\n", "        \"hint\",\n\t        \"important\",\n\t        \"info\",\n\t        \"note\",\n\t        \"tip\",\n\t        \"warning\",\n\t    }\n\t    def __call__(self, directive, md):\n\t        for name in self.SUPPORTED_NAMES:\n\t            directive.register(name, self.parse)\n", "        if md.renderer.NAME == \"html\":\n\t            md.renderer.register(\"admonition\", render_admonition)\n\t            md.renderer.register(\"admonition_title\", lambda plugin, text: \"\")\n\t            md.renderer.register(\"admonition_content\", render_admonition_content)\n\tdef render_admonition(self, text, name, **attrs):\n\t    _cls = attrs.get(\"class\", \"\")\n\t    class_attribute = f\"{name} {_cls}\".strip()\n\t    return f'<aside role=\"note\" class=\"{class_attribute}\">{text}</aside>'\n\tcontainer = FencedDirective([Container()], \":\")\n"]}
{"filename": "blurry/plugins/markdown_plugins/__init__.py", "chunked_list": []}
{"filename": "blurry/plugins/markdown_plugins/punctuation_plugin.py", "chunked_list": ["from re import Match\n\tfrom mistune import InlineParser\n\tfrom mistune import InlineState\n\tfrom mistune import Markdown\n\tEM_DASH_PATTERN = r\"---\"\n\tEN_DASH_PATTERN = r\"--\"\n\tdef parse_em_dash(_: InlineParser, match: Match, state: InlineState):\n\t    pos = match.end()\n\t    state.append_token({\"type\": \"text\", \"raw\": \"—\"})\n\t    return pos\n", "def parse_en_dash(_: InlineParser, match: Match, state: InlineState):\n\t    pos = match.end()\n\t    state.append_token({\"type\": \"text\", \"raw\": \"–\"})\n\t    return pos\n\tdef punctuation(md: Markdown):\n\t    md.inline.register(\"punctuation_em_dash\", EM_DASH_PATTERN, parse_em_dash)\n\t    md.inline.register(\"punctuation_en_dash\", EN_DASH_PATTERN, parse_en_dash)\n"]}
{"filename": "blurry/markdown/__init__.py", "chunked_list": ["from pathlib import Path\n\tfrom typing import Any\n\tfrom typing import Type\n\tfrom typing import TypeGuard\n\timport mistune\n\tfrom mistune import BlockState\n\tfrom mistune.plugins.abbr import abbr\n\tfrom mistune.plugins.def_list import def_list\n\tfrom mistune.plugins.footnotes import footnotes\n\tfrom mistune.plugins.formatting import strikethrough\n", "from mistune.plugins.table import table\n\tfrom mistune.plugins.task_lists import task_lists\n\tfrom mistune.plugins.url import url\n\tfrom mistune.util import escape\n\tfrom wand.image import Image\n\tfrom .front_matter import parse_front_matter\n\tfrom .renderer_functions.render_video import render_video\n\tfrom blurry.images import add_image_width_to_path\n\tfrom blurry.images import generate_sizes_string\n\tfrom blurry.images import generate_srcset_string\n", "from blurry.images import get_widths_for_image_width\n\tfrom blurry.plugins import discovered_markdown_plugins\n\tfrom blurry.settings import get_build_directory\n\tfrom blurry.settings import get_content_directory\n\tfrom blurry.settings import SETTINGS\n\tfrom blurry.types import is_str\n\tfrom blurry.utils import build_path_to_url\n\tfrom blurry.utils import content_path_to_url\n\tfrom blurry.utils import convert_relative_path_in_markdown_to_relative_build_path\n\tfrom blurry.utils import path_to_url_pathname\n", "from blurry.utils import remove_lazy_loading_from_first_image\n\tfrom blurry.utils import resolve_relative_path_in_markdown\n\tCONTENT_DIR = get_content_directory()\n\tTHUMBNAIL_WIDTH = SETTINGS.get(\"THUMBNAIL_WIDTH\")\n\tclass BlurryRenderer(mistune.HTMLRenderer):\n\t    \"\"\"Renderer that converts relative content URLs to build URLs.\"\"\"\n\t    filepath: Path\n\t    def image(self, alt, url, title=None) -> str:\n\t        # Improve images:\n\t        # - Converts relative paths to web server paths\n", "        # - Convert to <picture> tag with AVIF <source>\n\t        # - Adds srcset & sizes attributes\n\t        # - Adds width & height attributes\n\t        src = self.safe_url(url)\n\t        attributes: dict[str, str] = {\n\t            \"alt\": alt,\n\t            \"src\": src,\n\t            \"loading\": \"lazy\",\n\t        }\n\t        source_tag = \"\"\n", "        # Make local images responsive\n\t        if src.startswith(\".\"):\n\t            # Convert relative path to URL pathname\n\t            absolute_path = resolve_relative_path_in_markdown(src, self.filepath)\n\t            extension = absolute_path.suffix.removeprefix(\".\")\n\t            src = path_to_url_pathname(absolute_path)\n\t            attributes[\"src\"] = src\n\t            if extension.lower() in SETTINGS.get(\"VIDEO_EXTENSIONS\"):\n\t                return render_video(src, absolute_path, extension, title=alt)\n\t            # Tailor srcset and sizes to image width\n", "            with Image(filename=str(absolute_path)) as img:\n\t                image_width = img.width\n\t                attributes[\"width\"] = image_width\n\t                attributes[\"height\"] = img.height\n\t            if extension in [\"webp\", \"gif\"]:\n\t                source_tag = \"\"\n\t            else:\n\t                image_widths = get_widths_for_image_width(image_width)\n\t                attributes[\"sizes\"] = generate_sizes_string(image_widths)\n\t                attributes[\"srcset\"] = generate_srcset_string(src, image_widths)\n", "                avif_srcset = generate_srcset_string(\n\t                    src.replace(extension, \"avif\"), image_widths\n\t                )\n\t                source_tag = '<source srcset=\"{}\" sizes=\"{}\" />'.format(\n\t                    avif_srcset, attributes[\"sizes\"]\n\t                )\n\t        attributes_str = \" \".join(\n\t            f'{name}=\"{value}\"' for name, value in attributes.items()\n\t        )\n\t        return (\n", "            f\"<figure>\"\n\t            f\"<picture>{source_tag}<img {attributes_str} /></picture>\"\n\t            f'<figcaption>{attributes[\"alt\"]}</figcaption>'\n\t            f\"</figure>\"\n\t        )\n\t    def link(self, text, url, title: str | None = None) -> str:\n\t        link_is_relative = url.startswith(\".\")\n\t        if link_is_relative:\n\t            url = convert_relative_path_in_markdown_to_relative_build_path(url)\n\t        if text is None:\n", "            text = url\n\t        attrs = {\n\t            \"href\": self.safe_url(url),\n\t        }\n\t        if title:\n\t            attrs[\"title\"] = escape(title)\n\t        if not link_is_relative:\n\t            attrs[\"target\"] = \"_blank\"\n\t            attrs[\"rel\"] = \"noopener\"\n\t        attrs_string = \" \".join(\n", "            f'{attribute}=\"{value}\"' for attribute, value in attrs.items()\n\t        )\n\t        return f\"<a {attrs_string}>{text}</a>\"\n\tdef is_blurry_renderer(\n\t    renderer: mistune.HTMLRenderer,\n\t) -> TypeGuard[Type[BlurryRenderer]]:\n\t    return isinstance(renderer, BlurryRenderer)\n\trenderer = BlurryRenderer(escape=False)\n\tmarkdown = mistune.Markdown(\n\t    renderer,\n", "    plugins=[\n\t        abbr,\n\t        def_list,\n\t        footnotes,\n\t        strikethrough,\n\t        table,\n\t        task_lists,\n\t        url,\n\t    ]\n\t    + [plugin.load() for plugin in discovered_markdown_plugins],\n", ")\n\tdef convert_markdown_file_to_html(filepath: Path) -> tuple[str, dict[str, Any]]:\n\t    if not markdown.renderer:\n\t        raise Exception(\"Blurry markdown renderer not set on Mistune Markdown instance\")\n\t    BUILD_DIR = get_build_directory()\n\t    # Add filepath to the renderer to resolve relative paths\n\t    if not is_blurry_renderer(markdown.renderer):\n\t        raise Exception(\n\t            f\"Markdown renderer is not BlurryRenderer {repr(markdown.renderer)}\"\n\t        )\n", "    markdown.renderer.filepath = filepath\n\t    initial_state = BlockState()\n\t    initial_state.env[\"__file__\"] = str(filepath)  # type: ignore\n\t    markdown_text, state = parse_front_matter(markdown, state=initial_state)\n\t    html, state = markdown.parse(markdown_text, state=state)\n\t    if not is_str(html):\n\t        raise Exception(f\"Expected html to be a string but got: {type(html)}\")\n\t    # Post-process HTML\n\t    html = remove_lazy_loading_from_first_image(html)\n\t    # Seed front_matter with schema_data from config file\n", "    front_matter: dict[str, Any] = dict(SETTINGS.get(\"SCHEMA_DATA\", {}))\n\t    front_matter.update(state.env.get(\"front_matter\", {}))\n\t    # Add inferred/computed/relative values\n\t    front_matter.update({\"url\": content_path_to_url(filepath.relative_to(CONTENT_DIR))})\n\t    if image := front_matter.get(\"image\"):\n\t        image_path = filepath.parent / Path(image)\n\t        front_matter[\"image\"] = content_path_to_url(image_path)\n\t        # Add thumbnail URL, using the full image if the thumbnail doesn't exist\n\t        thumbnail_image_path = add_image_width_to_path(image_path, THUMBNAIL_WIDTH)\n\t        thumbnail_image_build_path = BUILD_DIR / thumbnail_image_path.relative_to(\n", "            CONTENT_DIR\n\t        )\n\t        if thumbnail_image_build_path.exists():\n\t            front_matter[\"thumbnailUrl\"] = build_path_to_url(thumbnail_image_build_path)\n\t        else:\n\t            front_matter[\"thumbnailUrl\"] = front_matter[\"image\"]\n\t    return html, front_matter\n"]}
{"filename": "blurry/markdown/front_matter.py", "chunked_list": ["import re\n\tfrom pathlib import Path\n\tfrom typing import Any\n\tfrom typing import MutableMapping\n\tfrom typing import TypeGuard\n\timport toml\n\tfrom mistune import BlockState\n\tfrom mistune import Markdown\n\tTOML_BLOCK_RE = re.compile(\n\t    r\"^\\+{3}[ \\t]*\\n(.*?\\n)(?:\\.{3}|\\+{3})[ \\t]*\\n\", re.UNICODE | re.DOTALL\n", ")\n\tdef is_mapping_with_str_keys(\n\t    val: MutableMapping,\n\t) -> TypeGuard[MutableMapping[str, Any]]:\n\t    return all(isinstance(x, str) for x in val)\n\tdef get_data(doc: str) -> tuple[str, MutableMapping]:\n\t    \"\"\"\n\t    Extract frontmatter from Markdown-style text.\n\t    Code adapted from docdata.yamldata:\n\t    https://github.com/waylan/docdata/blob/master/docdata/yamldata.py\n", "    \"\"\"\n\t    data: MutableMapping[str, Any] = {}\n\t    toml_block_match = TOML_BLOCK_RE.match(doc)\n\t    if toml_block_match:\n\t        try:\n\t            data = toml.loads(toml_block_match.group(1))\n\t            if not is_mapping_with_str_keys(data):\n\t                raise TypeError(\"data is the wrong type\")\n\t            if isinstance(data, dict):\n\t                doc = doc[toml_block_match.end() :].lstrip(\"\\n\")  # noqa: E203\n", "            else:\n\t                data: MutableMapping[str, Any] = {}\n\t        except Exception:\n\t            pass\n\t    return doc, data\n\tdef parse_front_matter(_: Markdown, state: BlockState) -> tuple[str, BlockState]:\n\t    filepath = state.env.get(\"__file__\")\n\t    if not isinstance(filepath, str):\n\t        raise Exception(f\"Count not find filepath {filepath}\")\n\t    file_contents = Path(filepath).read_text()\n", "    markdown_text, front_matter = get_data(file_contents)\n\t    state.env[\"front_matter\"] = front_matter  # type: ignore\n\t    return markdown_text, state\n"]}
{"filename": "blurry/markdown/renderer_functions/__init__.py", "chunked_list": []}
{"filename": "blurry/markdown/renderer_functions/render_video.py", "chunked_list": ["from pathlib import Path\n\timport ffmpeg\n\tfrom mistune.util import escape\n\tdef render_video(src: str, absolute_path: Path, extension: str, title: str | None):\n\t    video_probe_output = ffmpeg.probe(absolute_path)\n\t    video_info = video_probe_output[\"streams\"][0]\n\t    video_width = video_info[\"width\"]\n\t    video_height = video_info[\"height\"]\n\t    video_attributes = {\n\t        \"height\": video_height,\n", "        \"width\": video_width,\n\t    }\n\t    if title:\n\t        video_attributes[\"title\"] = escape(title)\n\t    video_attributes_str = \" \".join(\n\t        f'{name}=\"{value}\"' for name, value in video_attributes.items()\n\t    )\n\t    mimetype = f\"video/{extension}\"\n\t    return (\n\t        f\"<video {video_attributes_str} controls>\"\n", "        f'<source src=\"{src}\" type=\"{mimetype}\"></source></video>'\n\t    )\n"]}
{"filename": "tests/test_minify_html_plugin.py", "chunked_list": ["from blurry.plugins.html_plugins.minify_html_plugin import minify_css\n\tfrom blurry.plugins.html_plugins.minify_html_plugin import minify_style_tags\n\tdef test_minify_css():\n\t    css = \"\"\"\n\tbody {\n\t  color: pink;\n\t}\n\tdocument {\n\t  background: blue;\n\t}\n", "pre,\n\tcode {\n\t  font-family: monospace;\n\t  font-size: 0.9rem;\n\t}\n\t\"\"\".strip()\n\t    minified_css = minify_css(css)\n\t    assert minified_css == (\n\t        \"body{color:pink;}document{background:blue;}\"\n\t        \"pre,code{font-family:monospace;font-size:0.9rem;}\"\n", "    )\n\tdef test_minify_style_tags():\n\t    html = \"\"\"\n\t<html>\n\t<head>\n\t  <style>\n\t  body {\n\t    color: pink;\n\t  }\n\t  </style>\n", "</head>\n\t<body>\n\t  <style>\n\t  document {\n\t    background: blue;\n\t  }\n\t  </style>\n\t</body>\n\t</html>\n\t\"\"\".strip()\n", "    html_with_minified_style_tags = minify_style_tags(html)\n\t    assert (\n\t        html_with_minified_style_tags\n\t        == \"\"\"\n\t<html><head>\n\t  <style>body{color:pink;}</style>\n\t</head>\n\t<body>\n\t  <style>document{background:blue;}</style>\n\t</body></html>\n", "\"\"\".strip()\n\t    )\n"]}
{"filename": "tests/test_python_code_plugin.py", "chunked_list": ["from blurry.plugins.markdown_plugins.python_code_plugin import render_python_code\n\tdef test_render_python_code_within_module():\n\t    language = \"python\"\n\t    path = \"blurry.types.MarkdownFileData\"\n\t    fenced_code_block = render_python_code(None, language, path)\n\t    assert \"body: str\" in fenced_code_block\n\t    assert \"SchemaType\" not in fenced_code_block\n\tdef test_render_module_code():\n\t    language = \"python\"\n\t    path = \"blurry.plugins.html_plugins.minify_html_plugin\"\n", "    code = render_python_code(None, language, path)\n\t    assert \"import htmlmin\" in code\n\t    assert \"return html\" in code\n"]}
{"filename": "tests/test_images.py", "chunked_list": ["import pytest\n\tfrom blurry.images import generate_sizes_string\n\tfrom blurry.images import generate_srcset_string\n\tfrom blurry.images import get_widths_for_image_width\n\t@pytest.mark.parametrize(\n\t    \"image_path, image_widths, expected_output\",\n\t    [\n\t        (\n\t            \"dummy_image.png\",\n\t            [100, 200, 800],\n", "            (\n\t                \"dummy_image-100.png 100w, dummy_image-200.png 200w, \"\n\t                \"dummy_image-800.png 800w\"\n\t            ),\n\t        ),\n\t        (\n\t            \"dummy_image.avif\",\n\t            [240, 800],\n\t            \"dummy_image-240.avif 240w, dummy_image-800.avif 800w\",\n\t        ),\n", "    ],\n\t)\n\tdef test_generate_srcset_string(\n\t    image_path: str, image_widths: list[int], expected_output: str\n\t):\n\t    srcset_string = generate_srcset_string(image_path, image_widths)\n\t    assert srcset_string == expected_output\n\t@pytest.mark.parametrize(\n\t    \"image_widths, expected_output\",\n\t    [\n", "        (\n\t            [100, 200, 800],\n\t            \"(max-width: 100px) 100px, (max-width: 200px) 200px, 800px\",\n\t        ),\n\t        (\n\t            [200, 400],\n\t            \"(max-width: 200px) 200px, 400px\",\n\t        ),\n\t        ([240], \"240px\"),\n\t    ],\n", ")\n\tdef test_generate_sizes_string(image_widths: list[int], expected_output: str):\n\t    sizes_string = generate_sizes_string(image_widths)\n\t    assert sizes_string == expected_output\n\t@pytest.mark.parametrize(\n\t    \"image_width, expected_output\",\n\t    [\n\t        (900, [250, 360, 640, 768, 900]),\n\t        (700, [250, 360, 640, 700]),\n\t        (768, [250, 360, 640, 768]),\n", "        (249, [249]),\n\t    ],\n\t)\n\tdef test_get_widths_for_image_width(image_width: int, expected_output: list[int]):\n\t    image_widths = get_widths_for_image_width(image_width)\n\t    assert image_widths == expected_output\n"]}
{"filename": "tests/test_front_matter.py", "chunked_list": ["from blurry.markdown.front_matter import get_data\n\tMARKDOWN_WITH_BASIC_TOML_FRONT_MATTER = \"\"\"\n\t+++\n\t\"@type\" = \"WebPage\"\n\tname = \"Introduction\"\n\tabstract = \"A Python-powered static site generator with a focus on page speed and SEO.\"\n\tdatePublished = 2023-04-09\n\t+++\n\t# Blurry: A Python-powered static site generator\n\t## What is Blurry?\n", "Blurry is a static site generator with a terrible pun of a name...\n\t\"\"\".strip()\n\tdef test_get_data():\n\t    doc, data = get_data(MARKDOWN_WITH_BASIC_TOML_FRONT_MATTER)\n\t    assert doc.startswith(\"# Blurry: \")\n\t    assert len(data) == 4\n\t    assert data.get(\"@type\") == \"WebPage\"\n"]}
{"filename": "tests/test_sitemap.py", "chunked_list": ["from datetime import date\n\tfrom pathlib import Path\n\tfrom blurry.sitemap import generate_sitemap_for_file_data_list\n\tfrom blurry.types import MarkdownFileData\n\tblog_path = Path(\"blog\")\n\tdirectory_file_data = [\n\t    MarkdownFileData(\n\t        front_matter=dict(datePublished=date(2021, 1, 1), url=\"/blog/a-post-1/\"),\n\t        body=\"\",\n\t        path=blog_path / \"a-post-1\",\n", "    ),\n\t    MarkdownFileData(\n\t        front_matter=dict(datePublished=date(2021, 3, 1), url=\"/blog/b-post-3/\"),\n\t        body=\"\",\n\t        path=blog_path / \"b-post-3\",\n\t    ),\n\t    MarkdownFileData(\n\t        front_matter=dict(dateCreated=date(2021, 2, 1), url=\"/blog/c-post-2/\"),\n\t        body=\"\",\n\t        path=blog_path / \"c-post-2\",\n", "    ),\n\t    MarkdownFileData(\n\t        front_matter=dict(\n\t            dateCreated=date(2022, 1, 10),\n\t            dateModified=date(2022, 1, 13),\n\t            url=\"/blog/c-post-4/\",\n\t        ),\n\t        body=\"\",\n\t        path=blog_path / \"c-post-4\",\n\t    ),\n", "]\n\tdef test_generate_sitemap_for_file_data_list():\n\t    sitemap_content = generate_sitemap_for_file_data_list(\n\t        file_data_list=directory_file_data\n\t    )\n\t    assert sitemap_content.startswith('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')\n\t    assert sitemap_content.endswith(\"</urlset>\")\n\t    assert (\n\t        \"<url><loc>/blog/c-post-4/</loc><lastmod>2022-01-13</lastmod></url>\"\n\t        in sitemap_content\n", "    )\n"]}
{"filename": "tests/test_open_graph.py", "chunked_list": ["import pytest\n\tfrom blurry.open_graph import open_graph_meta_tags\n\tfrom blurry.open_graph import open_graph_type_from_schema_type\n\tfrom blurry.types import SchemaType\n\t@pytest.mark.parametrize(\n\t    \"schema_type, open_graph_type\",\n\t    [\n\t        (SchemaType.BLOG_POSTING, \"article\"),\n\t        (SchemaType.NEWS_ARTICLE, \"article\"),\n\t        (\"banana\", \"website\"),\n", "    ],\n\t)\n\tdef test_open_graph_type_from_schema_type(schema_type, open_graph_type):\n\t    assert open_graph_type_from_schema_type(schema_type) == open_graph_type\n\tschema_data = {\"@type\": \"BlogPosting\", \"url\": \"/blog/article-one/\", \"image\": \"/hey.png\"}\n\tmeta_tag_content = \"\"\"\n\t<meta property=\"og:type\" content=\"article\" />\n\t<meta property=\"og:url\" content=\"/blog/article-one/\" />\n\t<meta property=\"og:image\" content=\"/hey.png\" />\n\t\"\"\".strip()\n", "def test_open_graph_meta_tags():\n\t    assert open_graph_meta_tags(schema_data) == meta_tag_content\n"]}
{"filename": "tests/test_utils.py", "chunked_list": ["from datetime import date\n\tfrom pathlib import Path\n\tfrom unittest import mock\n\timport pytest\n\tfrom selectolax.parser import HTMLParser\n\tfrom blurry.settings import get_build_directory\n\tfrom blurry.settings import get_content_directory\n\tfrom blurry.settings import SETTINGS\n\tfrom blurry.types import MarkdownFileData\n\tfrom blurry.utils import content_path_to_url\n", "from blurry.utils import convert_content_path_to_directory_in_build\n\tfrom blurry.utils import convert_relative_path_in_markdown_to_relative_build_path\n\tfrom blurry.utils import format_schema_data\n\tfrom blurry.utils import get_domain_with_scheme\n\tfrom blurry.utils import path_to_url_pathname\n\tfrom blurry.utils import remove_lazy_loading_from_first_image\n\tfrom blurry.utils import sort_directory_file_data_by_date\n\tBUILD_DIR = get_build_directory()\n\tCONTENT_DIR = get_content_directory()\n\t@pytest.mark.parametrize(\n", "    \"path_in, expected_build_path\",\n\t    [\n\t        (\"cool-post.md\", \"cool-post\"),\n\t        (\"nested/post.md\", \"nested/post\"),\n\t        (\"index.md\", \"\"),\n\t    ],\n\t)\n\tdef test_convert_content_path_to_build_path(path_in, expected_build_path):\n\t    path = Path(path_in)\n\t    path_out = convert_content_path_to_directory_in_build(path)\n", "    assert path_out == (BUILD_DIR / Path(expected_build_path))\n\t@pytest.mark.parametrize(\n\t    \"path_in, expected_html_path\",\n\t    [\n\t        (\"./cool-post.md\", \"../cool-post/\"),\n\t        (\"../home.md\", \"../../home/\"),\n\t        (\"../index.md\", \"../../\"),\n\t        (\"./image.png\", \"../image.png\"),\n\t    ],\n\t)\n", "def test_convert_content_path_to_html_path(path_in, expected_html_path):\n\t    html_path = convert_relative_path_in_markdown_to_relative_build_path(path_in)\n\t    assert html_path == expected_html_path\n\tdef test_sort_directory_file_data_by_date():\n\t    blog_path = Path(\"blog\")\n\t    directory_file_data = {\n\t        blog_path: [\n\t            MarkdownFileData(\n\t                front_matter=dict(datePublished=date(2021, 1, 1)),\n\t                body=\"\",\n", "                path=Path(\"a-post-1\"),\n\t            ),\n\t            MarkdownFileData(\n\t                front_matter=dict(datePublished=date(2021, 3, 1)),\n\t                body=\"\",\n\t                path=Path(\"b-post-3\"),\n\t            ),\n\t            MarkdownFileData(\n\t                front_matter=dict(dateCreated=date(2021, 2, 1)),\n\t                body=\"\",\n", "                path=Path(\"c-post-2\"),\n\t            ),\n\t            MarkdownFileData(\n\t                front_matter=dict(),\n\t                body=\"\",\n\t                path=Path(\"c-post-4\"),\n\t            ),\n\t        ]\n\t    }\n\t    sorted_directory_file_data = sort_directory_file_data_by_date(directory_file_data)\n", "    file_data = sorted_directory_file_data[blog_path]\n\t    assert \"post-3\" in str(file_data[0].path)\n\t    assert \"post-2\" in str(file_data[1].path)\n\t    assert \"post-1\" in str(file_data[2].path)\n\t    assert \"post-4\" in str(file_data[3].path)\n\t@pytest.mark.parametrize(\n\t    \"path, expected_url\",\n\t    [\n\t        (Path(\"index.md\"), \"https://a.com/\"),\n\t        (Path(\"contact.md\"), \"https://a.com/contact/\"),\n", "        (Path(\"blog/index.md\"), \"https://a.com/blog/\"),\n\t        (Path(\"blog/my-post.md\"), \"https://a.com/blog/my-post/\"),\n\t    ],\n\t)\n\tdef test_content_path_to_url(path, expected_url):\n\t    with mock.patch.dict(SETTINGS, {\"DOMAIN\": \"a.com\"}):\n\t        assert content_path_to_url(path) == expected_url\n\t@pytest.mark.parametrize(\n\t    \"settings, expected_domain_with_scheme\",\n\t    [\n", "        ({\"RUNSERVER\": True}, \"http://127.0.0.1:8000\"),\n\t        ({\"RUNSERVER\": False}, \"https://example.com\"),\n\t        (\n\t            {\n\t                \"RUNSERVER\": True,\n\t                \"USE_HTTP\": True,\n\t                \"DEV_HOST\": \"localhost\",\n\t                \"DEV_PORT\": 8001,\n\t            },\n\t            \"http://localhost:8001\",\n", "        ),\n\t        ({\"RUNSERVER\": False, \"DOMAIN\": \"banana.biz\"}, \"https://banana.biz\"),\n\t        (\n\t            {\"RUNSERVER\": False, \"USE_HTTP\": True, \"DOMAIN\": \"banana.biz\"},\n\t            \"http://banana.biz\",\n\t        ),\n\t    ],\n\t)\n\tdef test_get_domain_with_scheme(settings, expected_domain_with_scheme):\n\t    with mock.patch.dict(SETTINGS, settings):\n", "        assert get_domain_with_scheme() == expected_domain_with_scheme\n\t@pytest.mark.parametrize(\n\t    \"path, expected_url_pathname\",\n\t    [\n\t        (CONTENT_DIR / \"favicon.png\", \"/favicon.png\"),\n\t        (CONTENT_DIR / \"images\" / \"some-image.jpg\", \"/images/some-image.jpg\"),\n\t    ],\n\t)\n\tdef test_path_to_url_pathname(path, expected_url_pathname):\n\t    assert path_to_url_pathname(path) == expected_url_pathname\n", "def test_format_schema_data():\n\t    assert format_schema_data({\"@type\": \"BlogPosting\"}) == {\n\t        \"@context\": \"https://schema.org\",\n\t        \"@type\": \"BlogPosting\",\n\t    }\n\tdef test_remove_lazy_loading_from_first_image():\n\t    html = \"\"\"\n\t    <body>\n\t    <picture class=\"one\">\n\t        <source src=\"one.avif\">\n", "        <img src=\"one.png\" loading=\"lazy\">\n\t    </picture>\n\t    <picture class=\"two\">\n\t        <source src=\"two.avif\">\n\t        <img src=\"two.png\" loading=\"lazy\">\n\t    </picture>\n\t    </body>\n\t    \"\"\"\n\t    updated_html = remove_lazy_loading_from_first_image(html)\n\t    parser = HTMLParser(updated_html)\n", "    assert parser.css_first(\"picture.one img\").attributes.get(\"loading\") is None\n\t    assert parser.css_first(\"picture.two img\").attributes.get(\"loading\") == \"lazy\"\n"]}
