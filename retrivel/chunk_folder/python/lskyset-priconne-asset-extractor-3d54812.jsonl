{"filename": "example.py", "chunked_list": ["from src import Dataminer\n\tdef examples():\n\t    # initializes the dataminer\n\t    dm = Dataminer()\n\t    # Extracting a whole manifest\n\t    dm.datamine(\n\t        manifest_filter=\"wac\",\n\t        assetbundle_filter=\"\",\n\t        file_filter=\"\",\n\t    )\n", "    # Extracting images\n\t    dm.datamine(\n\t        manifest_filter=\"bg\",\n\t        assetbundle_filter=r\"still_unit_1001[0-9]{2}\",\n\t        file_filter=r\"still_unit_1001[0-9]{2}\\.png\",\n\t    )\n\t    # Sound and Movie manifests only contain regular files so the assetbundle filter isn't needed.\n\t    dm.datamine(\n\t        manifest_filter=\"sound\",\n\t        assetbundle_filter=\"\",\n", "        file_filter=r\"bgm_M36\\.\",\n\t    )\n\t    dm.datamine(\n\t        manifest_filter=\"sound\",\n\t        assetbundle_filter=\"\",\n\t        file_filter=\"bgm_M152\",\n\t    )\n\t    dm.datamine(\n\t        manifest_filter=\"movie\",\n\t        assetbundle_filter=\"\",\n", "        file_filter=r\"character_1001[0-9]{2}\",\n\t    )\n\t    def sd_skel_example():\n\t        # 000000 files contains animations shared by all units\n\t        dm.datamine(\n\t            manifest_filter=\"spine\",\n\t            assetbundle_filter=\"000000\",\n\t            file_filter=\"cysp\",\n\t        )\n\t        # the common cysp contain animations shared by units from the same same class (eg. sword units)\n", "        dm.datamine(\n\t            manifest_filter=\"spine\",\n\t            assetbundle_filter=\"common\",\n\t            file_filter=\"cysp\",\n\t        )\n\t        # filters for the specific unit animations, include all uncap versions\n\t        dm.datamine(\n\t            manifest_filter=\"spine\",\n\t            assetbundle_filter=r\"1001[0-9]{2}\",\n\t            file_filter=r\"1001[0-9]{2}\",\n", "        )\n\t        # assemble .cysp files into a .skel file for a given unit_id\n\t        dm.get_skel(100111)\n\t    sd_skel_example()\n\tif __name__ == \"__main__\":\n\t    # keep all scripting in this scope to avoid bugs with multiprocessing\n\t    examples()\n"]}
{"filename": "priconne_asset_extractor.py", "chunked_list": ["from src import Dataminer\n\tdef main():\n\t    dm = Dataminer()\n\t    # Running as is will download all the manifests.\n\t    # They are just text files with file names so you can open them and adjust your filters.\n\t    # Files ending with .unity3d are assetbundles (containing more files) which you filter with assetbundle_filter\n\t    # Leaving filters empty will download / extract everything so make sure you have enough disk space when dealing with sound and movie files.\n\t    dm.datamine(\n\t        manifest_filter=\"\",  # (empty) manifest_name\n\t        assetbundle_filter=\"assetbundle_name\",\n", "        file_filter=\"file_name\",\n\t    )\n\tif __name__ == \"__main__\":\n\t    # keep all scripting in this scope to avoid bugs with multiprocessing\n\t    main()\n"]}
{"filename": "src/story_deserializer.py", "chunked_list": ["import base64\n\tfrom enum import Enum\n\tfrom struct import unpack\n\tclass CommandId(Enum):\n\t    NONE = -1\n\t    TITLE = 0\n\t    OUTLINE = 1\n\t    VISIBLE = 2\n\t    FACE = 3\n\t    FOCUS = 4\n", "    BACKGROUND = 5\n\t    PRINT = 6\n\t    TAG = 7\n\t    GOTO = 8\n\t    BGM = 9\n\t    TOUCH = 10\n\t    CHOICE = 11\n\t    VO = 12\n\t    WAIT = 13\n\t    IN_L = 14\n", "    IN_R = 15\n\t    OUT_L = 16\n\t    OUT_R = 17\n\t    FADEIN = 18\n\t    FADEOUT = 19\n\t    IN_FLOAT = 20\n\t    OUT_FLOAT = 21\n\t    JUMP = 22\n\t    SHAKE = 23\n\t    POP = 24\n", "    NOD = 25\n\t    SE = 26\n\t    BLACK_OUT = 27\n\t    BLACK_IN = 28\n\t    WHITE_OUT = 29\n\t    WHITE_IN = 30\n\t    TRANSITION = 31\n\t    SITUATION = 32\n\t    COLOR_FADEIN = 33\n\t    FLASH = 34\n", "    SHAKE_TEXT = 35\n\t    TEXT_SIZE = 36\n\t    SHAKE_SCREEN = 37\n\t    DOUBLE = 38\n\t    SCALE = 39\n\t    TITLE_TELOP = 40\n\t    WINDOW_VISIBLE = 41\n\t    LOG = 42\n\t    NOVOICE = 43\n\t    CHANGE = 44\n", "    FADEOUT_ALL = 45\n\t    MOVIE = 46\n\t    MOVIE_STAY = 47\n\t    BATTLE = 48\n\t    STILL = 49\n\t    BUSTUP = 50\n\t    ENV = 51\n\t    TUTORIAL_REWARD = 52\n\t    NAME_EDIT = 53\n\t    EFFECT = 54\n", "    EFFECT_DELETE = 55\n\t    EYE_OPEN = 56\n\t    MOUTH_OPEN = 57\n\t    AUTO_END = 58\n\t    EMOTION = 59\n\t    EMOTION_END = 60\n\t    ENV_STOP = 61\n\t    BGM_PAUSE = 62\n\t    BGM_RESUME = 63\n\t    BGM_VOLUME_CHANGE = 64\n", "    ENV_RESUME = 65\n\t    ENV_VOLUME = 66\n\t    SE_PAUSE = 67\n\t    CHARA_FULL = 68\n\t    SWAY = 69\n\t    BACKGROUND_COLOR = 70\n\t    PAN = 71\n\t    STILL_UNIT = 72\n\t    SLIDE_CHARA = 73\n\t    SHAKE_SCREEN_ONCE = 74\n", "    TRANSITION_RESUME = 75\n\t    SHAKE_LOOP = 76\n\t    SHAKE_DELETE = 77\n\t    UNFACE = 78\n\t    WAIT_TOKEN = 79\n\t    EFFECT_ENV = 80\n\t    BRIGHT_CHANGE = 81\n\t    CHARA_SHADOW = 82\n\t    UI_VISIBLE = 83\n\t    FADEIN_ALL = 84\n", "    CHANGE_WINDOW = 85\n\t    BG_PAN = 86\n\t    STILL_MOVE = 87\n\t    STILL_NORMALIZE = 88\n\t    VOICE_EFFECT = 89\n\t    TRIAL_END = 90\n\t    SE_EFFECT = 91\n\t    CHARACTER_UP_DOWN = 92\n\t    BG_CAMERA_ZOOM = 93\n\t    BACKGROUND_SPLIT = 94\n", "    CAMERA_ZOOM = 95\n\t    SPLIT_SLIDE = 96\n\t    BGM_TRANSITION = 97\n\t    SHAKE_ANIME = 98\n\t    INSERT_STORY = 99\n\t    PLACE = 100\n\t    IGNORE_BGM = 101\n\t    MULTI_LIPSYNC = 102\n\t    JINGLE = 103\n\t    TOUCH_TO_START = 104\n", "    EVENT_ADV_MOVE_HORIZONTAL = 105\n\t    BG_PAN_X = 106\n\t    BACKGROUND_BLUR = 107\n\t    SEASONAL_REWARD = 108\n\t    MINI_GAME = 109\n\t    MAX = 110\n\t    UNKNOWN = 112  # todo: find the actual name\n\tdef deserialize_command(data) -> tuple[CommandId, list[str]]:\n\t    index = data[0]\n\t    args = []\n", "    if len(data) > 1:\n\t        args = data[1:]\n\t    array = []\n\t    for arg in args:\n\t        array2 = []\n\t        for byte in arg:\n\t            if byte > 127:\n\t                array2.append(255 - byte)\n\t            else:\n\t                array2.append(byte)\n", "        str_ = base64.b64decode(bytearray(array2))\n\t        array.append(str_.decode())\n\t    return (CommandId(index), array)\n\tdef deserialize_story_raw(bytes_: bytes) -> list[tuple[CommandId, list[str]]]:\n\t    commands = []\n\t    fs = 0\n\t    raw_commands = []\n\t    i = 2\n\t    while i < len(bytes_):\n\t        args: list[bytes | int] = []\n", "        index = int(unpack(\">H\", bytes_[fs : fs + 2])[0])\n\t        fs += 2\n\t        args.append(index)\n\t        num = i\n\t        while True:\n\t            length = int(unpack(\">l\", bytes_[fs : fs + 4])[0])\n\t            fs += 4\n\t            if length == 0:\n\t                break\n\t            array = bytes_[fs : fs + length]\n", "            fs += length\n\t            args.append(array)\n\t            num += 4 + length\n\t        i = num + 4\n\t        raw_commands.append(args)\n\t        i += 2\n\t    for raw_command in raw_commands:\n\t        if len(raw_command) > 1:\n\t            commands.append(deserialize_command(raw_command))\n\t    return commands\n", "def deserialize_story(bytes_: bytes) -> dict:\n\t    commands = deserialize_story_raw(bytes_)\n\t    story: dict[int, dict] = {}\n\t    num = 0\n\t    story[num] = {}\n\t    block: dict[str, str | tuple | dict] = story[num]\n\t    for command_id, args in commands:\n\t        match command_id:\n\t            case CommandId.PRINT:\n\t                cmd = block.setdefault(command_id.name.lower(), {})\n", "                cmd.setdefault(\"name\", args[0])\n\t                cmd[\"text\"] = (cmd.get(\"text\") or \"\") + clean_text(args[1])\n\t            case CommandId.CHOICE:\n\t                block.setdefault(command_id.name.lower(), [])\n\t                block[command_id.name.lower()].append(\n\t                    {\n\t                        \"text\": args[0],\n\t                        \"tag\": args[1],\n\t                    }\n\t                )\n", "            case CommandId.BUSTUP:\n\t                num += 1\n\t                block = story.setdefault(num, {})\n\t            case CommandId.TAG:\n\t                story.setdefault(num + 1, {})\n\t                story[num + 1][command_id.name.lower()] = args[0]\n\t            case CommandId.TITLE | CommandId.SITUATION | CommandId.OUTLINE | CommandId.VO | CommandId.GOTO:\n\t                if len(args) == 1:\n\t                    args = args[0]\n\t                block[command_id.name.lower()] = args\n", "    return story\n\tdef clean_text(text: str) -> str:\n\t    replace_pairs = (\n\t        (\"\\\\n\", \"\\n\"),\n\t        (\"{0}\", \"{player_name}\"),\n\t        ('\\\\\"', '\"'),\n\t    )\n\t    for pair in replace_pairs:\n\t        text = text.replace(*pair)\n\t    return text\n"]}
{"filename": "src/config.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom enum import Enum\n\tfrom pathlib import Path\n\timport UnityPy\n\tclass ManifestType(Enum):\n\t    ASSET = \"dl/Resources/%s/Jpn/AssetBundles/Windows/manifest/%s\"\n\t    MOVIE = \"dl/Resources/%s/Jpn/Movie/PC/High/manifest/%s\"\n\t    SOUND = \"dl/Resources/%s/Jpn/Sound/manifest/%s\"\n\tclass AssetType(Enum):\n\t    ASSET = \"dl/pool/AssetBundles\"\n", "    MOVIE = \"dl/pool/Movie\"\n\t    SOUND = \"dl/pool/Sound\"\n\tclass BundleType(Enum):\n\t    TEXTURE_2D = \"Texture2D\"\n\t    Sprite = \"Sprite\"\n\t    TEXT_ASSET = \"TextAsset\"\n\tclass BundleSource(Enum):\n\t    WEB = 0\n\t    LOCAL = 1  # not implemented\n\tclass PricoHost(Enum):\n", "    JP = \"prd-priconne-redive.akamaized.net\"\n\t    EN = \"assets-priconne-redive-us.akamaized.net\"  # not implemented\n\t@dataclass(frozen=True)\n\tclass Config:\n\t    image_format: str = \".png\"\n\t    bundle_source: BundleSource = BundleSource.WEB\n\t    host = PricoHost.JP\n\t    usmtoolkit_path = Path(\"usmtoolkit/UsmToolkit.exe\")\n\t    vgmstream_path = usmtoolkit_path.parent / \"vgmstream\" / \"test.exe\"\n\tUnityPy.config.FALLBACK_UNITY_VERSION = \"2021.3.20f1\"\n"]}
{"filename": "src/asset_bundle.py", "chunked_list": ["from pathlib import Path\n\timport UnityPy  # type: ignore[import]\n\tfrom src.abc.abstract_manifest_file import AbstractManifestFile\n\tfrom .config import AssetType, BundleType, Config\n\tfrom .files import BundleFile, FileContainer\n\tclass AssetBundle(AbstractManifestFile, FileContainer[BundleFile]):\n\t    def __init__(\n\t        self,\n\t        path: Path | str,\n\t        hash_: str,\n", "        size: int,\n\t    ) -> None:\n\t        super().__init__(path, hash_, AssetType.ASSET, size)\n\t    @property\n\t    def name(self) -> str:\n\t        if name := self._name.split(\"_\", 1)[1]:\n\t            return name\n\t        return self._name\n\t    @property\n\t    def path(self) -> Path:\n", "        if len(self._name.split(\"_\", 1)) == 2:\n\t            sub_folder, name = self._name.split(\"_\", 1)\n\t            return self._path.parent / sub_folder / \"assetbundle\" / name\n\t        return self._path\n\t    @property\n\t    def url(self):\n\t        endpoint = f\"{AssetType.ASSET.value}/{self._hash[:2]}/{self._hash}\"\n\t        return f\"https://{Config.host.value}/{endpoint}\"\n\t    @property\n\t    def files(self) -> list[BundleFile]:\n", "        if self._files is None:\n\t            self._files = self._read()\n\t        return self._files\n\t    def _read(self) -> list[BundleFile]:\n\t        self.download()\n\t        files = []\n\t        env = UnityPy.load(self.path.as_posix())\n\t        supported_bundle_types = [t.value for t in BundleType]\n\t        for obj in env.objects:\n\t            if obj.type.name in supported_bundle_types:\n", "                files.append(BundleFile(self, obj))\n\t        return files\n"]}
{"filename": "src/version_finder.py", "chunked_list": ["import json\n\tfrom pathlib import Path\n\tfrom requests_futures.sessions import FuturesSession\n\tfrom src.config import ManifestType, PricoHost\n\tdef find_version(host: PricoHost, default_version: int) -> int:\n\t    max_test_amount = 30\n\t    test_multiplier = 10\n\t    version = default_version\n\t    s = FuturesSession()\n\t    while True:\n", "        urls = [\n\t            f'http://{host.value}/{ManifestType.ASSET.value % (version + (i + 1) * test_multiplier, \"manifest_assetmanifest\")}'\n\t            for i in range(max_test_amount)\n\t        ]\n\t        responses = [s.get(url) for url in urls]\n\t        results = [r.result().status_code == 200 for r in responses]\n\t        if not any(results):\n\t            return version\n\t        version += (max_test_amount - results[::-1].index(True)) * test_multiplier\n\tdef find_version_fallback(host: PricoHost) -> int:\n", "    s = FuturesSession()\n\t    if host == PricoHost.JP:\n\t        r = s.get(\"https://redive.estertion.win/last_version_jp.json\").result()\n\t        latest = json.loads(r.content)\n\t    else:\n\t        raise \"could not find version\"\n\t    return int(latest[\"TruthVersion\"])\n\tdef get_latest_version(host: PricoHost) -> int:\n\t    print(\"Finding latest version\")\n\t    default_version = 10047400\n", "    versions = {}\n\t    path = Path(\"versions.json\")\n\t    if path.exists():\n\t        versions = json.loads(path.read_text())\n\t        default_version = versions.get(host.value, default_version)\n\t    try:\n\t        version = find_version(host, default_version)\n\t    except Exception as e:\n\t        print(e, \"\\nusing fallback version finder\")\n\t        version = find_version_fallback(host)\n", "    versions[host.value] = version\n\t    path.write_text(json.dumps(versions))\n\t    print(f\"{version=}\")\n\t    return version\n"]}
{"filename": "src/__init__.py", "chunked_list": ["from .dataminer import Dataminer\n\t__all__ = [\"Dataminer\"]\n"]}
{"filename": "src/protocols.py", "chunked_list": ["from pathlib import Path\n\tfrom typing import Protocol\n\tclass File(Protocol):\n\t    @property\n\t    def path(self) -> Path:\n\t        ...\n\t    @property\n\t    def name(self) -> str:\n\t        ...\n\tclass Readable(Protocol):\n", "    def _read(self) -> list:\n\t        ...\n\tclass Downloadable(File, Protocol):\n\t    def download(self) -> None:\n\t        ...\n\tclass Extractable(Protocol):\n\t    def extract(self) -> None:\n\t        ...\n"]}
{"filename": "src/dataminer.py", "chunked_list": ["import re\n\tfrom itertools import chain\n\tfrom multiprocessing import Pool\n\tfrom pathlib import Path\n\tfrom urllib.request import urlretrieve\n\tfrom src.config import Config\n\tfrom . import version_finder\n\tfrom .asset_bundle import AssetBundle\n\tfrom .cysp2skel import Cysp2Skel\n\tfrom .files import BundleFile\n", "from .manifests import AssetManifest, Manifest, MovieManifest, SoundManifest\n\tfrom .mdb import MDB\n\tfrom .protocols import Extractable\n\tclass Dataminer:\n\t    _mdb: MDB | None = None\n\t    _cysp2skel: Cysp2Skel | None = None\n\t    __slots__ = (\n\t        \"_asset_manifest\",\n\t        \"_sound_manifest\",\n\t        \"_movie_manifest\",\n", "    )\n\t    def __init__(self, *, version: int | None = None) -> None:\n\t        if version is None:\n\t            version = version_finder.get_latest_version(Config.host)\n\t        self._asset_manifest: AssetManifest = AssetManifest(version)\n\t        self._sound_manifest: SoundManifest = SoundManifest(version)\n\t        self._movie_manifest: MovieManifest = MovieManifest(version)\n\t    @staticmethod\n\t    def _pool_manifest_files(data: tuple[Manifest, str]) -> list[AssetBundle]:\n\t        manifest, match = data\n", "        ret = manifest.get_files(match)\n\t        return ret\n\t    @staticmethod\n\t    def _pool_bundle_files(data: tuple[AssetBundle, str]) -> list[BundleFile]:\n\t        assetbundle, match = data\n\t        return assetbundle.get_files(match)\n\t    @staticmethod\n\t    def _extract_file(file: Extractable):\n\t        file.extract()\n\t    @staticmethod\n", "    def download_mdb(mdb_name=\"master.db\") -> str:\n\t        return urlretrieve(\n\t            \"https://github.com/lskyset/nozomi-cb-data/raw/main/master.db\",\n\t            mdb_name,\n\t        )[0]\n\t    @property\n\t    def mdb(self) -> MDB:\n\t        if Dataminer._mdb is None:\n\t            Dataminer._mdb = MDB(Dataminer.download_mdb())\n\t        return Dataminer._mdb\n", "    @property\n\t    def cysp2skel(self) -> Cysp2Skel:\n\t        if Dataminer._cysp2skel is None:\n\t            Dataminer._cysp2skel = Cysp2Skel(\"a/spine/unitanimation\", self.mdb)\n\t        return Dataminer._cysp2skel\n\t    def get_manifests(\n\t        self, match: str = \"\"\n\t    ) -> list[Manifest | SoundManifest | MovieManifest]:\n\t        manifests: list[SoundManifest | MovieManifest] = []\n\t        tmp: list[SoundManifest | MovieManifest] = [\n", "            self._sound_manifest,\n\t            self._movie_manifest,\n\t        ]\n\t        for manifest in tmp:\n\t            if re.search(match, manifest.name):\n\t                manifests.append(manifest)\n\t        return self._asset_manifest.get_files(match) + manifests\n\t    def datamine(\n\t        self,\n\t        *,\n", "        manifest_filter: str,\n\t        assetbundle_filter: str,\n\t        file_filter: str,\n\t    ):\n\t        manifests: list[Manifest | SoundManifest | MovieManifest]\n\t        manifests = self.get_manifests(manifest_filter)\n\t        with Pool() as p:\n\t            assetbundles: chain[AssetBundle] = chain(\n\t                *p.imap(\n\t                    self._pool_manifest_files,\n", "                    [\n\t                        (manifest, assetbundle_filter)\n\t                        for manifest in manifests\n\t                        if type(manifest) == Manifest\n\t                    ],\n\t                )\n\t            )\n\t            files: chain[Extractable] = chain(\n\t                *p.imap(\n\t                    self._pool_bundle_files,\n", "                    [(assetbndl, file_filter) for assetbndl in assetbundles],\n\t                ),\n\t                chain(\n\t                    *[\n\t                        manifest.get_files(file_filter)\n\t                        for manifest in manifests\n\t                        if type(manifest) == SoundManifest\n\t                        or type(manifest) == MovieManifest\n\t                    ]\n\t                ),\n", "            )\n\t            list(p.imap(self._extract_file, files))\n\t    def get_skel(self, unit_id: int):\n\t        if (buffer := self.cysp2skel.get_skeleton_buffer(unit_id)) is None:\n\t            return print(f\"Could not find {unit_id=}\")\n\t        path = Path(f\"a/spine/sdnormal/spine_{unit_id}/{unit_id}.skel\")\n\t        path.parent.mkdir(parents=True, exist_ok=True)\n\t        with path.open(\"wb\") as f:\n\t            f.write(buffer.read())\n\t        print(f\"EX {path.absolute()}\")\n"]}
{"filename": "src/cysp2skel.py", "chunked_list": ["import struct\n\tfrom io import BufferedReader, BytesIO, RawIOBase\n\tfrom pathlib import Path\n\tfrom typing import cast\n\tfrom .mdb import MDB\n\tclass Cysp2Skel:\n\t    _default_base: BufferedReader | None = None\n\t    _default_base_animation_count: int = 0\n\t    _default_animation_count_index: int = 0\n\t    _unit_class_data: dict[str, str] | None = None\n", "    __slots__ = (\n\t        \"_cysp_dir\",\n\t        \"mdb\",\n\t        \"_current_base\",\n\t        \"_current_base_animation_count\",\n\t        \"_current_animation_count_index\",\n\t    )\n\t    def __init__(self, cysp_dir: str | Path, mdb: MDB) -> None:\n\t        self._cysp_dir = Path(cysp_dir)\n\t        self.mdb = mdb\n", "        self._current_base: BufferedReader | None = None\n\t        self._current_base_animation_count: int = 0\n\t        self._current_animation_count_index: int = 0\n\t    def _get_base(self, str_id: str) -> RawIOBase:\n\t        files: list[str] = [\n\t            f\"{str_id}_{name}.cysp\"\n\t            for name in [\n\t                \"CHARA_BASE\",\n\t                \"DEAR\",\n\t                \"NO_WEAPON\",\n", "                \"POSING\",\n\t                \"RACE\",\n\t                \"RUN_JUMP\",\n\t                \"SMILE\",\n\t            ]\n\t        ]\n\t        paths: list[Path] = [self._cysp_dir / file for file in files]\n\t        self._current_base_animation_count = 0\n\t        base = BytesIO()\n\t        for file in paths:\n", "            try:\n\t                with file.open(\"rb\") as f:\n\t                    f.seek(12)\n\t                    count = _read_varint(f)\n\t                    f.seek((count + 1) * 32)\n\t                    base.write(f.read())\n\t                    if \"CHARA_BASE.cysp\" in file.name:\n\t                        self._current_animation_count_index = base.tell()\n\t                        base.write(b\"\\0\")\n\t                    else:\n", "                        self._current_base_animation_count += count\n\t            except FileNotFoundError as e:\n\t                print(f\"Ignoring {e}\")\n\t        base.seek(self._current_animation_count_index)\n\t        base.write(bytes([self._current_base_animation_count]))\n\t        base.seek(0)\n\t        return base\n\t    def get_default_base(self) -> BufferedReader:\n\t        if Cysp2Skel._default_base is not None:\n\t            Cysp2Skel._default_base.seek(0)\n", "            self._current_base_animation_count = Cysp2Skel._default_base_animation_count\n\t            self._current_animation_count_index = (\n\t                Cysp2Skel._default_animation_count_index\n\t            )\n\t            return Cysp2Skel._default_base\n\t        Cysp2Skel._default_base = BufferedReader(self._get_base(\"000000\"))\n\t        Cysp2Skel._default_base_animation_count = self._current_base_animation_count\n\t        Cysp2Skel._default_animation_count_index = self._current_animation_count_index\n\t        return Cysp2Skel._default_base\n\t    def get_unit_data(self) -> dict[str | dict[str | str]]:\n", "        unit_data = self.mdb.c.execute(\n\t            \"select unit_id,prefab_id,prefab_id_battle,motion_type from unit_data\"\n\t        ).fetchall()\n\t        unit_enemy_data = self.mdb.c.execute(\n\t            \"select unit_id,prefab_id,motion_type from unit_enemy_data\"\n\t        ).fetchall()\n\t        unit_data_dict = {\n\t            str(unit_id): {\n\t                \"motion_type\": str(motion_type),\n\t                \"prefab_id\": str(prefab_id),\n", "                \"prefab_id_battle\": str(prefab_id_battle),\n\t            }\n\t            for unit_id, prefab_id, prefab_id_battle, motion_type in unit_data\n\t        }\n\t        enemy_data_dict = {\n\t            str(unit_id): {\n\t                \"motion_type\": str(motion_type),\n\t                \"prefab_id\": str(prefab_id),\n\t            }\n\t            for unit_id, prefab_id, motion_type in unit_enemy_data\n", "        }\n\t        return {**unit_data_dict, **enemy_data_dict}\n\t    @property\n\t    def unit_data(self) -> dict:\n\t        if Cysp2Skel._unit_class_data is None:\n\t            Cysp2Skel._unit_class_data = self.get_unit_data()\n\t        return Cysp2Skel._unit_class_data\n\t    def get_skeleton_buffer(self, unit_id: int) -> BufferedReader | None:\n\t        base_unit_id = str(unit_id // 100) + \"01\"\n\t        if (unit := self.unit_data.get(base_unit_id)) is None:\n", "            for unit in self.unit_data.values():\n\t                if unit.get(\"prefab_id\") == base_unit_id:\n\t                    break\n\t                if unit.get(\"prefab_id_battle\") == base_unit_id:\n\t                    break\n\t        motion_type: str = unit.get(\"motion_type\")\n\t        if motion_type is None:\n\t            return None\n\t        if motion_type == \"0\":\n\t            motion_type = base_unit_id\n", "            self._current_base = self._get_base(base_unit_id)\n\t        else:\n\t            self._current_base = self.get_default_base()\n\t        chara_class: str = motion_type.rjust(2, \"0\")\n\t        files: list[str] = []\n\t        files.append(f\"{chara_class}_COMMON_BATTLE.cysp\")\n\t        # files.append(f\"{chara_class}_LOADING.cysp\")\n\t        files.append(f\"{unit.get('prefab_id')}_BATTLE.cysp\")\n\t        paths: list[Path] = [self._cysp_dir / file for file in files]\n\t        skel = BytesIO()\n", "        skel.write(self._current_base.read())\n\t        class_animation_count = 0\n\t        for file in paths:\n\t            with file.open(\"rb\") as f:\n\t                f.seek(12)\n\t                count = _read_varint(f)\n\t                f.seek((count + 1) * 32)\n\t                skel.write(f.read())\n\t                class_animation_count += count\n\t        skel.seek(self._current_animation_count_index)\n", "        anim_count = self._current_base_animation_count + class_animation_count\n\t        skel.write(bytes([anim_count]))\n\t        skel.seek(0)\n\t        return BufferedReader(cast(RawIOBase, skel))\n\tdef int32(x: int) -> int:\n\t    if x > 0xFFFFFFFF:\n\t        raise OverflowError\n\t    if x > 0x7FFFFFFF:\n\t        x = 0x100000000 - x\n\t        if x < 2147483648:\n", "            return -x\n\t        else:\n\t            return -2147483648\n\t    return x\n\tdef _read_byte(input: BufferedReader) -> int:\n\t    return struct.unpack(\">B\", input.read(1))[0]\n\tdef _read_varint(input: BufferedReader, optimizePositive: bool = True) -> int:\n\t    b = _read_byte(input)\n\t    value = b & 0x7F\n\t    if b & 0x80:\n", "        b = _read_byte(input)\n\t        value |= (b & 0x7F) << 7\n\t        if b & 0x80:\n\t            b = _read_byte(input)\n\t            value |= (b & 0x7F) << 14\n\t            if b & 0x80:\n\t                b = _read_byte(input)\n\t                value |= (b & 0x7F) << 21\n\t                if b & 0x80:\n\t                    value |= (_read_byte(input) & 0x7F) << 28\n", "    if not optimizePositive:\n\t        value = (value >> 1) ^ -(value & 1)\n\t    return int32(value)\n"]}
{"filename": "src/mdb.py", "chunked_list": ["import sqlite3\n\tfrom pathlib import Path\n\tclass MDB:\n\t    __slots__ = (\"_mdb\", \"_c\")\n\t    def __init__(self, path: str | Path) -> None:\n\t        self._mdb: sqlite3.Connection = sqlite3.connect(path)\n\t        self._c: sqlite3.Cursor = self._mdb.cursor()\n\t    @property\n\t    def c(self) -> sqlite3.Cursor:\n\t        return self._c\n", "    def __del__(self):\n\t        self._mdb.close()\n"]}
{"filename": "src/manifests/asset_manifest.py", "chunked_list": ["from ..config import ManifestType\n\tfrom .manifest import AbstractManifest, Manifest\n\tclass AssetManifest(AbstractManifest[Manifest]):\n\t    def __init__(self, version: int):\n\t        AbstractManifest.__init__(\n\t            self, \"manifest_assetmanifest\", version, ManifestType.ASSET\n\t        )\n\t    def _read(self) -> list[Manifest]:\n\t        self.download()\n\t        with self.path.open() as f:\n", "            rows = f.readlines()\n\t        files = []\n\t        for row in rows:\n\t            path, hash_, _, size, *_ = row.split(\",\")\n\t            manifest = Manifest(\n\t                path, hash_, self.version, ManifestType.ASSET, int(size)\n\t            )\n\t            files.append(manifest)\n\t        return files\n"]}
{"filename": "src/manifests/manifest.py", "chunked_list": ["from pathlib import Path\n\tfrom ..abc.abstract_manifest_file import AbstractManifestFile\n\tfrom ..asset_bundle import AssetBundle\n\tfrom ..config import ManifestType\n\tfrom .abstract_manifest import AbstractManifest\n\tclass Manifest(\n\t    AbstractManifestFile,\n\t    AbstractManifest[AssetBundle],\n\t):\n\t    def __init__(\n", "        self,\n\t        path: Path | str,\n\t        hash_: str,\n\t        version: int,\n\t        type_: ManifestType,\n\t        size: int = 0,\n\t    ) -> None:\n\t        AbstractManifest.__init__(self, path, version, type_, size)\n\t        AbstractManifestFile.__init__(self, path, hash_, type_, size, version)\n\t    def _read(self) -> list[AssetBundle]:\n", "        self.download()\n\t        with self.path.open() as f:\n\t            rows = f.readlines()\n\t        files = []\n\t        for row in rows:\n\t            path, hash_, _, size, *_ = row.split(\",\")\n\t            files.append(AssetBundle(path, hash_, int(size)))\n\t        return files\n"]}
{"filename": "src/manifests/__init__.py", "chunked_list": ["from .asset_manifest import AssetManifest\n\tfrom .manifest import Manifest\n\tfrom .movie_manifest import MovieManifest\n\tfrom .sound_manifest import SoundManifest\n\t__all__ = [\n\t    \"AssetManifest\",\n\t    \"Manifest\",\n\t    \"MovieManifest\",\n\t    \"SoundManifest\",\n\t]\n"]}
{"filename": "src/manifests/abstract_manifest.py", "chunked_list": ["from abc import ABCMeta, abstractmethod\n\tfrom pathlib import Path\n\tfrom typing import Generic, TypeVar\n\tfrom urllib.request import urlretrieve\n\tfrom ..abc import AbstractFile\n\tfrom ..config import Config, ManifestType\n\tfrom ..files import FileContainer\n\tfrom ..protocols import Downloadable, File, Readable\n\tT = TypeVar(\"T\", bound=File)\n\tclass AbstractManifest(\n", "    AbstractFile,\n\t    FileContainer[T],\n\t    Downloadable,\n\t    Readable,\n\t    Generic[T],\n\t    metaclass=ABCMeta,\n\t):\n\t    __slots__ = (\"_version\",)\n\t    def __init__(\n\t        self,\n", "        path: Path | str,\n\t        version: int,\n\t        type_: ManifestType,\n\t        size: int = 0,\n\t    ) -> None:\n\t        AbstractFile.__init__(self, path, type_, size)\n\t        self._version: int = version\n\t        self._files: list[T] | None = None\n\t    @property\n\t    def name(self) -> str:\n", "        return self._name\n\t    @property\n\t    def path(self) -> Path:\n\t        return self._path\n\t    @property\n\t    def url(self) -> str:\n\t        endpoint = self._type.value % (str(self._version), self._name)\n\t        return f\"https://{Config.host.value}/{endpoint}\"\n\t    @property\n\t    def version(self) -> int:\n", "        return self._version\n\t    @property\n\t    def files(self) -> list[T]:\n\t        if self._files is None:\n\t            self._files = self._read()\n\t        return self._files\n\t    @abstractmethod\n\t    def _read(self) -> list[T]:\n\t        ...\n\t    def download(self) -> None:\n", "        if self.path.exists():\n\t            if self.path.stat().st_size == self.size:\n\t                return\n\t        self.path.parent.mkdir(parents=True, exist_ok=True)\n\t        urlretrieve(self.url, self.path)\n\t        print(f\"DL {self.url} -> {self.path.absolute()}\")\n"]}
{"filename": "src/manifests/sound_manifest.py", "chunked_list": ["from pathlib import Path\n\tfrom ..config import ManifestType\n\tfrom ..files.sound_file import SoundFile\n\tfrom .abstract_manifest import AbstractManifest\n\tclass SoundManifest(AbstractManifest[SoundFile]):\n\t    def __init__(self, version: int):\n\t        super().__init__(\"soundmanifest\", version, ManifestType.SOUND)\n\t    def _read(self) -> list[SoundFile]:\n\t        self.download()\n\t        with self.path.open() as f:\n", "            rows = f.readlines()\n\t        files: list[SoundFile] = []\n\t        for row in rows:\n\t            path, hash_, _, size, *_ = row.split(\",\")\n\t            new_path: Path = Path(path)\n\t            files.append(\n\t                SoundFile(\n\t                    new_path.parent / \"awb\" / new_path.name,\n\t                    hash_,\n\t                    int(size),\n", "                ),\n\t            )\n\t        return files\n"]}
{"filename": "src/manifests/movie_manifest.py", "chunked_list": ["from pathlib import Path\n\tfrom ..config import ManifestType\n\tfrom ..files import MovieFile\n\tfrom .abstract_manifest import AbstractManifest\n\tclass MovieManifest(AbstractManifest[MovieFile]):\n\t    def __init__(self, version: int):\n\t        super().__init__(\"movie2manifest\", version, ManifestType.MOVIE)\n\t    def _read(self) -> list[MovieFile]:\n\t        self.download()\n\t        with self.path.open() as f:\n", "            rows = f.readlines()\n\t        files: list[MovieFile] = []\n\t        for row in rows:\n\t            path, hash_, _, size, *_ = row.split(\",\")\n\t            new_path = Path(path)\n\t            files.append(\n\t                MovieFile(\n\t                    new_path.parent / \"usm\" / new_path.name,\n\t                    hash_,\n\t                    int(size),\n", "                ),\n\t            )\n\t        return files\n"]}
{"filename": "src/abc/abstract_file.py", "chunked_list": ["from abc import ABCMeta\n\tfrom pathlib import Path\n\tfrom typing import Generic, TypeVar\n\tfrom ..protocols import File\n\tT = TypeVar(\"T\")\n\tclass AbstractFile(File, Generic[T], metaclass=ABCMeta):\n\t    __slots__ = (\"_path\", \"_name\", \"_size\", \"_type\")\n\t    def __init__(\n\t        self,\n\t        path: Path | str,\n", "        type_: T,\n\t        size: int = 0,\n\t    ) -> None:\n\t        self._path: Path = Path(path)\n\t        self._name: str = self._path.name\n\t        self._type: T = type_\n\t        self._size: int = size\n\t    @property\n\t    def path(self) -> Path:\n\t        return self._path\n", "    @property\n\t    def name(self) -> str:\n\t        return self._name\n\t    @property\n\t    def size(self) -> int:\n\t        return self._size\n"]}
{"filename": "src/abc/__init__.py", "chunked_list": ["from .abstract_file import AbstractFile\n\tfrom .abstract_manifest_file import AbstractManifestFile\n\t__all__ = [\"AbstractFile\", \"AbstractManifestFile\"]\n"]}
{"filename": "src/abc/abstract_manifest_file.py", "chunked_list": ["from abc import ABCMeta\n\tfrom pathlib import Path\n\tfrom typing import Generic, TypeVar\n\tfrom urllib.request import urlretrieve\n\tfrom ..config import Config, ManifestType\n\tfrom ..protocols import Downloadable\n\tfrom .abstract_file import AbstractFile\n\tT = TypeVar(\"T\")\n\tclass AbstractManifestFile(\n\t    AbstractFile,\n", "    Downloadable,\n\t    Generic[T],\n\t    metaclass=ABCMeta,\n\t):\n\t    def __init__(\n\t        self,\n\t        path: Path | str,\n\t        hash_: str,\n\t        type_: T,\n\t        size: int = 0,\n", "        version: int = 0,\n\t    ) -> None:\n\t        AbstractFile.__init__(self, path, type_, size)\n\t        self._hash = hash_\n\t        self._version = version\n\t    @property\n\t    def url(self) -> str:\n\t        if type(self._type) == ManifestType:\n\t            endpoint = f\"{self._type.value % (self._version,self.name)}\"\n\t        else:\n", "            endpoint = f\"{self._type.value}/{self._hash[:2]}/{self._hash}\"\n\t        return f\"https://{Config.host.value}/{endpoint}\"\n\t    def download(self) -> None:\n\t        if self.path.exists():\n\t            if self.path.stat().st_size == self.size:\n\t                return\n\t        self.path.parent.mkdir(parents=True, exist_ok=True)\n\t        urlretrieve(self.url, self.path)\n\t        print(f\"DL {self.url} -> {self.path.absolute()}\")\n"]}
{"filename": "src/files/file_container.py", "chunked_list": ["import re\n\tfrom abc import abstractmethod\n\tfrom typing import Generic, TypeVar\n\tfrom ..protocols import File\n\tT = TypeVar(\"T\", bound=File)\n\tclass FileContainer(Generic[T]):\n\t    _files: list[T] | None = None\n\t    @abstractmethod\n\t    def _read(self) -> list[T]:\n\t        ...\n", "    @property\n\t    def files(self) -> list[T]:\n\t        if self._files is None:\n\t            self._files = self._read()\n\t        return self._files\n\t    def get_file(self, match: str) -> T | None:\n\t        for file in self.files:\n\t            if re.search(match, file.name):\n\t                return file\n\t        return None\n", "    def get_files(self, match: str) -> list[T]:\n\t        files: list[T] = []\n\t        for file in self.files:\n\t            if re.search(match, file.name):\n\t                files.append(file)\n\t        return files\n"]}
{"filename": "src/files/sound_file.py", "chunked_list": ["import os\n\tfrom pathlib import Path\n\tfrom ..abc import AbstractManifestFile\n\tfrom ..config import AssetType, Config\n\tfrom ..protocols import Extractable\n\tclass SoundFile(AbstractManifestFile, Extractable):\n\t    def __init__(self, path: Path | str, hash_: str, size: int = 0) -> None:\n\t        super().__init__(path, hash_, AssetType.SOUND, size)\n\t    def extract(self) -> None:\n\t        self.download()\n", "        if \".acb\" in self.name:\n\t            return\n\t        extract_path = self.path.parent.parent / (self.path.stem + \".wav\")\n\t        extract_path_2 = self.path.parent.parent / (self.path.stem + \"_1.wav\")\n\t        if extract_path.exists() or extract_path_2.exists():\n\t            return\n\t        print(\n\t            f\"{Config.vgmstream_path.absolute()}\"\n\t            f\" -S 0 {self.path.absolute()}\"\n\t            f\" -o {extract_path.parent.absolute()}/?n_?s.wav\"\n", "        )\n\t        stream = os.popen(\n\t            f\"{Config.vgmstream_path.absolute()}\"\n\t            f\" -S 0 {self.path.absolute()}\"\n\t            f\" -o {extract_path.parent.absolute()}/?n_?s.wav\"\n\t        )\n\t        stream.read()\n\t        files = [*extract_path.parent.glob(f\"{self.path.stem};*\")] + [\n\t            *extract_path.parent.glob(f\"{self.path.stem}_*\")\n\t        ]\n", "        for file in files:\n\t            rename = file.stem.split(\";\")[0]\n\t            file = file.replace(file.with_stem(rename).absolute())\n\t            print(f\"EX {self.name} -> {file.absolute()}\")\n"]}
{"filename": "src/files/__init__.py", "chunked_list": ["from .bundle_file import BundleFile\n\tfrom .file_container import FileContainer\n\tfrom .movie_file import MovieFile\n\tfrom .sound_file import SoundFile\n\t__all__ = [\n\t    \"BundleFile\",\n\t    \"FileContainer\",\n\t    \"MovieFile\",\n\t    \"SoundFile\",\n\t]\n"]}
{"filename": "src/files/movie_file.py", "chunked_list": ["import os\n\tfrom pathlib import Path\n\tfrom ..abc import AbstractManifestFile\n\tfrom ..config import AssetType, Config\n\tfrom ..protocols import Extractable\n\tclass MovieFile(AbstractManifestFile, Extractable):\n\t    def __init__(self, path: Path | str, hash_: str, size: int = 0) -> None:\n\t        super().__init__(path, hash_, AssetType.MOVIE, size)\n\t    def extract(self) -> None:\n\t        self.download()\n", "        extract_path = self.path.parent.parent / (self.path.stem + \".mp4\")\n\t        if extract_path.exists():\n\t            return\n\t        os.system(\n\t            f\"cd {Config.usmtoolkit_path.parent.absolute()}\"\n\t            f\" && {Config.usmtoolkit_path.name} convert\"\n\t            f\" -c {self.path.absolute()}\"\n\t            f\" -o {extract_path.parent.absolute()}\"\n\t        )\n\t        print(f\"EX {self.name} -> {extract_path.absolute()}\")\n"]}
{"filename": "src/files/bundle_file.py", "chunked_list": ["from __future__ import annotations\n\timport json\n\tfrom pathlib import Path\n\tfrom typing import TYPE_CHECKING, Any, cast\n\timport UnityPy  # type: ignore[import]\n\tfrom src.story_deserializer import deserialize_story\n\tfrom ..config import BundleType, Config\n\tfrom ..protocols import Extractable\n\tif TYPE_CHECKING:\n\t    from ..asset_bundle import AssetBundle\n", "class BundleFile(Extractable):\n\t    __slots__ = (\n\t        \"_parent_path\",\n\t        \"_object\",\n\t        \"_type\",\n\t        \"_data\",\n\t        \"image\",\n\t        \"script\",\n\t        \"container\",\n\t        \"_asset_name\",\n", "    )\n\t    def __init__(\n\t        self, pcr_file: AssetBundle, obj: UnityPy.environment.ObjectReader\n\t    ) -> None:\n\t        self._parent_path: Path = pcr_file.path.parent.parent\n\t        self._object: UnityPy.environment.ObjectReader | None = obj\n\t        self._type: BundleType = BundleType(obj.type.name)\n\t        self._data: Any = None\n\t        self.image: Any = None\n\t        self.script: Any = None\n", "        self.container: str | None = None\n\t        self._asset_name: str | None = None\n\t        # for Protocol\n\t        self._name = self.name\n\t        self._path = self.path\n\t        self._size = self.size\n\t    @property\n\t    def parent_path(self) -> Path:\n\t        return self._parent_path\n\t    @property\n", "    def type(self) -> BundleType:\n\t        return self._type\n\t    @property\n\t    def data(self) -> Any:\n\t        if self._data is None and self._object:\n\t            self._data = self._object.read()\n\t            self._object = None\n\t        return self._data\n\t    @property\n\t    def extention(self) -> str:\n", "        if self.is_image:\n\t            return Config().image_format\n\t        if self.is_text:\n\t            if \"storydata\" in self._asset_name:\n\t                return \".json\"\n\t            return \".txt\"\n\t        return \"\"\n\t    @property\n\t    def name(self) -> str:\n\t        if self._asset_name is None and self.data:\n", "            self._asset_name = self.data.name\n\t        if self._asset_name:\n\t            return self._asset_name + self.extention\n\t        else:\n\t            raise Exception(\"Name cannot be None.\")\n\t    @property\n\t    def size(self) -> int:\n\t        return 0\n\t    @property\n\t    def path(self) -> Path:\n", "        if self.data:\n\t            self.container = cast(str | None, self.data.container)\n\t        if self.container:\n\t            str_path = self.container.replace(\n\t                \"assets/_elementsresources/resources\", \"a\"\n\t            )\n\t            return Path(str_path).parent / self.name\n\t        else:\n\t            return self._parent_path / self.name\n\t    @property\n", "    def is_image(self) -> bool:\n\t        return self.type in [BundleType.TEXTURE_2D, BundleType.Sprite]\n\t    @property\n\t    def is_text(self) -> bool:\n\t        return self.type == BundleType.TEXT_ASSET\n\t    def extract(self) -> None:\n\t        if self.path.exists():\n\t            return\n\t        self.path.parent.mkdir(parents=True, exist_ok=True)\n\t        self.process_data()\n", "        if self.image:\n\t            self._extract_image()\n\t        elif self.script:\n\t            self._extract_text()\n\t        print(f\"EX {self.name} -> {self.path.absolute()}\")\n\t    def _extract_image(self):\n\t        self.image.save(self.path, lossless=True)\n\t    def _extract_text(self):\n\t        if \"storydata\" in self.name:\n\t            with self.path.open(\"w\", encoding=\"utf-8\") as f:\n", "                json.dump(\n\t                    deserialize_story(self.script),\n\t                    f,\n\t                    indent=4,\n\t                    ensure_ascii=False,\n\t                )\n\t        else:\n\t            self.path.write_bytes(self.script)\n\t    def process_data(self) -> None:\n\t        if self._data is None:\n", "            return\n\t        if self.is_image:\n\t            self.image = self.data.image\n\t        elif self.is_text:\n\t            self.script = bytes(self.data.script)\n\t        self._asset_name = self.data.name\n\t        self.container = self.data.container\n\t        self._data = None\n\t    def __getstate__(self) -> tuple[None, dict]:\n\t        self.process_data()\n", "        slot_dict: dict[str, Any] = {}\n\t        for attribute in self.__slots__:\n\t            slot_dict[attribute] = getattr(self, attribute)\n\t        return (None, slot_dict)\n"]}
