{"filename": "tests/conftest.py", "chunked_list": ["from pathlib import Path\n\timport pytest\n\t@pytest.fixture\n\tdef data_dir() -> Path:\n\t    here = Path(__file__)\n\t    return here.parent / \"data\"\n"]}
{"filename": "tests/functional_tests/test_comments.py", "chunked_list": ["import pytest\n\tfrom textual.app import App\n\tfrom textual_textarea import TextArea\n\tfrom textual_textarea.key_handlers import Cursor\n\t@pytest.mark.parametrize(\n\t    \"language,expected_marker\",\n\t    [\n\t        (\"python\", \"# \"),\n\t        (\"sql\", \"-- \"),\n\t        (\"mysql\", \"# \"),\n", "        (\"c\", \"// \"),\n\t    ],\n\t)\n\t@pytest.mark.asyncio\n\tasync def test_comments(app: App, language: str, expected_marker: str) -> None:\n\t    async with app.run_test() as pilot:\n\t        ta = app.query_one(TextArea)\n\t        ta.language = language\n\t        original_text = \"foo bar baz\"\n\t        ta.text = original_text\n", "        ta.cursor = Cursor(0, 0)\n\t        await pilot.press(\"ctrl+underscore\")  # alias for ctrl+/\n\t        assert ta.text == f\"{expected_marker}{original_text}\"\n"]}
{"filename": "tests/functional_tests/test_textarea.py", "chunked_list": ["from typing import List, Union\n\timport pytest\n\tfrom textual.app import App\n\tfrom textual_textarea import TextArea\n\tfrom textual_textarea.key_handlers import Cursor\n\t@pytest.mark.parametrize(\n\t    \"keys,lines,anchor,cursor,expected_lines,expected_anchor,expected_cursor\",\n\t    [\n\t        (\n\t            [\"ctrl+a\"],\n", "            [\"select \", \" foo \"],\n\t            None,\n\t            Cursor(1, 2),\n\t            None,\n\t            Cursor(0, 0),\n\t            Cursor(1, 4),\n\t        ),\n\t        (\n\t            [\"ctrl+shift+right\"],\n\t            [\"select \", \" foo \"],\n", "            None,\n\t            Cursor(0, 0),\n\t            None,\n\t            Cursor(0, 0),\n\t            Cursor(0, 6),\n\t        ),\n\t        (\n\t            [\"right\"],\n\t            [\"select \", \" foo \"],\n\t            Cursor(0, 0),\n", "            Cursor(0, 6),\n\t            None,\n\t            None,\n\t            Cursor(1, 0),\n\t        ),\n\t        (\n\t            [\"a\"],\n\t            [\"select \", \" foo \"],\n\t            None,\n\t            Cursor(1, 4),\n", "            [\"select \", \" fooa \"],\n\t            None,\n\t            Cursor(1, 5),\n\t        ),\n\t        (\n\t            [\"a\"],\n\t            [\"select \", \" foo \"],\n\t            Cursor(1, 0),\n\t            Cursor(1, 4),\n\t            [\"select \", \"a \"],\n", "            None,\n\t            Cursor(1, 1),\n\t        ),\n\t        (\n\t            [\"enter\"],\n\t            [\"a \", \"a \"],\n\t            None,\n\t            Cursor(1, 0),\n\t            [\"a \", \" \", \"a \"],\n\t            None,\n", "            Cursor(2, 0),\n\t        ),\n\t        (\n\t            [\"enter\"],\n\t            [\"a \", \"a \"],\n\t            None,\n\t            Cursor(1, 1),\n\t            [\"a \", \"a \", \" \"],\n\t            None,\n\t            Cursor(2, 0),\n", "        ),\n\t        (\n\t            [\"enter\"],\n\t            [\"a() \"],\n\t            None,\n\t            Cursor(0, 2),\n\t            [\"a( \", \"     \", \") \"],\n\t            None,\n\t            Cursor(1, 4),\n\t        ),\n", "        (\n\t            [\"enter\"],\n\t            [\" a() \"],\n\t            None,\n\t            Cursor(0, 3),\n\t            [\" a( \", \"     \", \" ) \"],\n\t            None,\n\t            Cursor(1, 4),\n\t        ),\n\t    ],\n", ")\n\t@pytest.mark.asyncio\n\tasync def test_keys(\n\t    app: App,\n\t    keys: List[str],\n\t    lines: List[str],\n\t    anchor: Union[Cursor, None],\n\t    cursor: Cursor,\n\t    expected_lines: Union[List[str], None],\n\t    expected_anchor: Union[Cursor, None],\n", "    expected_cursor: Cursor,\n\t) -> None:\n\t    if expected_lines is None:\n\t        expected_lines = lines\n\t    async with app.run_test() as pilot:\n\t        widget = app.query_one(TextArea)\n\t        input = widget.text_input\n\t        input.lines = lines.copy()\n\t        input.selection_anchor = anchor\n\t        input.cursor = cursor\n", "        for key in keys:\n\t            await pilot.press(key)\n\t        assert input.lines == expected_lines\n\t        assert input.selection_anchor == expected_anchor\n\t        assert input.cursor == expected_cursor\n\t@pytest.mark.asyncio\n\tasync def test_move_cursor(app: App) -> None:\n\t    async with app.run_test():\n\t        ta = app.query_one(TextArea)\n\t        ti = ta.text_input\n", "        ti.lines = [f\"{'X' * i} \" for i in range(10)]\n\t        assert ta.cursor == Cursor(0, 0)\n\t        for i in range(10):\n\t            ti.move_cursor(100, i)\n\t            assert ta.cursor == Cursor(i, i)\n\t            ti.move_cursor(0, i)\n\t            assert ta.cursor == Cursor(i, 0)\n\t        ti.move_cursor(-100, -100)\n\t        assert ta.cursor == Cursor(0, 0)\n\t        ti.move_cursor(-10, 5)\n", "        assert ta.cursor == Cursor(5, 0)\n\t        ti.move_cursor(5, -5)\n\t        assert ta.cursor == Cursor(0, 0)\n\t@pytest.mark.parametrize(\n\t    \"starting_anchor,starting_cursor,expected_clipboard\",\n\t    [\n\t        (Cursor(0, 5), Cursor(1, 5), [\"56789 \", \"01234\"]),\n\t        (Cursor(0, 0), Cursor(1, 0), [\"0123456789 \", \"\"]),\n\t    ],\n\t)\n", "@pytest.mark.asyncio\n\tasync def test_copy_paste(\n\t    app_all_clipboards: App,\n\t    starting_anchor: Cursor,\n\t    starting_cursor: Cursor,\n\t    expected_clipboard: List[str],\n\t) -> None:\n\t    original_text = \"0123456789\\n0123456789\\n0123456789\"\n\t    async with app_all_clipboards.run_test() as pilot:\n\t        ta = app_all_clipboards.query_one(TextArea)\n", "        ti = ta.text_input\n\t        ta.text = original_text\n\t        ti.selection_anchor = starting_anchor\n\t        ti.cursor = starting_cursor\n\t        await pilot.press(\"ctrl+c\")\n\t        assert ti.clipboard == expected_clipboard\n\t        assert ti.selection_anchor == starting_anchor\n\t        assert ti.cursor == starting_cursor\n\t        assert ta.text == original_text\n\t        await pilot.press(\"ctrl+u\")\n", "        assert ti.clipboard == expected_clipboard\n\t        assert ti.selection_anchor is None\n\t        assert ti.cursor == starting_cursor\n\t        assert ta.text == original_text\n\t        await pilot.press(\"ctrl+a\")\n\t        assert ti.selection_anchor == Cursor(0, 0)\n\t        assert ti.cursor == Cursor(\n\t            len(original_text.splitlines()) - 1, len(original_text.splitlines()[-1])\n\t        )\n\t        assert ti.clipboard == expected_clipboard\n", "        assert ta.text == original_text\n\t        await pilot.press(\"ctrl+u\")\n\t        assert ti.selection_anchor is None\n\t        assert ti.cursor == Cursor(\n\t            len(expected_clipboard) - 1, len(expected_clipboard[-1])\n\t        )\n\t        assert ti.clipboard == expected_clipboard\n\t        assert ta.text == \"\\n\".join([line.strip() for line in expected_clipboard])\n\t        await pilot.press(\"ctrl+a\")\n\t        await pilot.press(\"ctrl+x\")\n", "        assert ti.selection_anchor is None\n\t        assert ti.cursor == Cursor(0, 0)\n\t        assert ti.clipboard == expected_clipboard\n\t        assert ta.text == \"\"\n\t        await pilot.press(\"ctrl+v\")\n\t        assert ti.selection_anchor is None\n\t        assert ti.cursor == Cursor(\n\t            len(expected_clipboard) - 1, len(expected_clipboard[-1])\n\t        )\n\t        assert ti.clipboard == expected_clipboard\n", "        assert ta.text == \"\\n\".join([line.rstrip() for line in expected_clipboard])\n\t@pytest.mark.asyncio\n\tasync def test_text_property(app: App) -> None:\n\t    async with app.run_test():\n\t        ta = app.query_one(TextArea)\n\t        assert ta.text == \"\"\n\t        assert ta.selected_text == \"\"\n\t        ta.text = \"select\\nfoo\"\n\t        assert ta.text_input.lines == [\"select \", \"foo \"]\n\t        assert ta.selection_anchor is None\n", "        assert ta.selected_text == \"\"\n\t        # this input should be validated and cursor moved\n\t        # to EOF\n\t        ta.cursor = Cursor(100, 100)\n\t        assert ta.cursor == Cursor(1, 3)\n\t        assert ta.selection_anchor is None\n\t        assert ta.selected_text == \"\"\n\t        ta.selection_anchor = Cursor(0, 0)\n\t        assert ta.selection_anchor == Cursor(0, 0)\n\t        assert ta.selected_text == ta.text\n", "        ta.selection_anchor = Cursor(0, 1)\n\t        ta.cursor = Cursor(1, 1)\n\t        assert ta.selected_text == \"elect\\nf\"\n\t        ta.text_input.lines = [\"a \", \" \", \"b \", \"c \"]\n\t        assert ta.text == \"a\\n\\nb\\nc\"\n\t        ta.cursor = Cursor(3, 0)\n\t        assert ta.selection_anchor == Cursor(0, 1)\n\t        assert ta.selected_text == \"\\n\\nb\\n\"\n"]}
{"filename": "tests/functional_tests/__init__.py", "chunked_list": []}
{"filename": "tests/functional_tests/test_open.py", "chunked_list": ["from pathlib import Path\n\timport pytest\n\tfrom textual.app import App\n\tfrom textual.widgets import Input\n\tfrom textual_textarea import TextArea\n\t@pytest.mark.parametrize(\"filename\", [\"foo.py\", \"empty.py\"])\n\t@pytest.mark.asyncio\n\tasync def test_open(data_dir: Path, app: App, filename: str) -> None:\n\t    p = data_dir / \"test_open\" / filename\n\t    with open(p, \"r\") as f:\n", "        contents = f.read()\n\t    async with app.run_test() as pilot:\n\t        ta = app.query_one(TextArea)\n\t        assert ta.text == \"\"\n\t        starting_text = \"123\"\n\t        for key in starting_text:\n\t            await pilot.press(key)\n\t        assert ta.text == starting_text\n\t        await pilot.press(\"ctrl+o\")\n\t        open_input = ta.query_one(Input)\n", "        assert open_input.id and \"open\" in open_input.id\n\t        assert open_input.has_focus\n\t        for key in str(p):\n\t            await pilot.press(key)\n\t        await pilot.press(\"enter\")\n\t        assert ta.text == contents\n\t        assert ta.text_input.has_focus\n\t        # make sure the end of the buffer is formatted properly.\n\t        # these previously caused a crash.\n\t        await pilot.press(\"ctrl+end\")\n", "        assert ta.cursor.pos >= 0\n\t        await pilot.press(\"enter\")\n"]}
{"filename": "tests/functional_tests/conftest.py", "chunked_list": ["from typing import Type, Union\n\timport pytest\n\tfrom textual.app import App, ComposeResult, CSSPathType\n\tfrom textual.driver import Driver\n\tfrom textual_textarea.textarea import TextArea\n\tclass TextAreaApp(App, inherit_bindings=False):\n\t    def __init__(\n\t        self,\n\t        driver_class: Union[Type[Driver], None] = None,\n\t        css_path: Union[CSSPathType, None] = None,\n", "        watch_css: bool = False,\n\t        language: Union[str, None] = None,\n\t        use_system_clipboard: bool = True,\n\t    ):\n\t        self.language = language\n\t        self.use_system_clipboard = use_system_clipboard\n\t        super().__init__(driver_class, css_path, watch_css)\n\t    def compose(self) -> ComposeResult:\n\t        yield TextArea(\n\t            language=self.language, use_system_clipboard=self.use_system_clipboard\n", "        )\n\t    def on_mount(self) -> None:\n\t        ta = self.query_one(TextArea)\n\t        ta.focus()\n\t@pytest.fixture\n\tdef app() -> App:\n\t    app = TextAreaApp(language=\"python\")\n\t    return app\n\t@pytest.fixture(params=[False, True], ids=[\"no_sys_clipboard\", \"default\"])\n\tdef app_all_clipboards(request: pytest.FixtureRequest) -> App:\n", "    app = TextAreaApp(use_system_clipboard=request.param)\n\t    return app\n"]}
{"filename": "tests/data/test_open/empty.py", "chunked_list": []}
{"filename": "tests/data/test_open/foo.py", "chunked_list": ["def foo(bar: str, baz: int) -> None:\n\t    return\n"]}
{"filename": "tests/unit_tests/test_path_validator.py", "chunked_list": ["from pathlib import Path\n\timport pytest\n\tfrom textual_textarea.path_input import PathValidator\n\t@pytest.mark.parametrize(\n\t    \"relpath,dir_okay,file_okay,must_exist,expected_result\",\n\t    [\n\t        (\"foo\", True, True, True, True),\n\t        (\"foo\", True, True, False, True),\n\t        (\"foo\", True, False, True, True),\n\t        (\"foo\", True, False, False, True),\n", "        (\"foo\", False, True, True, False),\n\t        (\"foo\", False, True, False, False),\n\t        (\"foo\", False, False, True, False),\n\t        (\"foo\", False, False, False, False),\n\t        (\"bar\", True, True, True, True),\n\t        (\"bar\", True, True, False, True),\n\t        (\"bar\", True, False, True, True),\n\t        (\"bar\", True, False, False, True),\n\t        (\"bar\", False, True, True, False),\n\t        (\"bar\", False, True, False, False),\n", "        (\"bar\", False, False, True, False),\n\t        (\"bar\", False, False, False, False),\n\t        (\"baz\", True, True, True, False),\n\t        (\"baz\", True, True, False, True),\n\t        (\"baz\", True, False, True, False),\n\t        (\"baz\", True, False, False, True),\n\t        (\"baz\", False, True, True, False),\n\t        (\"baz\", False, True, False, True),\n\t        (\"baz\", False, False, True, False),\n\t        (\"baz\", False, False, False, True),\n", "        (\"foo/baz.txt\", True, True, True, True),\n\t        (\"foo/baz.txt\", True, True, False, True),\n\t        (\"foo/baz.txt\", True, False, True, False),\n\t        (\"foo/baz.txt\", True, False, False, False),\n\t        (\"foo/baz.txt\", False, True, True, True),\n\t        (\"foo/baz.txt\", False, True, False, True),\n\t        (\"foo/baz.txt\", False, False, True, False),\n\t        (\"foo/baz.txt\", False, False, False, False),\n\t    ],\n\t)\n", "def test_path_validator(\n\t    data_dir: Path,\n\t    relpath: str,\n\t    dir_okay: bool,\n\t    file_okay: bool,\n\t    must_exist: bool,\n\t    expected_result: bool,\n\t) -> None:\n\t    p = data_dir / \"test_validator\" / relpath\n\t    validator = PathValidator(dir_okay, file_okay, must_exist)\n", "    result = validator.validate(str(p))\n\t    assert result.is_valid == expected_result\n"]}
{"filename": "tests/unit_tests/test_key_handlers.py", "chunked_list": ["from typing import List\n\timport pytest\n\tfrom textual_textarea.key_handlers import Cursor, handle_arrow\n\t@pytest.mark.parametrize(\n\t    \"key,lines,cursor,expected\",\n\t    [\n\t        (\"right\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 1)),\n\t        (\"left\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 0)),\n\t        (\"up\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 0)),\n\t        (\"down\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 8)),\n", "        (\"right\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 2)),\n\t        (\"left\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 0)),\n\t        (\"up\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 0)),\n\t        (\"down\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 8)),\n\t        (\"right\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 8)),\n\t        (\"left\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 7)),\n\t        (\"up\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 0)),\n\t        (\"down\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 8)),\n\t        (\"right\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 1)),\n\t        (\"left\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 0)),\n", "        (\"up\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 0)),\n\t        (\"down\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(1, 0)),\n\t        (\"right\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(1, 0)),\n\t        (\"left\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(0, 7)),\n\t        (\"up\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(0, 0)),\n\t        (\"down\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(1, 6)),\n\t        (\"right\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(1, 1)),\n\t        (\"left\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(0, 8)),\n\t        (\"up\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(0, 0)),\n\t        (\"down\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(1, 6)),\n", "        (\"right\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(1, 6)),\n\t        (\"left\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(1, 5)),\n\t        (\"up\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(0, 6)),\n\t        (\"down\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(1, 6)),\n\t        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 6)),\n\t        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 0)),\n\t        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 6), Cursor(0, 8)),\n\t        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 6), Cursor(0, 0)),\n\t        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 7), Cursor(0, 8)),\n\t        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 7), Cursor(0, 0)),\n", "        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 8)),\n\t        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 7)),\n\t        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 6)),\n\t        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 0)),\n\t        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 1), Cursor(0, 6)),\n\t        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 1), Cursor(0, 0)),\n\t        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 6), Cursor(0, 8)),\n\t        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 6), Cursor(0, 0)),\n\t        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 7), Cursor(0, 8)),\n\t        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 7), Cursor(0, 0)),\n", "        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(1, 4)),\n\t        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(0, 7)),\n\t        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(1, 4)),\n\t        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(0, 7)),\n\t        (\"ctrl+left\", [\"    select 1 \", \"    from a \"], Cursor(1, 4), Cursor(1, 0)),\n\t        (\"ctrl+right\", [\"    select 1 \", \"    from a \"], Cursor(1, 0), Cursor(1, 8)),\n\t        (\"ctrl+right\", [\"sum(foo) \"], Cursor(0, 0), Cursor(0, 3)),\n\t        (\"ctrl+right\", [\"sum(foo) \"], Cursor(0, 3), Cursor(0, 7)),\n\t        (\"ctrl+right\", [\"sum(foo) \"], Cursor(0, 7), Cursor(0, 8)),\n\t        (\"ctrl+left\", [\"sum(foo) \"], Cursor(0, 8), Cursor(0, 4)),\n", "        (\"ctrl+left\", [\"sum(foo) \"], Cursor(0, 4), Cursor(0, 0)),\n\t    ],\n\t)\n\tdef test_arrows(key: str, lines: List[str], cursor: Cursor, expected: Cursor) -> None:\n\t    actual = handle_arrow(key, lines, cursor)\n\t    assert actual == expected\n"]}
{"filename": "src/textual_textarea/colors.py", "chunked_list": ["from typing import NamedTuple\n\tfrom rich.syntax import PygmentsSyntaxTheme\n\tfrom textual.color import BLACK, WHITE, Color\n\tclass WidgetColors(NamedTuple):\n\t    contrast_text_color: Color\n\t    bgcolor: Color\n\t    selection_bgcolor: Color\n\t    @classmethod\n\t    def from_theme(cls, theme: str) -> \"WidgetColors\":\n\t        theme_background_style = PygmentsSyntaxTheme(theme).get_background_style()\n", "        if (\n\t            theme_background_style is not None\n\t            and theme_background_style.bgcolor is not None\n\t        ):\n\t            t_color = Color.from_rich_color(theme_background_style.bgcolor)\n\t            bgcolor = t_color\n\t            contrast_text_color = t_color.get_contrast_text()\n\t            if t_color.brightness >= 0.5:\n\t                selection_bgcolor = t_color.darken(0.10)\n\t            else:\n", "                selection_bgcolor = t_color.lighten(0.10)\n\t            return WidgetColors(contrast_text_color, bgcolor, selection_bgcolor)\n\t        else:\n\t            return WidgetColors(BLACK, WHITE, Color.parse(\"#aaaaaa\"))\n"]}
{"filename": "src/textual_textarea/__main__.py", "chunked_list": ["import sys\n\tfrom textual.app import App, ComposeResult\n\tfrom textual_textarea import TextArea\n\tclass TextApp(App, inherit_bindings=False):\n\t    def compose(self) -> ComposeResult:\n\t        try:\n\t            language = sys.argv[1]\n\t        except IndexError:\n\t            language = \"python\"\n\t        yield TextArea(language=language, theme=\"monokai\", use_system_clipboard=True)\n", "    def on_mount(self) -> None:\n\t        ta = self.query_one(TextArea)\n\t        ta.focus()\n\tapp = TextApp()\n\tapp.run()\n"]}
{"filename": "src/textual_textarea/error_modal.py", "chunked_list": ["from typing import Union\n\tfrom textual.app import ComposeResult\n\tfrom textual.containers import Vertical, VerticalScroll\n\tfrom textual.screen import ModalScreen\n\tfrom textual.widgets import Static\n\tclass ErrorModal(ModalScreen):\n\t    DEFAULT_CSS = \"\"\"\n\t        ErrorModal {\n\t            align: center middle;\n\t            padding: 0;\n", "        }\n\t        #error_modal__outer {\n\t            border: round $error;\n\t            background: $surface;\n\t            margin: 5 10;\n\t            padding: 1 2;\n\t            max-width: 88;\n\t        }\n\t        #error_modal__header {\n\t            dock: top;\n", "            color: $text-muted;\n\t            margin: 0 0 1 0;\n\t            padding: 0 1;\n\t        }\n\t        #error_modal__inner {\n\t            border: round $panel-lighten-1;\n\t            padding: 1 1 1 2;\n\t        }\n\t        #error_modal__info {\n\t            padding: 0 3 0 0;\n", "        }\n\t        #error_modal__footer {\n\t            dock: bottom;\n\t            color: $text-muted;\n\t            margin: 1 0 0 0;\n\t            padding: 0 1;\n\t        }\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n", "        title: str,\n\t        header: str,\n\t        error: BaseException,\n\t        name: Union[str, None] = None,\n\t        id: Union[str, None] = None,\n\t        classes: Union[str, None] = None,\n\t    ) -> None:\n\t        self.title = title\n\t        self.header = header\n\t        self.error = error\n", "        super().__init__(name, id, classes)\n\t    def compose(self) -> ComposeResult:\n\t        with Vertical(id=\"error_modal__outer\"):\n\t            yield Static(self.header, id=\"error_modal__header\")\n\t            with Vertical(id=\"error_modal__inner\"):\n\t                with VerticalScroll():\n\t                    yield Static(str(self.error), id=\"error_modal__info\")\n\t            yield Static(\"Press any key to continue.\", id=\"error_modal__footer\")\n\t    def on_mount(self) -> None:\n\t        container = self.query_one(\"#error_modal__outer\")\n", "        container.border_title = self.title\n\t    def on_key(self) -> None:\n\t        self.app.pop_screen()\n\t        self.app.action_focus_next()\n"]}
{"filename": "src/textual_textarea/comments.py", "chunked_list": ["INLINE_MARKERS = {\n\t    \"abap\": '\"',\n\t    \"actionscript\": \"//\",\n\t    \"as\": \"//\",\n\t    \"actionscript3\": \"//\",\n\t    \"as3\": \"//\",\n\t    \"ada\": \"--\",\n\t    \"ada95\": \"--\",\n\t    \"ada2005\": \"--\",\n\t    \"antlr-objc\": \"//\",\n", "    \"apl\": \"⍝\",\n\t    \"applescript\": \"--\",\n\t    \"autohotkey\": \";\",\n\t    \"ahk\": \";\",\n\t    \"autoit\": \";\",\n\t    \"basemake\": \"#\",\n\t    \"bash\": \"#\",\n\t    \"sh\": \"#\",\n\t    \"ksh\": \"#\",\n\t    \"zsh\": \"#\",\n", "    \"shell\": \"#\",\n\t    \"batch\": \"::\",\n\t    \"bat\": \"::\",\n\t    \"dosbatch\": \"::\",\n\t    \"winbatch\": \"::\",\n\t    \"bbcbasic\": \"REM\",\n\t    \"blitzbasic\": \"REM\",\n\t    \"b3d\": \"REM\",\n\t    \"bplus\": \"REM\",\n\t    \"boo\": \"#\",\n", "    \"c\": \"//\",\n\t    \"csharp\": \"//\",\n\t    \"c#\": \"//\",\n\t    \"cs\": \"//\",\n\t    \"cpp\": \"//\",\n\t    \"c++\": \"//\",\n\t    \"cbmbas\": \"REM\",\n\t    \"clojure\": \";\",\n\t    \"clj\": \";\",\n\t    \"clojurescript\": \";\",\n", "    \"cljs\": \";\",\n\t    \"cmake\": \"#\",\n\t    \"cobol\": \"*>\",\n\t    \"cobolfree\": \"*>\",\n\t    \"common-lisp\": \";\",\n\t    \"cl\": \";\",\n\t    \"lisp\": \";\",\n\t    \"d\": \"//\",\n\t    \"delphi\": \"//\",\n\t    \"pas\": \"//\",\n", "    \"pascal\": \"//\",\n\t    \"objectpascal\": \"//\",\n\t    \"eiffel\": \"--\",\n\t    \"elixir\": \"#\",\n\t    \"ex\": \"#\",\n\t    \"exs\": \"#\",\n\t    \"iex\": \"#\",\n\t    \"elm\": \"--\",\n\t    \"emacs-lisp\": \";\",\n\t    \"elisp\": \";\",\n", "    \"emacs\": \";\",\n\t    \"erlang\": \"%\",\n\t    \"erl\": \"%\",\n\t    \"fsharp\": \"//\",\n\t    \"f#\": \"//\",\n\t    \"factor\": \"!\",\n\t    \"fish\": \"#\",\n\t    \"fishshell\": \"#\",\n\t    \"forth\": \"\\\\\",\n\t    \"fortran\": \"!\",\n", "    \"f90\": \"!\",\n\t    \"fortranfixed\": \"!\",\n\t    \"go\": \"//\",\n\t    \"golang\": \"//\",\n\t    \"haskell\": \"--\",\n\t    \"hs\": \"--\",\n\t    \"inform6\": \"!\",\n\t    \"i6\": \"!\",\n\t    \"i6t\": \"!\",\n\t    \"inform7\": \"!\",\n", "    \"i7\": \"!\",\n\t    \"j\": \"NB.\",\n\t    \"java\": \"//\",\n\t    \"jsp\": \"//\",\n\t    \"javascript\": \"//\",\n\t    \"js\": \"//\",\n\t    \"julia\": \"#\",\n\t    \"jl\": \"#\",\n\t    \"jlcon\": \"#\",\n\t    \"julia-repl\": \"#\",\n", "    \"kotlin\": \"//\",\n\t    \"lua\": \"--\",\n\t    \"make\": \"#\",\n\t    \"makefile\": \"#\",\n\t    \"mf\": \"#\",\n\t    \"bsdmake\": \"#\",\n\t    \"matlab\": \"%\",\n\t    \"matlabsession\": \"%\",\n\t    \"monkey\": \"'\",\n\t    \"mysql\": \"#\",\n", "    \"newlisp\": \";\",\n\t    \"nimrod\": \"#\",\n\t    \"nim\": \"#\",\n\t    \"objective-c\": \"//\",\n\t    \"objectivec\": \"//\",\n\t    \"obj-c\": \"//\",\n\t    \"objc\": \"//\",\n\t    \"objective-c++\": \"//\",\n\t    \"objectivec++\": \"//\",\n\t    \"obj-c++\": \"//\",\n", "    \"objc++\": \"//\",\n\t    \"perl\": \"#\",\n\t    \"pl\": \"#\",\n\t    \"perl6\": \"#\",\n\t    \"pl6\": \"#\",\n\t    \"raku\": \"#\",\n\t    \"php\": \"#\",\n\t    \"php3\": \"#\",\n\t    \"php4\": \"#\",\n\t    \"php5\": \"#\",\n", "    \"plpgsql\": \"--\",\n\t    \"psql\": \"--\",\n\t    \"postgresql-console\": \"--\",\n\t    \"postgres-console\": \"--\",\n\t    \"postgres-explain\": \"--\",\n\t    \"postgresql\": \"--\",\n\t    \"postgres\": \"--\",\n\t    \"postscript\": \"%\",\n\t    \"postscr\": \"%\",\n\t    \"powershell\": \"#\",\n", "    \"pwsh\": \"#\",\n\t    \"posh\": \"#\",\n\t    \"ps1\": \"#\",\n\t    \"psm1\": \"#\",\n\t    \"pwsh-session\": \"#\",\n\t    \"ps1con\": \"#\",\n\t    \"prolog\": \"%\",\n\t    \"python\": \"#\",\n\t    \"py\": \"#\",\n\t    \"sage\": \"#\",\n", "    \"python3\": \"#\",\n\t    \"py3\": \"#\",\n\t    \"python2\": \"#\",\n\t    \"py2\": \"#\",\n\t    \"py2tb\": \"#\",\n\t    \"pycon\": \"#\",\n\t    \"pytb\": \"#\",\n\t    \"py3tb\": \"#\",\n\t    \"py+ul4\": \"#\",\n\t    \"qbasic\": \"REM\",\n", "    \"basic\": \"REM\",\n\t    \"ragel-ruby\": \"#\",\n\t    \"ragel-rb\": \"#\",\n\t    \"rebol\": \";\",\n\t    \"red\": \";\",\n\t    \"red/system\": \";\",\n\t    \"ruby\": \"#\",\n\t    \"rb\": \"#\",\n\t    \"duby\": \"#\",\n\t    \"rbcon\": \"#\",\n", "    \"irb\": \"#\",\n\t    \"rust\": \"//\",\n\t    \"rs\": \"//\",\n\t    \"sass\": \"//\",\n\t    \"scala\": \"//\",\n\t    \"scheme\": \";\",\n\t    \"scm\": \";\",\n\t    \"sql\": \"--\",\n\t    \"sql+jinja\": \"--\",\n\t    \"sqlite3\": \"--\",\n", "    \"swift\": \"//\",\n\t    \"tex\": \"%\",\n\t    \"latex\": \"%\",\n\t    \"tsql\": \"--\",\n\t    \"t-sql\": \"--\",\n\t    \"vbscript\": \"'\",\n\t    \"vhdl\": \"--\",\n\t    \"wast\": \";;\",\n\t    \"wat\": \";;\",\n\t    \"yaml\": \"#\",\n", "    \"yaml+jinja\": \"#\",\n\t    \"salt\": \"#\",\n\t    \"sls\": \"#\",\n\t    \"zig\": \"//\",\n\t}\n"]}
{"filename": "src/textual_textarea/__init__.py", "chunked_list": ["from textual_textarea.messages import TextAreaCursorMoved\n\tfrom textual_textarea.path_input import CancelPathInput, PathInput\n\tfrom textual_textarea.textarea import TextArea\n\t__all__ = [\"TextArea\", \"PathInput\", \"CancelPathInput\", \"TextAreaCursorMoved\"]\n"]}
{"filename": "src/textual_textarea/containers.py", "chunked_list": ["from typing import Union\n\tfrom textual.containers import Container, ScrollableContainer\n\tfrom textual.widget import Widget\n\tfrom textual_textarea.colors import WidgetColors\n\tclass TextContainer(\n\t    ScrollableContainer,\n\t    inherit_bindings=False,\n\t    can_focus=False,\n\t    can_focus_children=True,\n\t):\n", "    DEFAULT_CSS = \"\"\"\n\t        TextContainer {\n\t            height: 1fr;\n\t            width: 100%\n\t        }\n\t    \"\"\"\n\tclass FooterContainer(\n\t    Container,\n\t    inherit_bindings=False,\n\t    can_focus=False,\n", "    can_focus_children=True,\n\t):\n\t    DEFAULT_CSS = \"\"\"\n\t        FooterContainer {\n\t            dock: bottom;\n\t            height: auto;\n\t            width: 100%\n\t        }\n\t    \"\"\"\n\t    def __init__(\n", "        self,\n\t        theme_colors: WidgetColors,\n\t        *children: Widget,\n\t        name: Union[str, None] = None,\n\t        id: Union[str, None] = None,\n\t        classes: Union[str, None] = None,\n\t        disabled: bool = False,\n\t    ) -> None:\n\t        super().__init__(\n\t            *children, name=name, id=id, classes=classes, disabled=disabled\n", "        )\n\t        self.theme_colors = theme_colors\n"]}
{"filename": "src/textual_textarea/textarea.py", "chunked_list": ["from math import ceil, floor\n\tfrom os.path import expanduser\n\tfrom typing import List, Tuple, Union\n\timport pyperclip\n\tfrom rich.console import RenderableType\n\tfrom rich.style import Style\n\tfrom rich.syntax import Syntax\n\tfrom textual import events\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n", "from textual.reactive import reactive\n\tfrom textual.widget import Widget\n\tfrom textual.widgets import Input, Label, Static\n\tfrom textual_textarea.colors import WidgetColors\n\tfrom textual_textarea.comments import INLINE_MARKERS\n\tfrom textual_textarea.containers import FooterContainer, TextContainer\n\tfrom textual_textarea.error_modal import ErrorModal\n\tfrom textual_textarea.key_handlers import Cursor, handle_arrow\n\tfrom textual_textarea.messages import TextAreaCursorMoved, TextAreaScrollOne\n\tfrom textual_textarea.path_input import PathInput\n", "from textual_textarea.serde import deserialize_lines, serialize_lines\n\tBRACKETS = {\n\t    \"(\": \")\",\n\t    \"[\": \"]\",\n\t    \"{\": \"}\",\n\t}\n\tCLOSERS = {'\"': '\"', \"'\": \"'\", **BRACKETS}\n\tTAB_SIZE = 4\n\tclass TextInput(Static, can_focus=True):\n\t    DEFAULT_CSS = \"\"\"\n", "        TextInput {\n\t            height: auto;\n\t            width: auto;\n\t            padding: 0 1;\n\t        }\n\t    \"\"\"\n\t    lines: reactive[List[str]] = reactive(lambda: list(\" \"))\n\t    cursor: reactive[Cursor] = reactive(Cursor(0, 0))\n\t    selection_anchor: reactive[Union[Cursor, None]] = reactive(None)\n\t    clipboard: List[str] = list()\n", "    cursor_visible: reactive[bool] = reactive(True)\n\t    use_system_clipboard: bool = True\n\t    language: reactive[Union[str, None]] = reactive(None)\n\t    def __init__(\n\t        self,\n\t        theme_colors: WidgetColors,\n\t        language: Union[str, None] = None,\n\t        theme: str = \"monokai\",\n\t        use_system_clipboard: bool = True,\n\t    ) -> None:\n", "        super().__init__()\n\t        self.theme_colors = theme_colors\n\t        self.language = language\n\t        self.theme = theme\n\t        self.use_system_clipboard = use_system_clipboard\n\t    def on_mount(self) -> None:\n\t        self.blink_timer = self.set_interval(\n\t            0.5,\n\t            self._toggle_cursor,\n\t            pause=not self.has_focus,\n", "        )\n\t    def on_focus(self) -> None:\n\t        self.cursor_visible = True\n\t        self.blink_timer.reset()\n\t        self._scroll_to_cursor()\n\t        self.update(self._content)\n\t    def on_blur(self) -> None:\n\t        self.blink_timer.pause()\n\t        self.cursor_visible = False\n\t        self.update(self._content)\n", "    def on_mouse_down(self, event: events.MouseDown) -> None:\n\t        \"\"\"\n\t        Moves the anchor and cursor to the click.\n\t        \"\"\"\n\t        event.stop()\n\t        self.cursor_visible = True\n\t        self.blink_timer.reset()\n\t        self.selection_anchor = Cursor.from_mouse_event(event)\n\t        self.move_cursor(event.x - 1, event.y)\n\t        self.focus()\n", "    def on_mouse_move(self, event: events.MouseMove) -> None:\n\t        \"\"\"\n\t        Updates the cursor if the button is pressed while the mouse\n\t        is moving.\n\t        \"\"\"\n\t        if event.button == 1:\n\t            self.move_cursor(event.x - 1, event.y)\n\t    def on_mouse_up(self, event: events.MouseUp) -> None:\n\t        \"\"\"\n\t        Moves the cursor to the click.\n", "        \"\"\"\n\t        event.stop()\n\t        self.cursor_visible = True\n\t        self.blink_timer.reset()\n\t        if self.selection_anchor == Cursor.from_mouse_event(event):\n\t            # simple click\n\t            self.selection_anchor = None\n\t        else:\n\t            self.move_cursor(event.x - 1, event.y)\n\t        self.focus()\n", "    def on_click(self, event: events.Click) -> None:\n\t        \"\"\"\n\t        Click duplicates MouseUp and MouseDown, so we just capture and kill this event.\n\t        \"\"\"\n\t        event.stop()\n\t    def on_paste(self, event: events.Paste) -> None:\n\t        \"\"\"\n\t        If the user hits ctrl+v, we don't get that keypress;\n\t        we get a Paste event instead.\n\t        This ignores the contents of the Paste message and mimics the behavior of\n", "        ctrl+u.\n\t        \"\"\"\n\t        event.stop()\n\t        self.cursor_visible = True\n\t        self.blink_timer.reset()\n\t        self._insert_clipboard_at_selection(self.selection_anchor, self.cursor)\n\t        self.selection_anchor = None\n\t        self.update(self._content)\n\t    def on_key(self, event: events.Key) -> None:\n\t        self.cursor_visible = True\n", "        self.blink_timer.reset()\n\t        selection_before = self.selection_anchor\n\t        # set selection_anchor if it's unset\n\t        if event.key == \"shift+delete\":\n\t            pass  # todo: shift+delete should delete the whole line\n\t        elif event.key == \"shift+tab\":\n\t            pass\n\t        elif event.key in (\n\t            \"ctrl+underscore\",\n\t            \"ctrl+`\",\n", "            \"ctrl+@\",\n\t            \"ctrl+s\",\n\t            \"ctrl+c\",\n\t            \"ctrl+enter\",\n\t            \"ctrl+j\",\n\t            \"ctrl+e\",\n\t            \"f1\",\n\t            \"f2\",\n\t            \"f3\",\n\t            \"f4\",\n", "            \"f5\",\n\t            \"f6\",\n\t            \"f7\",\n\t            \"f8\",\n\t            \"f9\",\n\t            \"f10\",\n\t            \"f11\",\n\t            \"f12\",\n\t        ):\n\t            pass  #  these should maintain selection\n", "        elif event.key == \"ctrl+a\":\n\t            self.selection_anchor = Cursor(0, 0)\n\t        elif selection_before is None and \"shift\" in event.key:\n\t            self.selection_anchor = self.cursor\n\t        elif selection_before is not None and \"shift\" not in event.key:\n\t            self.selection_anchor = None\n\t        # set cursor and modify lines if necessary\n\t        if event.key in (\n\t            \"apostrophe\",\n\t            \"quotation_mark\",\n", "            \"left_parenthesis\",\n\t            \"left_square_bracket\",\n\t            \"left_curly_bracket\",\n\t            \"right_parenthesis\",\n\t            \"right_square_bracket\",\n\t            \"right_curly_bracket\",\n\t        ):\n\t            assert event.character is not None\n\t            if selection_before is None:\n\t                self._insert_closed_character_at_cursor(event.character, self.cursor)\n", "            elif event.key in (\n\t                \"right_parenthesis\",\n\t                \"right_square_bracket\",\n\t                \"right_curly_bracket\",\n\t            ):\n\t                self._delete_selection(selection_before, self.cursor)\n\t                self._insert_character_at_cursor(event.character, self.cursor)\n\t                self.cursor = Cursor(\n\t                    lno=self.cursor.lno, pos=self.cursor.pos + len(event.character)\n\t                )\n", "            else:\n\t                self._insert_characters_around_selection(\n\t                    event.character, selection_before, self.cursor\n\t                )\n\t        elif event.key in (\"pageup\", \"shift+pageup\"):\n\t            event.stop()\n\t            self.move_cursor(\n\t                x=self.cursor.pos, y=(self.cursor.lno - self._visible_height() + 1)\n\t            )\n\t        elif event.key in (\"pagedown\", \"shift+pagedown\"):\n", "            event.stop()\n\t            self.move_cursor(\n\t                x=self.cursor.pos, y=(self.cursor.lno + self._visible_height() - 1)\n\t            )\n\t        elif event.key in (\"ctrl+up\", \"ctrl+down\"):\n\t            event.stop()\n\t            self.post_message(TextAreaScrollOne(direction=event.key.split(\"+\")[1]))\n\t        elif any([dir in event.key for dir in [\"left\", \"right\", \"up\", \"down\"]]):\n\t            event.stop()\n\t            self.cursor = handle_arrow(event.key, self.lines, self.cursor)\n", "        elif event.key in (\"home\", \"shift+home\"):\n\t            event.stop()\n\t            self.cursor = Cursor(self.cursor.lno, 0)\n\t        elif event.key in (\"end\", \"shift+end\"):\n\t            event.stop()\n\t            self.cursor = Cursor(self.cursor.lno, len(self.lines[self.cursor.lno]) - 1)\n\t        elif event.key == \"ctrl+home\":\n\t            event.stop()\n\t            self.cursor = Cursor(0, 0)\n\t        elif event.key in (\"ctrl+end\", \"ctrl+a\"):\n", "            event.stop()\n\t            self.cursor = Cursor(lno=len(self.lines) - 1, pos=len(self.lines[-1]) - 1)\n\t        elif event.key == \"ctrl+underscore\":  # actually ctrl+/\n\t            event.stop()\n\t            if self.inline_comment_marker:\n\t                lines, first, last = self._get_selected_lines(selection_before)\n\t                stripped_lines = [line.lstrip() for line in lines]\n\t                indents = [len(line) - len(line.lstrip()) for line in lines]\n\t                if all(\n\t                    [\n", "                        line.startswith(self.inline_comment_marker)\n\t                        for line in stripped_lines\n\t                    ]\n\t                ):\n\t                    no_comment_lines = [\n\t                        line[len(self.inline_comment_marker) :].lstrip()\n\t                        for line in stripped_lines\n\t                    ]\n\t                    self.lines[first.lno : last.lno + 1] = [\n\t                        f\"{' ' * indent}{line}\"\n", "                        for indent, line in zip(indents, no_comment_lines)\n\t                    ]\n\t                    self.move_cursor(\n\t                        self.cursor.pos - len(self.inline_comment_marker) - 1,\n\t                        self.cursor.lno,\n\t                    )\n\t                    if selection_before:\n\t                        self.move_selection_anchor(\n\t                            selection_before.pos - len(self.inline_comment_marker) - 1,\n\t                            selection_before.lno,\n", "                        )\n\t                else:\n\t                    self.lines[first.lno : last.lno + 1] = [\n\t                        f\"{' ' * indent}{self.inline_comment_marker} {stripped_line}\"\n\t                        for indent, stripped_line in zip(indents, stripped_lines)\n\t                    ]\n\t                    self.move_cursor(\n\t                        self.cursor.pos + len(self.inline_comment_marker) + 1,\n\t                        self.cursor.lno,\n\t                    )\n", "                    if selection_before:\n\t                        self.move_selection_anchor(\n\t                            selection_before.pos + len(self.inline_comment_marker) + 1,\n\t                            selection_before.lno,\n\t                        )\n\t        elif event.key in (\"ctrl+c\", \"ctrl+x\"):\n\t            event.stop()\n\t            if selection_before:\n\t                lines, first, last = self._get_selected_lines(selection_before)\n\t            else:  # no selection, copy whole line\n", "                lines, first, last = (\n\t                    [self.lines[self.cursor.lno], \"\"],\n\t                    Cursor(self.cursor.lno, 0),\n\t                    Cursor(self.cursor.lno, len(self.lines[self.cursor.lno])),\n\t                )\n\t            lines[-1] = lines[-1][: last.pos]\n\t            lines[0] = lines[0][first.pos :]\n\t            self.clipboard = lines.copy()\n\t            if self.use_system_clipboard:\n\t                try:\n", "                    pyperclip.copy(serialize_lines(self.clipboard))\n\t                except pyperclip.PyperclipException:\n\t                    # no system clipboard; common in CI runners\n\t                    pass\n\t            self.log(f\"copied to clipboard: {self.clipboard}\")\n\t            if event.key == \"ctrl+x\":\n\t                self._delete_selection(first, last)\n\t                new_lno = min(first.lno, len(self.lines) - 1)\n\t                self.cursor = Cursor(\n\t                    new_lno, min(first.pos, len(self.lines[new_lno]) - 1)\n", "                )\n\t        elif event.key in (\"ctrl+u\", \"ctrl+v\"):\n\t            event.stop()\n\t            self._insert_clipboard_at_selection(selection_before, self.cursor)\n\t        elif event.key == \"tab\":\n\t            event.stop()\n\t            lines, first, last = self._get_selected_lines(selection_before)\n\t            # in some cases, selections are replaced with four spaces\n\t            if first.lno == last.lno and (\n\t                first.pos == last.pos\n", "                or first.pos != 0\n\t                or last.pos != len(self.lines[self.cursor.lno]) - 1\n\t            ):\n\t                self._delete_selection(first, last)\n\t                indent = TAB_SIZE - first.pos % TAB_SIZE\n\t                self._insert_character_at_cursor(\" \" * indent, first)\n\t                self.cursor = Cursor(lno=first.lno, pos=first.pos + indent)\n\t            # usually, selected lines are prepended with four-ish spaces\n\t            else:\n\t                self._indent_selection(selection_before, self.cursor, kind=\"indent\")\n", "        elif event.key == \"shift+tab\":\n\t            event.stop()\n\t            self._indent_selection(selection_before, self.cursor, kind=\"dedent\")\n\t        elif event.key == \"enter\":\n\t            event.stop()\n\t            old_lines, first, last = self._get_selected_lines(selection_before)\n\t            head = f\"{old_lines[0][:first.pos]} \"\n\t            tail = f\"{old_lines[-1][last.pos:]}\"\n\t            if old_lines[0].isspace():\n\t                indent = 0\n", "            else:\n\t                indent = len(old_lines[0]) - len(old_lines[0].lstrip())\n\t            char_before = self._get_character_before_cursor(first)\n\t            if char_before in BRACKETS and BRACKETS[\n\t                char_before\n\t            ] == self._get_character_at_cursor(last):\n\t                new_indent = indent + TAB_SIZE - (indent % TAB_SIZE)\n\t                self.lines[first.lno : last.lno + 1] = [\n\t                    head,\n\t                    f\"{' ' * new_indent} \",\n", "                    f\"{' ' * indent}{tail.lstrip()}\",\n\t                ]\n\t                self.cursor = Cursor(first.lno + 1, new_indent)\n\t            else:\n\t                self.lines[first.lno : last.lno + 1] = [\n\t                    head,\n\t                    f\"{' ' * indent}{tail.lstrip() or ' '}\",\n\t                ]\n\t                self.cursor = Cursor(first.lno + 1, min(first.pos, indent))\n\t        elif event.key == \"delete\":\n", "            event.stop()\n\t            if selection_before is None:\n\t                anchor = self.cursor\n\t                cursor = handle_arrow(\"right\", self.lines, self.cursor)\n\t            else:\n\t                anchor = selection_before\n\t                cursor = self.cursor\n\t            self._delete_selection(anchor, cursor)\n\t        elif event.key == \"backspace\":\n\t            event.stop()\n", "            if selection_before is None:\n\t                anchor = self.cursor\n\t                cursor = handle_arrow(\"left\", self.lines, self.cursor)\n\t            else:\n\t                anchor = selection_before\n\t                cursor = self.cursor\n\t            self._delete_selection(anchor, cursor)\n\t        elif event.is_printable:\n\t            event.stop()\n\t            assert event.character is not None\n", "            if selection_before is not None:\n\t                self._delete_selection(selection_before, self.cursor)\n\t            self._insert_character_at_cursor(event.character, self.cursor)\n\t            self.cursor = Cursor(\n\t                lno=self.cursor.lno, pos=self.cursor.pos + len(event.character)\n\t            )\n\t        self.update(self._content)\n\t    def watch_cursor(self) -> None:\n\t        self._scroll_to_cursor()\n\t    def watch_language(self, language: str) -> None:\n", "        self.inline_comment_marker = INLINE_MARKERS.get(language)\n\t    @property\n\t    def _content(self) -> RenderableType:\n\t        syntax = Syntax(\n\t            \"\\n\".join(self.lines),\n\t            lexer=self.language,\n\t            theme=self.theme,\n\t        )\n\t        if self.cursor_visible:\n\t            syntax.stylize_range(\n", "                \"reverse\",\n\t                # rows are 1-indexed\n\t                (self.cursor.lno + 1, self.cursor.pos),\n\t                (self.cursor.lno + 1, self.cursor.pos + 1),\n\t            )\n\t        if self.selection_anchor is not None:\n\t            first = min(self.selection_anchor, self.cursor)\n\t            second = max(self.selection_anchor, self.cursor)\n\t            selection_style = Style(\n\t                bgcolor=self.theme_colors.selection_bgcolor.rich_color\n", "            )\n\t            syntax.stylize_range(\n\t                selection_style,\n\t                # rows are 1-indexed\n\t                (first.lno + 1, first.pos),\n\t                (second.lno + 1, second.pos),\n\t            )\n\t        return syntax\n\t    def _scroll_to_cursor(self) -> None:\n\t        self.post_message(TextAreaCursorMoved(self.cursor.pos, self.cursor.lno))\n", "    def _visible_height(self) -> int:\n\t        parent = self.parent\n\t        assert isinstance(parent, TextContainer)\n\t        return parent.window_region.height\n\t    def _toggle_cursor(self) -> None:\n\t        self.cursor_visible = not self.cursor_visible\n\t        self.update(self._content)\n\t    def _get_selected_lines(\n\t        self,\n\t        maybe_anchor: Union[Cursor, None],\n", "        maybe_cursor: Union[Cursor, None] = None,\n\t    ) -> Tuple[List[str], Cursor, Cursor]:\n\t        \"\"\"\n\t        Returns a tuple of:\n\t         - the lines between (inclusive) the optional selection anchor and the cursor,\n\t         - the first of either the cursor or anchor\n\t         - the last of either the cursor or anchor\n\t        \"\"\"\n\t        cursor = maybe_cursor or self.cursor\n\t        anchor = maybe_anchor or cursor\n", "        first = min(anchor, cursor)\n\t        last = max(anchor, cursor)\n\t        return self.lines[first.lno : last.lno + 1], first, last\n\t    def _insert_character_at_cursor(self, character: str, cursor: Cursor) -> None:\n\t        line = self.lines[cursor.lno]\n\t        new_line = f\"{line[:cursor.pos]}{character}{line[cursor.pos:]}\"\n\t        self.lines[cursor.lno] = new_line\n\t    def _insert_characters_around_selection(\n\t        self, character: str, anchor: Cursor, cursor: Cursor\n\t    ) -> None:\n", "        first = min(anchor, cursor)\n\t        last = max(anchor, cursor)\n\t        self._insert_character_at_cursor(character, first)\n\t        if first.lno == last.lno:\n\t            self.cursor = Cursor(lno=last.lno, pos=last.pos + len(character))\n\t        else:\n\t            self.cursor = last\n\t        self._insert_character_at_cursor(CLOSERS[character], self.cursor)\n\t    def _insert_closed_character_at_cursor(\n\t        self, character: str, cursor: Cursor\n", "    ) -> None:\n\t        if self._get_character_at_cursor(cursor) == character:\n\t            self.cursor = Cursor(cursor.lno, cursor.pos + 1)\n\t        else:\n\t            prev = self._get_character_before_cursor(cursor)\n\t            self._insert_character_at_cursor(character, cursor)\n\t            self.cursor = Cursor(cursor.lno, cursor.pos + len(character))\n\t            if (\n\t                character in CLOSERS\n\t                and self.cursor.pos == len(self.lines[self.cursor.lno]) - 1\n", "                and (prev is None or prev == \" \" or character in BRACKETS)\n\t            ):\n\t                self._insert_character_at_cursor(CLOSERS[character], self.cursor)\n\t    def _delete_selection(self, anchor: Cursor, cursor: Cursor) -> None:\n\t        old_lines, first, last = self._get_selected_lines(anchor, maybe_cursor=cursor)\n\t        head = f\"{old_lines[0][:first.pos]}\"\n\t        tail = f\"{old_lines[-1][last.pos:]}\"\n\t        if new_line := f\"{head}{tail}\":\n\t            self.lines[first.lno : last.lno + 1] = [new_line]\n\t        else:  # empty str, no line-ending space, delete whole line\n", "            self.lines[first.lno : last.lno + 1] = []\n\t            if not self.lines:\n\t                self.lines = [\" \"]\n\t        self.cursor = Cursor(first.lno, first.pos)\n\t    def _indent_selection(\n\t        self, anchor: Union[Cursor, None], cursor: Cursor, kind: str\n\t    ) -> None:\n\t        assert kind in (\"indent\", \"dedent\")\n\t        rounder, offset = (ceil, -1) if kind == \"dedent\" else (floor, 1)\n\t        lines, first, last = self._get_selected_lines(anchor, cursor)\n", "        leading_spaces = [(len(line) - len(line.lstrip())) for line in lines]\n\t        leading_tabs = [rounder(space / TAB_SIZE) for space in leading_spaces]\n\t        new_lines = [\n\t            f\"{' ' * TAB_SIZE * max(0, indent+offset)}{line.lstrip()}\"\n\t            for line, indent in zip(lines, leading_tabs)\n\t        ]\n\t        self.lines[first.lno : last.lno + 1] = new_lines\n\t        if anchor:\n\t            change_at_anchor_line = len(new_lines[anchor.lno - first.lno]) - len(\n\t                lines[anchor.lno - first.lno]\n", "            )\n\t            self.selection_anchor = (\n\t                anchor\n\t                if anchor.pos == 0\n\t                else Cursor(\n\t                    anchor.lno,\n\t                    anchor.pos + change_at_anchor_line,\n\t                )\n\t            )\n\t        change_at_cursor = len(new_lines[cursor.lno - first.lno]) - len(\n", "            lines[cursor.lno - first.lno]\n\t        )\n\t        self.cursor = (\n\t            cursor\n\t            if cursor.pos == 0\n\t            else Cursor(cursor.lno, cursor.pos + change_at_cursor)\n\t        )\n\t    def _insert_clipboard_at_selection(\n\t        self, anchor: Union[Cursor, None], cursor: Cursor\n\t    ) -> None:\n", "        if self.use_system_clipboard:\n\t            try:\n\t                sys_clipboard = pyperclip.paste()\n\t            except pyperclip.PyperclipException:\n\t                # no system clipboard; common in CI runners\n\t                pass\n\t            else:\n\t                self.clipboard = deserialize_lines(sys_clipboard, trim=True)\n\t        if anchor:\n\t            self._delete_selection(anchor, cursor)\n", "            cursor = self.cursor\n\t        head = self.lines[cursor.lno][: cursor.pos]\n\t        tail = self.lines[cursor.lno][cursor.pos :]\n\t        if (clip_len := len(self.clipboard)) != 0:\n\t            new_lines = self.clipboard.copy()\n\t            new_lines[0] = f\"{head}{new_lines[0]}\"\n\t            new_lines[-1] = f\"{new_lines[-1]}{tail}\"\n\t            self.lines[cursor.lno : cursor.lno + 1] = new_lines\n\t            self.cursor = Cursor(\n\t                cursor.lno + clip_len - 1,\n", "                len(self.lines[cursor.lno + clip_len - 1]) - len(tail),\n\t            )\n\t    def _get_character_at_cursor(self, cursor: Cursor) -> str:\n\t        return self.lines[cursor.lno][cursor.pos]\n\t    def _get_character_before_cursor(self, cursor: Cursor) -> Union[str, None]:\n\t        if self.cursor.pos == 0:\n\t            return None\n\t        else:\n\t            return self.lines[cursor.lno][cursor.pos - 1]\n\t    def move_cursor(self, x: int, y: int) -> None:\n", "        self.cursor = self._get_valid_cursor(x, y)\n\t        self.update(self._content)\n\t    def move_selection_anchor(self, x: int, y: int) -> None:\n\t        self.selection_anchor = self._get_valid_cursor(x, y)\n\t        self.update(self._content)\n\t    def _get_valid_cursor(self, x: int, y: int) -> Cursor:\n\t        max_y = len(self.lines) - 1\n\t        safe_y = max(0, min(max_y, y))\n\t        max_x = len(self.lines[safe_y]) - 1\n\t        safe_x = max(0, min(max_x, x))\n", "        return Cursor(lno=safe_y, pos=safe_x)\n\t    def clear_selection_anchor(self) -> None:\n\t        self.selection_anchor = None\n\t        self.update(self._content)\n\tclass TextArea(Widget, can_focus=True, can_focus_children=False):\n\t    \"\"\"\n\t    A Widget that presents a feature-rich, multiline text editor interface.\n\t    Attributes:\n\t        text (str): The contents of the TextArea\n\t        language (str): Must be the short name of a Pygments lexer\n", "            (https://pygments.org/docs/lexers/), e.g., \"python\", \"sql\", \"as3\".\n\t        theme (str): Must be name of a Pygments style (https://pygments.org/styles/),\n\t            e.g., \"bw\", \"github-dark\", \"solarized-light\".\n\t        theme_colors (WidgetColors): The colors extracted from the theme.\n\t    \"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    #validation_label {\n\t        color: $error;\n\t        text-style: italic;\n\t        margin: 0 0 0 3;\n", "    }\n\t    \"\"\"\n\t    BINDINGS = [\n\t        Binding(\"ctrl+s\", \"save\", \"Save Query\"),\n\t        Binding(\"ctrl+o\", \"load\", \"Open Query\"),\n\t        Binding(\"ctrl+q\", \"quit\", \"Quit\"),\n\t    ]\n\t    def __init__(\n\t        self,\n\t        *children: Widget,\n", "        name: Union[str, None] = None,\n\t        id: Union[str, None] = None,\n\t        classes: Union[str, None] = None,\n\t        disabled: bool = False,\n\t        language: Union[str, None] = None,\n\t        theme: str = \"monokai\",\n\t        use_system_clipboard: bool = True,\n\t    ) -> None:\n\t        \"\"\"\n\t        Initializes an instance of a TextArea.\n", "        Args:\n\t            (see also textual.widget.Widget)\n\t            language (str): Must be the short name of a Pygments lexer\n\t                (https://pygments.org/docs/lexers/), e.g., \"python\", \"sql\", \"as3\".\n\t            theme (str): Must be name of a Pygments style (https://pygments.org/styles/),\n\t                e.g., \"bw\", \"github-dark\", \"solarized-light\".\n\t        \"\"\"\n\t        super().__init__(\n\t            *children, name=name, id=id, classes=classes, disabled=disabled\n\t        )\n", "        self._language = language\n\t        self.theme = theme\n\t        self.theme_colors = WidgetColors.from_theme(self.theme)\n\t        self.use_system_clipboard = use_system_clipboard\n\t    @property\n\t    def text(self) -> str:\n\t        \"\"\"\n\t        Returns:\n\t            (str) The contents of the TextArea.\n\t        \"\"\"\n", "        return serialize_lines(self.text_input.lines)\n\t    @text.setter\n\t    def text(self, contents: str) -> None:\n\t        \"\"\"\n\t        Args:\n\t            contents (str): A string (optionally containing newlines) to\n\t                set the contents of the TextArea equal to.\n\t        \"\"\"\n\t        self.text_input.move_cursor(0, 0)\n\t        self.text_input.lines = deserialize_lines(contents)\n", "    @property\n\t    def selected_text(self) -> str:\n\t        \"\"\"\n\t        Returns:\n\t            str: The contents of the TextArea between the selection\n\t            anchor and the cursor. Returns an empty string if the\n\t            selection anchor is not set.\n\t        \"\"\"\n\t        anchor = self.text_input.selection_anchor\n\t        if anchor is None:\n", "            return \"\"\n\t        else:\n\t            lines, first, last = self.text_input._get_selected_lines(anchor)\n\t            lines[-1] = lines[-1][: last.pos]\n\t            lines[0] = lines[0][first.pos :]\n\t            return serialize_lines(lines)\n\t    @property\n\t    def cursor(self) -> Cursor:\n\t        \"\"\"\n\t        Returns\n", "            Cursor: The location of the cursor in the TextInput\n\t        \"\"\"\n\t        return self.text_input.cursor\n\t    @cursor.setter\n\t    def cursor(self, cursor: Union[Cursor, Tuple[int, int]]) -> None:\n\t        \"\"\"\n\t        Args:\n\t            cursor (Union[Cursor, Tuple[int, int]]): The position (line number, pos)\n\t            to move the cursor to\n\t        \"\"\"\n", "        self.text_input.move_cursor(cursor[1], cursor[0])\n\t    @property\n\t    def selection_anchor(self) -> Union[Cursor, None]:\n\t        \"\"\"\n\t        Returns\n\t            Cursor: The location of the selection anchor in the TextInput\n\t        \"\"\"\n\t        return self.text_input.selection_anchor\n\t    @selection_anchor.setter\n\t    def selection_anchor(self, cursor: Union[Cursor, Tuple[int, int], None]) -> None:\n", "        \"\"\"\n\t        Args:\n\t            cursor (Union[Cursor, Tuple[int, int], None]): The position\n\t            (line number, pos) to move the selection anchor to, or None\n\t            to clear the selection.\n\t        \"\"\"\n\t        if cursor is None:\n\t            self.text_input.clear_selection_anchor()\n\t        else:\n\t            self.text_input.move_selection_anchor(cursor[1], cursor[0])\n", "    @property\n\t    def language(self) -> Union[str, None]:\n\t        \"\"\"\n\t        Returns\n\t            str | None: The Pygments short name of the active language\n\t        \"\"\"\n\t        return self.text_input.language\n\t    @language.setter\n\t    def language(self, language: str) -> None:\n\t        \"\"\"\n", "        Args:\n\t            langage (str | None): The Pygments short name for the new language\n\t        \"\"\"\n\t        self.text_input.language = language\n\t    def compose(self) -> ComposeResult:\n\t        with TextContainer():\n\t            yield TextInput(\n\t                language=self._language,\n\t                theme=self.theme,\n\t                theme_colors=self.theme_colors,\n", "            )\n\t        with FooterContainer(theme_colors=self.theme_colors):\n\t            yield Label(\"\", id=\"validation_label\")\n\t    def on_mount(self) -> None:\n\t        self.styles.background = self.theme_colors.bgcolor\n\t        self.text_container = self.query_one(TextContainer)\n\t        self.text_input = self.query_one(TextInput)\n\t        self.footer = self.query_one(FooterContainer)\n\t    def on_focus(self) -> None:\n\t        self.text_input.focus()\n", "    def on_click(self) -> None:\n\t        self.text_input.focus()\n\t    def action_save(self) -> None:\n\t        self._clear_footer_input()\n\t        self._mount_footer_input(\"save\")\n\t    def action_load(self) -> None:\n\t        self._clear_footer_input()\n\t        self._mount_footer_input(\"open\")\n\t    def _clear_footer_input(self) -> None:\n\t        try:\n", "            self.footer.query_one(PathInput).remove()\n\t        except Exception:\n\t            pass\n\t        try:\n\t            self.footer.query_one(Label).update(\"\")\n\t        except Exception:\n\t            pass\n\t    def on_cancel_path_input(self) -> None:\n\t        self._clear_footer_input()\n\t    def _mount_footer_input(self, name: str) -> None:\n", "        if name == \"open\":\n\t            file_okay, dir_okay, must_exist = True, False, True\n\t        else:\n\t            file_okay, dir_okay, must_exist = True, False, False\n\t        input = PathInput(\n\t            id=f\"textarea__{name}_input\",\n\t            placeholder=f\"{name.capitalize()}: Enter file path OR press ESC to cancel\",\n\t            file_okay=file_okay,\n\t            dir_okay=dir_okay,\n\t            must_exist=must_exist,\n", "        )\n\t        input.styles.background = self.theme_colors.bgcolor\n\t        input.styles.border = \"round\", self.theme_colors.contrast_text_color\n\t        input.styles.color = self.theme_colors.contrast_text_color\n\t        self.footer.mount(input)\n\t        input.focus()\n\t    def on_text_area_cursor_moved(self, event: TextAreaCursorMoved) -> None:\n\t        \"\"\"\n\t        Scrolls the container so the cursor is visible.\n\t        \"\"\"\n", "        container = self.text_container\n\t        x_buffer = max(container.window_region.width // 6, 2)\n\t        y_buffer = max(container.window_region.height // 6, 2)\n\t        if event.cursor_x < container.window_region.x + x_buffer:  # scroll left\n\t            container.scroll_to(event.cursor_x - x_buffer, container.window_region.y)\n\t        elif (\n\t            event.cursor_x\n\t            >= container.window_region.x + container.window_region.width - x_buffer\n\t        ):  # scroll right\n\t            container.scroll_to(\n", "                event.cursor_x - container.window_region.width + x_buffer,\n\t                container.window_region.y,\n\t            )\n\t        if event.cursor_y < container.window_region.y + y_buffer:  # scroll up\n\t            container.scroll_to(container.window_region.x, event.cursor_y - y_buffer)\n\t        elif (\n\t            event.cursor_y\n\t            >= container.window_region.y + container.window_region.height - y_buffer\n\t        ):  # scroll down\n\t            container.scroll_to(\n", "                container.window_region.x,\n\t                event.cursor_y - container.window_region.height + y_buffer,\n\t            )\n\t        self.text_input.update(self.text_input._content)\n\t    def on_text_area_scroll_one(self, event: TextAreaScrollOne) -> None:\n\t        event.stop()\n\t        offset = 1 if event.direction == \"down\" else -1\n\t        self.text_container.scroll_to(\n\t            self.text_container.window_region.x,\n\t            self.text_container.window_region.y + offset,\n", "        )\n\t    def on_input_changed(self, message: Input.Changed) -> None:\n\t        if message.input.id in (\"textarea__save_input\", \"textarea__open_input\"):\n\t            label = self.footer.query_one(Label)\n\t            if message.validation_result and not message.validation_result.is_valid:\n\t                label.update(\";\".join(message.validation_result.failure_descriptions))\n\t            else:\n\t                label.update(\"\")\n\t    def on_input_submitted(self, message: Input.Submitted) -> None:\n\t        \"\"\"\n", "        Handle the submit event for the Save and Open modals.\n\t        \"\"\"\n\t        expanded_path = expanduser(message.input.value)\n\t        if message.input.id == \"textarea__save_input\":\n\t            try:\n\t                with open(expanded_path, \"w\") as f:\n\t                    f.write(self.text)\n\t            except OSError as e:\n\t                self.app.push_screen(\n\t                    ErrorModal(\n", "                        title=\"Save File Error\",\n\t                        header=(\n\t                            \"There was an error when attempting to save your file:\"\n\t                        ),\n\t                        error=e,\n\t                    )\n\t                )\n\t        elif message.input.id == \"textarea__open_input\":\n\t            try:\n\t                with open(expanded_path, \"r\") as f:\n", "                    contents = f.read()\n\t            except OSError as e:\n\t                self.app.push_screen(\n\t                    ErrorModal(\n\t                        title=\"Open File Error\",\n\t                        header=(\n\t                            \"There was an error when attempting to open your file:\"\n\t                        ),\n\t                        error=e,\n\t                    )\n", "                )\n\t            else:\n\t                self.text = contents\n\t        self._clear_footer_input()\n\t        self.text_input.update(self.text_input._content)\n\t        self.text_input.focus()\n"]}
{"filename": "src/textual_textarea/key_handlers.py", "chunked_list": ["import re\n\tfrom typing import List, NamedTuple\n\tfrom textual import log\n\tfrom textual.events import MouseEvent\n\tWWB = re.compile(r\"\\W*\\w+\\b\")\n\tclass Cursor(NamedTuple):\n\t    lno: int\n\t    pos: int\n\t    @classmethod\n\t    def from_mouse_event(cls, event: MouseEvent) -> \"Cursor\":\n", "        return Cursor(event.y, event.x - 1)\n\tdef handle_arrow(key: str, lines: List[str], cursor: Cursor) -> Cursor:\n\t    arrow = key.split(\"+\")[-1]\n\t    if \"ctrl\" in key:\n\t        assert arrow not in (\"up\", \"down\"), \"ctrl+up/down should be handled first\"\n\t        if arrow == \"right\":\n\t            return _handle_ctrl_right(lines, cursor)\n\t        else:  # if arrow == \"left\":\n\t            return _handle_ctrl_left(lines, cursor)\n\t    else:\n", "        if arrow == \"right\":\n\t            return _handle_right(lines, cursor)\n\t        elif arrow == \"left\":\n\t            return _handle_left(lines, cursor)\n\t        elif arrow == \"down\":\n\t            return _handle_down(lines, cursor)\n\t        else:  # arrow == \"up\":\n\t            return _handle_up(lines, cursor)\n\tdef _handle_right(lines: List[str], cursor: Cursor) -> Cursor:\n\t    max_x = len(lines[cursor.lno]) - 1\n", "    max_y = len(lines) - 1\n\t    if cursor.lno == max_y:\n\t        return Cursor(lno=max_y, pos=min(max_x, cursor.pos + 1))\n\t    elif cursor.pos == max_x:\n\t        return Cursor(lno=cursor.lno + 1, pos=0)\n\t    else:\n\t        return Cursor(lno=cursor.lno, pos=cursor.pos + 1)\n\tdef _handle_left(lines: List[str], cursor: Cursor) -> Cursor:\n\t    if cursor.lno == 0:\n\t        return Cursor(0, pos=max(0, cursor.pos - 1))\n", "    elif cursor.pos == 0:\n\t        return Cursor(\n\t            lno=cursor.lno - 1,\n\t            pos=len(lines[cursor.lno - 1]) - 1,\n\t        )\n\t    else:\n\t        return Cursor(lno=cursor.lno, pos=cursor.pos - 1)\n\tdef _handle_down(lines: List[str], cursor: Cursor) -> Cursor:\n\t    max_y = len(lines) - 1\n\t    if cursor.lno == max_y:\n", "        return Cursor(lno=max_y, pos=len(lines[cursor.lno]) - 1)\n\t    else:\n\t        max_x = len(lines[cursor.lno + 1]) - 1\n\t        return Cursor(lno=cursor.lno + 1, pos=min(max_x, cursor.pos))\n\tdef _handle_up(lines: List[str], cursor: Cursor) -> Cursor:\n\t    if cursor.lno == 0:\n\t        return Cursor(0, 0)\n\t    else:\n\t        max_x = len(lines[cursor.lno - 1]) - 1\n\t        return Cursor(lno=cursor.lno - 1, pos=min(max_x, cursor.pos))\n", "def _handle_ctrl_right(lines: List[str], cursor: Cursor) -> Cursor:\n\t    max_x = len(lines[cursor.lno]) - 1\n\t    max_y = len(lines) - 1\n\t    if cursor.pos == max_x and cursor.lno == max_y:\n\t        return cursor\n\t    elif cursor.pos == max_x:\n\t        lno = cursor.lno + 1\n\t        pos = 0\n\t    else:\n\t        lno = cursor.lno\n", "        pos = cursor.pos\n\t    tail = lines[lno][pos:]\n\t    if match := WWB.match(tail):\n\t        return Cursor(lno=lno, pos=pos + match.span()[1])\n\t    else:  # no more words, move to end of line\n\t        return Cursor(lno=lno, pos=len(lines[lno]) - 1)\n\tdef _handle_ctrl_left(lines: List[str], cursor: Cursor) -> Cursor:\n\t    if cursor.pos == 0 and cursor.lno == 0:\n\t        return cursor\n\t    elif cursor.pos == 0:\n", "        lno = cursor.lno - 1\n\t        pos = len(lines[lno]) - 1\n\t    else:\n\t        lno = cursor.lno\n\t        pos = cursor.pos\n\t    tail = lines[lno][:pos][::-1]\n\t    if match := WWB.match(tail):\n\t        log(match)\n\t        return Cursor(lno=lno, pos=pos - match.span()[1])\n\t    else:  # no more words, move to start of line\n", "        return Cursor(lno=lno, pos=0)\n"]}
{"filename": "src/textual_textarea/path_input.py", "chunked_list": ["import stat\n\tfrom pathlib import Path\n\tfrom typing import Union\n\tfrom rich.highlighter import Highlighter\n\tfrom textual.message import Message\n\tfrom textual.suggester import Suggester\n\tfrom textual.validation import ValidationResult, Validator\n\tfrom textual.widgets import Input\n\tclass CancelPathInput(Message):\n\t    pass\n", "class PathSuggester(Suggester):\n\t    def __init__(self) -> None:\n\t        super().__init__(use_cache=True, case_sensitive=True)\n\t    async def get_suggestion(self, value: str) -> Union[str, None]:\n\t        try:\n\t            p = Path(value).expanduser()\n\t            matches = list(p.parent.glob(f\"{p.parts[-1]}*\"))\n\t            if len(matches) == 1:\n\t                return str(matches[0])\n\t            else:\n", "                return None\n\t        except Exception:\n\t            return None\n\tclass PathValidator(Validator):\n\t    def __init__(\n\t        self,\n\t        dir_okay: bool,\n\t        file_okay: bool,\n\t        must_exist: bool,\n\t        failure_description: str = \"Not a valid path.\",\n", "    ) -> None:\n\t        self.dir_okay = dir_okay\n\t        self.file_okay = file_okay\n\t        self.must_exist = must_exist\n\t        super().__init__(failure_description)\n\t    def validate(self, value: str) -> ValidationResult:\n\t        if self.dir_okay and self.file_okay and not self.must_exist:\n\t            return self.success()\n\t        try:\n\t            p = Path(value).expanduser().resolve()\n", "        except Exception:\n\t            return self.failure(\"Not a valid path.\")\n\t        try:\n\t            st = p.stat()\n\t        except FileNotFoundError:\n\t            if self.must_exist:\n\t                return self.failure(\"File or directory does not exist.\")\n\t            return self.success()\n\t        if not self.dir_okay and stat.S_ISDIR(st.st_mode):\n\t            return self.failure(\"Path cannot be a directory.\")\n", "        elif not self.file_okay and stat.S_ISREG(st.st_mode):\n\t            return self.failure(\"Path cannot be a regular file.\")\n\t        return self.success()\n\tclass PathInput(Input):\n\t    BINDINGS = [\n\t        (\"escape\", \"cancel\", \"Cancel\"),\n\t        (\"tab\", \"complete\", \"Accept Completion\"),\n\t    ]\n\t    def __init__(\n\t        self,\n", "        value: Union[str, None] = None,\n\t        placeholder: str = \"\",\n\t        highlighter: Union[Highlighter, None] = None,\n\t        password: bool = False,\n\t        *,\n\t        name: Union[str, None] = None,\n\t        id: Union[str, None] = None,\n\t        classes: Union[str, None] = None,\n\t        disabled: bool = False,\n\t        dir_okay: bool = True,\n", "        file_okay: bool = True,\n\t        must_exist: bool = False,\n\t        tab_advances_focus: bool = False,\n\t    ) -> None:\n\t        self.tab_advances_focus = tab_advances_focus\n\t        super().__init__(\n\t            value,\n\t            placeholder,\n\t            highlighter,\n\t            password,\n", "            suggester=PathSuggester(),\n\t            validators=PathValidator(dir_okay, file_okay, must_exist),\n\t            name=name,\n\t            id=id,\n\t            classes=classes,\n\t            disabled=disabled,\n\t        )\n\t    def action_cancel(self) -> None:\n\t        self.post_message(CancelPathInput())\n\t    def action_complete(self) -> None:\n", "        if self._suggestion and self._suggestion != self.value:\n\t            self.action_cursor_right()\n\t        elif self.tab_advances_focus:\n\t            self.app.action_focus_next()\n"]}
{"filename": "src/textual_textarea/serde.py", "chunked_list": ["from typing import List\n\tdef serialize_lines(lines: List[str]) -> str:\n\t    return \"\\n\".join([line.rstrip() for line in lines])\n\tdef deserialize_lines(text: str, trim: bool = False) -> List[str]:\n\t    if text:\n\t        lines = [f\"{line} \" for line in text.splitlines()]\n\t        if text.endswith((\"\\n\", \"\\r\", \"\\r\\n\")):\n\t            lines.append(\" \")\n\t    else:\n\t        lines = [\" \"]\n", "    if trim:\n\t        lines[-1] = lines[-1].rstrip()\n\t    return lines\n"]}
{"filename": "src/textual_textarea/messages.py", "chunked_list": ["from textual.message import Message\n\tclass TextAreaCursorMoved(Message, bubble=True):\n\t    \"\"\"Posted when the cursor moves\n\t    Attributes:\n\t        cursor_x: The x position of the cursor\n\t        cursor_y: The y position (line number)\n\t    \"\"\"\n\t    def __init__(self, cursor_x: int, cursor_y: int) -> None:\n\t        super().__init__()\n\t        self.cursor_x = cursor_x\n", "        self.cursor_y = cursor_y\n\tclass TextAreaScrollOne(Message, bubble=True):\n\t    \"\"\"\n\t    Posted to get parent container to scroll one in a direction\n\t    \"\"\"\n\t    def __init__(self, direction: str) -> None:\n\t        super().__init__()\n\t        assert direction in (\"up\", \"down\")\n\t        self.direction = direction\n"]}
