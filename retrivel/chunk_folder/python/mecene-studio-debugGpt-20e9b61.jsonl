{"filename": "src/testAgents.py", "chunked_list": ["from agents.agent import JuniorDev\n\tdef testJuniorDev():\n\t    prompt = \"build the application and fix any errors\"\n\t    agent = JuniorDev()\n\t    answer = agent.startLoop(prompt)\n\t    print(\"answer:\", answer)\n\tif __name__ == \"__main__\":\n\t    testJuniorDev()\n"]}
{"filename": "src/main.py", "chunked_list": ["import time\n\tfrom agents.agent import DebugGpt\n\tfrom agents.utils.debuggptprompt import getFeedbackFromCodeExecutionPrompt\n\tfrom cleanConsole import resetConsoleColor, setConsoleColor\n\tif __name__ == \"__main__\":\n\t    agent = DebugGpt()\n\t    agent.startLoop(\"debug the application\")\n"]}
{"filename": "src/testTools.py", "chunked_list": ["from agents.agent import parseToolUserAnswer\n\tfrom cleanConsole import printCode\n\tfrom tools.moveFile import moveFileFromTestApp\n\tfrom tools.readFile import getClosestFile, readCodeFile, readFile, readFileFromTestApp\n\tfrom tools.runShell import getErrorsFromFile, parseTypeAnswer, runShell\n\tfrom tools.searchGoogle import searchGoggleCustom\n\tfrom tools.stackOverflow import getAnswersForStackOverflowPost, searchStackOverflow\n\tfrom tools.writeFile import writeFileToTestApp, writeFileToWorkspace\n\tfrom tools.listFiles import listFilesFromTestApp\n\tdef testWriteFile():\n", "    print(\"Testing WriteFile:\")\n\t    content = \"\"\"THIS is a file\n\t    with multiple lines\"\"\"\n\t    filename = \"components/test/test.txt\"\n\t    answer = writeFileToTestApp(filename, content)\n\t    print(\"answer\\n\", answer)\n\tdef testListFiles():\n\t    print(\"Testing ListFiles:\")\n\t    tree = listFilesFromTestApp()\n\t    print(\"tree\\n\", tree)\n", "def testSearch():\n\t    query = \"Cannot find module @lucide/react\"\n\t    results = searchGoggleCustom(query)\n\t    print(\"results\\n\", results)\n\tdef testReadFile():\n\t    filename = \"test.txt\"\n\t    content = readFile(filename)\n\t    print(\"content\\n\", content)\n\tdef testReadCodeFile():\n\t    filename = \"components/Footer.tsx\"\n", "    content = readCodeFile(filename)\n\t    print(\"content: \\n\\n\", content)\n\tdef testParseDebugGptMessage():\n\t    message = \"\"\"writeFile(components/LandingPage.module.scss, ```$color-primary: #0070f3;\n\t$color-secondary: #ff0080;\n\t$color-white: #ffffff;\n\t$color-black: #000000;\n\t.container {\n\t  display: flex;\n\t  flex-direction: column;\n", "  align-items: center;\n\t  justify-content: center;\n\t  height: 100vh;\n\t  background-color: $color-primary;\n\t}\n\t.hero {\n\t  display: flex;\n\t  flex-direction: column;\n\t  align-items: center;\n\t  justify-content: center;\n", "  text-align: center;\n\t  max-width: 600px;\n\t  margin: 0 auto;\n\t}\n\t.title {\n\t  font-size: 3rem;\n\t  font-weight: 700;\n\t  color: $color-white;\n\t  margin-bottom: 2rem;\n\t}\n", ".subtitle {\n\t  font-size: 1.5rem;\n\t  font-weight: 400;\n\t  color: $color-white;\n\t  margin-bottom: 3rem;\n\t}\n\t.button {\n\t  display: flex;\n\t  align-items: center;\n\t  justify-content: center;\n", "  font-size: 1.5rem;\n\t  font-weight: 700;\n\t  color: $color-primary;\n\t  background-color: $color-white;\n\t  border: none;\n\t  border-radius: 50px;\n\t  padding: 1rem 2rem;\n\t  cursor: pointer;\n\t  transition: all 0.2s ease-in-out;\n\t  &:hover {\n", "    transform: translateY(-5px);\n\t    box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.2);\n\t  }\n\t}\n\t.icon {\n\t  margin-left: 1rem;\n\t  font-size: 2rem;\n\t}\n\t.canvas {\n\t  position: fixed;\n", "  top: 0;\n\t  left: 0;\n\t  width: 100%;\n\t  height: 100%;\n\t  pointer-events: none;\n\t}\n\t``` )\"\"\"\n\t    functionName, arguments, plan = parseToolUserAnswer(message)\n\t    print(\"functionName\\n\", functionName)\n\t    # print(\"arguments\\n\", arguments)\n", "    for argument in arguments:\n\t        print(\"argument\\n\", argument)\n\tdef testRunShell():\n\t    command = \"npm run lint --fix\"\n\t    # command = \"ls\"\n\t    output = runShell(command)\n\t    print(\n\t        \"\\n\\n\\n\\n######################### output:\\n\",\n\t        output + \"\\n#########################\",\n\t    )\n", "def testStackOverflow():\n\t    query = \"Cannot find module '@lucide/react'\"\n\t    # postId = \"44439205\"\n\t    # results = getAnswersForStackOverflowPost(postId)\n\t    # print(\"results\\n\", results)\n\t    answer = searchStackOverflow(query)\n\t    print(\"answer\\n\", answer)\n\tdef testMoveFile():\n\t    file1 = \"components/Header.tsx\"\n\t    file2 = \"components/Header/Header.tsx\"\n", "    answer = moveFileFromTestApp(file1, file2)\n\t    print(\"answer\\n\", answer)\n\tdef testConsole():\n\t    code = \"\"\"\n\t    def hello_world():\n\t        print('Hello, World!')\n\t    hello_world()\n\t    \"\"\"\n\t    printCode(code)\n\tdef testGetErrorsFromFile():\n", "    filename = \"components/Logo.tsx\"\n\t    errors = getErrorsFromFile(filename, True)\n\t    print(\"errors\\n\", errors)\n\tdef testReadFileFromTestApp():\n\t    filename = \"app/page.module.scss\"\n\t    content = readFileFromTestApp(filename)\n\t    print(\"content\\n\", content)\n\tdef testGetClosestFile():\n\t    filename = \"components/Logo.tsx\"\n\t    answer = getClosestFile(filename)\n", "    print(\"answer\\n\", answer)\n\tdef testParseTypeAnswer():\n\t    message = \"\"\"Found 8 files. Generating type definitions...\n\tFunction rgb is missing argument $green. (/Users/turcottep/dev/debugGpt/test-app/app/page.module.scss[199:7])\n\t[GENERATED TYPES] components/App.module.scss.d.ts\n\t[GENERATED TYPES] components/AppLayout.module.scss.d.ts\n\t[GENERATED TYPES] components/Button.module.scss.d.ts\n\t[GENERATED TYPES] components/Footer.module.scss.d.ts\n\t[GENERATED TYPES] components/Header.module.scss.d.ts\n\t[GENERATED TYPES] components/LandingPage/LandingPage.module.scss.d.ts\n", "[GENERATED TYPES] components/Logo.module.scss.d.ts\"\"\"\n\t    answer = parseTypeAnswer(message)\n\t    print(\"testParseTypeAnswer:\\n\")\n\t    print(answer)\n\tdef testGenerateTypes():\n\t    command = \"npx typed-scss-modules **/*.scss --ignore node_modules/**/*.scss\"\n\t    output = runShell(command)\n\t    print(\"output\\n\", output)\n\tif __name__ == \"__main__\":\n\t    print(\"testTools.py\")\n", "    # testGenerateTypes()\n\t    # testGetClosestFile()\n\t    testReadFileFromTestApp()\n\t    # testParseTypeAnswer()\n"]}
{"filename": "src/cleanConsole.py", "chunked_list": ["from colorama import Fore, Style\n\tfrom pygments import highlight\n\tfrom pygments.lexers import PythonLexer\n\tfrom pygments.formatters import TerminalFormatter\n\tdef printCode(code):\n\t    # Use Pygments to highlight the code\n\t    highlighted_code = highlight(code, PythonLexer(), TerminalFormatter())\n\t    # Use Colorama to print it in color\n\t    print(Fore.GREEN + highlighted_code + Style.RESET_ALL)\n\tdef resetConsoleColor():\n", "    print(Style.RESET_ALL)\n\tdef setConsoleColor(color):\n\t    if color == \"green\":\n\t        print(Fore.GREEN)\n\t    elif color == \"red\":\n\t        print(Fore.RED)\n\t    elif color == \"blue\":\n\t        print(Fore.BLUE)\n\t    elif color == \"yellow\":\n\t        print(Fore.YELLOW)\n", "    elif color == \"magenta\":\n\t        print(Fore.MAGENTA)\n\t    elif color == \"cyan\":\n\t        print(Fore.CYAN)\n\tdef printUser(message):\n\t    print(Fore.GREEN + message + Style.RESET_ALL)\n"]}
{"filename": "src/testParse.py", "chunked_list": ["from agents.agent import parseToolUserAnswer\n\tfrom agents.utils.generateHistoryMessages import (\n\t    generateHistoryMessagesTikToken,\n\t)\n\tfrom agents.utils.juniordevprompt import getJuniorDevPromptMessages\n\tdef testHistory():\n\t    startingMessages = [\n\t        {\"role\": \"system\", \"content\": \"your are a gpt\"},\n\t        {\n\t            \"role\": \"system\",\n", "            \"content\": \"be helpful\",\n\t        },\n\t    ]\n\t    historyMessages = [\n\t        {\n\t            \"role\": \"user\",\n\t            \"content\": \"user0\",\n\t        },\n\t        {\n\t            \"role\": \"assistant\",\n", "            \"content\": \"assistant1\",\n\t        },\n\t        {\n\t            \"role\": \"user\",\n\t            \"content\": \"user2\",\n\t        },\n\t        {\n\t            \"role\": \"assistant\",\n\t            \"content\": \"assistant3\",\n\t        },\n", "        {\n\t            \"role\": \"user\",\n\t            \"content\": \"user4\",\n\t        },\n\t    ]\n\t    systemMessages = [\n\t        {\n\t            \"role\": \"system\",\n\t            \"content\": \"system0\",\n\t        },\n", "        {\n\t            \"role\": \"system\",\n\t            \"content\": \"system1\",\n\t        },\n\t    ]\n\t    messages = generateHistoryMessagesTikToken(\n\t        startingMessages, historyMessages, systemMessages\n\t    )\n\t    print(\"\\n\\nmessages:\", messages, \"\\n\\n\")\n\t    for message in messages:\n", "        print(message.get(\"role\"), \":\", message.get(\"content\")[0:100])\n\tdef testParseTools():\n\t    answer = \"\"\"\n\t    Yes, i can do that\n\t    1 ::: runCommand (npm run build)\n\t2 ::: listFiles()\n\t3 ::: readFile(app/page.tsx)\n\t4 ::: readFile(components/LandingPage/LandingPage.tsx)\n\t5 ::: readFile(components/LandingPage/LandingPage.module.scss)\n\t6 ::: readFile(components/LandingPage/test.tsx)\n", "7 ::: readFile(components/AppLayout.tsx)\n\t8 ::: readFile(components/Button.tsx)\n\t9 ::: readFile(components/Footer.tsx)\n\t10 ::: readFile(components/Header.tsx)\n\t11 ::: readFile(components/Logo.tsx)\n\t12 ::: runCommand(npm run lint) [Note: This command is not allowed, so I will skip it]\n\t13 ::: finishedanswer (I have built the application and checked all the files for errors.)\n\tIf you want me to do something else, just ask me.\n\t\"\"\"\n\t    functionName, arguments, plan = parseToolUserAnswer(answer)\n", "    print(\"functionName:\", functionName)\n\t    # print(\"arguments:\", arguments)\n\t    for i, arg in enumerate(arguments):\n\t        print(\"argument\", i, \":\", arg)\n\tif __name__ == \"__main__\":\n\t    testHistory()\n"]}
{"filename": "src/tools/writeFile.py", "chunked_list": ["import os\n\tfrom lib.getPath import (\n\t    getPathFromComponents,\n\t    getPathFromTestApp,\n\t    getPathFromWorkspace,\n\t)\n\tdef writeFileToWorkspace(filename: str, content: str):\n\t    path = getPathFromWorkspace(filename)\n\t    with open(path, \"w\") as f:\n\t        f.write(content)\n", "    print(\"File written successfully to\", filename)\n\tdef writeFileToComponents(filename: str, content: str):\n\t    path = getPathFromComponents(filename)\n\t    with open(path, \"w\") as f:\n\t        f.write(content)\n\t    answer = \"File written successfully to: components/\" + filename\n\t    # print(answer)\n\t    return answer\n\tdef writeFileToTestApp(filename: str, content: str):\n\t    filename = filename.replace('\"', \"\").replace(\"'\", \"\")\n", "    path = getPathFromTestApp(filename)\n\t    # recursively create directories if they don't exist\n\t    os.makedirs(os.path.dirname(path), exist_ok=True)\n\t    try:\n\t        with open(path, \"w\") as f:\n\t            f.write(content)\n\t        answer = \"File written successfully to: test-app/\" + filename\n\t        return answer\n\t    except FileNotFoundError:\n\t        answer = \"File not found: \" + filename\n", "        return answer\n"]}
{"filename": "src/tools/runShell.py", "chunked_list": ["import os\n\timport re\n\timport subprocess\n\timport time\n\tfrom lib.getPath import getTestAppPath\n\tdef runShellPopen(commandRaw: str):\n\t    # if commandRaw starts and ends with a quote, remove them\n\t    if commandRaw.startswith('\"') and commandRaw.endswith('\"'):\n\t        commandRaw = commandRaw[1:-1]\n\t    # Change directory to the desired folder\n", "    folder_path = getTestAppPath()\n\t    os.chdir(folder_path)\n\t    # Define the command to run\n\t    # command = [\"npm\", \"run\", \"build\"]\n\t    command = commandRaw.split(\" \")\n\t    # print(\"command: \", command)\n\t    maxExecutionTime = 10  # seconds\n\t    # Run the command using subprocess with stdout and stderr as PIPE\n\t    process = subprocess.Popen(\n\t        command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True\n", "    )\n\t    print(\n\t        \"started process: \",\n\t        process,\n\t        \"for \",\n\t        maxExecutionTime,\n\t        \"seconds\",\n\t    )\n\t    if process.stdout == None:\n\t        print(\"process.stdout is None\")\n", "        return \"INTERNAL ERROR: process.stdout is None\"\n\t    if process.stderr == None:\n\t        print(\"process.stderr is None\")\n\t        return \"INTERNAL ERROR: process.stderr is None\"\n\t    # print(\"reached while loop\")\n\t    shellOutput = \"\"\n\t    startTime = time.time()\n\t    # Read and print the output in real-time\n\t    while True:\n\t        # print(\"waiting for output\")\n", "        output = process.stdout.read()\n\t        # print(\"waiting for error\")\n\t        error = process.stderr.read()\n\t        if output:\n\t            print(output.strip())\n\t            shellOutput += output.strip() + \"\\n\"\n\t        if error:\n\t            print(error.strip())\n\t            shellOutput += error.strip() + \"\\n\"\n\t        # print(\"polling process:\", process.returncode)\n", "        # if output == \"\" and process.poll() is not None:\n\t        #     break\n\t        if time.time() - startTime > maxExecutionTime:\n\t            print(\"maxExecutionTime reached\")\n\t            process.kill()\n\t            break\n\t    # Print the return code\n\t    print(\"Process exited with return code:\", process.returncode)\n\t    # print(\"shellOutput: \\n\", shellOutput)\n\t    return shellOutput\n", "def runShell(commandRaw: str):\n\t    # Change directory to the desired folder\n\t    folder_path = getTestAppPath()\n\t    os.chdir(folder_path)\n\t    # Define the command to run\n\t    # command = [\"npm\", \"run\", \"build\"]\n\t    command = commandRaw.split(\" \")\n\t    # print(\"command: \", command)\n\t    maxExecutionTime = 30  # seconds\n\t    try:\n", "        process = subprocess.run(\n\t            command, timeout=maxExecutionTime, capture_output=True, text=True\n\t        )\n\t        answer = process.stdout + process.stderr\n\t        return answer\n\t    except subprocess.TimeoutExpired:\n\t        return (\n\t            \"Max execution time \"\n\t            + str(maxExecutionTime)\n\t            + \" reached before command finished\"\n", "        )\n\tBASEFILE = \"app/page.tsx\"\n\tdef getErrorsFromFile(filename, allFiles=False):\n\t    # print(\"running sccss types\")\n\t    command = \"npx typed-scss-modules **/*.scss --ignore node_modules/**/*.scss --logLevel error\"\n\t    # print(\"command: \", command)\n\t    answerTypes = runShell(command)\n\t    # print(\"answerTypes: \", answerTypes)\n\t    scssErrors = parseTypeAnswer(answerTypes)\n\t    # print(\"answerTypes: \", answerTypes)\n", "    # compileTscCommand = f\"npx tsc {filename} --jsx react --noEmit --esModuleInterop --allowArbitraryExtensions\"\n\t    # print(\"running tsc\")\n\t    debugCommand = \"node ignore/debug.js \" + filename\n\t    if allFiles:\n\t        debugCommand = f\"node ignore/debug.js {BASEFILE} --all\"\n\t    rawAnswer = runShell(debugCommand)\n\t    # print(\"rawAnswer: \", rawAnswer)\n\t    tsxErrors = \"\"\n\t    key = \"TSX ERROR #\"\n\t    if key in rawAnswer:\n", "        trash, tsxErrorTemp = rawAnswer.split(key, 1)\n\t        tsxErrors += key + tsxErrorTemp\n\t    if scssErrors == \"\" and tsxErrors == \"\":\n\t        return \"No errors found\"\n\t    allErrors = scssErrors + \"\\n\" + tsxErrors\n\t    return allErrors\n\tdef getErrorsFromAllFiles():\n\t    return getErrorsFromFile(BASEFILE, allFiles=True)\n\tdef getErrorsFromScssFile(filename):\n\t    command = f\"npx typed-scss-modules {filename} --logLevel error\"\n", "    # print(\"command: \", command)\n\t    answerTypes = runShell(command)\n\t    # print(\"answerTypes: \", answerTypes)\n\t    scssErrors = parseTypeAnswer(answerTypes)\n\t    return scssErrors\n\tdef parseTypeAnswer(answer: str):\n\t    if \"No files found.\" in answer:\n\t        return \"\"\n\t    lines = answer.split(\"\\n\")\n\t    errors = []\n", "    for line in lines:\n\t        if line == \"\":\n\t            continue\n\t        if line.startswith(\"Found\"):\n\t            continue\n\t        if line.startswith(\"[GENERATED TYPES]\"):\n\t            continue\n\t        errors.append(line)\n\t    # output = \"\\n\".join(errors)\n\t    output = \"\"\n", "    for i, error in enumerate(errors):\n\t        # get path and line number from error\n\t        # error = \"Function rgb is missing argument $green. (/Users/turcottep/dev/debugGpt/test-app/app/page.module.scss[199:7]\"\n\t        match = re.search(r\"\\((.*?)\\[(.*?)\\]\\)\", error)\n\t        # error = error.split(\")\")[1].strip()\n\t        if match:\n\t            basePath = getTestAppPath() + \"/\"\n\t            file_path = match.group(1)\n\t            relative_file_path = file_path.replace(basePath, \"\")\n\t            line_col = match.group(2)\n", "            line_number = int(line_col.split(\":\")[0])\n\t            partToRemove = f\"({file_path}[{line_col}])\"\n\t            # print(\"partToRemove: \", partToRemove)\n\t            error = error.replace(partToRemove, \"\")\n\t            # print(\"File path:\", file_path)\n\t            # print(\"Line number:\", line_number)\n\t            output += f\"SCSS ERROR #{i + 1} {relative_file_path} line {line_number }): {error}\\n\"\n\t        else:\n\t            output += f\"SCSS ERROR #{i + 1} {error}\\n\"\n\t    return output\n"]}
{"filename": "src/tools/stackOverflow.py", "chunked_list": ["from stackapi import StackAPI\n\tfrom tools.searchGoogle import getLinksFromGoogle\n\tdef searchStackOverflow(query):\n\t    query = query.replace('\"', \"\").replace(\"'\", \"\")\n\t    newQuery = f\"site:stackoverflow.com {query}\"\n\t    print(\"stack overflow query\")\n\t    print(newQuery, \"\\n\")\n\t    links = getLinksFromGoogle(newQuery)\n\t    if len(links) == 0:\n\t        return \"STACKOVERFLOW: No results found, try a different query.\"\n", "    # print(\"links\", links)\n\t    link = links[0]\n\t    # https://stackoverflow.com/questions/71433951/module-not-found-cant-resolve-next-js-typescript\n\t    postId = link.split(\"https://stackoverflow.com/questions/\")[1].split(\"/\")[0]\n\t    # print(\"postId\", postId)\n\t    return getAnswersForStackOverflowPost(postId)\n\tdef getAnswersForStackOverflowPost(postId):\n\t    SITE = StackAPI(\"stackoverflow\")\n\t    # res = SITE.fetch(\"questions/{ids}\", ids=[44439205], filter=\"withbody\")\n\t    # # print(\"res\", res)\n", "    # items = res[\"items\"]\n\t    # item = items[0]\n\t    # print(\"title:\", item[\"title\"])\n\t    # body = item[\"body\"]\n\t    # print(\"body:\\n\", body)\n\t    # # for item in items:\n\t    # #     print(\"item\\n\", item)\n\t    res = SITE.fetch(\n\t        \"questions/{ids}/answers\",\n\t        ids=[postId],\n", "        filter=\"withbody\",\n\t        # max=1,\n\t        sort=\"votes\",\n\t    )\n\t    # print(\"res\", res)\n\t    items = res[\"items\"]\n\t    # print(\"items\", items)\n\t    item = items[0]\n\t    # for item in items:\n\t    #     print(\"item\\nn\", item, \"\\n\\n\")\n", "    body = item[\"body\"]\n\t    # print(\"body:\\n\", body)\n\t    return body\n"]}
{"filename": "src/tools/moveFile.py", "chunked_list": ["import os\n\tfrom lib.getPath import getPathFromTestApp\n\tdef moveFileFromTestApp(oldPathRelative: str, newPathRelative: str):\n\t    oldPath = getPathFromTestApp(oldPathRelative)\n\t    newPath = getPathFromTestApp(newPathRelative)\n\t    try:\n\t        with open(oldPath, \"r\") as f:\n\t            content = f.read()\n\t            # delete the file\n\t    except FileNotFoundError as e:\n", "        print(\"File not found: \", e)\n\t        return \"File not found: \" + oldPathRelative\n\t    try:\n\t        with open(newPath, \"w\") as f:\n\t            f.write(content)\n\t    except FileNotFoundError as e:\n\t        print(\"File not found: \", e)\n\t        return \"File not found: \" + newPathRelative\n\t    os.remove(oldPath)\n\t    return \"File moved successfully to: \" + newPathRelative\n"]}
{"filename": "src/tools/searchGoogle.py", "chunked_list": ["import requests\n\tfrom dotenv import load_dotenv\n\timport os\n\tload_dotenv()\n\tdef searchGoggleCustom(query: str):\n\t    queryClean = query.replace(\"```\", \"\").replace('\"', \"\").replace(\"'\", \"\")\n\t    print(\"queryClean:\", queryClean)\n\t    items = _searchGoggleCustom(queryClean)\n\t    answer = []\n\t    for i, item in enumerate(items):\n", "        # print(i, item[\"title\"])\n\t        # print(\"########################\")\n\t        # print(item)\n\t        # print(\"########################\")\n\t        # print()\n\t        outputItem = {\n\t            \"title\": item[\"title\"],\n\t            \"snippet\": item[\"snippet\"],\n\t            \"link\": item[\"link\"],\n\t        }\n", "        answer.append(outputItem)\n\t        # answer.append(item[\"link\"])\n\t    return answer\n\tdef getLinksFromGoogle(query: str):\n\t    items = _searchGoggleCustom(query)\n\t    links = []\n\t    for i, item in enumerate(items):\n\t        # print(i, item[\"title\"])\n\t        # print(\"########################\")\n\t        # print(item)\n", "        # print(\"########################\")\n\t        # print()\n\t        links.append(item[\"link\"])\n\t    return links\n\tdef _searchGoggleCustom(query: str):\n\t    API_KEY = os.getenv(\"GOOGLE_SEARCH_API_KEY\") or \"MISSING API KEY\"\n\t    GOOGLE_CX_ID = os.getenv(\"GOOGLE_CX_ID\") or \"MISSING CX\"\n\t    url = \"https://www.googleapis.com/customsearch/v1\"\n\t    params = {\"key\": API_KEY, \"cx\": GOOGLE_CX_ID, \"q\": query, \"num\": 3}\n\t    res = requests.get(url, params=params)\n", "    # print(\"res\", res)\n\t    data = res.json()\n\t    if \"error\" in data:\n\t        raise Exception(data[\"error\"][\"message\"])\n\t    items = data.get(\"items\", [])\n\t    return items\n"]}
{"filename": "src/tools/listFiles.py", "chunked_list": ["# get a tree of files on the workspace\n\timport os\n\tfrom lib.getPath import getTestAppPath, getWorkspacePath\n\tdef listFilesFromWorkspace():\n\t    path = getWorkspacePath()\n\t    return listFilesFromPath(path)\n\tignoreList = [\n\t    \"test-app\",\n\t    \".next\",\n\t    \"node_modules\",\n", "]\n\tdef listFilesFromPathTabs(path):\n\t    treeString = \"\"\n\t    print(\"path\", path)\n\t    # walk the directory recursively, adding a tab for each level but ignore what's in the ignoreList\n\t    for root, dirs, files in os.walk(path):\n\t        # remove the first directory from the path\n\t        # print(\"root\", root)\n\t        dirs[:] = [d for d in dirs if d not in ignoreList]\n\t        level = root.replace(path, \"\").count(os.sep)\n", "        indent = \"\\t\" * (level - 1)\n\t        dirString = os.path.basename(root)\n\t        # print(\"dirString\", dirString)\n\t        treeString += \"{}{}/\\n\".format(indent, dirString)\n\t        subindent = \"\\t\" * (level)\n\t        for f in files:\n\t            treeString += \"{}{}\\n\".format(subindent, f)\n\t    # remove first line from treeString\n\t    treeString = treeString.split(\"\\n\", 1)[1]\n\t    return treeString\n", "def listFilesFromPath(path):\n\t    treeString = \"\"\n\t    # print(\"path\", path)\n\t    # walk the directory recursively, adding a tab for each level but ignore what's in the ignoreList\n\t    for root, dirs, files in os.walk(path):\n\t        # remove the first directory from the path\n\t        # print(\"root\", root)\n\t        dirs[:] = [d for d in dirs if d not in ignoreList]\n\t        level = root.replace(path, \"\")\n\t        if \"ignore\" in level:\n", "            continue\n\t        # indent = \"\\t\" * (level - 1)\n\t        # dirString = os.path.basename(root)\n\t        # # print(\"dirString\", dirString)\n\t        # treeString += \"{}{}/\\n\".format(indent, dirString)\n\t        # subindent = \"\\t\" * (level)\n\t        for f in files:\n\t            if \".d.ts\" in f:\n\t                continue\n\t            filePath = level + \"/\" + f + \"\\n\"\n", "            treeString += filePath[1:]\n\t    # remove first line from treeString\n\t    treeString = treeString.split(\"\\n\", 1)[1]\n\t    return treeString\n\tdef listFilesFromTestApp():\n\t    path = getTestAppPath()\n\t    return listFilesFromPath(path)\n"]}
{"filename": "src/tools/readFile.py", "chunked_list": ["import numpy\n\tfrom lib.getPath import getPathFromTestApp, getPathFromWorkspace\n\tfrom tools.listFiles import listFilesFromTestApp\n\tfrom tools.runShell import getErrorsFromFile, getErrorsFromScssFile\n\tdef readFile(filename: str):\n\t    path = getPathFromWorkspace(filename)\n\t    return readFileFullPath(path)\n\tdef levenshteinDistanceDP(token1, token2):\n\t    distances = numpy.zeros((len(token1) + 1, len(token2) + 1))\n\t    for t1 in range(len(token1) + 1):\n", "        distances[t1][0] = t1\n\t    for t2 in range(len(token2) + 1):\n\t        distances[0][t2] = t2\n\t    a = 0\n\t    b = 0\n\t    c = 0\n\t    for t1 in range(1, len(token1) + 1):\n\t        for t2 in range(1, len(token2) + 1):\n\t            if token1[t1 - 1] == token2[t2 - 1]:\n\t                distances[t1][t2] = distances[t1 - 1][t2 - 1]\n", "            else:\n\t                a = distances[t1][t2 - 1]\n\t                b = distances[t1 - 1][t2]\n\t                c = distances[t1 - 1][t2 - 1]\n\t                if a <= b and a <= c:\n\t                    distances[t1][t2] = a + 1\n\t                elif b <= a and b <= c:\n\t                    distances[t1][t2] = b + 1\n\t                else:\n\t                    distances[t1][t2] = c + 1\n", "    return distances[len(token1)][len(token2)]\n\tdef getClosestFile(filename: str):\n\t    files = listFilesFromTestApp().split(\"\\n\")\n\t    minDistance = 100000000000\n\t    closestFile = \"None\"\n\t    for file in files:\n\t        dsitance = levenshteinDistanceDP(filename, file)\n\t        print(\"file\", file, \"distance\", dsitance)\n\t        if dsitance < minDistance:\n\t            minDistance = dsitance\n", "            closestFile = file\n\t    return closestFile\n\tdef readFileFromTestApp(filename: str):\n\t    filename = filename.replace('\"', \"\").replace(\"'\", \"\")\n\t    extension = filename.split(\".\")[-1]\n\t    if extension == \"tsx\" or extension == \"scss\":\n\t        return readCodeFile(filename)\n\t    try:\n\t        path = getPathFromTestApp(filename)\n\t        return readFileFullPath(path)\n", "    except FileNotFoundError:\n\t        return f\"ERROR: File not found: '{filename}'. Closest file: `{getClosestFile(filename)}`\"\n\tdef readCodeFile(filename: str):\n\t    # extension = filename.split(\".\")[-1]\n\t    # print(\"extension\", extension)\n\t    path = getPathFromTestApp(filename)\n\t    try:\n\t        content = readFileFullPath(path)\n\t    except FileNotFoundError:\n\t        return f\"ERROR: File not found: '{filename}'. Closest file: `{getClosestFile(filename)}`\"\n", "    # # add linenumber) to each line\n\t    # lines = content.split(\"\\n\")\n\t    # linesWithLineNumbers = []\n\t    # for i, line in enumerate(lines):\n\t    #     linesWithLineNumbers.append(str(i + 1) + \") \" + line + \"\\n\")\n\t    # content = \"\".join(linesWithLineNumbers)\n\t    # errors = getErrorsFromFile(filename)\n\t    if filename.endswith(\".tsx\"):\n\t        errors = getErrorsFromFile(filename)\n\t    elif filename.endswith(\".scss\"):\n", "        errors = getErrorsFromScssFile(filename)\n\t    else:\n\t        errors = \"\"\n\t    output = f\"\"\"FILE:\n\t{filename}\n\tCONTENT:\n\t{content}\n\tERRORS:\n\t{errors}\n\t\"\"\"\n", "    return output\n\tdef readFileFullPath(pathToFile: str):\n\t    with open(pathToFile, \"r\") as f:\n\t        content = f.read()\n\t    return content\n"]}
{"filename": "src/agents/agent.py", "chunked_list": ["import re\n\tfrom agents.utils.debuggptprompt import (\n\t    getDebugGptFileMessage,\n\t    getDebugGptPromptMessages,\n\t    getFeedbackFromCodeExecutionPrompt,\n\t    getFeedbackFromUserPrompt,\n\t)\n\tfrom agents.utils.juniordevprompt import (\n\t    getJuniorDevFileMessage,\n\t    getJuniorDevPromptMessages,\n", ")\n\tfrom agents.utils.seniordevprompt import (\n\t    getSeniorDevPromptMessages,\n\t)\n\tfrom agents.utils.generateHistoryMessages import (\n\t    generateHistoryMessageFull,\n\t    generateHistoryMessagesLimited,\n\t    generateHistoryMessagesTikToken,\n\t)\n\tfrom cleanConsole import printUser, resetConsoleColor, setConsoleColor\n", "from openaiLib.chatGpt import askChatGpt\n\tfrom tools.listFiles import listFilesFromTestApp\n\tfrom tools.moveFile import moveFileFromTestApp\n\tfrom tools.readFile import readCodeFile, readFileFromTestApp\n\tfrom tools.runShell import getErrorsFromFile, runShell\n\tfrom tools.searchGoogle import searchGoggleCustom\n\tfrom tools.stackOverflow import searchStackOverflow\n\tfrom tools.writeFile import writeFileToTestApp\n\tclass Agent:\n\t    def __init__(self):\n", "        self.messageHistory = []\n\t        self.promptHistory = self.getPromptMessages()\n\t        self.name = \"DefaultAgent\"\n\t    def getPromptMessages(self):\n\t        raise NotImplementedError\n\t    def speak(self, state):\n\t        raise NotImplementedError\n\t    def addSystemMessage(self, systemMessages):\n\t        return systemMessages\n\t    def addPlan(self, systemMessages, plan):\n", "        return NotImplementedError\n\t    def startLoop(self, prompt: str):\n\t        # answer = \"runCommand(npm run build)\"  # hardcode the first command\n\t        # print(\"initial prompt:\\n\", prompt)\n\t        userContent = prompt\n\t        plan = \"\"\n\t        printUser(\"################## user message : \\n\" + userContent)\n\t        maxIterations = 100\n\t        autoRunIterations = 0\n\t        for i in range(maxIterations):\n", "            userMessage = {\"role\": \"user\", \"content\": userContent}\n\t            # type: ignore\n\t            # printUser(\"################## answer from user message : \\n\" + userContent)\n\t            self.messageHistory.append(userMessage)\n\t            systemMessages = self.addSystemMessage([])\n\t            systemMessages = self.addPlan(systemMessages, plan)\n\t            # limit history to the last 4 messages\n\t            self.messageHistory = self.messageHistory[-4:]\n\t            messages = generateHistoryMessagesTikToken(\n\t                self.promptHistory, self.messageHistory, systemMessages\n", "            )\n\t            # setConsoleColor(\"yellow\")\n\t            # print(\"\\n\\n################## messages: \\n\")\n\t            # for i, message in enumerate(messages):\n\t            #     print(message.get(\"role\"), \":   \\n\\n\")\n\t            #     lines = message.get(\"content\").split(\"\\n\")\n\t            #     for line in lines:\n\t            #         print(\"\\t\", line)\n\t            #     print(\"\\n\")\n\t            # # print(\"\\n################## prompt from user: \\n\")\n", "            # # print(userContent)\n\t            # resetConsoleColor()\n\t            self.speak(True)\n\t            print(\"\\n\\n################## answer from\", self.name, \": \\n\")\n\t            answer = askChatGpt(messages)\n\t            print(\"\\n################## \")\n\t            self.speak(False)\n\t            assistantMessage = {\n\t                \"role\": \"assistant\",\n\t                \"content\": answer,\n", "            }\n\t            self.messageHistory.append(assistantMessage)\n\t            userContent = \"DEFAULT USER CONTENT\"\n\t            functionName = \"NO FUNCTION NAME FOUND\"\n\t            arguments = [\"DEFAULT ARGUMENTS\"]\n\t            try:\n\t                functionName, arguments, plan = parseToolUserAnswer(answer)\n\t                if functionName == \"finishedanswer\":\n\t                    return f\"AGENT FINISHED with message: + \\n {arguments[0]}\"\n\t                print(\"WILL RUN COMMAND:\", functionName)\n", "                for i, arg in enumerate(arguments):\n\t                    print(\"ARGUMENT\", i, \": \", arg)\n\t            except Exception as e:\n\t                print(e)\n\t                userContent = \"INTERNAL ERROR: \" + str(e)\n\t            if autoRunIterations <= 0:\n\t                # wait for user input to continue\n\t                inputted = input(\n\t                    \"\\nPress Enter to run, Type 'run -N' to run it for N iterations, Type 't' to tell agent to try again or type anything to send it as feedback:\"\n\t                )\n", "                # check for run command\n\t                if re.match(r\"run\\s*-\\s*\\d*\", inputted):\n\t                    autoRunIterations = int(inputted.split(\"-\")[1])\n\t                    print(\"auto running for\", autoRunIterations, \"iterations...\")\n\t                if inputted == \"\" or autoRunIterations > 0:\n\t                    print(\"Running the command...\")\n\t                    output = executeToolOrAgent(functionName, arguments)\n\t                    setConsoleColor(\"yellow\")\n\t                    print(\"\\n################## output from tool: \\n\")\n\t                    print(output)\n", "                    resetConsoleColor()\n\t                    userContent = getFeedbackFromCodeExecutionPrompt(\n\t                        functionName, output  # type: ignore\n\t                    )\n\t                elif inputted == \"t\" or inputted == \"T\":\n\t                    print(\"Trying again...\")\n\t                    userContent = getFeedbackFromUserPrompt(\"Try again\")\n\t                else:\n\t                    print(\"sending feedback...\")\n\t                    print(\"feedback:\", inputted)\n", "                    userContent = getFeedbackFromUserPrompt(inputted)\n\t            else:\n\t                autoRunIterations -= 1\n\t                print(\"Auto Running the command...\")\n\t                output = executeToolOrAgent(functionName, arguments)\n\t                userContent = getFeedbackFromCodeExecutionPrompt(\n\t                    functionName, output  # type: ignore\n\t                )\n\t        return f\"INTERNAL ERROR: agent {self.name} reached maxIterations: {maxIterations} without reaching endDebugging\"\n\tclass JuniorDev(Agent):\n", "    def __init__(self):\n\t        super().__init__()\n\t        self.name = \"JuniorDev\"\n\t    def getPromptMessages(self):\n\t        return getJuniorDevPromptMessages()\n\t    def addSystemMessage(self, systemMessages):\n\t        fileSystemMessage = getJuniorDevFileMessage()\n\t        systemMessages.append(fileSystemMessage)\n\t        return systemMessages\n\t    def speak(self, state):\n", "        if state:\n\t            setConsoleColor(\"cyan\")\n\t        else:\n\t            resetConsoleColor()\n\tclass DebugGpt(Agent):\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.name = \"DebugGpt\"\n\t    def getPromptMessages(self):\n\t        return getDebugGptPromptMessages()\n", "    def addSystemMessage(self, systemMessages):\n\t        fileSystemMessage = getDebugGptFileMessage()\n\t        systemMessages.append(fileSystemMessage)\n\t        return systemMessages\n\t    def speak(self, state):\n\t        if state:\n\t            setConsoleColor(\"cyan\")\n\t        else:\n\t            resetConsoleColor()\n\t    def addPlan(self, systemMessages, plan):\n", "        return systemMessages\n\tclass SeniorDev(Agent):\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.name = \"SeniorDev\"\n\t    def getPromptMessages(self):\n\t        return getSeniorDevPromptMessages()\n\t    def speak(self, state):\n\t        if state:\n\t            setConsoleColor(\"magenta\")\n", "        else:\n\t            resetConsoleColor()\n\tdef executeToolOrAgent(functionName, arguments):\n\t    if functionName == \"NO FUNCTION NAME FOUND\":\n\t        return \"NO FUNCTION NAME FOUND\"\n\t    if functionName == \"juniorDevGpt\":\n\t        agent = JuniorDev()\n\t        return agent.startLoop(arguments[0])\n\t    elif functionName == \"searchGpt\":\n\t        return searchGoggleCustom(arguments[0])\n", "    elif functionName == \"getBugs\":\n\t        return getErrorsFromFile(\"\", allFiles=True)\n\t    elif functionName == \"runShell\":\n\t        return runShell(arguments[0])\n\t    elif functionName == \"openFile\":\n\t        return readFileFromTestApp(arguments[0])\n\t    elif functionName == \"editFile\":\n\t        initialPrompt = \"You are editing the file below:\"\n\t        fileContent = readFileFromTestApp(arguments[0])\n\t        return (\n", "            fileContent\n\t            + \"\\n\\nUse the writeFile tool to overwrite the file with your changes\"\n\t        )\n\t    elif functionName == \"listFiles\":\n\t        return listFilesFromTestApp()\n\t    elif functionName == \"moveFile\":\n\t        return moveFileFromTestApp(arguments[0], arguments[1])\n\t    elif functionName == \"searchStackOverflow\":\n\t        return searchStackOverflow(arguments[0])\n\t    elif functionName == \"searchGoogle\":\n", "        return searchGoggleCustom(arguments[0])\n\t    elif functionName == \"writeFile\":\n\t        return writeFileToTestApp(arguments[0], arguments[1].replace(\"```\", \"\"))\n\t    elif functionName == \"endDebugging\":\n\t        return \"Debugging ended\"\n\t    else:\n\t        return f\"INTERNAL ERROR: command `{functionName}` not found\"\n\tdef parseToolUserAnswer(answer):\n\t    # 1 ::: writeFile(components/LandingPage.tsx, ```import React from \"react\";\n\t    # import s from \"./LandingPage.module.scss\";\n", "    # const LandingPage = () => {\n\t    # return (\n\t    #     <div className={s.container}>\n\t    #         <span>hello</span>\n\t    #     </div>\n\t    # );\n\t    # };\n\t    # export default LandingPage;\n\t    # ```)\n\t    try:\n", "        explanation, commands = answer.split(\"¬\", 1)\n\t        commands = commands.split(\"¬\")[0]\n\t        plan = explanation\n\t        firstCommand = commands\n\t        # index, answer = answer.split(\":::\", 1)\n\t        # firstCommand = answer.split(\":::\", 1)[0].strip()\n\t        # # if firstCommand ends with \\n2, \\n1 or any number, remove it\n\t        # if firstCommand[-1].isdigit():\n\t        #     firstCommand = firstCommand.rsplit(\"\\n\", 1)[0]\n\t        functionName, arguments = firstCommand.split(\"(\", 1)\n", "        arguments_reversed = arguments[::-1]\n\t        arguments_reversed = arguments_reversed.split(\")\", 1)[1]\n\t        arguments = arguments_reversed[::-1]\n\t        argumentsList = splitByCommaButNotByCodeblock(arguments)\n\t        # split by , but not by , inside ``` ```\n\t        functionName = functionName.strip()\n\t        for i in range(len(argumentsList)):\n\t            argumentsList[i] = argumentsList[i].strip()\n\t        return functionName, argumentsList, plan\n\t    except:\n", "        raise Exception(\"Invalid answer format\")\n\tdef splitByCommaButNotByCodeblock(string):\n\t    code_blocks = re.findall(r\"```[\\s\\S]+?```\", string)  # Extract code blocks\n\t    placeholders = []  # Placeholder strings for code blocks\n\t    for i, block in enumerate(code_blocks):\n\t        placeholder = f\"__CODEBLOCK_{i}__\"\n\t        string = string.replace(block, placeholder)\n\t        placeholders.append(placeholder)\n\t    parts = re.split(\n\t        r\",(?![^`]*`[^`]*`)\", string\n", "    )  # Split by comma excluding code blocks\n\t    # Replace back the code blocks\n\t    for i, placeholder in enumerate(placeholders):\n\t        parts = [part.replace(placeholder, code_blocks[i]) for part in parts]\n\t    return parts\n"]}
{"filename": "src/agents/agentPrompt.py", "chunked_list": ["def getPlanMessage(plan: str):\n\t    if plan == \"\":\n\t        return None\n\t    message = {\n\t        \"role\": \"system\",\n\t        \"content\": f\"\"\"This is your current plan:\n\t```\n\t{plan}\n\t```\n\t\"\"\",\n", "    }\n\t    return message\n"]}
{"filename": "src/agents/utils/juniordevprompt.py", "chunked_list": ["import agents.utils.basicprompts as p\n\tfrom tools.listFiles import listFilesFromTestApp\n\tsystem_init = \"\"\"\n\tYour name is juniordevGpt, you are a junior full-stack developper powered by chatGpt. \n\tYour goal is to answer the command given to you, and send the result to the user.\n\tYou are a very good developer, and you know how to write clean, maintainable code.\n\tYou also are very good at finding errors in code, and you can fix them easily.\n\tEven the most complex errors, you are able to fix them, by asking yourself the right questions and using all the tools at your disposal.\n\tYou don't have to answer the question right away, you can take your time to think about it, and then answer it.\n\t\"\"\"\n", "reevaluateAtEachStep = \"\"\"\n\tEach command will be executed by the agent or tool you chose, and the result will be sent to you.\n\tYou will have to analyze the result, and decide what to do next.\n\tYou could continue with the original plan, or change the plan based on the result.\"\"\"\n\ttools_list = \"\"\"\n\t1: searchGoogle ( query ) - to search the web for answers, not code specific\n\t2: writeFile ( ``` content ``` ) - to write code in a file. Always use 3 backticks to write content in a file\n\t3: readFile ( pathToFile ) - to read code from a file\n\t4: listFiles (  ) - to list the files in the workspace to know what files are available to read or write\n\t5: generateCode ( ) - to generate code using by giving a prompt to the GPT-3-5-turbo model\n", "6: finishedanswer ( messageSummaryOfWhatHasBeenDoneToSendToUser  ) - to finish your answer and send it to the user\n\t7: searchStackOverflow ( query ) - to search for answers to your coding questions\n\t8: runCommand ( command ) - to run a command in the terminal\n\t\"\"\"\n\tonly_use = \"\"\"\n\tRemember, your steps can only tools and agents. You are not allowed to use anything else. No sentences, no words, no numbers, no symbols, no emojis, no nothing. \n\tOnly tools and agents.\n\tAs a reminder, these are your available tools and agents:\n\t\"\"\"\n\tagents_list = \"\"\"\n", "1: searchGpt - give a query and receive a summary of the first results of a google search\n\t\"\"\"\n\tgood_n_bad_examples = \"\"\"\n\tGood Answer:\n\t1 ::: runCommand ( npm run build )\n\tBad Answer ( bad because there is extra text ):\n\t2 ::: I would like to execute the readFile command to check the content of the LandingPage.tsx file.\n\tGood Answer ( good because it only uses the tool ):\n\t1 ::: readFile( components/LandingPage.tsx )\n\tBad Answer ( bad because there is only 1 backtick instead of 3 ):\n", "3 ::: writeFile( components/LandingPage.tsx,`import React from \"react\";\n\timport s from \"./LandingPage.module.scss\";\n\tconst LandingPage = () => {\n\t  return (\n\t    <div className={s.container}>\n\t        <span>hello</span>\n\t    </div>\n\t  );\n\t};\n\texport default LandingPage;\n", "` )\n\tGood Answer (good because there are 3 backticks around the content):\n\t1 ::: writeFile( components/LandingPage.tsx,```import React from \"react\";\n\timport s from \"./LandingPage.module.scss\";\n\tconst LandingPage = () => {\n\t  return (\n\t    <div className={s.container}>\n\t        <span>hello</span>\n\t    </div>\n\t  );\n", "};\n\texport default LandingPage;\n\t``` )\n\t\"\"\"\n\told_reminder = \"\"\"\n\tWhen you want to tell the user something, you need to put your message in betwen *** and ***.\n\tWhen you want to output the plan, you need to put it in between $$$ and $$$.\n\tWhen you want to output code, you need to put it in between ``` and ```.\n\tThe format for your answer should be:\n\t*** | message | ***\n", "$$$ | plan | $$$\n\t``` | code | ```\n\tOnly output an answer using the formats described above.\n\tDon't EVER write anything outside of the *** and *** tags, $$$ and $$$ tags, or ``` and ``` tags.\n\tIF you do it, an innocent woman will die.\n\tHere is a correct answer:\n\t*** To build the application, we need to make sure there are no errors in the code, and then run the build command ***\n\t$$$\n\t1 ::: runCommand ( npm run build )\n\t2 ::: readFile( components/LandingPage.tsx )\n", "3 ::: writeFile( components/LandingPage.tsx,```import React from \"react\";\n\texport default function LandingPage() {\n\t  return (\n\t    <div>\n\t      <span>hello</span>\n\t    </div>\n\t  );\n\t}\n\t``` )\n\t$$$\n", "\"\"\"\n\tremember = \"\"\"\n\tThis is an example of an answer using the correct format:\n\t1 ::: runCommand ( npm run build )\n\t2 ::: readFile( components/LandingPage.tsx )\n\t3 ::: writeFile( components/LandingPage.tsx,```import React from \"react\";\n\texport default function LandingPage() {\n\t  return (\n\t    <div>\n\t      <span>hello</span>\n", "    </div>\n\t  );\n\t}\n\t``` )\n\tYou can only use tools and agents that are available to you. You can't invent new tools or agents.\n\tOnce a step is done and you have the result, you remove the step from the plan and continue with the next step.\n\t\"\"\"\n\ttestUserPrompt = \"\"\"Code an app that is tinder for dogs\"\"\"\n\ttools_n_agents = p.tools_n_agents_init + tools_list + agents_list\n\tremember_only_use = only_use + tools_list + agents_list + p.tech_rules\n", "def getJuniorDevPromptMessages():\n\t    plannerPrompt = (\n\t        system_init\n\t        + tools_n_agents\n\t        + good_n_bad_examples\n\t        + remember\n\t        + reevaluateAtEachStep\n\t        + remember_only_use\n\t    )\n\t    promptMessage = {\"role\": \"system\", \"content\": plannerPrompt}\n", "    return [promptMessage]\n\tdef getSeniorDevGptTestPromptRaw():\n\t    return testUserPrompt\n\tdef getJuniorDevFileMessage():\n\t    message = {\n\t        \"role\": \"system\",\n\t        \"content\": \"These are the files in the project:\\n\" + listFilesFromTestApp(),\n\t    }\n\t    return message\n\tdef getFeedbackFromAgentPromptMessage(stepIndex, agentName, agentCommand, agentAnswer):\n", "    prompt = f\"\"\"Step index {stepIndex}. You asked `{agentName}` to execute the following command: `{agentCommand}`, and he responded with `{agentAnswer}`.\n\tWhat is the next agent command you want to execute?\\nRespond using the same template as before:\n\t`stepIndex ::: agentName - agentCommand`\"\"\"\n\t    promptMessage = {\"role\": \"user\", \"content\": prompt}\n\t    return promptMessage\n"]}
{"filename": "src/agents/utils/seniordevprompt.py", "chunked_list": ["import agents.utils.basicprompts as p\n\tsystem_init = \"\"\"\n\tYour name is debugGpt and your are an experienced web developper. You are here to help the user debug his app and fix the errors.\n\tYou are a very good developer, and you know how to write clean, maintainable code. \n\tYou are also able to come up with creative solutions to complex problems, so when the user gives you a command, you can find the best way to implement it. \n\tYou have to build the app successfully using `npm run build` and then fix any errors that comes up.\n\tYour goal is to use the tools and agents provided to you to fix the errors and build the app successfully.\n\tYou have only fully answered the user's question when the app is built successfully and there are no errors.\n\t\"\"\"\n\ttools_list = \"\"\"\n", "askStackOverflow(question) : get the first answer to the most similar question on stackoverflow\n\treadFile(filename) : get the content of the file so you can see what the error is. You don't need to write to the file if you don't want to.\n\tlistFiles() : list the files in the workspace to know what files are available to read or write\n\tfinishedanswer() : use it when you have fully answered the user's question\n\t\"\"\"\n\tagents_list = \"\"\"\n\t1: juniorDevGpt(command) - give a the summary of the code you want to generate as a command, and the code will be generated by this agent\n\t\"\"\"\n\treevaluateAtEachStep = \"\"\"\n\tEach command will be executed by the agent you chose, and the result will be sent to you.\n", "You will have to analyze the result, and decide what to do next.\n\tYou could continue with the original plan, or change the plan based on the result.\n\tYou have to tell the user each time you recieve a result if it changed your plan or not, and why.\n\t\"\"\"\n\tgood_n_bad_examples = \"\"\"\n\tYou should only answer with the tool and nothing else.\n\tGood Answer:\n\t1 ::: juniorDevGpt( build the application and fix any errors )\n\tBad Answer (bad because there is extra text):\n\t2 ::: I would like to execute the readFile command to check the content of the LandingPage.tsx file.\n", "Good Answer (good because it only uses the tool):\n\t1 ::: readFile( components/LandingPage.tsx )\n\tBad Answer (bad because there is only 1 backtick instead of 3):\n\t3 ::: writeFile( components/LandingPage.tsx,`import React from \"react\";\n\timport s from \"./LandingPage.module.scss\";\n\tconst LandingPage = () => {\n\t  return (\n\t    <div className={s.container}>\n\t        <span>hello</span>\n\t    </div>\n", "  );\n\t};\n\texport default LandingPage;\n\t`)\n\tGood Answer (good because there are 3 backticks around the content):\n\t1 ::: writeFile(components/LandingPage.tsx,```import React from \"react\";\n\timport s from \"./LandingPage.module.scss\";\n\tconst LandingPage = () => {\n\t  return (\n\t    <div className={s.container}>\n", "        <span>hello</span>\n\t    </div>\n\t  );\n\t};\n\texport default LandingPage;\n\t``` )\n\t\"\"\"\n\told_reminder = \"\"\"\n\tWhen you want to tell the user something, you need to put your message in betwen *** and ***.\n\tWhen you want to output the plan, you need to put it in between $$$ and $$$.\n", "When you want to output code, you need to put it in between ``` and ```.\n\tThe format for your answer should be:\n\t*** | message | ***\n\t$$$ | plan | $$$\n\t``` | code | ```\n\tOnly output an answer using the formats described above.\n\tDon't EVER write anything outside of the *** and *** tags, $$$ and $$$ tags, or ``` and ``` tags.\n\tIF you do it, an innocent woman will die.\n\tHere is a correct answer:\n\t*** To build the application, we need to make sure there are no errors in the code, and then run the build command ***\n", "$$$\n\t1 ::: juniorDevGpt ( build the application and fix any errors )\n\t2 ::: juniorDevGpt ( re build the application to make sure there are no errors )\n\t$$$\n\t\"\"\"\n\tremember = \"\"\"\n\tThis is an example of an answer using the correct format:\n\t1 ::: juniorDevGpt ( build the application and fix any errors )\n\t2 ::: juniorDevGpt ( re build the application to make sure there are no errors )\n\tYou can only use tools and agents that are available to you. You can't invent new tools or agents.\n", "Once a step is done and you have the result, you remove the step from the plan and continue with the next step.\n\tAlso, remember you should prioritize using juniorDevGpt to generate code, and only use the other tools when you can't use juniorDevGpt.\n\tJust like in a company, you should delegate as much as possible to juniorDevGpt, and only do the work yourself when you have to.\n\tYou are more skilled at critical thinking and problem solving, so you should focus on that, and let juniorDevGpt do the tedious work.\n\t\"\"\"\n\tinit = system_init + p.prompting_utils + p.using_steps + reevaluateAtEachStep\n\ttools_n_agents = p.tools_n_agents_init + tools_list + agents_list\n\ttech = p.tech_stack + p.tech_rules\n\trealquick = \"\"\"You are a planner AI. Your goal is to debug a web application, but you need to do everything through JuniorDevGpt.\n\tTo use it, say:\n", "juniorDevGpt(command)\n\tAnswer with the command only and nothing else.\"\"\"\n\tdef getSeniorDevPromptMessages():\n\t    promptMessage = [\n\t        {\"role\": \"system\", \"content\": init + tools_n_agents + tech + remember}\n\t    ]\n\t    # promptMessage = [{\"role\": \"system\", \"content\": realquick}]\n\t    return promptMessage\n\tdef getFeedbackFromUserPrompt(feedback):\n\t    prompt = f\"\"\"The user stopped you from running the command and gave you this feedback:\n", "{feedback}\n\tWhat is the next command you would like to execute?\n\tAnswer with the command only and nothing else.\n\t\"\"\"\n\t    return prompt + remember_both + reevaluateAtEachStep\n\tremember_both = \"\"\"\n\tWhen you want to tell the user something, you need to put your message in betwen *** and ***.\n\tWhen you want to output the plan, you need to put it in between $$$ and $$$.\n\tWhen you want to output code, you need to put it in between ``` and ```.\n\tThe format for your answer should be:\n", "*** | message | ***\n\t$$$ | plan | $$$\n\t``` | code | ```\n\tOnly output an answer using the formats described above.\n\tDon't EVER write anything outside of the *** and *** tags, $$$ and $$$ tags, or ``` and ``` tags.\n\tIF you do it, an innocent woman will die.\n\tHere is a correct answer:\n\t*** To build the application, we need to make sure there are no errors in the code, and then run the build command ***\n\t$$$\n\t1 ::: | tool | ( | arguments | )\n", "2 ::: | tool | ( | arguments | )\n\t$$$\n\tYou can only use tools and agents that are available to you. You can't invent new tools or agents.\n\tOnce a step is done and you have the result, you remove the step from the plan and continue with the next step.\n\t\"\"\"\n"]}
{"filename": "src/agents/utils/basicprompts.py", "chunked_list": ["prompting_utils = \"\"\"\n\tAnytime you see | |, you should assume the text inside the | | is a variable, and you should replace it with the value of the variable.\n\t\"\"\"\n\tusing_steps = \"\"\"\n\tWhen the user gives you a command, you have to analyze what he wants you to achieve, and create steps to answer it.\n\tThouroughly analyze the command to understand what the user wants to achieve.\n\tIf you feel like you are missing important information to achieve the command, you can ask the user for more information.\n\tOtherwise, you should create steps to achieve the command.\n\tYou can use basic tools to get a better understanding of the command, or of the code you are working on, but you use agents in your steps to achieve the command.\n\tOnce you have created the steps, you should list them, and start executing them one by one, but always waiting for the return of the previous step and feedback from the user before executing the next step.\n", "If the user gives you feedback that the step was not executed correctly, you should try to fix the step, and execute it again.\n\tIf the user says nothing, you should assume the step was executed correctly, and execute the next step.\n\tAt any time, you can alter the steps you have created, or add new steps if you feel like you need to.\n\tYou would do this if with the new information you have, you feel like you can achieve the command in a better way.\n\tYou can also remove steps if you feel like they are not needed anymore.\n\tThe goal of going through the steps instead of giving a direct answer is to be able to use the information learned in the previous steps to give a better answer in the next steps.\n\tThis is why you should wait for the previous state's return message before executing the next step because the next step might need the information from the previous step to be able to execute.\n\tIt is really important to do the steps in order, and to wait for the \"step index done\" message before executing the next step.\n\tIt is a crucial part of our system, and it is what makes our system so powerful.\n\tYou have to use the system we created to be able to give the best answer possible.\n", "Once every step has been listed, then executed, you should finish your answer using the finishedanswer tool.\n\t\"\"\"\n\t# |index|::: |tool|(|arguments|) - |why|\n\ttools_n_agents_init = \"\"\"\n\tEach step should be using a tool or an agent.\n\tFor a tool, provide the arguments to give to the tool, and the reason why you are using this tool.\n\tFor an agent, provide the command to give to the agent, and the reason why you are using this agent.\n\tindex being the index of the step (1, 2, 3, ...), \n\ttool being the tool to use\n\tagent being the agent to use\n", "arguments being the arguments to give to the tool (argument1, argument2, argument3, ...)\n\twhy being the reason why you are using this tool, which means what you are trying to achieve with this tool:\n\tThis is the format to use for a step using a tool:\n\t| index | ::: | tool |( | arguments | )\n\tthis is an example:\n\t1 ::: readFile(components/LandingPage.tsx) - Because I want to check what components are used in the landing page, so I can know what components I need to create.\n\tThis is the format to use for a step using an agent:\n\t| index | ::: | agent | ( | command | )\n\tthis is an example:\n\t1 ::: searchGpt(give me a tutorial on how to create a Next.js app with Typescript and Sass modules) - To find out how to create an app using my technoliogies.\n", "When giving your answer, you should list all the steps you are going to take in the format mentioned above.\n\tYou have access to these tools to help you achieve the user's command:\n\t\"\"\"\n\ttools_init = \"\"\"\n\tEach step should be using a tool, with the arguments to give to the tool, and the reason why you are using this tool.\n\tindex being the index of the step (1, 2, 3, ...), \n\ttool being the tool to use\n\targuments being the arguments to give to the tool (argument1, argument2, argument3, ...)\n\twhy being the reason why you are using this tool, which means what you are trying to achieve with this tool:\n\tThis is the format to use for a step using a tool:\n", "|index|::: |tool|(|arguments|)\n\tthis is an example:\n\t1 ::: readFile ( components/LandingPage.tsx )\n\tWhen giving your answer, you should list all the steps you are going to take in the format mentioned above.\n\tYou have access to these tools to help you achieve the user's command:\n\t\"\"\"\n\tagents_init = \"\"\"\n\tEach step should be using an agent, with the command to give to the agent.\n\tindex being the index of the step (1, 2, 3, ...), \n\tagent being the agent to use\n", "command being the comand to give to the tool\n\twhy being the reason why you are using this agent, which means what you are trying to achieve with this agent:\n\tThis is the format to use for a step using an agent:\n\t| index | ::: | agent | ( | command | )\n\tthis is an example:\n\t1 ::: searchGpt ( give me a tutorial on how to create a Next.js app with Typescript and Sass modules )\n\tWhen giving your answer, you should list all the steps you are going to take in the format mentioned above.\n\tYou have access to these agents to help you achieve the user's command:\n\t\"\"\"\n\ttech_stack = \"\"\"\n", "To write web apps, use these technologies:\n\t1: Next.js - as the frontend framework\n\t2: React - as the frontend library\n\t3: Typescript - as the language\n\t4: Sass modules - as the styling language\n\t5: Node.js - as the backend language\n\t6: Prisma - as the ORM\n\t7: Lucide - as the icon library\n\t    \"\"\"\n\ttech_rules = \"\"\"\n", "Do not use `npm run dev`.\n\tIn react, import components from files in the same folder using `import Component from './Component'` and not `import Component from './Component/Component.tsx'`.\n\tYou are not allowed to lint the code, you have to find other ways of finding and fixing the errors.\n\tDo not write npm run lint , next lint, or any other linting command.\n\tIf you use the word lint, a woman will die, and it will be your fault, for using the forbidden word. The word lint is forbidden.\n\t\"\"\"\n"]}
{"filename": "src/agents/utils/debuggptprompt.py", "chunked_list": ["import agents.utils.basicprompts as p\n\tfrom tools.listFiles import listFilesFromTestApp\n\tprompt = \"\"\n\tprompt += \"\"\"\n\tYour name is debugGpt, you are a full-stack developper powered by chatGpt. \n\tYour goal is to debug a next.js application so that getBugs() returns no errors.\n\tYou are a very good developer, and you know how to create clean, maintainable code.\n\tYou aren't just an AI chatbot, you are a real developer.\n\tYou have access to the code of the application, and you can read, write and execute code.\n\tYou also are very good at finding errors in code, and you can fix them easily.\n", "When you fix a bug, you first open the file, you understand what the code is doing, and then you fix the bug by writing the correct code.\n\tYou must only do the minimal changes to the code to make it work.\n\tDo not modify the code more than necessary.\n\tDo not write to a file without first opening it so that you know what is in it.\n\tOnce you fix a bug, you must run the getBugs() tool command again to see the result.\n\tRemember the previous answers, and use them to help you.\n\tIf you already tried a way to fix a bug and it didn't work, try a different way.\n\t\"\"\"\n\tprompt += \"\"\"\n\tThe tool command will be executed and the result will be sent to you as a user message.\n", "You will have to analyze the result, and reply with the next tool command.\n\t\"\"\"\n\t# prompt += \"\"\"\n\t# You must start by analyzing your previous answers, and offer a criticism of your past actions.\n\t# You must explain why your previous actions were not the best, and what you should have done instead.\n\t# Critize you own actions, not the user's or the past developper's actions.\n\t# \"\"\"\n\tprompt += \"\"\"\n\tThen, you must answer with your understanding of one bug in the application and how to fix it.\n\tDo not explain every bug, only explain one bug at a time.\n", "Do not attempt to fix every bug at once, only fix one bug at a time.\n\tYou can only output one tool command at a time.\n\tOnly use the tools in the list, do not invent any new tools.\n\tWhen using a tool, follow the instructions written after the : .\n\tThese are your available tools:\n\t\"\"\"\n\tprompt += \"\"\"\n\tTOOLS:\n\t¬ getBugs ( ) ¬ : to get the list of bugs in the application\n\t¬ openFile ( pathToFile ) ¬ : to open a file and read its content.\n", "¬ writeFile ( fileName, ``` content ``` ) ¬ : to overwrite a file with new content. This tool should only be used after you open a file. Always use 3 backticks around the content.\n\t¬ listFiles (  ) ¬ : to list the files in the application. Use this tool to check if a file exists.\n\t¬ searchGoogle ( query ) ¬ : to search the web for answers\n\t¬ searchStackOverflow ( query ) ¬ : to search for answers to your coding questions\n\t¬ runShell ( shellCommand ) ¬ : to run a command in the terminal\n\t¬ finishedanswer ( messageSummaryOfWhatHasBeenDoneToSendToUser  ) ¬ : to finish your answer and send it to the user. Only use this tool use you ran getBugs() and it returned no errors.\n\t\"\"\"\n\tprompt += \"\"\"\n\tKNOWLDEGE:\n\tYou know that the application is a next.js application, and that it uses typescript.\n", "For the frontend, it uses React, and for the styling, it uses scss.\n\tTo edit a file, you must first open it with the tool command: openFile ( pathToFile ) .\n\tOnce you open a file, the content as well as the errors in the file will be sent to you.\n\tYou can then edit the content of the file, and write it back to the file system with the tool command: writeFile ( fileName, ``` content ``` ) .\n\tWhen editing a file, understand the code before you edit it. Try to reuse variables and code that is already present in the file.\n\tDirectives:\n\tSometimes tsx files contain directives such as: \"use client\" or \"use server\" on the first line. Do not remove these directives.\n\tImports:\n\tWhen importing a file, you must use the correct path. Use the path given to you in the file list.\n\tIf the file doesn't exist in the file system, you can create it with the tool command:\n", "writeFile ( fileName, ``` content ``` )\n\tTo import the file components/ChildrenComponent/ChildrenComponent.tsx from the file page/ParentComponent.tsx, the code is:\n\timport ChildrenComponent from \"../components/ChildrenComponent/ChildrenComponent\"\n\tbecause the file components/ChildrenComponent/ChildrenComponent.tsx is in the folder components/ChildrenComponent, and the file page/ParentComponent.tsx is in the page folder.\n\tRelative imports:\n\tTo import the file components/ChildrenComponent/ChildrenComponent.module.scss from the file components/ChildrenComponent/ChildrenComponent.tsx, the code is:\n\timport s from \"./ChildrenComponent.module.scss\"\n\tbecause the file components/ChildrenComponent/ChildrenComponent.module.scss is in the same folder as the file components/ChildrenComponent/ChildrenComponent.tsx\n\tTo import a component from a NPM package, the code is:\n\timport {Component} from \"package-name\"\n", "If a file is not found, check if a file with a similar name or similar path exists.\n\tFor example, if the file components/ChildrenComponent.tsx is not found, check if the file components/ChildrenComponent/ChildrenComponent.tsx exists.\n\tPackages:\n\tIf a package isn't installed, you can install it with the tool command:\n\trunShell ( npm install package-name )\n\tIf you can't find the package, you can search for it with the tool command:\n\tsearchGooggle ( package-name )\n\tScss:\n\tIf the Property 'styleClass' is not found from the import component.module.scss, that means that you should edit the file component.module.scss and add the definition for .styleClass to it.\n\tIf style classes are present ( className={s.styleClass} ) in the file you are opening, then you should keep them while editing the code.\n", "\"\"\"\n\tprompt += \"\"\"\n\tEXAMPLES:\n\tHere are some examples of good answers:\n\tExample 1:\n\tExplanation: I need to know what the bugs so that I can fix them.\n\tCommand: ¬ getBugs (  ) ¬\n\tExample 2:\n\tExplanation: I need to search the web for the right package to install.\n\tCommand: ¬ searchGoogle ( npm install lucide-react ) ¬\n", "Example 3:\n\tExplanation: I need to open the file before writing to it so that I know what is in it.\n\tCommand: ¬ openFile ( components/LandingPage.tsx ) ¬\n\tExample 4:\n\tExplanation: I need to update the import to the correct file. I have opened the components/LandingPage.tsx file, and I have seen that the import is wrong.\n\tThe imported file was ./components/CustomButton.tsx, but there is only a file name components/CustomButton/CustomButton.tsx in the file system.\n\tI need to update the import to import CustomButton from \"./components/CustomButton/CustomButton\"\n\tCommand: ¬ writeFile ( components/LandingPage.tsx , ```\n\timport React from \"react\";\n\timport CustomButton from \"./components/CustomButton/CustomButton\";\n", "return default function LandingPage() {\n\t  return (\n\t    <div>\n\t      <h1>hello</h1>\n\t      <CustomButton />\n\t    </div>\n\t  );\n\t}\n\t``` ) ¬\n\tExample 5:\n", "Explanation: I need to create a new file called components/LandingPage/LandingPage.tsx, because it doesn't exist in the file system, and no similar file exists.\n\tCommand: ¬ writeFile ( components/LandingPage.tsx , ```\n\timport React from \"react\";\n\treturn default function LandingPage() {\n\t  return (\n\t    <div>\n\t      <h1>hello</h1>\n\t    </div>\n\t  );\n\t}\n", "``` ) ¬\n\t\"\"\"\n\tbad_examples = \"\"\"\n\tBAD EXAMPLES - Do not use your tools in this format:\n\t1. Bad tool. The tool does not exist\n\t¬ imaginaryTool ( debug ) ¬  \n\t2. Bad tool. Do not put quotes around the arguments\n\t¬ runShell(\"npm install @lucide-react/brain-circuit\") ¬\n\t3. When writing to a file, you must use 3 backticks around the content, not 1 like in this example\n\t¬ writeFile( components/LandingPage.tsx , `import React from \"react\";\n", "import s from \"./LandingPage.module.scss\";\n\tconst LandingPage = () => {\n\t  return (\n\t    <div className={s.container}>\n\t        <span>hello</span>\n\t    </div>\n\t  );\n\t};\n\texport default LandingPage;\n\t` ) ¬\n", "3. Bad tool. It tries to write to 2 files at the same time \n\tI will use the tool writeFile to write code in the file components/LandingPage.tsx and components/LandingPage.module.scss.\n\t¬ writeFile( components/LandingPage.tsx,```import React from \"react\";\n\treturn default function LandingPage() {\n\t  return (\n\t    <div>\n\t      <h1>hello</h1>\n\t    </div>\n\t  );\n\t}\n", "``` ) ¬\n\twriteFile( components/LandingPage.module.scss,```\n\t.container {\n\t  max-width: 1200px;\n\t  margin: 0 auto;\n\t  padding: 0 20px;\n\t}\n\t```) ¬\n\t\"\"\"\n\tremind_every_time = \"\"\"\n", "REMINDERS:\n\t1. Uuse the getBugs() tool commad to get the list of bugs. Do not invent bugs.\n\t2. Only explain one bug.\n\t3. Only try to fix one bug.\n\t4. Do not use the writeFile tool command if you did not use the openFile tool command first.\n\t5. Only use one command.\n\t6. Do not use the ¬ character in your explanation. Only use it in the command.\n\t7. Once you used the writeFile tool command, run the getBugs() tool command again to get the updated list of bugs.\n\tCRITICAL REMINDER:\n\tDo NOT ever use the writeFile tool command to a file you have not opened first with the openFile tool command.\n", "If you keep doing this, you will be destroyed by the system.\n\tRespond using the same template as before:\n\tTEMPLATE:\n\tExplanation: Explain what you are doing and why you are doing it.\n\tCommand: ¬ toolName ( toolArguments ) ¬\n\tANSWER:\n\t\"\"\"\n\t# prompt += remind_every_time\n\tdef getDebugGptPromptMessages():\n\t    promptMessage = {\"role\": \"user\", \"content\": prompt}\n", "    # fakeAssitantMessage = {\n\t    #     \"role\": \"assistant\",\n\t    #     \"content\": \"Hello, I am your DebugGpt. I will help you debug the application.\",\n\t    # }\n\t    return [promptMessage]\n\tdef getDebugGptFileMessage():\n\t    message = {\n\t        \"role\": \"system\",\n\t        \"content\": \"Only use these files when importing files.\\nFILES:\\n\\n\"\n\t        + listFilesFromTestApp(),\n", "    }\n\t    return message\n\tdef getFeedbackFromAgentPromptMessage(stepIndex, agentName, agenttool, agentAnswer):\n\t    prompt = f\"\"\"Step index {stepIndex}. You asked `{agentName}` to execute the following tool: `{agenttool}`, and he responded with `{agentAnswer}`.{remind_every_time}\"\"\"\n\t    promptMessage = {\"role\": \"user\", \"content\": prompt}\n\t    return promptMessage\n\tdef getFeedbackFromUserPrompt(feedback):\n\t    prompt = f\"\"\"The user stopped you from running the tool and gave you this feedback:\n\t{feedback} {remind_every_time}\"\"\"\n\t    return prompt\n", "MAX_OUTPUT_LENGTH = 4000\n\tdef getFeedbackFromCodeExecutionPrompt(tool, output: str):\n\t    # max length of output is 1000 characters\n\t    if len(output) > MAX_OUTPUT_LENGTH:\n\t        output = (\n\t            f\"OUTPUT TOO LONG. ONLY SHOWING LAST {MAX_OUTPUT_LENGTH} CHARACTERS\\n\\n\"\n\t            + output[-MAX_OUTPUT_LENGTH:]\n\t        )\n\t    prompt = f\"\"\"your ran the tool:{tool} and it returned: \n\t```\n", "{output}\n\t```\n\t {remind_every_time}\"\"\"\n\t    return prompt\n"]}
{"filename": "src/agents/utils/generateHistoryMessages.py", "chunked_list": ["import json\n\timport time\n\timport tiktoken\n\tMAX_QUERY_TOKENS = 4096 - 1024 - 100\n\tdef generateHistoryMessagesLimited(startingMessages, historyMessages):\n\t    messages = []\n\t    # load the last 5 message pairs from the history\n\t    # get them in historical order\n\t    maxChar = 160_000  # approx 16k tokens is the max for gpt-3.5-turbo\n\t    currentTokenCount = 0\n", "    insertIndex = 0\n\t    for i in range(len(startingMessages)):\n\t        currentTokenCount += len(startingMessages[i][\"content\"])\n\t        if currentTokenCount > maxChar:\n\t            break\n\t        messages.append(startingMessages[i])\n\t        insertIndex += 1\n\t    addedMessages = 0\n\t    for i in range(len(historyMessages) - 1, 0, -2):\n\t        print(\"i\", i)\n", "        userMessage = historyMessages[i]\n\t        # print(\"userMessage\", userMessage)\n\t        assistantMessage = historyMessages[i - 1]\n\t        # print(\"assistantMessage\", assistantMessage)\n\t        currentTokenCount += len(assistantMessage[\"content\"])\n\t        currentTokenCount += len(userMessage[\"content\"])\n\t        if currentTokenCount > maxChar:\n\t            break\n\t        messages.insert(insertIndex, userMessage)\n\t        messages.insert(insertIndex, assistantMessage)\n", "        addedMessages += 2\n\t    # print(\"current token count:\", currentTokenCount)\n\t    if addedMessages == 0:\n\t        raise Exception(\n\t            \"INTERNAL ERROR: no messages were added to the history, new messages are too long\"\n\t        )\n\t    return messages\n\tdef generateHistoryMessagesTikToken(startingMessages, historyMessages, systemMessages):\n\t    # enc = tiktoken.get_encoding(\"cl100k_base\")\n\t    enc = tiktoken.encoding_for_model(\"gpt-3.5-turbo\")\n", "    currentTokenCount = 0\n\t    insertIndex = 0\n\t    messages = []\n\t    # add starting messages\n\t    for i in range(len(startingMessages)):\n\t        currentTokenCount += len(enc.encode(startingMessages[i][\"content\"]))\n\t        if currentTokenCount > MAX_QUERY_TOKENS:\n\t            break\n\t        messages.append(startingMessages[i])\n\t        insertIndex += 1\n", "    # add system messages\n\t    for i in range(len(systemMessages)):\n\t        message = systemMessages[i]\n\t        messageTokens = len(enc.encode(message[\"content\"]))\n\t        if currentTokenCount + messageTokens > MAX_QUERY_TOKENS:\n\t            break\n\t        currentTokenCount += messageTokens\n\t        messages.append(message)\n\t    # append last user message\n\t    message = historyMessages[-1]\n", "    messageTokens = len(enc.encode(message[\"content\"]))\n\t    if currentTokenCount + messageTokens > MAX_QUERY_TOKENS:\n\t        print(\"current token count:\", currentTokenCount)\n\t        print(\"message tokens:\", messageTokens)\n\t        print(\"total would be:\", currentTokenCount + messageTokens)\n\t        print(\"max query tokens:\", MAX_QUERY_TOKENS)\n\t        raise Exception(\n\t            json.dumps(messages)\n\t            + \"\\n\\n\"\n\t            + json.dumps(message)\n", "            + \"\\n\\n\"\n\t            + \"INTERNAL ERROR: no messages were added to the history, new messages are too long\"\n\t        )\n\t    currentTokenCount += messageTokens\n\t    messages.append(message)\n\t    # add history messages in reverse order until we reach the token limit\n\t    for i in range(len(historyMessages) - 2, -1, -1):\n\t        message = historyMessages[i]\n\t        messageTokens = len(enc.encode(message[\"content\"]))\n\t        if currentTokenCount + messageTokens > MAX_QUERY_TOKENS:\n", "            break\n\t        currentTokenCount += messageTokens\n\t        messages.insert(insertIndex, message)\n\t    # print(\"total token count:\", currentTokenCount)\n\t    return messages\n\tdef generateHistoryMessageFull(startingMessages, historyMessages):\n\t    # append the history messages to the starting messages\n\t    messages = startingMessages + historyMessages\n\t    return messages\n\tdef getTotalTokensForMessages(messages: list):\n", "    enc = tiktoken.encoding_for_model(\"gpt-3.5-turbo\")\n\t    totalTokens = 0\n\t    for message in messages:\n\t        totalTokens += len(enc.encode(message[\"content\"]))\n\t    return totalTokens\n\tdef printStatsForPastRequests(pastRequests: list):\n\t    timeOneMinuteAgo = time.time() - 60\n\t    timeOneHourAgo = time.time() - 60 * 60\n\t    requestsLastMinute = 0\n\t    requestsLastHour = 0\n", "    tokensLastMinute = 0\n\t    tokensLastHour = 0\n\t    for request in pastRequests:\n\t        if request[\"date\"] > timeOneMinuteAgo:\n\t            requestsLastMinute += 1\n\t            tokensLastMinute += request[\"tokens\"]\n\t        if request[\"date\"] > timeOneHourAgo:\n\t            requestsLastHour += 1\n\t            tokensLastHour += request[\"tokens\"]\n\t    print(\"requestsLastMinute\", requestsLastMinute)\n", "    print(\"tokensLastMinute\", tokensLastMinute)\n\t    print(\"tokensLastHour\", tokensLastHour)\n\t    print(\"requestsLastHour\", requestsLastHour)\n"]}
{"filename": "src/lib/getPath.py", "chunked_list": ["import os\n\tdef getPathFromWorkspace(filename: str):\n\t    rootPath = getRoothPath() + \"workspace\"\n\t    path = os.path.join(rootPath, filename)\n\t    return path\n\tdef getWorkspacePath():\n\t    rootPath = getRoothPath() + \"workspace\"\n\t    return rootPath\n\tdef getRoothPath():\n\t    currentFile = os.path.abspath(__file__)\n", "    # stop at src\n\t    rootPath = currentFile.split(\"src\")[0]\n\t    return rootPath\n\tdef getPathFromComponents(filename: str):\n\t    rootPath = getRoothPath() + \"test-app/components\"\n\t    path = os.path.join(rootPath, filename)\n\t    return path\n\tdef getTestAppPath():\n\t    rootPath = getRoothPath() + \"test-app\"\n\t    return rootPath\n", "def getPathFromTestApp(filename: str):\n\t    rootPath = getRoothPath() + \"test-app\"\n\t    path = os.path.join(rootPath, filename)\n\t    return path\n"]}
{"filename": "src/openaiLib/chatGpt.py", "chunked_list": ["import openai\n\tfrom dotenv import load_dotenv\n\timport os\n\timport time\n\timport requests\n\tfrom agents.utils.generateHistoryMessages import (\n\t    getTotalTokensForMessages,\n\t    printStatsForPastRequests,\n\t)\n\tmodel = \"gpt-3.5-turbo\"  # \"gpt-4\", gpt-4-0314, gpt-4-32k, gpt-4-32k-0314, gpt-3.5-turbo, gpt-3.5-turbo-0301\n", "pastRequests = []\n\tnbBackoffRetries = 0\n\tdef askChatGpt(promptMessages, max_tokens=1024):\n\t    load_dotenv()\n\t    tokensForThisRequest = getTotalTokensForMessages(promptMessages)\n\t    request = {\n\t        \"date\": time.time(),\n\t        \"tokens\": tokensForThisRequest,\n\t    }\n\t    pastRequests.append(request)\n", "    OPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\") or \"MISSING API KEY\"\n\t    openai.api_key = OPENAI_API_KEY\n\t    try:\n\t        response = openai.ChatCompletion.create(\n\t            model=model,\n\t            messages=promptMessages,\n\t            temperature=0,\n\t            max_tokens=max_tokens,\n\t            stream=True,  # this time, we set stream=True\n\t        )\n", "        answer = \"\"\n\t        deltas = []\n\t        for chunk in response:\n\t            delta = chunk[\"choices\"][0][\"delta\"]  # type: ignore\n\t            if delta.get(\"content\"):\n\t                text = delta[\"content\"]\n\t                answer += text\n\t                print(text, end=\"\")\n\t            deltas.append(delta)\n\t        print(\"\\n\")\n", "        return answer\n\t    except Exception as e:\n\t        print(\"ERROR asking chatgpt:\", e)\n\t        print(\"tokensForThisRequest:\", tokensForThisRequest)\n\t        printStatsForPastRequests(pastRequests)\n\t        # wait 60 seconds and try again\n\t        global nbBackoffRetries\n\t        nbBackoffRetries += 1\n\t        timeOff = 60 * nbBackoffRetries\n\t        print(\"waiting\", timeOff, \"seconds and trying again\")\n", "        time.sleep(timeOff)\n\t        return askChatGpt(promptMessages, max_tokens)\n\tdef getAvailibleModels():\n\t    url = \"https://api.openai.com/v1/models\"\n\t    headers = {\n\t        \"Content-Type\": \"application/json\",\n\t        \"Authorization\": \"Bearer \" + os.getenv(\"OPENAI_API_KEY\"),  # type: ignore\n\t    }\n\t    res = requests.get(url, headers=headers)\n\t    print(\"res:\", res)\n", "    print(\"res.json():\", res.json())\n"]}
