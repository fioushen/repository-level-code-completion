{"filename": "packages/python/setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\tfor name in ['dynamic-sh', 'dynamic-llm', 'dynamic-api']:\n\t    setup(\n\t        name=name,\n\t        version='0.0.2',\n\t        description='Dynamic âš¡ is a new open-source framework that streamlines the process of building production-ready applications with LLMs. Now in beta.',\n\t        authors=['Furqan Rydhan <furqan@f.inc>', 'Aman Ibrahim <amanmibra@gmail.com>'],\n\t        author_email='',\n\t        packages=find_packages(),\n\t        install_requires=[\n", "            # List of package dependencies\n\t        ],\n\t        classifiers=[\n\t            'Development Status :: 3 - Alpha',\n\t            'Intended Audience :: Developers',\n\t            'License :: OSI Approved :: MIT License',\n\t            'Programming Language :: Python :: 3',\n\t            'Programming Language :: Python :: 3.6',\n\t            'Programming Language :: Python :: 3.7',\n\t            'Programming Language :: Python :: 3.8',\n", "            'Programming Language :: Python :: 3.9',\n\t            'Programming Language :: Python :: 3.10',\n\t        ],\n\t)"]}
{"filename": "packages/python/example/app.py", "chunked_list": ["from dynamic import start_server\n\tfrom dynamic.router import Router, Route\n\tfrom agent import inline_agent, streaming_agent, chat_agent\n\tfrom chain import chain\n\tif __name__ == \"__main__\":\n\t    langchain_routes = [\n\t        Route(path=\"/inline_agent\", handle=inline_agent, inline=True),\n\t        Route(path=\"/agent\", handle=chat_agent, streaming=True),\n\t        Route(path=\"/chain\", handle=chain, inline=True),\n\t    ]\n", "    start_server(router=Router(routes=langchain_routes))"]}
{"filename": "packages/python/example/agent.py", "chunked_list": ["import logging\n\tfrom typing import Union\n\tfrom dotenv import load_dotenv\n\tfrom langchain.schema import AgentAction, AgentFinish\n\tload_dotenv()\n\tfrom langchain.agents import AgentType, initialize_agent, load_tools\n\tfrom langchain.llms import OpenAI\n\tfrom langchain.chat_models import ChatOpenAI\n\tfrom langchain.memory import ConversationBufferMemory\n\tfrom dynamic.classes.dynamic_agent  import DynamicAgent\n", "llm = OpenAI(temperature=0, streaming=True, verbose=True)\n\ttool_list = [\"google-serper\"]\n\tinline_agent = initialize_agent(\n\t    tools=load_tools(tool_list), llm=llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True,\n\t)\n\tstreaming_agent = DynamicAgent(\n\t    tool_list=tool_list, llm=llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True,\n\t)\n\tmemory = ConversationBufferMemory(memory_key=\"chat_history\", return_messages=True)\n\tchat_llm = ChatOpenAI(temperature=0, streaming=True)\n", "chat_agent = DynamicAgent(\n\t    tool_list=tool_list,\n\t    llm=chat_llm,\n\t    agent=AgentType.CHAT_CONVERSATIONAL_REACT_DESCRIPTION,\n\t    verbose=True,\n\t    memory=memory,\n\t)"]}
{"filename": "packages/python/example/chain.py", "chunked_list": ["from dotenv import load_dotenv\n\tload_dotenv()\n\tfrom langchain.prompts import PromptTemplate\n\tfrom langchain.llms import OpenAI\n\tfrom langchain.chains import LLMChain\n\tllm = OpenAI(\n\t    client=None,\n\t    temperature=0.9,\n\t)\n\tprompt = PromptTemplate(\n", "    input_variables=[\"product\"],\n\t    template=\"What is a good name for a company that makes {product}?\",\n\t)\n\tchain = LLMChain(llm=llm, prompt=prompt)"]}
{"filename": "packages/python/example/routes/__init__.py", "chunked_list": ["\"\"\"\n\tFile based routing is meant to skip this file\n\t\"\"\"\n\tdef handler():\n\t    pass\n\tdef get_foo():\n\t    return 'foo'\n\tdef delete_foo():\n\t    return 'foo-delete'\n\tclass User:\n", "    def __init__():\n\t        pass\n\t    def test():\n\t        pass"]}
{"filename": "packages/python/example/routes/file_based_agent.py", "chunked_list": ["from dotenv import load_dotenv\n\tload_dotenv()\n\tfrom langchain.agents import AgentType, initialize_agent, load_tools\n\tfrom langchain.llms import OpenAI\n\tfrom dynamic import dynamic\n\tfrom dynamic.classes.dynamic_agent  import DynamicAgent\n\tllm = OpenAI(temperature=0, streaming=True, verbose=True)\n\ttool_list = [\"google-serper\"]\n\tinline_agent = initialize_agent(\n\t    tools=load_tools(tool_list), llm=llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True,\n", ")\n\tstreaming_agent = DynamicAgent(\n\t    tool_list=tool_list, llm=llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True,\n\t)\n\t@dynamic(streaming=True)\n\tdef agent():\n\t    return streaming_agent"]}
{"filename": "packages/python/example/routes/user.py", "chunked_list": ["import logging\n\tfrom fastapi import Request\n\tfrom dynamic import dynamic\n\t@dynamic\n\tasync def get(req: Request):\n\t    return dict(message=\"Ran get\")\n\t@dynamic(methods=[\"PUT\", \"POST\"])\n\tasync def put_or_post(req: Request):\n\t    return dict(message=\"Ran put_or_post\")"]}
{"filename": "packages/python/example/routes/foo/bar.py", "chunked_list": ["import typing\n\timport logging\n\tfrom fastapi import Request\n\tfrom dynamic import dynamic\n\t@dynamic(methods=[\"GET\"])\n\tdef get(req: Request) -> typing.Any:\n\t    if req.method == \"GET\":\n\t        return dict(message=\"foo\")\n\t    else:\n\t        logging.warn(\"If you see this message, dynamic decorator method handling is not working correctly\")\n", "        return handle_all()\n\t@dynamic(methods=[\"PUT\", \"POST\"])\n\tasync def put_or_post(req: Request) -> typing.Any:\n\t    data = await req.json()\n\t    message = data.get(\"message\")\n\t    if message:\n\t        return dict(message=message)\n\t    return dict(message=\"foo, called PUT/POST\")\n\tdef handle_all() -> typing.Dict[str, str]:\n\t    return dict(message=\"handle all\")\n", "@dynamic(methods=[\"DELETE\"])\n\tdef delete():\n\t    return dict(message=\"Ran delete()\")"]}
{"filename": "packages/python/dynamic/decorator.py", "chunked_list": ["import logging\n\tfrom functools import wraps\n\tfrom typing import Callable, List, Optional\n\tfrom inspect import iscoroutinefunction\n\tfrom dynamic.classes.dynamic_agent  import DynamicAgent\n\tdef dynamic(\n\t        func: Optional[Callable] = None,\n\t        streaming: bool = False,\n\t        methods: List[str] = [\"GET\"]\n\t    ):\n", "    \"\"\"Dynamic wrapper to declare endpoints\"\"\"\n\t    def decorator(func):\n\t        wrapper = None\n\t        @wraps(func)\n\t        async def http_wrapper(*args, **kwargs):\n\t            if _is_async(func):\n\t                return await func(*args, **kwargs)\n\t            return func(*args, **kwargs)\n\t        @wraps(func)\n\t        def dynamic_wrapper(*args, **kwargs):\n", "            dynamic_handler = func(*args, **kwargs)\n\t            if not isinstance(dynamic_handler, DynamicAgent):\n\t                # If any other Dynamic handlers are added, for instance DynamicChat, make sure to type check here\n\t                raise Exception(f\"Streaming endpoints must return DynamicAgents. {func.__name__} returns {type(func)}.\")\n\t            return dynamic_handler\n\t        if streaming:\n\t            wrapper = dynamic_wrapper\n\t        else:\n\t            wrapper = http_wrapper\n\t        # set dynamic options\n", "        wrapper.streaming = streaming\n\t        wrapper.methods = methods\n\t        return wrapper\n\t    if callable(func):\n\t        return decorator(func)    \n\t    return decorator\n\tdef _is_async(func: Callable) -> bool:\n\t    return iscoroutinefunction(func)"]}
{"filename": "packages/python/dynamic/__init__.py", "chunked_list": ["from dynamic.decorator import dynamic\n\tfrom dynamic.start_server import start_server"]}
{"filename": "packages/python/dynamic/start_server.py", "chunked_list": ["import os\n\timport logging\n\tfrom typing import Any, List, Optional\n\tfrom dynamic.classes.logger import setup_logging\n\tfrom dynamic.protocols.server import Server\n\tfrom dynamic.router import Router, Route\n\tfrom dynamic.router.file_routes_builder import FileRoutesBuilder\n\thost = os.environ.get(\"HOST\", \"0.0.0.0\")\n\tport = int(os.environ.get(\"PORT\", 8000))\n\tsetup_logging()\n", "def start_server(\n\t        router: Router = Router(),\n\t        # TODO: Remove routes in start_server\n\t        routes: Optional[List[Any]] = None,\n\t        static_dir=None,\n\t    ):\n\t    router = _handle_router(router, routes)\n\t    server = Server(router, host=host, port=port, static_dir=static_dir)\n\t    server.start()\n\t    return server\n", "def _handle_router(router: Router, routes: Optional[List[Any]]) -> Router:\n\t    # get path of excuting script\n\t    if routes:\n\t        routes = [\n\t            Route(\n\t                path=path,\n\t                handle=handle,\n\t            ) for path, handle in routes.items()\n\t        ]\n\t    else:\n", "        routes = []\n\t    builder = FileRoutesBuilder()\n\t    if builder.has_file_based_routing():\n\t        logging.info(\"Building file based routes...\")\n\t        routes += builder.get_file_routes()\n\t    if router:\n\t        router.routes += routes\n\t    else:\n\t        router = Router(routes=routes)\n\t    return router\n"]}
{"filename": "packages/python/dynamic/classes/logger.py", "chunked_list": ["import logging\n\timport sys\n\tdef setup_logging():\n\t    logging.basicConfig(\n\t        level=logging.INFO,\n\t        format=\"%(asctime)s - %(levelname)s - %(message)s\",\n\t        handlers=[\n\t            logging.StreamHandler(sys.stdout),\n\t        ],\n\t    )\n"]}
{"filename": "packages/python/dynamic/classes/message.py", "chunked_list": ["from dataclasses import asdict, dataclass, field\n\timport json\n\tfrom typing import Any, Dict, Optional, Union\n\tfrom uuid import uuid4\n\tfrom dynamic.runners.runner import RunnerConfig\n\tclass BaseMessage:\n\t    \"\"\"Message Inteface to be interpreted by websocket server\"\"\"\n\t    def __init__(self, content: str, id: Optional[str] = None):\n\t        self.content = content\n\t        self.id = id\n", "        if self.id is None:\n\t            self.id = str(uuid4())\n\t    def to_dict(self):\n\t        return self.__dict__\n\t    def to_json_dump(self):\n\t        return json.dumps(self.to_dict())\n\tclass ClientMessage(BaseMessage):\n\t    \"\"\"Client-side websocket message\"\"\"\n\t    def __init__(self, config: RunnerConfig, *args, **kwargs):\n\t        self.config = config\n", "        return super(ClientMessage, self).__init__(*args, **kwargs)\n\tclass ServerMessage(BaseMessage):\n\t    \"\"\"Server-side websocket message\"\"\"\n\t    def __init__(self, *args, **kwargs):\n\t        return super(ServerMessage, self).__init__(*args, **kwargs)\n\tclass ErrorMessage(BaseMessage):\n\t    \"\"\"Base Error Message from websocket server\"\"\"\n\t    def __init__(self, error: Exception, *args, **kwargs):\n\t        self.error = str(error)\n\t        self.error_type = error.__class__.__name__\n", "        return super(ErrorMessage, self).__init__(*args, **kwargs)\n"]}
{"filename": "packages/python/dynamic/classes/__init__.py", "chunked_list": []}
{"filename": "packages/python/dynamic/classes/dynamic_agent.py", "chunked_list": ["import logging\n\tfrom typing import Any, List, Optional\n\timport json\n\tfrom uuid import UUID\n\t# fastapi\n\tfrom fastapi import WebSocket\n\t# langchain\n\tfrom langchain.agents import AgentType, load_tools, initialize_agent\n\tfrom langchain.callbacks.base import AsyncCallbackHandler\n\tfrom langchain.schema import LLMResult\n", "from langchain.agents.conversational_chat.output_parser import ConvoOutputParser\n\t# dynamic\n\tfrom dynamic.classes.message import ServerMessage\n\tCHAT_AGENTS = [\n\t    AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION,\n\t    AgentType.CHAT_CONVERSATIONAL_REACT_DESCRIPTION,\n\t    AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,\n\t]\n\tclass DynamicAgent:\n\t    def __init__(self, llm, agent, **kwargs):\n", "        self.llm = llm\n\t        self.agent = agent\n\t        self.kwargs = kwargs\n\t    def _initialize_agent_with_websocket(self, websocket: WebSocket):\n\t        # TODO: Minimize the number of agent inits\n\t        logging.info(\"Setting up streaming settings for agent...\")\n\t        llm = self.llm\n\t        llm.streaming = True\n\t        llm.verbose = True\n\t        llm.callbacks = [WebsocketCallbackHandler(websocket)]\n", "        # chat agent\n\t        if self.agent in CHAT_AGENTS:\n\t            agent_kwargs = self.kwargs.get(\"agent_kwargs\", {})\n\t            agent_kwargs[\"output_parser\"] = DynamicParser()\n\t            self.kwargs[\"agent_kwargs\"] = agent_kwargs\n\t        tool_list = self.kwargs.get(\"tool_list\")\n\t        if tool_list:\n\t            tools = self.kwargs.get(\"tools\", [])\n\t            tools += load_tools(tool_list, llm=llm)\n\t            self.kwargs[\"tools\"] = tools\n", "        logging.info(\"Initializing agent...\")\n\t        return initialize_agent(llm=llm, agent=self.agent, **self.kwargs)\n\tclass DynamicParser(ConvoOutputParser):\n\t    def parse(self, text: str):\n\t        if \"action\" not in text:\n\t            text = json.dumps(dict(action=\"Final Answer\", action_input=text))\n\t        return super().parse(text)\n\tclass WebsocketCallbackHandler(AsyncCallbackHandler):\n\t    def __init__(self, websocket: WebSocket):\n\t        super().__init__()\n", "        self.websocket = websocket\n\t    async def on_llm_new_token(self, token: str, **kwargs) -> None:\n\t        messsage = ServerMessage(\n\t            content=token\n\t        )\n\t        await self.websocket.send_json(messsage.to_dict())"]}
{"filename": "packages/python/dynamic/static/__init__.py", "chunked_list": []}
{"filename": "packages/python/dynamic/protocols/__init__.py", "chunked_list": []}
{"filename": "packages/python/dynamic/protocols/ws.py", "chunked_list": ["import logging\n\tfrom typing import Any, Dict, List\n\tfrom uuid import uuid4\n\timport asyncio\n\tfrom fastapi import WebSocket\n\tfrom dynamic.classes.message import BaseMessage\n\tclass WebSocketAckTimeoutError(Exception):\n\t    pass\n\tDEFAULT_TIMEOUT = 10 # seconds\n\tclass ConnectionManager:\n", "    \"\"\"WebSocket connection manager.\"\"\"\n\t    # TODO: Add logs\n\t    def __init__(self, wait_for_ack = False):\n\t        logging.info(\"ConnectionManager starting...\")\n\t        self.wait_for_ack = wait_for_ack\n\t        self.active_connections: Dict[str, WebSocket] = {}\n\t    async def connect(self, websocket: WebSocket) -> str:\n\t        await websocket.accept()\n\t        id = str(uuid4())\n\t        self.active_connections[id] = websocket\n", "        if self.wait_for_ack:\n\t            # TODO: Make wait_for_ack the default\n\t            try:\n\t                await asyncio.wait_for(websocket.receive(), timeout=DEFAULT_TIMEOUT)\n\t            except Exception as e:\n\t                await websocket.close()\n\t                err_msg = f\"Client acknowledge message exceeded timeout of {DEFAULT_TIMEOUT}s. Please make sure your client is sending a acknowledge message before timeout occurs.\"\n\t                logging.error(err_msg)\n\t                del self.active_connections[id]\n\t                raise WebSocketAckTimeoutError(err_msg)\n", "        logging.info(f\"Websocket with id({id}) is now active.\")\n\t        return id\n\t    def disconnect(self, id: str) -> None:\n\t        logging.info(f\"Removing Websocket with id({id}).\")\n\t        del self.active_connections[id]\n\t    async def send_message(self, websocket: WebSocket, message: BaseMessage) -> None:\n\t        await websocket.send_json(message.to_dict())\n\t    async def send_message_by_id(self, id: str, message: BaseMessage) -> None:\n\t        websocket = self.active_connections.get(id)\n\t        if websocket:\n", "            await self.send_message(websocket, message)\n\t        else:\n\t            logging.warn(f\"Websocket with id({id}) was not found. Message({message}) was not sent.\")\n\t    async def broadcast(self, message: BaseMessage) -> None:\n\t        for connection in self.active_connections.values():\n\t            await connection.send_json(message.to_dict())\n"]}
{"filename": "packages/python/dynamic/protocols/server.py", "chunked_list": ["import os\n\timport uuid\n\timport orjson\n\timport traceback\n\timport logging\n\tfrom typing import Any, Callable, Union\n\t# fastapi\n\tfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request\n\tfrom fastapi.middleware.cors import CORSMiddleware\n\tfrom fastapi.staticfiles import StaticFiles\n", "from starlette.responses import FileResponse\n\timport uvicorn\n\t# dynamic\n\tfrom dynamic.classes.dynamic_agent  import DynamicAgent\n\tfrom dynamic.classes.message import BaseMessage, ErrorMessage, ClientMessage, ServerMessage\n\tfrom dynamic.router import Router, Route\n\tfrom dynamic.runners.utils import get_runner\n\tfrom dynamic.protocols.ws import ConnectionManager, WebSocketAckTimeoutError\n\t# Exceptions\n\tclass RouteNotFound(Exception):\n", "    pass\n\tparent_dir_path = os.path.dirname(os.path.realpath(__file__))\n\tclass Server:\n\t    app = FastAPI(debug=True)\n\t    def __init__(\n\t            self,\n\t            router: Router,\n\t            host: str =\"0.0.0.0\",\n\t            port: int = 8000,\n\t            static_dir: Any = None\n", "        ):\n\t        self.host = host\n\t        self.port = port\n\t        self.connection_manager = ConnectionManager()\n\t        self.router = router\n\t        for route in router.routes:\n\t            self.add_route(route)\n\t        # Enable CORS for your frontend domain\n\t        self.app.add_middleware(\n\t            CORSMiddleware,\n", "            allow_origins=[\"*\"],\n\t            allow_credentials=True,\n\t            allow_methods=[\"*\"],\n\t            allow_headers=[\"*\"],\n\t        )\n\t        if static_dir:\n\t            logging.info(f\"Adding static dir {static_dir}\")\n\t            full_path = \"{}/{}\".format(\n\t                os.path.dirname(os.path.realpath(static_dir)), static_dir\n\t            )\n", "            logging.info(f\"Adding static dir {full_path}\")\n\t            self.app.mount(\n\t                \"/\",\n\t                StaticFiles(directory=full_path),\n\t                name=\"static\",\n\t            )\n\t            self.app.add_route(\"/\", FileResponse(\"{}/index.html\".format(full_path)))\n\t        else:\n\t            self.app.mount(\n\t                \"/static\",\n", "                StaticFiles(directory=parent_dir_path + \"/../static\"),\n\t                name=\"static\",\n\t            )\n\t            self.app.add_route(\n\t                \"/\", FileResponse(parent_dir_path + \"/../static/index.html\")\n\t            )\n\t        self.app.websocket(\"/ws\")(self.websocket_handler)\n\t    def add_route(self, route: Route) -> None:\n\t        \"\"\"Dynamically add routes\"\"\"\n\t        handle = route.handle\n", "        path = route.path\n\t        runner = route.runner\n\t        runner_config_type = route.runner_config_type\n\t        if route.streaming and route.inline:\n\t            raise Exception(f\"Routes cannot have both streaming=True and inline=True. Offending route: {route.path}, {route.methods}\")\n\t        async def run_inline_route(req: Request):\n\t            \"\"\"Non-streaming simple route\"\"\"\n\t            # collect data\n\t            data = await req.json()\n\t            # setup runner config\n", "            config_dict = data.get(\"config\")\n\t            # run runner and return output\n\t            config = runner_config_type(**config_dict)\n\t            output = runner(handle, config, streaming=False).run()\n\t            return dict(\n\t                message=\"Ran inline route successfully!\",\n\t                output=output\n\t            )\n\t        if route.streaming and isinstance(route.handle, DynamicAgent):\n\t            logging.info(f\"Adding websocket route {route.path}\")\n", "            self.app.websocket(route.path)(self.websocket_handler)\n\t        elif route.inline:\n\t            logging.info(f\"Adding inline route {route.path}, methods={route.methods}\")\n\t            self.app.add_api_route(path, run_inline_route, methods=route.methods)\n\t        else:\n\t            logging.info(f\"Adding route path={route.path}, methods={route.methods}\")\n\t            self.app.add_api_route(path, handle, methods=route.methods)\n\t    def start(self):\n\t        logging.info(f\"Starting server on host:port {self.host}:{self.port}\")\n\t        uvicorn.run(\n", "            self.app,\n\t            host=self.host,\n\t            port=self.port,\n\t            log_level=\"info\",\n\t        )\n\t    async def websocket_handler(self, websocket: WebSocket):\n\t        path = websocket.scope.get(\"path\")\n\t        if path is None:\n\t            raise RouteNotFound(\"Websocket recieved a request without a path declared.\")\n\t        async def handle_msg(recieved_message: ClientMessage) -> Union[ServerMessage, ErrorMessage]:\n", "            logging.info(f\"Processing message(id={recieved_message.id}) for route {path}\")\n\t            try:\n\t                # build runner and run incoming input\n\t                route = self.router.get_route(path)\n\t                if not route:\n\t                    err_message = f\"Server's router does not have path, {path}\"\n\t                    logging.error(err_message)\n\t                    raise RouteNotFound(err_message)\n\t                logging.info(f\"Route path {path}\")\n\t                logging.info(f\"Route {route}\")\n", "                handle = route.handle\n\t                runner = route.runner\n\t                streaming = route.streaming\n\t                runner_config_type = route.runner_config_type\n\t                config = runner_config_type(**recieved_message.config)\n\t                # TODO: Add a seperate try/catch for runner arun\n\t                output = await runner(handle, config, websocket=websocket, streaming=streaming).arun()\n\t                # return processed message\n\t                return ServerMessage(content=output)\n\t            except ValueError as e:\n", "                err_content = f\"ERROR: ValueError while processing {recieved_message.__class__.__name__}(id={recieved_message.id}) on route path ({path}). Message values: {recieved_message.to_dict()}\"\n\t                logging.error(err_content)\n\t                traceback.print_exc()\n\t                return ErrorMessage(content=err_content, error=e)\n\t            except Exception as e:\n\t                err_content = f\"ERROR: Unknown Error while processing Message(id={recieved_message.id}) on route path ({path}).\"\n\t                logging.error(err_content)\n\t                traceback.print_exc()\n\t                return ErrorMessage(content=err_content, error=e)\n\t        async def send_msg(message: BaseMessage, broadcast: bool = False) -> None:\n", "            logging.info(f\"Sending message {message.to_json_dump()}\")\n\t            if broadcast:\n\t                await self.connection_manager.broadcast(message)\n\t            else:\n\t                await self.connection_manager.send_message(websocket, message)\n\t        try:\n\t            websocket_id = await self.connection_manager.connect(websocket)\n\t        except WebSocketAckTimeoutError as e:\n\t            raise e\n\t        while True:\n", "            try:\n\t                received_json = await websocket.receive_json()\n\t                incoming_message = ClientMessage(**received_json)\n\t                logging.info(f\"Received message: {incoming_message.to_json_dump()}\")\n\t                outgoing_message = await handle_msg(incoming_message)\n\t                await send_msg(outgoing_message)\n\t            except WebSocketDisconnect as e:\n\t                logging.info(\"WebSocketDisconnect\")\n\t                self.connection_manager.disconnect(websocket_id)\n\t                break\n", "            # TODO: Update error messaging\n\t            except orjson.JSONDecodeError as e:\n\t                err_content = f\"ERROR: failed to handle recieve_json. {e.__class__.__name__} Recieved.\"\n\t                logging.error(err_content)\n\t                await send_msg(ErrorMessage(error=e, content=err_content))\n\t            except KeyError as e:\n\t                err_content = f\"ERROR: failed to handle recieve_json. {e.__class__.__name__} Recieved.\"\n\t                logging.error(err_content)\n\t                await send_msg(ErrorMessage(error=e, content=err_content))\n\t            except RouteNotFound as e:\n", "                err_content = f\"ERROR: failed to handle recieve_json. {e.__class__.__name__} Recieved.\"\n\t                logging.error(err_content)\n\t                await send_msg(ErrorMessage(error=e, content=err_content))\n\t            except TypeError as e:\n\t                err_content = f\"ERROR - {e.__class__.__name__}: the recieved client message was formatted in correctly. \\n Recieved: {received_json}\"\n\t                logging.error(err_content)\n\t                await send_msg(ErrorMessage(error=e, content=err_content))\n\t            except Exception as e:\n\t                err_content = f\"ERROR: Unknown failure to handle recieve_json. {e.__class__.__name__} Recieved.\"\n\t                logging.error(err_content)\n", "                await send_msg(ErrorMessage(error=e, content=err_content))\n"]}
{"filename": "packages/python/dynamic/response/__init__.py", "chunked_list": []}
{"filename": "packages/python/dynamic/request/__init__.py", "chunked_list": []}
{"filename": "packages/python/dynamic/router/router.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom enum import Enum\n\tfrom typing import Callable, List, Optional, Union\n\tfrom dynamic.runners.utils import get_runner\n\tfrom dynamic.runners.callable import CallableRunner\n\tfrom dynamic.runners.langchain import AgentRunner, ChainRunner\n\tclass RouteType(Enum):\n\t    AGENT = \"agent\"\n\t    CHAIN = \"chain\"\n\t    CALLABLE = \"callable\"\n", "_ROUTE_TYPE_TO_RUNNER = {\n\t    RouteType.AGENT: AgentRunner,\n\t    RouteType.CHAIN: ChainRunner,\n\t    RouteType.CALLABLE: CallableRunner,\n\t}\n\t_RUNNER_TO_ROUTE_TYPE = {\n\t    AgentRunner: RouteType.AGENT,\n\t    ChainRunner: RouteType.CHAIN,\n\t    CallableRunner: RouteType.CALLABLE,\n\t}\n", "class Route:\n\t    def __init__(\n\t            self,\n\t            path: str,\n\t            handle: Callable,\n\t            methods: List[str] = [\"GET\"],\n\t            inline: bool = False,\n\t            streaming: bool = False,\n\t            route_type: Optional[RouteType] = None,\n\t    ):\n", "        self.path = path\n\t        self.handle = handle\n\t        self.methods = methods\n\t        self.inline = inline\n\t        self.streaming = streaming\n\t        self.route_type = route_type\n\t        self.runner, self.runner_config_type = get_runner(self.handle)\n\t        if route_type:\n\t            assert _ROUTE_TYPE_TO_RUNNER[route_type] == self.runner, f\"The route_type set {route_type.value} does not match the runner retrieved via handler, {self.runner}.\"\n\t            self.route_type = route_type\n", "        else:\n\t            self.route_type = _RUNNER_TO_ROUTE_TYPE[self.runner]\n\tclass Router:\n\t    def __init__(self, routes: List[Route] = []):\n\t        self.routes: List[Route] = []\n\t        # error checks routes, duplicate paths are problematic atm\n\t        for route in routes:\n\t            self.add_route(route)\n\t    def get_route(self, path: str, method: str = \"GET\") -> Union[Route, None]:\n\t        for route in self.routes:\n", "            if route.path == path and (method in route.methods or route.streaming):\n\t                return route\n\t        return None\n\t    def add_route(self, route: Route):\n\t        for r in self.routes:\n\t            overlapping_methods = set(r.methods).intersection(set(route.methods))\n\t            # the route path is the same and if one the methods already has an existing handler, then raise exception\n\t            if r.path == route.path and len(overlapping_methods) > 0:\n\t                raise Exception(f\"Duplicate path (\\\"{route.path}\\\") + method(s) found, {overlapping_methods}. All incoming routes must have unique path (both http and websocket) and methods.\")\n\t        self.routes.append(route)\n"]}
{"filename": "packages/python/dynamic/router/__init__.py", "chunked_list": ["from dynamic.router.router import Router, Route"]}
{"filename": "packages/python/dynamic/router/get_file_routes.py", "chunked_list": ["import importlib.util\n\timport os\n\timport inspect\n\timport sys\n\timport logging\n\tfrom dynamic.router import Route\n\tMODULE_EXTENSIONS = '.py'\n\tDEFAULT_ROUTES_DIRECTORY = \"/routes\"\n\tDEFAULT_HANDLER_NAME = \"handler\"\n\tdef get_file_routes():\n", "    packages = [_get_package_contents(package) for package in _get_list_of_routes()]\n\t    handlers = {\n\t        _get_route_name(package.__file__): _get_valid_module_functions(package)\n\t        for package in packages\n\t    }\n\t    routes = []\n\t    for path, handle in handlers.items():\n\t        if handle:\n\t            route = Route(path=path, handle=handle, streaming=False)\n\t            routes.append(route)\n", "    logging.info(f\"Grabbing {len(routes)} file-based routes...\")\n\t    return routes\n\tdef has_file_based_routing():\n\t    route_dir_path = _get_route_dir_path()\n\t    return os.path.exists(route_dir_path)\n\t####################\n\t# Helper Functions #\n\t####################\n\tdef _get_valid_module_functions(package):\n\t    module_members = inspect.getmembers(package, inspect.isfunction)\n", "    for name, func in module_members:\n\t        if name == DEFAULT_HANDLER_NAME:\n\t            return func\n\t    file_path = package.__file__.split(DEFAULT_ROUTES_DIRECTORY)[1]\n\t    logging.warn(f\"The module at {file_path} does not have a handler function. Expected a function named '{DEFAULT_HANDLER_NAME}', did not find.\")\n\t    return None\n\tdef _get_package_contents(file_path):\n\t    spec = importlib.util.spec_from_file_location(file_path, location=file_path)\n\t    module = importlib.util.module_from_spec(spec)\n\t    sys.modules[\"module.name\"] = module\n", "    spec.loader.exec_module(module) \n\t    return module\n\tdef _get_route_name(file_path):\n\t    path = file_path.split(MODULE_EXTENSIONS)[0]\n\t    route_path = path.split(DEFAULT_ROUTES_DIRECTORY)[1]\n\t    return route_path\n\tdef _get_list_of_routes():\n\t    route_dir_path = _get_route_dir_path()\n\t    _, files = _run_fast_scandir(route_dir_path, [\".py\"])\n\t    files = [f for f in files if \"__\" not in f]\n", "    return files\n\tdef _run_fast_scandir(dir, ext):    # dir: str, ext: list\n\t    subfolders, files = [], []\n\t    for f in os.scandir(dir):\n\t        if f.is_dir():\n\t            subfolders.append(f.path)\n\t        if f.is_file():\n\t            if os.path.splitext(f.name)[1].lower() in ext:\n\t                files.append(f.path)\n\t    for dir in list(subfolders):\n", "        sf, f = _run_fast_scandir(dir, ext)\n\t        subfolders.extend(sf)\n\t        files.extend(f)\n\t    return subfolders, files\n\tdef _get_route_dir_path():\n\t    path = os.path.dirname(os.path.abspath(sys.argv[0]))\n\t    path = os.path.normpath(path + DEFAULT_ROUTES_DIRECTORY)\n\t    return path"]}
{"filename": "packages/python/dynamic/router/file_routes_builder.py", "chunked_list": ["from dataclasses import dataclass\n\timport importlib.util\n\timport os\n\timport inspect\n\timport sys\n\timport logging\n\tfrom dynamic.router import Route\n\tMODULE_EXTENSIONS = '.py'\n\tDEFAULT_ROUTES_DIRECTORY = \"/routes\"\n\tDEFAULT_HANDLER_NAME = \"handler\"\n", "class FileRoutesBuilder:\n\t    def __init__(self, routes_dir: str = DEFAULT_ROUTES_DIRECTORY):\n\t        self.routes = []\n\t        self._dir_path = self._get_route_dir_path(routes_dir)\n\t    def get_file_routes(self):\n\t        packages = [_get_package_contents(package) for package in self._get_list_of_routes()]\n\t        handlers = {\n\t            _get_route_name(package.__file__): _get_valid_module_handlers(package)\n\t            for package in packages\n\t        }\n", "        routes = []\n\t        for path, handlers in handlers.items():\n\t            existing_methods = set()\n\t            for handle in handlers:\n\t                if handle.streaming:                    \n\t                    if \"ws\" in existing_methods:\n\t                        raise Exception(f\"Each route can only have ONE streaming/websocket endpoints. {path} has declared multiple.\")\n\t                    existing_methods.add(\"ws\")\n\t                    dynamic_handle = handle()\n\t                    route = Route(path=path, handle=dynamic_handle, streaming=True, methods=[])\n", "                    routes.append(route)\n\t                else:\n\t                    if any(m in existing_methods for m in handle.methods):\n\t                        raise Exception(f\"Cannot repeat usage of HTTP methods in the same path (\\\"{path}\\\").\")\n\t                    route = Route(path=path, handle=handle, streaming=False, methods=handle.methods)\n\t                    routes.append(route)\n\t        logging.info(f\"Grabbed {len(routes)} file-based routes...\")\n\t        return routes\n\t    def has_file_based_routing(self):\n\t        return os.path.exists(self._dir_path)\n", "    def _get_route_dir_path(self, routes_dir):\n\t        path = os.path.dirname(os.path.abspath(sys.argv[0]))\n\t        path = os.path.normpath(path + routes_dir)\n\t        return path\n\t    def _get_list_of_routes(self):\n\t        _, files = _run_fast_scandir(self._dir_path)\n\t        files = [f for f in files if \"__\" not in f]\n\t        return files\n\t####################\n\t# Helper Functions #\n", "####################\n\tdef _get_valid_module_handlers(package):\n\t    handlers = []\n\t    module_members = inspect.getmembers(package, inspect.isfunction)\n\t    for name, func in module_members:\n\t        if hasattr(func, \"__wrapped__\"):\n\t            handlers.append(func)\n\t    if len(handlers) == 0:\n\t        file_path = package.__file__.split(DEFAULT_ROUTES_DIRECTORY)[1]\n\t        logging.warn(f\"The module at {file_path} does not have any valid handlers.\")\n", "    return handlers\n\tdef _get_package_contents(file_path):\n\t    \"\"\"Import functions and other modules within a file\"\"\"\n\t    spec = importlib.util.spec_from_file_location(file_path, location=file_path)\n\t    module = importlib.util.module_from_spec(spec)\n\t    sys.modules[\"module.name\"] = module\n\t    spec.loader.exec_module(module) \n\t    return module\n\tdef _get_route_name(file_path):\n\t    \"\"\"Given a file path, return a valid endpoint\n", "    Example: routes/foo/bar.py --> foo/bar\n\t    \"\"\"\n\t    path = file_path.split(MODULE_EXTENSIONS)[0]\n\t    route_path = path.split(DEFAULT_ROUTES_DIRECTORY)[1]\n\t    return route_path\n\tdef _run_fast_scandir(dir, ext=[MODULE_EXTENSIONS]):\n\t    \"\"\"Recurseively find all files in a directory, while also given desired file extension.\"\"\"\n\t    subfolders, files = [], []\n\t    for f in os.scandir(dir):\n\t        if f.is_dir():\n", "            subfolders.append(f.path)\n\t        if f.is_file():\n\t            if os.path.splitext(f.name)[1].lower() in ext:\n\t                files.append(f.path)\n\t    for dir in list(subfolders):\n\t        sf, f = _run_fast_scandir(dir, ext)\n\t        subfolders.extend(sf)\n\t        files.extend(f)\n\t    return subfolders, files\n"]}
{"filename": "packages/python/dynamic/runners/runner.py", "chunked_list": ["\"\"\"\n\tRunner Abstraction - executes an endpoint's functionality\n\t\"\"\"\n\tfrom abc import ABC, abstractmethod\n\tclass RunnerConfig:\n\t    pass\n\tclass Runner(ABC):\n\t    def __init__(self, handle, config, **kwargs):\n\t        self.handle = handle\n\t        self.config = config\n", "    @abstractmethod\n\t    def run(self):\n\t        pass"]}
{"filename": "packages/python/dynamic/runners/__init__.py", "chunked_list": []}
{"filename": "packages/python/dynamic/runners/utils.py", "chunked_list": ["from typing import Any, Tuple\n\tfrom dynamic.runners.runner import Runner, RunnerConfig\n\tfrom dynamic.runners.callable import CallableRunner, CallableRunnerConfig\n\tfrom dynamic.runners.langchain import AgentRunner, ChainRunner, ChainRunnerConfig\n\tfrom dynamic.classes.dynamic_agent  import DynamicAgent\n\tfrom langchain.agents import Agent, AgentExecutor\n\tfrom langchain.chains.base import Chain\n\tdef get_runner(handle: Any) -> Tuple[Runner, RunnerConfig]:\n\t    if isinstance(handle, (Agent, AgentExecutor, DynamicAgent)):\n\t        return AgentRunner, ChainRunnerConfig\n", "    elif isinstance(handle, Chain):\n\t        return ChainRunner, ChainRunnerConfig\n\t    elif callable(handle):\n\t        return CallableRunner, CallableRunnerConfig\n\t    # TODO: Return error, don't raise\n\t    raise ValueError(f\"Dynamic does not support your handler type. Type: {type(handle)}\")"]}
{"filename": "packages/python/dynamic/runners/callable.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom typing import Any, Callable\n\t# dyanmic imports\n\tfrom dynamic.runners.runner import Runner, RunnerConfig\n\t@dataclass\n\tclass CallableRunnerConfig(RunnerConfig):\n\t    params: Any  \n\tclass CallableRunner(Runner):\n\t    def __init__(self, handle: Callable, config: CallableRunnerConfig):\n\t        if not callable(handle):\n", "            raise ValueError(f\"CallableRunner requires handle to be a Callable. Instead got {type(handle)}.\")\n\t        super(CallableRunner, self).__init__(handle, config)\n\t    def run(self):\n\t        return self.handle(**self.config.params)\n"]}
{"filename": "packages/python/dynamic/runners/langchain/agent.py", "chunked_list": ["import asyncio\n\tfrom dataclasses import dataclass\n\tfrom typing import Union, Dict, Optional\n\tfrom fastapi import WebSocket\n\t# dyanmic\n\tfrom dynamic.runners.runner import Runner\n\tfrom dynamic.classes.dynamic_agent  import DynamicAgent\n\tfrom dynamic.runners.langchain.config import ChainRunnerConfig\n\t# langchain\n\tfrom langchain.agents import Agent, AgentExecutor, initialize_agent\n", "class AgentRunner(Runner):\n\t    def __init__(self,\n\t        handle: Union[DynamicAgent, Agent, AgentExecutor],\n\t        config: ChainRunnerConfig,\n\t        websocket: Optional[WebSocket] = None,\n\t        streaming: bool = False,\n\t    ):\n\t        self.streaming = streaming\n\t        self.config = config\n\t        if streaming:\n", "            if not isinstance(handle, DynamicAgent):\n\t                raise ValueError(f\"A streaming Agent needs to a DynamicAgent, recieved {type(handle)}.\")\n\t            handle = handle._initialize_agent_with_websocket(websocket)\n\t        if not (isinstance(handle, Agent) or isinstance(handle, AgentExecutor)):\n\t            raise ValueError(f\"AgentRunner requires handle to be a Langchain Agent or AgentExecutor. Instead got {type(handle)}.\")\n\t        super(AgentRunner, self).__init__(handle, config)\n\t    async def arun(self):\n\t        input = self.config.input\n\t        if self.streaming:\n\t            return await self.handle.arun(input)\n", "        return self.handle.run(input)\n\t    def run(self):\n\t        input = self.config.input\n\t        return self.handle.run(input)\n"]}
{"filename": "packages/python/dynamic/runners/langchain/config.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom typing import Dict, Union\n\tfrom dynamic.runners.runner import RunnerConfig\n\t@dataclass\n\tclass ChainRunnerConfig(RunnerConfig):\n\t    input: Union[str, Dict[str, str]]"]}
{"filename": "packages/python/dynamic/runners/langchain/chain.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom typing import Any, Union, Dict\n\t# dyanmic\n\tfrom dynamic.runners.runner import Runner\n\tfrom dynamic.runners.langchain.config import ChainRunnerConfig\n\t# langchain\n\tfrom langchain.chains.base import Chain\n\tclass ChainRunner(Runner):\n\t    def __init__(self, handle: Chain, config: ChainRunnerConfig, **kwargs):\n\t        if not isinstance(handle, Chain):\n", "            raise ValueError(f\"ChainRunner requires handle to be a Langchain Chain. Instead got {type(handle)}.\")\n\t        super(ChainRunner, self).__init__(handle, config, **kwargs)\n\t    def run(self):\n\t        prompt_input = self.config.input\n\t        return self.handle.run(prompt_input)\n"]}
{"filename": "packages/python/dynamic/runners/langchain/__init__.py", "chunked_list": ["from dynamic.runners.langchain.agent import AgentRunner\n\tfrom dynamic.runners.langchain.chain import ChainRunner\n\tfrom dynamic.runners.langchain.config import ChainRunnerConfig"]}
{"filename": "packages/python/dynamic/runners/langchain/examples/agent.py", "chunked_list": ["\"\"\"\n\tExample Script\n\t\"\"\"\n\timport asyncio\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tfrom langchain.agents import initialize_agent\n\tfrom langchain.agents import AgentType\n\tfrom langchain.llms import OpenAI\n\tfrom langchain.agents.agent_toolkits import NLAToolkit\n", "from dynamic.runners.langchain import AgentRunner, ChainRunnerConfig\n\tif __name__ == \"__main__\":\n\t    llm = OpenAI(\n\t        client=None,\n\t        temperature=0.9,\n\t    )\n\t    tools = NLAToolkit.from_llm_and_url(llm, \"https://api.speak.com/openapi.yaml\").get_tools()\n\t    agent = initialize_agent(\n\t        tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True\n\t    )\n", "    agent_input = dict(input=\"What does \\\"donde esta la biblioteca?\\\" mean? And what is a way to respond to this?\")\n\t    config = ChainRunnerConfig(agent_input=agent_input)\n\t    runner = AgentRunner(agent, config)\n\t    print(\"Runner created and running...\")\n\t    asyncio.run(runner.run())"]}
{"filename": "packages/python/dynamic/runners/langchain/examples/chain.py", "chunked_list": ["from dotenv import load_dotenv\n\tfrom langchain.prompts import PromptTemplate\n\tfrom langchain.llms import OpenAI\n\tfrom langchain.chains import LLMChain\n\tfrom dynamic.runners.langchain.chain import ChainRunner, ChainRunnerConfig\n\tload_dotenv()\n\tif __name__ == \"__main__\":\n\t    llm = OpenAI(\n\t        client=None,\n\t        temperature=0.9,\n", "    )\n\t    prompt = PromptTemplate(\n\t        input_variables=[\"product\"],\n\t        template=\"What is a good name for a company that makes {product}?\",\n\t    )\n\t    chain = LLMChain(llm=llm, prompt=prompt)\n\t    print(\"Testing Runner...\")\n\t    config = ChainRunnerConfig(prompt_input=\"running shoes\")\n\t    runner = ChainRunner(handle=chain, config=config)\n\t    print(\"Runner created and running...\")\n", "    print(runner.run())"]}
{"filename": "packages/python/dynamic/runners/examples/callable.py", "chunked_list": ["from dynamic.runners.callable import CallableRunner, CallableRunnerConfig\n\tif __name__ == \"__main__\":\n\t    print(\"Testing class...\")\n\t    def hello(msg):\n\t        return msg\n\t    config = CallableRunnerConfig(params=dict(msg=\"Hello World!\\n-from Runner\"))\n\t    runner = CallableRunner(hello, config)\n\t    print(\"Runner created and running...\")\n\t    print(runner.run())"]}
