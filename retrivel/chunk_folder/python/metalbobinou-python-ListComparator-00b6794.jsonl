{"filename": "plugins/example_plugin.py", "chunked_list": ["from PluginLogic import PluginLogic\n\t# You can rename the class, but keep its name exactly like the file one\n\tclass example_logic(PluginLogic):\n\t    # Name for calling this plugin\n\t    name_str = \"TEST_PLUGIN\"\n\t    # Text printed when calling the script with wrong parameters\n\t    help_str = \"This is an example plugin that copy the 1st element of each \" \\\n\t        \"list (if the list isn't empty)\"\n\t    # Text of button in the GUI\n\t    button_str = \"Example Plugin\"\n", "    # The main function doing something with the lists and returning a list\n\t    def Logic(self, list1, list2):\n\t        out = []\n\t        if ((not (list1 is None)) and\n\t            (not (list2 is None))):\n\t            if (list1 != []):\n\t                out.append(list1[0])\n\t            if (list2 != []):\n\t                out.append(list2[0])\n\t        return (out)\n"]}
{"filename": "src/plugins_loader.py", "chunked_list": ["import os\n\t# Tools for loading modules and inspecting classes\n\timport importlib\n\timport inspect\n\t# The parent class of the plugins\n\tfrom PluginLogic import PluginLogic\n\t# The directory containing the plugins\n\tg_plugins_directory = \"plugins\"\n\tclass PluginsImporter:\n\t    # List of classes imported from the plugins\n", "    classes_list = []\n\t    nb_classes = 0\n\t    # State of the plugins\n\t    nb_files = 0\n\t    loaded = False\n\t    def __init__(self):\n\t        self.classes_list = []\n\t        self.nb_classes = 0\n\t        self.nb_files = 0\n\t        self.loaded = False\n", "    def LoadPlugins(self):\n\t        # Do not reload plugins if they are already loaded\n\t        if (self.loaded == True):\n\t            return (-1)\n\t        # Check if plugins directory exists\n\t        directory = g_plugins_directory\n\t        if (not (self.__dir_exists_and_not_empty(directory))):\n\t            return (None)\n\t        # List all the files in the \"plugins\" directory, and process them\n\t        for filename in os.listdir(directory):\n", "            filepath = os.path.join(directory, filename)\n\t            absfilepath = os.path.abspath(filepath)\n\t            if (not os.path.isfile(absfilepath)):\n\t                continue\n\t            # Avoid the non python files / Filenames that do not ends by \".py\"\n\t            if (not (filename.split(\".\")[-1] == \"py\")):\n\t                continue\n\t            # Avoid the Parent class that could be loaded by every plugin\n\t            if (filename == \"PluginLogic.py\"):\n\t                continue\n", "            # Count one more file loaded\n\t            self.nb_files += 1\n\t            # Build the name of module in python format : Dir.Class\n\t            submodulename = os.path.splitext(filename)[0]\n\t            modulename = directory + \".\" + submodulename\n\t            # Import the module (import from relative path)\n\t            #module = importlib.import_module(modulename)\n\t            # Import the module (import from absolute path)\n\t            module_spec = importlib.util.spec_from_file_location(modulename, absfilepath)\n\t            module = importlib.util.module_from_spec(module_spec)\n", "            module_spec.loader.exec_module(module)\n\t            # Import classes inside (avoid the \"PluginLogic\"/Parent Class)\n\t            for name, obj in inspect.getmembers(module, inspect.isclass):\n\t                #print(obj)\n\t                #print(obj.__name__)\n\t                # Avoid loading the PluginLogic class\n\t                if (obj.__name__ == \"PluginLogic\"):\n\t                    continue\n\t                # Add the class to the class container\n\t                self.classes_list.append(obj)\n", "        # Count how many classes were loaded\n\t        self.nb_classes = len(self.classes_list)\n\t        # Set the state as \"loaded\"\n\t        self.loaded = True\n\t        return (self.nb_classes)\n\t    # Test if a directory exists and is not empty\n\t    def __dir_exists_and_not_empty(self, directory):\n\t        res = False\n\t        if (os.path.exists(directory)):\n\t            if (os.listdir(directory)):\n", "                res = True\n\t        return (res)\n\t    # Return the list of loaded classes\n\t    def GetClasses(self):\n\t        return (self.classes_list)\n\t    # Return the number of loaded classes\n\t    def GetNbClasses(self):\n\t        return (len(self.classes_list))\n\t    # Return the number of files read\n\t    def GetNbFilesLoaded(self):\n", "        return (self.nb_files)\n\t    # Return the state of the loader\n\t    def IsAlreadyLoaded(self):\n\t        return (self.loaded)\n\t### Example of how to load classes in different manners\n\t#def importer1():\n\t#    BasicSet = importlib.import_module(\"basic_set_operators\")\n\t#    BasicOcc = importlib.import_module(\"basic_occurrencies_operators\")\n\t#\n\t#    l1 = [\"A\", \"B\", \"C\", \"D\"]\n", "#    l2 = [\"C\", \"D\", \"E\", \"F\"]\n\t#\n\t#    out = occurrence(BasicSet.union(l1, l2))\n\t#    print(out)\n\t#\n\t#def importer2():\n\t#    MyImporter = PluginsImporter()\n\t#    nb_classes = MyImporter.LoadPlugins()\n\t#\n\t#    l1 = [\"A\", \"B\", \"C\", \"D\"]\n", "#    l2 = [\"C\", \"D\", \"E\", \"F\"]\n\t#\n\t#    cls = MyImporter.GetClasses()[0]\n\t#\n\t#    name_str = cls.GetName(cls)\n\t#    help_str = cls.GetHelp(cls)\n\t#    button_str = cls.GetButton(cls)\n\t#\n\t#    print(\"Str found :\")\n\t#    print(\"NAME : \" + name_str)\n", "#    print(\"HELP : \" + help_str)\n\t#    print(\"BUTTON : \" + button_str)\n\t#\n\t#    tmp = cls.Logic(cls, l1, l2)\n\t#    out = occurrence(tmp)\n\t#    print(out)\n"]}
{"filename": "src/basic_set_operators.py", "chunked_list": ["from PluginLogic import PluginLogic\n\t# Vector of classes containing the function and its descriptors/infos\n\tdef ListSetOperators():\n\t    SetOperations = []\n\t    SetOperations.append(Union)\n\t    SetOperations.append(Intersection)\n\t    #SetOperations.append(Inv_Intersection)\n\t    SetOperations.append(Unique_Both_Set)\n\t    SetOperations.append(Unique_1_Set)\n\t    SetOperations.append(Unique_2_Set)\n", "    return (SetOperations)\n\t# -- SETS OPERATIONS --\n\t# Each element is taken into account only one time (occurrencies are not used)\n\t# Union (set version)\n\tclass Union(PluginLogic):\n\t    name_str = \"UNION\"\n\t    help_str = \"Print all of the elements of the two CSV\"\n\t    button_str = \"Union\"\n\t    def Logic(self, list1, list2):\n\t        union_res = set(list1).union(set(list2))\n", "        return (union_res)\n\t# Intersection (set version)\n\tclass Intersection(PluginLogic):\n\t    name_str = \"INTERSECTION\"\n\t    help_str = \"Print only the common elements of the two CSV\"\n\t    button_str = \"Intersection\"\n\t    def Logic(self, list1, list2):\n\t        intersection_res = set(list1).intersection(set(list2))\n\t        ## intersection_res = [x for x in list1 if x in list2]\n\t        return (intersection_res)\n", "# Inverse of Intersection (set version) [SYMMETRIC DIFFERENCE]\n\t#class Inv_Intersection(PluginLogic):\n\t#    name_str = \"INV_INTERSECTION\"\n\t#    help_str = \"Print the inverse of the intersection (union - intersection)\"\n\t#    button_str = \"Inverse Intersection\"\n\t#\n\t#    def Logic(self, list1, list2):\n\t#        union = set(list1).union(set(list2))\n\t#        intersection = set(list1).intersection(set(list2))\n\t#        inv_intersection_res = set(union) - set(intersection)\n", "#        return (inv_intersection_res)\n\t# Unique elements to both CSV (delete commons elements)\n\tclass Unique_Both_Set(PluginLogic):\n\t    name_str = \"UNIQUE_SET_CSV_BOTH\"\n\t    help_str = \"Print elements unique to both CSV / Symmetric difference\"\n\t    button_str = \"Unique Both / Symmetric Diff\"\n\t    def Logic(self, list1, list2):\n\t        unique_both_res = set(list1).symmetric_difference(set(list2))\n\t        return (unique_both_res)\n\t# Unique elements to 1st CSV (delete elements from the other) (set version)\n", "class Unique_1_Set(PluginLogic):\n\t    name_str = \"UNIQUE_SET_CSV_1\"\n\t    help_str = \"Print elements unique to 1st CSV / Difference CSV1 - CSV2\"\n\t    button_str = \"Unique CSV 1 / Difference\"\n\t    def Logic(self, list1, list2):\n\t        unique_1_res = set(list1).difference(set(list2))\n\t        return (unique_1_res)\n\t# Unique elements to 2nd CSV (delete elements from the other) (set version)\n\tclass Unique_2_Set(PluginLogic):\n\t    name_str = \"UNIQUE_SET_CSV_2\"\n", "    help_str = \"Print elements unique to 2nd CSV / Difference CSV2 - CSV1\"\n\t    button_str = \"Unique CSV 2 / Difference\"\n\t    def Logic(self, list1, list2):\n\t        unique_2_res = set(list2).difference(set(list1))\n\t        return (unique_2_res)\n"]}
{"filename": "src/GUI.py", "chunked_list": ["# Windows for each part\n\tfrom GuiClasses import WindowStart\n\tfrom GuiClasses import WindowActions\n\tfrom GuiClasses import WindowList\n\tfrom GuiClasses import WindowExit\n\t# Plugin loader\n\tfrom plugins_loader import PluginsImporter\n\t# CSV Loader\n\tfrom csv_manipulate import load_csv\n\t# Tools\n", "from tools import occurrence\n\t# Globals required for the GUI\n\tfrom GuiClasses import Globals\n\t# gui_liste : Input List 1, Input List 2, Output List\n\t# gui_liste = [None, None, None]\n\tdef main():\n\t    # Load the plugins\n\t    Globals.MyPluginsImporter = PluginsImporter()\n\t    nb_plugins_classes = Globals.MyPluginsImporter.LoadPlugins()\n\t    # Initialize 2 empty CSV (global var)\n", "    # (done by the initial files)\n\t    # Load exit button in hardcoded way\n\t    #ExitWindow = WindowExit.WindowExit()\n\t    #ExitWindow.SetGeometry(\"300x50+1200+50\")\n\t    StartWindow = None\n\t    # main loop of events :\n\t    while (True):\n\t        # if 2 empty CSV (global var) :\n\t        if ((Globals.gui_liste[0] is None) or\n\t            (Globals.gui_liste[1] is None)) :\n", "            # Open WindowStart if not already opened\n\t            if (StartWindow is None) :\n\t                StartWindow = WindowStart.WindowStart(\"500x300+550+250\")\n\t                StartWindow.SetTitle(\"Import CSV\")\n\t            #   Load inside 2 FrameCSVLoader\n\t            #   OnPress \"Process\"\n\t            #     Validate content\n\t            #     if correct :\n\t            #       fill 2 CSV (global var)\n\t            #       quit WindowStart\n", "            #     if incorrect :\n\t            #       pop for error\n\t            #   WindowStart.mainloop\n\t            StartWindow.CallMainloop()\n\t        # else :\n\t        else :\n\t            # Open WindowActions   (300x250+650+50)\n\t            ActionsWindow = WindowActions.WindowActions(\"450x450+650+50\")\n\t            ActionsWindow.SetTitle(\"CSV List Comparator\")\n\t            #   Open 2 WindowList with their CSV content (global var)\n", "            List1Window = WindowList.WindowList(0,\n\t                                                \"300x400+200+150\")\n\t            List1Window.SetTitle(\"CSV 1 List\")\n\t            List1Window.SpecializedAsInputList()\n\t            List2Window = WindowList.WindowList(1,\n\t                                                \"300x400+1100+150\")\n\t            List2Window.SetTitle(\"CSV 2 List\")\n\t            List2Window.SpecializedAsInputList()\n\t            #   WindowActions.mainloop\n\t            ActionsWindow.CallMainloop()\n", "    return 0\n\tmain()\n"]}
{"filename": "src/csv_manipulate-Pandas.py", "chunked_list": ["import os\n\t# Pandas module for CSV parsing\n\timport pandas as pd\n\t# csv for Pandas options\n\timport csv\n\tdef load_csv(file_path, separator, column):\n\t    csv_reader = pd.read_csv(file_path,\n\t                             sep=separator,\n\t                             header=None,\n\t                             usecols=[column])\n", "    csv_list = csv_reader[column].tolist()\n\t    return csv_list\n\tdef save_csv_to_file(dictio, file_path, separator):\n\t    # Convert the dictionnary into a DataFrame\n\t    df = pd.DataFrame.from_dict(dictio,\n\t                                orient='index')\n\t    # Delete the CSV file if it already exists\n\t    if os.path.exists(file_path):\n\t        os.remove(file_path)\n\t    # Save the DataFrame as a CSV file\n", "    df.to_csv(file_path,\n\t              sep=separator,\n\t              header=False,\n\t              index=True,\n\t              quoting=csv.QUOTE_NONNUMERIC)\n\t### Quoting :\n\t# csv.QUOTE_ALL         : quotes every field\n\t# csv.QUOTE_MINIMAL     : quotes only fields with special characters\n\t# csv.QUOTE_NONNUMERIC  : quotes only non-numeric fields\n\t# csv.QUOTE_NONE        : no quoting [requires an 'escapechar']\n", "def print_out_csv(dictio, separator):\n\t    for key, value in dictio.items():\n\t        print(f\"{key}{separator}{value}\")\n\tdef save_csv(dictio, separator, file_path):\n\t    if (file_path == \"-\"):\n\t        print_out_csv(dictio, separator)\n\t    else:\n\t        save_csv_to_file(dictio, file_path, separator)\n"]}
{"filename": "src/tools.py", "chunked_list": ["def occurrence(liste):\n\t    # Initialiser un dictionnaire pour stocker les occurrences\n\t    occu = {}\n\t    # Parcourir les lignes du fichier CSV\n\t    for row in liste:\n\t        valeur = row\n\t        if valeur in occu:\n\t            occu[valeur] += 1\n\t        else:\n\t            occu[valeur] = 1\n", "    return occu\n"]}
{"filename": "src/basic_occurrencies_operators.py", "chunked_list": ["from PluginLogic import PluginLogic\n\t# Vector of classes containing the function and its descriptors/infos\n\tdef ListOccurrenciesOperators():\n\t    OccOperations = []\n\t    OccOperations.append(DisjointUnion)\n\t    OccOperations.append(Unique_1_Occ)\n\t    OccOperations.append(Unique_2_Occ)\n\t    return (OccOperations)\n\t# -- CATEGORIES / OCCURRENCIES OPERATIONS --\n\t# The set of origin is taken into account (occurrencies are used)\n", "# Disjoint Union (categories) (counts only one time the common elements)\n\tclass DisjointUnion(PluginLogic):\n\t    name_str = \"DISJOINT_UNION\"\n\t    help_str = \"Print union of the two CSV (add occurrencies)\"\n\t    button_str = \"Disjoint Union\"\n\t    def Logic(self, list1, list2):\n\t        disjoint_union_res = list1 + list2\n\t        return (disjoint_union_res)\n\t# Unique elements to 1st CSV (deletes elements from the other) (occurrencies)\n\tclass Unique_1_Occ(PluginLogic):\n", "    name_str = \"UNIQUE_CSV_1\"\n\t    help_str = \"Print elements unique to 1st CSV (delete occurrencies from the 2nd CSV)\"\n\t    button_str = \"Unique CSV 1\"\n\t    def Logic(self, list1, list2):\n\t        unique_1 = list1.copy()\n\t        unique_2 = list2.copy()\n\t        for value in list1:\n\t            if (value in list2):\n\t                if (value in unique_2):\n\t                    unique_1.remove(value)\n", "                    unique_2.remove(value)\n\t        return (unique_1)\n\t# Unique elements to 2nd CSV (deletes elements from the other) (occurrencies)\n\tclass Unique_2_Occ(PluginLogic):\n\t    name_str = \"UNIQUE_CSV_2\"\n\t    help_str = \"Print elements unique to 2nd CSV (delete occurrencies from the 1st CSV)\"\n\t    button_str = \"Unique CSV 2\"\n\t    def Logic(self, list1, list2):\n\t        unique_1 = list1.copy()\n\t        unique_2 = list2.copy()\n", "        for value in list2:\n\t            if (value in list1):\n\t                if (value in unique_1):\n\t                    unique_1.remove(value)\n\t                    unique_2.remove(value)\n\t        return (unique_2)\n"]}
{"filename": "src/PluginLogic.py", "chunked_list": ["### USE example_plugin.py FOR WRITING NEW OPERATIONS ###\n\t###############################\n\t### DO NOT MODIFY THIS FILE ###\n\t###############################\n\t### USE example_plugin.py FOR WRITING NEW OPERATIONS ###\n\tclass PluginLogic:\n\t    # Name for calling this plugin\n\t    name_str = \"NAME_STR\"\n\t    # Text printed when calling the script with wrong parameters\n\t    help_str = \"HELP_STR\"\n", "    # Text of button in the GUI\n\t    button_str = \"BUTTON_STR\"\n\t    def __init__(self):\n\t        return (None)\n\t    # The main function doing something with the lists and returning a list\n\t    def Logic(self, list1, list2):\n\t        return (None)\n\t    # Getter for the attributes\n\t    def GetName(self):\n\t        return (self.name_str)\n", "    def GetHelp(self):\n\t        return (self.help_str)\n\t    def GetButton(self):\n\t        return (self.button_str)\n"]}
{"filename": "src/CLI.py", "chunked_list": ["import os\n\timport sys\n\t# Plugin loader\n\tfrom plugins_loader import PluginsImporter\n\t# CSV loader (and saver)\n\tfrom csv_manipulate import load_csv\n\tfrom csv_manipulate import save_csv\n\tfrom csv_manipulate import print_out_csv\n\t# Actions\n\tfrom CliClasses.actions import execute_action\n", "# Usages & Helper\n\tfrom CliClasses.usages import print_usage\n\t### MAIN ###\n\tdef main():\n\t    # Load the plugins\n\t    MyPluginsImporter = PluginsImporter()\n\t    nb_plugins_classes = MyPluginsImporter.LoadPlugins()\n\t    # Test if enough parameters were given\n\t    if ((len(sys.argv) < 9) or ((len(sys.argv) > 10))) :\n\t        print_usage(MyPluginsImporter)\n", "        sys.exit(-1)\n\t    # Arguments assignation\n\t    file_path_1 = sys.argv[1]\n\t    sep1 = sys.argv[2]\n\t    id_col1 = int(sys.argv[3])\n\t    file_path_2 = sys.argv[4]\n\t    sep2 = sys.argv[5]\n\t    id_col2 = int(sys.argv[6])\n\t    action = sys.argv[7]\n\t    out_sep = sys.argv[8]\n", "    if (not (os.path.isfile(file_path_1))):\n\t        print(\"File 1 must exist\")\n\t        sys.exit(-2)\n\t    if (not (os.path.isfile(file_path_2))):\n\t        print(\"File 2 must exist\")\n\t        sys.exit(-2)\n\t    # Loading CSV in memory\n\t    list_csv_1 = load_csv(file_path_1, sep1, id_col1)\n\t    list_csv_2 = load_csv(file_path_2, sep2, id_col2)\n\t    # Executing the asked action\n", "    output_list = execute_action(list_csv_1,\n\t                                 list_csv_2,\n\t                                 action,\n\t                                 MyPluginsImporter)\n\t    # Write out the results\n\t    if (len(sys.argv) == 10):\n\t        out_file = sys.argv[9]\n\t        save_csv(output_list, out_sep, out_file)\n\t    else:\n\t        print_out_csv(output_list, out_sep)\n", "    return (0)\n\tmain()\n"]}
{"filename": "src/basic_various_operators.py", "chunked_list": ["from PluginLogic import PluginLogic\n\t# Vector of classes containing the function and its descriptors/infos\n\tdef ListVariousOperators():\n\t    VariousOperations = []\n\t    VariousOperations.append(IsDisjoint)\n\t    VariousOperations.append(IsSubset)\n\t    VariousOperations.append(IsSuperset)\n\t    return (VariousOperations)\n\t# -- VARIOUS OPERATIONS --\n\t# Various tests about the lists\n", "# Is Disjoint\n\tclass IsDisjoint(PluginLogic):\n\t    name_str = \"IS_DISJOINT\"\n\t    help_str = \"Test if the lists are disjoints (do not have any common element)\"\n\t    button_str = \"Is Disjoint ?\"\n\t    def Logic(self, list1, list2):\n\t        is_disjoint_res = set(list1).isdisjoint(set(list2))\n\t        return ([str(is_disjoint_res)])\n\t# Is Subset\n\tclass IsSubset(PluginLogic):\n", "    name_str = \"IS_SUBSET\"\n\t    help_str = \"Test if CSV 1 is a subset of CSV 2 (CSV 1 is completely included in CSV 2)\"\n\t    button_str = \"1 Is Subset of 2 ?\"\n\t    def Logic(self, list1, list2):\n\t        is_subset_res = set(list1).issubset(set(list2))\n\t        return ([str(is_subset_res)])\n\t# Is Superset\n\tclass IsSuperset(PluginLogic):\n\t    name_str = \"IS_SUPERSET\"\n\t    help_str = \"Test if CSV 1 is a superset of CSV 2 (CSV 1 contains the whole CSV 2)\"\n", "    button_str = \"1 Is Superset of 2 ?\"\n\t    def Logic(self, list1, list2):\n\t        is_superset_res = set(list1).issuperset(set(list2))\n\t        return ([str(is_superset_res)])\n"]}
{"filename": "src/csv_manipulate-Csv.py", "chunked_list": ["import os\n\t# csv module for CSV parsing\n\timport csv as csv\n\tdef load_csv(file_path, separator, column):\n\t    # Open file\n\t    with open(file_path, newline='') as  csv_file:\n\t        # Prepare a reader on the opened file\n\t        csv_reader = csv.reader(csv_file,\n\t                                delimiter=separator)\n\t        # Read each line and get the desired column\n", "        csv_list = []\n\t        for line in csv_reader:\n\t            csv_list.append(str(line[column]))\n\t    return csv_list\n\tdef save_csv_to_file(dictio, file_path, separator):\n\t    # Delete the CSV file if it already exists\n\t    if os.path.exists(file_path):\n\t        os.remove(file_path)\n\t    with open(file_path, 'w') as csv_file:\n\t        writer = csv.writer(csv_file,\n", "                            delimiter=separator,\n\t                            quoting=csv.QUOTE_NONNUMERIC,\n\t                            escapechar='')\n\t        for key, value in dictio.items():\n\t            writer.writerow([key, value])\n\t### Quoting :\n\t# csv.QUOTE_ALL         : quotes every field\n\t# csv.QUOTE_MINIMAL     : quotes only fields with special characters\n\t# csv.QUOTE_NONNUMERIC  : quotes only non-numeric fields\n\t# csv.QUOTE_NONE        : no quoting [requires an 'escapechar']\n", "def print_out_csv(dictio, separator):\n\t    for key, value in dictio.items():\n\t        print(f\"{key}{separator}{value}\")\n\tdef save_csv(dictio, separator, file_path):\n\t    if (file_path == \"-\"):\n\t        print_out_csv(dictio, separator)\n\t    else:\n\t        save_csv_to_file(dictio, file_path, separator)\n"]}
{"filename": "src/csv_manipulate.py", "chunked_list": ["import os\n\t# csv module for CSV parsing\n\timport csv as csv\n\tdef load_csv(file_path, separator, column):\n\t    # Open file\n\t    with open(file_path, newline='') as  csv_file:\n\t        # Prepare a reader on the opened file\n\t        csv_reader = csv.reader(csv_file,\n\t                                delimiter=separator)\n\t        # Read each line and get the desired column\n", "        csv_list = []\n\t        for line in csv_reader:\n\t            csv_list.append(str(line[column]))\n\t    return csv_list\n\tdef save_csv_to_file(dictio, file_path, separator):\n\t    # Delete the CSV file if it already exists\n\t    if os.path.exists(file_path):\n\t        os.remove(file_path)\n\t    with open(file_path, 'w') as csv_file:\n\t        writer = csv.writer(csv_file,\n", "                            delimiter=separator,\n\t                            quoting=csv.QUOTE_NONNUMERIC,\n\t                            escapechar='')\n\t        for key, value in dictio.items():\n\t            writer.writerow([key, value])\n\t### Quoting :\n\t# csv.QUOTE_ALL         : quotes every field\n\t# csv.QUOTE_MINIMAL     : quotes only fields with special characters\n\t# csv.QUOTE_NONNUMERIC  : quotes only non-numeric fields\n\t# csv.QUOTE_NONE        : no quoting [requires an 'escapechar']\n", "def print_out_csv(dictio, separator):\n\t    for key, value in dictio.items():\n\t        print(f\"{key}{separator}{value}\")\n\tdef save_csv(dictio, separator, file_path):\n\t    if (file_path == \"-\"):\n\t        print_out_csv(dictio, separator)\n\t    else:\n\t        save_csv_to_file(dictio, file_path, separator)\n"]}
{"filename": "src/GuiClasses/WindowList.py", "chunked_list": ["# Tkinter GUI\n\timport tkinter as tk\n\tfrom tkinter import ttk\n\tfrom tkinter import filedialog\n\t# Windows & Frames for loading and saving CSV\n\tfrom GuiClasses import FrameCSVLoader\n\tfrom GuiClasses import FrameCSVSaver\n\t# Tools\n\tfrom tools import occurrence\n\tfrom enum import Enum\n", "# Globals required for the GUI\n\tfrom GuiClasses import Globals\n\t# gui_liste : Input List 1, Input List 2, Output List\n\t# gui_liste = [None, None, None]\n\t# If the list is printed with only names (list), or with occurrencies (dict)\n\tclass WindowListState(Enum):\n\t    TERMS = 1\n\t    OCCURRENCIES = 2\n\t# If the list is unsorted (0), or sorted alphabetically or by occurrencies\n\tclass WindowListSortState(Enum):\n", "    UNKNOWN = 0\n\t    SORTED_AtoZ = 1\n\t    SORTED_ZtoA = 2\n\t    SORTED_0to9 = 3\n\t    SORTED_9to0 = 4\n\t# Class for printing lists (input and output) and asking for load/save\n\tclass WindowList:\n\t    GlobalListNumber = None\n\t    ### States / Context\n\t    # Context (Input list or Output list)\n", "    Context = None\n\t    # State (list in Name format only, or Name+Ocurrencies)\n\t    State = None\n\t    # SortState (list unsorted, sorted alphabetically, or by occurrencies)\n\t    SortState = None\n\t    ### GUI\n\t    # Main window getting everything\n\t    Root = None\n\t    # Specifications of the window\n\t    Geometry = \"0\"\n", "    Title = \"List Window\"\n\t    # Load/Save buttons in the window\n\t    FrameLoadSave = None\n\t    LoadButton = None\n\t    SaveButton = None\n\t    # Format list buttons\n\t    FrameFormatList = None\n\t    FormatTermButton = None\n\t    FormatOccButton = None\n\t    # Sorts buttons\n", "    FrameSorts = None\n\t    SortAlphaButton = None\n\t    SortNumButton = None\n\t    # List of terms\n\t    FrameListBox = None\n\t    ScrollbarListBox = None\n\t    ListBox = None\n\t    # def WindowListGenerator(self):\n\t    def __init__(self, globallistnum, geometry):\n\t        self.Root = tk.Tk()\n", "        self.SetGeometry(geometry)\n\t        self.GlobalListNumber = globallistnum\n\t        self.State = WindowListState.TERMS\n\t        self.SortState = WindowListSortState.UNKNOWN\n\t        ### Load / Save\n\t        # Frame for Load and Save\n\t        self.FrameLoadSave = ttk.Frame(self.Root)\n\t        self.FrameLoadSave.pack(side=tk.TOP,\n\t                                fill=tk.X,\n\t                                expand=tk.YES,\n", "                                anchor=tk.N)\n\t        # Load CSV button\n\t        self.LoadButton = tk.Button(self.FrameLoadSave,\n\t                                    text=\"Load\",\n\t                                    state=tk.DISABLED,\n\t                                    command=lambda: LoadFile(self.GlobalListNumber, self))\n\t        self.LoadButton.pack(side=tk.LEFT,\n\t                             fill=tk.X,\n\t                             expand=tk.YES,\n\t                             anchor=tk.NW)\n", "        # Save CSV button\n\t        self.SaveButton = tk.Button(self.FrameLoadSave,\n\t                                    text=\"Save\",\n\t                                    state=tk.DISABLED,\n\t                                    command=lambda: SaveFile(self.GlobalListNumber, self))\n\t        self.SaveButton.pack(side=tk.RIGHT,\n\t                             fill=tk.X,\n\t                             expand=tk.YES,\n\t                             anchor=tk.NE)\n\t        ### Format Terms/Occurrencies\n", "        # Frame for two modes\n\t        self.FrameFormatList = ttk.Frame(self.Root)\n\t        self.FrameFormatList.pack(side=tk.TOP,\n\t                                  fill=tk.X,\n\t                                  expand=tk.YES,\n\t                                  anchor=tk.N)\n\t        # Button format list as Terms list\n\t        self.FormatTermButton = tk.Button(self.FrameFormatList,\n\t                                          text=\"Mode:\\nTerms List\",\n\t                                          state=tk.NORMAL,\n", "                                          command=lambda: self.InsertListInListBox(Globals.gui_liste[self.GlobalListNumber]))\n\t        self.FormatTermButton.pack(side=tk.LEFT,\n\t                             fill=tk.X,\n\t                             expand=tk.YES,\n\t                             anchor=tk.NW)\n\t        # Button format list as Occurrencies list\n\t        self.FormatOccButton = tk.Button(self.FrameFormatList,\n\t                                         text=\"Mode:\\nOccurrences\",\n\t                                         state=tk.NORMAL,\n\t                                         command=lambda: self.InsertDictInListBox(occurrence(Globals.gui_liste[self.GlobalListNumber])))\n", "        self.FormatOccButton.pack(side=tk.RIGHT,\n\t                             fill=tk.X,\n\t                             expand=tk.YES,\n\t                             anchor=tk.NE)\n\t        ### Sorts buttons\n\t        # Frame for sorting by alphabetical and numerical orders\n\t        self.FrameSorts = ttk.Frame(self.Root)\n\t        self.FrameSorts.pack(side=tk.TOP,\n\t                             fill=tk.X,\n\t                             expand=tk.YES,\n", "                             anchor=tk.N)\n\t        # Sort A->Z CSV button\n\t        self.SortAlphaButton = tk.Button(self.FrameSorts,\n\t                                         text=\"Sort [Alphabetical]\",\n\t                                         state=tk.NORMAL,\n\t                                         command=lambda: self.SortListInListBoxAlphabetically())\n\t        self.SortAlphaButton.pack(side=tk.RIGHT,\n\t                                  fill=tk.X,\n\t                                  expand=tk.YES,\n\t                                  anchor=tk.NW)\n", "        self.UpdateSortAtoZButton()\n\t        # Sort 0->9 CSV button\n\t        self.SortNumButton = tk.Button(self.FrameSorts,\n\t                                       text=\"Sort [Numerical]\",\n\t                                       state=tk.DISABLED,\n\t                                       command=lambda: self.SortListInListBoxNumerically())\n\t        self.SortNumButton.pack(side=tk.RIGHT,\n\t                                fill=tk.X,\n\t                                expand=tk.YES,\n\t                                anchor=tk.NE)\n", "        self.UpdateSort0to9Button()\n\t        ### ListBox containing the list of terms\n\t        # Frame for containing the list\n\t        self.FrameListBox = ttk.Frame(self.Root)\n\t        self.FrameListBox.pack(fill=tk.BOTH,\n\t                               expand=True)\n\t        # Scrollbar for the list\n\t        self.ScrollbarListBox = ttk.Scrollbar(self.FrameListBox,\n\t                                              orient=tk.VERTICAL)\n\t        # ListBox containing the list\n", "        self.ListBox = tk.Listbox(self.FrameListBox,\n\t                                  yscrollcommand=self.ScrollbarListBox.set)\n\t        self.ListBox.pack(side=tk.LEFT,\n\t                          fill=tk.BOTH,\n\t                          expand=True)\n\t        # Configure the scrollbar for expanding with the list\n\t        self.ScrollbarListBox.config(command=self.ListBox.yview)\n\t        self.ScrollbarListBox.pack(side=tk.RIGHT,\n\t                                   fill=tk.Y)\n\t    # Specialize the Window List as an Input list (one of the 2 input CSV)\n", "    #  List each term in its exact position (print only the terms)\n\t    def SpecializedAsInputList(self):\n\t        self.LoadButton.config(state=tk.NORMAL)\n\t        self.SaveButton.config(state=tk.DISABLED)\n\t        self.ListBox.delete(0, tk.END)\n\t        self.InsertListInListBox(Globals.gui_liste[self.GlobalListNumber])\n\t    # Specialize the Window List as an Output list\n\t    #  List the occurrencies of terms\n\t    def SpecializedAsOutputList(self):\n\t        self.LoadButton.config(state=tk.DISABLED)\n", "        self.SaveButton.config(state=tk.NORMAL)\n\t        self.ListBox.delete(0, tk.END)\n\t        self.InsertDictInListBox(occurrence(Globals.gui_liste[self.GlobalListNumber]))\n\t    # Switch between the 2 states (TERMS <-> OCCURRENCIES)\n\t    def StateSwitch(self):\n\t        if (self.State == WindowListState.TERMS):\n\t            self.State = WindowListState.OCCURRENCES\n\t        else:\n\t            self.State = WindowListState.TERMS\n\t    # Switch the button from A->Z to Z->A (and vice versa)\n", "    def UpdateSortAtoZButton(self):\n\t        # If list is already in alphabetical, propose the reverse\n\t        if (self.SortState == WindowListSortState.SORTED_AtoZ):\n\t            self.SortAlphaButton.config(text=\"Sort (Z -> A)\")\n\t        else:\n\t            self.SortAlphaButton.config(text=\"Sort (A -> Z)\")\n\t    # Switch the button from 0->9 to 0->9 (and vice versa)\n\t    def UpdateSort0to9Button(self):\n\t        # If list is already in alphabetical, propose the reverse\n\t        if (self.SortState == WindowListSortState.SORTED_0to9):\n", "            self.SortNumButton.config(text=\"Sort (9 -> 0)\")\n\t        else:\n\t            self.SortNumButton.config(text=\"Sort (0 -> 9)\")\n\t    # Sort (A <-> Z) the list of terms\n\t    def SortListInListBoxAlphabetically(self):\n\t        liste = Globals.gui_liste[self.GlobalListNumber]\n\t        if (self.State == WindowListState.TERMS):\n\t            # List mode\n\t            if (self.SortState != WindowListSortState.SORTED_AtoZ):\n\t                # If the list is not sorted alphabetically...\n", "                #  let's sort it!\n\t                sorted_list = sorted(liste, reverse=False)\n\t                self.SortState = WindowListSortState.SORTED_AtoZ\n\t            else:\n\t                # Else, let's revert the sort\n\t                sorted_list = sorted(liste, reverse=True)\n\t                self.SortState = WindowListSortState.SORTED_ZtoA\n\t            self.InsertListInListBox(sorted_list)\n\t        else:\n\t            dico = occurrence(liste)\n", "            # Occurrencies mode\n\t            if (self.SortState != WindowListSortState.SORTED_AtoZ):\n\t                # If the list is not sorted alphabetically...\n\t                sorted_items = sorted(dico.items(), reverse=False)\n\t                self.SortState = WindowListSortState.SORTED_AtoZ\n\t            else:\n\t                # Else, let's revert the sort\n\t                sorted_items = sorted(dico.items(), reverse=True)\n\t                self.SortState = WindowListSortState.SORTED_ZtoA\n\t            self.InsertDictInListBox(dict(sorted_items))\n", "        self.UpdateSortAtoZButton()\n\t    # Sort (0 <-> 9) the list of terms\n\t    def SortListInListBoxNumerically(self):\n\t        liste = Globals.gui_liste[self.GlobalListNumber]\n\t        if (self.State == WindowListState.OCCURRENCIES):\n\t            dico = occurrence(liste)\n\t            # Occurrencies mode\n\t            if (self.SortState != WindowListSortState.SORTED_0to9):\n\t                # If the list is not sorted numerically...\n\t                sorted_items = sorted(dico.items(), key=lambda x : x[1], reverse=False)\n", "                self.SortState = WindowListSortState.SORTED_0to9\n\t            else:\n\t                # Else, let's revert the sort\n\t                sorted_items = sorted(dico.items(), key=lambda x : x[1], reverse=True)\n\t                self.SortState = WindowListSortState.SORTED_9to0\n\t            self.InsertDictInListBox(dict(sorted_items))\n\t        else:\n\t            # Terms mode\n\t            test = None\n\t        self.UpdateSort0to9Button()\n", "    # Insert a list of terms in the ListBox\n\t    def InsertListInListBox(self, liste):\n\t        self.ListBox.delete(0, tk.END)\n\t        for element in liste:\n\t            self.ListBox.insert(tk.END, element)\n\t        self.State = WindowListState.TERMS\n\t        self.SortNumButton.config(state=tk.DISABLED)\n\t    # Insert a dictionnary (term:occ) in the ListBox\n\t    def InsertDictInListBox(self, dico):\n\t        self.ListBox.delete(0, tk.END)\n", "        for valeur, compte in dico.items():\n\t            texte = f\"{valeur} : {compte} occurrence(s)\"\n\t            self.ListBox.insert(tk.END, texte)\n\t        self.State = WindowListState.OCCURRENCIES\n\t        self.SortNumButton.config(state=tk.NORMAL)\n\t    ### Regular Methods of the class (setters, getters, quit, geometry, ...)\n\t    def SetTitle(self, title):\n\t        self.Title = title\n\t        self.Root.title(title)\n\t    def SetGeometry(self, geometry):\n", "        self.Geometry = geometry\n\t        self.Root.geometry(geometry)\n\t    def GetGeometry(self):\n\t        return (self.Geometry)\n\t    def GetTitle(self):\n\t        return (self.Title)\n\t    # Hide the window\n\t    def CallWithdraw(self):\n\t        self.Root.withdraw()\n\t    # Destroy the window\n", "    def CallDestroy(self):\n\t        self.Root.destroy()\n\t# Callback for LoadButton\n\tdef LoadFile(NumList, TheWindowList):\n\t    WindowLoad = tk.Tk()\n\t    WindowLoad.title(\"Load CSV\")\n\t    WindowLoad.geometry(\"300x220+600+375\")\n\t    # Fill with the frame dedicated for loading CSV\n\t    FrameLoad = FrameCSVLoader.FrameCSVLoader(WindowLoad, NumList)\n\t    # Add the launch button & pack the frame\n", "    FrameLoad.Reload_PutLaunchButton(TheWindowList)\n\t    WindowLoad.mainloop()\n\t# Callback for SaveButton\n\tdef SaveFile(NumList, TheWindowList):\n\t    WindowSave = tk.Tk()\n\t    WindowSave.title(\"Save CSV\")\n\t    WindowSave.geometry(\"250x200+600+375\")\n\t    # Create a frame\n\t    FrameSave = FrameCSVSaver.FrameCSVSaver(WindowSave, NumList)\n\t    # Add the save button & pack the frame\n", "    FrameSave.Save_PutSaveButton(WindowSave)\n\t    WindowSave.mainloop()\n"]}
{"filename": "src/GuiClasses/WindowError.py", "chunked_list": ["# Tkinter GUI\n\timport tkinter as tk\n\tclass WindowError:\n\t    Geometry = None\n\t    Title = None\n\t    # Main window getting the label and button\n\t    Root = None\n\t    # The label first with the error message\n\t    Label = None\n\t    # The button and its text to click on\n", "    Button = None\n\t    ButtonText = None\n\t    def __init__(self):\n\t        self.Root = tk.Tk()\n\t        self.SetTitle(\"Error\")\n\t        self.Label = tk.Label(self.Root, text=\"Error\")\n\t        self.Label.pack()\n\t        self.ButtonText = \"OK\"\n\t        self.Button = tk.Button(self.Root,\n\t                                text=\"OK\",\n", "                                command=lambda: self.Root.destroy())\n\t        self.Button.pack()\n\t    def SetGeometry(self, geometry):\n\t        self.Geometry = geometry\n\t        self.Root.geometry(geometry)\n\t    def GetGeometry(self):\n\t        return (self.Geometry)\n\t    def SetTitle(self, title):\n\t        self.Title = title\n\t        self.Root.title(title)\n", "    def GetTitle(self):\n\t        return (self.Title)\n\t    def SetButton(self, button_text):\n\t        self.Button.destroy()\n\t        self.ButtonText = button_text\n\t        self.Button = tk.Button(self.Root,\n\t                                text=button_text,\n\t                                command=lambda: self.Root.destroy())\n\t        self.Button.pack()\n\t    # For upating the label, we must remove the button and put it again\n", "    def SetLabel(self, new_text):\n\t        self.Label.destroy()\n\t        self.Label = tk.Label(self.Root, text=new_text)\n\t        self.Label.pack()\n\t        self.SetButton(self.ButtonText)\n"]}
{"filename": "src/GuiClasses/WindowStart.py", "chunked_list": ["# Tkinter GUI\n\timport tkinter as tk\n\tfrom tkinter import messagebox\n\t# Windows & Frames for Errors and CSV Loading\n\tfrom GuiClasses import FrameCSVLoader\n\tfrom GuiClasses import WindowError\n\t# Tools\n\tfrom csv_manipulate import load_csv\n\t# Globals required for the GUI\n\tfrom GuiClasses import Globals\n", "# gui_liste : Input List 1, Input List 2, Output List\n\t# gui_liste = [None, None, None]\n\t# Main first window asking to input 2 CSV\n\tclass WindowStart:\n\t    Geometry = \"0\"\n\t    Title = \"List Window\"\n\t    # Main window getting everything\n\t    Root = None\n\t    # 1st Frame for CSV 1\n\t    FrameCSV1 = None\n", "    # 2nd Frame for CSV 2\n\t    FrameCSV2 = None\n\t    # Launch button\n\t    FrameButton = None\n\t    LaunchButton = None\n\t    def __init__(self, geometry):\n\t        self.Root = tk.Tk()\n\t        self.SetGeometry(geometry)\n\t        # If user close the window, kill everything\n\t        self.Root.protocol(\"WM_DELETE_WINDOW\",\n", "                           lambda: on_closing(self))\n\t        # Add the CSV 1 frame\n\t        self.FrameCSV1 = FrameCSVLoader.FrameCSVLoader(self.Root)\n\t        self.FrameCSV1.PackLeft()\n\t        # Add the CSV 2 frame\n\t        self.FrameCSV2 = FrameCSVLoader.FrameCSVLoader(self.Root)\n\t        self.FrameCSV2.PackRight()\n\t        # Add the launch button\n\t        self.FrameButton = tk.Frame(self.Root)\n\t        self.PutLaunchButton()\n", "        self.FrameButton.pack(side=tk.BOTTOM,\n\t                              fill=tk.BOTH)\n\t    def PutLaunchButton(self):\n\t        self.LaunchButton = tk.Button(self.FrameButton,\n\t                                      text=\"Launch\",\n\t                                      command=lambda: Launch_WindowListActions(self))\n\t        self.LaunchButton.pack(fill=tk.BOTH,\n\t                               padx=10,\n\t                               pady=10)\n\t    def SetTitle(self, title):\n", "        self.Title = title\n\t        self.Root.title(title)\n\t    def SetGeometry(self, geometry):\n\t        self.Geometry = geometry\n\t        self.Root.geometry(geometry)\n\t    def GetTitle(self):\n\t        return (self.Title)\n\t    def GetGeometry(self):\n\t        return (self.Geometry)\n\t    def GetCSVInfos(self, num):\n", "        if (num == 1):\n\t            return (self.FrameCSV1.Validate())\n\t        elif (num == 2):\n\t            return (self.FrameCSV2.Validate())\n\t        else:\n\t            print(\"Bad CSV number (should be 1 or 2) : \" + num)\n\t            return (None)\n\t    def CallMainloop(self):\n\t        self.Root.mainloop()\n\t    def CallWithdraw(self):\n", "        self.Root.withdraw()\n\t    # Quit the \"mainloop\" and return\n\t    def CallQuit(self):\n\t        self.Root.withdraw()\n\t        self.Root.quit()\n\t    # Kill the \"mainloop\" completely/Exit program\n\t    def CallDestroy(self):\n\t        self.Root.destroy()\n\tdef Launch_WindowListActions(TheStartWindow):\n\t    # Get CSV 1 & 2 informations\n", "    CSV1Infos = TheStartWindow.GetCSVInfos(1)\n\t    CSV2Infos = TheStartWindow.GetCSVInfos(2)\n\t    #print(\"[WindowStart] CSV 1 :\")\n\t    #print(type(CSV1Infos))\n\t    #print(CSV1Infos)\n\t    #print(\" \")\n\t    #print(\"[WindowStart] CSV 2 :\")\n\t    #print(type(CSV2Infos))\n\t    #print(CSV2Infos)\n\t    if ((not (CSV1Infos is None)) and (not (CSV2Infos is None))) :\n", "        # Correct the columns (technical) : [1 -> 9] to [0 -> 8]\n\t        Col1 = int(CSV1Infos[2]) - 1\n\t        Col2 = int(CSV2Infos[2]) - 1\n\t        Globals.gui_liste[0] = load_csv(CSV1Infos[0], CSV1Infos[1], Col1)\n\t        Globals.gui_liste[1] = load_csv(CSV2Infos[0], CSV2Infos[1], Col2)\n\t        # If the 2 CSV has been correctly loaded, exit\n\t        #if (! (Globals.gui_liste[0] is None) or\n\t        #    (Globals.gui_liste[1] is None)) :\n\t        # Close the main window and return back to the program\n\t        #TheStartWindow.CallDestroy()\n", "        TheStartWindow.CallQuit()\n\t    else :\n\t        #ErrWindow = tk.Tk()\n\t        #ErrWindow.title(\"Error\")\n\t        #ErrLabel = tk.Label(ErrWindow, text=\"Error : Fill correctly CSV\")\n\t        #ErrLabel.pack()\n\t        #ErrButton = tk.Button(ErrWindow,\n\t        #                      text=\"OK\",\n\t        #                      command=lambda: ErrWindow.destroy())\n\t        #ErrButton.pack()\n", "        ErrWindow = WindowError.WindowError()\n\t        ErrWindow.SetLabel(\"Error : Fill correctly CSV paths, separator, and column\")\n\tdef on_closing(TheStartWindow):\n\t    if (messagebox.askokcancel(\"Quit\", \"Do you want to quit?\")):\n\t        #TheStartWindow.CallDestroy()\n\t        exit(0)\n"]}
{"filename": "src/GuiClasses/__init__.py", "chunked_list": []}
{"filename": "src/GuiClasses/FrameCSVLoader.py", "chunked_list": ["import os.path\n\t# Tkinter GUI\n\timport tkinter as tk\n\tfrom tkinter import filedialog\n\t# Windows for errors\n\tfrom GuiClasses import WindowError\n\t# CSV Loader\n\tfrom csv_manipulate import load_csv\n\t# Globals required for the GUI\n\tfrom GuiClasses import Globals\n", "# gui_liste : Input List 1, Input List 2, Output List\n\t# gui_liste = [None, None, None]\n\t# Frame asking for informations about a CSV (path, sep, col)\n\tclass FrameCSVLoader:\n\t    GlobalListNumber = None\n\t    # Values we want to get from the user (tk.StringVar())\n\t    Filename = None\n\t    Separator = None\n\t    Column = None\n\t    ### GUI\n", "    # The current frame\n\t    Frame = None\n\t    # Canvas where to put the current frame\n\t    OutterCanvas = None\n\t    # Specifications of the current frame\n\t    Geometry = None\n\t    Padding = None\n\t    BorderWidth = None\n\t    Relief = None\n\t    # Widgets of the frame\n", "    FileLabel = None\n\t    FileButton = None\n\t    FileEntry = None\n\t    SeparatorLabel = None\n\t    SeparatorEntry = None\n\t    ColumnLabel = None\n\t    ColumnEntry = None\n\t    # Widgets for reloading a CSV\n\t    LaunchButton = None\n\t    def __init__(self, canvas, ListNum=None):\n", "        # Get the canvas where to put the frame\n\t        self.OutterCanvas = canvas\n\t        self.GlobalListNumber = ListNum\n\t        self.Frame = tk.Frame(self.OutterCanvas)\n\t        # Fill variables\n\t        self.Filename = tk.StringVar()\n\t        self.Separator = tk.StringVar()\n\t        self.Column = tk.StringVar()\n\t        # Describe the field and button\n\t        self.FileLabel = tk.Label(self.Frame,\n", "                                  text=\"CSV File Path:\")\n\t        self.FileLabel.pack()\n\t        # Put the button for the file and fill the file field when chosen\n\t        self.FileButton = tk.Button(self.Frame,\n\t                                    text=\"Choose file\",\n\t                                    command=self.ChooseFile)\n\t        self.FileButton.pack()\n\t        # Create a file field\n\t        self.FileEntry = tk.Entry(self.Frame, textvariable=self.Filename)\n\t        self.FileEntry.insert(0, \"C1.csv\")\n", "        self.FileEntry.pack()\n\t        # Separator Description and Field\n\t        self.SeparatorLabel = tk.Label(self.Frame,\n\t                                       text=\"Separator:\")\n\t        self.SeparatorLabel.pack()\n\t        self.SeparatorEntry = tk.Entry(self.Frame,\n\t                                       textvariable=self.Separator)\n\t        self.SeparatorEntry.insert(0, \";\")\n\t        self.SeparatorEntry.pack()\n\t        # Column Description and Field\n", "        self.ColumnLabel = tk.Label(self.Frame,\n\t                                    text=\"Column:\")\n\t        self.ColumnLabel.pack()\n\t        self.ColumnEntry = tk.Entry(self.Frame, textvariable=self.Column)\n\t        self.ColumnEntry.insert(0, \"6\")\n\t        self.ColumnEntry.pack()\n\t        #self.Frame.pack(side=\"left\", padx=50, pady=50)\n\t    def GetFilename(self):\n\t        return (self.Filename)\n\t    def GetSeparator(self):\n", "        return (self.Separator)\n\t    def GetColumn(self):\n\t        return (self.Column)\n\t    def SetPadding(self, padding):\n\t        self.Padding = padding\n\t        self.Frame['padding'] = padding\n\t    def SetBorder(self, borderwidth):\n\t        self.BorderWidth = borderwidth\n\t        self.Frame['borderwidth'] = borderwidth\n\t    def SetRelief(self, relief):\n", "        self.Relief = relief\n\t        self.Frame['relief'] = relief\n\t    def PackLeft(self):\n\t        self.Frame.pack(side=tk.LEFT,\n\t                        anchor=tk.NW,\n\t                        padx=10,\n\t                        pady=10)\n\t    def PackRight(self):\n\t        self.Frame.pack(side=tk.RIGHT,\n\t                        anchor=tk.NE,\n", "                        padx=10,\n\t                        pady=10)\n\t    # Called when reloading a CSV\n\t    #  Add the launch button and pack everything\n\t    def Reload_PutLaunchButton(self, TheWindowListToReload):\n\t        self.Frame.pack(side=tk.TOP, anchor=tk.N)\n\t        self.LaunchButton = tk.Button(self.OutterCanvas,\n\t                                      text=\"Launch\",\n\t                                      command=lambda: Reload_WindowList(self,\n\t                                                                        self.GlobalListNumber,\n", "                                                                        TheWindowListToReload))\n\t        self.LaunchButton.pack(side=tk.TOP,\n\t                               padx=10,\n\t                               pady=10)\n\t    # Quit the \"mainloop\" and return\n\t    def CallQuit(self):\n\t        self.OutterCanvas.quit()\n\t    # Kill the \"mainloop\" completely/Exit program\n\t    def CallDestroy(self):\n\t        self.OutterCanvas.destroy()\n", "    def ChooseFile(self):\n\t        # Open a dialog box in order to select the CSV file\n\t        file = filedialog.askopenfilename(title=\"Select a CSV file\",\n\t                                          filetypes=[(\"CSV Files\", \"*.csv\"),\n\t                                                     (\"Text Files\",\"*.txt\"),\n\t                                                     (\"All Files\",\"*.*\")])\n\t        # Check if a file has been selected\n\t        if (file):\n\t            # Store & Fill the file path in the entry box\n\t            self.Filename.set(file)\n", "            self.FileEntry.delete(0, tk.END) # remove previous content\n\t            self.FileEntry.insert(0, file)\n\t    def Validate(self):\n\t        self.Filename.set(self.FileEntry.get())\n\t        self.Separator.set(self.SeparatorEntry.get())\n\t        self.Column.set(self.ColumnEntry.get())\n\t        #print(\"Frame :\")\n\t        #print(\"  Path : --\" + self.Filename.get() + \"--\")\n\t        #print(\"  Sep  : --\" + self.Separator.get() + \"--\")\n\t        #print(\"  Col  : --\" + self.Column.get() + \"--\")\n", "        if ((os.path.isfile(self.Filename.get())) and\n\t            (len(self.Separator.get()) == 1) and\n\t            (int(self.Column.get()) > 0)) :\n\t            return (self.Filename.get(), self.Separator.get(), self.Column.get())\n\t        else :\n\t            return (None)\n\t    def GetCSVInfos(self):\n\t        return (self.Validate())\n\tdef Reload_WindowList(Frame, NumList, TheWindowListToReload):\n\t    # Get CSV informations\n", "    CSVInfos = Frame.GetCSVInfos()\n\t    #print(\"[ReloadWindowList] CSV :\")\n\t    #print(type(CSVInfos))\n\t    #print(CSVInfos)\n\t    #print(\" \")\n\t    if (not (CSVInfos is None)):\n\t        # Correct the columns (technical) : [1 -> 9] to [0 -> 8]\n\t        Col = int(CSVInfos[2]) - 1\n\t        Globals.gui_liste[NumList] = load_csv(CSVInfos[0], CSVInfos[1], Col)\n\t        # If the CSV has been correctly loaded, exit\n", "        if (not (Globals.gui_liste[NumList] is None)):\n\t            # Refresh the WindowList\n\t            TheWindowListToReload.InsertListInListBox(Globals.gui_liste[NumList])\n\t            # Close the main window and return back to the program\n\t            Frame.CallDestroy()\n\t            #Frame.CallQuit()\n\t    else :\n\t        #ErrWindow = tk.Tk()\n\t        #ErrWindow.title(\"Error\")\n\t        #ErrLabel = tk.Label(ErrWindow, text=\"Error : Fill correctly CSV\")\n", "        #ErrLabel.pack()\n\t        #ErrButton = tk.Button(ErrWindow,\n\t        #                      text=\"OK\",\n\t        #                      command=lambda: ErrWindow.destroy())\n\t        #ErrButton.pack()\n\t        ErrWindow = WindowError.WindowError()\n\t        ErrWindow.SetLabel(\"Error : Fill correctly CSV paths, separator, and column\")\n"]}
{"filename": "src/GuiClasses/WindowActions.py", "chunked_list": ["import sys\n\t# Tkinter GUI\n\timport tkinter as tk\n\tfrom tkinter import ttk\n\tfrom tkinter import messagebox\n\t# Windows for input lists\n\tfrom GuiClasses import WindowList\n\t# Plugin loader\n\tfrom plugins_loader import PluginsImporter\n\t# Logic operators\n", "from basic_set_operators import ListSetOperators\n\tfrom basic_occurrencies_operators import ListOccurrenciesOperators\n\tfrom basic_various_operators import ListVariousOperators\n\t# Globals required for the GUI\n\tfrom GuiClasses import Globals\n\t# gui_liste :  [0]:Input List 1  [1]:Input List 2  [2]:Output List\n\t# gui_liste = [None, None, None]\n\t# Class for proposing as much buttons as available operations on sets\n\tclass WindowActions:\n\t    Geometry = \"0\"\n", "    Title = \"CSV List Comparator\"\n\t    # Root Window\n\t    Root = None\n\t    # Canvas getting the Frame & Internal Canvas\n\t    Canvas = None\n\t    # Frame for putting scrollbars\n\t    FrameMain = None\n\t    FrameScrollbar = None\n\t    # Frame for buttons and others\n\t    Frame = None\n", "    # Scrollbars\n\t    Scrollbar_X = None\n\t    Scrollbar_Y = None\n\t    # Buttons for launching actions (set operations)\n\t    Buttons = []\n\t    # Labels\n\t    Labels = []\n\t    # Separators\n\t    Separators = []\n\t    # ListBox with the data\n", "    #ListBox = None\n\t    # Output WindowList that can be destroy as wished\n\t    OutWindow = None\n\t    def __init__(self, geometry):\n\t        self.Root = tk.Tk()\n\t        self.SetTitle(\"Actions\")\n\t        self.SetGeometry(geometry)\n\t        ## Frame Main [in root]\n\t        self.FrameMain = ttk.Frame(self.Root)\n\t        self.FrameMain.pack(fill=tk.BOTH,\n", "                            expand=True)\n\t        ## Frame for the scrollbar [in FrameMain]\n\t        self.FrameScrollbar = ttk.Frame(self.FrameMain)\n\t        self.FrameScrollbar.pack(side=tk.BOTTOM,\n\t                                 fill=tk.X)\n\t        ## Canvas [in FrameMain]\n\t        self.Canvas = tk.Canvas(self.FrameMain)\n\t        self.Canvas.pack(side=tk.LEFT,\n\t                         fill=tk.BOTH,\n\t                         expand=True)\n", "        ## Scrollbar in the Canvas [in FrameScrollbar and FrameMain]\n\t        #self.Scrollbar_X = ttk.Scrollbar(self.FrameScrollbar,\n\t        #                                 orient=tk.HORIZONTAL,\n\t        #                                 command=self.Canvas.xview)\n\t        #self.Scrollbar_X.pack(side=tk.BOTTOM,\n\t        #                      fill=tk.X)\n\t        self.Scrollbar_Y = ttk.Scrollbar(self.FrameMain,\n\t                                         orient=tk.VERTICAL,\n\t                                         command=self.Canvas.yview)\n\t        self.Scrollbar_Y.pack(side=tk.RIGHT,\n", "                              fill=tk.Y)\n\t        ## Configure the Canvas\n\t        #self.Canvas.configure(xscrollcommand=self.Scrollbar_X.set)\n\t        self.Canvas.configure(yscrollcommand=self.Scrollbar_Y.set)\n\t        self.Canvas.bind(\"<Configure>\",\n\t                         lambda e : self.Canvas.config(scrollregion=self.Canvas.bbox(tk.ALL)))\n\t        ## Frame internal (that will contain buttons) [in Canvas]\n\t        self.Frame = ttk.Frame(self.Canvas)\n\t        ## add a window to that frame in the canvas\n\t        self.Canvas.create_window((0,0),\n", "                                  window=self.Frame,\n\t                                  anchor=\"nw\")\n\t        ######################################\n\t        ### Put the separators and buttons ###\n\t        ######################################\n\t        self.__PutSeparatorsAndButtons()\n\t        ######################################\n\t        ## Separator\n\t        self.AddSeparator()\n\t        ## Exit button\n", "        self.Buttons.append(tk.Button(self.Frame,\n\t                                      text=\"Quit\",\n\t                                      command=lambda: on_closing(self)))\n\t        self.Buttons[-1].pack()\n\t        ## Catch the exit signal on the window ('X' in right corner)\n\t        self.Root.protocol(\"WM_DELETE_WINDOW\",\n\t                           lambda: on_closing(self))\n\t    ## Put the separators and buttons\n\t    def __PutSeparatorsAndButtons(self):\n\t        ## Loading buttons [in Frame]\n", "        ## [Currently hardcoded]\n\t        ## TODO : loading as much buttons as there are operations in the operations file\n\t        self.AddSeparator()\n\t        self.AddLabel(\"Occurrencies/Categories\")\n\t        for cls in ListOccurrenciesOperators():\n\t            button_str = str(cls.GetButton(cls))\n\t            name_str = str(cls.GetName(cls))\n\t            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\t        self.AddSeparator()\n\t        self.AddLabel(\"Sets (no occurrencies)\")\n", "        for cls in ListSetOperators():\n\t            button_str = str(cls.GetButton(cls))\n\t            name_str = str(cls.GetName(cls))\n\t            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\t        self.AddSeparator()\n\t        self.AddLabel(\"Various\")\n\t        for cls in ListVariousOperators():\n\t            button_str = str(cls.GetButton(cls))\n\t            name_str = str(cls.GetName(cls))\n\t            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n", "        self.AddSeparator()\n\t        self.AddLabel(\"Plugins\")\n\t        for cls in Globals.MyPluginsImporter.GetClasses():\n\t            button_str = str(cls.GetButton(cls))\n\t            name_str = str(cls.GetName(cls))\n\t            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\t    ## Add a button in the frame\n\t    def AddButton(self, Text, Command):\n\t        self.Buttons.append(tk.Button(self.Frame,\n\t                                      text=Text,\n", "                                      command=Command))\n\t        self.Buttons[-1].pack(side=tk.TOP,\n\t                              fill=tk.X)\n\t    ## Add a label in the frame\n\t    def AddLabel(self, Text):\n\t        self.Labels.append(tk.ttk.Label(self.Frame,\n\t                                        text=Text))\n\t        self.Labels[-1].pack(expand=True,\n\t                             pady=5)\n\t    ## Add a separator in the frame\n", "    def AddSeparator(self):\n\t        self.Separators.append(tk.ttk.Separator(self.Frame,\n\t                                                orient=tk.HORIZONTAL))\n\t        self.Separators[-1].pack(side=tk.TOP,\n\t                                 fill=tk.X,\n\t                                 pady=5)\n\t    ## Regular Setters and Getters\n\t    def SetTitle(self, title):\n\t        self.Title = title\n\t        self.Root.title(title)\n", "    def SetGeometry(self, geometry):\n\t        self.Geometry = geometry\n\t        self.Root.geometry(geometry)\n\t    def GetGeometry(self):\n\t        return (self.Geometry)\n\t    def GetTitle(self):\n\t        return (self.Title)\n\t    ## Window loop and destroyers\n\t    def CallMainloop(self):\n\t        self.Root.mainloop()\n", "    def CallWithdraw(self):\n\t        self.Root.withdraw()\n\t    def CallDestroy(self):\n\t        self.Root.destroy()\n\t## Callback for when an action button is clicked\n\tdef CallBackAction(action):\n\t    CloseOutWindow()\n\t    # Put Occurrencies and Set in the list of operators\n\t    operators = ListOccurrenciesOperators() + ListSetOperators() + ListVariousOperators()\n\t    # Add plugins in the list of operators\n", "    operators = operators + Globals.MyPluginsImporter.GetClasses()\n\t    for cls in operators:\n\t        verb = str(cls.GetName(cls))\n\t        if (action == verb[0:32]):\n\t            res = cls.Logic(cls, Globals.gui_liste[0], Globals.gui_liste[1])\n\t            break\n\t    Globals.gui_liste[2] = res\n\t    # Open a new Window List specialized as OutputList / FrameCSVSaver\n\t    Globals.gui_out_window = WindowList.WindowList(2,\n\t                                                   \"300x400+650+375\")\n", "    Globals.gui_out_window.SetTitle(action)\n\t    Globals.gui_out_window.SpecializedAsOutputList()\n\t# Procedure for closing the output window (before reopening it)\n\tdef CloseOutWindow():\n\t    if (not (Globals.gui_out_window is None)):\n\t        # Globals.gui_out_window.withdraw()\n\t        Globals.gui_out_window.CallWithdraw()\n\t        del Globals.gui_out_window\n\t        Globals.gui_out_window = None\n\t# Callback called when clicking on closing\n", "def on_closing(TheWindow):\n\t    if (messagebox.askokcancel(\"Quit\", \"Do you want to quit?\")):\n\t        #TheWindow.CallDestroy()\n\t        sys.exit(0)\n\t# Insert data in a dictionnary\n\tdef insert_data(data, dictio):\n\t    for valeur, compte in dictio.items():\n\t        texte = f\"{valeur} : {compte} occurrence(s)\"\n\t        data.insert(0, texte)\n"]}
{"filename": "src/GuiClasses/FrameCSVSaver.py", "chunked_list": ["import os.path\n\t# Tkinter GUI\n\timport tkinter as tk\n\tfrom tkinter import filedialog\n\t# Windows for errors\n\tfrom GuiClasses import WindowError\n\t# CSV Loader\n\tfrom csv_manipulate import load_csv\n\t# Tools\n\tfrom tools import occurrence\n", "from enum import Enum\n\t# Globals required for the GUI\n\tfrom GuiClasses import Globals\n\t# gui_liste : Input List 1, Input List 2, Output List\n\t# gui_liste = [None, None, None]\n\t# Choice of the output style : terms ? or terms;occ ?\n\tclass ChoiceModeType(Enum):\n\t    TERMS = 1\n\t    OCCURRENCIES = 2\n\t# Frame asking for informations about a CSV (path, sep, col)\n", "class FrameCSVSaver:\n\t    GlobalListNumber = None\n\t    # Values we want to get from the user (tk.StringVar())\n\t    Separator = None\n\t    ModeType = None\n\t    Filename = None\n\t    ### GUI\n\t    # The current frame\n\t    Frame = None\n\t    # Canvas where to put the current frame\n", "    OutterCanvas = None\n\t    # Specifications of the current frame\n\t    Geometry = None\n\t    Padding = None\n\t    BorderWidth = None\n\t    Relief = None\n\t    # Widgets of the frame\n\t    SeparatorLabel = None\n\t    SeparatorEntry = None\n\t    ModeTypeLabel = None\n", "    ModeTypeRadioButton1 = None\n\t    ModeTypeRadioButton2 = None\n\t    # Widgets for saving into a CSV\n\t    SaveButton = None\n\t    def __init__(self, canvas, ListNum=None):\n\t        # Get the canvas where to put the frame\n\t        self.OutterCanvas = canvas\n\t        self.GlobalListNumber = ListNum\n\t        self.Frame = tk.Frame(self.OutterCanvas)\n\t        # Fill variables\n", "        self.Separator = tk.StringVar()\n\t        self.ModeType = tk.IntVar(self.Frame)\n\t        self.Filename = tk.StringVar()\n\t        # Separator Description and Field\n\t        self.SeparatorLabel = tk.Label(self.Frame,\n\t                                       text=\"Separator:\")\n\t        self.SeparatorLabel.pack()\n\t        self.SeparatorEntry = tk.Entry(self.Frame,\n\t                                       textvariable=self.Separator)\n\t        self.SeparatorEntry.insert(0, \";\")\n", "        self.SeparatorEntry.pack()\n\t        # Output choice list type : terms ? or terms;occ ?\n\t        self.ModeTypeLabel = tk.Label(self.Frame,\n\t                                      text=\"Type of output:\")\n\t        self.ModeTypeLabel.pack()\n\t        # Radio button : List\n\t        self.ModeTypeRadioButton1 = tk.Radiobutton(self.Frame,\n\t                                                   text=\"Terms only\",\n\t                                                   variable=self.ModeType,\n\t                                                   value=ChoiceModeType.TERMS.value)\n", "        self.ModeTypeRadioButton1.pack()\n\t        # Radio button : Occurrencies\n\t        self.ModeTypeRadioButton2 = tk.Radiobutton(self.Frame,\n\t                                                   text=\"Occurrencies\",\n\t                                                   variable=self.ModeType,\n\t                                                   value=ChoiceModeType.OCCURRENCIES.value)\n\t        self.ModeTypeRadioButton2.pack()\n\t        # Default : Terms list\n\t        #self.ModeType.set(ChoiceModeType.TERMS.value)\n\t        self.ModeTypeRadioButton1.select()\n", "        # Default : None\n\t        #self.ModeType.set(None)\n\t        #self.Frame.pack(side=\"left\", padx=50, pady=50)\n\t    def GetFilename(self):\n\t        return (self.Filename)\n\t    def GetSeparator(self):\n\t        return (self.Separator)\n\t    def GetModeType(self):\n\t        return (self.ModeType)\n\t    # Called when saving a CSV\n", "    #  Add the launch button and pack everything\n\t    def Save_PutSaveButton(self, TheWindowListToSave):\n\t        self.Frame.pack(side=tk.TOP, anchor=tk.N)\n\t        self.SaveButton = tk.Button(self.OutterCanvas,\n\t                                    text=\"Save to\",\n\t                                    command=lambda: Save_WindowList(self,\n\t                                                                    self.GlobalListNumber,\n\t                                                                    TheWindowListToSave))\n\t        self.SaveButton.pack(side=tk.TOP,\n\t                             padx=10,\n", "                             pady=10)\n\t    # Quit the \"mainloop\" and return\n\t    def CallQuit(self):\n\t        self.OutterCanvas.quit()\n\t    # Kill the \"mainloop\" completely/Exit program\n\t    def CallDestroy(self):\n\t        self.OutterCanvas.destroy()\n\t    def Validate(self):\n\t        self.Separator.set(self.SeparatorEntry.get())\n\t        #self.ModeType.set(self.ModeTypeEntry.get())\n", "        #print(\"Frame [Save] :\")\n\t        #print(\"  Sep  : --\" + self.Separator.get() + \"--\")\n\t        #print(\"  ModeType  : --\" + str(self.ModeType.get()) + \"--\")\n\t        if ((len(self.Separator.get()) == 1) and\n\t            ((self.ModeType.get() == ChoiceModeType.TERMS.value)\n\t             or (self.ModeType.get() == ChoiceModeType.OCCURRENCIES.value))) :\n\t            return (self.Separator.get(), self.ModeType.get())\n\t        else :\n\t            return (None)\n\t    def GetCSVInfos(self):\n", "        return (self.Validate())\n\tdef Save_WindowList(Frame, NumList, TheWindowListToSave):\n\t    # Get CSV informations\n\t    CSVInfos = Frame.GetCSVInfos()\n\t    #print(\"[SaveWindowList] CSV :\")\n\t    #print(type(CSVInfos))\n\t    #print(CSVInfos)\n\t    #print(\" \")\n\t    if (not (CSVInfos is None)):\n\t        ModeType = int(CSVInfos[1])\n", "        Sep = CSVInfos[0]\n\t        data = Globals.gui_liste[NumList]\n\t        filename = filedialog.asksaveasfilename(filetypes=[(\"CSV Files\", \"*.csv\")],\n\t                                                defaultextension=\".csv\")\n\t        fd = open(filename, 'w')\n\t        if (ModeType == ChoiceModeType.TERMS.value):\n\t            [fd.write(\"{0}\\n\".format(key)) for key in data]\n\t        elif (ModeType == ChoiceModeType.OCCURRENCIES.value):\n\t            occu = occurrence(data)\n\t            [fd.write(\"{0}{1}{2}\\n\".format(key, Sep, value)) for key, value in occu.items()]\n", "        fd.close()\n\t        Frame.CallDestroy()\n\t    else:\n\t        ErrWindow = WindowError.WindowError()\n\t        ErrWindow.SetLabel(\"Error : Fill correctly CSV separator and column\")\n"]}
{"filename": "src/GuiClasses/WindowExit.py", "chunked_list": ["# Tkinter GUI\n\timport tkinter as tk\n\tclass WindowExit:\n\t    Geometry = None\n\t    Title = None\n\t    # Main window getting the label and button\n\t    Root = None\n\t    # The button and its text to click on\n\t    Button = None\n\t    ButtonText = None\n", "    def __init__(self):\n\t        self.Root = tk.Tk()\n\t        self.SetTitle(\"Close Application\")\n\t        self.ButtonText = \"Close All Windows\"\n\t        self.Button = tk.Button(self.Root,\n\t                                text=\"Close All Windows\",\n\t                                command=lambda: exit(0))\n\t        self.Button.pack()\n\t    def SetGeometry(self, geometry):\n\t        self.Geometry = geometry\n", "        self.Root.geometry(geometry)\n\t    def GetGeometry(self):\n\t        return (self.Geometry)\n\t    def SetTitle(self, title):\n\t        self.Title = title\n\t        self.Root.title(title)\n\t    def GetTitle(self):\n\t        return (self.Title)\n\t    def SetButton(self, button_text):\n\t        self.Button.destroy()\n", "        self.ButtonText = button_text\n\t        self.Button = tk.Button(self.Root,\n\t                                text=button_text,\n\t                                command=lambda: exit(0))\n\t        self.Button.pack()\n"]}
{"filename": "src/GuiClasses/Globals.py", "chunked_list": ["# gui_liste : [0]:Input List 1   [1]:Input List 2   [2]:Output List\n\tgui_liste = [None, None, None]\n\t# output window\n\tgui_out_window = None\n\t# MyPluginsImporter\n\tMyPluginsImporter = None\n"]}
{"filename": "src/CliClasses/actions.py", "chunked_list": ["import sys\n\t# Plugin loader\n\tfrom plugins_loader import PluginsImporter\n\t# Logic operators\n\tfrom basic_set_operators import ListSetOperators\n\tfrom basic_occurrencies_operators import ListOccurrenciesOperators\n\tfrom basic_various_operators import ListVariousOperators\n\t# Tools for lists\n\tfrom tools import occurrence\n\t### LOADS ACTIONS FROM DIFFERENT FILES ###\n", "def get_set_actions():\n\t    set_actions = []\n\t    for cls in ListSetOperators():\n\t        name_str = str(cls.GetName(cls))\n\t        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n\t        set_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n\t    return (set_actions)\n\tdef get_occurrencies_actions():\n\t    occ_actions = []\n\t    for cls in ListOccurrenciesOperators():\n", "        name_str = str(cls.GetName(cls))\n\t        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n\t        occ_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n\t    return (occ_actions)\n\tdef get_various_actions():\n\t    var_actions = []\n\t    for cls in ListVariousOperators():\n\t        name_str = str(cls.GetName(cls))\n\t        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n\t        var_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n", "    return (var_actions)\n\tdef get_plugins_actions(MyPluginsImporter):\n\t    plugins_actions = []\n\t    for cls in MyPluginsImporter.GetClasses():\n\t        name_str = str(cls.GetName(cls))\n\t        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n\t        plugins_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n\t    return (plugins_actions)\n\t### SEARCH ONE ACTION TO DO FROM THE LISTS OF ACTIONS ###\n\tdef execute_action(list_1, list_2, action, MyPluginsImporter):\n", "    # Execution of the desired action\n\t    out_dict = []\n\t    # Fundamental actions\n\t    if (action == \"CSV_1\"):\n\t        # Print CSV 1\n\t        csv_1 = list_1\n\t        out_dict = occurrence(csv_1)\n\t        return (out_dict)\n\t    if (action == \"CSV_2\"):\n\t        # Print CSV 2\n", "        csv_2 = list_2\n\t        out_dict = occurrence(csv_2)\n\t        return (out_dict)\n\t    # Load internal functions first (set & occ & var) and search the verbs\n\t    operations = get_set_actions() + get_occurrencies_actions() + get_various_actions()\n\t    for operation in operations:\n\t        # operation == [ name/action, lambda l1, l2 : Logic(l1, l2) ]\n\t        verb = operation[0]\n\t        #function = operation[1] ### Contains a lambda\n\t        if (action == verb):\n", "            res = operation[1](list_1, list_2)\n\t            out_dict = occurrence(res)\n\t            return (out_dict)\n\t    # Load plugins functions if action is not found in the integrated ones\n\t    new_operations = get_plugins_actions(MyPluginsImporter)\n\t    for operation in new_operations:\n\t        verb = operation[0]\n\t        #function = operation[1] ### Contains a lambda\n\t        if (action == verb):\n\t            res = operation[1](list_1, list_2)\n", "            out_dict = occurrence(res)\n\t            return (out_dict)\n\t    print(\"!!! ERROR: ACTION NOT FOUND !!!\")\n\t    sys.exit(-3)\n"]}
{"filename": "src/CliClasses/__init__.py", "chunked_list": []}
{"filename": "src/CliClasses/usages.py", "chunked_list": ["import sys\n\t# Plugin loader\n\tfrom plugins_loader import PluginsImporter\n\t# Logic operators\n\tfrom basic_set_operators import ListSetOperators\n\tfrom basic_occurrencies_operators import ListOccurrenciesOperators\n\tfrom basic_various_operators import ListVariousOperators\n\t### USAGE PRINTERS ###\n\tdef print_usage(MyPluginsImporter):\n\t    print_basic_usage()\n", "    print(\"\")\n\t    print_set_usage()\n\t    print(\"\")\n\t    print_various_usage()\n\t    print(\"\")\n\t    print_occurrencies_usage()\n\t    if (MyPluginsImporter.GetNbClasses() > 0):\n\t        print(\"\")\n\t        print_plugins_usage(MyPluginsImporter)\n\tdef print_basic_usage():\n", "    print(\"Usage: python CLI.py \" \\\n\t          \"<file_path_1> <separator1> <column_of_ID_1> \" \\\n\t          \"<file_path_2> <separator2> <column_of_ID_2> \" \\\n\t          \"<action> \" \\\n\t          \"<output_separator> [<output_file>]\")\n\t    print(\"\")\n\t    print(\"Write the output in the terminal if no <output_file> given or\" \\\n\t          \" if it is '-'\")\n\t    print(\"or write in the designated file (created if it does not exist)\")\n\t    print(\"\")\n", "    print(\"-- Actions --\")\n\t    print(\"CSV_1 : \")\n\t    print(\"   Print only 1st CSV\")\n\t    print(\"CSV_2 : \")\n\t    print(\"   Print only 2nd CSV\")\n\tdef print_set_usage():\n\t    print(\"-- Actions Set --\")\n\t    print(\" [set] : operation working on sets (occurrencies not used)\")\n\t    for cls in ListSetOperators():\n\t        name_str = str(cls.GetName(cls))\n", "        help_str = str(cls.GetHelp(cls))\n\t        print(name_str[0:32] + \" : [set]\")\n\t        print(\"   \" + help_str[0:256])\n\tdef print_occurrencies_usage():\n\t    print(\"-- Actions Occurrencies/Categories --\")\n\t    for cls in ListOccurrenciesOperators():\n\t        name_str = str(cls.GetName(cls))\n\t        help_str = str(cls.GetHelp(cls))\n\t        print(name_str[0:32] + \" :\")\n\t        print(\"   \" + help_str[0:256])\n", "def print_various_usage():\n\t    print(\"-- Actions Various --\")\n\t    for cls in ListVariousOperators():\n\t        name_str = str(cls.GetName(cls))\n\t        help_str = str(cls.GetHelp(cls))\n\t        print(name_str[0:32] + \" :\")\n\t        print(\"   \" + help_str[0:256])\n\tdef print_plugins_usage(MyPluginsImporter):\n\t    print(\"-- Actions Plugins --\")\n\t    for cls in MyPluginsImporter.GetClasses():\n", "        name_str = str(cls.GetName(cls))\n\t        help_str = str(cls.GetHelp(cls))\n\t        print(name_str[0:32] + \" :\")\n\t        print(\"   \" + help_str[0:256])\n"]}
