{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_version.py", "chunked_list": ["from src.stripe_integrations import __version__\n\tdef test_version():\n\t    assert __version__ == \"0.0.1\"\n"]}
{"filename": "src/__init__.py", "chunked_list": []}
{"filename": "src/stripe_integrations/settings.py", "chunked_list": ["# Third Party Stuff\n\tfrom django.conf import settings\n\tfrom django.test.signals import setting_changed\n\tfrom django.utils.module_loading import import_string\n\tDEFAULTS = {\n\t    \"CUSTOMER_MODEL\": \"\",\n\t    \"CARD_MODEL\": \"\",\n\t    \"PRODUCT_MODEL\": \"\",\n\t    \"PRICE_MODEL\": \"\",\n\t    \"COUPON_MODEL\": \"\",\n", "    \"EVENT_MODEL\": \"\",\n\t    \"SUBSCRIPTION_MODEL\": \"\",\n\t    \"CUSTOMER_FIELD_NAME\": \"customer\",\n\t    \"USER_FIELD_NAME\": \"user\",\n\t    \"API_VERSION\": \"\",\n\t    \"API_KEY\": \"\",\n\t}\n\tIMPORT_STRINGS = [\n\t    \"CUSTOMER_MODEL\",\n\t    \"CARD_MODEL\",\n", "    \"PRODUCT_MODEL\",\n\t    \"PRICE_MODEL\",\n\t    \"COUPON_MODEL\",\n\t    \"EVENT_MODEL\",\n\t    \"SUBSCRIPTION_MODEL\",\n\t]\n\tdef perform_import(val, setting_name):\n\t    if val is None:\n\t        return None\n\t    elif isinstance(val, str):\n", "        return import_from_string(val, setting_name)\n\t    return val\n\tdef import_from_string(val, setting_name):\n\t    try:\n\t        return import_string(val)\n\t    except ImportError as e:\n\t        msg = \"Could not import '%s' for Stripe setting '%s'. %s: %s.\" % (\n\t            val,\n\t            setting_name,\n\t            e.__class__.__name__,\n", "            e,\n\t        )\n\t        raise ImportError(msg)\n\tclass StripeSettings:\n\t    def __init__(self, user_settings=None, defaults=None, import_strings=None):\n\t        if user_settings:\n\t            self._user_settings = user_settings\n\t        self.defaults = defaults or DEFAULTS\n\t        self.import_strings = import_strings or IMPORT_STRINGS\n\t        self._cached_attrs = set()\n", "    @property\n\t    def user_settings(self):\n\t        if not hasattr(self, \"_user_settings\"):\n\t            self._user_settings = getattr(settings, \"STRIPE_CONFIG\", {})\n\t        return self._user_settings\n\t    def __getattr__(self, attr):\n\t        if attr not in self.defaults:\n\t            raise AttributeError(\"Invalid Stripe setting: '%s'\" % attr)\n\t        try:\n\t            # Check if present in user settings\n", "            val = self.user_settings[attr]\n\t        except KeyError:\n\t            # Fall back to defaults\n\t            val = self.defaults[attr]\n\t        # Coerce import strings into classes\n\t        if attr in self.import_strings:\n\t            val = perform_import(val, attr)\n\t        # Cache the result\n\t        self._cached_attrs.add(attr)\n\t        setattr(self, attr, val)\n", "        return val\n\t    def reload(self):\n\t        for attr in self._cached_attrs:\n\t            delattr(self, attr)\n\t        self._cached_attrs.clear()\n\t        if hasattr(self, \"_user_settings\"):\n\t            delattr(self, \"_user_settings\")\n\tstripe_settings = StripeSettings(None, DEFAULTS, IMPORT_STRINGS)\n\tdef reload_stripe_settings(*args, **kwargs):\n\t    setting = kwargs[\"setting\"]\n", "    if setting == \"STRIPE_CONFIG\":\n\t        stripe_settings.reload()\n\tsetting_changed.connect(reload_stripe_settings)\n"]}
{"filename": "src/stripe_integrations/models.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\tfrom django.contrib.postgres.fields import ArrayField, CIEmailField\n\tfrom django.db import models\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.base.models import StripeObject\n\tfrom stripe_integrations.utils import CURRENCY_SYMBOLS\n\tUSD = \"usd\"\n\tCURRENCY_CHOICES = ((USD, \"USD\"),)\n\tDEFAULT_CURRENCY = USD\n", "CHARGE_AUTOMATICALLY = \"charge_automatically\"\n\tSEND_INVOICE = \"send_invoice\"\n\tINVOICE_COLLECTION_METHOD_TYPES = (\n\t    (CHARGE_AUTOMATICALLY, \"Charge Automatically\"),\n\t    (SEND_INVOICE, \"Send_Invoice\"),\n\t)\n\tclass StripeBaseCustomer(StripeObject):\n\t    \"\"\"\n\t    Customer objects allow us to perform recurring charges and track multiple\n\t    charges that are associated with the same customer\n", "    Stripe documentation: https://stripe.com/docs/api/customers\n\t    \"\"\"\n\t    EXEMPT = \"exempt\"\n\t    REVERSE = \"reverse\"\n\t    NONE = \"none\"\n\t    TAX_EXEMPT_TYPES = ((EXEMPT, \"Exempt\"), (REVERSE, \"Reverse\"), (NONE, \"None\"))\n\t    # contact details\n\t    name = models.TextField(\n\t        max_length=255,\n\t        blank=True,\n", "        help_text=\"The customer's full name or business name\",\n\t    )\n\t    description = models.TextField(\n\t        max_length=255,\n\t        blank=True,\n\t        help_text=\"An arbitrary string attached to the object. Often useful for displaying to users.\",\n\t    )\n\t    email = CIEmailField(blank=True, db_index=True)\n\t    address = models.JSONField(\n\t        null=True, blank=True, help_text=\"The customer's address\"\n", "    )\n\t    balance = models.DecimalField(\n\t        decimal_places=2,\n\t        max_digits=9,\n\t        null=True,\n\t        blank=True,\n\t        help_text=(\n\t            \"Current balance (in cents), if any, being stored on the customer's \"\n\t            \"account. \"\n\t            \"If negative, the customer has credit to apply to the next invoice. \"\n", "            \"If positive, the customer has an amount owed that will be added to the \"\n\t            \"next invoice. The balance does not refer to any unpaid invoices; it \"\n\t            \"solely takes into account amounts that have yet to be successfully \"\n\t            \"applied to any invoice. This balance is only taken into account for \"\n\t            \"recurring billing purposes (i.e., subscriptions, invoices, invoice items)\"\n\t        ),\n\t    )\n\t    currency = models.CharField(\n\t        choices=CURRENCY_CHOICES,\n\t        default=DEFAULT_CURRENCY,\n", "        max_length=3,\n\t        help_text=\"The currency the customer can be charged in for recurring billing purposes\",\n\t    )\n\t    delinquent = models.BooleanField(\n\t        default=False,\n\t        help_text=\"Whether or not the latest charge for the customer's latest invoice has failed\",\n\t    )\n\t    default_source = models.TextField(blank=True)\n\t    shipping = models.JSONField(\n\t        null=True,\n", "        blank=True,\n\t        help_text=\"Shipping information associated with the customer\",\n\t    )\n\t    tax_exempt = models.CharField(\n\t        choices=TAX_EXEMPT_TYPES,\n\t        max_length=16,\n\t        default=NONE,\n\t        help_text=\"Describes the customer's tax exemption status. When set to reverse, \"\n\t        'invoice and receipt PDFs include the text \"Reverse charge\"',\n\t    )\n", "    preferred_locales = ArrayField(\n\t        models.CharField(default=\"\", blank=True, max_length=255),\n\t        default=[],\n\t        help_text=(\n\t            \"The customer's preferred locales (languages), ordered by preference\"\n\t        ),\n\t    )\n\t    invoice_prefix = models.CharField(\n\t        default=\"\",\n\t        blank=True,\n", "        max_length=255,\n\t        help_text=(\n\t            \"The prefix for the customer used to generate unique invoice numbers\"\n\t        ),\n\t    )\n\t    invoice_settings = models.JSONField(\n\t        null=True, blank=True, help_text=\"The customer's default invoice settings\"\n\t    )\n\t    date_purged = models.DateTimeField(null=True, blank=True, editable=False)\n\t    is_active = models.BooleanField(default=True)\n", "    @property\n\t    def stripe_customer(self):\n\t        return stripe.Customer.retrieve(self.stripe_id, expand=[\"subscriptions\"])\n\t    class Meta:\n\t        abstract = True\n\tclass StripeBaseCard(StripeObject):\n\t    \"\"\"\n\t    We can store multiple cards on a customer in order to charge the customer later.\n\t    We can also store multiple debit cards on a recipient in order to transfer to those cards later.\n\t    Stripe documentation: https://stripe.com/docs/api/cards\n", "    \"\"\"\n\t    name = models.TextField(null=True, blank=True)\n\t    address_line_1 = models.TextField(null=True, blank=True)\n\t    address_line_1_check = models.CharField(null=True, blank=True, max_length=64)\n\t    address_line_2 = models.TextField(null=True, blank=True)\n\t    address_city = models.TextField(null=True, blank=True)\n\t    address_state = models.TextField(null=True, blank=True)\n\t    address_country = models.TextField(null=True, blank=True)\n\t    address_zip = models.TextField(null=True, blank=True)\n\t    address_zip_check = models.CharField(null=True, blank=True, max_length=64)\n", "    brand = models.TextField(null=True, blank=True)\n\t    country = models.CharField(null=True, blank=True, max_length=2)\n\t    cvc_check = models.CharField(max_length=32, blank=True, null=True)\n\t    dynamic_last4 = models.CharField(max_length=4, blank=True, null=True)\n\t    tokenization_method = models.CharField(max_length=32, blank=True, null=True)\n\t    exp_month = models.IntegerField()\n\t    exp_year = models.IntegerField()\n\t    funding = models.CharField(max_length=15, blank=True, null=True)\n\t    last4 = models.CharField(max_length=4, blank=True, null=True)\n\t    fingerprint = models.TextField(blank=True, null=True)\n", "    def __repr__(self):\n\t        return \"Card(pk={!r}, customer={!r})\".format(\n\t            self.pk,\n\t            getattr(self, \"customer\", None),\n\t        )\n\t    class Meta:\n\t        abstract = True\n\tclass StripeBaseSubscription(StripeObject):\n\t    \"\"\"\n\t    Subscriptions allow us to charge a customer on a recurring basis.\n", "    Stripe documentation: https://stripe.com/docs/api/subscriptions\n\t    \"\"\"\n\t    # https://stripe.com/docs/api/subscriptions/object#subscription_object-status\n\t    INCOMPLETE = \"incomplete\"  # if the initial payment attempt fails\n\t    # If the first invoice is not paid within 23 hours\n\t    # (Its a terminal status)\n\t    INCOMPLETE_EXPIRED = \"incomplete_expired\"\n\t    TRIALING = \"trialing\"\n\t    ACTIVE = \"active\"\n\t    PAST_DUE = \"past_due\"  # it becomes past_due when payment to renew it fails\n", "    # 1. it becomes canceled when failed payment is not paid after all retries / by the due date\n\t    # 2. Can be cancelled manually\n\t    #  (Its a terminal status)\n\t    CANCELED = \"canceled\"\n\t    UNPAID = \"unpaid\"  # 1. it becomes unpaid When failed payment is not paid after all retries / by the due date\n\t    STATUS_CURRENT = [TRIALING, ACTIVE]\n\t    STATUS_CANCELLED = [CANCELED, UNPAID]\n\t    SUBSCRIPTION_STATUS_TYPES = (\n\t        (INCOMPLETE, \"Incomplete\"),\n\t        (INCOMPLETE_EXPIRED, \"Incomplete Expired\"),\n", "        (TRIALING, \"Trialing\"),\n\t        (ACTIVE, \"Active\"),\n\t        (PAST_DUE, \"Past Due\"),\n\t        (CANCELED, \"Canceled\"),\n\t        (UNPAID, \"Unpaid\"),\n\t    )\n\t    items = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"List of subscription items, each with an attached price.\",\n", "    )\n\t    application_fee_percent = models.DecimalField(\n\t        decimal_places=2,\n\t        max_digits=5,\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"A positive decimal that represents the fee percentage of the \"\n\t        \"subscription invoice amount that will be transferred to the application \"\n\t        \"owner's Stripe account each billing period.\",\n\t    )\n", "    automatic_tax = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Automatic tax settings for this subscription.\",\n\t    )\n\t    billing_cycle_anchor = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=(\n\t            \"Determines the date of the first full invoice, and, for plans \"\n", "            \"with `month` or `year` intervals, the day of the month for subsequent \"\n\t            \"invoices\"\n\t        ),\n\t    )\n\t    billing_thresholds = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=(\n\t            \"Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period\"\n\t        ),\n", "    )\n\t    cancel_at = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"A date in the future at which the subscription will automatically \"\n\t        \"get canceled\",\n\t    )\n\t    cancel_at_period_end = models.BooleanField(\n\t        default=False,\n\t        help_text=\"If the subscription has been canceled with the ``at_period_end`` \"\n", "        \"flag set to true, ``cancel_at_period_end`` on the subscription will be true. \"\n\t        \"We can use this attribute to determine whether a subscription that has a \"\n\t        \"status of active is scheduled to be canceled at the end of the \"\n\t        \"current period\",\n\t    )\n\t    canceled_at = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"If the subscription has been canceled, the date of that \"\n\t        \"cancellation. If the subscription was canceled with ``cancel_at_period_end``, \"\n", "        \"canceled_at will still reflect the date of the initial cancellation request, \"\n\t        \"not the end of the subscription period when the subscription is automatically \"\n\t        \"moved to a canceled state\",\n\t    )\n\t    cancellation_details = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=(\"Details about why this subscription was cancelled\"),\n\t    )\n\t    collection_method = models.CharField(\n", "        choices=INVOICE_COLLECTION_METHOD_TYPES,\n\t        max_length=32,\n\t        help_text=\"Either `charge_automatically`, or `send_invoice`. When charging \"\n\t        \"automatically, Stripe will attempt to pay this subscription at the end of the \"\n\t        \"cycle using the default source attached to the customer. \"\n\t        \"When sending an invoice, Stripe will email us customer an invoice with \"\n\t        \"payment instructions\",\n\t    )\n\t    current_period_end = models.DateTimeField(\n\t        help_text=\"End of the current period for which the subscription has been \"\n", "        \"invoiced. At the end of this period, a new invoice will be created\"\n\t    )\n\t    current_period_start = models.DateTimeField(\n\t        help_text=\"Start of the current period for which the subscription has \"\n\t        \"been invoiced\"\n\t    )\n\t    days_until_due = models.IntegerField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Number of days a customer has to pay invoices generated by this \"\n", "        \"subscription. This value will be `null` for subscriptions where \"\n\t        \"`billing=charge_automatically`\",\n\t    )\n\t    default_payment_method = models.TextField(blank=True)\n\t    default_source = models.TextField(blank=True)\n\t    default_tax_rates = models.JSONField(null=True, blank=True)\n\t    discount = models.JSONField(null=True, blank=True)\n\t    ended_at = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n", "        help_text=\"If the subscription has ended (either because it was canceled or \"\n\t        \"because the customer was switched to a subscription to a new plan), \"\n\t        \"the date the subscription ended\",\n\t    )\n\t    next_pending_invoice_item_invoice = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Specifies the approximate timestamp on which any pending \"\n\t        \"invoice items will be billed according to the schedule provided at \"\n\t        \"pending_invoice_item_interval\",\n", "    )\n\t    pause_collection = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"If specified, payment collection for this subscription will be paused.\",\n\t    )\n\t    pending_invoice_item_interval = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Specifies an interval for how often to bill for any \"\n", "        \"pending invoice items. It is analogous to calling Create an invoice \"\n\t        \"for the given subscription at the specified interval\",\n\t    )\n\t    pending_setup_intent = models.TextField(blank=True)\n\t    pending_update = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"If specified, pending updates that will be applied to the \"\n\t        \"subscription once the latest_invoice has been paid\",\n\t    )\n", "    quantity = models.IntegerField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"The quantity applied to this subscription. This value will be \"\n\t        \"`null` for multi-plan subscriptions\",\n\t    )\n\t    start_date = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Date when the subscription was first created. The date \"\n", "        \"might differ from the created date due to backdating\",\n\t    )\n\t    status = models.CharField(\n\t        choices=SUBSCRIPTION_STATUS_TYPES,\n\t        max_length=32,\n\t        help_text=\"The status of this subscription\",\n\t    )\n\t    # tax rate\n\t    trial_end = models.DateTimeField(\n\t        null=True,\n", "        blank=True,\n\t        help_text=\"If the subscription has a trial, the end of that trial\",\n\t    )\n\t    trial_start = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"If the subscription has a trial, the beginning of that trial\",\n\t    )\n\t    trial_settings = models.JSONField(\n\t        null=True,\n", "        blank=True,\n\t        help_text=\"Settings related to subscription trials.\",\n\t    )\n\t    latest_invoice = models.CharField(\n\t        max_length=255,\n\t        blank=True,\n\t        help_text=\"The most recent invoice this subscription has generated.\",\n\t    )\n\t    @property\n\t    def stripe_subscription(self):\n", "        return stripe.Subscription.retrieve(self.stripe_id)\n\t    class Meta:\n\t        abstract = True\n\tclass StripeBaseEvent(StripeObject):\n\t    kind = models.CharField(max_length=255)\n\t    webhook_message = models.JSONField()\n\t    validated_message = models.JSONField(null=True, blank=True)\n\t    valid = models.BooleanField(null=True)\n\t    processed = models.BooleanField(default=False)\n\t    request = models.JSONField(\n", "        null=True,\n\t        help_text=\"Information on the API request that instigated the event, If null, the event was automatic\"\n\t        \" (e.g., Stripe’s automatic subscription handling)\",\n\t    )\n\t    pending_webhooks = models.PositiveIntegerField(\n\t        default=0,\n\t        help_text=\"Number of webhooks that have yet to be successfully \"\n\t        \"delivered (i.e., to return a 20x response) \"\n\t        \"to the URLs we’ve specified\",\n\t    )\n", "    api_version = models.CharField(max_length=128, blank=True)\n\t    @property\n\t    def message(self):\n\t        return self.validated_message\n\t    def __str__(self):\n\t        return \"{} - {}\".format(self.kind, self.stripe_id)\n\t    class Meta:\n\t        abstract = True\n\tclass StripeBaseCoupon(StripeObject):\n\t    \"\"\"\n", "    A coupon contains information about a percent-off or amount-off discount we might want to apply to a customer.\n\t    Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges.\n\t    Stripe documentation: https://stripe.com/docs/api/coupons\n\t    \"\"\"\n\t    ONCE = \"once\"\n\t    REPEATING = \"repeating\"\n\t    FOREVER = \"forever\"\n\t    STRIPE_COUPON_DURATION_TYPES = (\n\t        (ONCE, \"Once\"),\n\t        (REPEATING, \"Repeating\"),\n", "        (FOREVER, \"Forever\"),\n\t    )\n\t    name = models.CharField(\n\t        max_length=64,\n\t        blank=True,\n\t        help_text=\"Name of the coupon displayed to customers on for instance invoices or receipts\",\n\t    )\n\t    applies_to = models.JSONField(\n\t        null=True,\n\t        blank=True,\n", "        help_text=\"Contains information about what product this coupon applies to. This field is not included by default. \"\n\t        \"To include it in the response, expand the applies_to field\",\n\t    )\n\t    amount_off = models.DecimalField(\n\t        decimal_places=2,\n\t        max_digits=9,\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Amount (in the currency specified) \"\n\t        \"that will be taken off the subtotal \"\n", "        \"of any invoices for this customer\",\n\t    )\n\t    currency = models.CharField(\n\t        choices=CURRENCY_CHOICES,\n\t        default=DEFAULT_CURRENCY,\n\t        max_length=3,\n\t        help_text=\"If amount_off has been set, the three-letter ISO code for the currency of the amount to take off\",\n\t    )\n\t    duration = models.CharField(\n\t        choices=STRIPE_COUPON_DURATION_TYPES,\n", "        max_length=16,\n\t        default=\"once\",\n\t        help_text=\"One of forever, once, and repeating. \"\n\t        \"Describes how long a customer who applies this coupon \"\n\t        \"will get the discount\",\n\t    )\n\t    duration_in_months = models.PositiveIntegerField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Required only if duration is repeating, in which case it must be a positive integer that \"\n", "        \"specifies the number of months the discount will be in effect\",\n\t    )\n\t    max_redemptions = models.PositiveIntegerField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"A positive integer specifying the number of times the coupon can \"\n\t        \"be redeemed before it’s no longer valid\",\n\t    )\n\t    percent_off = models.PositiveIntegerField(\n\t        null=True,\n", "        blank=True,\n\t        help_text=\"Percent that will be taken off the subtotal of any invoices \"\n\t        \"for this customer for the duration of the coupon\",\n\t    )\n\t    redeem_by = models.DateTimeField(\n\t        null=True,\n\t        blank=True,\n\t        help_text=\"Date after which the coupon can no longer be redeemed\",\n\t    )\n\t    times_redeemed = models.PositiveIntegerField(\n", "        null=True,\n\t        blank=True,\n\t        help_text=\"Number of times this coupon has been applied to a customer\",\n\t    )\n\t    valid = models.BooleanField(default=False)\n\t    # Soft delete price in DB on deletion from stripe\n\t    date_purged = models.DateTimeField(null=True, editable=False)\n\t    def __str__(self):\n\t        if self.amount_off is None:\n\t            description = \"{}% off\".format(\n", "                self.percent_off,\n\t            )\n\t        else:\n\t            description = \"{}{}\".format(\n\t                CURRENCY_SYMBOLS.get(self.currency, \"\"), self.amount_off\n\t            )\n\t        return \"Coupon for {}, {}\".format(description, self.duration)\n\t    class Meta:\n\t        abstract = True\n\tclass StripeBaseProduct(StripeObject):\n", "    \"\"\"\n\t    Products describe the specific goods or services you offer to your customers.\n\t    For example, you might offer a Standard and Premium version of your goods or service;\n\t    each version would be a separate Product. They can be used in conjunction with Prices\n\t    to configure pricing in Payment Links, Checkout, and Subscriptions.\n\t    Stripe documentation: https://stripe.com/docs/api/products\n\t    \"\"\"\n\t    active = models.BooleanField(\n\t        help_text=(\"Whether the product is currently available for purchase.\"),\n\t    )\n", "    description = models.TextField(\n\t        null=True,\n\t        help_text=\"The product’s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.\",\n\t    )\n\t    name = models.CharField(\n\t        max_length=255,\n\t        help_text=\"The product’s name, meant to be displayable to the customer. Whenever this product is sold via a subscription, name will show up on associated invoice line item descriptions.\",\n\t    )\n\t    statement_descriptor = models.TextField(\n\t        null=True,\n", "        help_text=(\n\t            \"Extra information about a product which will appear on your customer’s credit card statement.\"\n\t            \"In the case that multiple products are billed at once, the first statement descriptor will be used.\"\n\t        ),\n\t    )\n\t    tax_code = models.CharField(max_length=255, null=True, help_text=\"A tax code ID.\")\n\t    unit_label = models.CharField(\n\t        max_length=255,\n\t        null=True,\n\t        help_text=(\n", "            \"A label that represents units of this product in Stripe and on customers’ receipts and invoices.\"\n\t            \"When set, this will be included in associated invoice line item descriptions.\"\n\t        ),\n\t    )\n\t    images = ArrayField(\n\t        models.CharField(max_length=255),\n\t        size=8,\n\t        default=list,\n\t        help_text=(\n\t            \"A list of up to 8 URLs of images for this product, meant to be displayable to the customer.\"\n", "        ),\n\t    )\n\t    shippable = models.BooleanField(\n\t        null=True, help_text=\"Whether this product is shipped (i.e., physical goods).\"\n\t    )\n\t    package_dimensions = models.JSONField(\n\t        null=True,\n\t        help_text=\"The dimensions of this product for shipping purposes.\",\n\t    )\n\t    url = models.URLField(\n", "        max_length=500,\n\t        null=True,\n\t        help_text=\"A URL of a publicly-accessible webpage for this product.\",\n\t    )\n\t    created = models.BigIntegerField(\n\t        help_text=\"Time at which the object was created. Measured in seconds since the Unix epoch\"\n\t    )\n\t    updated = models.BigIntegerField(\n\t        help_text=\"Time at which the object was last updated. Measured in seconds since the Unix epoch\"\n\t    )\n", "    # Soft delete product in DB on deletion from stripe\n\t    date_purged = models.DateTimeField(null=True, editable=False)\n\t    class Meta:\n\t        abstract = True\n\tclass StripeBasePrice(StripeObject):\n\t    \"\"\"\n\t    Prices define the unit cost, currency, and (optional) billing cycle for both\n\t    recurring and one-time purchases of products. Products help you track inventory\n\t    or provisioning, and prices help you track payment terms. Different physical\n\t    goods or levels of service should be represented by products, and pricing options\n", "    should be represented by prices. This approach lets you change prices without\n\t    having to change your provisioning scheme.\n\t    For example, you might have a single \"gold\" product that has prices for $10/month, $100/year, and €9 once.\n\t    Stripe documentation: https://stripe.com/docs/api/prices\n\t    \"\"\"\n\t    ONE_TIME = \"one_time\"\n\t    RECURRING = \"recurring\"\n\t    PRICE_TYPES = [\n\t        (ONE_TIME, \"One Time\"),\n\t        (RECURRING, \"Recurring\"),\n", "    ]\n\t    TAX_INCLUSIVE = \"inclusive\"\n\t    TAX_EXCLUSIVE = \"exclusive\"\n\t    TAX_UNSPECIFIED = \"unspecified\"\n\t    TAX_BEHAVIOR_TYPES = [\n\t        (TAX_INCLUSIVE, \"TAX Inclusive\"),\n\t        (TAX_EXCLUSIVE, \"TAX Exclusive\"),\n\t        (TAX_INCLUSIVE, \"TAX Unspecified\"),\n\t    ]\n\t    PER_UNIT = \"per_unit\"\n", "    TIERED = \"tiered\"\n\t    BILLING_SCHEME_TYPES = [\n\t        (PER_UNIT, \"Per Unit\"),\n\t        (TIERED, \"Tiered\"),\n\t    ]\n\t    active = models.BooleanField(\n\t        help_text=\"Whether the price can be used for new purchases.\"\n\t    )\n\t    currency = models.CharField(\n\t        choices=CURRENCY_CHOICES,\n", "        max_length=3,\n\t        help_text=\"Three-letter ISO currency code, in lowercase. Must be a supported currency.\",\n\t    )\n\t    nickname = models.CharField(\n\t        max_length=255,\n\t        null=True,\n\t        help_text=\"A brief description of the price, hidden from customers.\",\n\t    )\n\t    recurring = models.JSONField(\n\t        null=True,\n", "        help_text=\"The recurring components of a price such as interval and usage_type.\",\n\t    )\n\t    type = models.CharField(\n\t        choices=PRICE_TYPES,\n\t        max_length=16,\n\t        help_text=(\n\t            \"One of one_time or recurring depending on whether the price is for \"\n\t            \"a one-time purchase or a recurring (subscription) purchase.\"\n\t        ),\n\t    )\n", "    custom_unit_amount = models.JSONField(\n\t        null=True,\n\t        help_text=(\n\t            \"When set, provides configuration for the amount to be adjusted \"\n\t            \"by the customer during Checkout Sessions and Payment Links.\"\n\t        ),\n\t    )\n\t    unit_amount = models.BigIntegerField(\n\t        null=True,\n\t        help_text=(\n", "            \"The unit amount in cents to be charged, represented as a whole \"\n\t            \"integer if possible. Null if a sub-cent precision is required\"\n\t        ),\n\t    )\n\t    unit_amount_decimal = models.DecimalField(\n\t        null=True,\n\t        max_digits=19,\n\t        decimal_places=12,\n\t        help_text=(\n\t            \"The unit amount in cents to be charged, represented as a decimal \"\n", "            \"string with at most 12 decimal places\"\n\t        ),\n\t    )\n\t    billing_scheme = models.CharField(\n\t        choices=BILLING_SCHEME_TYPES,\n\t        max_length=16,\n\t        help_text=(\n\t            \"Describes how to compute the price per period. Either per_unit or tiered.\"\n\t            \"per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal)\"\n\t            \"will be charged per unit in quantity (for prices with usage_type=licensed),\"\n", "            \"or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit\"\n\t            \"pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.\"\n\t        ),\n\t    )\n\t    tax_behavior = models.CharField(\n\t        choices=TAX_BEHAVIOR_TYPES,\n\t        max_length=16,\n\t        help_text=(\n\t            \"Specifies whether the price is considered inclusive of taxes or exclusive of taxes.\"\n\t            \"One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.\"\n", "        ),\n\t    )\n\t    tiers = models.JSONField(\n\t        null=True,\n\t        help_text=(\n\t            \"Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered.\"\n\t            \"See also the documentation for billing_scheme. This field is not included by default.\"\n\t            \"To include it in the response, expand the tiers field.\"\n\t        ),\n\t    )\n", "    tiers_mode = models.CharField(\n\t        null=True,\n\t        max_length=32,\n\t        help_text=(\n\t            \"Defines if the tiering price should be graduated or volume based.\"\n\t            \"In volume-based tiering, the maximum quantity within a period determines the per unit price.\"\n\t            \"In graduated tiering, pricing can change as the quantity grows.\"\n\t        ),\n\t    )\n\t    transform_quantity = models.JSONField(\n", "        null=True,\n\t        help_text=(\n\t            \"Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with tiers.\"\n\t        ),\n\t    )\n\t    lookup_key = models.CharField(\n\t        null=True,\n\t        max_length=255,\n\t        help_text=\"A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.\",\n\t    )\n", "    created = models.BigIntegerField(\n\t        help_text=\"Time at which the object was created. Measured in seconds since the Unix epoch\"\n\t    )\n\t    # Soft delete price in DB on deletion from stripe\n\t    date_purged = models.DateTimeField(null=True, editable=False)\n\t    class Meta:\n\t        abstract = True\n"]}
{"filename": "src/stripe_integrations/__init__.py", "chunked_list": ["__version__ = \"0.0.1\"\n\t__author__ = \"Two Point One\"\n"]}
{"filename": "src/stripe_integrations/utils.py", "chunked_list": ["# Standard Library\n\timport decimal\n\tfrom datetime import datetime\n\t# Third Party Stuff\n\tfrom django.conf import settings\n\tfrom django.utils import timezone\n\tdef convert_tstamp(response):\n\t    tz = timezone.utc if settings.USE_TZ else None\n\t    if response:\n\t        return datetime.fromtimestamp(response, tz)\n", "    return None\n\tdef convert_amount_for_db(amount, currency=\"usd\"):\n\t    if (\n\t        currency is None\n\t    ):  # @@@ not sure if this is right; find out what we should do when API returns null for currency\n\t        currency = \"usd\"\n\t    return (\n\t        (amount / decimal.Decimal(\"100\"))\n\t        if currency.lower() not in ZERO_DECIMAL_CURRENCIES\n\t        else decimal.Decimal(amount)\n", "    )\n\tCURRENCY_SYMBOLS = {\n\t    \"aud\": \"\\u0024\",\n\t    \"cad\": \"\\u0024\",\n\t    \"chf\": \"\\u0043\\u0048\\u0046\",\n\t    \"cny\": \"\\u00a5\",\n\t    \"eur\": \"\\u20ac\",\n\t    \"gbp\": \"\\u00a3\",\n\t    \"jpy\": \"\\u00a5\",\n\t    \"myr\": \"\\u0052\\u004d\",\n", "    \"sgd\": \"\\u0024\",\n\t    \"usd\": \"\\u0024\",\n\t}\n\t# currencies those amount=1 means 100 cents\n\t# https://support.stripe.com/questions/which-zero-decimal-currencies-does-stripe-support\n\tZERO_DECIMAL_CURRENCIES = [\n\t    \"bif\",\n\t    \"clp\",\n\t    \"djf\",\n\t    \"gnf\",\n", "    \"jpy\",\n\t    \"kmf\",\n\t    \"krw\",\n\t    \"mga\",\n\t    \"pyg\",\n\t    \"rwf\",\n\t    \"vuv\",\n\t    \"xaf\",\n\t    \"xof\",\n\t    \"xpf\",\n", "]\n"]}
{"filename": "src/stripe_integrations/apps.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\tfrom django.apps import AppConfig\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripeIntegrationsConfig(AppConfig):\n\t    name = \"stripe_integrations\"\n\t    def ready(self):\n\t        stripe.api_version = stripe_settings.API_VERSION\n\t        stripe.api_key = stripe_settings.API_KEY\n"]}
{"filename": "src/stripe_integrations/exceptions.py", "chunked_list": ["# Third Party Stuff\n\tfrom django.utils.translation import gettext_lazy as _\n\tclass StripeException(Exception):\n\t    default_detail = \"Stripe error\"\n\t    def __init__(self, detail=None):\n\t        self.detail = detail\n\t        if not self.detail:\n\t            self.detail = self.default_detail\n\t        super().__init__(self.detail)\n\tclass StripeAuthException(StripeException):\n", "    default_detail = _(\"Stripe auth error\")\n"]}
{"filename": "src/stripe_integrations/actions/webhooks.py", "chunked_list": ["# Standard Library\n\timport logging\n\t# Third Party Stuff\n\timport stripe\n\tfrom django.utils.encoding import smart_str\n\tfrom stripe.error import InvalidRequestError\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions.events import StripeEvent\n\tfrom stripe_integrations.settings import stripe_settings\n\tlogger = logging.getLogger(__name__)\n", "class StripeWebhook:\n\t    @classmethod\n\t    def process_webhook(cls, event_data):\n\t        event = stripe_settings.EVENT_MODEL.objects.filter(\n\t            stripe_id=event_data[\"id\"]\n\t        ).first()\n\t        if event:\n\t            logger.info(\n\t                \"Found duplicate stripe event record with event_id=%s\", event.id\n\t            )\n", "            return\n\t        if stripe.api_key:\n\t            try:\n\t                # create an event and process webhook\n\t                StripeEvent.add(\n\t                    stripe_id=event_data[\"id\"],\n\t                    kind=event_data[\"type\"],\n\t                    livemode=event_data[\"livemode\"],\n\t                    message=event_data,\n\t                    api_version=event_data[\"api_version\"],\n", "                    request=event_data[\"request\"],\n\t                    pending_webhooks=event_data[\"pending_webhooks\"],\n\t                )\n\t            except InvalidRequestError as e:\n\t                event_id = event_data[\"id\"]\n\t                logger.info(\n\t                    f\"Error occurred while processing stripe webhook, event_id={event_id}, error={smart_str(e)}\"\n\t                )\n\t            return\n\t        logger.info(\"Stripe API key not set while creating event\")\n", "        return\n"]}
{"filename": "src/stripe_integrations/actions/prices.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\tfrom django.utils import timezone\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions.products import StripeProduct\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripePrice:\n\t    @classmethod\n\t    def sync_all(cls):\n\t        \"\"\"\n", "        Synchronizes all prices from the Stripe API\n\t        \"\"\"\n\t        prices = stripe.Price.auto_paging_iter()\n\t        synced_price_ids = []\n\t        for price in prices:\n\t            price_obj, _ = cls.sync(price)\n\t            synced_price_ids.append(price_obj.id)\n\t        # sync deleted prices\n\t        stripe_settings.PRICE_MODEL.objects.exclude(id__in=synced_price_ids).update(\n\t            date_purged=timezone.now()\n", "        )\n\t    @classmethod\n\t    def sync(cls, price):\n\t        \"\"\"\n\t        Synchronizes a price from the Stripe API\n\t        Args:\n\t            price: data from Stripe API representing a price\n\t        \"\"\"\n\t        product = stripe_settings.PRODUCT_MODEL.objects.filter(\n\t            stripe_id=price[\"product\"]\n", "        ).first()\n\t        if not product:\n\t            stripe_product = stripe.Product.retrieve(price[\"product\"])\n\t            product, _ = StripeProduct.sync(stripe_product)\n\t        defaults = {\n\t            \"active\": price[\"active\"],\n\t            \"currency\": price[\"currency\"],\n\t            \"metadata\": price[\"metadata\"],\n\t            \"nickname\": price[\"nickname\"],\n\t            \"recurring\": price[\"recurring\"],\n", "            \"type\": price[\"type\"],\n\t            \"custom_unit_amount\": price[\"custom_unit_amount\"],\n\t            \"unit_amount\": price[\"unit_amount\"],\n\t            \"unit_amount_decimal\": price[\"unit_amount_decimal\"],\n\t            \"billing_scheme\": price[\"billing_scheme\"],\n\t            \"tax_behavior\": price[\"tax_behavior\"],\n\t            \"tiers\": price.get(\"tiers\", None),\n\t            \"tiers_mode\": price[\"tiers_mode\"],\n\t            \"transform_quantity\": price[\"transform_quantity\"],\n\t            \"lookup_key\": price[\"lookup_key\"],\n", "            \"livemode\": price[\"livemode\"],\n\t            \"created\": price[\"created\"],\n\t            \"product\": product,\n\t        }\n\t        price, is_created = stripe_settings.PRICE_MODEL.objects.update_or_create(\n\t            stripe_id=price[\"id\"], defaults=defaults\n\t        )\n\t        return price, is_created\n\t    @classmethod\n\t    def soft_delete(cls, stripe_id):\n", "        \"\"\"\n\t        Soft deletes the local price object (Price)\n\t        Args:\n\t            stripe_id: the Stripe ID of the price\n\t        \"\"\"\n\t        if stripe_id.startswith(\"price_\"):\n\t            price = stripe_settings.PRICE_MODEL.objects.filter(\n\t                stripe_id=stripe_id\n\t            ).first()\n\t            if price:\n", "                price.date_purged = timezone.now()\n\t                price.save()\n"]}
{"filename": "src/stripe_integrations/actions/subscriptions.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\tfrom django.db.models import Q\n\tfrom django.utils import timezone\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations import utils\n\tfrom stripe_integrations.actions.customers import StripeCustomer\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripeSubscription:\n\t    @classmethod\n", "    def create(cls, customer, prices, coupon=None, trial_from_plan=True):\n\t        \"\"\"\n\t        Creates a subscription for the given customer\n\t        Args:\n\t            customer: the customer to create the subscription for\n\t            price: the pricing of product to subscribe to\n\t        Returns:\n\t            the stripe_integrations.stripe.models.Subscription\n\t            object (created or updated)\n\t        \"\"\"\n", "        subscription_params = {}\n\t        subscription_params[\"customer\"] = customer.stripe_id\n\t        subscription_params[\"items\"] = list(map(lambda price: {\"price\": price}, prices))\n\t        # Indicates if a price’s trial_period_days should be applied to the subscription\n\t        # Ref: https://stripe.com/docs/api/subscriptions/create#create_subscription-trial_from_plan\n\t        options = {\n\t            \"trial_from_plan\": trial_from_plan,\n\t        }\n\t        # Apply coupon to subscription\n\t        if coupon:\n", "            subscription_params[\"coupon\"] = coupon.stripe_id\n\t        stripe_subscription = stripe.Subscription.create(\n\t            **subscription_params, **options\n\t        )\n\t        subscription = cls.sync_from_stripe_data(customer, stripe_subscription)\n\t        return subscription\n\t    @classmethod\n\t    def update(cls, subscription, price, pro_rate=True):\n\t        \"\"\"\n\t        Updates a subscription\n", "        Args:\n\t            subscription: the subscription to be updated\n\t            price: the new pricing obj of product to subscribe to\n\t            pro_rate: Whether to prorate Subscription charges\n\t        Ref Docs: https://stripe.com/docs/api/subscriptions/update\n\t        \"\"\"\n\t        if pro_rate:\n\t            # prorate charges in next billing cycle\n\t            proration_behavior = \"create_prorations\"\n\t        else:\n", "            # Do not prorate, update subscription from next billing cycle\n\t            proration_behavior = \"none\"\n\t        items = [{\"id\": subscription.items[\"data\"][0][\"id\"], \"price\": price.stripe_id}]\n\t        stripe_subscription = stripe.Subscription.modify(\n\t            subscription.stripe_id, proration_behavior=proration_behavior, items=items\n\t        )\n\t        return cls.sync_from_stripe_data(\n\t            getattr(subscription, stripe_settings.CUSTOMER_FIELD_NAME),\n\t            stripe_subscription,\n\t        )\n", "    @classmethod\n\t    def cancel(cls, subscription, cancel_immediately=False):\n\t        \"\"\"\n\t        Cancels the subscription at the end of the current billing period\n\t        Ref Docs: https://stripe.com/docs/api/subscriptions/cancel\n\t        Args:\n\t            subscription: the subscription obj to cancel\n\t        \"\"\"\n\t        if cancel_immediately:\n\t            stripe_subscription = stripe.Subscription.delete(subscription.stripe_id)\n", "        else:\n\t            stripe_subscription = stripe.Subscription.modify(\n\t                subscription.stripe_id, cancel_at_period_end=True\n\t            )\n\t        return cls.sync_from_stripe_data(\n\t            getattr(subscription, stripe_settings.CUSTOMER_FIELD_NAME),\n\t            stripe_subscription,\n\t        )\n\t    @classmethod\n\t    def sync_from_stripe_data(cls, customer, stripe_subscription):\n", "        \"\"\"\n\t        Synchronizes data from the Stripe API for a subscription\n\t        Args:\n\t            customer: the customer who's subscription we are syncronizing\n\t            stripe_subscription: data from the Stripe API representing\n\t            a subscription\n\t        Returns:\n\t            the stripe_integrations.models.Subscription object (created or updated)\n\t        \"\"\"\n\t        defaults = dict(\n", "            items=stripe_subscription[\"items\"],\n\t            application_fee_percent=stripe_subscription[\"application_fee_percent\"],\n\t            automatic_tax=dict(stripe_subscription[\"automatic_tax\"]),\n\t            billing_cycle_anchor=utils.convert_tstamp(\n\t                stripe_subscription[\"billing_cycle_anchor\"]\n\t            ),\n\t            billing_thresholds=stripe_subscription[\"billing_thresholds\"],\n\t            cancel_at=utils.convert_tstamp(stripe_subscription[\"cancel_at\"]),\n\t            cancel_at_period_end=stripe_subscription[\"cancel_at_period_end\"],\n\t            canceled_at=utils.convert_tstamp(stripe_subscription[\"canceled_at\"]),\n", "            cancellation_details=dict(stripe_subscription[\"cancellation_details\"]),\n\t            current_period_start=utils.convert_tstamp(\n\t                stripe_subscription[\"current_period_start\"]\n\t            ),\n\t            current_period_end=utils.convert_tstamp(\n\t                stripe_subscription[\"current_period_end\"]\n\t            ),\n\t            collection_method=stripe_subscription[\"collection_method\"],\n\t            days_until_due=stripe_subscription[\"days_until_due\"],\n\t            default_payment_method=stripe_subscription[\"default_payment_method\"] or \"\",\n", "            default_source=stripe_subscription[\"default_source\"] or \"\",\n\t            default_tax_rates=stripe_subscription[\"default_tax_rates\"],\n\t            discount=stripe_subscription[\"discount\"],\n\t            ended_at=utils.convert_tstamp(stripe_subscription[\"ended_at\"]),\n\t            next_pending_invoice_item_invoice=utils.convert_tstamp(\n\t                stripe_subscription[\"next_pending_invoice_item_invoice\"]\n\t            ),\n\t            pause_collection=stripe_subscription[\"pause_collection\"],\n\t            pending_invoice_item_interval=stripe_subscription[\n\t                \"pending_invoice_item_interval\"\n", "            ],\n\t            pending_setup_intent=stripe_subscription[\"pending_setup_intent\"] or \"\",\n\t            pending_update=stripe_subscription[\"pending_update\"],\n\t            quantity=stripe_subscription[\"quantity\"],\n\t            start_date=utils.convert_tstamp(stripe_subscription[\"start_date\"]),\n\t            status=stripe_subscription[\"status\"],\n\t            trial_start=utils.convert_tstamp(stripe_subscription[\"trial_start\"]),\n\t            trial_end=utils.convert_tstamp(stripe_subscription[\"trial_end\"]),\n\t            latest_invoice=stripe_subscription[\"latest_invoice\"] or \"\",\n\t        )\n", "        defaults.update({stripe_settings.CUSTOMER_FIELD_NAME: customer})\n\t        subscription, _ = stripe_settings.SUBSCRIPTION_MODEL.objects.update_or_create(\n\t            stripe_id=stripe_subscription[\"id\"], defaults=defaults\n\t        )\n\t        return subscription\n\t    @classmethod\n\t    def has_active_subscription(cls, customer):\n\t        \"\"\"\n\t        Checks if the given customer has an active subscription\n\t        Args:\n", "            customer: the customer to check\n\t        Returns:\n\t            True, if there is an active subscription, otherwise False\n\t        \"\"\"\n\t        data = {stripe_settings.CUSTOMER_FIELD_NAME: customer}\n\t        if customer:\n\t            return (\n\t                stripe_settings.SUBSCRIPTION_MODEL.objects.filter(**data)\n\t                .filter(Q(ended_at__isnull=True) | Q(ended_at__gt=timezone.now()))\n\t                .exists()\n", "            )\n\t        return None\n\t    @classmethod\n\t    def get_current_subscription(cls, user, customer=None):\n\t        \"\"\"\n\t        Get current subscription obj for a given user\n\t        Args:\n\t            user: a user object\n\t            customer: a stripe customer object\n\t        Returns:\n", "            a user subscription object\n\t        \"\"\"\n\t        if not customer:\n\t            customer = StripeCustomer.get(user)\n\t        data = {stripe_settings.CUSTOMER_FIELD_NAME: customer}\n\t        current_subscription = stripe_settings.SUBSCRIPTION_MODEL.objects.filter(\n\t            status__in=stripe_settings.SUBSCRIPTION_MODEL.STATUS_CURRENT, **data\n\t        ).first()\n\t        return current_subscription\n\t    @classmethod\n", "    def get_subscription(cls, user, customer=None):\n\t        \"\"\"\n\t        Get subscription obj for a given user\n\t        Args:\n\t            user: a user object\n\t            customer: a stripe customer object\n\t        Returns:\n\t            a user subscription object\n\t        \"\"\"\n\t        if not customer:\n", "            customer = StripeCustomer.get(user)\n\t        # check for active subscription\n\t        data = {stripe_settings.CUSTOMER_FIELD_NAME: customer}\n\t        subscription = stripe_settings.SUBSCRIPTION_MODEL.objects.filter(\n\t            status__in=stripe_settings.SUBSCRIPTION_MODEL.STATUS_CURRENT, **data\n\t        ).first()\n\t        # if there is no active subscription then send the latest subscription object\n\t        if not subscription:\n\t            subscription = (\n\t                stripe_settings.SUBSCRIPTION_MODEL.objects.filter(**data)\n", "                .order_by(\"-created_at\")\n\t                .first()\n\t            )\n\t        return subscription\n\t    @classmethod\n\t    def get_stripe_subscription(cls, subscription):\n\t        \"\"\"\n\t        Get stripe subscription obj for a given subscription\n\t        Args:\n\t            subscription: a subscription object\n", "        Returns:\n\t            a stripe subscription object\n\t        \"\"\"\n\t        return stripe.Subscription.retrieve(subscription.stripe_id)\n\t    @classmethod\n\t    def get_upcoming_invoice(cls, subscription):\n\t        \"\"\"\n\t        Get upcoming stripe invoice obj for a given subscription\n\t        Args:\n\t            subscription: a subscription object\n", "        Returns:\n\t            a stripe invoice object\n\t        \"\"\"\n\t        return stripe.Invoice.upcoming(subscription=subscription.stripe_id)\n\t    @classmethod\n\t    def get_latest_invoice(cls, subscription):\n\t        \"\"\"\n\t        Get latest stripe invoice obj for a given subscription\n\t        Args:\n\t            subscription: a subscription object\n", "        Returns:\n\t            a stripe invoice object\n\t        \"\"\"\n\t        return stripe.Invoice.retrieve(subscription.latest_invoice)\n"]}
{"filename": "src/stripe_integrations/actions/events.py", "chunked_list": ["# Stripe Integrations Stuff\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripeEvent:\n\t    @classmethod\n\t    def add(\n\t        cls,\n\t        stripe_id,\n\t        kind,\n\t        livemode,\n\t        api_version,\n", "        message,\n\t        request=None,\n\t        pending_webhooks=0,\n\t    ):\n\t        \"\"\"\n\t        Adds and processes an event from a received webhook\n\t        Args:\n\t            stripe_id: the stripe id of the event\n\t            kind: the label of the event\n\t            livemode: True or False if the webhook was sent from livemode or not\n", "            message: the data of the webhook\n\t            request_id: the id of the request that initiated the webhook\n\t            pending_webhooks: the number of pending webhooks\n\t        \"\"\"\n\t        event = stripe_settings.EVENT_MODEL.objects.create(\n\t            stripe_id=stripe_id,\n\t            kind=kind,\n\t            livemode=livemode,\n\t            webhook_message=message,\n\t            api_version=api_version,\n", "            request=request,\n\t            pending_webhooks=pending_webhooks,\n\t        )\n\t        # Stripe Integrations Stuff\n\t        from stripe_integrations.webhooks.base import registry\n\t        WebhookClass = registry.get(kind)\n\t        if WebhookClass is not None:\n\t            webhook = WebhookClass(event)\n\t            webhook.process()\n"]}
{"filename": "src/stripe_integrations/actions/products.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\tfrom django.utils import timezone\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripeProduct:\n\t    @classmethod\n\t    def sync_all(cls):\n\t        \"\"\"\n\t        Synchronizes all products from the Stripe API\n", "        \"\"\"\n\t        products = stripe.Product.auto_paging_iter()\n\t        synced_product_ids = []\n\t        for product in products:\n\t            product_obj, _ = cls.sync(product)\n\t            synced_product_ids.append(product_obj.id)\n\t        # sync deleted products\n\t        stripe_settings.PRODUCT_MODEL.objects.exclude(id__in=synced_product_ids).update(\n\t            date_purged=timezone.now()\n\t        )\n", "    @classmethod\n\t    def sync(cls, product):\n\t        \"\"\"\n\t        Synchronizes a product from the Stripe API\n\t        Args:\n\t            product: data from Stripe API representing a product\n\t        \"\"\"\n\t        defaults = {\n\t            \"active\": product[\"active\"],\n\t            \"description\": product[\"description\"],\n", "            \"metadata\": product[\"metadata\"],\n\t            \"name\": product[\"name\"],\n\t            \"statement_descriptor\": product[\"statement_descriptor\"],\n\t            \"tax_code\": product[\"tax_code\"],\n\t            \"unit_label\": product[\"unit_label\"],\n\t            \"images\": product[\"images\"],\n\t            \"shippable\": product[\"shippable\"],\n\t            \"package_dimensions\": product[\"package_dimensions\"],\n\t            \"url\": product[\"url\"],\n\t            \"livemode\": product[\"livemode\"],\n", "            \"created\": product[\"created\"],\n\t            \"updated\": product[\"updated\"],\n\t        }\n\t        product, is_created = stripe_settings.PRODUCT_MODEL.objects.update_or_create(\n\t            stripe_id=product[\"id\"], defaults=defaults\n\t        )\n\t        return product, is_created\n\t    @classmethod\n\t    def soft_delete(cls, stripe_id):\n\t        \"\"\"\n", "        Soft delete the local product object (Product)\n\t        Args:\n\t            stripe_id: the Stripe ID of the product\n\t        \"\"\"\n\t        if stripe_id.startswith(\"prod_\"):\n\t            product = stripe_settings.PRODUCT_MODEL.objects.filter(\n\t                stripe_id=stripe_id\n\t            ).first()\n\t            if product:\n\t                product.date_purged = timezone.now()\n", "                product.save()\n"]}
{"filename": "src/stripe_integrations/actions/customers.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\tfrom django.core.exceptions import ObjectDoesNotExist\n\tfrom django.http import Http404\n\tfrom django.utils import timezone\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations import utils\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripeCustomer:\n\t    @classmethod\n", "    def create(cls, user, billing_email, metadata=None, **kwargs):\n\t        \"\"\"\n\t        Creates a Stripe customer.\n\t        If a customer already exists, the existing customer will be returned.\n\t        Args:\n\t            user: a user object\n\t        Returns:\n\t            a customer object that was created\n\t        \"\"\"\n\t        if not metadata:\n", "            metadata = {}\n\t        customer = cls.get(user)\n\t        if customer:\n\t            try:\n\t                stripe.Customer.retrieve(customer.stripe_id)\n\t                return customer\n\t            except stripe.error.InvalidRequestError:\n\t                pass\n\t        # At this point we maybe have a local Customer but no stripe customer\n\t        # let's create one and make the binding\n", "        stripe_customer = stripe.Customer.create(\n\t            email=billing_email, metadata=metadata, **kwargs\n\t        )\n\t        data = {\n\t            stripe_settings.USER_FIELD_NAME: user,\n\t            \"is_active\": True,\n\t            \"livemode\": stripe_customer[\"livemode\"],\n\t            \"defaults\": {\"stripe_id\": stripe_customer[\"id\"], \"email\": billing_email},\n\t        }\n\t        customer, created = stripe_settings.CUSTOMER_MODEL.objects.get_or_create(**data)\n", "        if not created:\n\t            customer.stripe_id = stripe_customer[\"id\"]  # sync will call customer.save()\n\t        customer = cls.sync_from_stripe_data(customer, stripe_customer)\n\t        return customer\n\t    @classmethod\n\t    def get(cls, user):\n\t        \"\"\"\n\t        Get a customer object for a given user\n\t        Args:\n\t                user: a user object\n", "        Returns:\n\t            a customer object(local customer)\n\t        \"\"\"\n\t        if not hasattr(user, stripe_settings.CUSTOMER_FIELD_NAME):\n\t            data = {stripe_settings.USER_FIELD_NAME: user, \"is_active\": True}\n\t            customer = stripe_settings.CUSTOMER_MODEL.objects.filter(**data).first()\n\t            setattr(user, stripe_settings.CUSTOMER_FIELD_NAME, customer)\n\t        return getattr(user, stripe_settings.CUSTOMER_FIELD_NAME)\n\t    @classmethod\n\t    def sync_from_stripe_data(cls, customer, stripe_customer):\n", "        \"\"\"\n\t        Synchronizes a local Customer object with details from the Stripe API\n\t        Args:\n\t            customer: a Customer object\n\t            stripe_customer: optionally,\n\t            data from the Stripe API representing the customer\n\t        Returns:\n\t            a customer object(local customer)\n\t        \"\"\"\n\t        customer.balance = utils.convert_amount_for_db(\n", "            stripe_customer[\"balance\"], stripe_customer[\"currency\"]\n\t        )\n\t        customer.currency = stripe_customer[\"currency\"] or \"\"\n\t        customer.delinquent = stripe_customer[\"delinquent\"]\n\t        customer.default_source = stripe_customer[\"default_source\"] or \"\"\n\t        customer.description = stripe_customer[\"description\"] or \"\"\n\t        customer.address = stripe_customer[\"address\"] or \"\"\n\t        customer.name = stripe_customer[\"name\"] or \"\"\n\t        customer.shipping = stripe_customer[\"shipping\"]\n\t        customer.tax_exempt = stripe_customer[\"tax_exempt\"]\n", "        customer.preferred_locales = stripe_customer[\"preferred_locales\"]\n\t        customer.invoice_prefix = stripe_customer[\"invoice_prefix\"] or \"\"\n\t        customer.invoice_settings = stripe_customer[\"invoice_settings\"]\n\t        customer.metadata = stripe_customer[\"metadata\"]\n\t        customer.save()\n\t        return customer\n\t    @classmethod\n\t    def sync(cls, customer, stripe_customer=None):\n\t        \"\"\"\n\t        Synchronizes a local Customer object with details from the Stripe API\n", "        Args:\n\t            customer: a Customer object\n\t            stripe_customer: optionally,\n\t            data from the Stripe API representing the customer\n\t        Returns:\n\t            a customer object(local customer)\n\t        \"\"\"\n\t        if not customer.is_active:\n\t            return\n\t        if not stripe_customer:\n", "            stripe_customer = stripe.Customer.retrieve(customer.stripe_id)\n\t        if stripe_customer.get(\"deleted\", False):\n\t            cls.soft_delete(customer)\n\t            return\n\t        # Sync customer details\n\t        customer = cls.sync_from_stripe_data(customer, stripe_customer)\n\t        # Stripe Integrations Stuff\n\t        from stripe_integrations.actions.sources import StripeCard\n\t        from stripe_integrations.actions.subscriptions import StripeSubscription\n\t        # Sync customer card details\n", "        if customer.default_source:\n\t            stripe_source = stripe.Customer.retrieve_source(\n\t                customer.stripe_id, customer.default_source\n\t            )\n\t            StripeCard.sync_from_stripe_data(customer, source=stripe_source)\n\t        # Sync subscription details\n\t        subscriptions = stripe.Subscription.auto_paging_iter(\n\t            customer=customer.stripe_id\n\t        )\n\t        for subscription in subscriptions:\n", "            StripeSubscription.sync_from_stripe_data(\n\t                customer=customer,\n\t                stripe_subscription=subscription,\n\t            )\n\t        return customer\n\t    @classmethod\n\t    def link_customer(cls, event):\n\t        \"\"\"\n\t        Links a customer referenced in a webhook event message to the event object\n\t        Args:\n", "            event: the stripe_integrations.stripe.models.Event object to link\n\t        \"\"\"\n\t        if event.kind == \"customer.created\":\n\t            return\n\t        customer_crud_events = [\n\t            \"customer.updated\",\n\t            \"customer.deleted\",\n\t        ]\n\t        event_data_object = event.message[\"data\"][\"object\"]\n\t        if event.kind in customer_crud_events:\n", "            stripe_customer_id = event_data_object[\"id\"]\n\t        else:\n\t            stripe_customer_id = event_data_object.get(\"customer\", None)\n\t        if stripe_customer_id is not None:\n\t            try:\n\t                customer = stripe_settings.CUSTOMER_MODEL.objects.get(\n\t                    stripe_id=stripe_customer_id\n\t                )\n\t            except ObjectDoesNotExist:\n\t                raise Http404(\n", "                    f\"Stripe customer does not exist for event={event.stripe_id}\"\n\t                )\n\t            event.customer = customer\n\t            event.save()\n\t        return event\n\t    @classmethod\n\t    def soft_delete(cls, customer):\n\t        \"\"\"\n\t        Soft deletes the local customer object (Customer)\n\t        Args:\n", "            customer: Customer object\n\t        \"\"\"\n\t        customer.is_active = False\n\t        customer.date_purged = timezone.now()\n\t        customer.save()\n"]}
{"filename": "src/stripe_integrations/actions/__init__.py", "chunked_list": ["# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions.coupons import StripeCoupon\n\tfrom stripe_integrations.actions.customers import StripeCustomer\n\tfrom stripe_integrations.actions.events import StripeEvent\n\tfrom stripe_integrations.actions.prices import StripePrice\n\tfrom stripe_integrations.actions.products import StripeProduct\n\tfrom stripe_integrations.actions.sources import StripeCard\n\tfrom stripe_integrations.actions.subscriptions import StripeSubscription\n\tfrom stripe_integrations.actions.webhooks import StripeWebhook\n"]}
{"filename": "src/stripe_integrations/actions/sources.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions.customers import StripeCustomer\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripeCard:\n\t    @classmethod\n\t    def set_default_card(cls, customer, card_token):\n\t        \"\"\"\n\t        Create a new source object, make it the new customer default source,\n", "        and delete the old customer default if one exists\n\t        Args:\n\t            customer: the customer to update the source for\n\t            card_token: the token created from Stripe.js\n\t        Update Customer default sourceDocs: https://stripe.com/docs/api/customers/update?lang=python\n\t        Retrieve Card Docs: https://stripe.com/docs/api/cards/retrieve?lang=python\n\t        \"\"\"\n\t        stripe_customer = stripe.Customer.modify(customer.stripe_id, source=card_token)\n\t        # sync customer from stripe to update default source\n\t        StripeCustomer.sync_from_stripe_data(customer, stripe_customer)\n", "        source = stripe.Customer.retrieve_source(\n\t            customer.stripe_id, stripe_customer[\"default_source\"]\n\t        )\n\t        return cls.sync_from_stripe_data(customer, source)\n\t    @classmethod\n\t    def delete_card(cls, customer, source_stripe_id):\n\t        \"\"\"\n\t        Deletes a card from a customer\n\t        Args:\n\t            customer: the customer to delete the card from\n", "            source_stripe_id: the Stripe ID of the payment source to delete\n\t        Ref Docs: https://stripe.com/docs/api/cards/delete\n\t        \"\"\"\n\t        stripe.Customer.delete_source(customer.stripe_id, source_stripe_id)\n\t        # sync customer from stripe to update default source\n\t        StripeCustomer.sync(customer)\n\t        return cls.delete(source_stripe_id)\n\t    @classmethod\n\t    def sync_from_stripe_data(cls, customer, source):\n\t        \"\"\"\n", "        Synchronizes the data for a payment source locally for a given customer\n\t        Args:\n\t            customer: the customer to create or update a Bitcoin receiver for\n\t            source: data representing the payment source from the Stripe API\n\t        \"\"\"\n\t        if source[\"object\"] == \"card\":\n\t            return cls.sync(customer, source)\n\t    @classmethod\n\t    def sync(cls, customer, source=None):\n\t        \"\"\"\n", "        Synchronizes the data for a card locally for a given customer\n\t        Args:\n\t            customer: the customer to create or update a card for\n\t            source: data representing the card from the Stripe API\n\t        \"\"\"\n\t        defaults = dict(\n\t            name=source[\"name\"],\n\t            address_line_1=source[\"address_line1\"],\n\t            address_line_1_check=source[\"address_line1_check\"],\n\t            address_line_2=source[\"address_line2\"],\n", "            address_city=source[\"address_city\"],\n\t            address_state=source[\"address_state\"],\n\t            address_country=source[\"address_country\"],\n\t            address_zip=source[\"address_zip\"],\n\t            address_zip_check=source[\"address_zip_check\"],\n\t            brand=source[\"brand\"],\n\t            country=source[\"country\"],\n\t            cvc_check=source[\"cvc_check\"],\n\t            dynamic_last4=source[\"dynamic_last4\"],\n\t            tokenization_method=source[\"tokenization_method\"],\n", "            exp_month=source[\"exp_month\"],\n\t            exp_year=source[\"exp_year\"],\n\t            funding=source[\"funding\"],\n\t            last4=source[\"last4\"],\n\t            fingerprint=source[\"fingerprint\"],\n\t        )\n\t        defaults.update({stripe_settings.CUSTOMER_FIELD_NAME: customer})\n\t        card, _ = stripe_settings.CARD_MODEL.objects.update_or_create(\n\t            stripe_id=source[\"id\"], defaults=defaults\n\t        )\n", "        return card\n\t    @classmethod\n\t    def delete(cls, stripe_id):\n\t        \"\"\"\n\t        Deletes the local card object (Card)\n\t        Args:\n\t            stripe_id: the Stripe ID of the card\n\t        \"\"\"\n\t        if stripe_id.startswith(\"card_\"):\n\t            return stripe_settings.CARD_MODEL.objects.filter(\n", "                stripe_id=stripe_id\n\t            ).delete()\n\t    @classmethod\n\t    def get_for_customer(cls, customer):\n\t        \"\"\"\n\t        Returns default source for customer\n\t        Args:\n\t            customer: the customer to get the default source for\n\t        \"\"\"\n\t        default_card = stripe_settings.CARD_MODEL.objects.filter(\n", "            stripe_id=customer.default_source\n\t        ).first()\n\t        return default_card\n"]}
{"filename": "src/stripe_integrations/actions/coupons.py", "chunked_list": ["# Third Party Stuff\n\timport stripe\n\tfrom django.utils import timezone\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations import utils\n\tfrom stripe_integrations.settings import stripe_settings\n\tclass StripeCoupon:\n\t    @classmethod\n\t    def sync(cls, stripe_coupon):\n\t        \"\"\"\n", "        Sync stripe coupons data\n\t        Note:\n\t            applies_to: This key is not received from stripe\n\t            when the coupon is not applied to specific product\n\t        Args:\n\t            stripe_coupon: Stripe coupon object\n\t        Retruns:\n\t            coupon object, is_created status (Boolean)\n\t        \"\"\"\n\t        defaults = dict(\n", "            amount_off=(\n\t                utils.convert_amount_for_db(\n\t                    stripe_coupon[\"amount_off\"], stripe_coupon[\"currency\"]\n\t                )\n\t                if stripe_coupon[\"amount_off\"]\n\t                else None\n\t            ),\n\t            currency=stripe_coupon[\"currency\"] or \"\",\n\t            duration=stripe_coupon[\"duration\"],\n\t            duration_in_months=stripe_coupon[\"duration_in_months\"],\n", "            max_redemptions=stripe_coupon[\"max_redemptions\"],\n\t            metadata=stripe_coupon[\"metadata\"],\n\t            name=stripe_coupon[\"name\"],\n\t            applies_to=stripe_coupon.get(\"applies_to\", None),\n\t            percent_off=stripe_coupon[\"percent_off\"],\n\t            redeem_by=utils.convert_tstamp(stripe_coupon[\"redeem_by\"])\n\t            if stripe_coupon[\"redeem_by\"]\n\t            else None,\n\t            times_redeemed=stripe_coupon[\"times_redeemed\"],\n\t            valid=stripe_coupon[\"valid\"],\n", "            livemode=stripe_coupon[\"livemode\"],\n\t        )\n\t        coupon, is_created = stripe_settings.COUPON_MODEL.objects.update_or_create(\n\t            stripe_id=stripe_coupon[\"id\"], defaults=defaults\n\t        )\n\t        return coupon, is_created\n\t    @classmethod\n\t    def sync_all(cls):\n\t        \"\"\"\n\t        Synchronizes all coupons from the Stripe API\n", "        Retruns:\n\t            list of coupons that is synced\n\t        \"\"\"\n\t        strip_coupons = stripe.Coupon.auto_paging_iter(expand=[\"data.applies_to\"])\n\t        coupons = []\n\t        for coupon in strip_coupons:\n\t            obj, _ = cls.sync(coupon)\n\t            coupons.append(obj)\n\t        return coupons\n\t    @classmethod\n", "    def get(cls, stripe_id):\n\t        \"\"\"\n\t        Retrieve coupon object\n\t        Args:\n\t            stripe_id: Coupon's stripe id\n\t        Retruns:\n\t            a coupon object\n\t        \"\"\"\n\t        coupon = stripe_settings.COUPON_MODEL.objects.filter(\n\t            stripe_id=stripe_id, valid=True\n", "        ).first()\n\t        return coupon\n\t    @classmethod\n\t    def soft_delete(cls, stripe_id):\n\t        \"\"\"\n\t        Deletes the local price object (Coupon)\n\t        Args:\n\t            stripe_id: the Stripe ID of the coupon\n\t        \"\"\"\n\t        coupon = stripe_settings.COUPON_MODEL.objects.filter(\n", "            stripe_id=stripe_id\n\t        ).first()\n\t        if coupon:\n\t            coupon.date_purged = timezone.now()\n\t            coupon.save()\n"]}
{"filename": "src/stripe_integrations/webhooks/prices.py", "chunked_list": ["# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripePrice\n\tfrom stripe_integrations.webhooks.base import BaseWebhook\n\tclass PriceBaseWebhook(BaseWebhook):\n\t    def process_webhook(self):\n\t        StripePrice.sync(self.event.message[\"data\"][\"object\"])\n\tclass PriceCreatedWebhook(PriceBaseWebhook):\n\t    name = \"price.created\"\n\t    description = \"Occurs whenever a new price is created.\"\n\tclass PriceUpdatedWebhook(PriceBaseWebhook):\n", "    name = \"price.updated\"\n\t    description = \"Occurs whenever any property of a price changes.\"\n\tclass PriceDeletedWebhook(PriceBaseWebhook):\n\t    name = \"price.deleted\"\n\t    description = \"Occurs whenever a price is deleted.\"\n\t    def process_webhook(self):\n\t        StripePrice.soft_delete(self.event.validated_message[\"data\"][\"object\"][\"id\"])\n"]}
{"filename": "src/stripe_integrations/webhooks/subscriptions.py", "chunked_list": ["# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeCustomer, StripeSubscription\n\tfrom stripe_integrations.webhooks.base import BaseWebhook\n\tclass CustomerSubscriptionBaseWebhook(BaseWebhook):\n\t    def process_webhook(self):\n\t        if self.event.validated_message:\n\t            StripeSubscription.sync_from_stripe_data(\n\t                self.event.customer,\n\t                self.event.validated_message[\"data\"][\"object\"],\n\t            )\n", "        if self.event.customer:\n\t            StripeCustomer.sync(self.event.customer)\n\tclass CustomerSubscriptionCreatedWebhook(CustomerSubscriptionBaseWebhook):\n\t    name = \"customer.subscription.created\"\n\t    description = (\n\t        \"Occurs whenever a customer with no subscription is signed up for a plan.\"\n\t    )\n\tclass CustomerSubscriptionDeletedWebhook(CustomerSubscriptionBaseWebhook):\n\t    name = \"customer.subscription.deleted\"\n\t    description = \"Occurs whenever a customer ends their subscription.\"\n", "class CustomerSubscriptionTrialWillEndWebhook(CustomerSubscriptionBaseWebhook):\n\t    name = \"customer.subscription.trial_will_end\"\n\t    description = \"Occurs three days before the trial period of a subscription is scheduled to end.\"\n\tclass CustomerSubscriptionUpdatedWebhook(CustomerSubscriptionBaseWebhook):\n\t    name = \"customer.subscription.updated\"\n\t    description = \"Occurs whenever a subscription changes. Examples would include switching from one plan to another, or switching status from trial to active.\"\n"]}
{"filename": "src/stripe_integrations/webhooks/base.py", "chunked_list": ["# Standard Library\n\timport json\n\t# Third Party Stuff\n\timport stripe\n\tfrom six import with_metaclass\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeCustomer\n\tfrom stripe_integrations.base.webhooks import WebhookRegistry\n\tregistry = WebhookRegistry()\n\tdel WebhookRegistry\n", "class Registerable(type):\n\t    def __new__(cls, clsname, bases, attrs):\n\t        new_class = super(Registerable, cls).__new__(cls, clsname, bases, attrs)\n\t        if getattr(new_class, \"name\", None) is not None:\n\t            registry.register(new_class)\n\t        return new_class\n\tclass BaseWebhook(with_metaclass(Registerable, object)):\n\t    \"\"\"\n\t    REGISTRY: webhook registry\n\t    name: webhook event name\n", "    \"\"\"\n\t    REGISTRY = registry\n\t    name = None\n\t    def __init__(self, event):\n\t        if event.kind != self.name:\n\t            raise Exception(\n\t                \"The Webhook handler ({}) received the wrong type of Event ({})\".format(\n\t                    self.name, event.kind\n\t                )\n\t            )\n", "        self.event = event\n\t    def validate(self):\n\t        \"\"\"\n\t        Validate incoming events\n\t        We fetch the event data to ensure it is legit\n\t        \"\"\"\n\t        evt = stripe.Event.retrieve(\n\t            self.event.stripe_id,\n\t        )\n\t        self.event.validated_message = json.loads(\n", "            json.dumps(\n\t                evt.to_dict(),\n\t                sort_keys=True,\n\t            )\n\t        )\n\t        self.event.valid = self.is_event_valid(\n\t            self.event.webhook_message[\"data\"], self.event.validated_message[\"data\"]\n\t        )\n\t        self.event.save()\n\t    @staticmethod\n", "    def is_event_valid(webhook_message_data, validated_message_data):\n\t        return (\n\t            \"object\" in webhook_message_data\n\t            and \"object\" in validated_message_data\n\t            and webhook_message_data[\"object\"][\"id\"]\n\t            == validated_message_data[\"object\"][\"id\"]\n\t        )\n\t    def send_signal(self):\n\t        signal = self.REGISTRY.get_signal(self.name)\n\t        if signal:\n", "            return signal.send(sender=self.__class__, event=self.event)\n\t    def process(self):\n\t        if self.event.processed:\n\t            return\n\t        self.validate()\n\t        if not self.event.valid:\n\t            return\n\t        try:\n\t            StripeCustomer.link_customer(self.event)\n\t            self.process_webhook()\n", "            self.send_signal()\n\t            self.event.processed = True\n\t            self.event.save()\n\t        except Exception as e:\n\t            raise e\n\t    def process_webhook(self):\n\t        return\n"]}
{"filename": "src/stripe_integrations/webhooks/products.py", "chunked_list": ["# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeProduct\n\tfrom stripe_integrations.webhooks.base import BaseWebhook\n\tclass ProductBaseWebhook(BaseWebhook):\n\t    def process_webhook(self):\n\t        StripeProduct.sync(self.event.message[\"data\"][\"object\"])\n\tclass ProductCreatedWebhook(ProductBaseWebhook):\n\t    name = \"product.created\"\n\t    description = \"Occurs whenever a new product is created.\"\n\tclass ProductUpdatedWebhook(ProductBaseWebhook):\n", "    name = \"product.updated\"\n\t    description = \"Occurs whenever any property of a product changes.\"\n\tclass ProductDeletedWebhook(BaseWebhook):\n\t    name = \"product.deleted\"\n\t    description = \"Occurs whenever a product is deleted.\"\n\t    def process_webhook(self):\n\t        StripeProduct.soft_delete(self.event.validated_message[\"data\"][\"object\"][\"id\"])\n"]}
{"filename": "src/stripe_integrations/webhooks/customers.py", "chunked_list": ["# Third Party Stuff\n\tfrom django.apps import apps\n\tfrom django.conf import settings\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeCustomer\n\tfrom stripe_integrations.settings import stripe_settings\n\tfrom stripe_integrations.webhooks.base import BaseWebhook\n\tclass CustomerUpdatedWebhook(BaseWebhook):\n\t    name = \"customer.updated\"\n\t    description = \"Occurs whenever any property of a customer changes.\"\n", "    def process_webhook(self):\n\t        if self.event.customer:\n\t            stripe_customer = self.event.message[\"data\"][\"object\"]\n\t            StripeCustomer.sync(self.event.customer, stripe_customer)\n\tclass CustomerCreatedWebhook(BaseWebhook):\n\t    name = \"customer.created\"\n\t    description = \"Occurs whenever a new customer is created.\"\n\t    def process_webhook(self):\n\t        stripe_customer = self.event.message[\"data\"][\"object\"]\n\t        email = stripe_customer[\"email\"]\n", "        stripe_id = self.event.message[\"data\"][\"object\"][\"id\"]\n\t        User = apps.get_model(settings.AUTH_USER_MODEL)\n\t        user = User.objects.filter(email=email).first()\n\t        if user and not user.stripe_customers.exists():\n\t            # create customer\n\t            data = {\n\t                \"user\": user,\n\t                \"email\": user.email,\n\t                \"is_active\": True,\n\t                \"defaults\": {\"stripe_id\": stripe_id},\n", "            }\n\t            customer, _ = stripe_settings.CUSTOMER_MODEL.objects.get_or_create(**data)\n\t            # link customer to event\n\t            self.event.customer = customer\n\t            self.event.save()\n\t            # sync customer\n\t            StripeCustomer.sync(customer, stripe_customer)\n\tclass CustomerDeletedWebhook(BaseWebhook):\n\t    name = \"customer.deleted\"\n\t    description = \"Occurs whenever a customer is deleted.\"\n", "    def process_webhook(self):\n\t        if self.event.customer:\n\t            StripeCustomer.soft_delete(self.event.customer)\n"]}
{"filename": "src/stripe_integrations/webhooks/__init__.py", "chunked_list": ["# Standard Library\n\timport importlib\n\timportlib.import_module(\"stripe_integrations.webhooks.products\")\n\timportlib.import_module(\"stripe_integrations.webhooks.customers\")\n\timportlib.import_module(\"stripe_integrations.webhooks.subscriptions\")\n\timportlib.import_module(\"stripe_integrations.webhooks.prices\")\n\timportlib.import_module(\"stripe_integrations.webhooks.sources\")\n\timportlib.import_module(\"stripe_integrations.webhooks.coupons\")\n"]}
{"filename": "src/stripe_integrations/webhooks/sources.py", "chunked_list": ["# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeCard\n\tfrom stripe_integrations.webhooks.base import BaseWebhook\n\tclass CustomerSourceBaseWebhook(BaseWebhook):\n\t    def process_webhook(self):\n\t        StripeCard.sync_from_stripe_data(\n\t            self.event.customer, self.event.validated_message[\"data\"][\"object\"]\n\t        )\n\tclass CustomerSourceCreatedWebhook(CustomerSourceBaseWebhook):\n\t    name = \"customer.source.created\"\n", "    description = \"Occurs whenever a new source is created for the customer.\"\n\tclass CustomerSourceDeletedWebhook(BaseWebhook):\n\t    name = \"customer.source.deleted\"\n\t    description = \"Occurs whenever a source is removed from a customer.\"\n\t    def process_webhook(self):\n\t        StripeCard.delete(self.event.validated_message[\"data\"][\"object\"][\"id\"])\n\tclass CustomerSourceUpdatedWebhook(CustomerSourceBaseWebhook):\n\t    name = \"customer.source.updated\"\n\t    description = \"Occurs whenever a source's details are changed.\"\n"]}
{"filename": "src/stripe_integrations/webhooks/coupons.py", "chunked_list": ["# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeCoupon\n\tfrom stripe_integrations.webhooks.base import BaseWebhook\n\tclass CouponBaseWebhook(BaseWebhook):\n\t    def process_webhook(self):\n\t        StripeCoupon.sync(self.event.message[\"data\"][\"object\"])\n\tclass CouponCreatedWebhook(CouponBaseWebhook):\n\t    name = \"coupon.created\"\n\t    description = \"Occurs whenever a new coupon is created.\"\n\tclass CouponUpdatedWebhook(CouponBaseWebhook):\n", "    name = \"coupon.updated\"\n\t    description = \"Occurs whenever any property of a coupon changes.\"\n\tclass CouponDeletedWebhook(CouponBaseWebhook):\n\t    name = \"coupon.deleted\"\n\t    description = \"Occurs whenever a coupon is deleted.\"\n\t    def process_webhook(self):\n\t        StripeCoupon.soft_delete(self.event.validated_message[\"data\"][\"object\"][\"id\"])\n"]}
{"filename": "src/stripe_integrations/base/webhooks.py", "chunked_list": ["# Third Party Stuff\n\tfrom django.dispatch import Signal\n\tclass WebhookRegistry(object):\n\t    def __init__(self):\n\t        self._registry = {}\n\t    def register(self, webhook):\n\t        self._registry[webhook.name] = {\n\t            \"webhook\": webhook,\n\t            \"signal\": Signal(providing_args=[\"event\"]),\n\t        }\n", "    def keys(self):\n\t        return self._registry.keys()\n\t    def get(self, name, default=None):\n\t        try:\n\t            return self[name][\"webhook\"]\n\t        except KeyError:\n\t            return default\n\t    def get_signal(self, name, default=None):\n\t        try:\n\t            return self[name][\"signal\"]\n", "        except KeyError:\n\t            return default\n\t    def signals(self):\n\t        return {key: self.get_signal(key) for key in self.keys()}\n\t    def __getitem__(self, name):\n\t        return self._registry[name]\n"]}
{"filename": "src/stripe_integrations/base/models.py", "chunked_list": ["# Standard Library\n\timport uuid\n\t# Third Party Stuff\n\tfrom django.db import models\n\tclass UUIDModel(models.Model):\n\t    \"\"\"An abstract base class model that makes primary key `id` as UUID\n\t    instead of default auto incremented number.\n\t    \"\"\"\n\t    id = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4)\n\t    class Meta:\n", "        abstract = True\n\tclass TimeStampedUUIDModel(UUIDModel):\n\t    \"\"\"An abstract base class model that provides self-updating\n\t    ``created`` and ``modified`` fields with UUID as primary_key field.\n\t    \"\"\"\n\t    created_at = models.DateTimeField(auto_now_add=True, editable=False)\n\t    modified_at = models.DateTimeField(auto_now=True, editable=False)\n\t    class Meta:\n\t        abstract = True\n\tclass StripeObject(TimeStampedUUIDModel):\n", "    \"\"\"\n\t    An abstract base class model that provides stripe_id field\n\t    with UUID as primary_key along with self-updating\n\t    created_at and modified_at fields\n\t    \"\"\"\n\t    stripe_id = models.CharField(max_length=255, unique=True)\n\t    livemode = models.BooleanField(\n\t        default=False,\n\t        help_text=(\n\t            \"Has the value true if the object exists in live mode or\"\n", "            \"the value false if the object exists in test mode.\"\n\t        ),\n\t    )\n\t    metadata = models.JSONField(\n\t        null=True,\n\t        blank=True,\n\t        default=dict,\n\t        help_text=(\n\t            \"Set of key-value pairs that you can attach to an object.\"\n\t            \"This can be useful for storing additional information \"\n", "            \"about the object in a structured format.\"\n\t        ),\n\t    )\n\t    class Meta:\n\t        abstract = True\n"]}
{"filename": "src/stripe_integrations/base/__init__.py", "chunked_list": []}
{"filename": "src/stripe_integrations/management/__init__.py", "chunked_list": []}
{"filename": "src/stripe_integrations/management/commands/sync_stripe_customers.py", "chunked_list": ["# Standard Library\n\timport logging\n\t# Third Party Stuff\n\timport stripe\n\tfrom django.apps import apps\n\tfrom django.conf import settings\n\tfrom django.core.management import BaseCommand\n\tfrom stripe.error import InvalidRequestError\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeCustomer\n", "logger = logging.getLogger(__name__)\n\tclass Command(BaseCommand):\n\t    \"\"\"\n\t    Sync (ONLY UPDATE, it doesn't create customers if not exist in local DB) customers from stripe\n\t    command: python manage.py sync_stripe_customers\n\t    \"\"\"\n\t    help = \"Sync customers data\"\n\t    def handle(self, *args, **options):\n\t        if not stripe.api_key:\n\t            logger.info(\"Stripe API key not set\")\n", "            return\n\t        User = apps.get_model(settings.AUTH_USER_MODEL)\n\t        users = User.objects.all()\n\t        total = users.count()\n\t        count = 0\n\t        for user in users:\n\t            customer = StripeCustomer.get(user)\n\t            # show percentage of local customer's synced with stripe\n\t            if customer:\n\t                count += 1\n", "                percent = int(round(100 * (float(count) / float(total))))\n\t                self.stdout.write(\n\t                    \"[{0}/{1} {2}%] Syncing {3} {4}\\n\".format(\n\t                        count,\n\t                        total,\n\t                        percent,\n\t                        user.first_name,\n\t                        user.last_name,\n\t                    )\n\t                )\n", "                # sync local customer with stripe\n\t                try:\n\t                    customer = StripeCustomer.sync(customer)\n\t                except InvalidRequestError as exc:\n\t                    if exc.http_status == 404:\n\t                        # This user doesn't exist (might be in test mode)\n\t                        logger.info(\n\t                            \"Stripe customer doesn't exist, user_id=%s, customer_id=%s\",\n\t                            user.id,\n\t                            customer.stripe_id,\n", "                        )\n\t                        continue\n\t                    raise exc\n"]}
{"filename": "src/stripe_integrations/management/commands/sync_stripe_prices.py", "chunked_list": ["# Standard Library\n\timport logging\n\t# Third Party Stuff\n\timport stripe\n\tfrom django.core.management import BaseCommand\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripePrice\n\tlogger = logging.getLogger(__name__)\n\tclass Command(BaseCommand):\n\t    \"\"\"\n", "    Sync (UPDATE_OR_CREATE in local DB) prices from stripe\n\t    command: python manage.py sync_stripe_prices\n\t    \"\"\"\n\t    help = \"Sync prices\"\n\t    def handle(self, *args, **options):\n\t        if not stripe.api_key:\n\t            logger.info(\"Stripe API key not set while syncing prices\")\n\t            return\n\t        StripePrice.sync_all()\n\t        logger.info(\"Synced stripe prices\")\n"]}
{"filename": "src/stripe_integrations/management/commands/sync_stripe_products.py", "chunked_list": ["# Standard Library\n\timport logging\n\t# Third Party Stuff\n\timport stripe\n\tfrom django.core.management import BaseCommand\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeProduct\n\tlogger = logging.getLogger(__name__)\n\tclass Command(BaseCommand):\n\t    \"\"\"\n", "    Sync (UPDATE_OR_CREATE in local DB) products from stripe\n\t    command: python manage.py sync_stripe_products\n\t    \"\"\"\n\t    help = \"Sync products\"\n\t    def handle(self, *args, **options):\n\t        if not stripe.api_key:\n\t            logger.info(\"Stripe API key not set while syncing products\")\n\t            return\n\t        StripeProduct.sync_all()\n\t        logger.info(\"Synced stripe products\")\n"]}
{"filename": "src/stripe_integrations/management/commands/__init__.py", "chunked_list": []}
{"filename": "src/stripe_integrations/management/commands/sync_stripe_coupons.py", "chunked_list": ["# Standard Library\n\timport logging\n\t# Third Party Stuff\n\timport stripe\n\tfrom django.core.management import BaseCommand\n\t# Stripe Integrations Stuff\n\tfrom stripe_integrations.actions import StripeCoupon\n\tlogger = logging.getLogger(__name__)\n\tclass Command(BaseCommand):\n\t    \"\"\"\n", "    Sync (UPDATE_OR_CREATE in local DB) soupons from stripe\n\t    command: python manage.py sync_stripe_coupons\n\t    \"\"\"\n\t    help = \"Sync coupons\"\n\t    def handle(self, *args, **options):\n\t        if not stripe.api_key:\n\t            logger.info(\"Stripe API key not set while syncing coupons\")\n\t            return\n\t        StripeCoupon.sync_all()\n\t        logger.info(\"Synced stripe coupons\")\n"]}
