{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\tsetup(\n\t    name='OnlineJudge',\n\t    version='0.0.1',\n\t    packages=['OJ', 'OJ.db', 'OJ.app', 'OJ.util', 'OJ.views', 'OJ.views.admin', 'OJ.models', 'OJ.middleware'],\n\t    url='',\n\t    license='',\n\t    author='cslzc',\n\t    author_email='',\n\t    description='',\n", "    install_requires=[\n\t        'fastapi',\n\t        'redis',\n\t        'requests',\n\t        'SQLAlchemy',\n\t        'urllib3',\n\t        'fastapi-pagination',\n\t        'pycryptodome',\n\t        'PyMySQL',\n\t        'uvicorn',\n", "        'python-multipart',\n\t        'PyYAML',\n\t        'cryptography'\n\t    ]\n\t)\n"]}
{"filename": "main.py", "chunked_list": ["from OJ import OJBe\n\tif __name__ == '__main__':\n\t    server = OJBe(\n\t        'config.yaml'\n\t    )\n\t    # add custom middleware\n\t    # server.add_middleware(...)\n\t    # You can also add other routes here\n\t    # server.add_route(...)\n\t    server.start()\n"]}
{"filename": "OJ/__init__.py", "chunked_list": ["import os\n\timport importlib\n\timport uvicorn\n\timport yaml\n\tfrom fastapi import FastAPI\n\tfrom fastapi.middleware.cors import CORSMiddleware\n\tfrom fastapi_pagination.utils import FastAPIPaginationWarning\n\timport warnings\n\tclass OJBe(object):\n\t    available = True\n", "    def __init__(self, config_path) -> None:\n\t        super().__init__()\n\t        self.config = {}\n\t        self.config_path = config_path\n\t        self.check_config_is_available()\n\t        self.load_config()\n\t        self.host = self.config['server']['host']\n\t        self.port = self.config['server']['port']\n\t        self.app = FastAPI()\n\t        self.setup()\n", "    def setup(self):\n\t        db = importlib.import_module('OJ.db.database')\n\t        db.create_connection()\n\t        db.Base.metadata.create_all(db.engine)\n\t        users_mw = importlib.import_module('OJ.middleware.users')\n\t        urls = importlib.import_module('OJ.views')\n\t        self.add_middleware(users_mw.CheckLogin)\n\t        self.add_routes(urls.routes)\n\t        if self.config['server'].get('is_cors', 0) == 1:\n\t            self.add_middleware(\n", "                CORSMiddleware,\n\t                allow_origins=[\"*\"],\n\t                allow_credentials=True,\n\t                allow_methods=[\"*\"],\n\t                allow_headers=[\"*\"],\n\t            )\n\t    def check_config_is_available(self):\n\t        try:\n\t            self.config = yaml.load(open(self.config_path), yaml.Loader)\n\t        except:\n", "            assert False, 'Invalid config file.'\n\t        self.config['server'] = self.config.get('server', {'host': '0.0.0.0', 'port': 16808})\n\t        self.config['AES_KEY'] = self.config.get('AES_KEY', 'zjuerzclu')\n\t        self.config['test_case'] = self.config.get('test_case', {'dir': './testcases'})\n\t        assert (\n\t                self.config.get('mysql', None) and\n\t                self.config['mysql'].get('user', None) and\n\t                self.config['mysql'].get('host', None) and\n\t                self.config['mysql'].get('pass', None) and\n\t                self.config['mysql'].get('port', None) and\n", "                self.config['mysql'].get('name', None)\n\t        ), 'Invalid MySQL config.'\n\t        assert (\n\t                self.config.get('redis', None) and\n\t                self.config['redis'].get('host', None) and\n\t                self.config['redis'].get('pass', None) and\n\t                self.config['redis'].get('port', None) and\n\t                self.config['redis'].get('db', None)\n\t        ), 'Invalid Redis config.'\n\t    def load_config(self):\n", "        #  Server config\n\t        os.environ['HOST'] = self.config['server']['host']\n\t        os.environ['PORT'] = str(self.config['server']['port'])\n\t        #  MySQL config\n\t        os.environ['DB_USER'] = self.config['mysql']['user']\n\t        os.environ['DB_PASS'] = self.config['mysql']['pass']\n\t        os.environ['DB_HOST'] = self.config['mysql']['host']\n\t        os.environ['DB_PORT'] = self.config['mysql']['port']\n\t        os.environ['DB_NAME'] = self.config['mysql']['name']\n\t        #  Redis config\n", "        os.environ['REDIS_HOST'] = self.config['redis']['host']\n\t        os.environ['REDIS_PORT'] = self.config['redis']['port']\n\t        os.environ['REDIS_PASSWORD'] = self.config['redis']['pass']\n\t        os.environ['REDIS_DB'] = self.config['redis']['db']\n\t        #  AES Key\n\t        os.environ['AES_KEY'] = self.config['AES_KEY']\n\t        #  Judge server token\n\t        os.environ['JUDGER_TOKEN'] = self.config['JUDGER_TOKEN']\n\t    def add_route(self, route):\n\t        self.app.include_router(route)\n", "    def add_routes(self, routes):\n\t        for route in routes:\n\t            self.add_route(route)\n\t    def add_middleware(self, mw, **kwargs):\n\t        self.app.add_middleware(mw, **kwargs)\n\t    def exclude_check_login(self, path):\n\t        setting = importlib.import_module('OJ.app.settings')\n\t        setting.CHECKLOGIN_EXCLUDE_PATH.append(path)\n\t    def add_model(self, custom_base):\n\t        db = importlib.import_module('OJ.db.database')\n", "        custom_base.metadata.create_all(db.engine)\n\t    def start(self):\n\t        uvicorn.run(self.app, host=self.host, port=self.port)\n\twarnings.simplefilter(\"ignore\", FastAPIPaginationWarning)\n"]}
{"filename": "OJ/db/database.py", "chunked_list": ["from sqlalchemy import create_engine\n\tfrom sqlalchemy.ext.declarative import declarative_base\n\tfrom sqlalchemy.orm import sessionmaker\n\timport importlib\n\t__all__ = ['Base', 'BaseModel']\n\tBase = declarative_base()\n\tSessionLocal = None\n\tengine = None\n\tdef create_connection():\n\t    global engine, SessionLocal\n", "    settings = importlib.import_module('OJ.app.settings')\n\t    engine = create_engine(settings.SQLALCHEMY_DATABASE_URI)\n\t    SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=True)\n\tclass BaseModel(object):\n\t    def to_dict(self, filter_fields: list = []):\n\t        if not filter_fields:\n\t            return {c.name: getattr(self, c.name) for c in self.__table__.columns}\n\t        else:\n\t            return {c: getattr(self, c) for c in filter_fields}\n\tdef get_session():\n", "    db = SessionLocal()\n\t    try:\n\t        yield db\n\t        db.commit()\n\t    finally:\n\t        db.close()\n"]}
{"filename": "OJ/db/__init__.py", "chunked_list": []}
{"filename": "OJ/util/constant.py", "chunked_list": ["class PROBLEM_MODE:\n\t    ACM = 0\n\t    OI = 1\n\tclass PROBLEM_STATUS:\n\t    VISIBLE = 0\n\t    HIDDEN = 1\n\t    CONTEST_HIDDEN = 2\n\t    CONTEST_VISIBLE = 3\n\tclass ContestStatus:\n\t    CONTEST_NOT_START = \"1\"\n", "    CONTEST_ENDED = \"-1\"\n\t    CONTEST_UNDERWAY = \"0\"\n\tclass ContestRuleType:\n\t    ACM = 0\n\t    OI = 1\n\tclass CONTEST_TYPE:\n\t    NORMAL = 0\n\t    PASSWORD = 1\n\t    HIDDEN_VISIBLE = 2\n\t    HIDDEN_INVISIBLE = 3\n", "class JudgeStatus:\n\t    COMPILE_ERROR = -2\n\t    WRONG_ANSWER = -1\n\t    ACCEPTED = 0\n\t    CPU_TIME_LIMIT_EXCEEDED = 1\n\t    REAL_TIME_LIMIT_EXCEEDED = 2\n\t    MEMORY_LIMIT_EXCEEDED = 3\n\t    RUNTIME_ERROR = 4\n\t    SYSTEM_ERROR = 5\n\t    PENDING = 6\n", "    JUDGING = 7\n\t    PARTIALLY_ACCEPTED = 8\n\tclass CacheKey:\n\t    waiting_queue = 'waiting_queue'\n"]}
{"filename": "OJ/util/zip_processor.py", "chunked_list": ["import json\n\timport os\n\timport zipfile\n\tfrom .common import *\n\tclass TestCaseZipProcessor(object):\n\t    def process_zip(self, uploaded_zip_file, spj, dir=\"\"):\n\t        try:\n\t            zip_file = zipfile.ZipFile(uploaded_zip_file, \"r\")\n\t        except zipfile.BadZipFile:\n\t            raise \"Bad zip file\"\n", "        name_list = zip_file.namelist()\n\t        test_case_list = self.filter_name_list(name_list, spj=spj, dir=dir)\n\t        if not test_case_list:\n\t            raise \"Empty file\"\n\t        test_case_id = rand_str()\n\t        test_case_dir = os.path.join('testcases', test_case_id)\n\t        os.mkdir(test_case_dir)\n\t        os.chmod(test_case_dir, 0o710)\n\t        size_cache = {}\n\t        md5_cache = {}\n", "        for item in test_case_list:\n\t            with open(os.path.join(test_case_dir, item), \"wb\") as f:\n\t                content = zip_file.read(f\"{dir}{item}\").replace(b\"\\r\\n\", b\"\\n\")\n\t                size_cache[item] = len(content)\n\t                if item.endswith(\".out\"):\n\t                    md5_cache[item] = hashlib.md5(content.rstrip()).hexdigest()\n\t                f.write(content)\n\t        test_case_info = {\"spj\": spj, \"test_cases\": {}}\n\t        info = []\n\t        if spj:\n", "            for index, item in enumerate(test_case_list):\n\t                data = {\"input_name\": item, \"input_size\": size_cache[item]}\n\t                info.append(data)\n\t                test_case_info[\"test_cases\"][str(index + 1)] = data\n\t        else:\n\t            # [\"1.in\", \"1.out\", \"2.in\", \"2.out\"] => [(\"1.in\", \"1.out\"), (\"2.in\", \"2.out\")]\n\t            test_case_list = zip(*[test_case_list[i::2] for i in range(2)])\n\t            for index, item in enumerate(test_case_list):\n\t                data = {\"stripped_output_md5\": md5_cache[item[1]],\n\t                        \"input_size\": size_cache[item[0]],\n", "                        \"output_size\": size_cache[item[1]],\n\t                        \"input_name\": item[0],\n\t                        \"output_name\": item[1]}\n\t                info.append(data)\n\t                test_case_info[\"test_cases\"][str(index + 1)] = data\n\t        with open(os.path.join(test_case_dir, \"info\"), \"w\", encoding=\"utf-8\") as f:\n\t            f.write(json.dumps(test_case_info, indent=4))\n\t        for item in os.listdir(test_case_dir):\n\t            os.chmod(os.path.join(test_case_dir, item), 0o640)\n\t        return info, test_case_id\n", "    def filter_name_list(self, name_list, spj, dir=\"\"):\n\t        ret = []\n\t        prefix = 1\n\t        if spj:\n\t            while True:\n\t                in_name = f\"{prefix}.in\"\n\t                if f\"{dir}{in_name}\" in name_list:\n\t                    ret.append(in_name)\n\t                    prefix += 1\n\t                    continue\n", "                else:\n\t                    return sorted(ret, key=natural_sort_key)\n\t        else:\n\t            while True:\n\t                in_name = f\"{prefix}.in\"\n\t                out_name = f\"{prefix}.out\"\n\t                if f\"{dir}{in_name}\" in name_list and f\"{dir}{out_name}\" in name_list:\n\t                    ret.append(in_name)\n\t                    ret.append(out_name)\n\t                    prefix += 1\n", "                    continue\n\t                else:\n\t                    return sorted(ret, key=natural_sort_key)\n"]}
{"filename": "OJ/util/cache.py", "chunked_list": ["import redis\n\tfrom OJ.app.settings import *\n\tfrom OJ.util.constant import *\n\tclass Cache(object):\n\t    def __init__(self, queue=CacheKey.waiting_queue, host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD,\n\t                 db=REDIS_DB):\n\t        self.queue_name = queue\n\t        self.client = redis.Redis(host=host, port=port, password=password, db=db)\n\t    def push(self, data):\n\t        self.client.rpush(self.queue_name, data)\n", "    def pop(self):\n\t        return self.client.lpop(self.queue_name)\n\t    def __getitem__(self, ix):\n\t        return self.client.lindex(self.queue_name, ix)\n\t    def __len__(self):\n\t        return self.client.llen(self.queue_name)\n"]}
{"filename": "OJ/util/judge.py", "chunked_list": ["import hashlib\n\timport json\n\timport logging\n\tfrom urllib.parse import urljoin\n\tfrom sqlalchemy.orm import Session\n\timport requests\n\tfrom OJ.app.settings import *\n\tfrom OJ.db.database import engine, SessionLocal\n\tfrom OJ.models import *\n\tfrom OJ.models.JudgeModel import JudgeServer\n", "logger = logging.getLogger(__name__)\n\tclass ChooseJudgeServer:\n\t    def __init__(self, sess=Session(engine)):\n\t        self.server = None\n\t        self.sess = sess\n\t    def __enter__(self) -> [JudgeServer, None]:\n\t        servers = self.sess.query(JudgeServer).filter_by(is_disabled=False).order_by(\"task_number\").all()\n\t        servers = [s for s in servers if s.status == \"normal\"]\n\t        for server in servers:\n\t            if server.task_number <= server.cpu_core * 2:\n", "                server.task_number = server.task_number + 1\n\t                self.sess.commit()\n\t                self.server = server\n\t                return server\n\t        return None\n\t    def __exit__(self, exc_type, exc_val, exc_tb):\n\t        if self.server:\n\t            self.sess.begin()\n\t            server = self.sess.query(JudgeServer).filter_by(id=self.server.id).first()\n\t            server.task_number = server.task_number - 1\n", "            self.sess.commit()\n\t            self.sess.close()\n\tclass DispatcherBase(object):\n\t    def __init__(self):\n\t        self.token = hashlib.sha256(JUDGER_TOKEN.encode()).hexdigest()\n\t    def _request(self, url=JUDGER_SERVER, data=None, language=None):\n\t        kwargs = {\"headers\": {\"X-Judge-Server-Token\": self.token}}\n\t        if data:\n\t            kwargs[\"json\"] = data\n\t        try:\n", "            return requests.post(url, params={\n\t                'language': language\n\t            }, data=data, **kwargs).json()\n\t        except Exception as e:\n\t            logger.exception(e)\n\tclass JudgeDispatcher(DispatcherBase):\n\t    def __init__(self, submission_id, problem_id, session=SessionLocal(), cp_id=-1):\n\t        \"\"\"\n\t        :param submission_id: which submission\n\t        :param problem_id: which problem\n", "        :param db: db_session\n\t        \"\"\"\n\t        super().__init__()\n\t        self.sess = session\n\t        self.cp_id = cp_id\n\t        if cp_id > 0:\n\t            self.cp = self.sess.query(ContestProblem).filter_by(id=cp_id).first()\n\t        else:\n\t            self.cp = None\n\t        self.submission_id = submission_id\n", "        self.submission = self.sess.query(Submission).filter_by(id=self.submission_id).first()\n\t        self.problem_id = problem_id\n\t        self.contest_id = self.submission.contest_id\n\t        self.last_result = self.submission.result if self.submission.info else None\n\t        # submission.statistic_info\n\t        self.statistic_info = {}\n\t        if self.contest_id:\n\t            self.contest = self.submission.contest\n\t        else:\n\t            self.contest = None\n", "        self.problem = self.submission.problem\n\t    def _compute_statistic_info(self, resp_data):\n\t        # 用时和内存占用保存为多个测试点中最长的那个\n\t        self.statistic_info[\"time_cost\"] = max([x[\"cpu_time\"] for x in resp_data])\n\t        self.statistic_info[\"memory_cost\"] = max([x[\"memory\"] for x in resp_data])\n\t        # sum up the score in OI mode\n\t        if self.problem.mode == PROBLEM_MODE.OI:\n\t            score = 0\n\t            try:\n\t                for i in range(len(resp_data)):\n", "                    if resp_data[i][\"result\"] == JudgeStatus.ACCEPTED:\n\t                        resp_data[i][\"score\"] = self.problem.test_case_score[str(i)]\n\t                        score += resp_data[i][\"score\"]\n\t                    else:\n\t                        resp_data[i][\"score\"] = 0\n\t            except IndexError:\n\t                logger.error(f\"Index Error raised when summing up the score in problem {self.problem.id}\")\n\t                self.statistic_info[\"score\"] = 0\n\t                return\n\t            self.statistic_info[\"score\"] = score\n", "    def judge(self):\n\t        language = self.submission.language\n\t        code = self.submission.code_source\n\t        problem = self.sess.query(ProblemInfo).filter_by(id=self.problem_id).first()\n\t        judge_params = {\n\t            'src': code,\n\t            'max_memory': problem.memory_limit * 1024 * 1024,\n\t            'test_case_id': problem.test_id,\n\t            'max_cpu_time': problem.time_limit\n\t        }\n", "        with ChooseJudgeServer() as server:\n\t            # if not server:\n\t            #     print('No Server')\n\t            #     data = {\"submission_id\": self.submission.id, \"problem_id\": self.problem_id}\n\t            #     submission_cache.push(json.dumps(data))\n\t            #     return\n\t            self.submission.result = JudgeStatus.JUDGING\n\t            self.sess.commit()\n\t            resp = self._request(urljoin(JUDGER_SERVER, \"/judge\"), data=judge_params, language=language)\n\t        if not resp:\n", "            self.submission.result = JudgeStatus.SYSTEM_ERROR\n\t            self.sess.commit()\n\t            return\n\t        if resp[\"err\"]:\n\t            self.submission.result = JudgeStatus.COMPILE_ERROR\n\t            self.statistic_info[\"err_info\"] = resp[\"data\"]\n\t            self.statistic_info[\"score\"] = 0\n\t            self.submission.info = resp\n\t        else:\n\t            resp[\"data\"].sort(key=lambda x: int(x[\"test_case\"]))\n", "            self.submission.info = resp\n\t            self._compute_statistic_info(resp[\"data\"])\n\t            error_test_case = list(filter(lambda case: case[\"result\"] != 0, resp[\"data\"]))\n\t            if not error_test_case:\n\t                self.submission.result = JudgeStatus.ACCEPTED\n\t            elif problem.mode == PROBLEM_MODE.ACM or len(error_test_case) == len(resp[\"data\"]):\n\t                self.submission.result = error_test_case[0][\"result\"]\n\t            else:\n\t                self.submission.result = JudgeStatus.PARTIALLY_ACCEPTED\n\t        self.sess.commit()\n", "        ups = self.sess.query(UserProblemStatus).filter_by(\n\t            user_id=self.submission.user_id,\n\t            problem_id=self.problem_id\n\t        ).first()\n\t        problem.submission_count = self.problem.submission_count + 1\n\t        if not ups:\n\t            ups = UserProblemStatus(\n\t                user_id=self.submission.user_id,\n\t                problem_id=self.problem_id,\n\t            )\n", "            exist = False\n\t        else:\n\t            exist = True\n\t        if exist and ups.is_ac:\n\t            return\n\t        if self.problem.mode == PROBLEM_MODE.OI:\n\t            now_score = self.statistic_info['score']\n\t            is_ac = self.problem.total_score == now_score\n\t            ups.is_ac = is_ac\n\t            if is_ac:\n", "                ups.ac_id = self.submission.id\n\t            ups.score = now_score\n\t        else:\n\t            is_ac = self.submission.result == JudgeStatus.ACCEPTED\n\t            if is_ac:\n\t                ups.ac_id = self.submission.id\n\t            ups.is_ac = is_ac\n\t        if not exist:\n\t            self.sess.add(ups)\n\t        self.sess.commit()\n", "        if self.contest_id:\n\t            self.update_contest_problem_status()\n\t        self.sess.expire_all()\n\t        self.sess.close_all()\n\t        self.sess.close()\n\t    def update_contest_problem_status(self):\n\t        if self.contest.rule == ContestRuleType.ACM:\n\t            self._update_acm_contest_rank()\n\t        elif self.contest.rule == ContestRuleType.OI:\n\t            self._update_oi_contest_rank()\n", "        problem = self.sess.query(ProblemInfo).filter_by(id=self.problem.id).first()\n\t        result = str(self.submission.result)\n\t        problem_info = problem.statistic_info\n\t        problem_info[result] = problem_info.get(result, 0) + 1\n\t        submission_count = problem.submission_count\n\t        if not submission_count:\n\t            submission_count = 0\n\t        ac_count = problem.ac_count\n\t        if not ac_count:\n\t            ac_count = 0\n", "        wa_count = problem.wa_count\n\t        if not wa_count:\n\t            wa_count = 0\n\t        if self.submission.result == JudgeStatus.ACCEPTED:\n\t            ac_count = ac_count + 1\n\t        else:\n\t            wa_count = wa_count + 1\n\t        self.sess.query(ProblemInfo).filter_by(id=self.problem.id).update({\n\t            ProblemInfo.ac_count: ac_count,\n\t            ProblemInfo.wa_count: wa_count,\n", "            ProblemInfo.submission_count: submission_count,\n\t            ProblemInfo.statistic_info: problem_info\n\t        })\n\t        self.sess.commit()\n\t    def _update_acm_contest_rank(self):\n\t        with Session(engine) as session:\n\t            session.begin()\n\t            rank = session.query(ACMRank).filter_by(cp_id=self.cp_id)\n\t            user_rank = rank.filter_by(user_id=self.submission.user_id).first()\n\t            ac_rank = rank.filter_by(is_ac=True).all()\n", "            if not user_rank:\n\t                is_ac = self.submission.result == 0\n\t                submission_number = 1\n\t                if is_ac:\n\t                    diff_time = datetime.datetime.now() - self.contest.start_at\n\t                    ac_time = diff_time.days * 24 * 3600 + diff_time.seconds\n\t                    total_time = ac_time\n\t                else:\n\t                    ac_time = None\n\t                    total_time = 20 * 60\n", "                is_first_ac = len(ac_rank) == 0\n\t                new_rank = ACMRank(\n\t                    user_id=self.submission.user_id,\n\t                    cp_id=self.cp_id,\n\t                    submission_id=self.submission.id,\n\t                    submission_number=submission_number,\n\t                    total_time=total_time,\n\t                    is_ac=is_ac,\n\t                    is_first_ac=is_first_ac,\n\t                    ac_time=ac_time\n", "                )\n\t                session.add(new_rank)\n\t            else:\n\t                if user_rank.is_ac:\n\t                    return\n\t                submission_number = user_rank.submission_number\n\t                user_rank.submission_number = submission_number + 1\n\t                is_ac = self.submission.result == 0\n\t                if is_ac:\n\t                    diff_time = datetime.datetime.now() - self.contest.start_at\n", "                    ac_time = diff_time.days * 24 * 3600 + diff_time.seconds\n\t                    total_time = submission_number * 20 * 60 + ac_time\n\t                else:\n\t                    ac_time = None\n\t                    total_time = user_rank.total_time + 20 * 60\n\t                is_first_ac = len(ac_rank) == 0 and is_ac\n\t                user_rank.is_ac = is_ac\n\t                user_rank.total_time = total_time\n\t                user_rank.is_first_ac = is_first_ac\n\t                user_rank.ac_time = ac_time\n", "            session.commit()\n\t    def _update_oi_contest_rank(self):\n\t        with Session(engine) as session:\n\t            session.begin()\n\t            rank = session.query(OIRank).filter_by(\n\t                user_id=self.submission.user_id,\n\t                cp_id=self.cp_id,\n\t            ).first()\n\t            if not rank:\n\t                rank = OIRank(\n", "                    user_id=self.submission.user_id,\n\t                    cp_id=self.cp_id,\n\t                    submission_id=self.submission_id,\n\t                    total_score=self.submission.statistic_info[\"score\"],\n\t                    submission_number=1,\n\t                )\n\t                is_ac = rank.total_score == self.problem.total_score\n\t                rank.is_ac = is_ac\n\t                if is_ac:\n\t                    rank.ac_time = (datetime.datetime.now() - self.contest.start_at).seconds\n", "                session.add(rank)\n\t            else:\n\t                last_score = rank.total_score\n\t                if self.submission.statistic_info[\"score\"] > last_score:\n\t                    last_score = self.submission.statistic_info[\"score\"]\n\t                rank.total_score = last_score\n\t                is_ac = rank.total_score == self.problem.total_score\n\t                rank.is_ac = is_ac\n\t                if is_ac:\n\t                    rank.ac_time = (datetime.datetime.now() - self.contest.start_at).seconds\n", "            session.commit()\n"]}
{"filename": "OJ/util/__init__.py", "chunked_list": ["from .common import *\n\tfrom .zip_processor import *\n\tfrom .cache import Cache\n\tsubmission_cache = Cache()\n"]}
{"filename": "OJ/util/controller.py", "chunked_list": ["from OJ.models.UserModels import UserSession, UserInfo\n\tfrom sqlalchemy.orm import Session\n\tfrom OJ.db.database import engine\n\tdef get_user(token) -> UserInfo:\n\t    with Session(engine) as session:\n\t        session.begin()\n\t        sess = session.query(UserSession).filter(UserSession.token == token).first()\n\t        if not sess:\n\t            return UserInfo()\n\t        user = sess.sess2user\n", "        session.close()\n\t        return user\n"]}
{"filename": "OJ/util/schedule.py", "chunked_list": ["import datetime\n\tfrom pydantic import BaseModel\n\tclass LoginForm(BaseModel):\n\t    username: str\n\t    password: str\n\tclass RegisterForm(BaseModel):\n\t    username: str\n\t    email: str\n\t    password: str\n\t    confirmPassword: str\n", "    code: str\n\tclass ProblemForm(BaseModel):\n\t    cid: str = ''\n\t    id: int = -1\n\t    title: str\n\t    description: str\n\t    inputs: str\n\t    outputs: str\n\t    samples: list\n\t    language: list\n", "    mode: int\n\t    is_spj: bool\n\t    source: str\n\t    time_limit: int\n\t    memory_limit: int\n\t    hints: str\n\t    test_id: str\n\tclass JudgeForm(BaseModel):\n\t    pid: str\n\t    language: str\n", "    source_code: str\n\t    cp_id: str = ''\n\tclass ContestForm(BaseModel):\n\t    id: int = -1\n\t    title: str\n\t    description: str\n\t    start_at: str\n\t    end_at: str\n\t    contest_type: int\n\t    password: str\n", "    only_id: str\n\t    rule: int\n"]}
{"filename": "OJ/util/common.py", "chunked_list": ["import hashlib\n\timport random\n\timport re\n\tdef get_random_string(length=24, allowed_chars='1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'):\n\t    code = ''\n\t    for _ in range(length):\n\t        code += allowed_chars[random.randint(0, len(allowed_chars) - 1)]\n\t    return code\n\tdef natural_sort_key(s, _nsre=re.compile(r\"(\\d+)\")):\n\t    return [int(text) if text.isdigit() else text.lower()\n", "            for text in re.split(_nsre, s)]\n\tdef rand_str(length=32, type=\"lower_hex\"):\n\t    if type == \"str\":\n\t        return get_random_string(length, allowed_chars=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n\t    elif type == \"lower_str\":\n\t        return get_random_string(length, allowed_chars=\"abcdefghijklmnopqrstuvwxyz0123456789\")\n\t    elif type == \"lower_hex\":\n\t        return random.choice(\"123456789abcdef\") + get_random_string(length - 1, allowed_chars=\"0123456789abcdef\")\n\t    else:\n\t        return random.choice(\"123456789\") + get_random_string(length - 1, allowed_chars=\"0123456789\")\n", "def hash256(text: str):\n\t    hash_object = hashlib.sha256()\n\t    hash_object.update(text.encode())\n\t    hash_value = hash_object.hexdigest()\n\t    return hash_value\n\tdef get_file_md5(file_name):\n\t    \"\"\"\n\t    计算文件的md5\n\t    :param file_name:\n\t    :return:\n", "    \"\"\"\n\t    m = hashlib.md5()  # 创建md5对象\n\t    with open(file_name, 'rb') as fobj:\n\t        while True:\n\t            data = fobj.read(4096)\n\t            if not data:\n\t                break\n\t            m.update(data)  # 更新md5对象\n\t    return m.hexdigest()  # 返回md5对象\n\tdef get_str_md5(content):\n", "    \"\"\"\n\t    计算字符串md5\n\t    :param content:\n\t    :return:\n\t    \"\"\"\n\t    m = hashlib.md5(content)  # 创建md5对象\n\t    return m.hexdigest()\n"]}
{"filename": "OJ/util/aes.py", "chunked_list": ["from Crypto.Cipher import AES\n\tfrom Crypto.Util.Padding import pad, unpad\n\timport base64\n\timport os\n\tfrom OJ.app.settings import AES_KEY\n\tclass AESTool:\n\t    @staticmethod\n\t    def encrypt_data(plaintext):\n\t        plaintext = str(plaintext)\n\t        iv = os.urandom(AES.block_size)\n", "        cipher = AES.new(AES_KEY.encode(), AES.MODE_CBC, iv)\n\t        ciphertext = cipher.encrypt(pad(plaintext.encode(), AES.block_size))\n\t        encrypted_data = base64.b64encode(iv + ciphertext).decode()\n\t        encrypted_data = encrypted_data.replace('/', '~')\n\t        return encrypted_data\n\t    @staticmethod\n\t    def decrypt_data(encrypted_data):\n\t        encrypted_data = encrypted_data.replace('~', '/')\n\t        ciphertext = base64.b64decode(encrypted_data)\n\t        iv = ciphertext[:AES.block_size]\n", "        ciphertext = ciphertext[AES.block_size:]\n\t        cipher = AES.new(AES_KEY.encode(), AES.MODE_CBC, iv)\n\t        decrypted_data = unpad(cipher.decrypt(ciphertext), AES.block_size)\n\t        return decrypted_data.decode()\n"]}
{"filename": "OJ/models/UserModels.py", "chunked_list": ["from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, DateTime, JSON\n\tfrom sqlalchemy.orm import relationship\n\timport datetime\n\tfrom OJ.db.database import Base, BaseModel\n\tfrom OJ.util.common import hash256\n\tclass UserInfo(Base, BaseModel):\n\t    __tablename__ = 'UserInfo'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    username = Column(String(200), unique=True, nullable=False)\n\t    email = Column(String(200), unique=True, nullable=False)\n", "    password = Column(String(200))\n\t    is_admin = Column(Boolean, default=False)\n\t    lastlogin = Column(DateTime, default=datetime.datetime.now)\n\t    real_name = Column(String(30), nullable=True)\n\t    accepted_number = Column(Integer, default=0)\n\t    total_score = Column(Integer, default=0)\n\t    submission_number = Column(Integer, default=0)\n\t    def check_password(self, _password):\n\t        return hash256(_password) == self.password\n\t    def make_password(self, _password):\n", "        self.password = hash256(_password)\n\t    def add_accepted_problem_number(self):\n\t        self.accepted_number = self.accepted_number + 1\n\t    def add_submission_number(self):\n\t        self.submission_number = self.submission_number + 1\n\tclass UserSession(Base, BaseModel):\n\t    __tablename__ = 'UserSession'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    user_id = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n\t    token = Column(String(200), nullable=False)\n", "    sess2user = relationship('UserInfo', backref='user2sess')\n\t    time = Column(DateTime,\n\t                  onupdate=datetime.datetime.now,\n\t                  default=datetime.datetime.now\n\t                  )\n\t    expire_time = Column(DateTime,\n\t                         onupdate=datetime.datetime.now() + datetime.timedelta(days=1),\n\t                         default=datetime.datetime.now() + datetime.timedelta(days=1)\n\t                         )\n\t    _user = relationship('UserInfo', backref='session')\n", "    @property\n\t    def user(self):\n\t        return self._user\n"]}
{"filename": "OJ/models/SubmissionModel.py", "chunked_list": ["from sqlalchemy import Column, ForeignKey, Integer, String, DateTime, Text, JSON\n\tfrom sqlalchemy.orm import relationship\n\timport datetime\n\tfrom OJ.db.database import Base, BaseModel\n\tfrom OJ.util.constant import *\n\tclass Submission(Base, BaseModel):\n\t    __tablename__ = 'Submission'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    user_id = Column(Integer, ForeignKey('UserInfo.id'))\n\t    language = Column(String(30))\n", "    contest_id = Column(Integer, ForeignKey('ContestInfo.id'))\n\t    problem_id = Column(Integer, ForeignKey('ProblemInfo.id'))\n\t    create_time = Column(DateTime, default=datetime.datetime.now)\n\t    code_source = Column(String(5000), nullable=False)\n\t    result = Column(Integer, default=JudgeStatus.PENDING)\n\t    info = Column(JSON, default={})  # judger response\n\t    statistic_info = Column(JSON, default={})\n\t    _user = relationship('UserInfo', backref='submissions')\n\t    _contest = relationship('ContestInfo', backref='submissions')\n\t    _problem = relationship('ProblemInfo', backref='submissions')\n", "    @property\n\t    def user(self):\n\t        return self._user\n\t    @property\n\t    def problem(self):\n\t        return self._problem\n\t    @property\n\t    def contest(self):\n\t        return self._contest\n\t    @property\n", "    def is_ac(self):\n\t        return self.result == JudgeStatus.ACCEPTED\n"]}
{"filename": "OJ/models/JudgeModel.py", "chunked_list": ["from sqlalchemy import Boolean, Column, Integer, String, DateTime, Float\n\timport datetime\n\tfrom OJ.db.database import Base, BaseModel\n\tclass JudgeServer(Base, BaseModel):\n\t    __tablename__ = 'JudgerServer'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    ip = Column(String(50), nullable=True)\n\t    port = Column(String(50))\n\t    hostname = Column(String(50))\n\t    judger_version = Column(String(50))\n", "    cpu_core = Column(Integer)\n\t    memory_usage = Column(Float)\n\t    cpu_usage = Column(Float)\n\t    last_heartbeat = Column(DateTime)\n\t    create_time = Column(DateTime, default=datetime.datetime.now)\n\t    task_number = Column(Integer, default=0)\n\t    service_url = Column(String(100))\n\t    is_disabled = Column(Boolean, default=False)\n\t    @property\n\t    def status(self):\n", "        # 增加一秒延时，提高对网络环境的适应性\n\t        # if (datetime.datetime.now() - self.last_heartbeat).seconds > 6:\n\t        #     return \"abnormal\"\n\t        return \"normal\"\n"]}
{"filename": "OJ/models/ContestModel.py", "chunked_list": ["from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, DateTime, BigInteger\n\tfrom sqlalchemy.orm import relationship\n\timport datetime\n\tfrom OJ.util.constant import ContestStatus\n\tfrom OJ.db.database import Base, BaseModel\n\tclass ContestInfo(Base, BaseModel):\n\t    __tablename__ = 'ContestInfo'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    title = Column(String(200), nullable=False)\n\t    description = Column(String(5000), nullable=False)  # Description\n", "    start_at = Column(DateTime, nullable=False)\n\t    end_at = Column(DateTime, nullable=False)\n\t    # 0-->Normal 1-->Password Protected\n\t    # 2-->Hidden but available(visit by invitation URL)\n\t    # 3-->Hidden and unavailable\n\t    contest_type = Column(Integer, default=0)\n\t    password = Column(String(100), default='')  # needed if contest_type==1\n\t    only_id = Column(String(50), default='')  # needed if contest_type==2\n\t    rule = Column(Integer, default=0)  # 0-->ACM 1-->OI\n\t    created_by = Column(Integer, ForeignKey('UserInfo.id'))\n", "    _user = relationship('UserInfo', backref='contests')\n\t    @property\n\t    def status(self):\n\t        if self.start_at > datetime.datetime.now():\n\t            # 没有开始 返回1\n\t            return ContestStatus.CONTEST_NOT_START\n\t        elif self.end_at < datetime.datetime.now():\n\t            # 已经结束 返回-1\n\t            return ContestStatus.CONTEST_ENDED\n\t        else:\n", "            # 正在进行 返回0\n\t            return ContestStatus.CONTEST_UNDERWAY\n\t    def user(self, filed=None):\n\t        if not filed:\n\t            return self._user\n\t        else:\n\t            return getattr(self._user, filed)\n\tclass ContestProblem(Base, BaseModel):\n\t    __tablename__ = 'ContestProblem'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n", "    cid = Column(Integer, ForeignKey('ContestInfo.id'), nullable=False)\n\t    pid = Column(Integer, ForeignKey('ProblemInfo.id'), nullable=False)\n\t    is_visible = Column(Boolean, default=True)\n\t    _contest = relationship('ContestInfo', backref='cps')\n\t    _problem = relationship('ProblemInfo', backref='cps')\n\t    @property\n\t    def contest(self):\n\t        return self._contest\n\t    @property\n\t    def problem(self):\n", "        return self._problem\n\tclass ACMRank(Base, BaseModel):\n\t    __tablename__ = 'ACMRank'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    user_id = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n\t    cp_id = Column(Integer, ForeignKey('ContestProblem.id'), nullable=False)\n\t    submission_id = Column(Integer, ForeignKey('Submission.id'))\n\t    submission_number = Column(Integer, default=0)  # tries\n\t    total_time = Column(BigInteger, default=0)\n\t    is_ac = Column(Boolean, default=False)\n", "    is_first_ac = Column(Boolean, default=False)\n\t    ac_time = Column(Integer, default=0)\n\t    _user = relationship('UserInfo', backref='acm_ranks')\n\t    _cp = relationship('ContestProblem', backref='acm_rank')\n\t    _submission = relationship('Submission')\n\t    def user(self, filed=None):\n\t        if not filed:\n\t            return self._user\n\t        else:\n\t            return getattr(self._user, filed)\n", "    @property\n\t    def cp(self) -> ContestProblem:\n\t        return self._cp\n\t    @property\n\t    def contest(self) -> ContestInfo:\n\t        return self.cp.contest\n\t    @property\n\t    def problem(self):\n\t        return self.cp.problem\n\tclass OIRank(Base, BaseModel):\n", "    __tablename__ = 'oi_rank'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    user_id = Column(Integer, ForeignKey('UserInfo.id'))\n\t    cp_id = Column(Integer, ForeignKey('ContestProblem.id'))\n\t    submission_id = Column(Integer, ForeignKey('Submission.id'))\n\t    submission_number = Column(Integer, default=0)  # tries\n\t    total_score = Column(Integer, default=0)\n\t    is_ac = Column(Boolean, default=False)\n\t    ac_time = Column(Integer, default=0)\n\t    _user = relationship('UserInfo', backref='oi_ranks')\n", "    _cp = relationship('ContestProblem', backref='oi_rank')\n\t    _submission = relationship('Submission')\n\t    @property\n\t    def user(self):\n\t        return self._user\n\t    @property\n\t    def cp(self) -> ContestProblem:\n\t        return self._cp\n\t    @property\n\t    def contest(self) -> ContestInfo:\n", "        return self.cp.contest\n\t    @property\n\t    def problem(self):\n\t        return self.cp.problem\n\t    @property\n\t    def submission(self):\n\t        return self._submission\n\tclass Announcement(Base, BaseModel):\n\t    __tablename__ = 'Announcement'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n", "    title = Column(String(200), nullable=False)\n\t    content = Column(String(5000), nullable=False)\n\t    create_time = Column(DateTime, default=datetime.datetime.now)\n\t    update_time = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now)\n\t    contest = Column(Integer, ForeignKey('ContestInfo.id'), nullable=False)\n\t    author = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n\t    is_visible = Column(Integer, default=True)\n\t    _contest = relationship('ContestInfo', backref='announcements')\n\t    _user = relationship('UserInfo', backref='contest_announcements')\n\t    def user(self, filed=None):\n", "        if not filed:\n\t            return self._user\n\t        else:\n\t            return getattr(self._user, filed)\n"]}
{"filename": "OJ/models/ProblemModels.py", "chunked_list": ["from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, DateTime, Text, JSON\n\tfrom sqlalchemy.orm import relationship\n\timport datetime\n\tfrom OJ.db.database import Base, BaseModel\n\tfrom OJ.util.aes import AESTool\n\tclass ProblemInfo(Base, BaseModel):\n\t    __tablename__ = 'ProblemInfo'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    title = Column(String(200), nullable=False)\n\t    description = Column(Text, nullable=False)  # Description\n", "    inputs = Column(Text, nullable=False)  # Input\n\t    outputs = Column(Text, nullable=False)  # Output\n\t    language = Column(Text, nullable=False)\n\t    # sample input1|||sample output1+#+#sample input2|||sample output2\n\t    samples = Column(Text, nullable=False, default='')\n\t    hints = Column(Text, default='')\n\t    source = Column(Text, default='')\n\t    is_spj = Column(Boolean, default=False)  # normal judge/special judge\n\t    test_id = Column(String(50))\n\t    submission_count = Column(Integer, default=0)\n", "    ac_count = Column(Integer, default=0)\n\t    wa_count = Column(Integer, default=0)\n\t    time_limit = Column(Integer, default=1000)  # ms\n\t    memory_limit = Column(Integer, default=256)  # MB\n\t    mode = Column(Integer, default=0)  # 0-->ACM 1-->OI\n\t    # 0-->show 1-->hide\n\t    # 2-->contest mode but hide\n\t    # 3-->contest mode but show\n\t    status = Column(Integer, default=0)\n\t    test_case_score = Column(JSON, default={})\n", "    total_score = Column(Integer, default=0)\n\t    create_time = Column(DateTime, default=datetime.datetime.now)\n\t    created_by = Column(Integer, ForeignKey('UserInfo.id'))\n\t    statistic_info = Column(JSON, default={})\n\t    _user = relationship('UserInfo', backref='problems')\n\t    @property\n\t    def pid(self):\n\t        return AESTool.encrypt_data(self.id)\n\t    def user(self, filed=None):\n\t        if not filed:\n", "            return self._user\n\t        else:\n\t            return getattr(self._user, filed)\n\tclass UserProblemStatus(Base, BaseModel):\n\t    __tablename__ = 'UserProblemStatus'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    user_id = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n\t    problem_id = Column(Integer, ForeignKey('ProblemInfo.id'), nullable=False)\n\t    ac_id = Column(Integer, ForeignKey('Submission.id'))  # first ac\n\t    is_ac = Column(Boolean, default=False)\n", "    score = Column(Integer, default=0)  # if problem.mode == OI\n\t    _user = relationship('UserInfo', backref='problems_status')\n\t    _submission = relationship('Submission')\n\t    _problem = relationship('ProblemInfo', backref='users_status')\n\t    @property\n\t    def user(self):\n\t        return self._user\n\t    @property\n\t    def submission(self):\n\t        return self._submission\n", "    @property\n\t    def problem(self):\n\t        return self._problem\n"]}
{"filename": "OJ/models/__init__.py", "chunked_list": ["from .UserModels import *\n\tfrom .ContestModel import *\n\tfrom .ProblemModels import *\n\tfrom .SubmissionModel import *\n\tfrom .JudgeModel import JudgeServer\n\tfrom .SystemModel import SysAnnouncement\n"]}
{"filename": "OJ/models/SystemModel.py", "chunked_list": ["from sqlalchemy import Column, ForeignKey, Integer, String, DateTime, Text, JSON\n\timport datetime\n\tfrom OJ.db.database import Base, BaseModel\n\tclass SysAnnouncement(Base, BaseModel):\n\t    __tablename__ = 'SysAnnouncement'\n\t    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\t    title = Column(String(200), nullable=False)\n\t    content = Column(Text, nullable=False)\n\t    create_time = Column(DateTime, default=datetime.datetime.now)\n\t    update_time = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now)\n", "    author = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n\t    is_visible = Column(Integer, default=True)\n"]}
{"filename": "OJ/views/contests.py", "chunked_list": ["from fastapi import APIRouter, Depends, Header, status, Response\n\tfrom sqlalchemy.orm import Session\n\tfrom starlette.responses import JSONResponse\n\tfrom OJ.db.database import get_session\n\tfrom OJ.util.constant import CONTEST_TYPE, ContestRuleType\n\tfrom OJ.models import ContestInfo, Announcement, ContestProblem\n\tfrom OJ.util.aes import AESTool\n\tfrom fastapi_pagination import Page, paginate, Params\n\trouter = APIRouter(\n\t    prefix='/api/contest',\n", "    tags=['contest']\n\t)\n\t@router.get('/recent')\n\tasync def get_recent(db: Session = Depends(get_session)):\n\t    contests = db.query(ContestInfo).filter_by(contest_type=CONTEST_TYPE.NORMAL).order_by('start_at').limit(5).all()\n\t    result = []\n\t    for it in contests:\n\t        dic = it.to_dict()\n\t        dic['status'] = it.status\n\t        del dic['contest_type']\n", "        del dic['created_by']\n\t        del dic['password']\n\t        del dic['only_id']\n\t        dic['admin'] = it.user('username')\n\t        dic['rule'] = 'ACM' if dic['rule'] == 0 else 'OI'\n\t        result.append(dic)\n\t    return result\n\t@router.get('/all')\n\tasync def get_all(db: Session = Depends(get_session), params: Params = Depends()):\n\t    contests = db.query(ContestInfo).filter_by(contest_type=CONTEST_TYPE.NORMAL).all()\n", "    result = []\n\t    for it in contests:\n\t        dic = it.to_dict([\n\t            'title', 'description', 'start_at', 'end_at', 'rule', 'status'\n\t        ])\n\t        dic['admin'] = it.user('username')\n\t        dic['rule'] = 'ACM' if dic['rule'] == 0 else 'OI'\n\t        result.append(dic)\n\t    return paginate(result, params)\n\t@router.get('/detail')\n", "async def get_detail(contest_id, db: Session = Depends(get_session)):\n\t    def get_problem_info(cp: ContestProblem):\n\t        pro = cp.problem\n\t        dic = pro.to_dict(['pid', 'title', 'submission_count', 'ac_count', ])\n\t        dic['ac_rate'] = 0 if pro.ac_count == 0 else (pro.ac_count / pro.submission_count) * 100\n\t        dic['cp_id'] = AESTool.encrypt_data(cp.id)\n\t        return dic\n\t    contest = db.query(ContestInfo).filter_by(id=contest_id).first()\n\t    if not contest:\n\t        return JSONResponse({\n", "            'msg': '比赛不存在，异常访问'\n\t        }, status_code=status.HTTP_404_NOT_FOUND)\n\t    response = contest.to_dict([\n\t        'id', 'title', 'description', 'start_at', 'end_at', 'rule', 'status'\n\t    ])\n\t    cps = db.query(ContestProblem).filter_by(cid=contest.id).all()\n\t    problems = [get_problem_info(it) for it in cps]\n\t    response['problems'] = problems\n\t    return response\n\t@router.get('/announcements')\n", "async def get_announcements(contest_id, db: Session = Depends(get_session)):\n\t    announcements = db.query(Announcement).filter_by(contest=contest_id).order_by('update_time').all()\n\t    response = []\n\t    for it in announcements:\n\t        dic = it.to_dict([\n\t            'id', 'title', 'content', 'create_time', 'update_time'\n\t        ])\n\t        dic['author'] = it.user('username')\n\t        response.append(dic)\n\t    return response\n", "@router.get('/rank')\n\tasync def get_rank(cid, db: Session = Depends(get_session), params: Params = Depends()):\n\t    contest = db.query(ContestInfo).filter_by(id=cid).first()\n\t    if not contest:\n\t        return JSONResponse({\n\t            'msg': '比赛不存在，异常访问'\n\t        }, status_code=status.HTTP_404_NOT_FOUND)\n\t    cps = db.query(ContestProblem).filter_by(cid=cid).all()\n\t    problems = [cp.problem for cp in cps]\n\t    pids = {it.id: ix for ix, it in enumerate(problems)}\n", "    usernames = []\n\t    u_result = {}\n\t    u_rank = {}\n\t    cps = db.query(ContestProblem).filter_by(cid=cid).all()\n\t    if contest.rule == ContestRuleType.ACM:\n\t        for cp in cps:\n\t            for rank in cp.acm_rank:\n\t                username = rank.user('username')\n\t                usernames.append(username)\n\t                u_rank[username] = u_rank.get(username, [])\n", "                u_rank[username].append(rank)\n\t                u_result[username] = u_result.get(username, {})\n\t                u_result[username]['submissions'] = u_result[username].get('submissions',\n\t                                                                           [{} for _ in range(len(problems))])\n\t                u_result[username]['problems'] = u_result[username].get('problems', [0 for _ in range(len(problems))])\n\t                u_result[username]['problems'][pids[cp.pid]] = 1\n\t                u_result[username]['submission_count'] = u_result[username].get('submission_count', 0) + \\\n\t                                                         rank.submission_number\n\t                u_result[username]['ac_count'] = u_result[username].get('ac_count', 0) + rank.is_ac\n\t                u_result[username]['total_time'] = u_result[username].get('total_time', 0)\n", "                if rank.is_ac:\n\t                    u_result[username]['total_time'] += rank.total_time\n\t                    u_result[username]['is_ac'] = True\n\t                else:\n\t                    u_result[username]['is_ac'] = False\n\t                u_result[username]['submissions'][pids[cp.pid]]['total_time'] = rank.total_time\n\t                u_result[username]['submissions'][pids[cp.pid]]['is_ac'] = rank.is_ac\n\t                u_result[username]['submissions'][pids[cp.pid]]['is_first_ac'] = rank.is_first_ac\n\t                u_result[username]['submissions'][pids[cp.pid]]['submission_number'] = rank.submission_number\n\t    response = []\n", "    for key, val in u_result.items():\n\t        dic = {'username': key}\n\t        dic.update(val)\n\t        response.append(dic)\n\t    response.sort(key=lambda x: (-x['ac_count'], x['total_time'], x['username']))\n\t    return {'ranks': paginate(response, params), 'length': len(cps)}\n"]}
{"filename": "OJ/views/submission.py", "chunked_list": ["from threading import Thread\n\tfrom fastapi import APIRouter, Depends, Header, status, Response\n\tfrom fastapi_pagination import Params, paginate\n\tfrom sqlalchemy.orm import Session\n\tfrom OJ.util.aes import AESTool\n\tfrom OJ.db.database import get_session, SessionLocal\n\tfrom OJ.util.controller import get_user\n\tfrom OJ.util.judge import JudgeDispatcher\n\tfrom OJ.util.constant import JudgeStatus\n\tfrom OJ.util.schedule import *\n", "from OJ.models import Submission, ProblemInfo, ContestProblem\n\tfrom typing import Union\n\trouter = APIRouter(\n\t    prefix='/api/submission',\n\t    tags=['submissions']\n\t)\n\t@router.post(\"/judge\")\n\tasync def judge(form: JudgeForm, x_token: Union[str, None] = Header(None), db: Session = Depends(get_session)):\n\t    pid = AESTool.decrypt_data(form.pid)\n\t    problem = db.query(ProblemInfo).filter_by(id=pid).first()\n", "    if not problem:\n\t        return Response(status_code=status.HTTP_404_NOT_FOUND)\n\t    language = form.language\n\t    user = get_user(x_token)\n\t    user_id = user.id\n\t    code_source = form.source_code\n\t    if form.cp_id != '':\n\t        cp = db.query(ContestProblem).filter_by(id=AESTool.decrypt_data(form.cp_id), pid=pid).first()\n\t        if cp:\n\t            cid = cp.cid\n", "        else:\n\t            cid = None\n\t    else:\n\t        cp = None\n\t        cid = None\n\t    submission = Submission(language=language,\n\t                            user_id=user_id,\n\t                            code_source=code_source,\n\t                            problem_id=pid,\n\t                            contest_id=cid)\n", "    db.add(submission)\n\t    db.commit()\n\t    if cp:\n\t        thread = Thread(target=SubmissionJudge, args=(submission.id, pid, cp.id))\n\t    else:\n\t        thread = Thread(target=SubmissionJudge, args=(submission.id, pid))\n\t    thread.start()\n\t    # JudgeDispatcher(submission.id, problem.id, db).judge()\n\t    return submission.id\n\tdef SubmissionJudge(sid, pid, cp_id=-1):\n", "    sess = SessionLocal()\n\t    dis = JudgeDispatcher(sid, pid, sess, cp_id)\n\t    dis.judge()\n\t@router.get(\"/status\")\n\tasync def submission_status(submission_id: int,\n\t                            db: Session = Depends(get_session)):\n\t    submission = db.query(Submission).filter_by(id=submission_id).first()\n\t    if not submission:\n\t        return Response(status_code=status.HTTP_404_NOT_FOUND)\n\t    if submission.result in (JudgeStatus.PENDING, JudgeStatus.JUDGING):\n", "        return {\n\t            'result': submission.result\n\t        }\n\t    else:\n\t        return submission.to_dict()\n\t@router.get(\"/problem\")\n\tasync def submission_problem(pid: str, db: Session = Depends(get_session), params: Params = Depends()):\n\t    pid = AESTool.decrypt_data(pid)\n\t    submissions = db.query(Submission).filter_by(problem_id=pid).all()\n\t    response = []\n", "    for sub in submissions:\n\t        response.append(sub.to_dict(['id', 'create_time', 'result', 'language']))\n\t    return paginate(response, params)\n"]}
{"filename": "OJ/views/__init__.py", "chunked_list": ["from .problems import router as problems_router\n\tfrom .user import router as user_router\n\tfrom .submission import router as sub_router\n\tfrom .contests import router as con_router\n\tfrom .admin import *\n\troutes = [\n\t    problems_router,\n\t    user_router,\n\t    sub_router,\n\t    con_router,\n", "    admin_problem_router,\n\t    admin_sys_router,\n\t    admin_contest_router\n\t]\n"]}
{"filename": "OJ/views/user.py", "chunked_list": ["from fastapi import APIRouter, Depends\n\tfrom fastapi.responses import JSONResponse\n\tfrom sqlalchemy.orm import Session\n\tfrom sqlalchemy import or_\n\tfrom OJ.models.UserModels import UserInfo, UserSession\n\tfrom OJ.util.schedule import *\n\tfrom OJ.db.database import get_session\n\tfrom OJ.util import get_random_string\n\trouter = APIRouter(\n\t    prefix='/api/user',\n", "    tags=['user']\n\t)\n\t@router.post(\"/login\")\n\tasync def login(form: LoginForm, db: Session = Depends(get_session)):\n\t    user = db.query(UserInfo).filter_by(username=form.username).first()\n\t    if not user or not user.check_password(form.password):\n\t        return JSONResponse({\n\t            'status': 404,\n\t            'msg': 'Invalid Username or Password!'\n\t        }, status_code=404)\n", "    token = get_random_string()\n\t    sess = db.query(UserSession).filter_by(user_id=user.id)\n\t    if sess.first():\n\t        sess.update({'token': token})\n\t        db.commit()\n\t    else:\n\t        sess = UserSession(user_id=user.id, token=token)\n\t        db.add(sess)\n\t        db.commit()\n\t    return JSONResponse({\n", "        'msg': 'Login Successfully!',\n\t        'token': token,\n\t    })\n\t@router.post(\"/register\")\n\tasync def register(form: RegisterForm, db: Session = Depends(get_session)):\n\t    if form.password != form.confirmPassword:\n\t        return JSONResponse({\n\t            'status': 404,\n\t            'msg': '两次密码不一致'\n\t        }, status_code=404)\n", "    user = UserInfo(username=form.username, email=form.email)\n\t    user.make_password(form.password)\n\t    u = db.query(UserInfo).filter(or_(UserInfo.username == form.username, UserInfo.email == form.email)).first()\n\t    if u:\n\t        return JSONResponse({\n\t            'status': 404,\n\t            'msg': '用户已存在'\n\t        }, status_code=404)\n\t    try:\n\t        db.add(user)\n", "        db.commit()\n\t    except Exception as e:\n\t        return JSONResponse({\n\t            'msg': e\n\t        }, 404)\n\t    return JSONResponse({\n\t        'msg': '注册成功'\n\t    })\n"]}
{"filename": "OJ/views/problems.py", "chunked_list": ["from typing import Union\n\tfrom fastapi import UploadFile, File, APIRouter, Depends, Header\n\tfrom fastapi.responses import JSONResponse\n\timport os\n\tfrom sqlalchemy import desc\n\tfrom sqlalchemy.orm import Session\n\tfrom OJ.app.settings import PROJECT_PATH\n\tfrom OJ.db.database import get_session\n\tfrom OJ.util.aes import AESTool\n\tfrom OJ.util.common import rand_str\n", "from OJ.util.controller import get_user\n\tfrom OJ.util.zip_processor import TestCaseZipProcessor\n\tfrom OJ.util.schedule import *\n\tfrom OJ.models import ProblemInfo, UserProblemStatus, ContestProblem\n\tfrom fastapi_pagination import Params, paginate\n\trouter = APIRouter(\n\t    prefix='/api/problem',\n\t    tags=['problems']\n\t)\n\t@router.get(\"/hot\")\n", "async def problem_hot(db: Session = Depends(get_session)):\n\t    problems = db.query(ProblemInfo).filter_by(status=0).order_by(desc(ProblemInfo.submission_count)).limit(5).all()\n\t    result = []\n\t    for pro in problems:\n\t        result.append({\n\t            'id': pro.id,\n\t            'title': pro.title,\n\t            'submission': pro.submission_count,\n\t            'ac_count': pro.ac_count,\n\t            'ac_rate': 0 if pro.ac_count == 0 else (pro.ac_count / pro.submission_count) * 100\n", "        })\n\t    return result\n\t@router.get(\"/all\")\n\tasync def problem_all(db: Session = Depends(get_session), params: Params = Depends()):\n\t    problems = db.query(ProblemInfo).filter_by(status=0).all()\n\t    result = []\n\t    for pro in problems:\n\t        result.append({\n\t            'id': AESTool.encrypt_data(pro.id),\n\t            'title': pro.title,\n", "            'submission': pro.submission_count,\n\t            'ac_count': pro.ac_count,\n\t            'ac_rate': 0 if pro.ac_count == 0 else (pro.ac_count / pro.submission_count) * 100\n\t        })\n\t    return paginate(result, params)\n\t@router.get(\"/detail\")\n\tasync def problem_detail(\n\t        pid, cid: int = -1,\n\t        x_token: Union[str, None] = Header(None),\n\t        db: Session = Depends(get_session)\n", "):\n\t    problem_id = AESTool.decrypt_data(pid)\n\t    if cid > 0:\n\t        cp = db.query(ContestProblem).filter_by(pid=problem_id, cid=cid).first()\n\t        if not cp or not cp.is_visible:\n\t            return JSONResponse({\n\t                'msg': '问题不存在，异常访问'\n\t            }, status_code=404)\n\t        problem = cp.problem\n\t    else:\n", "        cp = None\n\t        problem = db.query(ProblemInfo).filter_by(id=problem_id).first()\n\t        if not problem or problem.status > 0:\n\t            return JSONResponse({\n\t                'msg': '问题不存在，异常访问'\n\t            }, status_code=404)\n\t    user = get_user(x_token)\n\t    response = problem.to_dict()\n\t    if response['samples']:\n\t        response['samples'] = [(it.split('|||')[0], it.split('|||')[1]) for it in response['samples'].split('+#+#')]\n", "    else:\n\t        response['samples'] = []\n\t    response['language'] = response['language'].split('###')\n\t    response['created_by'] = problem.user('username')\n\t    status = db.query(UserProblemStatus).filter_by(user_id=user.id, problem_id=problem_id).first()\n\t    if status:\n\t        status = status.to_dict(['is_ac', 'score', 'submission'])\n\t        if status['submission']:\n\t            status['submission'] = status['submission'].to_dict(['result'])\n\t    if cp:\n", "        response['cp_id'] = AESTool.encrypt_data(cp.id)\n\t    response['status'] = status\n\t    return response\n\t@router.post(\"/create\")\n\tasync def problem_create(form: ProblemForm, db: Session = Depends(get_session)):\n\t    problem = ProblemInfo(\n\t        title=form.title,\n\t        description=form.description,\n\t        inputs=form.inputs,\n\t        outputs=form.outputs,\n", "        samples=form.samples,\n\t        hints=form.hints,\n\t        source=form.source,\n\t        is_spj=form.is_spj,\n\t        test_id=form.test_id,\n\t        time_limit=form.time_limit,\n\t        memory_limit=form.memory_limit,\n\t        io_mode=form.io_mode,\n\t    )\n\t    db.add(problem)\n", "    db.commit()\n\t    return problem.to_dict()\n\t@router.post(\"/upload/testcases\")\n\tasync def problem_upload_testcases(file: UploadFile = File(...), spj=False):\n\t    tmp_file = f\"tmp/{rand_str()}.zip\"\n\t    with open(tmp_file, \"wb\") as f:\n\t        content = await file.read()\n\t        f.write(content)\n\t    zip_process = TestCaseZipProcessor()\n\t    spj = spj == 'true'\n", "    info, test_case_id = zip_process.process_zip(tmp_file, spj=spj)\n\t    os.remove(tmp_file)\n\t    return {\"id\": test_case_id, \"info\": info, \"spj\": spj}\n\t@router.get(\"/testcase\")\n\tasync def problem_get_testcase(testcase_id):\n\t    path = os.path.join(PROJECT_PATH, 'testcases', testcase_id)\n\t    files = os.listdir(path)\n\t    inputs = [it for it in files if it.endswith('.in')]\n\t    outputs = [it for it in files if it.endswith('.out')]\n\t    count = len(files)\n", "    return {\n\t        'count': count,\n\t        'inputs': inputs,\n\t        'outputs': outputs\n\t    }\n"]}
{"filename": "OJ/views/admin/contest.py", "chunked_list": ["from typing import Union\n\tfrom fastapi import APIRouter, Depends, Header, status\n\tfrom fastapi.responses import JSONResponse, Response\n\tfrom sqlalchemy.orm import Session\n\tfrom OJ.db.database import get_session\n\tfrom OJ.util.aes import AESTool\n\tfrom OJ.util.common import hash256\n\tfrom OJ.util.controller import get_user\n\tfrom OJ.util.schedule import *\n\tfrom OJ.models import ContestInfo, ContestProblem\n", "from fastapi_pagination import Page, Params, paginate\n\trouter = APIRouter(\n\t    prefix='/api/admin/contest',\n\t    tags=['admin contest']\n\t)\n\t@router.get(\"/all\")\n\tasync def contest_all(db: Session = Depends(get_session), params: Params = Depends()):\n\t    contests = db.query(ContestInfo).all()\n\t    result = []\n\t    for con in contests:\n", "        result.append({\n\t            'id': con.id,\n\t            'title': con.title,\n\t            'author': con.user('username'),\n\t            'start_at': con.start_at,\n\t            'end_at': con.end_at,\n\t            'status': con.status\n\t        })\n\t    return paginate(result, params)\n\t@router.get('/detail')\n", "async def get_detail(cid, db: Session = Depends(get_session)):\n\t    cid = AESTool.decrypt_data(cid)\n\t    contest = db.query(ContestInfo).filter_by(id=cid).first()\n\t    if not contest:\n\t        return JSONResponse({\n\t            'msg': '比赛不存在，异常访问'\n\t        }, status_code=status.HTTP_404_NOT_FOUND)\n\t    response = contest.to_dict([\n\t        'id', 'title', 'description', 'start_at', 'end_at', 'rule', 'status', 'contest_type', 'only_id'\n\t    ])\n", "    return response\n\t@router.post(\"/add\")\n\tasync def contest_add(form: ContestForm, x_token: Union[str, None] = Header(None), db: Session = Depends(get_session)):\n\t    user = get_user(x_token)\n\t    contest = ContestInfo()\n\t    contest.title = form.title\n\t    contest.description = form.description\n\t    datetime_format = \"%Y-%m-%dT%H:%M:%S.%fZ\"\n\t    contest.start_at = datetime.datetime.strptime(form.start_at, datetime_format)\n\t    contest.end_at = datetime.datetime.strptime(form.end_at, datetime_format)\n", "    contest.contest_type = form.contest_type\n\t    contest.password = hash256(form.password)\n\t    contest.rule = form.rule\n\t    contest.created_by = user.id\n\t    db.add(contest)\n\t    db.commit()\n\t    contest.only_id = AESTool.encrypt_data(str(contest.id))\n\t    db.commit()\n\t@router.post(\"/update\")\n\tasync def contest_update(form: ContestForm, x_token: Union[str, None] = Header(None),\n", "                         db: Session = Depends(get_session)):\n\t    user = get_user(x_token)\n\t    contest = db.query(ContestInfo).filter_by(id=form.id).first()\n\t    if not contest:\n\t        return Response('Invalid Contest ID', status_code=status.HTTP_404_NOT_FOUND)\n\t    db.commit()\n\t    contest.only_id = AESTool.encrypt_data(str(contest.id))\n\t    db.commit()\n\t@router.get(\"/problem\")\n\tasync def contest_problem_all(cid, db: Session = Depends(get_session), params: Params = Depends()):\n", "    cid = AESTool.decrypt_data(cid)\n\t    cps = db.query(ContestProblem).filter_by(cid=cid).all()\n\t    problems = []\n\t    for cp in cps:\n\t        pro = cp.problem\n\t        problems.append({\n\t            'id': AESTool.encrypt_data(str(pro.id)),\n\t            'title': pro.title,\n\t            'author': pro.user('username'),\n\t            'create_time': pro.create_time,\n", "            'status': pro.status == 0\n\t        })\n\t    return problems\n"]}
{"filename": "OJ/views/admin/__init__.py", "chunked_list": ["from .problem import router as admin_problem_router\n\tfrom .sys import router as admin_sys_router\n\tfrom .contest import router as admin_contest_router\n"]}
{"filename": "OJ/views/admin/sys.py", "chunked_list": ["import os\n\timport hashlib\n\timport json\n\timport zipfile\n\tfrom fastapi import UploadFile, File, APIRouter, Depends, status\n\tfrom fastapi.responses import Response\n\tfrom sqlalchemy.orm import Session\n\tfrom OJ.db.database import get_session\n\tfrom OJ.util.common import rand_str\n\tfrom OJ.models.ProblemModels import ProblemInfo\n", "router = APIRouter(\n\t    prefix='/api/admin/sys',\n\t    tags=['system control']\n\t)\n\t@router.post('/qdu/import')\n\tasync def qdu_export(file: UploadFile = File(...), db: Session = Depends(get_session)):\n\t    tmp_file = f\"tmp/{rand_str()}.zip\"\n\t    with open(tmp_file, \"wb\") as f:\n\t        content = await file.read()\n\t        f.write(content)\n", "    try:\n\t        zip_file = zipfile.ZipFile(tmp_file, \"r\")\n\t    except zipfile.BadZipFile as e:\n\t        print(e)\n\t        return Response(\"Bad zip file\", status.HTTP_500_INTERNAL_SERVER_ERROR)\n\t    files = zip_file.namelist()\n\t    dic = {}\n\t    for f in files:\n\t        if len(f.strip('/').split('/')) == 1:\n\t            continue\n", "        tid = f.split('/')[0]\n\t        dic[tid] = dic.get(tid, {})\n\t        if '.json' in f:\n\t            dic[tid]['problem'] = f\n\t        if len(f.strip('/').split('/')) == 2:\n\t            continue\n\t        else:\n\t            dic[tid]['testcase'] = dic[tid].get('testcase', [])\n\t            dic[tid]['testcase'].append(f)\n\t    null = None\n", "    problems = []\n\t    for tid, val in dic.items():\n\t        problem_info = eval(zip_file.read(val['problem']).decode())\n\t        title = problem_info['title']\n\t        description = problem_info['description']['value']\n\t        time_limit = problem_info['time_limit']\n\t        memory_limit = problem_info['memory_limit']\n\t        samples = problem_info['samples']\n\t        is_spj = problem_info['spj'] is not None\n\t        mode = 0 if problem_info['rule_type'] == 'ACM' else 1\n", "        try:\n\t            test_case_score = {str(ix): it['score'] for ix, it in enumerate(problem_info['test_case_score'])}\n\t            total_score = sum([it['score'] for it in problem_info['test_case_score']])\n\t        except:\n\t            test_case_score = {}\n\t            total_score = 0\n\t        source = problem_info['source']\n\t        inputs = problem_info['input_description']['value']\n\t        outputs = problem_info['output_description']['value']\n\t        hint = problem_info['hint']['value']\n", "        samples = '+#+#'.join([it['input'] + '|||' + it['output'] for it in samples])\n\t        problem = ProblemInfo(\n\t            title=title,\n\t            language='cxx###c###py3###php',\n\t            description=description,\n\t            inputs=inputs,\n\t            outputs=outputs,\n\t            time_limit=time_limit,\n\t            memory_limit=memory_limit,\n\t            samples=samples,\n", "            is_spj=is_spj,\n\t            mode=mode,\n\t            test_case_score=test_case_score,\n\t            total_score=total_score,\n\t            source=source,\n\t            hints=hint,\n\t            created_by=1,\n\t        )\n\t        test_case_id = rand_str()\n\t        test_case_dir = os.path.join('testcases', test_case_id)\n", "        os.mkdir(test_case_dir)\n\t        os.chmod(test_case_dir, 0o710)\n\t        size_cache = {}\n\t        md5_cache = {}\n\t        test_case_list = val['testcase']\n\t        for item in test_case_list:\n\t            file_name = item.split('/')[-1]\n\t            print(test_case_dir, item)\n\t            with open(os.path.join(test_case_dir, file_name), \"wb\") as f:\n\t                content = zip_file.read(f\"{item}\").replace(b\"\\r\\n\", b\"\\n\")\n", "                size_cache[file_name] = len(content)\n\t                if file_name.endswith(\".out\"):\n\t                    md5_cache[file_name] = hashlib.md5(content.rstrip()).hexdigest()\n\t                f.write(content)\n\t        test_case_info = {\"spj\": is_spj, \"test_cases\": {}}\n\t        info = []\n\t        test_case_list = [it.split('/')[-1] for it in test_case_list]\n\t        if is_spj:\n\t            for index, item in enumerate(test_case_list):\n\t                data = {\"input_name\": item, \"input_size\": size_cache[item]}\n", "                info.append(data)\n\t                test_case_info[\"test_cases\"][str(index + 1)] = data\n\t        else:\n\t            # [\"1.in\", \"1.out\", \"2.in\", \"2.out\"] => [(\"1.in\", \"1.out\"), (\"2.in\", \"2.out\")]\n\t            test_case_list = zip(*[test_case_list[i::2] for i in range(2)])\n\t            for index, item in enumerate(test_case_list):\n\t                data = {\"stripped_output_md5\": md5_cache[item[1]],\n\t                        \"input_size\": size_cache[item[0]],\n\t                        \"output_size\": size_cache[item[1]],\n\t                        \"input_name\": item[0],\n", "                        \"output_name\": item[1]}\n\t                info.append(data)\n\t                test_case_info[\"test_cases\"][str(index + 1)] = data\n\t        with open(os.path.join(test_case_dir, \"info\"), \"w\", encoding=\"utf-8\") as f:\n\t            f.write(json.dumps(test_case_info, indent=4))\n\t        for item in os.listdir(test_case_dir):\n\t            os.chmod(os.path.join(test_case_dir, item), 0o640)\n\t        problem.test_id = test_case_id\n\t        db.add(problem)\n\t    db.commit()\n", "    return True\n"]}
{"filename": "OJ/views/admin/problem.py", "chunked_list": ["import os\n\tfrom typing import Union\n\tfrom fastapi import UploadFile, File, APIRouter, Depends, Header, status\n\tfrom fastapi.responses import Response\n\tfrom sqlalchemy.orm import Session\n\tfrom sqlalchemy import or_, and_\n\tfrom OJ.db.database import get_session\n\tfrom OJ.util.aes import AESTool\n\tfrom OJ.util.common import rand_str, hash256\n\tfrom OJ.util.controller import get_user\n", "from OJ.util.zip_processor import TestCaseZipProcessor\n\tfrom OJ.util.schedule import *\n\tfrom OJ.models import ProblemInfo, ContestProblem\n\tfrom fastapi_pagination import Params, paginate\n\trouter = APIRouter(\n\t    prefix='/api/admin/problem',\n\t    tags=['admin problems']\n\t)\n\t@router.delete('')\n\tasync def delete_problem(pid: str, db: Session = Depends(get_session)):\n", "    pid = AESTool.decrypt_data(pid)\n\t    pid = AESTool.decrypt_data(pid)\n\t    pro = db.query(ProblemInfo).filter_by(id=pid).first()\n\t    if not pro:\n\t        return Response('Problem not found', status_code=status.HTTP_404_NOT_FOUND)\n\t    db.delete(pro)\n\t    db.commit()\n\t    return True\n\t@router.get(\"/all\")\n\tasync def problem_all(db: Session = Depends(get_session), params: Params = Depends()):\n", "    problems = db.query(ProblemInfo).filter(or_(ProblemInfo.status == 0, ProblemInfo.status == 1)).all()\n\t    result = []\n\t    for pro in problems:\n\t        result.append({\n\t            'id': pro.id,\n\t            'title': pro.title,\n\t            'author': pro.user('username'),\n\t            'create_time': pro.create_time,\n\t            'status': pro.status == 0\n\t        })\n", "    return paginate(result, params)\n\t@router.post(\"/upload/testcases\")\n\tasync def problem_upload_testcases(file: UploadFile = File(...), spj=False):\n\t    tmp_file = f\"tmp/{rand_str()}.zip\"\n\t    with open(tmp_file, \"wb\") as f:\n\t        content = await file.read()\n\t        f.write(content)\n\t    zip_process = TestCaseZipProcessor()\n\t    spj = spj == 'true'\n\t    info, test_case_id = zip_process.process_zip(tmp_file, spj=spj)\n", "    os.remove(tmp_file)\n\t    return {\"id\": test_case_id, \"info\": info, \"spj\": spj}\n\t@router.post(\"/update\")\n\tasync def problem_update(problem: ProblemForm, db: Session = Depends(get_session)):\n\t    pro = db.query(ProblemInfo).filter_by(id=problem.id).first()\n\t    if not pro:\n\t        return Response('Problem not found', status_code=status.HTTP_404_NOT_FOUND)\n\t    pro.title = problem.title\n\t    pro.description = problem.description\n\t    pro.inputs = problem.inputs\n", "    pro.outputs = problem.outputs\n\t    pro.samples = '+#+#'.join(['|||'.join(it) for it in problem.samples])\n\t    pro.language = '###'.join([it for it in problem.language if it in ['c', 'cxx', 'py3', 'py2', 'php', 'go', 'js']])\n\t    pro.mode = problem.mode\n\t    pro.is_spj = problem.is_spj\n\t    pro.source = problem.source\n\t    pro.time_limit = problem.time_limit\n\t    pro.memory_limit = problem.memory_limit\n\t    pro.hints = problem.hints\n\t    pro.test_id = problem.test_id\n", "    db.commit()\n\t    return True\n\t@router.post(\"/add\")\n\tasync def problem_add(problem: ProblemForm, x_token: Union[str, None] = Header(None),\n\t                      db: Session = Depends(get_session)):\n\t    if problem.cid != '':\n\t        sta = 3\n\t        try:\n\t            cid = AESTool.decrypt_data(problem.cid)\n\t        except:\n", "            return Response('Invalid Request', status_code=status.HTTP_400_BAD_REQUEST)\n\t    else:\n\t        sta = 1\n\t        cid = None\n\t    pro = ProblemInfo()\n\t    pro.title = problem.title\n\t    pro.description = problem.description\n\t    pro.inputs = problem.inputs\n\t    pro.outputs = problem.outputs\n\t    pro.samples = '+#+#'.join(['|||'.join(it) for it in problem.samples])\n", "    pro.language = '###'.join([it for it in problem.language if it in ['c', 'cxx', 'py3', 'py2', 'php', 'go', 'js']])\n\t    pro.mode = problem.mode\n\t    pro.is_spj = problem.is_spj\n\t    pro.source = problem.source\n\t    pro.time_limit = problem.time_limit\n\t    pro.memory_limit = problem.memory_limit\n\t    pro.hints = problem.hints\n\t    pro.test_id = problem.test_id\n\t    pro.created_by = get_user(x_token).id\n\t    pro.status = sta\n", "    db.add(pro)\n\t    db.commit()\n\t    if cid:\n\t        cp = ContestProblem(cid=cid, pid=pro.id)\n\t        db.add(cp)\n\t        db.commit()\n\t    return True\n\t@router.get(\"/visible\")\n\tasync def problem_visible(pid: str, s=None, db: Session = Depends(get_session)):\n\t    pid = AESTool.decrypt_data(pid)\n", "    pro = db.query(ProblemInfo).filter_by(id=pid).first()\n\t    if not pro:\n\t        return Response('Problem not found', status_code=status.HTTP_404_NOT_FOUND)\n\t    if s:\n\t        pro.status = None\n\t    else:\n\t        if pro.status == 0:\n\t            pro.status = 1\n\t        elif pro.status == 1:\n\t            pro.status = 0\n", "    db.commit()\n\t    return True\n"]}
{"filename": "OJ/middleware/users.py", "chunked_list": ["import typing\n\tfrom fastapi import Request, status\n\tfrom fastapi.responses import JSONResponse, Response\n\tfrom sqlalchemy.orm import Session\n\tfrom starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint, DispatchFunction\n\tfrom starlette.types import ASGIApp\n\tfrom OJ.db.database import engine\n\tfrom OJ.models.UserModels import UserSession\n\tfrom OJ.app.settings import CHECKLOGIN_EXCLUDE_PATH\n\tclass CheckLogin(BaseHTTPMiddleware):\n", "    def __init__(self, app: ASGIApp, dispatch: typing.Optional[DispatchFunction] = None) -> None:\n\t        super().__init__(app, dispatch)\n\t        self.app = app\n\t    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n\t        if request.method == 'OPTIONS':\n\t            response = await call_next(request)\n\t            return response\n\t        path: str = request.get('path')\n\t        for it in CHECKLOGIN_EXCLUDE_PATH:\n\t            if path.startswith(it):\n", "                response = await call_next(request)\n\t                return response\n\t        else:\n\t            with Session(engine) as session:\n\t                session.begin()\n\t                token = request.headers.get('x-token', '')\n\t                sess = session.query(UserSession).filter(UserSession.token == token).first()\n\t                if not sess:\n\t                    return JSONResponse({}, status_code=status.HTTP_401_UNAUTHORIZED)\n\t                if path.startswith('/api/admin') and not sess.user.is_admin:\n", "                    return Response('NOT ACCEPTABLE REQUEST', status_code=status.HTTP_406_NOT_ACCEPTABLE)\n\t                response = await call_next(request)\n\t                session.close()\n\t            return response\n"]}
{"filename": "OJ/middleware/__init__.py", "chunked_list": []}
{"filename": "OJ/app/settings.py", "chunked_list": ["import os\n\tenviron = os.environ\n\t# PROJECT_PATH = os.path.dirname(__file__)\n\tPROJECT_PATH = os.getcwd()\n\tTEMPLATE_FOLDER = os.path.join(PROJECT_PATH, \"templates\")\n\tSTATIC_FOLDER = os.path.join(PROJECT_PATH, \"static\")\n\tDEBUG = True  # open debug /or hot restart\n\t# ****** 上传配置\n\tUPLOAD_FOLDER = '/tmp/uploads'\n\tALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'sql'}\n", "# SQLALCHEMY_DATABASE_URI = 'sqlite:///test.db'\n\t# ****** MySQL 配置\n\tSQLALCHEMY_DATABASE_URI = 'mysql+pymysql://{user}:{password}@{host}:{port}/{database}?charset=utf8'.format(\n\t    user=environ.get('DB_USER', 'DB_USER'),\n\t    password=environ.get('DB_PASS', 'DB_PASS'),\n\t    host=environ.get('DB_HOST', '127.0.0.1'),\n\t    port=environ.get('DB_PORT', 3306),\n\t    database=environ.get('DB_NAME', 'DB_NAME'))\n\t# # SQLALCHEMY_POOL_SIZE = 15  # 数据库连接池的大小。默认是数据库引擎的默认值 （通常是 5）。\n\t# # SQLALCHEMY_POOL_TIMEOUT = 10  # 指定数据库连接池的超时时间。默认是 10。\n", "# # SQLALCHEMY_POOL_RECYCLE = 60 * 60 * 2  # 自动回收连接的秒数。\n\t# # SQLALCHEMY_MAX_OVERFLOW = 0  # 控制在连接池达到最大值后可以创建的连接数。\n\t# SQLALCHEMY_POOL_SIZE = 30  # 数据库连接池的大小。默认是数据库引擎的默认值 （通常是 5）。\n\t# SQLALCHEMY_POOL_TIMEOUT = 10  # 指定数据库连接池的超时时间。默认是 10。\n\t# SQLALCHEMY_POOL_RECYCLE = 60 * 60 * 2  # 自动回收连接的秒数。\n\t# SQLALCHEMY_MAX_OVERFLOW = 20  # 控制在连接池达到最大值后可以创建的连接数。\n\tREDIS_HOST = os.environ.get('REDIS_HOST', '127.0.0.1')\n\tREDIS_PORT = os.environ.get('REDIS_PORT', 6379)\n\tREDIS_PASSWORD = os.environ.get('REDIS_PASSWORD', 'REDIS_PASSWORD')\n\tREDIS_DB = os.environ.get('REDIS_DB', '0')\n", "if REDIS_PASSWORD:\n\t    RESULT_BACKEND = f'redis://:{REDIS_PASSWORD}@{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'\n\t    BROKER_URL = f'redis://:{REDIS_PASSWORD}@{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'\n\telse:\n\t    RESULT_BACKEND = f'redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'\n\t    BROKER_URL = f'redis://{REDIS_PORT}/{REDIS_DB}'\n\tHOST = environ.get('HOST', '0.0.0.0')\n\tPORT = environ.get('PORT', 16808)\n\tJUDGER_SERVER = 'http://{judger_host}:{judger_port}/'.format(\n\t    judger_host=environ.get('JUDGER_HOST', '127.0.0.1'),\n", "    judger_port=environ.get('JUDGER_PORT', '16358'),\n\t)\n\tJUDGER_TOKEN = environ.get('JUDGER_TOKEN', '123456')\n\t# middleware settings\n\tCHECKLOGIN_EXCLUDE_PATH = [\n\t    '/api/user/register',\n\t    '/api/user/login',\n\t    '/api/submission/status',\n\t    '/api/contest/recent',\n\t    '/api/contest/all',\n", "    '/api/contest/detail',\n\t    '/api/contest/announcements',\n\t    '/api/problem/hot',\n\t    '/api/problem/all',\n\t    '/api/problem/detail',\n\t    '/api/admin/sys/qdu/import',\n\t    '/docs',\n\t    '/openapi.json',\n\t]\n\tAES_KEY = environ.get('AES_KEY', 'Your_AES_KEY')\n", "AES_KEY = AES_KEY.ljust(16)\n\tTEST_CASE_DIR = ''\n"]}
{"filename": "OJ/app/__init__.py", "chunked_list": []}
