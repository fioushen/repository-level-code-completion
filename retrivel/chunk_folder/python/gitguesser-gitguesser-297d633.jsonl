{"filename": "backend/tests/test_main.py", "chunked_list": ["import pytest\n\t@pytest.mark.anyio\n\tasync def test_root(client):\n\t    response = await client.get(\"/\")\n\t    assert response.status_code == 200\n\t    assert response.json() == {\"message\": \"Hello World\"}\n"]}
{"filename": "backend/tests/__init__.py", "chunked_list": []}
{"filename": "backend/tests/conftest.py", "chunked_list": ["import pytest\n\tfrom app.config import settings\n\tfrom app.database import Base\n\tfrom app.main import app\n\tfrom httpx import AsyncClient\n\tfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom testcontainers.core.waiting_utils import wait_for_logs\n\tfrom testcontainers.postgres import PostgresContainer\n\t@pytest.fixture(scope=\"session\")\n", "def anyio_backend():\n\t    return \"asyncio\"\n\t@pytest.fixture\n\tasync def client():\n\t    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n\t        yield client\n\t@pytest.fixture(scope=\"session\")\n\tdef postgres_container():\n\t    postgres = PostgresContainer(\n\t        image=\"postgres:15.2\",\n", "        user=settings.postgres_user,\n\t        password=settings.postgres_password,\n\t        dbname=settings.postgres_db + \"_test\",\n\t        port=settings.postgres_port,\n\t    )\n\t    with postgres:\n\t        wait_for_logs(\n\t            postgres,\n\t            r\"UTC \\[1\\] LOG:  database system is ready to accept connections\",\n\t            10,\n", "        )\n\t        postgres.driver = \"asyncpg\"\n\t        yield postgres\n\t@pytest.fixture(scope=\"session\")\n\tasync def db_engine(postgres_container):\n\t    engine = create_async_engine(postgres_container.get_connection_url())\n\t    yield engine\n\t@pytest.fixture(scope=\"session\")\n\tasync def db_session(db_engine):\n\t    async_session = sessionmaker(db_engine, class_=AsyncSession, expire_on_commit=False)\n", "    yield async_session\n\t@pytest.fixture\n\tasync def db(db_session, db_engine):\n\t    async with db_engine.begin() as conn:\n\t        await conn.run_sync(Base.metadata.drop_all)  # Just in case.\n\t        await conn.run_sync(Base.metadata.create_all)\n\t    async with db_session() as session:\n\t        yield session\n\t    async with db_engine.begin() as conn:\n\t        await conn.run_sync(Base.metadata.drop_all)\n"]}
{"filename": "backend/tests/routers/test_repository_routers.py", "chunked_list": ["from json import dumps\n\timport pytest\n\tSAMPLE_REPOSITORY_DATA = [\n\t    {\n\t        \"player_name\": \"player\",\n\t        \"repo_owner\": \"gitguesser\",\n\t        \"repo_name\": \"gitguesser\",\n\t        \"repo_branch\": \"main\",\n\t    },\n\t]\n", "# We need test repo in our app. So we add one using game route.\n\tasync def create_repository(client, repo_data):\n\t    response = await client.post(\"game/\", content=dumps(repo_data))\n\t    response = await client.get(\"game/\" + str(response.json()[\"game_id\"]))\n\t    repo_id = response.json()[\"repository_id\"]\n\t    assert isinstance(repo_id, int)\n\t    return repo_id\n\t@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n\t@pytest.mark.anyio\n\tasync def test_get_correct_repository(client, repo_data):\n", "    repo_id = await create_repository(client, repo_data)\n\t    response = await client.get(\"repository/\" + str(repo_id))\n\t    assert response.status_code == 200\n\t    response_json = response.json()\n\t    assert response_json[\"id\"] == repo_id\n\t    assert response_json[\"name\"] == repo_data[\"repo_name\"]\n\t    assert response_json[\"owner\"] == repo_data[\"repo_owner\"]\n\t    assert response_json[\"branch\"] == repo_data[\"repo_branch\"]\n\t    return repo_id\n\t@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n", "@pytest.mark.anyio\n\tasync def test_correct_repository_get_root_directory(client, repo_data):\n\t    repo_id = await test_get_correct_repository(client, repo_data)\n\t    response = await client.get(\"repository/\" + str(repo_id) + \"/tree\")\n\t    assert response.status_code == 200\n\t    response_json = response.json()\n\t    assert \"subdirectories\" in response_json\n\t    assert any(dir[\"name\"] == \"backend\" for dir in response_json[\"subdirectories\"])\n\t    assert any(dir[\"name\"] == \"frontend\" for dir in response_json[\"subdirectories\"])\n\t    assert all(len(dir[\"id\"]) > 0 for dir in response_json[\"subdirectories\"])\n", "    backend_dir_id = [\n\t        dir[\"id\"] for dir in response_json[\"subdirectories\"] if dir[\"name\"] == \"backend\"\n\t    ][0]\n\t    return str(repo_id) + \"/tree/\" + str(backend_dir_id)\n\t@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n\t@pytest.mark.anyio\n\tasync def test_correct_repository_get_no_directory(client, repo_data):\n\t    repo_id = await test_get_correct_repository(client, repo_data)\n\t    response = await client.get(\"repository/\" + str(repo_id) + \"/tree/0\")\n\t    assert response.status_code == 404\n", "    assert response.json() == {\"detail\": \"Directory not found\"}\n\t@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n\t@pytest.mark.anyio\n\tasync def test_correct_repository_get_correct_directory(client, repo_data):\n\t    directory_url = await test_correct_repository_get_root_directory(client, repo_data)\n\t    response = await client.get(\"repository/\" + directory_url)\n\t    assert response.status_code == 200\n\t    response_json = response.json()\n\t    assert \"subdirectories\" in response_json\n\t    assert any(dir[\"name\"] == \"app\" for dir in response_json[\"subdirectories\"])\n", "    assert any(dir[\"name\"] == \"tests\" for dir in response_json[\"subdirectories\"])\n\t    assert all(len(dir[\"id\"]) > 0 for dir in response_json[\"subdirectories\"])\n\t@pytest.mark.anyio\n\tasync def test_get_no_repository(client):\n\t    response = await client.get(\"repository/1\")\n\t    assert response.status_code == 404\n\t    assert response.json() == {\"detail\": \"Repository not found\"}\n\t@pytest.mark.anyio\n\tasync def test_no_repository_get_no_directory(client):\n\t    response = await client.get(\"repository/1/tree/1\")\n", "    assert response.status_code == 404\n\t    assert response.json() == {\"detail\": \"Repository not found\"}\n\t@pytest.mark.anyio\n\tasync def test_no_repository_get_root_directory(client):\n\t    response = await client.get(\"repository/1/tree\")\n\t    assert response.status_code == 404\n\t    assert response.json() == {\"detail\": \"Repository not found\"}\n"]}
{"filename": "backend/tests/routers/__init__.py", "chunked_list": []}
{"filename": "backend/tests/routers/test_game_routers.py", "chunked_list": ["from datetime import datetime\n\tfrom json import dumps\n\timport pytest\n\tfrom pydantic.datetime_parse import parse_datetime\n\tCORRECT_GAME_DATA = [\n\t    {\n\t        \"player_name\": \"player\",\n\t        \"repo_owner\": \"gitguesser\",\n\t        \"repo_name\": \"gitguesser\",\n\t        \"repo_branch\": \"main\",\n", "    },\n\t]\n\tINCORRECT_GAME_DATA = [\n\t    {},\n\t    {\n\t        \"repo_owner\": \"gitguesser\",\n\t        \"repo_name\": \"gitguesser\",\n\t        \"repo_branch\": \"main\",\n\t    },\n\t    {\n", "        \"player_name\": \"player\",\n\t        \"repo_owner\": \"I don't have this repo\",\n\t        \"repo_name\": \"gitguesser\",\n\t        \"repo_branch\": \"main\",\n\t    },\n\t]\n\t@pytest.mark.parametrize(\"game_data\", INCORRECT_GAME_DATA)\n\t@pytest.mark.anyio\n\tasync def test_post_incorrect_game(client, game_data):\n\t    response = await client.post(\"game/\", content=dumps(game_data))\n", "    assert (\n\t        response.status_code == 404 or response.status_code == 422\n\t    )  # Maybe add json check but i don't think it is worth the effort.\n\t@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n\t@pytest.mark.anyio\n\tasync def test_post_correct_game(client, game_data):\n\t    start_time = datetime.now()\n\t    response = await client.post(\"game/\", content=dumps(game_data))\n\t    assert response.status_code == 200\n\t    assert response.json()[\"game_id\"] == 1\n", "    new_game_data = response.json()\n\t    new_game_data[\"start_time\"] = start_time\n\t    return new_game_data\n\t@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n\t@pytest.mark.anyio\n\tasync def test_get_correct_game(client, game_data):\n\t    new_game_data = await test_post_correct_game(client, game_data)\n\t    max_time = datetime.now()\n\t    response = await client.get(\"game/\" + str(new_game_data[\"game_id\"]))\n\t    assert response.status_code == 200\n", "    response_json = response.json()\n\t    assert response_json[\"id\"] == new_game_data[\"game_id\"]\n\t    assert response_json[\"player_name\"] == game_data[\"player_name\"]\n\t    assert \"repository_id\" in response_json and isinstance(\n\t        response_json[\"repository_id\"], int\n\t    )\n\t    assert \"start_time\" in response_json\n\t    start_time = parse_datetime(response_json[\"start_time\"])\n\t    assert new_game_data[\"start_time\"] <= start_time <= max_time\n\t@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n", "@pytest.mark.anyio\n\tasync def test_correct_game_get_results_without_answer(client, game_data):\n\t    new_game_data = await test_post_correct_game(client, game_data)\n\t    response = await client.get(\"game/\" + str(new_game_data[\"game_id\"]) + \"/results\")\n\t    assert response.status_code == 404\n\t    assert response.json() == {\"detail\": \"Game not found\"}\n\t@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n\t@pytest.mark.anyio\n\tasync def test_correct_game_post_answer(client, game_data):\n\t    new_game_data = await test_post_correct_game(client, game_data)\n", "    sample_answer = {\"answer\": \"sample\"}\n\t    new_game_data[\"answer\"] = \"sample\"\n\t    response = await client.post(\n\t        \"game/\" + str(new_game_data[\"game_id\"]), content=dumps(sample_answer)\n\t    )\n\t    assert response.status_code == 200\n\t    return new_game_data\n\t@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n\t@pytest.mark.anyio\n\tasync def test_correct_game_get_results_with_answer(client, game_data):\n", "    new_game_data = await test_correct_game_post_answer(client, game_data)\n\t    response = await client.get(\"game/\" + str(new_game_data[\"game_id\"]) + \"/results\")\n\t    assert response.status_code == 200\n\t    response_json = response.json()\n\t    assert response_json[\"player_answer\"] == new_game_data[\"answer\"]\n\t    assert \"end_time\" in response_json\n\t    assert \"score\" in response_json\n\t    assert \"player_answer\" in response_json\n\t@pytest.mark.anyio\n\tasync def test_get_no_game(client):\n", "    response = await client.get(\"game/1\")\n\t    assert response.status_code == 404\n\t    assert response.json() == {\"detail\": \"Game not found\"}\n\t@pytest.mark.anyio\n\tasync def test_no_game_get_results(client):\n\t    response = await client.get(\"game/1/results\")\n\t    assert response.status_code == 404\n\t    assert response.json() == {\"detail\": \"Game not found\"}\n\t@pytest.mark.anyio\n\tasync def test_no_game_post_answer(client):\n", "    sample_answer = {\"answer\": \"sample\"}\n\t    response = await client.post(\"game/1\", content=dumps(sample_answer))\n\t    assert response.status_code == 404\n\t    assert response.json() == {\"detail\": \"Game not found\"}\n"]}
{"filename": "backend/tests/routers/test_search_routers.py", "chunked_list": ["import pytest\n\t@pytest.mark.anyio\n\tasync def test_search(client):\n\t    response = await client.get(\"search/?query=java\")\n\t    assert response.status_code == 200\n\t    assert \"repos\" in response.json()\n\t    assert len(response.json()[\"repos\"]) > 0\n\t@pytest.mark.anyio\n\tasync def test_search_incorrect(client):\n\t    response = await client.get(\"search/\")\n", "    assert response.status_code == 404\n"]}
{"filename": "backend/tests/routers/conftest.py", "chunked_list": ["import pytest\n\tfrom app.dependencies import get_session\n\tfrom app.main import app\n\tfrom httpx import AsyncClient\n\t@pytest.fixture\n\tasync def client(db):\n\t    app.dependency_overrides[get_session] = lambda: db\n\t    async with AsyncClient(app=app, base_url=\"http://test/\") as client:\n\t        yield client\n\t    app.dependency_overrides.clear()\n"]}
{"filename": "backend/tests/services/test_game_service.py", "chunked_list": ["import pytest\n\tfrom app.models.models import Game\n\tfrom app.schemas.game import GameStartConfig\n\tfrom app.services import game_service\n\tfrom fastapi import HTTPException\n\tfrom sqlalchemy import func, select\n\tCORRECT_GAME_START_CONFIG = [\n\t    GameStartConfig(\n\t        player_name=\"player\",\n\t        repo_name=\"gitguesser\",\n", "        repo_owner=\"gitguesser\",\n\t        repo_branch=\"main\",\n\t    ),\n\t]\n\tINCORRECT_GAME_START_CONFIG = [\n\t    GameStartConfig(\n\t        player_name=\"player\",\n\t        repo_name=\"gitguesser\",\n\t        repo_owner=\"abcd\",\n\t        repo_branch=\"main\",\n", "    ),\n\t    GameStartConfig(\n\t        player_name=\"player\",\n\t        repo_name=\"gitguesser\",\n\t        repo_owner=\"gitguesser\",\n\t        repo_branch=\"master\",\n\t    ),\n\t]\n\t@pytest.fixture\n\tasync def game_id(db):\n", "    return await game_service.start_game(\n\t        db=db, game_config=CORRECT_GAME_START_CONFIG[0]\n\t    )\n\tasync def _count(db):\n\t    return await db.scalar(select(func.count(\"*\")).select_from(Game))\n\t@pytest.mark.parametrize(\"game_config\", CORRECT_GAME_START_CONFIG)\n\t@pytest.mark.anyio\n\tasync def test_start_game_correct(db, game_config):\n\t    assert await _count(db) == 0\n\t    id = await game_service.start_game(db=db, game_config=game_config)\n", "    game = await db.scalar(select(Game).where(Game.id == int(id)))\n\t    assert await _count(db) == 1\n\t    assert game is not None\n\t    assert game.player_name == game_config.player_name\n\t    assert game.repository_id is not None\n\t@pytest.mark.parametrize(\"game_config\", INCORRECT_GAME_START_CONFIG)\n\t@pytest.mark.anyio\n\tasync def test_start_game_incorrect(db, game_config):\n\t    with pytest.raises(HTTPException) as excinfo:\n\t        await game_service.start_game(db=db, game_config=game_config)\n", "    assert excinfo.value.status_code == 404\n\t    assert await _count(db) == 0\n\t@pytest.mark.anyio\n\tasync def test_get_game_when_exists(db, game_id):\n\t    game = await game_service.get_game(db=db, game_id=game_id)\n\t    assert game is not None\n\t    assert game.id == game_id\n\t@pytest.mark.anyio\n\tasync def test_get_game_when_not_exists(db):\n\t    with pytest.raises(HTTPException) as excinfo:\n", "        await game_service.get_game(db=db, game_id=0)\n\t    assert excinfo.value.status_code == 404\n\t    assert await _count(db) == 0\n\t@pytest.mark.anyio\n\tasync def test_give_answer_correct(db, game_id):\n\t    game = await game_service.get_game(db=db, game_id=game_id)\n\t    assert game.end_time is None\n\t    assert game.player_answer is None\n\t    answer = game.correct_answer\n\t    await game_service.give_answer(db=db, game_id=game_id, answer=answer)\n", "    game = await game_service.get_game(db=db, game_id=game_id)\n\t    assert game.score == 0\n\t    assert game.end_time is not None\n\t    assert game.player_answer == answer\n\t@pytest.mark.anyio\n\tasync def test_give_wrong_correct(db, game_id):\n\t    game = await game_service.get_game(db=db, game_id=game_id)\n\t    assert game.end_time is None\n\t    assert game.player_answer is None\n\t    answer = game.correct_answer + \"/does_not_exist\"\n", "    await game_service.give_answer(db=db, game_id=game_id, answer=answer)\n\t    game = await game_service.get_game(db=db, game_id=game_id)\n\t    assert game.score > 0\n\t    assert game.end_time is not None\n\t    assert game.player_answer == answer\n"]}
{"filename": "backend/tests/services/__init__.py", "chunked_list": []}
{"filename": "backend/tests/services/test_repository_service.py", "chunked_list": ["import pytest\n\tfrom app.models.models import Repository\n\tfrom app.services import repository_service\n\tfrom fastapi import HTTPException\n\tfrom sqlalchemy import func, select\n\tCORRECT_REPOSITORY = [\n\t    {\n\t        \"owner\": \"gitguesser\",\n\t        \"name\": \"gitguesser\",\n\t        \"branch\": \"main\",\n", "    },\n\t]\n\tINCORRECT_REPOSITORY = [\n\t    {\n\t        \"owner\": \"gitguesser\",\n\t        \"name\": \"gitguesser\",\n\t        \"branch\": \"master\",\n\t    },\n\t    {\n\t        \"owner\": \"gitguesser\",\n", "        \"name\": \"gitguesser1\",\n\t        \"branch\": \"main\",\n\t    },\n\t]\n\t@pytest.fixture\n\tasync def repo_id(db):\n\t    return await repository_service.update_repo(\n\t        db=db, owner=\"gitguesser\", name=\"gitguesser\", branch=\"main\"\n\t    )\n\tasync def _count(db):\n", "    return await db.scalar(select(func.count(\"*\")).select_from(Repository))\n\t@pytest.mark.parametrize(\"repo_data\", CORRECT_REPOSITORY)\n\t@pytest.mark.anyio\n\tasync def test_update_repo_correct(db, repo_data):\n\t    assert await _count(db) == 0\n\t    id = await repository_service.update_repo(db=db, **repo_data)\n\t    repo = await db.scalar(select(Repository).where(Repository.id == int(id)))\n\t    assert await _count(db) == 1\n\t    assert repo is not None\n\t    assert repo.name == repo_data[\"name\"]\n", "    assert repo.owner == repo_data[\"owner\"]\n\t    assert repo.branch == repo_data[\"branch\"]\n\t    assert len(repo.data) > 0\n\t@pytest.mark.parametrize(\"repo_data\", CORRECT_REPOSITORY)\n\t@pytest.mark.anyio\n\tasync def test_update_repo_unchanged(db, repo_data):\n\t    assert await _count(db) == 0\n\t    await repository_service.update_repo(db=db, **repo_data)\n\t    await repository_service.update_repo(db=db, **repo_data)\n\t    assert await _count(db) == 1\n", "@pytest.mark.parametrize(\"repo_data\", INCORRECT_REPOSITORY)\n\t@pytest.mark.anyio\n\tasync def test_update_repo_incorrect(db, repo_data):\n\t    assert await _count(db) == 0\n\t    with pytest.raises(HTTPException) as excinfo:\n\t        await repository_service.update_repo(db=db, **repo_data)\n\t    assert excinfo.value.status_code == 404\n\t    assert await _count(db) == 0\n\t@pytest.mark.anyio\n\tasync def test_get_repo_when_exists(db, repo_id):\n", "    repo = await repository_service.get_repo(db=db, repo_id=repo_id)\n\t    assert repo is not None\n\t    assert repo.id == repo_id\n\t@pytest.mark.anyio\n\tasync def test_get_repo_when_not_exists(db):\n\t    with pytest.raises(HTTPException) as excinfo:\n\t        repo = await repository_service.get_repo(db=db, repo_id=0)\n\t    assert excinfo.value.status_code == 404\n\t    assert await _count(db) == 0\n\t@pytest.mark.anyio\n", "async def test_get_directory_when_not_exists(db, repo_id):\n\t    with pytest.raises(HTTPException) as excinfo:\n\t        await repository_service.get_directory(db=db, repo_id=repo_id, directory_id=\"0\")\n\t    assert excinfo.value.status_code == 404\n\t@pytest.mark.anyio\n\tasync def test_get_root_directory(db, repo_id):\n\t    dir = await repository_service.get_root_directory(db=db, repo_id=repo_id)\n\t    assert dir is not None\n\t    assert dir.name == \"\"\n\t    assert len(dir.subdirectories) > 0\n", "    assert any(d.name == \"backend\" for d in dir.subdirectories)\n\t    assert any(d.name == \"frontend\" for d in dir.subdirectories)\n\t    assert all(len(d.id) > 0 for d in dir.subdirectories)\n\t@pytest.mark.anyio\n\tasync def test_get_random_file_path(db, repo_id):\n\t    path = await repository_service.get_random_file_path(db=db, repo_id=repo_id)\n\t    assert path is not None\n\t@pytest.mark.anyio\n\tasync def test_get_random_file_path_when_not_exists(db):\n\t    with pytest.raises(HTTPException) as excinfo:\n", "        await repository_service.get_random_file_path(db=db, repo_id=0)\n\t    assert excinfo.value.status_code == 404\n"]}
{"filename": "backend/tests/services/test_search_service.py", "chunked_list": ["import pytest\n\tfrom app.services import search_service\n\tfrom fastapi import HTTPException\n\t@pytest.mark.anyio\n\tasync def test_search_repos():\n\t    data = await search_service.search_repos(query=\"python\")\n\t    assert len(data.repos) > 0\n\t@pytest.mark.anyio\n\tasync def test_search_incorrect():\n\t    with pytest.raises(HTTPException) as excinfo:\n", "        await search_service.search_repos(query=\"\")\n"]}
{"filename": "backend/app/database.py", "chunked_list": ["from app.config import settings\n\tfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\tfrom sqlalchemy.orm import declarative_base, sessionmaker\n\tengine = create_async_engine(\n\t    \"postgresql+asyncpg://\"\n\t    f\"{settings.postgres_user}:{settings.postgres_password}@\"\n\t    f\"db:{settings.postgres_port}/{settings.postgres_db}\",\n\t    echo=True,\n\t)\n\tBase = declarative_base()\n", "async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\tasync def init_models():\n\t    async with engine.begin() as conn:\n\t        await conn.run_sync(\n\t            Base.metadata.drop_all\n\t        )  # Can be commented in future if we want to preserve data in database.\n\t        await conn.run_sync(Base.metadata.create_all)\n"]}
{"filename": "backend/app/main.py", "chunked_list": ["from app.database import init_models\n\tfrom app.routers import game, repository, search\n\tfrom fastapi import FastAPI\n\tfrom fastapi.middleware.cors import CORSMiddleware\n\tapp = FastAPI()\n\tapp.add_middleware(\n\t    CORSMiddleware,\n\t    allow_origins=[\"*\"],\n\t    allow_credentials=True,\n\t    allow_methods=[\"*\"],\n", "    allow_headers=[\"*\"],\n\t)\n\tapp.include_router(game.router)\n\tapp.include_router(repository.router)\n\tapp.include_router(search.router)\n\t@app.on_event(\"startup\")\n\tasync def on_startup():\n\t    await init_models()\n\t@app.get(\"/\")\n\tasync def root():\n", "    return {\"message\": \"Hello World\"}\n"]}
{"filename": "backend/app/config.py", "chunked_list": ["from pydantic import BaseSettings\n\tclass Settings(BaseSettings):\n\t    \"\"\"Loads configuration of the application.\n\t    When an instance of this class is created, its attributes are\n\t    initialized using the values from both environment variables and\n\t    the content of .env file.\n\t    \"\"\"\n\t    postgres_user: str\n\t    postgres_password: str\n\t    postgres_port: int\n", "    postgres_db: str\n\t    github_username: str | None\n\t    github_token: str | None\n\t    class Config:\n\t        case_sensitive = False\n\t        env_file = \".env\"\n\t        env_file_encoding = \"utf-8\"\n\tsettings = Settings()\n"]}
{"filename": "backend/app/dependencies.py", "chunked_list": ["from app.database import async_session\n\tfrom sqlalchemy.ext.asyncio import AsyncSession\n\tasync def get_session() -> AsyncSession:\n\t    async with async_session() as session:\n\t        yield session\n"]}
{"filename": "backend/app/__init__.py", "chunked_list": []}
{"filename": "backend/app/schemas/game.py", "chunked_list": ["from datetime import datetime\n\tfrom pydantic import BaseModel\n\tclass GameWithId(BaseModel):\n\t    game_id: int\n\tclass GameStartConfig(BaseModel):\n\t    player_name: str\n\t    repo_name: str\n\t    repo_owner: str\n\t    repo_branch: str\n\tclass GameInfo(BaseModel):\n", "    id: int\n\t    repository_id: int\n\t    player_name: str\n\t    start_time: datetime\n\t    file_name: str\n\t    class Config:\n\t        orm_mode = True\n\tclass GameResults(GameInfo):\n\t    end_time: datetime\n\t    score: int\n", "    player_answer: str\n\t    correct_answer: str\n\t    class Config:\n\t        orm_mode = True\n\tclass PlayerAnswer(BaseModel):\n\t    answer: str\n"]}
{"filename": "backend/app/schemas/__init__.py", "chunked_list": []}
{"filename": "backend/app/schemas/repository.py", "chunked_list": ["from pydantic import BaseModel\n\tclass DirectoryInfo(BaseModel):\n\t    id: str\n\t    name: str\n\tclass Directory(DirectoryInfo):\n\t    subdirectories: list[DirectoryInfo]\n\tclass Repository(BaseModel):\n\t    id: int\n\t    name: str\n\t    owner: str\n", "    branch: str\n\t    class Config:\n\t        orm_mode = True\n"]}
{"filename": "backend/app/schemas/search.py", "chunked_list": ["from pydantic import BaseModel\n\tclass Repository(BaseModel):\n\t    name: str\n\t    owner: str\n\t    branch: str\n\tclass Repositories(BaseModel):\n\t    repos: list[Repository]\n"]}
{"filename": "backend/app/routers/game.py", "chunked_list": ["from app.dependencies import get_session\n\tfrom app.schemas.game import (\n\t    GameInfo,\n\t    GameResults,\n\t    GameStartConfig,\n\t    GameWithId,\n\t    PlayerAnswer,\n\t)\n\tfrom app.services import game_service\n\tfrom fastapi import APIRouter, Depends\n", "from sqlalchemy.ext.asyncio import AsyncSession\n\trouter = APIRouter(\n\t    prefix=\"/game\",\n\t    tags=[\"game\"],\n\t)\n\t@router.post(\n\t    \"/\",\n\t    response_model=GameWithId,\n\t    description=\"Starts a new game.\",\n\t)\n", "async def start_game(\n\t    game_start_config: GameStartConfig, session: AsyncSession = Depends(get_session)\n\t):\n\t    game_id = await game_service.start_game(db=session, game_config=game_start_config)\n\t    return {\"game_id\": game_id}\n\t@router.get(\n\t    \"/{id}\",\n\t    response_model=GameInfo,\n\t    description=\"Retrieves information about a game with given id.\",\n\t)\n", "async def get_game_info(id: int, session: AsyncSession = Depends(get_session)):\n\t    game = await game_service.get_game(db=session, game_id=id)\n\t    return game\n\t@router.get(\n\t    \"/{id}/results\",\n\t    response_model=GameResults,\n\t    description=\"Retrieves results of finished game with given id.\",\n\t)\n\tasync def get_game_results(id: int, session: AsyncSession = Depends(get_session)):\n\t    game = await game_service.get_game_answered(db=session, game_id=id)\n", "    return game\n\t@router.post(\"/{id}\", description=\"Sends player answer for a game with given id.\")\n\tasync def send_answer(\n\t    id: int, answer: PlayerAnswer, session: AsyncSession = Depends(get_session)\n\t):\n\t    await game_service.give_answer(db=session, game_id=id, answer=answer.answer)\n\t    return\n"]}
{"filename": "backend/app/routers/__init__.py", "chunked_list": []}
{"filename": "backend/app/routers/repository.py", "chunked_list": ["from app.dependencies import get_session\n\tfrom app.schemas.repository import Directory, Repository\n\tfrom app.services import repository_service\n\tfrom fastapi import APIRouter, Depends\n\tfrom sqlalchemy.ext.asyncio import AsyncSession\n\trouter = APIRouter(\n\t    prefix=\"/repository\",\n\t    tags=[\"repository\"],\n\t)\n\t@router.get(\n", "    \"/{id}/tree\",\n\t    response_model=Directory,\n\t    description=\"Returns root directory of the repository with given id.\",\n\t)\n\tasync def get_root_directory(id: int, session: AsyncSession = Depends(get_session)):\n\t    root_directory = await repository_service.get_root_directory(db=session, repo_id=id)\n\t    return root_directory\n\t@router.get(\n\t    \"/{id}/tree/{directory_id}\",\n\t    response_model=Directory,\n", "    description=\"Returns directory with given id that belongs to the repository.\",\n\t)\n\tasync def get_directory(\n\t    id: int, directory_id: str, session: AsyncSession = Depends(get_session)\n\t):\n\t    directory = await repository_service.get_directory(\n\t        db=session, repo_id=id, directory_id=directory_id\n\t    )\n\t    return directory\n\t@router.get(\n", "    \"/{id}\",\n\t    response_model=Repository,\n\t    description=\"Returns information about a repository with given id.\",\n\t)\n\tasync def get_repository(id: int, session: AsyncSession = Depends(get_session)):\n\t    repository = await repository_service.get_repo(db=session, repo_id=id)\n\t    return repository\n"]}
{"filename": "backend/app/routers/search.py", "chunked_list": ["from app.schemas.search import Repositories\n\tfrom app.services import search_service\n\tfrom fastapi import APIRouter\n\trouter = APIRouter(\n\t    prefix=\"/search\",\n\t    tags=[\"search\"],\n\t)\n\t@router.get(\n\t    \"/\",\n\t    response_model=Repositories,\n", "    description=\"Gets repositories from GitHub.\",\n\t)\n\tasync def search_repos(query: str = \"\"):\n\t    return await search_service.search_repos(query=query)\n"]}
{"filename": "backend/app/models/models.py", "chunked_list": ["import datetime\n\tfrom app.database import Base\n\tfrom sqlalchemy import Column, DateTime, ForeignKey, Index, Integer, String\n\tfrom sqlalchemy.dialects.postgresql import JSONB\n\tfrom sqlalchemy.orm import relationship\n\tclass Game(Base):\n\t    __tablename__ = \"games\"\n\t    id = Column(Integer, primary_key=True, index=True)\n\t    repository_id = Column(Integer, ForeignKey(\"repositories.id\"), nullable=False)\n\t    start_time = Column(DateTime, nullable=False)\n", "    end_time = Column(DateTime)\n\t    player_name = Column(String, nullable=False)\n\t    correct_answer = Column(String, nullable=False)\n\t    player_answer = Column(String)\n\t    score = Column(Integer)\n\t    file_name = Column(String)\n\t    repository = relationship(\"Repository\", back_populates=\"games\")\n\tclass Repository(Base):\n\t    __tablename__ = \"repositories\"\n\t    __table_args__ = (Index(\"idx_name_owner\", \"name\", \"owner\"),)\n", "    id = Column(Integer, primary_key=True, index=True)\n\t    name = Column(String, nullable=False)\n\t    owner = Column(String, nullable=False)\n\t    branch = Column(String, nullable=False)\n\t    etag = Column(String, nullable=False)\n\t    data = Column(JSONB, nullable=False)\n\t    creation_date = Column(DateTime, nullable=False, default=datetime.datetime.utcnow)\n\t    games = relationship(\"Game\", back_populates=\"repository\")\n"]}
{"filename": "backend/app/models/__init__.py", "chunked_list": []}
{"filename": "backend/app/services/game_service.py", "chunked_list": ["import datetime\n\tfrom app.models.models import Game\n\tfrom app.schemas.game import GameStartConfig\n\tfrom app.services.repository_service import get_random_file_path, update_repo\n\tfrom fastapi import HTTPException\n\tfrom sqlalchemy import select, update\n\tfrom sqlalchemy.ext.asyncio import AsyncSession\n\tasync def start_game(*, db: AsyncSession, game_config: GameStartConfig) -> int:\n\t    \"\"\"Starts a game based on data in game_config and returns its id.\"\"\"\n\t    repo_id = await update_repo(\n", "        db=db,\n\t        owner=game_config.repo_owner,\n\t        name=game_config.repo_name,\n\t        branch=game_config.repo_branch,\n\t    )\n\t    correct_answer = await get_random_file_path(db=db, repo_id=repo_id)\n\t    game = Game(\n\t        repository_id=repo_id,\n\t        start_time=datetime.datetime.utcnow(),\n\t        player_name=game_config.player_name,\n", "        correct_answer=correct_answer.rsplit(\"/\", 1)[0],\n\t        file_name=correct_answer.split(\"/\")[-1],\n\t    )\n\t    db.add(game)\n\t    await db.commit()\n\t    return game.id\n\tasync def get_game(*, db: AsyncSession, game_id: int) -> Game:\n\t    \"\"\"Returns the game with given id or raises a 404 HTTPException if it does not exist.\"\"\"\n\t    game = await db.scalar(select(Game).where(Game.id == int(game_id)))\n\t    if game is None:\n", "        raise HTTPException(status_code=404, detail=\"Game not found\")\n\t    return game\n\t# Maybe add tests for it in service test.\n\tasync def get_game_answered(*, db: AsyncSession, game_id: int) -> Game:\n\t    \"\"\"Returns the game with given id which was answered or raises a 404 HTTPException if it does not exist.\"\"\"\n\t    game = await db.scalar(select(Game).where(Game.id == int(game_id)))\n\t    if game is None or game.end_time is None:\n\t        raise HTTPException(status_code=404, detail=\"Game not found\")\n\t    return game\n\tasync def give_answer(*, db: AsyncSession, game_id: int, answer: str) -> None:\n", "    \"\"\"Gives answer to the game with given id.\n\t    If the game does not exist, raises a 404 HTTPException. If it has already\n\t    ended, nothing happens.\n\t    The score is calculated as the distance (in directories tree) between\n\t    user's answer and the correct answer (lower score is better).\n\t    \"\"\"\n\t    game = await get_game(db=db, game_id=game_id)\n\t    if game.end_time is not None:\n\t        return\n\t    correct_path = game.correct_answer.split(\"/\") if game.correct_answer != \"\" else []\n", "    player_path = answer.split(\"/\") if answer != \"\" and answer != \" \" else []\n\t    min_len = min(len(correct_path), len(player_path))\n\t    i = 0\n\t    while i < min_len and correct_path[i] == player_path[i]:\n\t        i += 1\n\t    score = len(correct_path) + len(player_path) - 2 * i\n\t    await db.execute(\n\t        update(Game)\n\t        .where(Game.id == int(game_id))\n\t        .values(\n", "            dict(score=score, end_time=datetime.datetime.utcnow(), player_answer=answer)\n\t        )\n\t    )\n\t    await db.commit()\n"]}
{"filename": "backend/app/services/repository_service.py", "chunked_list": ["import random\n\timport httpx\n\tfrom app.config import settings\n\tfrom app.models.models import Repository\n\tfrom app.schemas.repository import Directory, DirectoryInfo\n\tfrom fastapi import HTTPException, status\n\tfrom sqlalchemy import func, literal_column, select\n\tfrom sqlalchemy.dialects.postgresql import JSONB\n\tfrom sqlalchemy.ext.asyncio import AsyncSession\n\tasync def update_repo(*, db: AsyncSession, owner: str, name: str, branch: str) -> int:\n", "    \"\"\"Saves the repository in the database and returns its id.\n\t    If the repository is already saved, then it checks if the newest one has\n\t    been updated since saving it (using ETag). If there are any updates, it saves\n\t    a new copy to the database. If the repository does not exist, raises a 404 HTTPException.\n\t    \"\"\"\n\t    repo = await db.scalar(\n\t        select(Repository)\n\t        .where(Repository.name == name)\n\t        .where(Repository.owner == owner)\n\t        .where(Repository.branch == branch)\n", "        .order_by(Repository.creation_date.desc())\n\t        .limit(1)\n\t    )\n\t    response = None\n\t    endpoint = (\n\t        f\"https://api.github.com/repos/{owner}/{name}/git/trees/{branch}?recursive=true\"\n\t    )\n\t    auth = None\n\t    if settings.github_username and settings.github_token:\n\t        auth = (settings.github_username, settings.github_token)\n", "    async with httpx.AsyncClient(auth=auth) as client:\n\t        if repo is None:\n\t            response = await client.get(endpoint)\n\t        else:\n\t            response = await client.get(endpoint, headers={\"If-None-Match\": repo.etag})\n\t    if response.status_code == status.HTTP_200_OK:\n\t        repo = Repository(\n\t            name=name,\n\t            owner=owner,\n\t            branch=branch,\n", "            etag=response.headers[\"etag\"],\n\t            data=_parse_response(response),\n\t        )\n\t        db.add(repo)\n\t        await db.commit()\n\t    elif response.status_code == status.HTTP_404_NOT_FOUND:\n\t        raise HTTPException(status_code=404, detail=\"Repository not found\")\n\t    elif response.status_code != status.HTTP_304_NOT_MODIFIED:\n\t        raise HTTPException(status_code=404, detail=\"Error connecting to GitHub API\")\n\t    return repo.id\n", "async def get_repo(*, db: AsyncSession, repo_id: int) -> Repository:\n\t    \"\"\"Returns the repository with given id or raises a 404 HTTPException if it does not exist.\"\"\"\n\t    repo = await db.scalar(select(Repository).where(Repository.id == int(repo_id)))\n\t    if repo is None:\n\t        raise HTTPException(status_code=404, detail=\"Repository not found\")\n\t    return repo\n\tasync def get_directory(\n\t    *, db: AsyncSession, repo_id: int, directory_id: str\n\t) -> Directory:\n\t    \"\"\"Returns the directory with given id that belongs to the repository.\n", "    Raises a 404 HTTPException if the repository does not exist or it\n\t    does not contain this directory.\n\t    \"\"\"\n\t    await get_repo(db=db, repo_id=repo_id)\n\t    val = literal_column(\"value\", type_=JSONB)\n\t    directory = await db.scalar(\n\t        select(val)\n\t        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n\t        .where(Repository.id == int(repo_id))\n\t        .where(val.contains({\"sha\": directory_id}))\n", "    )\n\t    if directory is None:\n\t        raise HTTPException(status_code=404, detail=\"Directory not found\")\n\t    q = await db.scalars(\n\t        select(val)\n\t        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n\t        .where(Repository.id == int(repo_id))\n\t        .where(val.contains({\"parent\": directory[\"path\"]}))\n\t        .where(val.contains({\"type\": \"tree\"}))\n\t    )\n", "    subdirectories = q.all()\n\t    return Directory(\n\t        id=directory[\"sha\"],\n\t        name=directory[\"path\"].split(\"/\")[-1],\n\t        subdirectories=[\n\t            DirectoryInfo(id=subdir[\"sha\"], name=subdir[\"path\"].split(\"/\")[-1])\n\t            for subdir in subdirectories\n\t        ],\n\t    )\n\tasync def get_root_directory(*, db: AsyncSession, repo_id: int) -> Directory:\n", "    \"\"\"Returns the root directory of the repository with given id.\n\t    Raises a 404 HTTPException if the repository does not exist.\n\t    \"\"\"\n\t    await get_repo(db=db, repo_id=repo_id)\n\t    val = literal_column(\"value\", type_=JSONB)\n\t    q = await db.scalars(\n\t        select(val)\n\t        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n\t        .where(Repository.id == int(repo_id))\n\t        .where(val.contains({\"parent\": \"\"}))\n", "        .where(val.contains({\"type\": \"tree\"}))\n\t    )\n\t    subdirectories = q.all()\n\t    return Directory(\n\t        id=\"\",\n\t        name=\"\",\n\t        subdirectories=[\n\t            DirectoryInfo(id=subdir[\"sha\"], name=subdir[\"path\"].split(\"/\")[-1])\n\t            for subdir in subdirectories\n\t        ],\n", "    )\n\tasync def get_random_file_path(*, db: AsyncSession, repo_id: int) -> str:\n\t    \"\"\"Returns path to a randomly selected file that belongs to the repository.\n\t    Raises a 404 HTTPException if the repository does not exist.\n\t    The returned path is in the format 'a/b/c/file.txt'.\n\t    \"\"\"\n\t    await get_repo(db=db, repo_id=repo_id)\n\t    val = literal_column(\"value\", type_=JSONB)\n\t    q = await db.scalars(\n\t        select(val)\n", "        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n\t        .where(Repository.id == int(repo_id))\n\t        .where(val.contains({\"type\": \"blob\"}))\n\t    )\n\t    return random.choice(q.all())[\"path\"]\n\tdef _parse_response(response):\n\t    data = response.json()[\"tree\"]\n\t    for item in data:\n\t        item[\"parent\"] = \"/\".join(item[\"path\"].split(\"/\")[:-1])\n\t    return data\n"]}
{"filename": "backend/app/services/__init__.py", "chunked_list": []}
{"filename": "backend/app/services/search_service.py", "chunked_list": ["import httpx\n\tfrom app.config import settings\n\tfrom app.schemas.search import Repositories, Repository\n\tfrom fastapi import HTTPException, status\n\tasync def search_repos(*, query: str) -> list[Repository]:\n\t    \"\"\"Finds repositories on Github.\"\"\"\n\t    endpoint = f\"https://api.github.com/search/repositories?q={query}&sort=stars&order=desc&per_page=50\"\n\t    auth = None\n\t    if settings.github_username and settings.github_token:\n\t        auth = (settings.github_username, settings.github_token)\n", "    async with httpx.AsyncClient(auth=auth) as client:\n\t        response = await client.get(endpoint)\n\t    if response.status_code == status.HTTP_200_OK:\n\t        data = response.json()[\"items\"]\n\t        return Repositories(\n\t            repos=[\n\t                Repository(\n\t                    name=item[\"name\"],\n\t                    owner=item[\"owner\"][\"login\"],\n\t                    branch=item[\"default_branch\"],\n", "                )\n\t                for item in data\n\t            ]\n\t        )\n\t    raise HTTPException(status_code=404, detail=\"Error connecting to GitHub API\")\n"]}
