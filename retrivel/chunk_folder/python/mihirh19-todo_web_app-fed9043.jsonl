{"filename": "backend/main.py", "chunked_list": ["import uvicorn\n\tif __name__ == \"__main__\":\n\t    uvicorn.run(\"app:app\", host=\"0.0.0.0\", port=8000, reload=True)\n"]}
{"filename": "backend/__init__.py", "chunked_list": []}
{"filename": "backend/app/app.py", "chunked_list": ["from fastapi import FastAPI\n\tfrom fastapi.middleware.cors import CORSMiddleware\n\tfrom .core import settings\n\tfrom beanie import init_beanie\n\tfrom motor.motor_asyncio import AsyncIOMotorClient\n\tfrom .models import User, Todo\n\tfrom .api.api_v1 import router\n\tapp = FastAPI(\n\t    title=settings.PROJECT_NAME,\n\t    openapi_url=f\"{settings.API_V1_STR}/openapi.json\"\n", ")\n\torigins = ['*']\n\tapp.add_middleware(\n\t    CORSMiddleware,\n\t    allow_origins=origins,\n\t    allow_credentials=True,\n\t    allow_methods=[\"*\"],\n\t    allow_headers=[\"*\"]\n\t)\n\t@app.on_event(\"startup\")\n", "async def app_init():\n\t    \"\"\"\n\t        Initialize crucial application services\n\t    \"\"\"\n\t    db_client = AsyncIOMotorClient(settings.MONGO_CONNECTION_STRING).fodolist\n\t    await init_beanie(\n\t        database=db_client,\n\t        document_models=[\n\t            User,\n\t            Todo\n", "        ]\n\t    )\n\tapp.include_router(router, prefix=settings.API_V1_STR)\n\t@app.get('/')\n\tdef index():\n\t    return {'message': \"server is running\", \"documents\": \"http://localhost:8000/docs\",\n\t            \"postman Documentation\": \"https://documenter.getpostman.com/view/22926184/2s93RUtBH8\"}\n"]}
{"filename": "backend/app/__init__.py", "chunked_list": ["from .app import app\n\t__all__ = ['app']"]}
{"filename": "backend/app/schemas/user_schema.py", "chunked_list": ["from uuid import UUID\n\tfrom typing import Optional\n\tfrom pydantic import BaseModel, EmailStr, Field\n\tclass UserAuth(BaseModel):\n\t    email: EmailStr = Field(..., description=\"user email\")\n\t    username: str = Field(..., min_length=5, max_length=50, description=\"user username\")\n\t    password: str = Field(..., min_length=5, max_length=25)\n\tclass UserOut(BaseModel):\n\t    user_id: UUID\n\t    username: str\n", "    email: EmailStr\n\t    first_name: Optional[str] = None\n\t    last_name: Optional[str] = None\n\t    disabled:Optional[bool] = False\n"]}
{"filename": "backend/app/schemas/__init__.py", "chunked_list": ["from .auth_schema import TokenSchema, TokenPayload\n\tfrom .todo_schema import TodoCreate, TodoUpdate, TodoOut\n\tfrom .user_schema import UserAuth, UserOut\n\t__all__ = ['TokenSchema', 'TokenPayload', 'TodoOut', 'TodoUpdate', 'TodoCreate', 'UserOut', 'UserAuth']\n"]}
{"filename": "backend/app/schemas/auth_schema.py", "chunked_list": ["from uuid import UUID\n\tfrom pydantic import BaseModel\n\tclass TokenSchema(BaseModel):\n\t    access_token: str\n\t    refresh_token: str\n\tclass TokenPayload(BaseModel):\n\t    sub: UUID = None\n\t    exp: int\n"]}
{"filename": "backend/app/schemas/todo_schema.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Optional\n\tfrom uuid import UUID\n\tfrom pydantic import BaseModel, Field\n\tclass TodoCreate(BaseModel):\n\t    title: str = Field(..., title=\"Title\", max_length=55, min_length=1)\n\t    description: str = Field(..., title=\"Description\", max_length=7555, min_length=1)\n\t    status: Optional[bool] = False\n\tclass TodoUpdate(BaseModel):\n\t    title: Optional[str] = Field(..., title=\"Title\", max_length=55, min_length=1)\n", "    description: Optional[str] = Field(..., title=\"Description\", max_length=7555, min_length=1)\n\t    status: Optional[bool] = False\n\tclass TodoOut(BaseModel):\n\t    todo_id: UUID\n\t    status: bool\n\t    title: str\n\t    description: str\n\t    created_at: datetime\n\t    updated_at: datetime\n"]}
{"filename": "backend/app/models/user_model.py", "chunked_list": ["from datetime import datetime\n\tfrom uuid import UUID, uuid4\n\tfrom typing import Optional\n\tfrom beanie import Document, Indexed\n\tfrom pydantic import Field, EmailStr\n\tclass User(Document):\n\t    user_id: UUID = Field(default_factory=uuid4)\n\t    username: Indexed(str, unique=True)\n\t    email: Indexed(EmailStr, unique=True)\n\t    hashed_password: str\n", "    first_name: Optional[str] = None\n\t    last_name: Optional[str] = None\n\t    disabled: Optional[bool] = False\n\t    def __repr__(self) -> str:\n\t        return f\"<User> {self.email}\"\n\t    def __str__(self) -> str:\n\t        return self.email\n\t    def __hash__(self) -> int:\n\t        return hash(self.email)\n\t    def __eq__(self, other: object) -> bool:\n", "        if isinstance(other, User):\n\t            return self.email == other.email\n\t        return False\n\t    @property\n\t    def create(self) -> datetime:\n\t        return self.id.generation_time\n\t    @classmethod\n\t    async def by_email(self, email: str) -> \"User\":\n\t        return await self.find_one(self.email == email)\n\t    class Settings:\n", "        name = 'users'\n"]}
{"filename": "backend/app/models/__init__.py", "chunked_list": ["from .todo_model import Todo\n\tfrom .user_model import User\n\t__all__ =['User', 'Todo']"]}
{"filename": "backend/app/models/todo_model.py", "chunked_list": ["from datetime import datetime\n\tfrom uuid import UUID, uuid4\n\tfrom typing import Optional\n\tfrom beanie import Document, Indexed, Link, before_event, Replace, Insert\n\tfrom pydantic import Field, EmailStr\n\tfrom ..models.user_model import User\n\t# from .user_model import User\n\tclass Todo(Document):\n\t    todo_id: UUID = Field(default_factory=uuid4, unique=True)\n\t    status: bool = False\n", "    title: Indexed(str)\n\t    description: str\n\t    created_at: datetime = Field(default_factory=datetime.utcnow)\n\t    updated_at: datetime = Field(default_factory=datetime.utcnow)\n\t    owner: Link[User]\n\t    def __repr__(self) -> str:\n\t        return f\"<User> {self.title}\"\n\t    def __str__(self) -> str:\n\t        return self.title\n\t    def __hash__(self) -> int:\n", "        return hash(self.title)\n\t    def __eq__(self, other: object) -> bool:\n\t        if isinstance(other, Todo):\n\t            return self.todo_id == other.todo_id\n\t        return False\n\t    @before_event(Replace, Insert)\n\t    def update_update_at(self):\n\t        self.updated_at = datetime.utcnow()\n\t    class Settings:\n\t        name = \"todos\""]}
{"filename": "backend/app/core/security.py", "chunked_list": ["from passlib.context import CryptContext\n\tfrom typing import Any, Union\n\tfrom datetime import datetime, timedelta\n\tfrom .config import settings\n\tfrom jose import jwt\n\tpassword_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\tdef create_access_token(subject: Union[str, Any], expires_delta: int = None) -> str:\n\t    if expires_delta is not None:\n\t        expires_delta = datetime.utcnow() + expires_delta\n\t    else:\n", "        expires_delta = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n\t    to_encode = {\"exp\": expires_delta, \"sub\": str(subject)}\n\t    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=settings.ALGORITHM)\n\t    return encoded_jwt\n\tdef create_refresh_token(subject: Union[str, Any], expires_delta: int = None) -> str:\n\t    if expires_delta is not None:\n\t        expires_delta = datetime.utcnow() + expires_delta\n\t    else:\n\t        expires_delta = datetime.utcnow() + timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\t    to_encode = {\"exp\": expires_delta, \"sub\": str(subject)}\n", "    encoded_jwt = jwt.encode(to_encode, settings.JWT_REFRESH_SECRET_KEY, algorithm=settings.ALGORITHM)\n\t    return encoded_jwt\n\t1\n\tdef get_password(password: str) -> str:\n\t    return password_context.hash(password)\n\tdef verify_password(password: str, hashed_password: str) -> bool:\n\t    return password_context.verify(password, hashed_password)\n"]}
{"filename": "backend/app/core/config.py", "chunked_list": ["from pydantic import BaseSettings, AnyHttpUrl\n\tfrom decouple import config\n\tfrom typing import List\n\tclass Settings(BaseSettings):\n\t    API_V1_STR: str = \"/api/v1\"\n\t    JWT_SECRET_KEY: str = config('JWT_SECRET_KEY', cast=str)\n\t    JWT_REFRESH_SECRET_KEY: str = config('JWT_REFRESH_SECRET_KEY', cast=str)\n\t    ALGORITHM = \"HS256\"\n\t    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15\n\t    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7\n", "    BACKEND_CORS_ORIGINS: List[AnyHttpUrl] = []\n\t    PROJECT_NAME: str = \"TODOLIST\"\n\t    # Database\n\t    MONGO_CONNECTION_STRING: str = config(\"MONGO_CONNECTION_STRING\", cast=str)\n\t    class Config:\n\t        case_sensitive = True\n\tsettings = Settings()\n"]}
{"filename": "backend/app/core/__init__.py", "chunked_list": ["from .config import settings\n\tfrom .security import create_access_token, create_refresh_token, get_password,verify_password\n\t__all__ = ['settings', 'create_refresh_token', 'create_access_token', 'get_password', 'verify_password']"]}
{"filename": "backend/app/api/__init__.py", "chunked_list": []}
{"filename": "backend/app/api/deps/__init__.py", "chunked_list": ["from .user_deps import get_current_user\n\t__all__ = ['get_current_user']"]}
{"filename": "backend/app/api/deps/user_deps.py", "chunked_list": ["from fastapi.security import OAuth2PasswordBearer\n\tfrom fastapi import Depends, HTTPException, status\n\tfrom ...core import settings\n\tfrom ...models import User\n\tfrom ...services import UserService\n\tfrom jose import jwt\n\tfrom datetime import datetime\n\tfrom pydantic import ValidationError\n\tfrom ...schemas import TokenPayload\n\treuseble_oauth = OAuth2PasswordBearer(\n", "    tokenUrl=f\"{settings.API_V1_STR}/auth/login\",\n\t    scheme_name=\"JWT\"\n\t)\n\tasync def get_current_user(token: str = Depends(reuseble_oauth)) -> User:\n\t    try:\n\t        payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.ALGORITHM])\n\t        token_data = TokenPayload(**payload)\n\t        if datetime.fromtimestamp(token_data.exp) < datetime.now():\n\t            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Token expired\",\n\t                                headers={\"WWW-Authenticate\": \"Bearer\"})\n", "    except(jwt.JWTError, ValidationError):\n\t        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Could not validate credentials\",\n\t                            headers={\"WWW-Authenticate\": \"Bearer\"})\n\t    user = await UserService.get_user_by_id(token_data.sub)\n\t    if not user:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Could not find user\")\n\t    return user\n"]}
{"filename": "backend/app/api/auth/jwt.py", "chunked_list": ["from datetime import datetime\n\tfrom fastapi import APIRouter, Depends, HTTPException, status, Body\n\tfrom fastapi.security import OAuth2PasswordRequestForm\n\tfrom typing import Any\n\tfrom jose import jwt\n\tfrom pydantic import ValidationError\n\tfrom ..deps import get_current_user\n\tfrom ...core import settings, create_access_token, create_refresh_token\n\tfrom ...models import User\n\t# from ...services.user_services import UserService\n", "from ...services import UserService\n\t# from ...core.security import create_refresh_token, create_access_token\n\tfrom ...schemas import TokenSchema, TokenPayload, UserOut\n\tauth_router = APIRouter()\n\t@auth_router.post('/login', summary=\"Create access and refresh token\", response_model=TokenSchema)\n\tasync def login(form_data: OAuth2PasswordRequestForm = Depends()) -> Any:\n\t    user = await UserService.authenticate(email=form_data.username, password=form_data.password)\n\t    if not user:\n\t        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"incorrect email or password\")\n\t    # create a access and refresh token\n", "    return {\n\t        \"access_token\": create_access_token(user.user_id),\n\t        \"refresh_token\": create_refresh_token(user.user_id)\n\t    }\n\t@auth_router.post('/test-token', summary=\"test if the access token is vaild\", response_model=UserOut)\n\tasync def tset_token(user: User = Depends(get_current_user)):\n\t    return user\n\t@auth_router.post('/refresh', summary=\"refresh token\", response_model=TokenSchema)\n\tasync def refresh_token(refresh_token:str = Body(...)):\n\t    try:\n", "        payload = jwt.decode(refresh_token, settings.JWT_REFRESH_SECRET_KEY, algorithms=[settings.ALGORITHM])\n\t        token_data = TokenPayload(**payload)\n\t        if datetime.fromtimestamp(token_data.exp) < datetime.now():\n\t            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Token expired\",\n\t                                headers={\"WWW-Authenticate\": \"Bearer\"})\n\t    except(jwt.JWTError, ValidationError):\n\t        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Could not validate credentials\",\n\t                            headers={\"WWW-Authenticate\": \"Bearer\"})\n\t    user = await UserService.get_user_by_id(token_data.sub)\n\t    if not user:\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Could not find user\")\n\t    return {\n\t        \"access_token\":create_access_token(user.user_id),\n\t        \"refresh_token\": create_refresh_token(user.user_id)\n\t    }\n"]}
{"filename": "backend/app/api/auth/__init__.py", "chunked_list": ["from .jwt import auth_router\n\t__all__= ['auth_router']"]}
{"filename": "backend/app/api/api_v1/router.py", "chunked_list": ["from fastapi import APIRouter\n\tfrom .handlers import user_router, todo_router\n\tfrom ..auth import auth_router\n\trouter = APIRouter()\n\trouter.include_router(user_router, prefix='/users', tags=['users'])\n\trouter.include_router(auth_router, prefix='/auth', tags=['auth'])\n\trouter.include_router(todo_router, prefix='/todo', tags=['todo'])\n"]}
{"filename": "backend/app/api/api_v1/__init__.py", "chunked_list": ["from .router import router\n\t__all__ =['router']"]}
{"filename": "backend/app/api/api_v1/handlers/__init__.py", "chunked_list": ["from .todo import todo_router\n\tfrom .user import user_router\n\t__all__ =['todo_router', 'user_router']"]}
{"filename": "backend/app/api/api_v1/handlers/user.py", "chunked_list": ["from fastapi import APIRouter, HTTPException, status\n\tfrom ....schemas import UserAuth, UserOut\n\tfrom ....services import UserService\n\timport pymongo\n\tuser_router = APIRouter()\n\t@user_router.post('/create', summary=\"create new user\", response_model=UserOut)\n\tasync def create_user(data: UserAuth):\n\t    try:\n\t        return await UserService.create_user(data)\n\t    except pymongo.errors.DuplicateKeyError:\n", "        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,\n\t                            detail='user will this email or username already exits')\n"]}
{"filename": "backend/app/api/api_v1/handlers/todo.py", "chunked_list": ["from uuid import UUID\n\tfrom typing import List\n\tfrom fastapi import APIRouter, Depends\n\tfrom ....schemas import TodoOut, TodoUpdate, TodoCreate\n\tfrom ....models import User, Todo\n\tfrom ...deps import get_current_user\n\tfrom ....services.todo_services import TodoService\n\ttodo_router = APIRouter()\n\t@todo_router.get('/', summary=\"Get all todos of user\", response_model=List[TodoOut])\n\tasync def list(current_user: User = Depends(get_current_user)):\n", "    return await TodoService.list_todos(current_user)\n\t@todo_router.post('/create', summary=\"create todo\", response_model=Todo)\n\tasync def create_todo(data: TodoCreate, current_user: User = Depends(get_current_user)):\n\t    return await TodoService.create_todo(current_user, data)\n\t@todo_router.get('/{todo_id}', summary=\"get a todo by todo_id\", response_model=TodoOut)\n\tasync def retrieve(todo_id: UUID, current_user: User = Depends(get_current_user)):\n\t    return await TodoService.retrieve_todo(current_user, todo_id)\n\t@todo_router.put('/{todo_id}', summary=\"Update todo by todo_id\", response_model=TodoOut)\n\tasync def update(todo_id: UUID, data: TodoUpdate, current_user: User = Depends(get_current_user)):\n\t    return await TodoService.update_todo(current_user, todo_id, data)\n", "@todo_router.delete('/{todo_id}', summary=\"delete todo by todo_id\")\n\tasync def delete(todo_id: UUID, current_user: User = Depends(get_current_user)):\n\t    await TodoService.delete_todo(current_user, todo_id)\n\t    return None\n"]}
{"filename": "backend/app/services/__init__.py", "chunked_list": ["from .todo_services import TodoService\n\tfrom .user_services import UserService\n\t__all__ = ['TodoService', 'UserService']"]}
{"filename": "backend/app/services/user_services.py", "chunked_list": ["from typing import Optional\n\tfrom uuid import UUID\n\tfrom ..schemas import UserAuth\n\tfrom ..models import User\n\tfrom ..core import get_password, verify_password\n\tclass UserService:\n\t    @staticmethod\n\t    async def create_user(user: UserAuth):\n\t        user_in = User(\n\t            username=user.username,\n", "            email=user.email,\n\t            hashed_password=get_password(user.password)\n\t        )\n\t        await user_in.save()\n\t        return user_in\n\t    @staticmethod\n\t    async def authenticate(email: str, password: str) -> Optional[User]:\n\t        user = await UserService.get_user_by_email(email)\n\t        if not user:\n\t            return None\n", "        if not verify_password(password=password, hashed_password=user.hashed_password):\n\t            return None\n\t        return user\n\t    @staticmethod\n\t    async def get_user_by_email(email: str) -> Optional[User]:\n\t        user = await User.find_one(User.email == email)\n\t        return user\n\t    async def get_user_by_id(id: UUID) -> Optional[User]:\n\t        user = await User.find_one(User.user_id == id)\n\t        return user\n"]}
{"filename": "backend/app/services/todo_services.py", "chunked_list": ["from uuid import UUID\n\tfrom ..models import Todo,User\n\t# from ..schemas.todo_schema import TodoCreate, TodoUpdate\n\tfrom ..schemas import TodoCreate,TodoUpdate\n\tclass TodoService:\n\t    @staticmethod\n\t    async def list_todos(user: User):\n\t        todos = await Todo.find(Todo.owner.id == user.id).to_list()\n\t        return todos\n\t    @staticmethod\n", "    async def create_todo(user: User, data: TodoCreate) -> Todo:\n\t        todo = Todo(**data.dict(), owner=user)\n\t        return await todo.insert()\n\t    @staticmethod\n\t    async def retrieve_todo(current_user: User, todo_id: UUID):\n\t        todo = await Todo.find_one(Todo.todo_id == todo_id, Todo.owner.id == current_user.id)\n\t        return todo\n\t    @staticmethod\n\t    async def update_todo(current_user: User, todo_id: UUID, data: TodoUpdate):\n\t        todo = await TodoService.retrieve_todo(current_user, todo_id)\n", "        await todo.update({\"$set\": data.dict(exclude_unset=True)})\n\t        await todo.save()\n\t        return todo\n\t    @staticmethod\n\t    async def delete_todo(current_user: User, todo_id: UUID):\n\t        todo = await TodoService.retrieve_todo(current_user, todo_id)\n\t        if todo:\n\t            await todo.delete()\n\t        return None\n"]}
