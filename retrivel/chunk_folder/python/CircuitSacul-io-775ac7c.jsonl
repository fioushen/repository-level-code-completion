{"filename": "noxfile.py", "chunked_list": ["import nox\n\tdef install_poetry_groups(session: nox.Session, *groups: str) -> None:\n\t    session.run(\"poetry\", \"install\", f\"--with={','.join(groups)}\")\n\t@nox.session\n\tdef typecheck(session: nox.Session) -> None:\n\t    install_poetry_groups(session, \"typing\")\n\t    session.run(\"mypy\", \".\")\n\t@nox.session\n\tdef lint(session: nox.Session) -> None:\n\t    install_poetry_groups(session, \"linting\")\n", "    session.run(\"black\", \"--check\", \".\")\n\t    session.run(\"ruff\", \"check\", \".\")\n\t    session.run(\"codespell\", \".\")\n\t@nox.session\n\tdef fix(session: nox.Session) -> None:\n\t    install_poetry_groups(session, \"linting\")\n\t    session.run(\"black\", \".\")\n\t    session.run(\"ruff\", \"check\", \"--fix\", \".\")\n\t    session.run(\"codespell\", \"-w\", \"-i2\", \".\")\n"]}
{"filename": "bot/manager.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\timport typing as t\n\tfrom bot import models\n\tfrom bot.providers.godbolt import GodBolt\n\tfrom bot.providers.piston import Piston\n\tfrom bot.providers.provider import Provider\n\tif t.TYPE_CHECKING:\n\t    from bot.app import Model\n\tclass Manager:\n", "    def __init__(self, model: Model) -> None:\n\t        self.piston_provider = Piston(model)\n\t        self.providers: list[Provider] = [GodBolt(model), self.piston_provider]\n\t        self.runtimes = models.RuntimeTree()\n\t        self.model = model\n\t    async def startup(self) -> None:\n\t        await asyncio.gather(\n\t            *(asyncio.create_task(p.startup()) for p in self.providers)\n\t        )\n\t    async def shutdown(self) -> None:\n", "        await asyncio.gather(\n\t            *(asyncio.create_task(p.shutdown()) for p in self.providers)\n\t        )\n\t    async def update_data(self) -> None:\n\t        await asyncio.gather(\n\t            *(asyncio.create_task(p.update_data()) for p in self.providers)\n\t        )\n\t        runtimes = models.RuntimeTree()\n\t        for provider in self.providers:\n\t            runtimes.extend(provider.runtimes)\n", "        runtimes.sort()\n\t        self.runtimes = runtimes\n\t    def unalias(self, language: str) -> str | None:\n\t        if language in self.runtimes.run or language in self.runtimes.asm:\n\t            return language\n\t        return self.piston_provider.aliases.get(language)\n"]}
{"filename": "bot/__main__.py", "chunked_list": ["from bot.app import main\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "bot/app.py", "chunked_list": ["import crescent\n\timport hikari\n\tfrom bot.config import CONFIG\n\tfrom bot.manager import Manager\n\tPlugin = crescent.Plugin[hikari.GatewayBot, \"Model\"]\n\tINTENTS = hikari.Intents.ALL_UNPRIVILEGED | hikari.Intents.MESSAGE_CONTENT\n\tclass Model:\n\t    def __init__(self) -> None:\n\t        self.manager = Manager(self)\n\t    async def startup(self) -> None:\n", "        await self.manager.startup()\n\t    async def shutdown(self) -> None:\n\t        await self.manager.shutdown()\n\tdef main() -> None:\n\t    app = hikari.GatewayBot(CONFIG.TOKEN, intents=INTENTS)\n\t    client = crescent.Client(app, model := Model())\n\t    @app.listen(hikari.StartingEvent)\n\t    async def _(_: hikari.StartingEvent) -> None:\n\t        await model.startup()\n\t    @app.listen(hikari.StoppingEvent)\n", "    async def _(_: hikari.StoppingEvent) -> None:\n\t        await model.shutdown()\n\t    client.plugins.load_folder(\"bot.plugins\")\n\t    app.run()\n"]}
{"filename": "bot/config.py", "chunked_list": ["import dataclasses\n\timport typing as t\n\timport dotenv\n\t@dataclasses.dataclass\n\tclass Config:\n\t    TOKEN: str\n\t    PISTON_URL: str = \"https://emkc.org/api/v2/piston/\"\n\t    GODBOLT_URL: str = \"https://godbolt.org/api/\"\n\tenv_vars: dict[str, str] = t.cast(dict[str, str], dotenv.dotenv_values())\n\ttry:\n", "    CONFIG = Config(**env_vars)\n\texcept TypeError as e:\n\t    raise Exception(\n\t        \"You have an error in your .env file. Check the README for more info.\"\n\t    ) from e\n"]}
{"filename": "bot/models.py", "chunked_list": ["from __future__ import annotations\n\timport functools\n\timport re\n\timport typing as t\n\tfrom collections import defaultdict\n\tfrom dataclasses import dataclass, field\n\tfrom enum import Enum, auto\n\timport dahlia\n\tfrom bot.providers.provider import Provider\n\tfrom bot.utils.display import format_text\n", "class Action(Enum):\n\t    RUN = auto()\n\t    ASM = auto()\n\t@dataclass\n\tclass Runtime:\n\t    id: str\n\t    name: str\n\t    description: str\n\t    provider: Provider\n\t@dataclass\n", "class Code:\n\t    code: str\n\t    filename: t.Optional[str] = None\n\t    language: t.Optional[str] = None\n\t@dataclass\n\tclass Result:\n\t    output: str\n\t    def format(self) -> str:\n\t        out = format_text(self.output)\n\t        try:\n", "            out = dahlia.quantize_ansi(out, to=3)\n\t        except Exception:\n\t            pass\n\t        return out\n\tTREE_T = t.Dict[\n\t    str | None,  # language\n\t    t.Dict[\n\t        str | None,  # Instruction Set\n\t        t.Dict[\n\t            str | None,  # Compiler Type\n", "            t.Dict[\n\t                str | None,  # Version\n\t                Runtime,\n\t            ],\n\t        ],\n\t    ],\n\t]\n\tdef make_tree() -> TREE_T:\n\t    return defaultdict(lambda: defaultdict(lambda: defaultdict(dict)))\n\t@dataclass\n", "class RuntimeTree:\n\t    asm: TREE_T = field(default_factory=make_tree)\n\t    run: TREE_T = field(default_factory=make_tree)\n\t    def extend(self, other: RuntimeTree) -> None:\n\t        for this_tree, other_tree in [(self.asm, other.asm), (self.run, other.run)]:\n\t            for lang, tree in other_tree.items():\n\t                for compiler, tree2 in tree.items():\n\t                    for instruction, tree3 in tree2.items():\n\t                        for version, runtime in tree3.items():\n\t                            this_tree[lang][compiler][instruction][version] = runtime\n", "    def sort(self) -> None:\n\t        self.asm = sort(self.asm)\n\t        self.run = sort(self.run)\n\tK = t.TypeVar(\"K\")\n\tT = t.TypeVar(\"T\")\n\tSEMVER_RE = re.compile(r\"(\\d+)(\\.(\\d+))+\")\n\t@dataclass\n\t@functools.total_ordering\n\tclass Key:\n\t    semver: t.Optional[list[int]]\n", "    string: str\n\t    def __lt__(self, other: object) -> bool:\n\t        assert isinstance(other, Key)\n\t        if self.semver and other.semver:\n\t            return self.semver < other.semver\n\t        if self.string == \"piston\":\n\t            return True\n\t        elif other.string == \"piston\":\n\t            return False\n\t        return self.string > other.string\n", "    def __eq__(self, other: object) -> bool:\n\t        return False\n\tdef sort(item: dict[K, T]) -> dict[K, T]:\n\t    def key(item: tuple[K, object]) -> Key:\n\t        key = item[0]\n\t        if isinstance(key, str):\n\t            if m := SEMVER_RE.search(key):\n\t                version = [int(i) for i in m.group().split(\".\")]\n\t                return Key(version, key)\n\t        return Key([], str(key))\n", "    item = {k: v for k, v in sorted(item.items(), key=key, reverse=True)}\n\t    for k, v in item.items():\n\t        if isinstance(v, dict):\n\t            item[k] = t.cast(T, sort(v))\n\t    return item\n"]}
{"filename": "bot/lang_defaults.py", "chunked_list": ["DEFAULTS = {\n\t    \"python\": \"piston\",\n\t    \"rust\": {\"amd64\": \"rust\"},\n\t    \"go\": {\"amd64\": \"none\"},\n\t    \"typescript\": \"piston\",\n\t    \"c\": {\n\t        \"amd64\": {\n\t            \"clang-intel\": \"16.0.0\",\n\t            \"clang\": \"16.0.0\",\n\t        },\n", "        \"aarch64\": {\"clang\": \"16.0.0\"},\n\t    },\n\t    \"c++\": {\n\t        \"amd64\": {\n\t            \"clang-intel\": \"16.0.0\",\n\t            \"clang\": \"16.0.0\",\n\t        },\n\t        \"aarch64\": {\n\t            \"clang\": \"16.0.0\",\n\t        },\n", "    },\n\t}\n"]}
{"filename": "bot/__init__.py", "chunked_list": []}
{"filename": "bot/constants.py", "chunked_list": ["import hikari\n\tEMBED_COLOR = hikari.Color(0xF7B159)\n"]}
{"filename": "bot/plugins/instance.py", "chunked_list": ["from __future__ import annotations\n\timport contextlib\n\timport enum\n\timport typing as t\n\tfrom dataclasses import dataclass, field\n\timport crescent\n\timport hikari\n\tfrom bot import models\n\tfrom bot.app import Plugin\n\tfrom bot.lang_defaults import DEFAULTS\n", "from bot.utils import parse\n\tplugin = Plugin()\n\tinstances: dict[hikari.Snowflake, Instance] = {}\n\tK = t.TypeVar(\"K\")\n\tV = t.TypeVar(\"V\")\n\tclass ComponentID(enum.StrEnum):\n\t    DELETE = \"delete\"\n\t    REFRESH_CODE = \"refresh_code\"\n\t    CODE_BLOCK = \"code_block\"\n\t    LANGUAGE = \"language\"\n", "    TOGGLE_MODE = \"toggle_mode\"\n\t    INSTRUCTION_SET = \"instruction_set\"\n\t    COMPILER_TYPE = \"compiler_type\"\n\t    VERSION = \"version\"\n\t    STDIN = \"stdin\"\n\tclass ModalID(enum.StrEnum):\n\t    LANGUAGE = \"language\"\n\t    STDIN = \"stdin\"\n\tdef next_in_default_chain(path: list[str | None]) -> str | None:\n\t    tree = DEFAULTS\n", "    for k in path:\n\t        if isinstance(tree, str):\n\t            return None\n\t        tree = tree.get(k)  # type: ignore\n\t        if not tree:\n\t            return None\n\t    if isinstance(tree, str):\n\t        return tree\n\t    elif isinstance(tree, dict):\n\t        return next(iter(tree.keys()))\n", "    return None\n\tdef get_or_first(\n\t    dct: dict[str | None, V], key: str | None, path: list[str | None]\n\t) -> tuple[str | None, V] | None:\n\t    with contextlib.suppress(KeyError):\n\t        return (key, dct[key])\n\t    if k := next_in_default_chain(path):\n\t        with contextlib.suppress(KeyError):\n\t            return (k, dct[k])\n\t    with contextlib.suppress(StopIteration):\n", "        return next(iter(dct.items()))\n\t    return None\n\t@plugin.include\n\t@crescent.event\n\tasync def on_modal_interaction(event: hikari.InteractionCreateEvent) -> None:\n\t    if not isinstance(event.interaction, hikari.ModalInteraction):\n\t        return\n\t    if not (message := event.interaction.message):\n\t        return\n\t    if not (inst := instances.get(message.id)):\n", "        return\n\t    id = event.interaction.custom_id\n\t    match id:\n\t        case ModalID.LANGUAGE:\n\t            lang: str | None = event.interaction.components[0].components[0].value\n\t            if not lang:\n\t                if inst.code:\n\t                    lang = inst.code.language\n\t                else:\n\t                    lang = None\n", "                inst.update_language(lang, False)\n\t            else:\n\t                inst.update_language(lang, True)\n\t        case ModalID.STDIN:\n\t            inst.stdin = event.interaction.components[0].components[0].value\n\t    await event.app.rest.create_interaction_response(\n\t        event.interaction,\n\t        event.interaction.token,\n\t        hikari.ResponseType.MESSAGE_UPDATE,\n\t        components=inst.components(),\n", "        content=\"Working...\",\n\t        attachment=None,\n\t    )\n\t    await inst.execute()\n\t@plugin.include\n\t@crescent.event\n\tasync def on_component_interaction(event: hikari.InteractionCreateEvent) -> None:\n\t    if not isinstance(event.interaction, hikari.ComponentInteraction):\n\t        return\n\t    if not (inst := instances.get(event.interaction.message.id)):\n", "        return\n\t    if event.interaction.user.id != inst.requester:\n\t        await event.app.rest.create_interaction_response(\n\t            event.interaction,\n\t            event.interaction.token,\n\t            hikari.ResponseType.MESSAGE_CREATE,\n\t            flags=hikari.MessageFlag.EPHEMERAL,\n\t            content=\"Only the person who created this instance can edit it.\",\n\t        )\n\t        return\n", "    id = event.interaction.custom_id\n\t    match id:\n\t        case ComponentID.DELETE:\n\t            await inst.delete()\n\t            return\n\t        case ComponentID.REFRESH_CODE:\n\t            message = await plugin.app.rest.fetch_message(inst.channel, inst.message)\n\t            await inst.update(message)\n\t        case ComponentID.CODE_BLOCK:\n\t            if v := event.interaction.values:\n", "                for x, block in enumerate(inst.codes):\n\t                    if str(x) == v[0]:\n\t                        inst.update_code(block)\n\t                        break\n\t            else:\n\t                if inst.codes:\n\t                    inst.update_code(inst.codes[0])\n\t        case ComponentID.LANGUAGE:\n\t            await event.app.rest.create_modal_response(\n\t                event.interaction,\n", "                event.interaction.token,\n\t                title=\"Select Language\",\n\t                custom_id=ModalID.LANGUAGE,\n\t                component=event.app.rest.build_modal_action_row().add_text_input(\n\t                    ModalID.LANGUAGE,\n\t                    \"Language\",\n\t                    placeholder=\"Leave empty to use the default.\",\n\t                    required=False,\n\t                ),\n\t            )\n", "            return\n\t        case ComponentID.TOGGLE_MODE:\n\t            if inst.action is models.Action.RUN:\n\t                inst.update_action(models.Action.ASM)\n\t            else:\n\t                inst.update_action(models.Action.RUN)\n\t        case ComponentID.INSTRUCTION_SET:\n\t            if v := event.interaction.values:\n\t                inst.instruction_set = v[0]\n\t            else:\n", "                inst.instruction_set = None\n\t            inst.compiler_type = None\n\t            inst.version = None\n\t        case ComponentID.COMPILER_TYPE:\n\t            if v := event.interaction.values:\n\t                inst.compiler_type = v[0]\n\t            else:\n\t                inst.compiler_type = None\n\t            inst.version = None\n\t        case ComponentID.VERSION:\n", "            if v := event.interaction.values:\n\t                inst.version = v[0]\n\t            else:\n\t                inst.version = None\n\t        case ComponentID.STDIN:\n\t            await event.app.rest.create_modal_response(\n\t                event.interaction,\n\t                event.interaction.token,\n\t                title=\"Set STDIN\",\n\t                custom_id=ModalID.STDIN,\n", "                component=event.app.rest.build_modal_action_row().add_text_input(\n\t                    ModalID.STDIN,\n\t                    \"Set STDIN\",\n\t                    value=inst.stdin or hikari.UNDEFINED,\n\t                    required=False,\n\t                    style=hikari.TextInputStyle.PARAGRAPH,\n\t                ),\n\t            )\n\t            return\n\t    await event.app.rest.create_interaction_response(\n", "        event.interaction,\n\t        event.interaction.token,\n\t        hikari.ResponseType.MESSAGE_UPDATE,\n\t        content=\"Working...\",\n\t        attachment=None,\n\t        components=inst.components(),\n\t    )\n\t    await inst.execute()\n\tT = t.TypeVar(\"T\")\n\t@dataclass\n", "class Setting(t.Generic[T]):\n\t    v: T\n\t    overwritten: bool = False\n\t    def update(self, v: T) -> None:\n\t        self.v = v\n\t        self.overwritten = False\n\t    def user_update(self, v: T) -> None:\n\t        self.v = v\n\t        self.overwritten = True\n\t    @classmethod\n", "    def make(cls, v: T) -> Setting[T]:\n\t        return field(default_factory=lambda: cls(v))\n\tclass Selector(t.NamedTuple):\n\t    id: ComponentID\n\t    \"\"\"The custom ID for the component used to select this.\"\"\"\n\t    selected: str | None\n\t    \"\"\"The currently selected runtime.\"\"\"\n\t    options: list[str | None]\n\t    \"\"\"A list of all runtimes the user can select.\"\"\"\n\t@dataclass\n", "class Instance:\n\t    channel: hikari.Snowflake\n\t    message: hikari.Snowflake\n\t    requester: hikari.Snowflake\n\t    codes: list[models.Code]\n\t    code: t.Optional[models.Code] = None\n\t    stdin: str | None = None\n\t    language: Setting[t.Optional[str]] = Setting.make(None)\n\t    action: models.Action = models.Action.RUN\n\t    instruction_set: str | None = None\n", "    compiler_type: str | None = None\n\t    version: str | None = None\n\t    response: t.Optional[hikari.Snowflake] = None\n\t    def update_code(self, code: models.Code | None) -> None:\n\t        self.code = code\n\t        if (\n\t            code\n\t            and code.language\n\t            and plugin.model.manager.unalias(code.language.lower()) != self.language.v\n\t            and not self.language.overwritten\n", "        ):\n\t            self.update_language(code.language, False)\n\t    def update_language(self, language: str | None, user: bool) -> None:\n\t        if language:\n\t            language = plugin.model.manager.unalias(language.lower())\n\t        if user:\n\t            self.language.user_update(language)\n\t        else:\n\t            self.language.update(language)\n\t        self.reset_selectors()\n", "    def update_action(self, action: models.Action) -> None:\n\t        self.action = action\n\t    def reset_selectors(self) -> None:\n\t        self.instruction_set = None\n\t        self.compiler_type = None\n\t        self.version = None\n\t    def selectors(self) -> list[Selector]:\n\t        if self.language.v is None:\n\t            return []\n\t        selectors: list[Selector] = []\n", "        runtimes = plugin.model.manager.runtimes\n\t        match self.action:\n\t            case models.Action.RUN:\n\t                tree = runtimes.run\n\t            case models.Action.ASM:\n\t                tree = runtimes.asm\n\t        path: list[str | None] = []\n\t        if instructions := tree.get(self.language.v):\n\t            path.append(self.language.v)\n\t            if instruction_set_select := get_or_first(\n", "                instructions, self.instruction_set, path\n\t            ):\n\t                instruction_set, compilers = instruction_set_select\n\t                if len(instructions) > 1:\n\t                    selectors.append(\n\t                        Selector(\n\t                            id=ComponentID.INSTRUCTION_SET,\n\t                            selected=instruction_set,\n\t                            options=list(instructions),\n\t                        )\n", "                    )\n\t                path.append(instruction_set)\n\t                if compiler_type_select := get_or_first(\n\t                    compilers, self.compiler_type, path\n\t                ):\n\t                    compiler, versions = compiler_type_select\n\t                    if len(compilers) > 1:\n\t                        selectors.append(\n\t                            Selector(\n\t                                id=ComponentID.COMPILER_TYPE,\n", "                                selected=compiler,\n\t                                options=list(compilers),\n\t                            )\n\t                        )\n\t                    path.append(compiler)\n\t                    if version_select := get_or_first(versions, self.version, path):\n\t                        version, _ = version_select\n\t                        selectors.append(\n\t                            Selector(\n\t                                id=ComponentID.VERSION,\n", "                                selected=version,\n\t                                options=list(versions),\n\t                            )\n\t                        )\n\t        return selectors\n\t    @property\n\t    def runtime(self) -> models.Runtime | None:\n\t        lang = self.language.v\n\t        match self.action:\n\t            case models.Action.RUN:\n", "                tree = plugin.model.manager.runtimes.run\n\t            case models.Action.ASM:\n\t                tree = plugin.model.manager.runtimes.asm\n\t        path: list[str | None] = [lang]\n\t        if not (tree2 := tree.get(lang)):\n\t            return None\n\t        if not (tree3 := get_or_first(tree2, self.instruction_set, path)):\n\t            return None\n\t        self.instruction_set = tree3[0]\n\t        path.append(tree3[0])\n", "        if not (tree4 := get_or_first(tree3[1], self.compiler_type, path)):\n\t            return None\n\t        self.compiler_type = tree4[0]\n\t        path.append(tree4[0])\n\t        tree5 = get_or_first(tree4[1], self.version, path)\n\t        if tree5:\n\t            self.version = tree5[0]\n\t            return tree5[1]\n\t        else:\n\t            return None\n", "    @staticmethod\n\t    async def from_original(\n\t        message: hikari.Message,\n\t        requester: hikari.Snowflake,\n\t    ) -> Instance | None:\n\t        codes = await parse.get_codes(message)\n\t        if not codes:\n\t            return None\n\t        instance = Instance(message.channel_id, message.id, requester, codes)\n\t        instance.update_code(codes[0])\n", "        return instance\n\t    async def delete(self) -> None:\n\t        if not self.response:\n\t            return\n\t        try:\n\t            await plugin.app.rest.delete_message(self.channel, self.response)\n\t        except hikari.NotFoundError:\n\t            pass\n\t        else:\n\t            del instances[self.response]\n", "    async def update(self, message: hikari.Message) -> None:\n\t        if not (codes := await parse.get_codes(message)):\n\t            await self.delete()\n\t            return\n\t        self.codes = codes\n\t        self.update_code(codes[0])\n\t    def components(self) -> list[hikari.api.MessageActionRowBuilder]:\n\t        rows = []\n\t        # basic buttons\n\t        rows.append(\n", "            plugin.app.rest.build_message_action_row()\n\t            .add_interactive_button(\n\t                hikari.ButtonStyle.SECONDARY, ComponentID.DELETE, label=\"Delete\"\n\t            )\n\t            .add_interactive_button(\n\t                hikari.ButtonStyle.SECONDARY,\n\t                ComponentID.REFRESH_CODE,\n\t                label=\"Refresh Code\",\n\t            )\n\t            .add_interactive_button(\n", "                hikari.ButtonStyle.SECONDARY,\n\t                ComponentID.TOGGLE_MODE,\n\t                label=\"Mode: Execute\"\n\t                if self.action is models.Action.RUN\n\t                else \"Mode: ASM\",\n\t            )\n\t            .add_interactive_button(\n\t                hikari.ButtonStyle.SECONDARY,\n\t                ComponentID.LANGUAGE,\n\t                label=f\"Language: {self.language.v or 'Unknown'}\",\n", "            )\n\t            .add_interactive_button(\n\t                hikari.ButtonStyle.SECONDARY,\n\t                ComponentID.STDIN,\n\t                label=\"Set STDIN\",\n\t            )\n\t        )\n\t        # code block selection\n\t        if len(self.codes) > 1:\n\t            select = plugin.app.rest.build_message_action_row().add_text_menu(\n", "                ComponentID.CODE_BLOCK,\n\t                placeholder=\"Select the code block to run\",\n\t            )\n\t            for x, block in enumerate(self.codes):\n\t                if block.filename:\n\t                    label = f\"Attachment {block.filename}\"\n\t                else:\n\t                    label = f'Code Block: \"{block.code[0:32]}...\"'\n\t                select.add_option(label, str(x), is_default=block == self.code)\n\t            rows.append(select.parent)\n", "        # version\n\t        for id, selected, options in self.selectors():\n\t            select = (\n\t                plugin.app.rest.build_message_action_row()\n\t                .add_text_menu(id)\n\t                .set_is_disabled(len(options) == 1)\n\t            )\n\t            for option in options[0:25]:\n\t                select.add_option(\n\t                    str(option), str(option), is_default=option == selected\n", "                )\n\t            rows.append(select.parent)\n\t        return rows\n\t    async def execute(self) -> None:\n\t        if not self.response:\n\t            await plugin.app.rest.trigger_typing(self.channel)\n\t        # try to execute code\n\t        code_file: hikari.Bytes | None = None\n\t        stdin_file: hikari.Bytes | None = None\n\t        out: list[str] = [f\"<@{self.requester}>\"]\n", "        code_output_in_file = False\n\t        stdin_in_file = False\n\t        code_output: str = \"\"\n\t        if self.runtime:\n\t            ret = await self.runtime.provider.execute(self)\n\t            code_output = ret.format()\n\t            if not code_output.strip():\n\t                out.append(\"Your code ran with no output.\")\n\t                code_output = \"\"\n\t        else:\n", "            out.append(\"No runtime selected.\")\n\t        stdin = self.stdin or \"\"\n\t        formatted_stdin = \"\\n\".join(\n\t            f\"\\x1b[1;33mIN:\\x1b[0m {line}\" for line in stdin.splitlines()\n\t        )\n\t        if len(code_output) + len(formatted_stdin) > 1_950:\n\t            if len(code_output) < 1_950:\n\t                stdin_in_file = True\n\t            elif len(formatted_stdin) < 1_950:\n\t                code_output_in_file = True\n", "            else:\n\t                code_output_in_file = True\n\t                stdin_in_file = True\n\t        if code_output:\n\t            if code_output_in_file:\n\t                code_file = hikari.Bytes(code_output, \"code.ansi\")\n\t            else:\n\t                out.append(f\"```ansi\\n{code_output}```\")\n\t        if stdin:\n\t            if stdin_in_file:\n", "                stdin_file = hikari.Bytes(stdin, \"stdin.txt\")\n\t            else:\n\t                out.append(f\"```ansi\\n{formatted_stdin}```\")\n\t        # send message\n\t        out_str = \"\\n\".join(out)\n\t        rows = self.components()\n\t        attachments = list(filter(None, [code_file, stdin_file]))\n\t        if self.response:\n\t            await plugin.app.rest.edit_message(\n\t                self.channel,\n", "                self.response,\n\t                out_str,\n\t                components=rows,\n\t                attachments=attachments or None,\n\t            )\n\t        else:\n\t            resp = await plugin.app.rest.create_message(\n\t                self.channel,\n\t                out_str,\n\t                reply=self.message,\n", "                components=rows,\n\t                attachments=attachments,\n\t                user_mentions=[self.requester],\n\t            )\n\t            self.response = resp.id\n\t            instances[resp.id] = self\n"]}
{"filename": "bot/plugins/help.py", "chunked_list": ["import crescent\n\timport hikari\n\tfrom bot.app import Plugin\n\tfrom bot.constants import EMBED_COLOR\n\tplugin = Plugin()\n\tHELP_EMBEDS = [\n\t    hikari.Embed(\n\t        description=(\n\t            \"Hi! My name is io, and my job is to run code.\"\n\t            \"\\n I can run any code inside of code blocks:\"\n", "            \"\\n```\"\n\t            \"\\n`\\u200b`\\u200b`\\u200b<language-name>\"\n\t            \"\\n<your code here>\"\n\t            \"\\n`\\u200b`\\u200b`\\u200b\"\n\t            \"\\n```\"\n\t        ),\n\t        color=EMBED_COLOR,\n\t    ),\n\t    hikari.Embed(\n\t        description=(\n", "            \"\\n- Running code - Start your message with `io/run`.\"\n\t            \"\\n- View Assembly - Start your message with `io/asm`.\"\n\t            \"\\nYou can use message commands by right-clicking on a message, \"\n\t            \"selecting the `Apps` subcategory, then clicking on the `Create Instance` \"\n\t            \"command.\"\n\t        ),\n\t        color=EMBED_COLOR,\n\t    ),\n\t]\n\t@plugin.include\n", "@crescent.command\n\tasync def help(ctx: crescent.Context) -> None:\n\t    await ctx.respond(embeds=HELP_EMBEDS)\n\t@plugin.include\n\t@crescent.event\n\tasync def on_message(message: hikari.MessageCreateEvent) -> None:\n\t    me = plugin.app.get_me()\n\t    if not me:\n\t        return\n\t    if not message.is_human:\n", "        return\n\t    if not message.content:\n\t        return\n\t    if not (\n\t        message.content == me.mention\n\t        or message.content == \"io/help\"\n\t        or (\n\t            message.content.startswith(me.mention)\n\t            and message.content.removeprefix(me.mention).strip() == \"help\"\n\t        )\n", "    ):\n\t        return\n\t    await message.message.respond(embeds=HELP_EMBEDS, reply=True)\n"]}
{"filename": "bot/plugins/events.py", "chunked_list": ["import crescent\n\timport hikari\n\tfrom bot import models\n\tfrom bot.app import Plugin\n\tfrom bot.plugins.instance import Instance\n\tplugin = Plugin()\n\t@plugin.include\n\t@crescent.event\n\tasync def on_message(event: hikari.MessageCreateEvent) -> None:\n\t    if not event.is_human:\n", "        return None\n\t    if not (ct := event.message.content):\n\t        return None\n\t    if not ct.startswith(\"io/\"):\n\t        return None\n\t    try:\n\t        cmd = ct[3:].splitlines()[0].split(\" \", 1)[0]\n\t    except KeyError:\n\t        return None\n\t    match cmd:\n", "        case \"run\":\n\t            action = models.Action.RUN\n\t        case \"asm\":\n\t            action = models.Action.ASM\n\t        case _:\n\t            return None\n\t    instance = await Instance.from_original(event.message, event.author_id)\n\t    if not instance:\n\t        return\n\t    instance.action = action\n", "    await instance.execute()\n"]}
{"filename": "bot/plugins/tasks.py", "chunked_list": ["from crescent.ext import tasks\n\tfrom bot.app import Plugin\n\tplugin = Plugin()\n\t@plugin.include\n\t@tasks.loop(minutes=30)\n\tasync def update_languages() -> None:\n\t    await plugin.model.manager.update_data()\n"]}
{"filename": "bot/plugins/message_commands.py", "chunked_list": ["import crescent\n\timport hikari\n\tfrom bot.app import Plugin\n\tfrom .instance import Instance\n\tplugin = Plugin()\n\t@plugin.include\n\t@crescent.message_command(name=\"Create Instance\")\n\tasync def create_instance(ctx: crescent.Context, msg: hikari.Message) -> None:\n\t    inst = await Instance.from_original(msg, ctx.user.id)\n\t    if not inst:\n", "        await ctx.respond(\"No code blocks to run could be found.\", ephemeral=True)\n\t        return\n\t    await ctx.respond(\"Instance created.\", ephemeral=True)\n\t    await inst.execute()\n"]}
{"filename": "bot/plugins/__init__.py", "chunked_list": []}
{"filename": "bot/plugins/languages.py", "chunked_list": ["import crescent\n\timport hikari\n\tfrom bot.app import Plugin\n\tfrom bot.constants import EMBED_COLOR\n\tplugin = Plugin()\n\t@plugin.include\n\t@crescent.command\n\tasync def languages(ctx: crescent.Context) -> None:\n\t    lang_names = list(\n\t        f\"`{runtime}`\" for runtime in plugin.model.manager.runtimes.run if runtime\n", "    )\n\t    embed = hikari.Embed(\n\t        title=\"Supported Languages\", description=\",\".join(lang_names), color=EMBED_COLOR\n\t    )\n\t    await ctx.respond(embed=embed)\n"]}
{"filename": "bot/utils/fixes.py", "chunked_list": ["import re\n\tJAVA_PUBLIC_CLASS_REGEX = re.compile(r\"public\\s+class\")\n\tRUST_FN_REGEX = re.compile(r\"fn\\s+main\\s*\\(\\s*\\)\")\n\tZIG_STD_REGEX = re.compile(r\"std\\s*=\")\n\tZIG_MAIN_FN_REGEX = re.compile(r\"fn\\s+main\\s*\\(\\s*\\)\")\n\tdef transform_code(lang: str, code: str) -> str:\n\t    \"\"\"\n\t    Converts the code into new code based on the language and some rules.\n\t    \"\"\"\n\t    match lang:\n", "        case \"java\":\n\t            return JAVA_PUBLIC_CLASS_REGEX.sub(\"class\", code, count=1)\n\t        case \"rust\":\n\t            if not RUST_FN_REGEX.search(code):\n\t                return \"fn main() {\\n\" f\"{code}\\n\" \"}\"\n\t            return code\n\t        case \"zig\":\n\t            if not ZIG_STD_REGEX.search(code):\n\t                header = 'const std = @import(\"std\");'\n\t            else:\n", "                header = \"\"\n\t            if not ZIG_MAIN_FN_REGEX.search(code):\n\t                return f\"{header}\\n\" \"pub fn main() !void { \" f\"{code}\" \"}\"\n\t            return f\"{header}\\n{code}\"\n\t        case _:\n\t            return code\n"]}
{"filename": "bot/utils/__init__.py", "chunked_list": []}
{"filename": "bot/utils/display.py", "chunked_list": ["def format_text(text: str) -> str:\n\t    return (\n\t        # GCC is stupid.\n\t        text.replace(\"\\x1b[K\", \"\")\n\t        # Discord doesn't understand this alias.\n\t        .replace(\"\\x1b[m\", \"\\x1b[0m\")\n\t        # Discord doesn't understand this either.\n\t        .replace(\"\\x1b[01m\", \"\\x1b[1m\")\n\t    )\n"]}
{"filename": "bot/utils/parse.py", "chunked_list": ["from __future__ import annotations\n\timport re\n\timport typing as t\n\tfrom hikari import Attachment, Message\n\tfrom bot import models\n\tCODE_BLOCK_REGEX = re.compile(r\"```(?P<lang>\\w*)[\\n\\s]*(?P<code>(.|\\n)*?)```\")\n\tCODE_LINE_REGEX = re.compile(r\"`(?P<code>[^`\\n]+)`\")\n\tasync def get_codes(message: Message) -> list[models.Code]:\n\t    return [\n\t        *_get_code_blocks(message.content),\n", "        *await _get_code_attachments(message.attachments),\n\t    ]\n\tdef _get_code_blocks(content: str | None) -> list[models.Code]:\n\t    if not content:\n\t        return []\n\t    blocks: list[models.Code] = []\n\t    for block in CODE_BLOCK_REGEX.finditer(content):\n\t        dct = block.groupdict()\n\t        code = models.Code(code=dct[\"code\"])\n\t        if language := dct.get(\"lang\"):\n", "            code.language = language\n\t        blocks.append(code)\n\t    content = CODE_BLOCK_REGEX.sub(\"\", content)\n\t    for line in CODE_LINE_REGEX.finditer(content):\n\t        blocks.append(models.Code(code=line.groupdict()[\"code\"]))\n\t    return blocks\n\tasync def _get_code_attachments(files: t.Sequence[Attachment]) -> list[models.Code]:\n\t    codes: list[models.Code] = []\n\t    for file in files:\n\t        content = await file.read()\n", "        code = models.Code(code=content.decode(), filename=file.filename)\n\t        if extension := file.extension:\n\t            code.language = extension\n\t        codes.append(code)\n\t    return codes\n"]}
{"filename": "bot/providers/__init__.py", "chunked_list": []}
{"filename": "bot/providers/piston.py", "chunked_list": ["from __future__ import annotations\n\timport typing as t\n\timport aiohttp\n\tfrom bot import models\n\tfrom bot.config import CONFIG\n\tfrom bot.providers.provider import Provider\n\tfrom bot.utils.fixes import transform_code\n\tif t.TYPE_CHECKING:\n\t    from bot.app import Model\n\t    from bot.plugins.instance import Instance\n", "class Piston(Provider):\n\t    URL = CONFIG.PISTON_URL\n\t    def __init__(self, model: Model) -> None:\n\t        self.aliases: dict[str, str] = {}\n\t        super().__init__(model)\n\t    async def startup(self) -> None:\n\t        self._session = aiohttp.ClientSession(\n\t            headers={\"content-type\": \"application/json\"}\n\t        )\n\t    async def update_data(self) -> None:\n", "        runtimes = models.RuntimeTree()\n\t        aliases: dict[str, str] = {}\n\t        async with self.session.get(self.URL + \"runtimes/\") as resp:\n\t            resp.raise_for_status()\n\t            for data in await resp.json():\n\t                if \"runtime\" in data:\n\t                    version = \"{}@{}\".format(data[\"runtime\"], data[\"version\"])\n\t                else:\n\t                    version = data[\"version\"]\n\t                runtime = models.Runtime(\n", "                    id=\"{}@{}\".format(data[\"language\"], data[\"version\"]),\n\t                    name=data[\"language\"],\n\t                    description=\"{} {}\".format(data[\"language\"], version),\n\t                    provider=self,\n\t                )\n\t                for alias in data[\"aliases\"]:\n\t                    aliases[alias] = runtime.name\n\t                runtimes.run[data[\"language\"]][\"piston\"][\"piston\"][version] = runtime\n\t        self.aliases = aliases\n\t        self.runtimes = runtimes\n", "    async def execute(self, instance: Instance) -> models.Result:\n\t        assert instance.runtime\n\t        assert instance.language.v\n\t        assert instance.code\n\t        lang, version = instance.runtime.id.split(\"@\")\n\t        post_data = {\n\t            \"language\": lang,\n\t            \"version\": version,\n\t            \"files\": [{\"content\": transform_code(lang, instance.code.code)}],\n\t            \"stdin\": instance.stdin,\n", "        }\n\t        async with self.session.post(self.URL + \"execute\", json=post_data) as resp:\n\t            resp.raise_for_status()\n\t            data = await resp.json()\n\t        return models.Result(\n\t            \"\\n\".join(\n\t                [\n\t                    data.get(\"compile\", {}).get(\"output\", \"\"),\n\t                    data.get(\"run\", {}).get(\"output\", \"\"),\n\t                ]\n", "            )\n\t        )\n"]}
{"filename": "bot/providers/godbolt.py", "chunked_list": ["from __future__ import annotations\n\timport typing as t\n\timport aiohttp\n\tfrom bot import models\n\tfrom bot.config import CONFIG\n\tfrom bot.providers.provider import Provider\n\tfrom bot.utils.fixes import transform_code\n\tif t.TYPE_CHECKING:\n\t    from bot.plugins.instance import Instance\n\tdef parse_response(data: dict[str, t.Any]) -> str:\n", "    berr = get_text(data, \"buildResult\", \"stderr\")\n\t    bout = get_text(data, \"buildResult\", \"stdout\")\n\t    err = get_text(data, \"stderr\")\n\t    out = get_text(data, \"stdout\")\n\t    asm = get_text(data, \"asm\")\n\t    if berr == err:\n\t        berr = None\n\t    if bout == out:\n\t        bout = None\n\t    return join_text(berr, bout, err, out, asm)\n", "def join_text(*texts: str | None) -> str:\n\t    return \"\\n\".join(t for t in texts if t)\n\tdef get_text(obj: object, *path: str) -> str | None:\n\t    for k in path:\n\t        assert isinstance(obj, dict)\n\t        try:\n\t            obj = obj[k]\n\t        except (KeyError, TypeError):\n\t            return None\n\t    assert isinstance(obj, list)\n", "    return \"\\n\".join(line[\"text\"] for line in obj)\n\tclass GodBolt(Provider):\n\t    URL = CONFIG.GODBOLT_URL\n\t    async def startup(self) -> None:\n\t        self._session = aiohttp.ClientSession(headers={\"Accept\": \"application/json\"})\n\t    async def update_data(self) -> None:\n\t        runtimes = models.RuntimeTree()\n\t        async with self.session.get(self.URL + \"compilers/\") as resp:\n\t            resp.raise_for_status()\n\t            for data in await resp.json():\n", "                runtime = models.Runtime(\n\t                    id=data[\"id\"],\n\t                    name=data[\"name\"],\n\t                    description=\"{}/{}/{}/{}\".format(\n\t                        data[\"lang\"],\n\t                        data[\"instructionSet\"] or \"none\",\n\t                        data[\"compilerType\"] or \"none\",\n\t                        data[\"semver\"] or \"none\",\n\t                    ),\n\t                    provider=self,\n", "                )\n\t                for tree in [runtimes.asm, runtimes.run]:\n\t                    # godbolt supports execution and compilation\n\t                    # fmt: off\n\t                    (\n\t                        tree \n\t                        [data[\"lang\"]]\n\t                        [data[\"instructionSet\"] or \"none\"]\n\t                        [data[\"compilerType\"] or \"none\"]\n\t                        [data[\"semver\"] or \"none\"]\n", "                    ) = runtime\n\t                    # fmt: on\n\t        self.runtimes = runtimes\n\t    async def _run(self, instance: Instance) -> models.Result:\n\t        if not (rt := instance.runtime):\n\t            return models.Result(\"No runtime selected.\")\n\t        if not (code := instance.code):\n\t            return models.Result(\"No code to run.\")\n\t        if not (lang := instance.language.v):\n\t            return models.Result(\"No language.\")\n", "        url = self.URL + f\"compiler/{rt.id}/compile\"\n\t        post_data = {\n\t            \"source\": transform_code(lang, code.code),\n\t            \"lang\": lang.lower(),\n\t            \"options\": {\n\t                \"compilerOptions\": {\"executorRequest\": True},\n\t                \"executeParameters\": {\"stdin\": instance.stdin},\n\t                \"filters\": {\"execute\": True},\n\t            },\n\t        }\n", "        async with self.session.post(url, json=post_data) as resp:\n\t            resp.raise_for_status()\n\t            data = await resp.json()\n\t        return models.Result(parse_response(data))\n\t    async def _asm(self, instance: Instance) -> models.Result:\n\t        assert instance.runtime\n\t        assert instance.language.v\n\t        assert instance.code\n\t        rt = instance.runtime\n\t        lang = instance.language.v\n", "        code = instance.code\n\t        url = self.URL + f\"compiler/{rt.id}/compile\"\n\t        post_data = {\n\t            \"source\": transform_code(lang, code.code),\n\t            \"lang\": lang.lower(),\n\t            \"options\": {\n\t                \"compilerOptions\": {\n\t                    \"executorRequest\": False,\n\t                },\n\t                \"filters\": {\n", "                    \"binary\": False,\n\t                    \"binaryObject\": False,\n\t                    \"commentOnly\": True,\n\t                    \"demangle\": True,\n\t                    \"directives\": True,\n\t                    \"execute\": False,\n\t                    \"intel\": True,\n\t                    \"labels\": True,\n\t                    \"libraryCode\": False,\n\t                    \"trim\": False,\n", "                },\n\t            },\n\t        }\n\t        async with self.session.post(url, json=post_data) as resp:\n\t            resp.raise_for_status()\n\t            data = await resp.json()\n\t        return models.Result(parse_response(data))\n\t    async def execute(self, instance: Instance) -> models.Result:\n\t        match instance.action:\n\t            case models.Action.RUN:\n", "                return await self._run(instance)\n\t            case models.Action.ASM:\n\t                return await self._asm(instance)\n"]}
{"filename": "bot/providers/provider.py", "chunked_list": ["from __future__ import annotations\n\timport abc\n\timport typing as t\n\timport aiohttp\n\tfrom bot import models\n\tif t.TYPE_CHECKING:\n\t    from bot.app import Model\n\t    from bot.plugins.instance import Instance\n\tclass Provider(abc.ABC):\n\t    def __init__(self, model: Model) -> None:\n", "        self.model = model\n\t        self.runtimes = models.RuntimeTree()\n\t        self._session: aiohttp.ClientSession | None = None\n\t    @property\n\t    def session(self) -> aiohttp.ClientSession:\n\t        assert self._session, \"aiohttp session not initialized\"\n\t        return self._session\n\t    async def shutdown(self) -> None:\n\t        if self._session and not self._session.closed:\n\t            await self._session.close()\n", "    @abc.abstractmethod\n\t    async def startup(self) -> None:\n\t        ...\n\t    @abc.abstractmethod\n\t    async def execute(self, instance: Instance) -> models.Result:\n\t        ...\n\t    @abc.abstractmethod\n\t    async def update_data(self) -> None:\n\t        ...\n\t    def __str__(self) -> str:\n", "        return self.__class__.__name__.lower()\n"]}
