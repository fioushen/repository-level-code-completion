{"filename": "conftest.py", "chunked_list": ["from __future__ import annotations\n\timport logging\n\timport os\n\timport platform\n\timport tempfile\n\timport pytest\n\tfrom appsignal.agent import agent\n\t@pytest.fixture(scope=\"function\", autouse=True)\n\tdef reset_environment_between_tests():\n\t    old_environ = dict(os.environ)\n", "    yield\n\t    os.environ.clear()\n\t    os.environ.update(old_environ)\n\t@pytest.fixture(scope=\"function\", autouse=True)\n\tdef remove_logging_handlers_after_tests():\n\t    yield\n\t    logger = logging.getLogger(\"appsignal\")\n\t    for handler in logger.handlers:\n\t        logger.removeHandler(handler)\n\t@pytest.fixture(scope=\"function\", autouse=True)\n", "def reset_agent_active_state():\n\t    agent.active = False\n\t@pytest.fixture(scope=\"function\", autouse=True)\n\tdef stop_agent():\n\t    tmp_path = \"/tmp\" if platform.system() == \"Darwin\" else tempfile.gettempdir()\n\t    working_dir = os.path.join(tmp_path, \"appsignal\")\n\t    if os.path.isdir(working_dir):\n\t        os.system(f\"rm -rf {working_dir}\")\n\t    yield\n"]}
{"filename": "tests/test_push_api_key_validator.py", "chunked_list": ["from unittest.mock import MagicMock\n\tfrom appsignal.config import Config, Options\n\tfrom appsignal.push_api_key_validator import PushApiKeyValidator\n\tdef test_push_api_key_validator_valid(mocker):\n\t    mock_request = mocker.patch(\"requests.post\")\n\t    mock_request.return_value = MagicMock(status_code=200)\n\t    assert (\n\t        PushApiKeyValidator.validate(Config(Options(push_api_key=\"valid\"))) == \"valid\"\n\t    )\n\tdef test_push_api_key_validator_invalid(mocker):\n", "    mock_request = mocker.patch(\"requests.post\")\n\t    mock_request.return_value = MagicMock(status_code=401)\n\t    assert (\n\t        PushApiKeyValidator.validate(Config(Options(push_api_key=\"invalid\")))\n\t        == \"invalid\"\n\t    )\n\tdef test_push_api_key_validator_error(mocker):\n\t    mock_request = mocker.patch(\"requests.post\")\n\t    mock_request.return_value = MagicMock(status_code=500)\n\t    assert PushApiKeyValidator.validate(Config(Options(push_api_key=\"500\"))) == \"500\"\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_config.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\tfrom appsignal.__about__ import __version__\n\tfrom appsignal.config import Config, Options\n\tdef test_option():\n\t    config = Config(Options(active=False, enable_host_metrics=True))\n\t    assert config.option(\"active\") is False\n\t    assert config.option(\"enable_host_metrics\") is True\n\t    assert config.option(\"nonsense\") is None\n\tdef test_source_order():\n", "    # Read only from default\n\t    config = Config()\n\t    assert config.sources[\"default\"][\"enable_host_metrics\"] is True\n\t    assert config.option(\"enable_host_metrics\") is True\n\t    # Read from environment\n\t    os.environ[\"APPSIGNAL_ENABLE_HOST_METRICS\"] = \"false\"\n\t    config = Config()\n\t    assert config.sources[\"default\"][\"enable_host_metrics\"] is True\n\t    assert config.sources[\"environment\"][\"enable_host_metrics\"] is False\n\t    assert config.option(\"enable_host_metrics\") is False\n", "    # Read from config initializer last\n\t    os.environ[\"APPSIGNAL_HOSTNAME\"] = \"env name\"\n\t    config = Config(Options(hostname=\"initial name\"))\n\t    assert config.sources[\"environment\"][\"hostname\"] == \"env name\"\n\t    assert config.sources[\"initial\"][\"hostname\"] == \"initial name\"\n\t    assert config.option(\"hostname\") == \"initial name\"\n\tdef test_system_source():\n\t    config = Config()\n\t    assert list(config.sources[\"system\"].keys()) == [\"app_path\"]\n\t    assert \"app_path\" in list(config.options.keys())\n", "def test_environ_source():\n\t    os.environ[\"APPSIGNAL_ACTIVE\"] = \"true\"\n\t    os.environ[\"APPSIGNAL_APP_ENV\"] = \"development\"\n\t    os.environ[\"APPSIGNAL_APP_NAME\"] = \"MyApp\"\n\t    os.environ[\"APPSIGNAL_BIND_ADDRESS\"] = \"0.0.0.0\"\n\t    os.environ[\"APPSIGNAL_CA_FILE_PATH\"] = \"/path/to/cacert.pem\"\n\t    os.environ[\"APPSIGNAL_DNS_SERVERS\"] = \"8.8.8.8,8.8.4.4\"\n\t    os.environ[\"APPSIGNAL_ENABLE_HOST_METRICS\"] = \"true\"\n\t    os.environ[\"APPSIGNAL_ENABLE_NGINX_METRICS\"] = \"false\"\n\t    os.environ[\"APPSIGNAL_ENABLE_STATSD\"] = \"false\"\n", "    os.environ[\"APPSIGNAL_FILES_WORLD_ACCESSIBLE\"] = \"true\"\n\t    os.environ[\"APPSIGNAL_FILTER_PARAMETERS\"] = \"password,secret\"\n\t    os.environ[\"APPSIGNAL_FILTER_SESSION_DATA\"] = \"key1,key2\"\n\t    os.environ[\"APPSIGNAL_HOSTNAME\"] = \"Test hostname\"\n\t    os.environ[\"APPSIGNAL_HTTP_PROXY\"] = \"http://proxy.local:9999\"\n\t    os.environ[\"APPSIGNAL_IGNORE_ACTIONS\"] = \"action1,action2\"\n\t    os.environ[\"APPSIGNAL_IGNORE_ERRORS\"] = \"error1,error2\"\n\t    os.environ[\"APPSIGNAL_IGNORE_NAMESPACES\"] = \"namespace1,namespace2\"\n\t    os.environ[\"APPSIGNAL_LOG_LEVEL\"] = \"trace\"\n\t    os.environ[\"APPSIGNAL_LOG_PATH\"] = \"/path/to/log_dir\"\n", "    os.environ[\"APPSIGNAL_PUSH_API_KEY\"] = \"some-api-key\"\n\t    os.environ[\"APPSIGNAL_PUSH_API_ENDPOINT\"] = \"https://push.appsignal.com\"\n\t    os.environ[\"APPSIGNAL_REQUEST_HEADERS\"] = \"accept,x-custom-header\"\n\t    os.environ[\"APPSIGNAL_RUNNING_IN_CONTAINER\"] = \"true\"\n\t    os.environ[\"APPSIGNAL_SEND_ENVIRONMENT_METADATA\"] = \"true\"\n\t    os.environ[\"APPSIGNAL_SEND_PARAMS\"] = \"true\"\n\t    os.environ[\"APPSIGNAL_SEND_SESSION_DATA\"] = \"true\"\n\t    os.environ[\"APPSIGNAL_WORKING_DIRECTORY_PATH\"] = \"/path/to/working/dir\"\n\t    os.environ[\"APP_REVISION\"] = \"abc123\"\n\t    config = Config()\n", "    env_options = Options(\n\t        active=True,\n\t        bind_address=\"0.0.0.0\",\n\t        ca_file_path=\"/path/to/cacert.pem\",\n\t        dns_servers=[\"8.8.8.8\", \"8.8.4.4\"],\n\t        enable_host_metrics=True,\n\t        enable_nginx_metrics=False,\n\t        enable_statsd=False,\n\t        endpoint=\"https://push.appsignal.com\",\n\t        environment=\"development\",\n", "        files_world_accessible=True,\n\t        filter_parameters=[\"password\", \"secret\"],\n\t        filter_session_data=[\"key1\", \"key2\"],\n\t        hostname=\"Test hostname\",\n\t        http_proxy=\"http://proxy.local:9999\",\n\t        ignore_actions=[\"action1\", \"action2\"],\n\t        ignore_errors=[\"error1\", \"error2\"],\n\t        ignore_namespaces=[\"namespace1\", \"namespace2\"],\n\t        log_level=\"trace\",\n\t        log_path=\"/path/to/log_dir\",\n", "        name=\"MyApp\",\n\t        push_api_key=\"some-api-key\",\n\t        revision=\"abc123\",\n\t        request_headers=[\"accept\", \"x-custom-header\"],\n\t        running_in_container=True,\n\t        send_environment_metadata=True,\n\t        send_params=True,\n\t        send_session_data=True,\n\t        working_directory_path=\"/path/to/working/dir\",\n\t    )\n", "    assert config.sources[\"environment\"] == env_options\n\t    final_options = Options()\n\t    final_options.update(config.sources[\"default\"])\n\t    final_options.update(config.sources[\"system\"])\n\t    final_options.update(env_options)\n\t    assert config.options == final_options\n\tdef test_environ_source_bool_is_unset():\n\t    config = Config()\n\t    assert config.sources[\"environment\"].get(\"active\") is None\n\t    assert config.option(\"active\") is None\n", "def test_environ_source_bool_is_empty_string():\n\t    os.environ[\"APPSIGNAL_ACTIVE\"] = \"\"\n\t    config = Config()\n\t    assert config.sources[\"environment\"].get(\"active\") is None\n\t    assert config.option(\"active\") is None\n\tdef test_environ_source_bool_is_invalid():\n\t    os.environ[\"APPSIGNAL_ACTIVE\"] = \"invalid\"\n\t    config = Config()\n\t    assert config.sources[\"environment\"].get(\"active\") is None\n\t    assert config.option(\"active\") is None\n", "def test_environ_source_disable_default_instrumentations_list():\n\t    os.environ[\"APPSIGNAL_DISABLE_DEFAULT_INSTRUMENTATIONS\"] = \",\".join(\n\t        [\"opentelemetry.instrumentation.celery\", \"something.else\"]\n\t    )\n\t    config = Config()\n\t    assert config.sources[\"environment\"][\"disable_default_instrumentations\"] == [\n\t        \"opentelemetry.instrumentation.celery\"\n\t    ]\n\t    assert config.options[\"disable_default_instrumentations\"] == [\n\t        \"opentelemetry.instrumentation.celery\"\n", "    ]\n\tdef test_environ_source_disable_default_instrumentations_bool():\n\t    for value, expected in [\n\t        (\"True\", True),\n\t        (\"true\", True),\n\t        (\"False\", False),\n\t        (\"false\", False),\n\t    ]:\n\t        os.environ[\"APPSIGNAL_DISABLE_DEFAULT_INSTRUMENTATIONS\"] = value\n\t        config = Config()\n", "        assert config.options[\"disable_default_instrumentations\"] is expected\n\tdef test_set_private_environ():\n\t    cwdir = os.getcwd()\n\t    config = Config(\n\t        Options(\n\t            active=True,\n\t            app_path=\"/path/to/app\",\n\t            bind_address=\"0.0.0.0\",\n\t            ca_file_path=\"/path/to/cacert.pem\",\n\t            dns_servers=[\"8.8.8.8\", \"8.8.4.4\"],\n", "            enable_host_metrics=True,\n\t            enable_nginx_metrics=False,\n\t            enable_statsd=False,\n\t            endpoint=\"https://push.appsignal.com\",\n\t            environment=\"development\",\n\t            files_world_accessible=True,\n\t            filter_parameters=[\"password\", \"secret\"],\n\t            filter_session_data=[\"key1\", \"key2\"],\n\t            hostname=\"Test hostname\",\n\t            http_proxy=\"http://proxy.local:9999\",\n", "            ignore_actions=[\"action1\", \"action2\"],\n\t            ignore_errors=[\"error1\", \"error2\"],\n\t            ignore_namespaces=[\"namespace1\", \"namespace2\"],\n\t            log_level=\"trace\",\n\t            log_path=cwdir,\n\t            name=\"MyApp\",\n\t            push_api_key=\"some-api-key\",\n\t            revision=\"abc123\",\n\t            running_in_container=True,\n\t            send_environment_metadata=True,\n", "            send_params=True,\n\t            send_session_data=True,\n\t            working_directory_path=\"/path/to/working/dir\",\n\t        )\n\t    )\n\t    config.set_private_environ()\n\t    assert os.environ[\"_APPSIGNAL_ACTIVE\"] == \"true\"\n\t    assert os.environ[\"_APPSIGNAL_APP_ENV\"] == \"development\"\n\t    assert os.environ[\"_APPSIGNAL_APP_NAME\"] == \"MyApp\"\n\t    assert os.environ[\"_APPSIGNAL_APP_PATH\"] == \"/path/to/app\"\n", "    assert os.environ[\"_APPSIGNAL_BIND_ADDRESS\"] == \"0.0.0.0\"\n\t    assert os.environ[\"_APPSIGNAL_CA_FILE_PATH\"] == \"/path/to/cacert.pem\"\n\t    assert os.environ[\"_APPSIGNAL_DNS_SERVERS\"] == \"8.8.8.8,8.8.4.4\"\n\t    assert os.environ[\"_APPSIGNAL_ENABLE_HOST_METRICS\"] == \"true\"\n\t    assert os.environ[\"_APPSIGNAL_ENABLE_NGINX_METRICS\"] == \"false\"\n\t    assert os.environ[\"_APPSIGNAL_ENABLE_STATSD\"] == \"false\"\n\t    assert os.environ[\"_APPSIGNAL_FILES_WORLD_ACCESSIBLE\"] == \"true\"\n\t    assert os.environ[\"_APPSIGNAL_FILTER_PARAMETERS\"] == \"password,secret\"\n\t    assert os.environ[\"_APPSIGNAL_FILTER_SESSION_DATA\"] == \"key1,key2\"\n\t    assert os.environ[\"_APPSIGNAL_HOSTNAME\"] == \"Test hostname\"\n", "    assert os.environ[\"_APPSIGNAL_HTTP_PROXY\"] == \"http://proxy.local:9999\"\n\t    assert os.environ[\"_APPSIGNAL_IGNORE_ACTIONS\"] == \"action1,action2\"\n\t    assert os.environ[\"_APPSIGNAL_IGNORE_ERRORS\"] == \"error1,error2\"\n\t    assert os.environ[\"_APPSIGNAL_IGNORE_NAMESPACES\"] == \"namespace1,namespace2\"\n\t    assert os.environ[\"_APPSIGNAL_LOG_LEVEL\"] == \"trace\"\n\t    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == f\"{cwdir}/appsignal.log\"\n\t    assert os.environ[\"_APPSIGNAL_PUSH_API_KEY\"] == \"some-api-key\"\n\t    assert os.environ[\"_APPSIGNAL_PUSH_API_ENDPOINT\"] == \"https://push.appsignal.com\"\n\t    assert (\n\t        os.environ[\"_APPSIGNAL_LANGUAGE_INTEGRATION_VERSION\"] == f\"python-{__version__}\"\n", "    )\n\t    assert os.environ[\"_APPSIGNAL_RUNNING_IN_CONTAINER\"] == \"true\"\n\t    assert os.environ[\"_APPSIGNAL_SEND_ENVIRONMENT_METADATA\"] == \"true\"\n\t    assert os.environ[\"_APPSIGNAL_SEND_PARAMS\"] == \"true\"\n\t    assert os.environ[\"_APPSIGNAL_SEND_SESSION_DATA\"] == \"true\"\n\t    assert os.environ[\"_APPSIGNAL_WORKING_DIRECTORY_PATH\"] == \"/path/to/working/dir\"\n\t    assert os.environ[\"_APP_REVISION\"] == \"abc123\"\n\tdef test_set_private_environ_valid_log_path():\n\t    cwdir = os.getcwd()\n\t    config = Config(Options(log_path=cwdir))\n", "    config.set_private_environ()\n\t    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == f\"{cwdir}/appsignal.log\"\n\tdef test_set_private_environ_remove_filename_from_log_path():\n\t    cwdir = os.getcwd()\n\t    log_path = os.path.join(cwdir, \"test.log\")\n\t    config = Config(Options(log_path=log_path))\n\t    config.set_private_environ()\n\t    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == f\"{cwdir}/appsignal.log\"\n\tdef test_set_private_environ_invalid_log_path():\n\t    config = Config(Options(log_path=\"/i_dont_exist\"))\n", "    config.set_private_environ()\n\t    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == \"/tmp/appsignal.log\"\n\tdef test_set_private_environ_bool_is_none():\n\t    config = Config(Options(active=None))\n\t    config.set_private_environ()\n\t    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") is None\n\tdef test_set_private_environ_list_is_none():\n\t    config = Config(Options(dns_servers=None))\n\t    config.set_private_environ()\n\t    assert os.environ.get(\"_APPSIGNAL_DNS_SERVERS\") is None\n"]}
{"filename": "tests/test_cli.py", "chunked_list": ["from __future__ import annotations\n\tfrom contextlib import contextmanager\n\tfrom unittest.mock import MagicMock\n\tfrom appsignal.cli.base import main\n\tEXPECTED_FILE_CONTENTS = \"\"\"from appsignal import Appsignal\n\tappsignal = Appsignal(\n\t    active=True,\n\t    name=\"My app name\",\n\t    push_api_key=\"My push API key\",\n\t)\n", "\"\"\"\n\t@contextmanager\n\tdef mock_input(mocker, *pairs: tuple[str, str]):\n\t    prompt_calls = [mocker.call(prompt) for (prompt, _) in pairs]\n\t    answers = [answer for (_, answer) in pairs]\n\t    mock = mocker.patch(\"builtins.input\", side_effect=answers)\n\t    yield\n\t    assert prompt_calls == mock.mock_calls\n\tdef mock_file_operations(mocker, file_exists: bool = False):\n\t    mocker.patch(\"os.path.exists\", return_value=file_exists)\n", "    mocker.patch(\"appsignal.cli.install.open\")\n\tdef assert_wrote_file_contents(mocker):\n\t    from appsignal.cli import install\n\t    builtins_open: MagicMock = install.open  # type: ignore[attr-defined]\n\t    assert mocker.call(\"__appsignal__.py\", \"w\") in builtins_open.mock_calls\n\t    assert (\n\t        mocker.call().__enter__().write(EXPECTED_FILE_CONTENTS)\n\t        in builtins_open.mock_calls\n\t    )\n\tdef mock_validate_push_api_key_request(mocker, status_code=200):\n", "    mock_request = mocker.patch(\"requests.get\")\n\t    mock_request.return_value = MagicMock(status_code=status_code)\n\tdef test_install_command_run(mocker):\n\t    mock_file_operations(mocker)\n\t    mock_validate_push_api_key_request(mocker)\n\t    with mock_input(\n\t        mocker,\n\t        (\"Please enter the name of your application: \", \"My app name\"),\n\t        (\"Please enter your Push API key: \", \"My push API key\"),\n\t    ):\n", "        main([\"install\"])\n\t    assert_wrote_file_contents(mocker)\n\tdef test_install_command_when_empty_value_ask_again(mocker):\n\t    mock_file_operations(mocker)\n\t    mock_validate_push_api_key_request(mocker)\n\t    with mock_input(\n\t        mocker,\n\t        (\"Please enter the name of your application: \", \"\"),\n\t        (\"Please enter the name of your application: \", \"My app name\"),\n\t        (\"Please enter your Push API key: \", \"\"),\n", "        (\"Please enter your Push API key: \", \"My push API key\"),\n\t    ):\n\t        main([\"install\"])\n\t    assert_wrote_file_contents(mocker)\n\tdef test_install_command_when_push_api_key_given(mocker):\n\t    mock_file_operations(mocker)\n\t    mock_validate_push_api_key_request(mocker)\n\t    with mock_input(\n\t        mocker,\n\t        (\"Please enter the name of your application: \", \"My app name\"),\n", "    ):\n\t        main([\"install\", \"--push-api-key\", \"My push API key\"])\n\t    assert_wrote_file_contents(mocker)\n\tdef test_install_command_when_file_exists_overwrite(mocker):\n\t    mock_file_operations(mocker, file_exists=True)\n\t    mock_validate_push_api_key_request(mocker)\n\t    with mock_input(\n\t        mocker,\n\t        (\"Please enter the name of your application: \", \"My app name\"),\n\t        (\"Please enter your Push API key: \", \"My push API key\"),\n", "        (\n\t            \"The __appsignal__.py file already exists.\"\n\t            \" Should it be overwritten? (y/N): \",\n\t            \"y\",\n\t        ),\n\t    ):\n\t        main([\"install\"])\n\t    assert_wrote_file_contents(mocker)\n\tdef test_install_command_when_file_exists_no_overwrite(mocker):\n\t    mock_file_operations(mocker, file_exists=True)\n", "    mock_validate_push_api_key_request(mocker)\n\t    with mock_input(\n\t        mocker,\n\t        (\"Please enter the name of your application: \", \"My app name\"),\n\t        (\"Please enter your Push API key: \", \"My push API key\"),\n\t        (\n\t            \"The __appsignal__.py file already exists.\"\n\t            \" Should it be overwritten? (y/N): \",\n\t            \"n\",\n\t        ),\n", "    ):\n\t        main([\"install\"])\n\t    from appsignal.cli import install\n\t    assert install.open.mock_calls == []  # type: ignore[attr-defined]\n\tdef test_install_comand_when_api_key_is_not_valid(mocker):\n\t    mock_validate_push_api_key_request(mocker, status_code=401)\n\t    with mock_input(\n\t        mocker,\n\t        (\"Please enter the name of your application: \", \"My app name\"),\n\t    ):\n", "        assert main([\"install\", \"--push-api-key=bad-push-api-key\"]) == 1\n"]}
{"filename": "tests/test_opentelemetry.py", "chunked_list": ["from __future__ import annotations\n\tfrom unittest.mock import Mock\n\tfrom appsignal.config import Config, Options\n\tfrom appsignal.opentelemetry import add_instrumentations\n\tdef raise_module_not_found_error():\n\t    raise ModuleNotFoundError\n\tdef mock_adders() -> dict[Config.DefaultInstrumentation, Mock]:\n\t    return {\n\t        \"opentelemetry.instrumentation.celery\": Mock(),\n\t        \"opentelemetry.instrumentation.jinja2\": Mock(\n", "            side_effect=raise_module_not_found_error\n\t        ),\n\t    }\n\tdef test_add_instrumentations():\n\t    adders = mock_adders()\n\t    config = Config()\n\t    add_instrumentations(config, _adders=adders)\n\t    for adder in adders.values():\n\t        adder.assert_called_once()\n\tdef test_add_instrumentations_disable_some_default_instrumentations():\n", "    adders = mock_adders()\n\t    config = Config(\n\t        Options(\n\t            disable_default_instrumentations=[\"opentelemetry.instrumentation.celery\"]\n\t        )\n\t    )\n\t    add_instrumentations(config, _adders=adders)\n\t    adders[\"opentelemetry.instrumentation.celery\"].assert_not_called()\n\t    adders[\"opentelemetry.instrumentation.jinja2\"].assert_called_once()\n\tdef test_add_instrumentations_disable_all_default_instrumentations():\n", "    adders = mock_adders()\n\t    config = Config(Options(disable_default_instrumentations=True))\n\t    add_instrumentations(config, _adders=adders)\n\t    for adder in adders.values():\n\t        adder.assert_not_called()\n"]}
{"filename": "tests/test_client.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\timport re\n\tfrom logging import DEBUG, ERROR, INFO, WARNING\n\tfrom appsignal.agent import agent\n\tfrom appsignal.client import Client\n\tdef test_client_options_merge_sources():\n\t    os.environ[\"APPSIGNAL_PUSH_API_KEY\"] = \"some_key\"\n\t    client = Client(name=\"MyApp\")\n\t    assert client._config.options[\"name\"] == \"MyApp\"\n", "    assert client._config.options[\"push_api_key\"] == \"some_key\"\n\t    assert \"app_path\" in client._config.options\n\tdef test_client_agent_inactive():\n\t    client = Client(active=True, name=\"MyApp\")\n\t    assert client._config.options[\"active\"] is True\n\t    client.start()\n\t    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n\t    assert agent.active is False\n\tdef test_client_agent_active():\n\t    client = Client(active=True, name=\"MyApp\", push_api_key=\"000\")\n", "    assert client._config.options[\"active\"] is True\n\t    client.start()\n\t    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n\t    assert agent.active is True\n\tdef test_client_active():\n\t    client = Client(\n\t        active=True,\n\t        name=\"MyApp\",\n\t        request_headers=[\"accept\", \"x-custom-header\"],\n\t        push_api_key=\"0000-0000-0000-0000\",\n", "    )\n\t    assert client._config.options[\"active\"] is True\n\t    assert client._config.options[\"name\"] == \"MyApp\"\n\t    assert client._config.options[\"request_headers\"] == [\"accept\", \"x-custom-header\"]\n\t    assert client._config.options[\"push_api_key\"] == \"0000-0000-0000-0000\"\n\t    client.start()\n\t    # Sets the private config environment variables\n\t    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n\t    assert os.environ.get(\"_APPSIGNAL_APP_NAME\") == \"MyApp\"\n\t    assert os.environ.get(\"_APPSIGNAL_PUSH_API_KEY\") == \"0000-0000-0000-0000\"\n", "    assert (\n\t        os.environ.get(\"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\")\n\t        == \"accept,x-custom-header\"\n\t    )\n\t    assert agent.active\n\tdef test_client_active_without_request_headers():\n\t    client = Client(active=True, name=\"MyApp\", request_headers=None)\n\t    assert client._config.options[\"active\"] is True\n\t    assert client._config.options[\"name\"] == \"MyApp\"\n\t    assert client._config.options[\"request_headers\"] is None\n", "    client.start()\n\t    # Sets the private config environment variables\n\t    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n\t    assert os.environ.get(\"_APPSIGNAL_APP_NAME\") == \"MyApp\"\n\t    assert (\n\t        os.environ.get(\"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\")\n\t        is None\n\t    )\n\tdef test_client_inactive():\n\t    client = Client(active=False, name=\"MyApp\")\n", "    assert client._config.options[\"active\"] is False\n\t    assert client._config.options[\"name\"] == \"MyApp\"\n\t    client.start()\n\t    # Does not set the private config environment variables\n\t    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") is None\n\t    assert os.environ.get(\"_APPSIGNAL_APP_NAME\") is None\n\t    assert (\n\t        os.environ.get(\"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\")\n\t        is None\n\t    )\n", "def test_logger_default_level():\n\t    client = Client()\n\t    assert client._logger.getEffectiveLevel() == INFO\n\t    client = Client(log_level=\"info\")\n\t    assert client._logger.getEffectiveLevel() == INFO\n\tdef test_logger_error_level():\n\t    client = Client(log_level=\"error\")\n\t    assert client._logger.getEffectiveLevel() == ERROR\n\tdef test_logger_warning_level():\n\t    client = Client(log_level=\"warning\")\n", "    assert client._logger.getEffectiveLevel() == WARNING\n\tdef test_logger_debug_level():\n\t    client = Client(log_level=\"debug\")\n\t    assert client._logger.getEffectiveLevel() == DEBUG\n\tdef test_logger_trace_level():\n\t    client = Client(log_level=\"trace\")\n\t    assert client._logger.getEffectiveLevel() == DEBUG\n\tdef test_logger_file(tmp_path):\n\t    log_path = tmp_path\n\t    log_file_path = os.path.join(log_path, \"appsignal.log\")\n", "    client = Client(log_path=log_path)\n\t    logger = client._logger\n\t    logger.info(\"test me\")\n\t    with open(log_file_path) as file:\n\t        contents = file.read()\n\t    log_line_regex = re.compile(\n\t        r\"\\[\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2} \\(process\\) #\\d+\\]\\[INFO\\] test me\"\n\t    )\n\t    assert log_line_regex.search(contents)\n\tdef test_logger_stdout(capsys):\n", "    client = Client(log=\"stdout\")\n\t    logger = client._logger\n\t    logger.info(\"test me\")\n\t    captured = capsys.readouterr()\n\t    log_line_regex = re.compile(\n\t        r\"\\[\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2} \\(process\\) #\\d+\\]\\[appsignal\\]\"\n\t        r\"\\[INFO\\] test me\"\n\t    )\n\t    assert log_line_regex.search(captured.out)\n\tdef test_logger_stdout_fallback(capsys, mocker):\n", "    # Make any path appear unwritable so it will fall back to the STDOUT logger\n\t    mocker.patch(\"os.access\", return_value=False)\n\t    client = Client(log=\"file\", log_path=None)\n\t    logger = client._logger\n\t    logger.info(\"test me\")\n\t    captured = capsys.readouterr()\n\t    log_line_regex = re.compile(\n\t        r\"\\[\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2} \\(process\\) #\\d+\\]\\[appsignal\\]\"\n\t        r\"\\[INFO\\] test me\"\n\t    )\n", "    assert log_line_regex.search(captured.out)\n"]}
{"filename": "src/scripts/sdist_hook.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Any\n\tfrom hatchling.builders.hooks.plugin.interface import BuildHookInterface\n\tclass CustomBuildHook(BuildHookInterface):\n\t    def initialize(self, version: str, build_data: dict[str, Any]) -> None:\n\t        \"\"\"\n\t        This occurs immediately before each build.\n\t        Any modifications to the build data will be seen by the build target.\n\t        \"\"\"\n\t        print(\n", "            \"It is not possible to build a source distribution package for \"\n\t            \"this project, as it requires a platform-dependent binary.\"\n\t        )\n\t        print(\"Hint: you may wish to run `hatch run build:me` instead?\")\n\t        exit(1)\n"]}
{"filename": "src/scripts/platform.py", "chunked_list": ["from __future__ import annotations\n\tTRIPLE_PLATFORM_TAG = {\n\t    # MacOS builds\n\t    \"x86_64-darwin\": \"macosx_10_9_x86_64\",\n\t    # Apple Silicon (and Apple Silicon w/ Intel emulation)\n\t    \"arm64-darwin\": \"macosx_10_9_universal2.macosx_12_3_arm64\",\n\t    # Glibc Linux builds\n\t    # manylinux2014 is a legacy tag defined as glibc >= 2.17,\n\t    # we actually support glibc >= 2.15\n\t    # https://peps.python.org/pep-0600/#legacy-manylinux-tags\n", "    \"aarch64-linux\": \"manylinux2014_aarch64.manylinux_2_15_aarch64\",\n\t    \"x86_64-linux\": \"manylinux2014_x86_64.manylinux_2_15_x86_64\",\n\t    \"i686-linux\": \"manylinux2014_i686.manylinux_2_15_i686\",\n\t    # MUSL Linux builds\n\t    # our docs say we support v1.1.16 or above, but we can't\n\t    # specify the patch\n\t    # https://peps.python.org/pep-0656/\n\t    \"aarch64-linux-musl\": \"musllinux_1_1_aarch64\",\n\t    \"x86_64-linux-musl\": \"musllinux_1_1_x86_64\",\n\t}\n"]}
{"filename": "src/scripts/agent.py", "chunked_list": ["# DO NOT EDIT\n\t# This is a generated file by the `rake ship` family of tasks in the\n\t# appsignal-agent repository.\n\t# Modifications to this file will be overwritten with the next agent release.\n\tAPPSIGNAL_AGENT_CONFIG = {\n\t    \"version\": \"d789895\",\n\t    \"mirrors\": [\n\t        \"https://appsignal-agent-releases.global.ssl.fastly.net\",\n\t        \"https://d135dj0rjqvssy.cloudfront.net\",\n\t    ],\n", "    \"triples\": {\n\t        \"x86_64-darwin\": {\n\t            \"static\": {\n\t                \"checksum\": \"8ea76b7d011c728b7988d017a39fc3a432d9c86392e6e46767ecc931e583777a\",\n\t                \"filename\": \"appsignal-x86_64-darwin-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"beacdcd579bcc06a69da279dbca2f363395ea4b1846fa4b6e49de612beb07a8a\",\n\t                \"filename\": \"appsignal-x86_64-darwin-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"universal-darwin\": {\n\t            \"static\": {\n\t                \"checksum\": \"8ea76b7d011c728b7988d017a39fc3a432d9c86392e6e46767ecc931e583777a\",\n\t                \"filename\": \"appsignal-x86_64-darwin-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"beacdcd579bcc06a69da279dbca2f363395ea4b1846fa4b6e49de612beb07a8a\",\n\t                \"filename\": \"appsignal-x86_64-darwin-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"aarch64-darwin\": {\n\t            \"static\": {\n\t                \"checksum\": \"535fed60ac1484e40bbfe77cd4fe9131c67f25e6362a2fe31d987c36ec82ba08\",\n\t                \"filename\": \"appsignal-aarch64-darwin-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"6c984f53a07788ebb469ede014ac8732d9db1ef43736825690492e7c12e3fb83\",\n\t                \"filename\": \"appsignal-aarch64-darwin-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"arm64-darwin\": {\n\t            \"static\": {\n\t                \"checksum\": \"535fed60ac1484e40bbfe77cd4fe9131c67f25e6362a2fe31d987c36ec82ba08\",\n\t                \"filename\": \"appsignal-aarch64-darwin-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"6c984f53a07788ebb469ede014ac8732d9db1ef43736825690492e7c12e3fb83\",\n\t                \"filename\": \"appsignal-aarch64-darwin-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"arm-darwin\": {\n\t            \"static\": {\n\t                \"checksum\": \"535fed60ac1484e40bbfe77cd4fe9131c67f25e6362a2fe31d987c36ec82ba08\",\n\t                \"filename\": \"appsignal-aarch64-darwin-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"6c984f53a07788ebb469ede014ac8732d9db1ef43736825690492e7c12e3fb83\",\n\t                \"filename\": \"appsignal-aarch64-darwin-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"aarch64-linux\": {\n\t            \"static\": {\n\t                \"checksum\": \"35f96e0adf408fd8ac3e89c6cb3c5506eb4250643199aad3ba298ab131d773c8\",\n\t                \"filename\": \"appsignal-aarch64-linux-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"6f4e5431c50c947f9fdeb92b7536780277bebb75327cfa5ee9c27659a9d20b5e\",\n\t                \"filename\": \"appsignal-aarch64-linux-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"i686-linux\": {\n\t            \"static\": {\n\t                \"checksum\": \"f4a1c9a67a0a4cde7e13ef555a6782e5d4f15bfbce9277c2aaf8e248a0fb858e\",\n\t                \"filename\": \"appsignal-i686-linux-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"26a3fa059874d76897e6a4c709048789f531d7e84e6b8ae4e7fbcdfb26cdef40\",\n\t                \"filename\": \"appsignal-i686-linux-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"x86-linux\": {\n\t            \"static\": {\n\t                \"checksum\": \"f4a1c9a67a0a4cde7e13ef555a6782e5d4f15bfbce9277c2aaf8e248a0fb858e\",\n\t                \"filename\": \"appsignal-i686-linux-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"26a3fa059874d76897e6a4c709048789f531d7e84e6b8ae4e7fbcdfb26cdef40\",\n\t                \"filename\": \"appsignal-i686-linux-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"x86_64-linux\": {\n\t            \"static\": {\n\t                \"checksum\": \"016c962727e31a07eee7a221944ff9c4bbb054eada7e87bbe4602233364f380c\",\n\t                \"filename\": \"appsignal-x86_64-linux-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"d286a8bcc4a876057a14a90cc6ceecdc75230e1c4d721ea3f3138c58c748e602\",\n\t                \"filename\": \"appsignal-x86_64-linux-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"x86_64-linux-musl\": {\n\t            \"static\": {\n\t                \"checksum\": \"2ce9e34b283c76c6b25028d3a770a942f4975cd071c586438a8765948237ca42\",\n\t                \"filename\": \"appsignal-x86_64-linux-musl-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"0eebe8cd448bce5386cdce1039e7f74c60208408108af9537a80e8e8737f7aec\",\n\t                \"filename\": \"appsignal-x86_64-linux-musl-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"aarch64-linux-musl\": {\n\t            \"static\": {\n\t                \"checksum\": \"017da79e62a2875c0384898c9160cd83acd712faba05154fd8a0627fec1b5ba4\",\n\t                \"filename\": \"appsignal-aarch64-linux-musl-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"507d4fa0f3d6168f905404b4b36fe494c5479606d77f50d2d2d3d27b6c645ea1\",\n\t                \"filename\": \"appsignal-aarch64-linux-musl-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"x86_64-freebsd\": {\n\t            \"static\": {\n\t                \"checksum\": \"13d27afcb68aff5e164e05fc4fd8874e73f14c0154301f2e6e6e75f67fa9182c\",\n\t                \"filename\": \"appsignal-x86_64-freebsd-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"dafa25a73cd79e269466d5129dd7b61ac88e09d87c3f253fc9705e1d9469fa2b\",\n\t                \"filename\": \"appsignal-x86_64-freebsd-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t        \"amd64-freebsd\": {\n\t            \"static\": {\n\t                \"checksum\": \"13d27afcb68aff5e164e05fc4fd8874e73f14c0154301f2e6e6e75f67fa9182c\",\n\t                \"filename\": \"appsignal-x86_64-freebsd-all-static.tar.gz\",\n\t            },\n\t            \"dynamic\": {\n\t                \"checksum\": \"dafa25a73cd79e269466d5129dd7b61ac88e09d87c3f253fc9705e1d9469fa2b\",\n\t                \"filename\": \"appsignal-x86_64-freebsd-all-dynamic.tar.gz\",\n\t            },\n", "        },\n\t    },\n\t}\n"]}
{"filename": "src/scripts/build_hook.py", "chunked_list": ["from __future__ import annotations\n\timport hashlib\n\timport os\n\timport shutil\n\timport stat\n\timport subprocess\n\timport sysconfig\n\timport tarfile\n\tfrom runpy import run_path\n\tfrom typing import Any\n", "import requests\n\tfrom hatchling.builders.hooks.plugin.interface import BuildHookInterface\n\tdef run_relative(filename: str) -> dict[str, Any]:\n\t    return run_path(os.path.join(os.path.dirname(os.path.abspath(__file__)), filename))\n\tAPPSIGNAL_AGENT_CONFIG = run_relative(\"agent.py\")[\"APPSIGNAL_AGENT_CONFIG\"]\n\tTRIPLE_PLATFORM_TAG = run_relative(\"platform.py\")[\"TRIPLE_PLATFORM_TAG\"]\n\tdef triple_filename(triple: str) -> str:\n\t    return APPSIGNAL_AGENT_CONFIG[\"triples\"][triple][\"static\"][\"filename\"]\n\tdef triple_checksum(triple: str) -> str:\n\t    return APPSIGNAL_AGENT_CONFIG[\"triples\"][triple][\"static\"][\"checksum\"]\n", "def triple_urls(triple: str) -> list[str]:\n\t    mirrors = APPSIGNAL_AGENT_CONFIG[\"mirrors\"]\n\t    version = APPSIGNAL_AGENT_CONFIG[\"version\"]\n\t    filename = triple_filename(triple)\n\t    return [f\"{mirror}/{version}/{filename}\" for mirror in mirrors]\n\tdef rm(path: str) -> None:\n\t    try:\n\t        os.remove(path)\n\t    except FileNotFoundError:\n\t        pass\n", "def should_download(agent_path: str, version_path: str) -> bool:\n\t    if not os.path.exists(agent_path):\n\t        return True\n\t    if not os.path.exists(version_path):\n\t        return True\n\t    with open(version_path) as version:\n\t        return version.read() != APPSIGNAL_AGENT_CONFIG[\"version\"]\n\tdef this_triple() -> str:\n\t    platform = sysconfig.get_platform()\n\t    [os, *_, arch] = platform.split(\"-\")\n", "    if os == \"macosx\":\n\t        os = \"darwin\"\n\t    if arch == \"universal2\":\n\t        arch = \"arm64\"\n\t    if os == \"linux\":\n\t        ldd_run = subprocess.run([\"ldd\", \"--version\"], capture_output=True)\n\t        if b\"musl\" in ldd_run.stderr:\n\t            os = \"linux-musl\"\n\t    return f\"{arch}-{os}\"\n\tclass DownloadError(Exception):\n", "    pass\n\tclass CustomBuildHook(BuildHookInterface):\n\t    def initialize(self, _version: str, build_data: dict[str, Any]) -> None:\n\t        \"\"\"\n\t        This occurs immediately before each build.\n\t        Any modifications to the build data will be seen by the build target.\n\t        \"\"\"\n\t        triple = None\n\t        if \"_APPSIGNAL_BUILD_TRIPLE\" in os.environ:\n\t            triple = os.environ[\"_APPSIGNAL_BUILD_TRIPLE\"]\n", "        else:\n\t            triple = this_triple()\n\t            print(\n\t                f\"_APPSIGNAL_BUILD_TRIPLE not set; building for local triple ({triple})\"\n\t            )\n\t        platform_tag = TRIPLE_PLATFORM_TAG[triple]\n\t        build_data[\"tag\"] = f\"py3-none-{platform_tag}\"\n\t        build_data[\"pure_python\"] = False\n\t        agent_path = os.path.join(self.root, \"src\", \"appsignal\", \"appsignal-agent\")\n\t        if os.environ.get(\n", "            \"_APPSIGNAL_BUILD_AGENT_PATH\", \"\"\n\t        ).strip() == \"--keep-agent\" and os.path.isfile(agent_path):\n\t            print(f\"Using existing agent binary at {agent_path}\")\n\t            return\n\t        rm(agent_path)\n\t        tempdir_path = os.path.join(self.root, \"tmp\", triple)\n\t        os.makedirs(tempdir_path, exist_ok=True)\n\t        tempagent_path = os.path.join(tempdir_path, \"appsignal_agent\")\n\t        tempversion_path = os.path.join(tempdir_path, \"version\")\n\t        if os.environ.get(\"_APPSIGNAL_BUILD_AGENT_PATH\", \"\").strip() != \"\":\n", "            tempagent_path = os.path.abspath(\n\t                os.environ[\"_APPSIGNAL_BUILD_AGENT_PATH\"].strip()\n\t            )\n\t            if not os.path.isfile(tempagent_path):\n\t                print(\n\t                    f\"Custom agent binary at {tempagent_path} is not a file; exiting...\"\n\t                )\n\t                exit(1)\n\t            print(f\"Using custom agent binary at {tempagent_path}\")\n\t        elif should_download(tempagent_path, tempversion_path):\n", "            temptar_path = os.path.join(tempdir_path, triple_filename(triple))\n\t            rm(tempagent_path)\n\t            rm(tempversion_path)\n\t            rm(temptar_path)\n\t            with open(temptar_path, \"wb\") as temptar:\n\t                for url in triple_urls(triple):\n\t                    try:\n\t                        r = requests.get(url, allow_redirects=True)\n\t                        if r.status_code != 200:\n\t                            raise DownloadError(\"Status code is not 200\")\n", "                        if hashlib.sha256(r.content).hexdigest() != triple_checksum(\n\t                            triple\n\t                        ):\n\t                            raise DownloadError(\"Checksum does not match\")\n\t                        temptar.write(r.content)\n\t                    except DownloadError as e:\n\t                        print(f\"Something went wrong downloading from `{url}`: {e}\")\n\t                    else:\n\t                        break\n\t                else:\n", "                    print(\"Failed to download from any mirrors; exiting...\")\n\t                    exit(1)\n\t            print(f\"Downloaded agent tarball for {triple}\")\n\t            with tarfile.open(temptar_path, \"r:*\") as tar:\n\t                with open(tempagent_path, \"wb\") as agent:\n\t                    tar_agent = tar.extractfile(\"appsignal-agent\")\n\t                    if tar_agent is not None:\n\t                        agent.write(tar_agent.read())\n\t                    else:\n\t                        print(\"Failed to extract agent binary; exiting...\")\n", "                        exit(1)\n\t            with open(tempversion_path, \"w\") as version:\n\t                version.write(APPSIGNAL_AGENT_CONFIG[\"version\"])\n\t            print(f\"Extracted agent binary to {tempagent_path}\")\n\t            rm(temptar_path)\n\t        else:\n\t            print(f\"Using cached agent binary at {tempagent_path}\")\n\t        shutil.copy(tempagent_path, agent_path)\n\t        os.chmod(agent_path, stat.S_IEXEC | stat.S_IREAD | stat.S_IWRITE)\n\t        print(f\"Copied agent binary to {agent_path}\")\n"]}
{"filename": "src/scripts/__init__.py", "chunked_list": []}
{"filename": "src/scripts/build_all.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\tfrom runpy import run_path\n\tfrom typing import Any\n\tdef run_relative(filename: str) -> dict[str, Any]:\n\t    return run_path(os.path.join(os.path.dirname(os.path.abspath(__file__)), filename))\n\tTRIPLE_PLATFORM_TAG = run_relative(\"platform.py\")[\"TRIPLE_PLATFORM_TAG\"]\n\tfor triple in TRIPLE_PLATFORM_TAG:\n\t    result = os.system(f\"_APPSIGNAL_BUILD_TRIPLE={triple} hatch build -t wheel\")\n\t    if result != 0:\n", "        break\n"]}
{"filename": "src/appsignal/__main__.py", "chunked_list": ["from .cli.base import run\n\trun()\n"]}
{"filename": "src/appsignal/opentelemetry.py", "chunked_list": ["from __future__ import annotations\n\timport logging\n\timport os\n\tfrom typing import TYPE_CHECKING, Callable, Mapping\n\tfrom opentelemetry import trace\n\tfrom opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter\n\tfrom opentelemetry.sdk.trace import TracerProvider\n\tfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\n\tfrom .config import Config, list_to_env_str\n\tif TYPE_CHECKING:\n", "    from opentelemetry.trace.span import Span\n\tdef add_celery_instrumentation() -> None:\n\t    from opentelemetry.instrumentation.celery import CeleryInstrumentor\n\t    CeleryInstrumentor().instrument()\n\tdef add_django_instrumentation() -> None:\n\t    import json\n\t    from django.http.request import HttpRequest\n\t    from django.http.response import HttpResponse\n\t    from opentelemetry.instrumentation.django import DjangoInstrumentor\n\t    def response_hook(span: Span, request: HttpRequest, response: HttpResponse) -> None:\n", "        span.set_attribute(\n\t            \"appsignal.request.parameters\",\n\t            json.dumps({\"GET\": request.GET, \"POST\": request.POST}),\n\t        )\n\t    DjangoInstrumentor().instrument(response_hook=response_hook)\n\tdef add_flask_instrumentation() -> None:\n\t    import json\n\t    from urllib.parse import parse_qs\n\t    from opentelemetry.instrumentation.flask import FlaskInstrumentor\n\t    def request_hook(span: Span, environ: dict[str, str]) -> None:\n", "        if span and span.is_recording():\n\t            query_params = parse_qs(environ.get(\"QUERY_STRING\", \"\"))\n\t            span.set_attribute(\n\t                \"appsignal.request.parameters\", json.dumps({\"args\": query_params})\n\t            )\n\t    FlaskInstrumentor().instrument(request_hook=request_hook)\n\tdef add_jinja2_instrumentation() -> None:\n\t    from opentelemetry.instrumentation.jinja2 import Jinja2Instrumentor\n\t    Jinja2Instrumentor().instrument()\n\tdef add_psycopg2_instrumentation() -> None:\n", "    from opentelemetry.instrumentation.psycopg2 import Psycopg2Instrumentor\n\t    Psycopg2Instrumentor().instrument(enable_commenter=True, commenter_options={})\n\tdef add_redis_instrumentation() -> None:\n\t    from opentelemetry.instrumentation.redis import RedisInstrumentor\n\t    RedisInstrumentor().instrument(sanitize_query=True)\n\tdef add_requests_instrumentation() -> None:\n\t    from opentelemetry.instrumentation.requests import RequestsInstrumentor\n\t    RequestsInstrumentor().instrument()\n\tDefaultInstrumentationAdder = Callable[[], None]\n\tDEFAULT_INSTRUMENTATION_ADDERS: Mapping[\n", "    Config.DefaultInstrumentation, DefaultInstrumentationAdder\n\t] = {\n\t    \"opentelemetry.instrumentation.celery\": add_celery_instrumentation,\n\t    \"opentelemetry.instrumentation.django\": add_django_instrumentation,\n\t    \"opentelemetry.instrumentation.flask\": add_flask_instrumentation,\n\t    \"opentelemetry.instrumentation.jinja2\": add_jinja2_instrumentation,\n\t    \"opentelemetry.instrumentation.psycopg2\": add_psycopg2_instrumentation,\n\t    \"opentelemetry.instrumentation.redis\": add_redis_instrumentation,\n\t    \"opentelemetry.instrumentation.requests\": add_requests_instrumentation,\n\t}\n", "def start_opentelemetry(config: Config) -> None:\n\t    # Configure OpenTelemetry request headers config\n\t    request_headers = list_to_env_str(config.option(\"request_headers\"))\n\t    if request_headers:\n\t        os.environ[\n\t            \"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\"\n\t        ] = request_headers\n\t    provider = TracerProvider()\n\t    otlp_exporter = OTLPSpanExporter(endpoint=\"http://localhost:8099/v1/traces\")\n\t    exporter_processor = BatchSpanProcessor(otlp_exporter)\n", "    provider.add_span_processor(exporter_processor)\n\t    trace.set_tracer_provider(provider)\n\t    add_instrumentations(config)\n\tdef add_instrumentations(\n\t    config: Config,\n\t    _adders: Mapping[\n\t        Config.DefaultInstrumentation, DefaultInstrumentationAdder\n\t    ] = DEFAULT_INSTRUMENTATION_ADDERS,\n\t) -> None:\n\t    logger = logging.getLogger(\"appsignal\")\n", "    disable_list = config.options.get(\"disable_default_instrumentations\") or []\n\t    if disable_list is True:\n\t        return\n\t    for name, adder in _adders.items():\n\t        if name not in disable_list:\n\t            try:\n\t                logger.info(f\"Instrumenting {name}\")\n\t                adder()\n\t            except ModuleNotFoundError:\n\t                pass\n"]}
{"filename": "src/appsignal/agent.py", "chunked_list": ["from __future__ import annotations\n\timport subprocess\n\tfrom dataclasses import dataclass\n\tfrom pathlib import Path\n\tfrom .config import Config\n\t@dataclass\n\tclass Agent:\n\t    path: Path = Path(__file__).parent / \"appsignal-agent\"\n\t    active: bool = False\n\t    def start(self, config: Config) -> None:\n", "        config.set_private_environ()\n\t        p = subprocess.Popen(\n\t            [self.path, \"start\", \"--private\"],\n\t            stdout=subprocess.PIPE,\n\t            stderr=subprocess.PIPE,\n\t        )\n\t        p.wait(timeout=1)\n\t        returncode = p.returncode\n\t        if returncode == 0:\n\t            self.active = True\n", "        else:\n\t            output, _ = p.communicate()\n\t            out = output.decode(\"utf-8\")\n\t            print(f\"AppSignal agent is unable to start ({returncode}): \", out)\n\t    def diagnose(self) -> bytes:\n\t        return subprocess.run([self.path, \"diagnose\"], capture_output=True).stdout\n\t    def version(self) -> bytes:\n\t        return subprocess.run(\n\t            [self.path, \"--version\"], capture_output=True\n\t        ).stdout.split()[-1]\n", "agent = Agent()\n"]}
{"filename": "src/appsignal/config.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\timport platform\n\timport tempfile\n\tfrom typing import (\n\t    TYPE_CHECKING,\n\t    Any,\n\t    ClassVar,\n\t    List,\n\t    Literal,\n", "    TypedDict,\n\t    cast,\n\t    get_args,\n\t)\n\tfrom .__about__ import __version__\n\tif TYPE_CHECKING:\n\t    pass\n\tclass Options(TypedDict, total=False):\n\t    active: bool | None\n\t    app_path: str | None\n", "    bind_address: str | None\n\t    ca_file_path: str | None\n\t    diagnose_endpoint: str | None\n\t    disable_default_instrumentations: None | (\n\t        list[Config.DefaultInstrumentation] | bool\n\t    )\n\t    dns_servers: list[str] | None\n\t    enable_host_metrics: bool | None\n\t    enable_nginx_metrics: bool | None\n\t    enable_statsd: bool | None\n", "    endpoint: str | None\n\t    environment: str | None\n\t    files_world_accessible: bool | None\n\t    filter_parameters: list[str] | None\n\t    filter_session_data: list[str] | None\n\t    hostname: str | None\n\t    http_proxy: str | None\n\t    ignore_actions: list[str] | None\n\t    ignore_errors: list[str] | None\n\t    ignore_namespaces: list[str] | None\n", "    log: str | None\n\t    log_level: str | None\n\t    log_path: str | None\n\t    name: str | None\n\t    push_api_key: str | None\n\t    revision: str | None\n\t    request_headers: list[str] | None\n\t    running_in_container: bool | None\n\t    send_environment_metadata: bool | None\n\t    send_params: bool | None\n", "    send_session_data: bool | None\n\t    working_directory_path: str | None\n\tclass Sources(TypedDict):\n\t    default: Options\n\t    system: Options\n\t    initial: Options\n\t    environment: Options\n\tclass Config:\n\t    sources: Sources\n\t    CA_FILE_PATH = os.path.join(\n", "        os.path.dirname(os.path.abspath(__file__)), \"resources\", \"cacert.pem\"\n\t    )\n\t    DEFAULT_CONFIG = Options(\n\t        ca_file_path=CA_FILE_PATH,\n\t        diagnose_endpoint=\"https://appsignal.com/diag\",\n\t        enable_host_metrics=True,\n\t        enable_nginx_metrics=False,\n\t        enable_statsd=False,\n\t        environment=\"development\",\n\t        endpoint=\"https://push.appsignal.com\",\n", "        files_world_accessible=True,\n\t        log=\"file\",\n\t        log_level=\"info\",\n\t        send_environment_metadata=True,\n\t        send_params=True,\n\t        send_session_data=True,\n\t        request_headers=[\n\t            \"accept\",\n\t            \"accept-charset\",\n\t            \"accept-encoding\",\n", "            \"accept-language\",\n\t            \"cache-control\",\n\t            \"connection\",\n\t            \"content-length\",\n\t            \"range\",\n\t        ],\n\t    )\n\t    DefaultInstrumentation = Literal[\n\t        \"opentelemetry.instrumentation.celery\",\n\t        \"opentelemetry.instrumentation.django\",\n", "        \"opentelemetry.instrumentation.flask\",\n\t        \"opentelemetry.instrumentation.jinja2\",\n\t        \"opentelemetry.instrumentation.psycopg2\",\n\t        \"opentelemetry.instrumentation.redis\",\n\t        \"opentelemetry.instrumentation.requests\",\n\t    ]\n\t    DEFAULT_INSTRUMENTATIONS = cast(\n\t        List[DefaultInstrumentation], list(get_args(DefaultInstrumentation))\n\t    )\n\t    def __init__(self, options: Options | None = None) -> None:\n", "        self.sources = Sources(\n\t            default=self.DEFAULT_CONFIG,\n\t            system=Config.load_from_system(),\n\t            initial=options or Options(),\n\t            environment=Config.load_from_environment(),\n\t        )\n\t        final_options = Options()\n\t        final_options.update(self.sources[\"default\"])\n\t        final_options.update(self.sources[\"system\"])\n\t        final_options.update(self.sources[\"environment\"])\n", "        final_options.update(self.sources[\"initial\"])\n\t        self.options = final_options\n\t    def option(self, option: str) -> Any:\n\t        return self.options.get(option)\n\t    @staticmethod\n\t    def load_from_system() -> Options:\n\t        return Options(app_path=os.getcwd())\n\t    @staticmethod\n\t    def load_from_environment() -> Options:\n\t        options = Options(\n", "            active=parse_bool(os.environ.get(\"APPSIGNAL_ACTIVE\")),\n\t            bind_address=os.environ.get(\"APPSIGNAL_BIND_ADDRESS\"),\n\t            ca_file_path=os.environ.get(\"APPSIGNAL_CA_FILE_PATH\"),\n\t            diagnose_endpoint=os.environ.get(\"APPSIGNAL_DIAGNOSE_ENDPOINT\"),\n\t            disable_default_instrumentations=parse_disable_default_instrumentations(\n\t                os.environ.get(\"APPSIGNAL_DISABLE_DEFAULT_INSTRUMENTATIONS\")\n\t            ),\n\t            dns_servers=parse_list(os.environ.get(\"APPSIGNAL_DNS_SERVERS\")),\n\t            enable_host_metrics=parse_bool(\n\t                os.environ.get(\"APPSIGNAL_ENABLE_HOST_METRICS\")\n", "            ),\n\t            enable_nginx_metrics=parse_bool(\n\t                os.environ.get(\"APPSIGNAL_ENABLE_NGINX_METRICS\")\n\t            ),\n\t            enable_statsd=parse_bool(os.environ.get(\"APPSIGNAL_ENABLE_STATSD\")),\n\t            endpoint=os.environ.get(\"APPSIGNAL_PUSH_API_ENDPOINT\"),\n\t            environment=os.environ.get(\"APPSIGNAL_APP_ENV\"),\n\t            files_world_accessible=parse_bool(\n\t                os.environ.get(\"APPSIGNAL_FILES_WORLD_ACCESSIBLE\")\n\t            ),\n", "            filter_parameters=parse_list(os.environ.get(\"APPSIGNAL_FILTER_PARAMETERS\")),\n\t            filter_session_data=parse_list(\n\t                os.environ.get(\"APPSIGNAL_FILTER_SESSION_DATA\")\n\t            ),\n\t            hostname=os.environ.get(\"APPSIGNAL_HOSTNAME\"),\n\t            http_proxy=os.environ.get(\"APPSIGNAL_HTTP_PROXY\"),\n\t            ignore_actions=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_ACTIONS\")),\n\t            ignore_errors=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_ERRORS\")),\n\t            ignore_namespaces=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_NAMESPACES\")),\n\t            log=os.environ.get(\"APPSIGNAL_LOG\"),\n", "            log_level=os.environ.get(\"APPSIGNAL_LOG_LEVEL\"),\n\t            log_path=os.environ.get(\"APPSIGNAL_LOG_PATH\"),\n\t            name=os.environ.get(\"APPSIGNAL_APP_NAME\"),\n\t            push_api_key=os.environ.get(\"APPSIGNAL_PUSH_API_KEY\"),\n\t            revision=os.environ.get(\"APP_REVISION\"),\n\t            request_headers=parse_list(os.environ.get(\"APPSIGNAL_REQUEST_HEADERS\")),\n\t            running_in_container=parse_bool(\n\t                os.environ.get(\"APPSIGNAL_RUNNING_IN_CONTAINER\")\n\t            ),\n\t            send_environment_metadata=parse_bool(\n", "                os.environ.get(\"APPSIGNAL_SEND_ENVIRONMENT_METADATA\")\n\t            ),\n\t            send_params=parse_bool(os.environ.get(\"APPSIGNAL_SEND_PARAMS\")),\n\t            send_session_data=parse_bool(os.environ.get(\"APPSIGNAL_SEND_SESSION_DATA\")),\n\t            working_directory_path=os.environ.get(\"APPSIGNAL_WORKING_DIRECTORY_PATH\"),\n\t        )\n\t        for key, value in list(options.items()):\n\t            if value is None:\n\t                del cast(dict, options)[key]\n\t        return options\n", "    CONSTANT_PRIVATE_ENVIRON: ClassVar[dict[str, str]] = {\n\t        \"_APPSIGNAL_LANGUAGE_INTEGRATION_VERSION\": f\"python-{__version__}\",\n\t        \"_APPSIGNAL_ENABLE_OPENTELEMETRY_HTTP\": \"true\",\n\t    }\n\t    def set_private_environ(self) -> None:\n\t        options = self.options\n\t        private_environ = {\n\t            \"_APPSIGNAL_ACTIVE\": bool_to_env_str(options.get(\"active\")),\n\t            \"_APPSIGNAL_APP_ENV\": options.get(\"environment\"),\n\t            \"_APPSIGNAL_APP_NAME\": options.get(\"name\"),\n", "            \"_APPSIGNAL_APP_PATH\": options.get(\"app_path\"),\n\t            \"_APPSIGNAL_BIND_ADDRESS\": options.get(\"bind_address\"),\n\t            \"_APPSIGNAL_CA_FILE_PATH\": options.get(\"ca_file_path\"),\n\t            \"_APPSIGNAL_DNS_SERVERS\": list_to_env_str(options.get(\"dns_servers\")),\n\t            \"_APPSIGNAL_DIAGNOSE_ENDPOINT\": options.get(\"diagnose_endpoint\"),\n\t            \"_APPSIGNAL_ENABLE_HOST_METRICS\": bool_to_env_str(\n\t                options.get(\"enable_host_metrics\")\n\t            ),\n\t            \"_APPSIGNAL_ENABLE_NGINX_METRICS\": bool_to_env_str(\n\t                options.get(\"enable_nginx_metrics\")\n", "            ),\n\t            \"_APPSIGNAL_ENABLE_STATSD\": bool_to_env_str(options.get(\"enable_statsd\")),\n\t            \"_APPSIGNAL_FILES_WORLD_ACCESSIBLE\": bool_to_env_str(\n\t                options.get(\"files_world_accessible\")\n\t            ),\n\t            \"_APPSIGNAL_FILTER_PARAMETERS\": list_to_env_str(\n\t                options.get(\"filter_parameters\")\n\t            ),\n\t            \"_APPSIGNAL_FILTER_SESSION_DATA\": list_to_env_str(\n\t                options.get(\"filter_session_data\")\n", "            ),\n\t            \"_APPSIGNAL_HOSTNAME\": options.get(\"hostname\"),\n\t            \"_APPSIGNAL_HTTP_PROXY\": options.get(\"http_proxy\"),\n\t            \"_APPSIGNAL_IGNORE_ACTIONS\": list_to_env_str(options.get(\"ignore_actions\")),\n\t            \"_APPSIGNAL_IGNORE_ERRORS\": list_to_env_str(options.get(\"ignore_errors\")),\n\t            \"_APPSIGNAL_IGNORE_NAMESPACES\": list_to_env_str(\n\t                options.get(\"ignore_namespaces\")\n\t            ),\n\t            \"_APPSIGNAL_LOG\": options.get(\"log\"),\n\t            \"_APPSIGNAL_LOG_LEVEL\": options.get(\"log_level\"),\n", "            \"_APPSIGNAL_LOG_FILE_PATH\": self.log_file_path(),\n\t            \"_APPSIGNAL_PUSH_API_KEY\": options.get(\"push_api_key\"),\n\t            \"_APPSIGNAL_PUSH_API_ENDPOINT\": options.get(\"endpoint\"),\n\t            \"_APPSIGNAL_RUNNING_IN_CONTAINER\": bool_to_env_str(\n\t                options.get(\"running_in_container\")\n\t            ),\n\t            \"_APPSIGNAL_SEND_ENVIRONMENT_METADATA\": bool_to_env_str(\n\t                options.get(\"send_environment_metadata\")\n\t            ),\n\t            \"_APPSIGNAL_SEND_PARAMS\": bool_to_env_str(options.get(\"send_params\")),\n", "            \"_APPSIGNAL_SEND_SESSION_DATA\": bool_to_env_str(\n\t                options.get(\"send_session_data\")\n\t            ),\n\t            \"_APPSIGNAL_WORKING_DIRECTORY_PATH\": options.get(\"working_directory_path\"),\n\t            \"_APP_REVISION\": options.get(\"revision\"),\n\t        }\n\t        private_environ.update(self.CONSTANT_PRIVATE_ENVIRON)\n\t        for var, value in private_environ.items():\n\t            if value is not None:\n\t                os.environ[var] = str(value)\n", "    def log_file_path(self) -> str | None:\n\t        path = self.options.get(\"log_path\")\n\t        if path:\n\t            _, ext = os.path.splitext(path)\n\t            if ext:\n\t                path = os.path.dirname(path)\n\t            if not os.access(path, os.W_OK):\n\t                print(\n\t                    f\"appsignal: Unable to write to configured '{path}'. Please \"\n\t                    \"check the permissions of the 'log_path' directory.\"\n", "                )\n\t                path = None\n\t        if not path:\n\t            path = \"/tmp\" if platform.system() == \"Darwin\" else tempfile.gettempdir()\n\t        if not os.access(path, os.W_OK):\n\t            print(\n\t                f\"appsignal: Unable to write to '{path}'. Please check the \"\n\t                \"permissions of the 'log_path' directory.\"\n\t            )\n\t            return None\n", "        return os.path.join(path, \"appsignal.log\")\n\tdef parse_bool(value: str | None) -> bool | None:\n\t    if value is None:\n\t        return None\n\t    val = value.lower()\n\t    if val == \"true\":\n\t        return True\n\t    if val == \"false\":\n\t        return False\n\t    return None\n", "def parse_list(value: str | None) -> list[str] | None:\n\t    if value is None:\n\t        return None\n\t    return value.split(\",\")\n\tdef parse_disable_default_instrumentations(\n\t    value: str | None,\n\t) -> list[Config.DefaultInstrumentation] | bool | None:\n\t    if value is None:\n\t        return None\n\t    if value.lower() == \"true\":\n", "        return True\n\t    if value.lower() == \"false\":\n\t        return False\n\t    return cast(\n\t        List[Config.DefaultInstrumentation],\n\t        [x for x in value.split(\",\") if x in Config.DEFAULT_INSTRUMENTATIONS],\n\t    )\n\tdef bool_to_env_str(value: bool | None) -> str | None:\n\t    if value is None:\n\t        return None\n", "    return str(value).lower()\n\tdef list_to_env_str(value: list[str] | None) -> str | None:\n\t    if value is None:\n\t        return None\n\t    return \",\".join(value)\n"]}
{"filename": "src/appsignal/client.py", "chunked_list": ["from __future__ import annotations\n\timport logging\n\timport sys\n\tfrom logging import DEBUG, ERROR, INFO, WARNING, Logger\n\tfrom typing import TYPE_CHECKING, ClassVar\n\tfrom .agent import agent\n\tfrom .config import Config, Options\n\tfrom .opentelemetry import start_opentelemetry\n\tif TYPE_CHECKING:\n\t    from typing_extensions import Unpack\n", "class Client:\n\t    _logger: Logger\n\t    _config: Config\n\t    LOG_LEVELS: ClassVar[dict[str, int]] = {\n\t        \"error\": ERROR,\n\t        \"warning\": WARNING,\n\t        \"info\": INFO,\n\t        \"debug\": DEBUG,\n\t        \"trace\": DEBUG,\n\t    }\n", "    def __init__(self, **options: Unpack[Options]) -> None:\n\t        self._config = Config(options)\n\t        self.start_logger()\n\t        if not self._config.option(\"active\"):\n\t            self._logger.info(\"AppSignal not starting: no active config found\")\n\t    def start(self) -> None:\n\t        if self._config.option(\"active\"):\n\t            self._logger.info(\"Starting AppSignal\")\n\t            agent.start(self._config)\n\t            start_opentelemetry(self._config)\n", "    def start_logger(self) -> None:\n\t        self._logger = logging.getLogger(\"appsignal\")\n\t        self._logger.setLevel(self.LOG_LEVELS[self._config.option(\"log_level\")])\n\t        if self._config.option(\"log\") == \"file\":\n\t            log_file_path = self._config.log_file_path()\n\t            if log_file_path:\n\t                handler = logging.FileHandler(log_file_path)\n\t                handler.setFormatter(\n\t                    logging.Formatter(\n\t                        \"[%(asctime)s (process) #%(process)d][%(levelname)s] \"\n", "                        \"%(message)s\",\n\t                        \"%Y-%m-%dT%H:%M:%S\",\n\t                    )\n\t                )\n\t                self._logger.addHandler(handler)\n\t            else:\n\t                self._start_stdout_logger()\n\t        else:\n\t            self._start_stdout_logger()\n\t    def _start_stdout_logger(self) -> None:\n", "        handler = logging.StreamHandler(sys.stdout)\n\t        handler.setFormatter(\n\t            logging.Formatter(\n\t                \"[%(asctime)s (process) #%(process)d][appsignal][%(levelname)s] \"\n\t                \"%(message)s\",\n\t                \"%Y-%m-%dT%H:%M:%S\",\n\t            )\n\t        )\n\t        self._logger.addHandler(handler)\n"]}
{"filename": "src/appsignal/__init__.py", "chunked_list": ["from .client import Client as Appsignal\n\t__all__ = [\"Appsignal\"]\n\t# Try and load the appsignal-beta package. If it's present and imported, it\n\t# will print a message about switching to the `appsignal` package.\n\ttry:\n\t    import appsignal_beta  # type:ignore # noqa: F401\n\texcept ImportError:\n\t    pass\n"]}
{"filename": "src/appsignal/push_api_key_validator.py", "chunked_list": ["import urllib\n\timport requests\n\tfrom appsignal.config import Config\n\tclass PushApiKeyValidator:\n\t    @staticmethod\n\t    def validate(config: Config) -> str:\n\t        endpoint = config.option(\"endpoint\")\n\t        params = urllib.parse.urlencode(\n\t            {\n\t                \"api_key\": config.option(\"push_api_key\"),\n", "                \"name\": config.option(\"name\"),\n\t                \"environment\": config.option(\"environment\"),\n\t                \"hostname\": config.option(\"hostname\") or \"\",\n\t            }\n\t        )\n\t        url = f\"{endpoint}/1/auth?{params}\"\n\t        proxies = {}\n\t        if config.option(\"http_proxy\"):\n\t            proxies[\"http\"] = config.option(\"http_proxy\")\n\t            proxies[\"https\"] = config.option(\"http_proxy\")\n", "        cert = config.option(\"ca_file_path\")\n\t        response = requests.post(url, proxies=proxies, verify=cert)\n\t        if response.status_code == 200:\n\t            return \"valid\"\n\t        if response.status_code == 401:\n\t            return \"invalid\"\n\t        return str(response.status_code)\n"]}
{"filename": "src/appsignal/__about__.py", "chunked_list": ["from __future__ import annotations\n\t__version__ = \"0.2.1\"\n"]}
{"filename": "src/appsignal/cli/version.py", "chunked_list": ["from __future__ import annotations\n\tfrom argparse import ArgumentParser\n\tfrom ..__about__ import __version__\n\tfrom .command import AppsignalCLICommand\n\tclass VersionCommand(AppsignalCLICommand):\n\t    \"\"\"Show the SDK version and exit.\"\"\"\n\t    @staticmethod\n\t    def init_parser(parser: ArgumentParser) -> None:\n\t        pass\n\t    def run(self) -> int:\n", "        print(__version__)\n\t        return 0\n"]}
{"filename": "src/appsignal/cli/base.py", "chunked_list": ["from __future__ import annotations\n\timport sys\n\tfrom argparse import ArgumentParser\n\tfrom typing import Mapping, NoReturn\n\tfrom .command import AppsignalCLICommand\n\tfrom .demo import DemoCommand\n\tfrom .diagnose import DiagnoseCommand\n\tfrom .install import InstallCommand\n\tfrom .version import VersionCommand\n\tCOMMANDS: Mapping[str, type[AppsignalCLICommand]] = {\n", "    \"demo\": DemoCommand,\n\t    \"install\": InstallCommand,\n\t    \"version\": VersionCommand,\n\t    \"diagnose\": DiagnoseCommand,\n\t}\n\tdef run() -> NoReturn:\n\t    \"\"\"The entry point for CLI.\"\"\"\n\t    sys.exit(main(sys.argv[1:]))\n\tdef main(argv: list[str]) -> int:\n\t    parser = ArgumentParser(\"appsignal\", description=\"AppSignal for Python CLI.\")\n", "    _register_commands(parser)\n\t    args = parser.parse_args(argv)\n\t    cmd_class: type[AppsignalCLICommand] | None\n\t    cmd_class = args.cmd\n\t    if cmd_class is None:\n\t        parser.print_help()\n\t        return 1\n\t    cmd = cmd_class(args=args)\n\t    try:\n\t        return cmd.run()\n", "    except KeyboardInterrupt:\n\t        return 0\n\tdef _register_commands(parser: ArgumentParser) -> None:\n\t    subparsers = parser.add_subparsers()\n\t    parser.set_defaults(cmd=None)\n\t    cmd_class: type[AppsignalCLICommand]\n\t    for name, cmd_class in COMMANDS.items():\n\t        subparser = subparsers.add_parser(name=name, help=cmd_class.__doc__)\n\t        subparser.set_defaults(cmd=cmd_class)\n\t        cmd_class.init_parser(subparser)\n"]}
{"filename": "src/appsignal/cli/diagnose.py", "chunked_list": ["# ruff: noqa: E501\n\tfrom __future__ import annotations\n\timport json\n\timport os\n\timport platform\n\timport urllib\n\tfrom argparse import ArgumentParser\n\tfrom typing import Any\n\timport requests\n\tfrom appsignal.agent import Agent\n", "from appsignal.config import Config\n\tfrom appsignal.push_api_key_validator import PushApiKeyValidator\n\tfrom ..__about__ import __version__\n\tfrom .command import AppsignalCLICommand\n\tclass AgentReport:\n\t    def __init__(self, report: dict) -> None:\n\t        self.report = report\n\t    def configuration_valid(self) -> str:\n\t        if self.report[\"config\"][\"valid\"][\"result\"]:\n\t            return \"valid\"\n", "        return \"invalid\"\n\t    def configuration_error(self) -> str | None:\n\t        if self.configuration_valid() == \"invalid\":\n\t            return self.report[\"config\"][\"valid\"][\"error\"]\n\t        return None\n\t    def started(self) -> str:\n\t        if self.report[\"boot\"][\"started\"][\"result\"]:\n\t            return \"started\"\n\t        return \"not started\"\n\t    def user_id(self) -> str:\n", "        return self.report[\"host\"][\"uid\"][\"result\"]\n\t    def group_id(self) -> str:\n\t        return self.report[\"host\"][\"gid\"][\"result\"]\n\t    def logger_started(self) -> str:\n\t        if \"logger\" in self.report:\n\t            if self.report[\"logger\"][\"started\"][\"result\"]:\n\t                return \"started\"\n\t            return \"not started\"\n\t        return \"-\"\n\t    def working_directory_user_id(self) -> str:\n", "        if \"working_directory_stat\" in self.report:\n\t            return self.report[\"working_directory_stat\"][\"uid\"][\"result\"]\n\t        return \"-\"\n\t    def working_directory_group_id(self) -> str:\n\t        if \"working_directory_stat\" in self.report:\n\t            return self.report[\"working_directory_stat\"][\"gid\"][\"result\"]\n\t        return \"-\"\n\t    def working_directory_permissions(self) -> str:\n\t        if \"working_directory_stat\" in self.report:\n\t            return self.report[\"working_directory_stat\"][\"mode\"][\"result\"]\n", "        return \"-\"\n\t    def lock_path(self) -> str:\n\t        if \"lock_path\" in self.report:\n\t            if self.report[\"lock_path\"][\"created\"][\"result\"]:\n\t                return \"writable\"\n\t            return \"not writable\"\n\t        return \"-\"\n\tclass DiagnoseCommand(AppsignalCLICommand):\n\t    @staticmethod\n\t    def init_parser(parser: ArgumentParser) -> None:\n", "        parser.add_argument(\n\t            \"--send-report\",\n\t            action=\"store_true\",\n\t            help=\"Send the report to AppSignal\",\n\t        )\n\t        parser.add_argument(\n\t            \"--no-send-report\",\n\t            action=\"store_true\",\n\t            help=\"Do not send the report to AppSignal\",\n\t        )\n", "    def run(self) -> int:\n\t        self.send_report = self.args.send_report\n\t        self.no_send_report = self.args.no_send_report\n\t        if self.send_report and self.no_send_report:\n\t            print(\"Error: Cannot use --send-report and --no-send-report together.\")\n\t            return 1\n\t        agent = Agent()\n\t        agent_json = json.loads(agent.diagnose())\n\t        self.config = Config()\n\t        self.agent_report = AgentReport(agent_json)\n", "        self.report = {\n\t            \"agent\": {\n\t                \"agent\": {\n\t                    \"boot\": agent_json[\"boot\"],\n\t                    \"config\": {\n\t                        \"valid\": agent_json[\"config\"][\"valid\"],\n\t                    },\n\t                    \"host\": agent_json[\"host\"],\n\t                    \"lock_path\": agent_json.get(\"lock_path\"),\n\t                    \"logger\": agent_json.get(\"logger\"),\n", "                    \"working_directory_stat\": agent_json.get(\"working_directory_stat\"),\n\t                }\n\t            },\n\t            \"config\": {\n\t                \"options\": self.config.options,\n\t                \"sources\": self.config.sources,\n\t            },\n\t            \"host\": {\n\t                \"architecture\": platform.machine(),\n\t                \"heroku\": os.environ.get(\"DYNO\") is not None,\n", "                \"language_version\": platform.python_version(),\n\t                \"os\": platform.system().lower(),\n\t                \"os_distribution\": self._os_distribution(),\n\t                \"root\": os.getuid() == 0,\n\t            },\n\t            \"library\": {\n\t                \"language\": \"python\",\n\t                \"package_version\": __version__,\n\t                \"agent_version\": str(agent.version(), \"utf-8\"),\n\t            },\n", "            \"paths\": self._paths_data(),\n\t            \"process\": {\n\t                \"uid\": os.getuid(),\n\t            },\n\t            \"validation\": {\"push_api_key\": self._validate_push_api_key()},\n\t        }\n\t        self._header()\n\t        print()\n\t        self._library_information()\n\t        print()\n", "        self._host_information()\n\t        print()\n\t        self._agent_information()\n\t        print()\n\t        self._configuration_information()\n\t        print()\n\t        self._validation_information()\n\t        print()\n\t        self._paths_information()\n\t        print()\n", "        self._report_information()\n\t        if self.send_report or (not self.no_send_report and self._report_prompt()):\n\t            self._send_diagnose_report()\n\t        elif self.no_send_report:\n\t            print(\"Not sending report. (Specified with the --no-send-report option.)\")\n\t        return 0\n\t    def _header(self) -> None:\n\t        print(\"AppSignal diagnose\")\n\t        print(\"=\" * 80)\n\t        print(\"Use this information to debug your configuration.\")\n", "        print(\"More information is available on the documentation site.\")\n\t        print(\"https://docs.appsignal.com/\")\n\t        print(\"Send this output to support@appsignal.com if you need help.\")\n\t        print(\"=\" * 80)\n\t    def _library_information(self) -> None:\n\t        library_report: Any = self.report[\"library\"]\n\t        print(\"AppSignal library\")\n\t        print(\"  Language: Python\")\n\t        print(f'  Package version: \"{library_report[\"package_version\"]}\"')\n\t        print(f'  Agent version: \"{library_report[\"agent_version\"]}\"')\n", "    def _host_information(self) -> None:\n\t        host_report: Any = self.report[\"host\"]\n\t        print(\"Host information\")\n\t        print(f'  Architecture: \"{host_report[\"architecture\"]}\"')\n\t        print(f'  Operating System: \"{host_report[\"os\"]}\"')\n\t        print(f'  Python version: \"{host_report[\"language_version\"]}\"')\n\t        print(f'  Root user: {host_report[\"root\"]}')\n\t    def _agent_information(self) -> None:\n\t        print(\"Agent diagnostics\")\n\t        print(\"  Agent tests\")\n", "        print(f\"    Started: {self.agent_report.started()}\")\n\t        print(f\"    Process user id: {self.agent_report.user_id()}\")\n\t        print(f\"    Process user group id: {self.agent_report.group_id()}\")\n\t        print(f\"    Configuration: {self.agent_report.configuration_valid()}\")\n\t        if self.agent_report.configuration_error():\n\t            print(f\"        Error: {self.agent_report.configuration_error()}\")\n\t        print(f\"    Logger: {self.agent_report.logger_started()}\")\n\t        print(\n\t            f\"    Working directory user id: {self.agent_report.working_directory_user_id()}\"\n\t        )\n", "        print(\n\t            f\"    Working directory user group id: {self.agent_report.working_directory_group_id()}\"\n\t        )\n\t        print(\n\t            f\"    Working directory permissions: {self.agent_report.working_directory_permissions()}\"\n\t        )\n\t        print(f\"    Lock path: {self.agent_report.lock_path()}\")\n\t    def _configuration_information(self) -> None:\n\t        print(\"Configuration\")\n\t        for key in self.config.options:\n", "            print(f\"  {key}: {self.config.options[key]!r}\")  # type: ignore\n\t        print()\n\t        print(\"Read more about how the diagnose config output is rendered\")\n\t        print(\"https://docs.appsignal.com/python/command-line/diagnose.html\")\n\t    def _validation_information(self) -> None:\n\t        validation_report: Any = self.report[\"validation\"]\n\t        print(\"Validation\")\n\t        print(f'  Validating Push API key: {validation_report[\"push_api_key\"]}')\n\t    def _paths_information(self) -> None:\n\t        log_file_path = self.config.log_file_path() or \"\"\n", "        log_path = self.config.option(\"log_path\") or os.path.dirname(log_file_path)\n\t        log_file_lines = self._last_ten_lines(log_file_path)\n\t        print(\"Paths\")\n\t        print(\"  Current working directory\")\n\t        print(f\"    Path: '{os.getcwd()}'\")\n\t        print()\n\t        print(\"  Log directory\")\n\t        print(f\"    Path: '{log_path}'\")\n\t        print()\n\t        print(\"  AppSignal log\")\n", "        print(f\"    Path: '{log_file_path}'\")\n\t        print(\"    Contents (last 10 lines):\")\n\t        for line in log_file_lines:\n\t            print(line.strip())\n\t    def _report_information(self) -> None:\n\t        print(\"Diagnostics report\")\n\t    def _report_prompt(self) -> bool | None:\n\t        print(\"  Do you want to send this diagnostics report to AppSignal?\")\n\t        print(\"  If you share this report you will be given a link to\")\n\t        print(\"  AppSignal.com to validate the report.\")\n", "        print(\"  You can also contact us at support@appsignal.com\")\n\t        print(\"  with your support token.\")\n\t        print()\n\t        send_report = input(\"  Send diagnostics report to AppSignal? (Y/n):   \").lower()\n\t        if send_report in [\"y\", \"yes\", \"\"]:\n\t            print(\"Transmitting diagnostics report\")\n\t            return True\n\t        if send_report in [\"n\", \"no\"]:\n\t            print(\"Not sending diagnostics information to AppSignal.\")\n\t            return False\n", "        self._report_prompt()\n\t        return None\n\t    def _send_diagnose_report(self) -> None:\n\t        params = urllib.parse.urlencode(\n\t            {\n\t                \"api_key\": self.config.option(\"push_api_key\"),\n\t                \"name\": self.config.option(\"name\"),\n\t                \"environment\": self.config.option(\"environment\"),\n\t                \"hostname\": self.config.option(\"hostname\") or \"\",\n\t            }\n", "        )\n\t        endpoint = self.config.option(\"diagnose_endpoint\")\n\t        url = f\"{endpoint}?{params}\"\n\t        response = requests.post(url, json={\"diagnose\": self.report})\n\t        status = response.status_code\n\t        if status == 200:\n\t            token = response.json()[\"token\"]\n\t            print()\n\t            print(f\"  Your support token: {token}\")\n\t            print(f\"  View this report:   https://appsignal.com/diagnose/{token}\")\n", "        else:\n\t            print(\n\t                \"  Error: Something went wrong while submitting the report to AppSignal.\"\n\t            )\n\t            print(f\"  Response code: {status}\")\n\t            print(f\"  Response body: {response.text}\")\n\t    def _paths_data(self) -> dict:\n\t        working_dir = os.getcwd() or \"\"\n\t        log_file_path = self.config.log_file_path() or \"\"\n\t        log_path = self.config.option(\"log_path\") or os.path.dirname(log_file_path)\n", "        log_file_lines = self._read_last_two_mib(log_file_path)\n\t        return {\n\t            \"appsignal.log\": {\n\t                \"content\": log_file_lines,\n\t                \"exists\": os.path.exists(log_file_path),\n\t                \"mode\": self._file_stat(log_file_path).get(\"mode\"),\n\t                \"ownership\": self._file_stat(log_file_path).get(\"ownership\"),\n\t                \"path\": log_file_path,\n\t                \"type\": self._file_type(log_file_path),\n\t                \"writable\": self._file_is_writable(log_file_path),\n", "            },\n\t            \"log_dir_path\": {\n\t                \"exists\": os.path.exists(log_path),\n\t                \"mode\": self._file_stat(log_path).get(\"mode\"),\n\t                \"ownership\": self._file_stat(log_path).get(\"ownership\"),\n\t                \"path\": log_path,\n\t                \"type\": self._file_type(log_path),\n\t                \"writable\": self._file_is_writable(log_path),\n\t            },\n\t            \"working_dir\": {\n", "                \"exists\": os.path.exists(working_dir),\n\t                \"mode\": self._file_stat(working_dir).get(\"mode\"),\n\t                \"ownership\": self._file_stat(working_dir).get(\"ownership\"),\n\t                \"path\": working_dir,\n\t                \"type\": self._file_type(working_dir),\n\t                \"writable\": self._file_is_writable(working_dir),\n\t            },\n\t        }\n\t    def _file_stat(self, path: str) -> dict:\n\t        try:\n", "            file_stat = os.stat(path)\n\t            return {\n\t                \"mode\": str(file_stat.st_mode),\n\t                \"ownership\": {\n\t                    \"gid\": file_stat.st_gid,\n\t                    \"uid\": file_stat.st_uid,\n\t                },\n\t            }\n\t        except FileNotFoundError:\n\t            return {}\n", "    def _file_type(self, path: str) -> str:\n\t        if os.path.exists(path):\n\t            if os.path.isfile(path):\n\t                return \"file\"\n\t            if os.path.isdir(path):\n\t                return \"directory\"\n\t        return \"\"\n\t    def _file_is_writable(self, path: str) -> bool:\n\t        return os.access(path, os.W_OK)\n\t    def _os_distribution(self) -> str:\n", "        try:\n\t            return platform.freedesktop_os_release()[\"NAME\"]\n\t        # The platform.freedesktop_os_release is not available in all Python\n\t        # versions that we support. That's why we catch AttributeError along with\n\t        # OSError which is thrown when the host OS doesn't comply with freedesktop.\n\t        except (OSError, AttributeError):\n\t            return \"\"\n\t    def _validate_push_api_key(self) -> str:\n\t        api_key_validation = PushApiKeyValidator.validate(self.config)\n\t        if api_key_validation == \"valid\":\n", "            return \"valid\"\n\t        if api_key_validation == \"invalid\":\n\t            return \"invalid\"\n\t        return f\"Failed to validate: {api_key_validation}\"\n\t    def _last_ten_lines(self, file_path: str) -> list[str]:\n\t        try:\n\t            file_contents = self._read_last_two_mib(file_path)\n\t            lines = file_contents.splitlines()\n\t            file_lines = lines[-10:] if len(lines) > 10 else lines\n\t            file_lines = [line.strip() for line in file_lines]\n", "        except FileNotFoundError:\n\t            file_lines = [\"\"]\n\t        return file_lines\n\t    def _read_last_two_mib(self, path: str) -> str:\n\t        two_mib = 2 * 1024 * 1024\n\t        file_size = os.path.getsize(path)\n\t        with open(path, \"rb\") as file:\n\t            bytes_to_read = two_mib if two_mib < file_size else file_size\n\t            file.seek(-bytes_to_read, os.SEEK_END)\n\t            return file.read().decode(\"utf-8\")\n"]}
{"filename": "src/appsignal/cli/__init__.py", "chunked_list": []}
{"filename": "src/appsignal/cli/demo.py", "chunked_list": ["from __future__ import annotations\n\timport json\n\tfrom opentelemetry import trace\n\tfrom appsignal.client import Client\n\tfrom .command import AppsignalCLICommand\n\tclass DemoCommand(AppsignalCLICommand):\n\t    \"\"\"Run demo application.\"\"\"\n\t    def run(self) -> int:\n\t        print()\n\t        client = Client(\n", "            active=True,\n\t            name=self._name,\n\t            push_api_key=self._push_api_key,\n\t            log_level=\"trace\",\n\t        )\n\t        print(\"Sending example data to AppSignal...\")\n\t        print(f\"Starting AppSignal client for {self._name}...\")\n\t        client.start()\n\t        tracer = trace.get_tracer(__name__)\n\t        # Performance sample\n", "        with tracer.start_as_current_span(\"GET /demo\") as span:\n\t            span.set_attribute(\"http.method\", \"GET\")\n\t            span.set_attribute(\n\t                \"appsignal.request.parameters\",\n\t                json.dumps({\"GET\": {\"id\": 1}, \"POST\": {}}),\n\t            )\n\t            span.set_attribute(\n\t                \"otel.instrumentation_library.name\",\n\t                \"opentelemetry.instrumentation.wsgi\",\n\t            )\n", "            span.set_attribute(\n\t                \"demo_sample\",\n\t                True,\n\t            )\n\t        # Error sample\n\t        with tracer.start_as_current_span(\"GET /demo\") as span:\n\t            span.set_attribute(\"http.method\", \"GET\")\n\t            span.set_attribute(\n\t                \"appsignal.request.parameters\",\n\t                json.dumps({\"GET\": {\"id\": 1}, \"POST\": {}}),\n", "            )\n\t            span.set_attribute(\n\t                \"demo_sample\",\n\t                True,\n\t            )\n\t            try:\n\t                raise ValueError(\"Something went wrong\")\n\t            except ValueError as e:\n\t                span.record_exception(e)\n\t        return 0\n"]}
{"filename": "src/appsignal/cli/install.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\timport requests\n\tfrom .command import AppsignalCLICommand\n\tfrom .demo import DemoCommand\n\tINSTALL_FILE_TEMPLATE = \"\"\"from appsignal import Appsignal\n\tappsignal = Appsignal(\n\t    active=True,\n\t    name=\"{name}\",\n\t    push_api_key=\"{push_api_key}\",\n", ")\n\t\"\"\"\n\tINSTALL_FILE_NAME = \"__appsignal__.py\"\n\tclass InstallCommand(AppsignalCLICommand):\n\t    \"\"\"Generate Appsignal client integration code.\"\"\"\n\t    def run(self) -> int:\n\t        # Make sure to show input prompts before the welcome text.\n\t        self._name  # noqa: B018\n\t        self._push_api_key  # noqa: B018\n\t        print(\"👋 Welcome to the AppSignal for Python installer!\")\n", "        print()\n\t        print(\"Reach us at support@appsignal.com for support\")\n\t        print(\"Documentation available at https://docs.appsignal.com/python\")\n\t        print()\n\t        print()\n\t        print(\"Validating API key\")\n\t        print()\n\t        if self._validate_push_api_key():\n\t            print(\"API key is valid!\")\n\t        else:\n", "            print(f\"API key {self._push_api_key} is not valid \")\n\t            print(\"please get a new one on https://appsignal.com\")\n\t            return 1\n\t        if self._should_write_file():\n\t            print(f\"Writing the {INSTALL_FILE_NAME} configuration file...\")\n\t            self._write_file()\n\t            print()\n\t            demo = DemoCommand(args=self.args)\n\t            demo._name = self._name\n\t            demo._push_api_key = self._push_api_key\n", "            demo.run()\n\t            if self._search_dependency(\"django\"):\n\t                self._django_installation()\n\t            elif self._search_dependency(\"flask\"):\n\t                self._flask_installation()\n\t            else:\n\t                self._generic_installation()\n\t        else:\n\t            print(\"Nothing to do. Exiting...\")\n\t        return 0\n", "    def _should_write_file(self) -> bool:\n\t        if os.path.exists(INSTALL_FILE_NAME):\n\t            return self._input_should_overwrite_file()\n\t        return True\n\t    def _input_should_overwrite_file(self) -> bool:\n\t        response = input(\n\t            f\"The {INSTALL_FILE_NAME} file already exists.\"\n\t            \" Should it be overwritten? (y/N): \"\n\t        )\n\t        if len(response) == 0 or response[0].lower() == \"n\":\n", "            return False\n\t        if response[0].lower() == \"y\":\n\t            return True\n\t        print('Please answer \"y\" (yes) or \"n\" (no)')\n\t        return self._input_should_overwrite_file()\n\t    def _write_file(self) -> None:\n\t        with open(INSTALL_FILE_NAME, \"w\") as f:\n\t            file_contents = INSTALL_FILE_TEMPLATE.format(\n\t                name=self._name,\n\t                push_api_key=self._push_api_key,\n", "            )\n\t            f.write(file_contents)\n\t    def _requirements_file(self) -> str | None:\n\t        current_dir = os.getcwd()\n\t        for _root, _dirs, files in os.walk(current_dir):\n\t            for file in files:\n\t                if file.endswith(\"requirements.txt\"):\n\t                    return file\n\t        return None\n\t    def _search_dependency(self, dependency_name: str) -> bool:\n", "        requirement_file = self._requirements_file()\n\t        if requirement_file:\n\t            with open(requirement_file) as f:\n\t                for line in f.readlines():\n\t                    return line.startswith(dependency_name)\n\t        return False\n\t    def _django_installation(self) -> None:\n\t        print(\"We've detected that you're using Django.\")\n\t        print()\n\t        if not self._search_dependency(\"opentelemetry-instrumentation-django\"):\n", "            print(\"Adding the Django instrumentation to your requirements.txt file\")\n\t            print()\n\t            self._add_dependency(\"opentelemetry-instrumentation-django\")\n\t        print(\"Django requires some manual configuration.\")\n\t        print(\"The __appsignal__ module needs to be imported in the manage.py file\")\n\t        print(\"and the appsignal.start() method needs to be called in the main method.\")\n\t        print()\n\t        print(\"Please refer to the documentation for more information:\")\n\t        print(\"https://docs.appsignal.com/python/instrumentations/django.html\")\n\t    def _flask_installation(self) -> None:\n", "        print(\"We've detected that you're using Flask.\")\n\t        print()\n\t        if not self._search_dependency(\"opentelemetry-instrumentation-flask\"):\n\t            print(\"Adding the Flask instrumentation to your requirements.txt file\")\n\t            print()\n\t            self._add_dependency(\"opentelemetry-instrumentation-flask\")\n\t        print(\"Flask requires some manual configuration.\")\n\t        print(\"The __appsignal__ module needs to be imported before Flask is imported\")\n\t        print(\"and the appsignal.start() method needs to be called right after.\")\n\t        print()\n", "        print(\"Please refer to the documentation for more information:\")\n\t        print(\"https://docs.appsignal.com/python/instrumentations/flask.html\")\n\t    def _generic_installation(self) -> None:\n\t        print(\"✅ Done! AppSignal for Python has now been installed.\")\n\t        print()\n\t        print(\"To start AppSignal in your application, add the following code to your\")\n\t        print(\"application's entrypoint:\")\n\t        print()\n\t        print(\"    from __appsignal__ import appsignal\")\n\t        print(\"    appsignal.start()\")\n", "        print()\n\t        print(\"You can check a list of the supported integrations here:\")\n\t        print(\"https://docs.appsignal.com/python/instrumentations\")\n\t    def _add_dependency(self, dependency_name: str) -> None:\n\t        requirement_file = self._requirements_file()\n\t        if requirement_file:\n\t            with open(requirement_file, \"a\") as f:\n\t                f.write(f\"{dependency_name}\\n\")\n\t    def _validate_push_api_key(self) -> bool:\n\t        endpoint = self._config.option(\"endpoint\")\n", "        url = f\"{endpoint}/1/auth?api_key={self._push_api_key}\"\n\t        proxies = {}\n\t        if self._config.option(\"http_proxy\"):\n\t            proxies[\"http\"] = self._config.option(\"http_proxy\")\n\t            proxies[\"https\"] = self._config.option(\"http_proxy\")\n\t        cert = self._config.option(\"ca_file_path\")\n\t        response = requests.get(url, proxies=proxies, verify=cert)\n\t        return response.status_code == 200\n"]}
{"filename": "src/appsignal/cli/command.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\tfrom abc import ABC, abstractmethod\n\tfrom argparse import ArgumentParser, Namespace\n\tfrom dataclasses import dataclass\n\tfrom functools import cached_property\n\tfrom appsignal.config import Config\n\t@dataclass(frozen=True)\n\tclass AppsignalCLICommand(ABC):\n\t    args: Namespace\n", "    @staticmethod\n\t    def init_parser(parser: ArgumentParser) -> None:\n\t        parser.add_argument(\n\t            \"--push-api-key\",\n\t            default=os.environ.get(\"APPSIGNAL_PUSH_API_KEY\"),\n\t            help=\"Push API Key\",\n\t        )\n\t        parser.add_argument(\n\t            \"--application\",\n\t            default=os.environ.get(\"APPSIGNAL_APP_NAME\"),\n", "            help=\"Application name\",\n\t        )\n\t    @abstractmethod\n\t    def run(self) -> int:\n\t        raise NotImplementedError\n\t    @cached_property\n\t    def _push_api_key(self) -> str | None:\n\t        key = self.args.push_api_key\n\t        while not key:\n\t            key = input(\"Please enter your Push API key: \")\n", "        return key\n\t    @cached_property\n\t    def _name(self) -> str | None:\n\t        name = self.args.application\n\t        while not name:\n\t            name = input(\"Please enter the name of your application: \")\n\t        return name\n\t    @cached_property\n\t    def _config(self) -> Config:\n\t        return Config()\n"]}
