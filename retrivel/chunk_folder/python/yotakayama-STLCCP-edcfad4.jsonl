{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\tlong_description = \"\"\"\n\tA Convex-Concave Procedure-based SQP method from Signal Temporal Logic (STL) specifications\n\t\"\"\"\n\tsetup(name='STLCCP',\n\t      version='0.1.0',\n\t      description='A Convex-Concave Procedure-based SQP method from Signal Temporal Logic (STL) specifications',\n\t      long_description=long_description,\n\t      long_description_content_type='text/markdown',\n\t      project_urls ={\n", "          \"Source Code\": \"https://github.com/\",\n\t},\n\t      author='Yoshinari Takayama',\n\t      author_email='yoshijbbsk1121@gmail.com',\n\t      license='MIT',\n\t      packages=find_packages(),\n\t      install_requires=['numpy', 'matplotlib', 'treelib'],\n\t      python_requires='>=3.8',\n\t      zip_safe=False)\n"]}
{"filename": "log_sum_exp.py", "chunked_list": ["\"\"\"\n\tCopyright 2013 Steven Diamond\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\t# Modified _column_grad by Takayama in 2023-01 for STLCCP\n\tfrom typing import Tuple\n\timport numpy as np\n\tfrom scipy.special import logsumexp\n\tfrom cvxpy.atoms.atom import Atom\n\tfrom cvxpy.atoms.axis_atom import AxisAtom\n\timport cvxpy \n\tclass log_sum_exp(AxisAtom):\n", "    \"\"\":math:`\\\\log\\\\sum_i e^{x_i}`\n\t    \"\"\"\n\t    def __init__(self, x, axis=None, keepdims: bool = False) -> None:\n\t        super(log_sum_exp, self).__init__(x, axis=axis, keepdims=keepdims)\n\t    @Atom.numpy_numeric\n\t    def numeric(self, values):\n\t        \"\"\"Evaluates e^x elementwise, sums, and takes the log.\n\t        \"\"\"\n\t        return logsumexp(values[0], axis=self.axis, keepdims=self.keepdims)\n\t    def _grad(self, values):\n", "        \"\"\"Gives the (sub/super)gradient of the atom w.r.t. each argument.\n\t        Matrix expressions are vectorized, so the gradient is a matrix.\n\t        Args:\n\t            values: A list of numeric values for the arguments.\n\t        Returns:\n\t            A list of SciPy CSC sparse matrices or None.\n\t        \"\"\"\n\t        return self._axis_grad(values)\n\t    def _column_grad(self, value):\n\t        \"\"\"Gives the (sub/super)gradient of the atom w.r.t. a column argument.\n", "        Matrix expressions are vectorized, so the gradient is a matrix.\n\t        Args:\n\t            value: A numeric value for a column.\n\t        Returns:\n\t            A NumPy ndarray or None.\n\t        \"\"\"\n\t        n = len(value)\n\t        s = 0\n\t        e = np.zeros(n)\n\t        xmax = np.max(value)\n", "        k = np.argmax(value)\n\t        a = xmax\n\t        for i in range(n):\n\t            e[i] = np.exp(value[i] - xmax)\n\t            if i != k:\n\t                s += e[i]\n\t        D = e / (1 + s)\n\t        D = D.reshape((D.shape[0], 1))\n\t        return D\n\t    def sign_from_args(self) -> Tuple[bool, bool]:\n", "        \"\"\"Returns sign (is positive, is negative) of the expression.\n\t        \"\"\"\n\t        return (False, False)\n\t    def is_atom_convex(self) -> bool:\n\t        \"\"\"Is the atom convex?\n\t        \"\"\"\n\t        return True\n\t    def is_atom_concave(self) -> bool:\n\t        \"\"\"Is the atom concave?\n\t        \"\"\"\n", "        return False\n\t    def is_incr(self, idx) -> bool:\n\t        \"\"\"Is the composition non-decreasing in argument idx?\n\t        \"\"\"\n\t        return True\n\t    def is_decr(self, idx) -> bool:\n\t        \"\"\"Is the composition non-increasing in argument idx?\n\t        \"\"\"\n\t        return False\n"]}
{"filename": "STLCCP/__init__.py", "chunked_list": []}
{"filename": "STLCCP/systems/__init__.py", "chunked_list": ["from .linear import LinearSystem, DoubleIntegrator\n\tfrom .nonlinear import NonlinearSystem, Unicycle\n"]}
{"filename": "STLCCP/systems/linear.py", "chunked_list": ["from .nonlinear import NonlinearSystem\n\timport numpy as np\n\tclass LinearSystem(NonlinearSystem):\n\t    \"\"\"\n\t    A linear discrete-time system of the form\n\t    .. math::\n\t        x_{t+1} = A x_t + B u_t\n\t        y_t = C x_t + D u_t\n\t    where\n\t        - :math:`x_t \\in \\mathbb{R}^n` is a system state,\n", "        - :math:`u_t \\in \\mathbb{R}^m` is a control input,\n\t        - :math:`y_t \\in \\mathbb{R}^p` is a system output.\n\t    :param A: A ``(n,n)`` numpy array representing the state transition matrix\n\t    :param B: A ``(n,m)`` numpy array representing the control input matrix\n\t    :param C: A ``(p,n)`` numpy array representing the state output matrix\n\t    :param D: A ``(p,m)`` numpy array representing the control output matrix\n\t    \"\"\"\n\t    def __init__(self, A, B, C, D):\n\t        self.n = A.shape[1]\n\t        self.m = B.shape[1]\n", "        self.p = C.shape[0]\n\t        # Sanity checks on matrix sizes\n\t        assert A.shape == (self.n, self.n), \"A must be an (n,n) matrix\"\n\t        assert B.shape == (self.n, self.m), \"B must be an (n,m) matrix\"\n\t        assert C.shape == (self.p, self.n), \"C must be an (p,n) matrix\"\n\t        assert D.shape == (self.p, self.m), \"D must be an (p,m) matrix\"\n\t        # Store dynamics parameters\n\t        self.A = A\n\t        self.B = B\n\t        self.C = C\n", "        self.D = D\n\t        # Dynamics functions\n\t        self.dynamics_fcn = lambda x, u: A@x + B@u\n\t        self.output_fcn = lambda x, u: C@x + D@u\n\tclass DoubleIntegrator(LinearSystem):\n\t    \"\"\"\n\t    A linear system describing a double integrator in :math:`d` dimensions\n\t    with full state and control output:\n\t    .. math::\n\t        A = \\\\begin{bmatrix} I_{d \\\\times d}  & I_{d \\\\times d} \\\\\\ 0_{d \\\\times d} & I_{d \\\\times d}  \\\\end{bmatrix}\n", "        \\quad\n\t        B = \\\\begin{bmatrix} 0_{d \\\\times d} \\\\\\ I_{d \\\\times d}  \\\\end{bmatrix}\n\t    .. math::\n\t        C = \\\\begin{bmatrix} I_{2d \\\\times 2d} \\\\\\ 0_{d \\\\times 2d} \\\\end{bmatrix}\n\t        \\quad\n\t        D = \\\\begin{bmatrix} 0_{2d \\\\times d} \\\\\\ I_{d \\\\times d} \\\\end{bmatrix}\n\t    :param d: Integer describing the dimensionality of the system\n\t    \"\"\"\n\t    def __init__(self, d):\n\t        I = np.eye(d)\n", "        z = np.zeros((d,d))\n\t        A = np.block([[I,I],\n\t                      [z,I]])\n\t        B = np.block([[z],\n\t                      [I]])\n\t        C = np.block([[I,z],\n\t                      [z,I],\n\t                      [z,z]])\n\t        D = np.block([[z],\n\t                      [z],\n", "                      [I]])\n\t        LinearSystem.__init__(self, A, B, C, D)\n"]}
{"filename": "STLCCP/systems/nonlinear.py", "chunked_list": ["import numpy as np\n\tclass NonlinearSystem:\n\t    \"\"\"\n\t    A class which represents some (possibly nonlinear)\n\t    discrete-time control system\n\t    .. math::\n\t        x_{t+1} = f(x_t, u_t)\n\t        y_t = g(x_t, u_t)\n\t    where\n\t        - :math:`x_t \\in \\mathbb{R}^n` is a system state,\n", "        - :math:`u_t \\in \\mathbb{R}^m` is a control input,\n\t        - :math:`y_t \\in \\mathbb{R}^p` is a system output.\n\t    :param f:   A function representing :math:`f`, which takes two numpy\n\t                arrays (:math:`x_t,u_t`) as input and returns another\n\t                numpy array (:math:`x_{t+1}`).\n\t    :param g:   A function representing :math:`f`, which takes two numpy\n\t                arrays (:math:`x_t,u_t`) as input and returns another\n\t                numpy array (:math:`y_{t}`).\n\t    :param n:   Size of the state vector :math:`x_t`.\n\t    :param m:   Size of the control vector :math:`u_t`.\n", "    :param p:   Size of the output vector :math:`p_t`.\n\t    \"\"\"\n\t    def __init__(self, f, g, n, m, p):\n\t        # TODO: do some checks on function signature\n\t        self.dynamics_fcn = f\n\t        self.output_fcn = g\n\t        self.n = n\n\t        self.m = m\n\t        self.p = p\n\t    def f(self, x, u):\n", "        \"\"\"\n\t        Given state :math:`x_t` and control :math:`u_t`, compute\n\t        the forward dynamics\n\t        .. math::\n\t            x_{t+1} = f(x_t, u_t).\n\t        :param x:   The current state :math:`x_t`\n\t        :param u:   The control input :math:`u_t`\n\t        :return:    The subsequent state :math:`x_{t+1}`\n\t        \"\"\"\n\t        return self.dynamics_fcn(x, u)\n", "    def g(self, x, u):\n\t        \"\"\"\n\t        Given state :math:`x_t` and control :math:`u_t`, compute\n\t        the output\n\t        .. math::\n\t            y_t = g(x_t, u_t).\n\t        :param x:   The current state :math:`x_t`\n\t        :param u:   The control input :math:`u_t`\n\t        :return:    The output :math:`y_t`\n\t        \"\"\"\n", "        return self.output_fcn(x,u)\n\tclass Unicycle(NonlinearSystem):\n\t    r\"\"\"\n\t    A simple nonlinear system representing a 2D mobile robot with\n\t    unicycle dynamics. The robot is controlled by specifing a forward\n\t    velociy :math:`v` and an angular velocity :math:`\\omega`. \n\t    This is example of a non-holonomic system: the robot cannot\n\t    directly control its motion in the horizontal direction.\n\t    The state is given by \n\t    .. math::\n", "        x = \\begin{bmatrix} p_x \\\\ p_y \\\\ \\theta \\end{bmatrix},\n\t    where :math:`p_x` and :math:`p_y` are positions in the plane and\n\t    :math:`\\theta` is an orientation. The dynamics are given by\n\t    .. math::\n\t        \\dot{x} = \\begin{bmatrix} v \\cos(\\theta) \\\\ v \\sin(\\theta) \\\\ \\omega \\end{bmatrix}\n\t    and the control input is :math:`u = \\begin{bmatrix} v \\\\ \\omega \\end{bmatrix}`.\n\t    We use forward Euler integration to transform this into a discrete-time system:\n\t    .. math::\n\t        x_{t+1} = x_t + \\dot{x}~dt.\n\t    The system output is simply the state of the robot, :math:`y_t = x_t`.\n", "    :param dt:  Discretization step size (for forward Euler integration)\n\t    \"\"\"\n\t    def __init__(self, dt):\n\t        self.dt = dt\n\t        # State, control, and output sizes\n\t        self.n = 3\n\t        self.m = 2\n\t        self.p = 3\n\t    def f(self, x, u):\n\t        v = u[0]      # linear velocity\n", "        omega = u[1]  # angular velocity\n\t        theta = x[2]  # orientation\n\t        xdot = np.array([ v * np.cos(theta),\n\t                          v * np.sin(theta),\n\t                          omega])\n\t        return x + self.dt * xdot\n\t    def g(self, x, u):\n\t        return x\n"]}
{"filename": "STLCCP/benchmarks/either_or.py", "chunked_list": ["from .base import BenchmarkScenario\n\tfrom .common import (inside_rectangle_formula,\n\t                     outside_rectangle_formula,\n\t                     make_rectangle_patch)\n\tfrom ..systems import DoubleIntegrator\n\tclass EitherOr(BenchmarkScenario):\n\t    r\"\"\"\n\t    A 2D mobile robot with double integrator dynamics must\n\t    avoid an obstacle (:math:`\\mathcal{O}`) before reaching a goal\n\t    (:math:`\\mathcal{G}`). Along the way, the robot must reach one\n", "    of two intermediate targets (:math:`\\mathcal{T}_i`) and stay\n\t    there for several timesteps:\n\t    .. math::\n\t        \\varphi = \n\t            F_{[0,T-\\tau]} \n\t                \\left( G_{[0,\\tau]} \\mathcal{T}_1 \\lor G_{[0,\\tau]} \\mathcal{T}_2 \\right)\n\t            \\land F_{[0,T]} \\mathcal{G} \n\t            \\land G_{[0,T]} \\lnot \\mathcal{O}\n\t    :param goal:        Tuple containing bounds of the rectangular goal region\n\t    :param target_one:  Tuple containing bounds of the rectangular first target\n", "    :param target_two:  Tuple containing bounds of the rectangular second target\n\t    :param obstacle:    Tuple containing bounds of the rectangular obstacle\n\t    :param T:           Total number of time steps\n\t    :param T_dwell:     Dwell time :math:`\\tau` (integer number of timesteps)\n\t    \"\"\"\n\t    def __init__(self, goal, target_one, target_two, obstacle, T, T_dwell):\n\t        self.goal = goal\n\t        self.target_one = target_one\n\t        self.target_two = target_two\n\t        self.obstacle = obstacle\n", "        self.T = T\n\t        self.T_dwell = T_dwell\n\t    def GetSpecification(self):\n\t        # Goal Reaching\n\t        at_goal = inside_rectangle_formula(self.goal, 0, 1, 6)\n\t        # Target reaching\n\t        at_target_one = inside_rectangle_formula(self.target_one, 0, 1, 6).always(0, self.T_dwell)\n\t        at_target_two = inside_rectangle_formula(self.target_two, 0, 1, 6).always(0, self.T_dwell)\n\t        at_either_target = at_target_one | at_target_two\n\t        # Obstacle Avoidance\n", "        not_at_obstacle = outside_rectangle_formula(self.obstacle, 0, 1, 6)\n\t        specification = at_either_target.eventually(0, self.T-self.T_dwell) & \\\n\t                        not_at_obstacle.always(0, self.T) & \\\n\t                        at_goal.eventually(0, self.T)\n\t        return specification\n\t    def GetSystem(self):\n\t        return DoubleIntegrator(2)\n\t    def add_to_plot(self, ax):\n\t        # Make and add rectangular patches\n\t        ax.add_patch(make_rectangle_patch(*self.obstacle, color='k', alpha=0.5))\n", "        ax.add_patch(make_rectangle_patch(*self.target_one, color='blue', alpha=0.5))\n\t        ax.add_patch(make_rectangle_patch(*self.target_two, color='blue', alpha=0.5))\n\t        ax.add_patch(make_rectangle_patch(*self.goal, color='green', alpha=0.5))\n\t        # set the field of view\n\t        ax.set_xlim((0,10))\n\t        ax.set_ylim((0,10))\n\t        ax.set_aspect('equal')\n"]}
{"filename": "STLCCP/benchmarks/base.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tclass BenchmarkScenario(ABC):\n\t    \"\"\"\n\t    An abstract base class defining a benchmark\n\t    scenario for STL synthesis.\n\t    \"\"\"\n\t    @abstractmethod\n\t    def GetSpecification(self):\n\t        \"\"\"\n\t        Get the STL specification associated with this scenario.\n", "        :return spec: an ``STLFormula`` describing the specification.\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def GetSystem(self):\n\t        \"\"\"\n\t        Get the system dynamics model associated with this\n\t        scenario. \n\t        :return sys: a ``LinearSystem`` or ``NonlinearSystem`` \n\t                     specifying the system dynamics.\n", "        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def add_to_plot(self, ax):\n\t        \"\"\"\n\t        Add a visualization of this specification\n\t        to the given ``matplotlib`` axis.\n\t        :param ax:  The ``matplotlib`` axis object to add the \n\t                    visualization to.\n\t        \"\"\"\n", "        pass\n"]}
{"filename": "STLCCP/benchmarks/door_puzzle.py", "chunked_list": ["from .base import BenchmarkScenario\n\tfrom .common import (inside_rectangle_formula,\n\t                     outside_rectangle_formula,\n\t                     make_rectangle_patch)\n\tfrom ..systems import DoubleIntegrator\n\tclass DoorPuzzle(BenchmarkScenario):\n\t    r\"\"\"\n\t    A mobile robot with double integrator dynamics must pick up\n\t    several keys (by visiting certain regions :math:`\\mathcal{K}_i`)\n\t    before it cat pass through associated doors (:math:`\\mathcal{D}_i`)\n", "    and reach a goal (:math:`\\mathcal{G}`). Along the way, it must\n\t    avoid obstacles (:math:`\\mathcal{O}_j`).\n\t    .. math::\n\t        \\varphi = \\bigwedge_{i=1}^{N} \\left( \\lnot \\mathcal{D}_i U_{[0,T]} \\mathcal{K}_i \\right)  \n\t        \\land F_{[0,T]} \\mathcal{G} \n\t        \\land G_{[0,T]} (\\bigwedge_{j=1}^5 \\lnot \\mathcal{O}_i)\n\t    :param T:   The time horizon for this scenario\n\t    :param N:   The number of key-door pairs. Must be between 1 and 4.\n\t    \"\"\"\n\t    def __init__(self, T, N):\n", "        assert N >= 1 and N <= 4, \"number of pairs must be between 1 and 4\"\n\t        self.N = N\n\t        self.T = T\n\t        # Goal location\n\t        self.goal_bounds = (14.1,14.9,4.1,5.9)\n\t        # Obstacle locations\n\t        self.obs1_bounds = (8,15.01,-0.01,4)\n\t        self.obs2_bounds = (8,15.01,6,10.01)\n\t        self.obs3_bounds = (3.5,5,-0.01,2.5)\n\t        self.obs4_bounds = (-0.01,2.5,4,6)\n", "        self.obs5_bounds = (3.5,5,7.5,10.01)\n\t        # Door locations (set to overlap obstacles slightly)\n\t        self.door1_bounds = (12.8,14,3.99,6.01)\n\t        self.door2_bounds = (11.5,12.7,3.99,6.01)\n\t        self.door3_bounds = (10.2,11.4,3.99,6.01)\n\t        self.door4_bounds = (8.9,10.1,3.99,6.01)\n\t        # Key locations\n\t        self.key1_bounds = (1,2,1,2)\n\t        self.key2_bounds = (1,2,8,9)\n\t        self.key3_bounds = (6,7,8,9)\n", "        self.key4_bounds = (6,7,1,2)\n\t    def GetSpecification(self):\n\t        # Goal Reaching\n\t        at_goal = inside_rectangle_formula(self.goal_bounds, 0, 1, 6)\n\t        # Obstacle Avoidance\n\t        not_at_obs1 = outside_rectangle_formula(self.obs1_bounds, 0, 1, 6)\n\t        not_at_obs2 = outside_rectangle_formula(self.obs2_bounds, 0, 1, 6)\n\t        not_at_obs3 = outside_rectangle_formula(self.obs3_bounds, 0, 1, 6)\n\t        not_at_obs4 = outside_rectangle_formula(self.obs4_bounds, 0, 1, 6)\n\t        not_at_obs5 = outside_rectangle_formula(self.obs5_bounds, 0, 1, 6)\n", "        obstacle_avoidance = not_at_obs1 & not_at_obs2 & not_at_obs3 & not_at_obs4 & not_at_obs5\n\t        # Being outside a door region\n\t        no_door1 = outside_rectangle_formula(self.door1_bounds, 0, 1, 6)\n\t        no_door2 = outside_rectangle_formula(self.door2_bounds, 0, 1, 6)\n\t        no_door3 = outside_rectangle_formula(self.door3_bounds, 0, 1, 6)\n\t        no_door4 = outside_rectangle_formula(self.door4_bounds, 0, 1, 6)\n\t        # Being in a key region\n\t        key1 = inside_rectangle_formula(self.key1_bounds, 0, 1, 6)\n\t        key2 = inside_rectangle_formula(self.key2_bounds, 0, 1, 6)\n\t        key3 = inside_rectangle_formula(self.key3_bounds, 0, 1, 6)\n", "        key4 = inside_rectangle_formula(self.key4_bounds, 0, 1, 6)\n\t        # Not reaching a door until the correspoding key region has been\n\t        # visited\n\t        k1d1 = no_door1.until(key1, 0, self.T)\n\t        k2d2 = no_door2.until(key2, 0, self.T)\n\t        k3d3 = no_door3.until(key3, 0, self.T)\n\t        k4d4 = no_door4.until(key4, 0, self.T)\n\t        # Putting it all together\n\t        if self.N == 1:\n\t            key_constraints = k1d1\n", "        elif self.N == 2:\n\t            key_constraints = k1d1 & k2d2\n\t        elif self.N == 3:\n\t            key_constraints = k1d1 & k2d2 & k3d3\n\t        elif elf.N == 4:\n\t            key_constraints = k1d1 & k2d2 & k3d3 & k4d4\n\t        # Put all of the constraints together in one specification\n\t        specification = obstacle_avoidance.always(0, self.T) & \\\n\t                        key_constraints & \\\n\t                        at_goal.eventually(0, self.T)\n", "        return specification\n\t    def GetSystem(self):\n\t        return DoubleIntegrator(2)\n\t    def add_to_plot(self, ax):\n\t        # Obstacles\n\t        obs = [self.obs1_bounds, self.obs2_bounds, self.obs3_bounds, self.obs4_bounds, self.obs5_bounds]\n\t        for obs_bounds in obs:\n\t            obs_patch = make_rectangle_patch(*obs_bounds, color='k', alpha=0.5)\n\t            ax.add_patch(obs_patch)\n\t        # Doors\n", "        door1 = make_rectangle_patch(*self.door1_bounds, color='red', alpha=0.5)\n\t        door2 = make_rectangle_patch(*self.door2_bounds, color='red', alpha=0.5)\n\t        door3 = make_rectangle_patch(*self.door3_bounds, color='red', alpha=0.5)\n\t        door4 = make_rectangle_patch(*self.door4_bounds, color='red', alpha=0.5)\n\t        # Keys\n\t        key1 = make_rectangle_patch(*self.key1_bounds, color='blue', alpha=0.5)\n\t        key2 = make_rectangle_patch(*self.key2_bounds, color='blue', alpha=0.5)\n\t        key3 = make_rectangle_patch(*self.key3_bounds, color='blue', alpha=0.5)\n\t        key4 = make_rectangle_patch(*self.key4_bounds, color='blue', alpha=0.5)\n\t        # Goals\n", "        goal = make_rectangle_patch(*self.goal_bounds, color='green', alpha=0.5)\n\t        ax.add_patch(goal)\n\t        # Only add the doors and keys that we actually used\n\t        if self.N >= 1:\n\t            ax.add_patch(door1)\n\t            ax.add_patch(key1)\n\t        if self.N >= 2:\n\t            ax.add_patch(door2)\n\t            ax.add_patch(key2)\n\t        if self.N >= 3:\n", "            ax.add_patch(door3)\n\t            ax.add_patch(key3)\n\t        if self.N >= 4:\n\t            ax.add_patch(door4)\n\t            ax.add_patch(key4)\n\t        # set the field of view\n\t        ax.set_xlim((0,15))\n\t        ax.set_ylim((0,10))\n\t        ax.set_aspect('equal')\n"]}
{"filename": "STLCCP/benchmarks/narrow_passage.py", "chunked_list": ["from .base import BenchmarkScenario\n\tfrom .common import (inside_rectangle_formula,\n\t                     outside_rectangle_formula,\n\t                     make_rectangle_patch)\n\tfrom ..systems import DoubleIntegrator\n\tclass NarrowPassage(BenchmarkScenario):\n\t    r\"\"\"\n\t    A 2D mobile robot with double integrator dynamics must navigate around\n\t    several obstacles (:math:`\\mathcal{O}_i`) before reaching one of two\n\t    goals (:math:`\\mathcal{G}_i`).\n", "    .. math::\n\t        \\varphi = F_{[0,T]}(\\mathcal{G}_1 \\lor \\mathcal{G}_2) \\land\n\t            G_{[0,T]} \\left( \\bigwedge_{i=1}^4 \\lnot \\mathcal{O}_i \\right)\n\t    :param T:   The time horizon of the specification.\n\t    \"\"\"\n\t    def __init__(self, T):\n\t        # Define obstacle and goal regions by their bounds,\n\t        # (xmin, xmax, ymin, ymax)\n\t        self.obstacles = [(2,5,4,6),\n\t                          (5.5,9,3.8,5.7),\n", "                          (4.6,8,0.5,3.5),\n\t                          (2.2,4.4,6.4,11)]\n\t        self.goals = [(7,8,8,9),\n\t                      (9.5,10.5,1.5,2.5)]\n\t        self.T = T\n\t    def GetSpecification(self):\n\t        # Goal Reaching\n\t        goal_formulas = []\n\t        for goal in self.goals:\n\t            goal_formulas.append(inside_rectangle_formula(goal, 0, 1, 6))\n", "        at_any_goal = goal_formulas[0]\n\t        for i in range(1,len(goal_formulas)):\n\t            at_any_goal = at_any_goal | goal_formulas[i]\n\t        # Obstacle Avoidance\n\t        obstacle_formulas = []\n\t        for obs in self.obstacles:\n\t            obstacle_formulas.append(outside_rectangle_formula(obs, 0, 1, 6))\n\t        obstacle_avoidance = obstacle_formulas[0]\n\t        for i in range(1, len(obstacle_formulas)):\n\t            obstacle_avoidance = obstacle_avoidance & obstacle_formulas[i]\n", "        # Put all of the constraints together in one specification\n\t        specification = at_any_goal.eventually(0, self.T) & \\\n\t                        obstacle_avoidance.always(0, self.T)\n\t        return specification\n\t    def GetSystem(self):\n\t        return DoubleIntegrator(2)\n\t    def add_to_plot(self, ax):\n\t        # Make and add rectangular patches\n\t        for obstacle in self.obstacles:\n\t            ax.add_patch(make_rectangle_patch(*obstacle, color='k', alpha=0.5))\n", "        for goal in self.goals:\n\t            ax.add_patch(make_rectangle_patch(*goal, color='green', alpha=0.5))\n\t        # set the field of view\n\t        ax.set_xlim((0,12))\n\t        ax.set_ylim((0,12))\n\t        ax.set_aspect('equal')\n"]}
{"filename": "STLCCP/benchmarks/__init__.py", "chunked_list": ["from .reach_avoid import ReachAvoid\n\tfrom .either_or import EitherOr\n\tfrom .narrow_passage import NarrowPassage\n\tfrom .random_multitarget import RandomMultitarget\n\tfrom .door_puzzle import DoorPuzzle\n\tfrom .stepping_stones import SteppingStones\n"]}
{"filename": "STLCCP/benchmarks/reach_avoid.py", "chunked_list": ["from .base import BenchmarkScenario\n\tfrom .common import (inside_rectangle_formula,\n\t                     outside_rectangle_formula,\n\t                     make_rectangle_patch)\n\tfrom ..systems import DoubleIntegrator\n\tclass ReachAvoid(BenchmarkScenario):\n\t    r\"\"\"\n\t    A 2D mobile robot with double integrator dynamics must\n\t    avoid an obstacle (:math:`\\mathcal{O}`) before reaching a goal (:math:`\\mathcal{G}`):\n\t    .. math::\n", "        \\varphi = G_{[0,T]} \\lnot \\mathcal{O} \\land F_{[0,T]} \\mathcal{G}\n\t    :param goal_bounds:      a tuple ``(xmin, xmax, ymin, ymax)`` defining a\n\t                             rectangular goal region.\n\t    :param obstacle_bounds:  a tuple ``(xmin, xmax, ymin, ymax)`` defining a\n\t                             rectangular obstacle.\n\t    :param T:                the time horizon for this scenario.\n\t    \"\"\"\n\t    def __init__(self, goal_bounds, obstacle_bounds, T):\n\t        self.goal_bounds = goal_bounds\n\t        self.obstacle_bounds = obstacle_bounds\n", "        self.T = T\n\t    def GetSpecification(self):\n\t        # Goal Reaching\n\t        at_goal = inside_rectangle_formula(self.goal_bounds, 0, 1, 6)\n\t        # Obstacle Avoidance\n\t        not_at_obstacle = outside_rectangle_formula(self.obstacle_bounds, 0, 1, 6)\n\t        # Put all of the constraints together in one specification\n\t        spec = not_at_obstacle.always(0, self.T) & at_goal.eventually(0, self.T)\n\t        return spec\n\t    def GetSystem(self):\n", "        sys = DoubleIntegrator(2)\n\t        return sys\n\t    def add_to_plot(self, ax):\n\t        # Make and add rectangular patches\n\t        obstacle = make_rectangle_patch(*self.obstacle_bounds, color='k', alpha=0.5)\n\t        goal = make_rectangle_patch(*self.goal_bounds, color='green', alpha=0.5)\n\t        ax.add_patch(obstacle)\n\t        ax.add_patch(goal)\n\t        # set the field of view\n\t        ax.set_xlim((0,10))\n", "        ax.set_ylim((0,10))\n\t        ax.set_aspect('equal')\n"]}
{"filename": "STLCCP/benchmarks/stepping_stones.py", "chunked_list": ["import numpy as np\n\tfrom .base import BenchmarkScenario\n\tfrom .common import inside_rectangle_formula, make_rectangle_patch\n\tfrom ..systems import DoubleIntegrator\n\tclass SteppingStones(BenchmarkScenario):\n\t    r\"\"\"\n\t    A 2D mobile robot with double integrator dynamics must\n\t    navigate to a goal (:math:`\\mathcal{G}`) while only stepping \n\t    on certain predefined spaces (:math:`\\mathcal{S}_i`):\n\t    .. math::\n", "        \\varphi = G_{[0,T]} \\left( \\bigvee_{i}^{N_s} \\mathcal{S}_i \\right) \\land\n\t                  F_{[0,T]} \\mathcal{G}\n\t    :param num_stones:  The number of stepping stones :math:`N_s`\n\t    :param T:           The specification time horizon\n\t    :param seed:        (optional) The random seed for stone placement.\n\t                        Default is None.\n\t    \"\"\"\n\t    def __init__(self, num_stones, T, seed=None):\n\t        self.T = T\n\t        # Set the seed for the random number generator (for reproducability)\n", "        np.random.seed(seed)\n\t        # Create the (randomly generated) set of stepping stones\n\t        self.stones = []\n\t        for i in range(num_stones):\n\t            x = np.random.uniform(0,9)  # keep within workspace\n\t            y = np.random.uniform(0,9)\n\t            self.stones.append((x,x+1,y,y+1))\n\t        # Specify the target/goal\n\t        self.target = self.stones[-1]\n\t    def GetSpecification(self):\n", "        # Specify that we must be on any one of the stones\n\t        stone_formulas = []\n\t        for stone in self.stones:\n\t            stone_formulas.append(inside_rectangle_formula(stone, 0, 1, 6))\n\t        on_any_stone = stone_formulas[0]\n\t        for i in range(1, len(stone_formulas)):\n\t            on_any_stone = on_any_stone | stone_formulas[i]\n\t        # Specify that we much reach the target\n\t        reach_target = inside_rectangle_formula(self.target, 0, 1, 6)\n\t        # Put all of the constraints together in one specification\n", "        specification = on_any_stone.always(0, self.T) & \\\n\t                        reach_target.eventually(0, self.T)\n\t        return specification\n\t    def GetSystem(self):\n\t        return DoubleIntegrator(2)\n\t    def add_to_plot(self, ax):\n\t        n_stones = len(self.stones)\n\t        # Add rectangles for the stones\n\t        for i in range(n_stones):\n\t            if i < n_stones-1:  # ordinary stepping stones are orange\n", "                ax.add_patch(make_rectangle_patch(*self.stones[i], color='orange', alpha=0.5, zorder=-1))\n\t            else:  # the target is green\n\t                ax.add_patch(make_rectangle_patch(*self.stones[i], color='g', alpha=0.5, zorder=-1))\n\t        # set the field of view\n\t        ax.set_xlim((0,10))\n\t        ax.set_ylim((0,10))\n\t        ax.set_aspect('equal')\n"]}
{"filename": "STLCCP/benchmarks/common.py", "chunked_list": ["##\n\t#\n\t# Common helper functions for defining STL specifications.\n\t#\n\t##\n\timport numpy as np\n\tfrom STLCCP.STL import LinearPredicate, NonlinearPredicate\n\tfrom matplotlib.patches import Rectangle, Circle\n\tdef inside_circle_formula(center, radius, y1_index, y2_index, d, name=None):\n\t    \"\"\"\n", "    Create an STL formula representing being inside a\n\t    circle with the given center and radius.\n\t    :param center:      Tuple ``(y1, y2)`` specifying the center of the\n\t                        circle.\n\t    :param radius:      Radius of the circle\n\t    :param y1_index:    index of the first (``y1``) dimension\n\t    :param y2_index:    index of the second (``y2``) dimension\n\t    :param d:           dimension of the overall signal\n\t    :param name:        (optional) string describing this formula\n\t    :return inside_circle:   A ``NonlinearPredicate`` specifying being inside the\n", "                             circle at time zero.\n\t    \"\"\"\n\t    # Define the predicate function g(y) >= 0\n\t    def g(y):\n\t        y1 = y[y1_index]\n\t        y2 = y[y2_index]\n\t        return radius**2 - (y1-center[0])**2 - (y2-center[1])**2\n\t    return NonlinearPredicate(g, d, name=name)\n\tdef inside_rectangle_formula(bounds, y1_index, y2_index, d, name=None):\n\t    \"\"\"\n", "    Create an STL formula representing being inside a\n\t    rectangle with the given bounds:\n\t    ::\n\t       y2_max   +-------------------+\n\t                |                   |\n\t                |                   |\n\t                |                   |\n\t       y2_min   +-------------------+\n\t                y1_min              y1_max\n\t    :param bounds:      Tuple ``(y1_min, y1_max, y2_min, y2_max)`` containing\n", "                        the bounds of the rectangle.\n\t    :param y1_index:    index of the first (``y1``) dimension\n\t    :param y2_index:    index of the second (``y2``) dimension\n\t    :param d:           dimension of the overall signal\n\t    :param name:        (optional) string describing this formula\n\t    :return inside_rectangle:   An ``STLFormula`` specifying being inside the\n\t                                rectangle at time zero.\n\t    \"\"\"\n\t    assert y1_index < d , \"index must be less than signal dimension\"\n\t    assert y2_index < d , \"index must be less than signal dimension\"\n", "    # Unpack the bounds\n\t    y1_min, y1_max, y2_min, y2_max = bounds\n\t    # Create predicates a*y >= b for each side of the rectangle\n\t    a1 = np.zeros((1,d)); a1[:,y1_index] = 1\n\t    right = LinearPredicate(a1, y1_min)\n\t    left = LinearPredicate(-a1, -y1_max)\n\t    a2 = np.zeros((1,d)); a2[:,y2_index] = 1\n\t    top = LinearPredicate(a2, y2_min)\n\t    bottom = LinearPredicate(-a2, -y2_max)\n\t    # Take the conjuction across all the sides\n", "    inside_rectangle = right & left & top & bottom\n\t    # set the names\n\t    if name is not None:\n\t        right.name = \"right of \" + name\n\t        left.name = \"left of \" + name\n\t        top.name = \"top of \" + name\n\t        bottom.name = \"bottom of \" + name\n\t        inside_rectangle.name = name\n\t    return inside_rectangle\n\tdef outside_rectangle_formula(bounds, y1_index, y2_index, d, name=None):\n", "    \"\"\"\n\t    Create an STL formula representing being outside a\n\t    rectangle with the given bounds:\n\t    ::\n\t       y2_max   +-------------------+\n\t                |                   |\n\t                |                   |\n\t                |                   |\n\t       y2_min   +-------------------+\n\t                y1_min              y1_max\n", "    :param bounds:      Tuple ``(y1_min, y1_max, y2_min, y2_max)`` containing\n\t                        the bounds of the rectangle.\n\t    :param y1_index:    index of the first (``y1``) dimension\n\t    :param y2_index:    index of the second (``y2``) dimension\n\t    :param d:           dimension of the overall signal\n\t    :param name:        (optional) string describing this formula\n\t    :return outside_rectangle:   An ``STLFormula`` specifying being outside the\n\t                                 rectangle at time zero.\n\t    \"\"\"\n\t    assert y1_index < d , \"index must be less than signal dimension\"\n", "    assert y2_index < d , \"index must be less than signal dimension\"\n\t    # Unpack the bounds\n\t    y1_min, y1_max, y2_min, y2_max = bounds\n\t    # Create predicates a*y >= b for each side of the rectangle\n\t    a1 = np.zeros((1,d)); a1[:,y1_index] = 1\n\t    right = LinearPredicate(a1, y1_max)\n\t    left = LinearPredicate(-a1, -y1_min)\n\t    a2 = np.zeros((1,d)); a2[:,y2_index] = 1\n\t    top = LinearPredicate(a2, y2_max)\n\t    bottom = LinearPredicate(-a2, -y2_min)\n", "    # Take the disjuction across all the sides\n\t    outside_rectangle = right | left | top | bottom\n\t    # set the names\n\t    if name is not None:\n\t        right.name = \"right of \" + name\n\t        left.name = \"left of \" + name\n\t        top.name = \"top of \" + name\n\t        bottom.name = \"bottom of \" + name\n\t        outside_rectangle.name = name\n\t    return outside_rectangle\n", "def make_rectangle_patch(xmin, xmax, ymin, ymax, **kwargs):\n\t    \"\"\"\n\t    Convienience function for making a ``matplotlib.patches.Rectangle``\n\t    patch for visualizing a rectangle:\n\t    ::\n\t       ymax   +-------------------+\n\t              |                   |\n\t              |                   |\n\t              |                   |\n\t       ymin   +-------------------+\n", "              xmin                xmax\n\t    :param xmin:        horizontal lower bound of the rectangle.\n\t    :param xmax:        horizontal upper bound of the rectangle.\n\t    :param ymin:        vertical lower bound of the rectangle.\n\t    :param ymax:        vertical upper bound of the rectangle.\n\t    :param kwargs:    (optional) keyword arguments passed to\n\t                        the ``Rectangle`` constructor.\n\t    :return patch:  a ``matplotlib.patches.Rectangle`` patch.\n\t    \"\"\"\n\t    x = xmin\n", "    y = ymin\n\t    width = xmax-x\n\t    height = ymax-y\n\t    return Rectangle((x,y), width, height, **kwargs)\n\tdef make_circle_patch(center, radius, **kwargs):\n\t    \"\"\"\n\t    Convienience function for making a ``matplotlib.patches.Circle``\n\t    patch for visualizing a circle with the given center and radius.\n\t    :param center:  Tuple containing the center coordinates of the circle\n\t    :param radius:  The circle's radius\n", "    :param kwargs:  (optional) keyword arguments passed to\n\t                        the ``Circle`` constructor.\n\t    :return patch:  a ``matplotlib.patches.Circle`` patch.\n\t    \"\"\"\n\t    return Circle(center, radius, **kwargs)\n"]}
{"filename": "STLCCP/benchmarks/random_multitarget.py", "chunked_list": ["import numpy as np\n\timport matplotlib.pyplot as plt\n\tfrom .base import BenchmarkScenario\n\tfrom .common import (inside_rectangle_formula,\n\t                     outside_rectangle_formula,\n\t                     make_rectangle_patch)\n\tfrom ..systems import DoubleIntegrator\n\tclass RandomMultitarget(BenchmarkScenario):\n\t    r\"\"\"\n\t    A 2D mobile robot with double integrator dynamics must \n", "    navigate through a field of obstacles (grey, :math:`\\mathcal{O}_i`)\n\t    and reach at least one target of each color (:math:`\\mathcal{T}_i^j`):\n\t    .. math::\n\t        \\varphi = \n\t            \\bigwedge_{i=1}^{N_c} \\left( \\bigvee_{j=1}^{N_t} F_{[0,T]} T_{i}^{j} \\right) \n\t            \\land G_{[0,T]} (\\bigwedge_{k=1}^{N_o} \\lnot O_k),\n\t    :param num_obstacles:       number of obstacles, :math:`N_o`\n\t    :param num_groups:          number of target groups/colors, :math:`N_c`\n\t    :param targets_per_group:   number of targets in each group, :math:`N_t`\n\t    :param T:                   time horizon of the specification\n", "    :param seed:                (optional) seed for random generation of obstacle \n\t                                and target locations. Default is ``None``.\n\t    \"\"\"\n\t    def __init__(self, num_obstacles, num_groups, targets_per_group, T, seed=None):\n\t        self.T = T\n\t        self.targets_per_group = targets_per_group\n\t        # Set the seed for the random number generator (for reproducability)\n\t        np.random.seed(seed)\n\t        # Create the (randomly generated) set of obstacles\n\t        self.obstacles = []\n", "        for i in range(num_obstacles):\n\t            x = np.random.uniform(0,9)  # keep within workspace\n\t            y = np.random.uniform(0,9)\n\t            self.obstacles.append((x,x+2,y,y+2))\n\t        # Create the (randomly generated) set of targets\n\t        self.targets = []\n\t        for i in range(num_groups):\n\t            target_group = []\n\t            for j in range(targets_per_group):\n\t                x = np.random.uniform(0,9)\n", "                y = np.random.uniform(0,9)\n\t                target_group.append((x,x+1,y,y+1))\n\t            self.targets.append(target_group)\n\t        self.T = T\n\t    def GetSpecification(self):\n\t        # Specify that we must avoid all obstacles\n\t        obstacle_formulas = []\n\t        for obs in self.obstacles:\n\t            obstacle_formulas.append(outside_rectangle_formula(obs, 0, 1, 6))\n\t        obstacle_avoidance = obstacle_formulas[0]\n", "        for i in range(1, len(obstacle_formulas)):\n\t            obstacle_avoidance = obstacle_avoidance & obstacle_formulas[i]\n\t        # Specify that for each target group, we need to visit at least one\n\t        # of the targets in that group\n\t        target_group_formulas = []\n\t        for target_group in self.targets:\n\t            group_formulas = []\n\t            for target in target_group:\n\t                group_formulas.append(inside_rectangle_formula(target, 0, 1, 6))\n\t            reach_target_group = group_formulas[0]\n", "            for i in range(1, self.targets_per_group):\n\t                reach_target_group = reach_target_group | group_formulas[i]\n\t            target_group_formulas.append(reach_target_group)\n\t        # Put all of the constraints together in one specification\n\t        specification = obstacle_avoidance.always(0, self.T)\n\t        for reach_target_group in target_group_formulas:\n\t            specification = specification & reach_target_group.eventually(0, self.T)\n\t        return specification\n\t    def GetSystem(self):\n\t        return DoubleIntegrator(2)\n", "    def add_to_plot(self, ax):\n\t        # Add red rectangles for the obstacles\n\t        for obstacle in self.obstacles:\n\t            ax.add_patch(make_rectangle_patch(*obstacle, color='k', alpha=0.5, zorder=-1))\n\t        # Use the color cycle to choose the colors of each target group\n\t        # (note that this won't work for more than 10 target groups)\n\t        selected = ['#1f77b4','#ff7f0e','yellow','#d62728','#9467bd']\n\t        for i, target_group in enumerate(self.targets):\n\t            color = selected[i]\n\t            for i,target in enumerate(target_group):\n", "                ax.add_patch(make_rectangle_patch(*target, color= color, alpha=0.7, zorder=-1))\n\t        # set the field of view\n\t        ax.set_xlim((0,10))\n\t        ax.set_ylim((0,10))\n\t        ax.set_aspect('equal')\n"]}
{"filename": "STLCCP/solver/solver.py", "chunked_list": ["from .base import STLSolver\n\timport cvxpy\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\timport matplotlib.patches as mpatches\n\tfrom typing import Tuple\n\tfrom .dccp import *\n\tfrom ..STL import *\n\timport time\n\tclass CCPSTLSolver(STLSolver):\n", "    def __init__(self, spec, sys, x0, T, k, mode, verbose):\n\t        STLSolver.__init__(self, spec, sys, x0, T, verbose)\n\t        self.k = k\n\t        self.mode = mode\n\t        self.Q = np.zeros((sys.n,sys.n))\n\t        self.R = np.zeros((sys.m,sys.m))\n\t        self.y = cvxpy.Variable((self.sys.p, self.T+1)) # y_0,...,y_T-1\n\t        self.x = cvxpy.Variable((self.sys.n, self.T+1)) # x_0,...,x_T-1\n\t        self.u = cvxpy.Variable((self.sys.m, self.T+1)) \n\t        self.constr = []\n", "        self.constr_penalty = []\n\t        self.cost = 0\n\t        self.AddDynamicsConstraints()\n\t        self.AddRobustness() # Robustness Decomposition (include cost function and constraints)\n\t        # Below are specified in \"example\" file\n\t            # self.AddControlBounds()\n\t            # self.AddStateBounds()\n\t            # self.AddQuadraticCost(Q,R)\n\t    def AddControlBounds(self, u_min, u_max):\n\t        for t in range(self.T+1):\n", "            self.constr += [self.u[:,t]- u_max <= 0]\n\t            #subformula.countleaves()\n\t            self.constr_penalty += [1]\n\t            self.constr += [ u_min - self.u[:,t] <= 0]\n\t            #subformula.countleaves()\n\t            self.constr_penalty += [1]\n\t    def AddStateBounds(self, x_min, x_max):\n\t        for t in range(self.T+1):\n\t            self.constr += [self.x[:,t] - x_max <= 0]\n\t            self.constr_penalty += [1]\n", "            self.constr += [x_min - self.x[:,t] <= 0 ] \n\t            self.constr_penalty += [1]\n\t    def AddQuadraticCost(self, Q, R):\n\t        for t in range(self.T+1):\n\t            temp = cvxpy.quad_form( self.x[:,t],Q ) + cvxpy.quad_form(self.u[:,t], R )\n\t            if temp.curvature ==  \"UNKNOWN\":\n\t                print(\"Quadratic objective curvature unknown\")\n\t            else:\n\t                #print(temp.curvature)\n\t                self.cost += temp  \n", "    def AddDynamicsConstraints(self):\n\t        self.constr += [  self.x[:,0] - self.x0 == 0]\n\t        self.constr_penalty += [1]\n\t        for t in range(self.T):\n\t            self.constr += [self.x[:,t+1] - self.sys.f(self.x[:,t], self.u[:,t]) == 0]\n\t            self.constr_penalty += [1]\n\t            self.constr += [self.y[:,t] - self.sys.g(self.x[:,t], self.u[:,t]) == 0]\n\t            self.constr_penalty += [1]\n\t        self.constr += [self.y[:,self.T] - self.sys.g(self.x[:,self.T], self.u[:,self.T]) == 0]\n\t        self.constr_penalty += [1]\n", "    def Solve(self,initial_guess,weight):\n\t        prob = cvxpy.Problem(cvxpy.Minimize(self.cost), self.constr)\n\t        if initial_guess is not None:\n\t            for i,var in enumerate(prob.variables()):\n\t                var.value = initial_guess[i]\n\t        # GUROBI QP solver options:\n\t        #   solopts={'Method':2,'BarConvTol':1e-3,'BarQCPConvTol':1e-3} # barrier\n\t        #   solopts={'Method':1} # 1=dual simplex\n\t        result,solve_time = prob.solve(method=\"dccp\", solver='GUROBI',verbose=False, constr_penalty=self.constr_penalty,weight=weight) # ,verbose=True, **solopts)\n\t        # Output\n", "        print(\"cost:\", \"{:.4f}\".format(result[0]),\"rho_max:\", \"{:.4f}\".format(self.rho_max.value[0]),\"quadratic cost:\", \"{:.4f}\".format(result[0]-self.rho_max.value[0]))\n\t        rho = self.spec.robustness(self.y.value,0,self.k,self.mode)\n\t        rho_orig = self.spec.orig_robustness(self.y.value,0)[0]\n\t        print(\"original robustness:\", \"{:.4f}\".format(rho_orig),\"(smooth reversed-robustness:\", \"{:.4f})\".format(rho))\n\t        print(\"solve_time:\",\"{:.2f}\".format(solve_time))\n\t        return (self.x,self.u,self.y,rho_orig,solve_time,result[-2],result[-1])\n\t    def AddRobustness(self):\n\t        if self.spec.combination_type ==\"and\":\n\t            self.rho_max = cvxpy.Variable(1) \n\t            self.constr += [ self.rho_max <= 0] # this is a dcp constraint\n", "            self.spec.countleaves()\n\t            self.constr_penalty += [self.spec.count] \n\t            #self.constr += [ -20.0 - self.rho_max <= 0] # # this is a dcp constraint and can be dropped off\n\t            #self.constr_penalty += [1]\n\t            self.cost += self.rho_max \n\t            for i, subformula in enumerate(self.spec.subformula_list):\n\t                t = self.spec.timesteps[i] \n\t                if isinstance(subformula, LinearPredicate):\n\t                    y = self.y[:,t]\n\t                    self.constr += [ subformula.b - subformula.a.T@y - self.rho_max <= 0]\n", "                    self.constr_penalty += [1]\n\t                elif isinstance(subformula, NonlinearPredicate):\n\t                    y = self.y[:,t]\n\t                    self.constr += [ -subformula.g(y) - self.rho_max <= 0]\n\t                    self.constr_penalty += [1]\n\t                elif subformula.combination_type ==\"and\":\n\t                        print(\"You did not simplify the robustness tree\")\n\t                else: \n\t                    self.or_and_loop_to_constr(subformula,self.rho_max,t)\n\t        else: #self.spec.combination_type ==\"or\":\n", "            subrho_array = []\n\t            for i, subformula in enumerate(self.spec.subformula_list):\n\t                t = self.spec.timesteps[i] \n\t                if isinstance(subformula, LinearPredicate):\n\t                    y = self.y[:,t]\n\t                    subrho = subformula.b - subformula.a.T@y\n\t                    subrho_array.append(subrho)\n\t                elif isinstance(subformula, NonlinearPredicate):\n\t                    y = self.y[:,t]\n\t                    subrho = -subformula.g(y)\n", "                    subrho_array.append(subrho)\n\t                elif subformula.combination_type == \"or\":\n\t                    raise Exception(\"error, _or_ should not be here\")\n\t                else: #subformula.combination_type == \"and\": \n\t                    subrho = cvxpy.Variable(1) \n\t                    subrho_array.append(subrho)\n\t                    for l, subsubformula in enumerate(subformula.subformula_list):\n\t                        t_sub = subformula.timesteps[l]\n\t                        if isinstance(subsubformula, LinearPredicate):\n\t                            y = self.y[:,t+t_sub]\n", "                            self.constr += [ subsubformula.b - subsubformula.a.T@y - subrho <= 0]\n\t                            self.constr_penalty += [1]\n\t                        elif isinstance(subsubformula, NonlinearPredicate):\n\t                            # rho = g(y)\n\t                            y = self.y[:,t+t_sub]\n\t                            self.constr += [ -subusbusbformula.g(y) - subrho <= 0 ]\n\t                            self.constr_penalty += [1]\n\t                        else: \n\t                            self.or_and_loop_to_constr(subsubformula,subrho,t+t_sub)\n\t            length = len(subrho_array)\n", "            for i in range(length):\n\t                subrho_array[i] = -self.k * subrho_array[i]\n\t            subrho_array = cvxpy.vstack(subrho_array)\n\t            if self.mode ==\"mellowmin\": \n\t                    smoothedmin = - (cvxpy.log_sum_exp(subrho_array)-np.log(length)) / self.k\n\t            else: # self.mode ==\"lse\": \n\t                    smoothedmin = - (cvxpy.log_sum_exp(subrho_array)) / self.k\n\t            self.rho_max = cvxpy.Variable(1) \n\t            self.cost += self.rho_max \n\t            self.constr += [ self.rho_max <= 0] # this is a dcp constraint\n", "            self.spec.countleaves()\n\t            self.constr_penalty += [self.spec.count] \n\t            self.constr += [smoothedmin <= self.rho_max] \n\t            self.spec.countleaves()\n\t            self.constr_penalty += [self.spec.count]\n\t    def or_and_loop_to_constr(self,formula,rhomax,t):\n\t        subrho_array = []\n\t        for j , subformula in enumerate(formula.subformula_list):\n\t            t_sub = formula.timesteps[j] \n\t            if isinstance(subformula, LinearPredicate):\n", "                y = self.y[:,t+t_sub]\n\t                subrho = subformula.b - subformula.a.T@y\n\t                subrho_array.append(subrho)\n\t            elif isinstance(subformula, NonlinearPredicate):\n\t                # rho = g(y)\n\t                y = self.y[:,t+t_sub]\n\t                subrho = -subformula.g(y)\n\t                subrho_array.append(subrho)\n\t            elif subformula.combination_type == \"or\":\n\t                raise Exception(\"error, _or_ should not be here\")\n", "            else: #subformula.combination_type == \"and\": \n\t                subrho = cvxpy.Variable(1) \n\t                subrho_array.append(subrho)\n\t                for l, subsubformula in enumerate(subformula.subformula_list):\n\t                    t_subsub = subformula.timesteps[l]\n\t                    if isinstance(subsubformula, LinearPredicate):\n\t                        y = self.y[:,t+t_sub+t_subsub]\n\t                        self.constr += [ subsubformula.b - subsubformula.a.T@y - subrho <= 0]\n\t                        self.constr_penalty += [1]\n\t                    elif isinstance(subsubformula, NonlinearPredicate):\n", "                        # rho = g(y)\n\t                        y = self.y[:,t+t_sub+t_subsub]\n\t                        self.constr += [ -subusbusbformula.g(y) - subrho <= 0 ]\n\t                        self.constr_penalty += [1]\n\t                    else: \n\t                        self.or_and_loop_to_constr(subsubformula,subrho,t+t_sub+t_subsub)\n\t        length = len(subrho_array)\n\t        for i in range(length):\n\t            subrho_array[i] = -self.k * subrho_array[i]\n\t        subrho_array = cvxpy.vstack(subrho_array)\n", "        if self.mode ==\"mellowmin\": \n\t                smoothedmin = - (cvxpy.log_sum_exp(subrho_array)-np.log(length)) / self.k\n\t        else: # self.mode ==\"lse\": \n\t                smoothedmin = - (cvxpy.log_sum_exp(subrho_array)) / self.k\n\t        self.constr += [smoothedmin - rhomax <= 0] \n\t        formula.countleaves()\n\t        self.constr_penalty += [formula.count]\n"]}
{"filename": "STLCCP/solver/base.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tclass STLSolver(ABC):\n\t    \"\"\"\n\t    A simple abstract base class defining a common solver interface\n\t    for different optimization-based STL synthesis methods.\n\t    This class considers variations on the trajectory synthesis problem\n\t    .. math::\n\t        \\min & \\sum_{t=0}^T x_t^TQx_t + u_t^TRu_t\n\t        \\\\text{s.t. } & x_0 \\\\text{ fixed }\n\t        & x_{t+1} = f(x_t, u_t)\n", "        & y_t = g(x_t, u_t)\n\t        & \\\\rho^{\\\\varphi}(y_0,y_1,\\dots,y_T) \\geq 0\n\t    where :math:`Q \\\\succeq 0` and :math:`R \\\\succeq 0` are cost weights, :math:`f` and :math:`g`\n\t    define the system dynamics, and :math:`\\\\rho` is the robustness measure associated with\n\t    a given STL specification :math:`\\\\varphi`.\n\t    Possible variations include using the robustness measure :math:`\\\\rho^\\\\varphi`\n\t    as a cost, dropping the quadratic running cost, and removing the hard satisfaction\n\t    constriant :math:`\\\\rho^{\\\\varphi}\\geq 0`.\n\t    :param spec:    An :class:`.STLFormula` describing the specification.\n\t    :param sys:     An :class:`.NonlinearSystem` characterizing the system dynamics.\n", "    :param x0:      A ``(n,1)`` numpy array representing the initial state :math:`x_0`.\n\t    :param T:       A positive integer fixing the total number of timesteps :math:`T`.\n\t    :param verbose: A boolean specifying whether to print detailed solver info.\n\t    \"\"\"\n\t    def __init__(self, spec, sys, x0, T, verbose):\n\t        # Store the relevant data\n\t        self.sys = sys\n\t        self.spec = spec\n\t        self.x0 = x0\n\t        self.T = T+1  # needed to be consistent with how we've defined STLFormula\n", "        self.verbose = verbose\n\t    @abstractmethod\n\t    def AddDynamicsConstraints(self):\n\t        \"\"\"\n\t        Add the dynamics constraints\n\t        .. math::\n\t            & x_0 \\\\text{ fixed }\n\t            & x_{t+1} = f(x_t, u_t)\n\t            & y_t = g(x_t, u_t)\n\t        to the optimization problem.\n", "        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def AddRobustness(self):\n\t        \"\"\"\n\t        Add a constraint on the robustness measure to the\n\t        optimization problem:\n\t        .. math::\n\t            \\\\rho^{\\\\varphi}(y_0,y_1,\\dots,y_T) \\geq \\\\rho_{min}\n\t        :param rho_min:     (optional) Minimum robustness measure :math:`\\\\rho_{min}`.\n", "                            Defaults to 0, which enforces STL satisfaction.\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def AddControlBounds(self, u_min, u_max):\n\t        \"\"\"\n\t        Add upper and lower bounds on the control inputs :math:`u_t`\n\t        to the optimization problem:\n\t        .. math::\n\t            u_{min} \\leq u_t \\leq u_{max} \\quad \\\\forall t\n", "        :param u_min:   A ``(m,)`` numpy array specifying the minimum control input\n\t        :param u_max:   A ``(m,)`` numpy array specifying the maximum control input\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def AddStateBounds(self, x_min, x_max):\n\t        \"\"\"\n\t        Add upper and lower bounds on the state variables :math:`x_t`\n\t        to the optimization problem:\n\t        .. math::\n", "            x_{min} \\leq x_t \\leq x_{max} \\quad \\\\forall t\n\t        :param x_min:   A ``(n,)`` numpy array specifying :math:`x_{min}`\n\t        :param x_max:   A ``(n,)`` numpy array specifying :math:`x_{max}`\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def AddQuadraticCost(self, Q, R):\n\t        \"\"\"\n\t        Add a quadratic running cost to the optimization problem:\n\t        .. math::\n", "            \\min \\sum_{t=0}^T x_t^TQx_t + u_t^TRu_t\n\t        :param Q:   A ``(n,n)`` numpy array representing the state penalty matrix :math:`Q`\n\t        :param R:   A ``(m,m)`` numpy array representing the control penalty matrix :math:`R`\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def Solve(self):\n\t        \"\"\"\n\t        Solve the STL syntheis optimization problem and return an optimal trajectory.\n\t        :return x:          A ``(n,T)`` numpy array containing the optimal state :math:`x_t`\n", "                            for each timestep.\n\t        :return u:          A ``(m,T)`` numpy array containing the optimal control :math:`x_t`\n\t                            for each timestep.\n\t        :return rho:        A scalar indicating the optimal robustness value.\n\t        :return solve_time: The time it took the solver to find a solution, in seconds.\n\t        .. note::\n\t            ``x`` and ``u`` are returned as ``None`` if the optimization problem is\n\t            infeasible or the solver is unable to find a solution.\n\t        \"\"\"\n\t        pass\n"]}
{"filename": "STLCCP/solver/__init__.py", "chunked_list": ["from .solver import CCPSTLSolver\n\tfrom .dccp import *"]}
{"filename": "STLCCP/solver/dccp/constraint.py", "chunked_list": ["__author__ = \"Xinyue\"\n\t# Modified by Takayama in 2023-01 for STLCCP\n\tfrom dccp.linearize import linearize\n\timport cvxpy as cvx\n\tdef convexify_constr(constr):\n\t    \"\"\"\n\t    :param constr: a constraint of a problem\n\t    :return:\n\t    for a dcp constraint, return itself;\n\t    for a non-dcp constraint, return a convexified constraint and domain constraints;\n", "    return None if non-sub/super-diff\n\t    \"\"\"\n\t    if not constr.is_dcp():\n\t        dom = []\n\t        # left hand concave\n\t        if constr.args[0].curvature == \"CONCAVE\":\n\t            left = linearize(constr.args[0])\n\t            if left is None:\n\t                return None\n\t            else:\n", "                for con in constr.args[0].domain:\n\t                    dom.append(con)\n\t        else:\n\t            left = constr.args[0]\n\t        # right hand convex\n\t        if constr.args[1].curvature == \"CONVEX\":\n\t            right = linearize(constr.args[1])\n\t            if right is None:\n\t                return None\n\t            else:\n", "                for con in constr.args[1].domain:\n\t                    dom.append(con)\n\t        else:\n\t            right = constr.args[1]\n\t        return left - right <= 0, dom\n\t    else:\n\t        return constr, []\n"]}
{"filename": "STLCCP/solver/dccp/__init__.py", "chunked_list": ["from .problem import is_dccp\n\tfrom .linearize import linearize\n\tfrom .objective import convexify_obj\n\tfrom .constraint import convexify_constr\n\tfrom .problem import dccp\n"]}
{"filename": "STLCCP/solver/dccp/problem.py", "chunked_list": ["__author__ = \"Xinyue\"\n\t# Modified by Takayama in 2023-01 for STLCCP\n\timport numpy as np\n\timport cvxpy as cvx\n\timport logging\n\timport warnings\n\timport time\n\tfrom .objective import convexify_obj\n\tfrom .constraint import convexify_constr\n\timport os\n", "logger = logging.getLogger(\"dccp\")\n\tlogger.addHandler(logging.FileHandler(filename=\"dccp.log\", mode=\"w\", delay=True))\n\tlogger.setLevel(logging.INFO)\n\tlogger.propagate = False\n\tdef dccp(\n\t    self,\n\t    max_iter=25,\n\t    tau=0.005,\n\t    mu=2.0,\n\t    tau_max=1e3,\n", "    solver=None,\n\t    max_penalty=1e-5,\n\t    ep=1e-2,\n\t    **kwargs\n\t):\n\t    \"\"\"\n\t    main algorithm ccp\n\t    :param max_iter: maximum number of iterations in ccp\n\t    :param tau: initial weight on slack variables\n\t    :param mu:  increment of weight on slack variables\n", "    :param tau_max: maximum weight on slack variables\n\t    :param solver: specify the solver for the transformed problem\n\t    :return\n\t        if the transformed problem is infeasible, return None;\n\t    \"\"\"\n\t    self.tau = tau\n\t    print(\"Solver:\",solver)\n\t    if not is_dccp(self):\n\t        raise Exception(\"Problem is not DCCP.\")\n\t    if is_contain_complex_numbers(self):\n", "        warnings.warn(\"Problem contains complex numbers and may not be supported by DCCP.\")\n\t        logger.info(\"WARN: Problem contains complex numbers and may not be supported by DCCP.\")\n\t    result = None\n\t    if self.objective.NAME == \"minimize\":\n\t        cost_value = float(\"inf\")  # record on the best cost value\n\t    else:\n\t        cost_value = -float(\"inf\")\n\t    start_time=time.time()\n\t    ccp_times = 1 \n\t    # In STLCCP, this ccp_times parameter, which determines how many times we run ccp to solve a problem\n", "    #  with random initial values on variables, is \n\t    for t in range(ccp_times):  # for each time of running ccp\n\t        dccp_ini(\n\t            self, random=(ccp_times > 1), solver=solver, **kwargs\n\t        )  # initialization; \n\t        # iterations\n\t        result_temp = iter_dccp(\n\t            self, max_iter, self.tau, mu, tau_max, solver, ep, max_penalty, **kwargs\n\t        )\n\t        # first iteration\n", "        if t == 0:\n\t            self._status = result_temp[-1]\n\t            result = result_temp\n\t            cost_value = result_temp[0]\n\t            result_record = {}\n\t            for var in self.variables():\n\t                result_record[var] = var.value\n\t        else:\n\t            if result_temp[-1] == \"Converged\":\n\t                self._status = result_temp[-1]\n", "                if result_temp[0] is not None:\n\t                    if (\n\t                        (cost_value is None)\n\t                        or (\n\t                            self.objective.NAME == \"minimize\"\n\t                            and result_temp[0] < cost_value\n\t                        )\n\t                        or (\n\t                            self.objective.NAME == \"maximize\"\n\t                            and result_temp[0] > cost_value\n", "                        )\n\t                    ):  # find a better cost value\n\t                        # no slack; slack small enough\n\t                        if len(result_temp) < 4 or result_temp[1] < max_penalty:\n\t                            result = result_temp  # update the result\n\t                            cost_value = result_temp[\n\t                                0\n\t                            ]  # update the record on the best cost value\n\t                            for var in self.variables():\n\t                                result_record[var] = var.value\n", "            else:\n\t                for var in self.variables():\n\t                    var.value = result_record[var]\n\t    solve_time = time.time() - start_time\n\t    return result,solve_time\n\tdef dccp_ini(self, times=1, random=0, solver=None, **kwargs):\n\t    \"\"\"\n\t    set initial values\n\t    :param times: number of random projections for each variable\n\t    :param random: mandatory random initial values\n", "    \"\"\"\n\t    dom_constr = self.objective.args[0].domain  # domain of the objective function\n\t    for arg in self.constraints:\n\t        for l in range(len(arg.args)):\n\t            for dom in arg.args[l].domain:\n\t                dom_constr.append(dom)  # domain on each side of constraints\n\t    var_store = {}  # store initial values for each variable\n\t    init_flag = {}  # indicate if any variable is initialized by the user\n\t    var_user_ini = {}\n\t    #print(\"self.variables()\",self.variables())\n", "    for var in self.variables():\n\t        var_store[var] = np.zeros(var.shape)  # to be averaged\n\t        init_flag[var] = var.value is None\n\t        if var.value is None:\n\t            var_user_ini[var] = np.zeros(var.shape)\n\t        else:\n\t            var_user_ini[var] = var.value\n\t    for t in range(times):  # for each time of random projection\n\t        # setup the problem\n\t        ini_cost = 0\n", "        for var in self.variables():\n\t            if (init_flag[var] or random):  # if the variable is not initialized by the user, or random initialization is mandatory\n\t                if len(var.shape) > 1:\n\t                    a = cvx.norm(var - np.random.randn(var.shape[0], var.shape[1]) * 10, \"fro\")\n\t                    ini_cost += a\n\t                else:\n\t                    a = cvx.norm(var - np.random.randn(var.size) * 10)\n\t                    ini_cost += a\n\t        ini_obj = cvx.Minimize(ini_cost)\n\t        ini_prob = cvx.Problem(ini_obj, dom_constr)\n", "        solver = \"ECOS\" # only for the above problem to avoid error\n\t        #print(dom_constr)\n\t        ini_prob.solve(solver=solver)  \n\t        print(\"End solving initial problem\")\n\t        for var in self.variables():\n\t            var_store[var] = var_store[var] + var.value / float(times)  # randomized \n\t    # set initial values\n\t    for var in self.variables():\n\t        if init_flag[var] or random: \n\t            #print(\"randomized\")\n", "            var.value = var_store[var]\n\t        else:\n\t            #print(\"User specified\")\n\t            var.value = var_user_ini[var]\n\tdef is_dccp(problem):\n\t    \"\"\"\n\t    :param\n\t        a problem\n\t    :return\n\t        a boolean indicating if the problem is dccp\n", "    \"\"\"\n\t    if problem.objective.expr.curvature == \"UNKNOWN\":\n\t        return False\n\t    for constr in problem.constraints:\n\t        for arg in constr.args:\n\t            if arg.curvature == \"UNKNOWN\":\n\t                return False\n\t    return True\n\tdef is_contain_complex_numbers(self):\n\t    for variable in self.variables():\n", "        if variable.is_complex():\n\t            return True\n\t    for para in self.parameters():\n\t        if para.is_complex():\n\t            return True\n\t    for constant in self.constants():\n\t        if constant.is_complex():\n\t            return True\n\t    for arg in self.objective.args:\n\t        if arg.is_complex():\n", "            return True\n\t    for constr in self.constraints:\n\t        for arg in constr.args:\n\t            if arg.is_complex():\n\t                return True\n\t    return False\n\tdef iter_dccp(self, max_iter, tau, mu, tau_max, solver, ep, max_penalty_tol, **kwargs):\n\t    \"\"\"\n\t    ccp iterations\n\t    :param max_iter: maximum number of iterations in ccp\n", "    :param tau: initial weight on slack variables\n\t    :param mu:  increment of weight on slack variables\n\t    :param tau_max: maximum weight on slack variables\n\t    :param solver: specify the solver for the transformed problem\n\t    :return\n\t        value of the objective function, maximum value of slack variables, value of variables\n\t    \"\"\"\n\t    # split non-affine equality constraints\n\t    constr = []\n\t    for constraint in self.constraints:\n", "        if (str(type(constraint)) == \"<class 'cvxpy.constraints.zero.Equality'>\" and not constraint.is_dcp()):\n\t            print(\"The optimization problem contains some non-affine equality constraints that CCP has to approximate, which can decrease the performance of our method.\")\n\t            print(\"Note that the robustness decomposition method does not produce any equality constraints\")\n\t            constr.append(constraint.args[0] <= constraint.args[1])\n\t            constr.append(constraint.args[0] >= constraint.args[1])\n\t        else:\n\t            constr.append(constraint)\n\t    obj = self.objective\n\t    tau = self.tau\n\t    self = cvx.Problem(obj, constr)\n", "    self.tau = tau\n\t    it = 1\n\t    converge = False\n\t    # keep the values from the previous iteration or initialization\n\t    previous_cost = float(\"inf\")\n\t    previous_org_cost = self.objective.value\n\t    variable_pres_value = []\n\t    for var in self.variables():\n\t        variable_pres_value.append(var.value)\n\t    # each non-dcp constraint needs a slack variable\n", "    var_penalty = []\n\t    var_weight =[]\n\t    self.constr_penalty = kwargs['constr_penalty']\n\t    kwargs.pop('constr_penalty')\n\t    weight_type = kwargs['weight']\n\t    kwargs.pop('weight')\n\t    for i, constr in enumerate(self.constraints):\n\t        if (not constr.is_dcp()):\n\t            var_penalty.append(cvx.Variable(constr.shape))\n\t            var_weight.append(self.constr_penalty[i]) # tree weighted penalty (TWP)\n", "    # Just compute the average and minimum of penalty weights\n\t    sum=0\n\t    for i in range(len(var_weight)):\n\t        sum += var_weight[i]\n\t    av = float(sum)/ len(var_weight)\n\t    penaltymin=np.array(var_weight).min() \n\t    if weight_type == \"50\":\n\t        var_weight = np.full_like(var_weight,50) # same-weight = 50 \n\t    elif weight_type == \"smallest\":\n\t        var_weight = np.full_like(var_weight,penaltymin) # same-weight = lowest in tree\n", "    rate=0.2 # the decay parameter for TWP-CCP with decay\n\t    while it <= max_iter and all(var.value is not None for var in self.variables()):\n\t        constr_new = []\n\t        # objective\n\t        convexified_obj = convexify_obj(self.objective)\n\t        if not self.objective.is_dcp():\n\t            # non-sub/super-diff\n\t            while convexified_obj is None:\n\t                # damping\n\t                var_index = 0\n", "                for var in self.variables():\n\t                    var.value = 0.8 * var.value + 0.2 * variable_pres_value[var_index]\n\t                    var_index += 1\n\t                convexified_obj = convexify_obj(self.objective)\n\t            # domain constraints\n\t            for dom in self.objective.expr.domain:\n\t                print(dom,\"dom\")\n\t                constr_new.append(dom)\n\t        # new cost function\n\t        cost_new = convexified_obj.expr\n", "        # constraints\n\t        count_slack = 0\n\t        for i,arg in enumerate(self.constraints):\n\t            temp = convexify_constr(arg) \n\t            if (not arg.is_dcp()): \n\t                while temp is None:\n\t                    # damping\n\t                    var_index = 0\n\t                    for var in self.variables():\n\t                        var.value = (\n", "                            0.8 * var.value + 0.2 * variable_pres_value[var_index]\n\t                        )\n\t                        var_index += 1\n\t                    temp = convexify_constr(arg)\n\t                newcon = temp[0]  \n\t                for dom in temp[1]:  \n\t                    constr_new.append(dom)\n\t                constr_new.append(newcon.expr <= var_penalty[count_slack])\n\t                constr_new.append(var_penalty[count_slack] >= 0)\n\t                count_slack = count_slack + 1\n", "            else:\n\t                constr_new.append(arg)\n\t        # objective\n\t        if self.objective.NAME == \"minimize\":\n\t            for i,var in enumerate(var_penalty):\n\t                if weight_type == \"decay\":\n\t                    cost_new += ((var_weight[i]-penaltymin) * np.exp(-rate*(it-1)) + penaltymin) * self.tau * cvx.sum(var)\n\t                else:\n\t                    cost_new += var_weight[i]  * self.tau * cvx.sum(var)\n\t            obj_new = cvx.Minimize(cost_new)\n", "        else:\n\t            for i,var in enumerate(var_penalty):\n\t                if weight_type == \"decay\":\n\t                    cost_new -= ((var_weight[i]-penaltymin) * np.exp(-rate*(it-1)) + penaltymin) * self.tau * cvx.sum(var)\n\t                else:\n\t                    cost_new -= var_weight[i]  * self.tau * cvx.sum(var)\n\t            obj_new = cvx.Maximize(cost_new)\n\t        # new problem\n\t        #print(len(constr_new),\"length of constr new\")\n\t        prob_new = cvx.Problem(obj_new, constr_new)\n", "        # keep previous value of variables\n\t        variable_pres_value = []\n\t        for var in self.variables():\n\t            variable_pres_value.append(var.value)\n\t        # solve\n\t        if solver is None:\n\t            prob_new_cost_value = prob_new.solve(**kwargs)\n\t        else:\n\t            prob_new_cost_value = prob_new.solve(solver=solver, **kwargs)\n\t        if prob_new_cost_value is not None:\n", "            logger.info(\n\t                \"iteration=%d, cost value=%.5f, self.tau=%.5f, solver status=%s\",\n\t                it,\n\t                prob_new_cost_value,\n\t                self.tau,\n\t                prob_new.status,\n\t            )\n\t        else:\n\t            logger.info(\n\t                \"iteration=%d, cost value=%.5f, self.tau=%.5f, solver status=%s\",\n", "                it,\n\t                np.nan,\n\t                self.tau,\n\t                prob_new.status,\n\t            )\n\t        max_penalty = None\n\t        # print slack\n\t        if (\n\t            prob_new._status == \"optimal\" or prob_new._status == \"optimal_inaccurate\"\n\t        ) and not var_penalty == []:\n", "            slack_values = [v.value for v in var_penalty if v.value is not None]\n\t            max_penalty = max([np.max(v) for v in slack_values] + [-np.inf])\n\t            logger.info(\"max slack = %.5f\", max_penalty)\n\t        # terminal conditions\n\t        if (\n\t            (prob_new.value is not None\n\t            and np.abs(previous_cost - prob_new.value) <= ep\n\t            and np.abs(self.objective.value - previous_org_cost) <= ep\n\t            and (max_penalty is None or max_penalty <= max_penalty_tol))\n\t        ):\n", "            it = max_iter + 1\n\t            converge = True\n\t        else:\n\t            print(\"Iteration: \",it, \", max_penalty:\", \"{:.2e}\".format(max_penalty), \" tau: \" , self.tau)\n\t            print(\"Terminal Conditions:\" #, (prob_new.value is not None) # relaxed program has a value\n\t            , (np.abs(previous_cost - prob_new.value) <= ep) #  cost_difference (relaxed program)\n\t            , (np.abs(self.objective.value - previous_org_cost) <= ep) # cost_difference (original program)\n\t            , (max_penalty is None or max_penalty <= max_penalty_tol)   ) #  max_penalty  \n\t            print(\"--- Constraints whose penalty variables remain high ---\")\n\t            for i in range(len(slack_values)):\n", "                if slack_values[i] >= 1.0: #or (var_weight[i] != 4):\n\t                    print(\"constraint number:\", i, \", slack value:\" ,\"{:.4f}\".format(slack_values[i][0]),\", penalty weight:\", var_weight[i]) \n\t            print(\"--------------------------------------\")\n\t            previous_cost = prob_new.value\n\t            previous_org_cost = self.objective.value\n\t            self.tau = min([self.tau * mu, tau_max])\n\t            it += 1\n\t    # return\n\t    if converge:\n\t        self._status = \"Converged\"\n", "    else:\n\t        self._status = \"Not_converged\"\n\t    var_value = []\n\t    for var in self.variables():\n\t        var_value.append(var.value)\n\t    if not var_penalty == []:\n\t        return (self.objective.value, max_penalty, var_value, self._status)\n\t    else:\n\t        return (self.objective.value, var_value, self._status)\n\tcvx.Problem.register_solve(\"dccp\", dccp)\n"]}
{"filename": "STLCCP/solver/dccp/linearize.py", "chunked_list": ["__author__ = \"Xinyue\"\n\t# Modified by Takayama in 2023-01 for STLCCP\n\timport numpy as np\n\timport cvxpy as cvx\n\tdef linearize(expr):\n\t    \"\"\"Returns the tangent approximation to the expression.\n\t    Gives an elementwise lower (upper) bound for convex (concave)\n\t    expressions. No guarantees for non-DCP expressions.\n\t    Args:\n\t        expr: An expression.\n", "    Returns:\n\t        An affine expression.\n\t    \"\"\"\n\t    if expr.is_affine():\n\t        return expr\n\t    else:\n\t        if expr.value is None:\n\t            raise ValueError(\n\t                \"Cannot linearize non-affine expression with missing variable values.\"\n\t            )\n", "        tangent = np.real(expr.value) #+ np.imag(expr.value)\n\t        grad_map = expr.grad\n\t        for var in expr.variables():\n\t            if grad_map[var] is None:\n\t                return None\n\t            complex_flag = False\n\t            if var.is_complex() or np.any(np.iscomplex(grad_map[var])):\n\t                complex_flag = True\n\t            if var.ndim > 1:\n\t                temp = cvx.reshape(\n", "                    cvx.vec(var - var.value), (var.shape[0] * var.shape[1], 1)\n\t                )\n\t                if complex_flag:\n\t                    flattened = np.transpose(np.real(grad_map[var])) @ cvx.real(temp) + \\\n\t                    np.transpose(np.imag(grad_map[var])) @ cvx.imag(temp)\n\t                else:\n\t                    flattened = np.transpose(np.real(grad_map[var])) @ temp\n\t                tangent = tangent + cvx.reshape(flattened, expr.shape)\n\t            elif var.size > 1:\n\t                if complex_flag:\n", "                    tangent = tangent + np.transpose(np.real(grad_map[var])) @ (cvx.real(var) - np.real(var.value)) \\\n\t                    + np.transpose(np.imag(grad_map[var])) @ (cvx.imag(var) - np.imag(var.value))\n\t                else:\n\t                    tangent = tangent + np.transpose(np.real(grad_map[var])) @ (var - var.value)\n\t            else:\n\t                if complex_flag:\n\t                    tangent = tangent + np.real(grad_map[var]) * (cvx.real(var) - np.real(var.value)) \\\n\t                    + np.imag(grad_map[var]) * (cvx.imag(var) - np.imag(var.value))\n\t                else:\n\t                    tangent = tangent + np.real(grad_map[var]) * (var - var.value)\n", "        return tangent\n"]}
{"filename": "STLCCP/solver/dccp/objective.py", "chunked_list": ["__author__ = \"Xinyue\"\n\t# Modified by Takayama in 2023-01 for STLCCP\n\tfrom dccp.linearize import linearize\n\timport cvxpy as cvx\n\tdef is_dccp(objective):\n\t    \"\"\"\n\t    input:\n\t        objective: an objective of a problem\n\t    return:\n\t        if the objective is dccp\n", "        the objective must be convex, concave, affine, or constant\n\t    \"\"\"\n\t    if objective.expr.curvature == \"UNKNOWN\":\n\t        print(\"objfal\")\n\t        return False\n\t    else:\n\t        return True\n\tdef convexify_obj(obj):\n\t    \"\"\"\n\t    :param obj: objective of a problem\n", "    :return: convexified onjective or None\n\t    \"\"\"\n\t    # not dcp\n\t    if obj.is_dcp() == False:\n\t        lin = linearize(obj.expr)\n\t        # non-sub/super-diff\n\t        if lin is None:\n\t            return None\n\t        else:\n\t            if obj.NAME == \"minimize\":\n", "                result = cvx.Minimize(lin)\n\t            else:\n\t                result = cvx.Maximize(lin)\n\t    else:\n\t        result = obj\n\t    return result\n"]}
{"filename": "STLCCP/STL/formula.py", "chunked_list": ["import numpy as np\n\tfrom abc import ABC, abstractmethod\n\tfrom treelib import Tree\n\tfrom scipy.special import logsumexp\n\timport collections\n\tclass STLFormula(ABC):\n\t    \"\"\"\n\t    An abstract class which encompasses represents all kinds of STL formulas :math:`\\\\varphi`, including\n\t    predicates (the simplest possible formulas) and standard formulas (made up of logical operations over\n\t    predicates and other formulas).\n", "    \"\"\"\n\t    @abstractmethod\n\t    def robustness(self, y, t):\n\t        \"\"\"\n\t        Compute the robustness measure :math:`\\\\rho^\\\\varphi(y,t)` of this formula for the\n\t        given signal :math:`y = y_0,y_1,\\\\dots,y_T`, evaluated at timestep :math:`t`.\n\t        :param y:    A ``(d,T)`` numpy array representing the signal\n\t                     to evaluate, where ``d`` is the dimension of\n\t                     the signal and ``T`` is the number of timesteps\n\t        :param t:    The timestep :math:`t` to evaluate the signal at. This\n", "                     is typically 0 for the full formula.\n\t        :return:    The robustness measure :math:`\\\\rho^\\\\varphi(y,t)` which is positive only\n\t                    if the signal satisfies the specification.\n\t        \"\"\"\n\t        pass\n\t    def orig_robustness(self, y, t):\n\t        pass\n\t    @abstractmethod\n\t    def is_predicate(self):\n\t        \"\"\"\n", "        Indicate whether this formula is a predicate.\n\t        :return:    A boolean which is ``True`` only if this is a predicate.\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def is_state_formula(self):\n\t        \"\"\"\n\t        Indicate whether this formula is a state formula, e.g.,\n\t        a predicate or the result of boolean operations over\n\t        predicates.\n", "        :return:    A boolean which is ``True`` only if this is a state formula.\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def is_disjunctive_state_formula(self):\n\t        \"\"\"\n\t        Indicate whether this formula is a state formula defined by\n\t        only disjunctions (or) over predicates.\n\t        :return:     A boolean which is ``True`` only if this is a disjunctive state formula.\n\t        \"\"\"\n", "        pass\n\t    @abstractmethod\n\t    def is_conjunctive_state_formula(self):\n\t        \"\"\"\n\t        Indicate whether this formula is a state formula defined by\n\t        only conjunctions (and) over predicates.\n\t        :return:     A boolean which is ``True`` only if this is a conjunctive state formula.\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n", "    def get_all_inequalities(self):\n\t        \"\"\"\n\t        Return all inequalities associated with this formula stacked into vector form\n\t        .. math::\n\t            Ay \\le b\n\t        where each row of :math:`A` and :math:`b` correspond to a predicate in this formula.\n\t        .. note::\n\t            This method is really only useful for conjunctive state formulas.\n\t        :return A:  An (n,m) numpy array representing :math:`A`\n\t        :return b:  An (n,) numpy array representing :math:`b`\n", "        \"\"\"\n\t        pass\n\t    @abstractmethod\n\t    def negation(self):\n\t        \"\"\"\n\t        Return a new :class:`.STLFormula` :math:`\\\\varphi_{new}` which represents\n\t        the negation of this formula:\n\t        .. math::\n\t            \\\\varphi_{new} = \\lnot \\\\varphi\n\t        :return: An :class:`.STLFormula` representing :math:`\\\\varphi_{new}`\n", "        .. note::\n\t            For now, only formulas in positive normal form are supported. That means that negation\n\t            (:math:`\\lnot`) can only be applied to predicates (:math:`\\\\pi`).\n\t        \"\"\"\n\t        pass\n\t    def conjunction(self, other):\n\t        \"\"\"\n\t        Return a new :class:`.STLTree` :math:`\\\\varphi_{new}` which represents the conjunction\n\t        (and) of this formula (:math:`\\\\varphi`) and another one (:math:`\\\\varphi_{other}`):\n\t        .. math::\n", "            \\\\varphi_{new} = \\\\varphi \\land \\\\varphi_{other}\n\t        :param other:   The :class:`.STLFormula` :math:`\\\\varphi_{other}`\n\t        :return: An :class:`.STLTree` representing :math:`\\\\varphi_{new}`\n\t        .. note::\n\t            Conjuction can also be represented with the ``&`` operator, i.e.,\n\t            ::\n\t                c = a & b\n\t            is equivalent to\n\t            ::\n\t                c = a.conjuction(b)\n", "        \"\"\"\n\t        return STLTree([self,other],\"and\",[0,0])\n\t    def __and__(self, other):\n\t        \"\"\"\n\t        Syntatic sugar so we can write `one_and_two = one & two`\n\t        \"\"\"\n\t        return self.conjunction(other)\n\t    def disjunction(self, other):\n\t        \"\"\"\n\t        Return a new :class:`.STLTree` :math:`\\\\varphi_{new}` which represents the disjunction\n", "        (or) of this formula (:math:`\\\\varphi`) and another one (:math:`\\\\varphi_{other}`):\n\t        .. math::\n\t            \\\\varphi_{new} = \\\\varphi \\lor \\\\varphi_{other}\n\t        :param other:   The :class:`.STLFormula` :math:`\\\\varphi_{other}`\n\t        :return: An :class:`.STLTree` representing :math:`\\\\varphi_{new}`\n\t        .. note::\n\t            Disjunction can also be represented with the ``|`` operator, i.e.,\n\t            ::\n\t                c = a | b\n\t            is equivalent to\n", "            ::\n\t                c = a.disjunction(b)\n\t        \"\"\"\n\t        return STLTree([self,other],\"or\",[0,0])\n\t    def __or__(self, other):\n\t        \"\"\"\n\t        Syntatic sugar so we can write `one_or_two = one | two`\n\t        \"\"\"\n\t        return self.disjunction(other)\n\t    def always(self, t1, t2):\n", "        \"\"\"\n\t        Return a new :class:`.STLTree` :math:`\\\\varphi_{new}` which ensures that this\n\t        formula (:math:`\\\\varphi`) holds for all of the timesteps between\n\t        :math:`t_1` and :math:`t_2`:\n\t        .. math::\n\t            \\\\varphi_{new} = G_{[t_1,t_2]}(\\\\varphi)\n\t        :param t1:  An integer representing the delay :math:`t_1`\n\t        :param t2:  An integer representing the deadline :math:`t_2`\n\t        :return: An :class:`.STLTree` representing :math:`\\\\varphi_{new}`\n\t        \"\"\"\n", "        time_interval = [t for t in range(t1,t2+1)]\n\t        subformula_list = [self for t in time_interval]\n\t        formula = STLTree(subformula_list, \"and\", time_interval)\n\t        if self.name is not None:\n\t            formula.name = \"always [%s,%s] %s\" % (t1,t2,self.name)\n\t        return formula\n\t    def eventually(self, t1, t2):\n\t        \"\"\"\n\t        Return a new :class:`.STLTree` :math:`\\\\varphi_{new}` which ensures that this\n\t        formula (:math:`\\\\varphi`) holds for at least one timestep between\n", "        :math:`t_1` and :math:`t_2`:\n\t        .. math::\n\t            \\\\varphi_{new} = F_{[t_1,t_2]}(\\\\varphi)\n\t        :param t1:  An integer representing the delay :math:`t_1`\n\t        :param t2:  An integer representing the deadline :math:`t_2`\n\t        :return: An :class:`.STLTree` representing :math:`\\\\varphi_{new}`\n\t        \"\"\"\n\t        time_interval = [t for t in range(t1,t2+1)]\n\t        subformula_list = [self for t in time_interval]\n\t        formula = STLTree(subformula_list, \"or\", time_interval)\n", "        if self.name is not None:\n\t            formula.name = \"eventually [%s,%s] %s\" % (t1,t2,self.name)\n\t        return formula\n\t    def until(self, other, t1, t2):\n\t        \"\"\"\n\t        Return a new :class:`.STLTree` :math:`\\\\varphi_{new}` which ensures that the\n\t        given formula :math:`\\\\varphi_{other}` holds for at least one timestep between\n\t        :math:`t_1` and :math:`t_2`, and that this formula (:math:`\\\\varphi`) holds\n\t        at all timesteps until then:\n\t        .. math::\n", "            \\\\varphi_{new} = \\\\varphi U_{[t_1,t_2]}(\\\\varphi_{other})\n\t        :param other:   A :class:`.STLFormula` representing :math:`\\\\varphi_{other`\n\t        :param t1:  An integer representing the delay :math:`t_1`\n\t        :param t2:  An integer representing the deadline :math:`t_2`\n\t        :return: An :class:`.STLTree` representing :math:`\\\\varphi_{new}`\n\t        \"\"\"\n\t        # For every candidate swiching time (t_prime), construct a subformula\n\t        # representing 'self' holding until t_prime, at which point 'other' holds.\n\t        self_until_tprime = []\n\t        for t_prime in range(t1, t2+1):\n", "            time_interval = [t for t in range(t1, t_prime+1)]\n\t            subformula_list = [self for t in range(t1, t_prime)]\n\t            subformula_list.append(other)\n\t            self_until_tprime.append(STLTree(subformula_list, \"and\", time_interval))\n\t        # Then we take the disjunction over each of these formulas\n\t        return STLTree(self_until_tprime, \"or\", [0 for i in range(len(self_until_tprime))])\n\t    def get_all_conjunctive_state_formulas(self):\n\t        \"\"\"\n\t        Return a list of all of the (unique) conjunctive state\n\t        formulas that make up this specification.\n", "        :return:    A list of STLFormula objects\n\t        \"\"\"\n\t        CSFs = []\n\t        if self.is_conjunctive_state_formula():\n\t            CSFs.append(self)\n\t        else:\n\t            for subformula in self.subformula_list:\n\t                new_csf_list = subformula.get_all_conjunctive_state_formulas()\n\t                # TODO: Deal with special case where there is only one formula in the\n\t                # conjunction list: this comes up when the UNTIL operator is used\n", "                # Only add those formulas that we don't already have to the list\n\t                for csf in new_csf_list:\n\t                    if not csf in CSFs:\n\t                        CSFs.append(csf)\n\t        return CSFs\n\tclass STLTree(STLFormula):\n\t    \"\"\"\n\t    Describes an STL formula :math:`\\\\varphi` which is made up of\n\t    operations over :class:`.STLFormula` objects. This defines a tree structure,\n\t    so that, for example, the specification\n", "    .. math::\n\t        \\\\varphi = G_{[0,3]} \\\\pi_1 \\land F_{[0,3]} \\\\pi_2\n\t    is represented by the tree\n\t    .. graphviz::\n\t        digraph tree {\n\t            root [label=\"phi\"];\n\t            G [label=\"G\"];\n\t            F [label=\"F\"];\n\t            n1 [label=\"pi_1\"];\n\t            n2 [label=\"pi_1\"];\n", "            n3 [label=\"pi_1\"];\n\t            n4 [label=\"pi_2\"];\n\t            n5 [label=\"pi_2\"];\n\t            n6 [label=\"pi_2\"];\n\t            root -> G;\n\t            root -> F;\n\t            G -> n1;\n\t            G -> n2;\n\t            G -> n3;\n\t            F -> n4;\n", "            F -> n5;\n\t            F -> n6;\n\t        }\n\t    where each node is an :class:`.STLFormula` and the leaf nodes are :class:`.LinearPredicate` objects.\n\t    Each :class:`.STLTree` is defined by a list of :class:`.STLFormula` objects\n\t    (the child nodes in the tree) which are combined together using either conjunction or\n\t    disjunction.\n\t    :param subformula_list:     A list of :class:`.STLFormula` objects (formulas or\n\t                                predicates) that we'll use to construct this formula.\n\t    :param combination_type:    A string representing the type of operation we'll use\n", "                                to combine the child nodes. Must be either ``\"and\"`` or ``\"or\"``.\n\t    :param timesteps:           A list of timesteps that the subformulas must hold at.\n\t                                This is needed to define the temporal operators.\n\t    \"\"\"\n\t    def __init__(self, subformula_list, combination_type, timesteps, name=None):\n\t        # Record the dimension of the signal this formula is defined over\n\t        self.d = subformula_list[0].d\n\t        # Run some type check on the inputs\n\t        assert (combination_type == \"and\") or (combination_type == \"or\"), \"Invalid combination type\"\n\t        assert isinstance(subformula_list, list), \"subformula_list must be a list of STLTree or LinearPredicate objects\"\n", "        assert isinstance(timesteps, list), \"timesteps must be a list of integers\"\n\t        assert len(timesteps) == len(subformula_list), \"a timestep must be provided for each subformula\"\n\t        for formula in subformula_list:\n\t            assert isinstance(formula, STLFormula), \"subformula_list must be a list of STLTree or LinearPredicate objects\"\n\t            assert formula.d == self.d, \"all subformulas must be defined over same dimension of signal\"\n\t        for t in timesteps:\n\t            assert isinstance(t, int), \"each timestep must be an integer\"\n\t        # Simply save the input arguments. We will parse these recursively later on to\n\t        # determine, for example, the formula robustness.\n\t        self.subformula_list = subformula_list\n", "        self.combination_type = combination_type\n\t        self.timesteps = timesteps\n\t        # Save the given name for pretty printing\n\t        self.name=name\n\t    def negation(self):\n\t        raise NotImplementedError(\"Only formulas in positive normal form are supported at this time\")\n\t    def robustness(self, y, t, k,mode): # smoothed reversed-robustness\n\t        if self.combination_type == \"and\": \n\t            return max( [formula.robustness(y,t+self.timesteps[i],k,mode) for i, formula in enumerate(self.subformula_list)] )\n\t        else: # combination_type == \"or\"\n", "            return smoothmin(mode, k, [formula.robustness(y,t+self.timesteps[i],k,mode) for i, formula in enumerate(self.subformula_list)] )\n\t    def orig_robustness(self, y, t):\n\t        if self.combination_type == \"and\":\n\t            return min( [formula.orig_robustness(y,t+self.timesteps[i]) for i, formula in enumerate(self.subformula_list)] )\n\t        else: # combination_type == \"or\"\n\t            return max( [formula.orig_robustness(y,t+self.timesteps[i]) for i, formula in enumerate(self.subformula_list)] )\n\t    def is_predicate(self):\n\t        return False\n\t    def is_state_formula(self):\n\t        boolean_operation = all([self.timesteps[i] == self.timesteps[0] for i in range(len(self.timesteps))])\n", "        children_are_state_formulas = all([subformula.is_state_formula() for subformula in self.subformula_list])\n\t        return boolean_operation and children_are_state_formulas\n\t    def is_disjunctive_state_formula(self):\n\t        boolean_operation = all([self.timesteps[i] == self.timesteps[0] for i in range(len(self.timesteps))])\n\t        children_match = all([s.is_disjunctive_state_formula() for s in self.subformula_list])\n\t        return boolean_operation and children_match and self.combination_type == \"or\"\n\t    def is_conjunctive_state_formula(self):\n\t        boolean_operation = all([self.timesteps[i] == self.timesteps[0] for i in range(len(self.timesteps))])\n\t        children_match = all([s.is_conjunctive_state_formula() for s in self.subformula_list])\n\t        return boolean_operation and children_match and self.combination_type == \"and\"\n", "    def simplify(self):\n\t        \"\"\"\n\t        Modify this formula to reduce the depth of the formula tree while preserving\n\t        logical equivalence.\n\t        A shallower formula tree can result in a more efficient binary encoding in some\n\t        cases.\n\t        \"\"\"\n\t        mod = True\n\t        count = 0\n\t        while mod:\n", "            # Just keep trying to flatten until we don't get any improvement\n\t            mod = self.flatten(self)\n\t            count = count +1\n\t            # print(count)\n\t    def flatten(self, formula):\n\t        \"\"\"\n\t        Reduce the depth of the given :class:`STLFormula` by combining adjacent\n\t        layers with the same logical operation. This preserves the meaning of the\n\t        formula, since, for example,\n\t        ..math::\n", "            (a \\land b) \\land (c \\land d) = a \\land b \\land c \\land d\n\t        :param formula: The formula to modify\n\t        :return made_modification: boolean flag indicating whether the formula was changed.l\n\t        \"\"\"\n\t        made_modification = False\n\t        for subformula in formula.subformula_list:\n\t            if subformula.is_predicate():\n\t                pass\n\t            else:\n\t                if formula.combination_type == subformula.combination_type:\n", "                    # Remove the subformula\n\t                    i = formula.subformula_list.index(subformula)\n\t                    formula.subformula_list.pop(i)\n\t                    st = formula.timesteps.pop(i)\n\t                    # Add all the subformula's subformulas instead\n\t                    formula.subformula_list += subformula.subformula_list\n\t                    formula.timesteps += [t+st for t in subformula.timesteps]\n\t                    made_modification = True\n\t                made_modification = self.flatten(subformula) or made_modification\n\t        return made_modification\n", "    def get_all_inequalities(self):\n\t        As = []\n\t        bs = []\n\t        for subformula in self.subformula_list:\n\t            A, b = subformula.get_all_inequalities()\n\t            As.append(A)\n\t            bs.append(b)\n\t        A = np.vstack(As)\n\t        b = np.hstack(bs)\n\t        return A, b\n", "    def __str__(self):\n\t        \"\"\"\n\t        Return a string representing this formula. This string displays\n\t        the tree structure of the formula, where each node represents either\n\t        a conjuction or disjuction of subformulas, and leaves are state formulas.\n\t        \"\"\"\n\t        tree = Tree()\n\t        root = tree.create_node(self.combination_type)\n\t        for subformula in self.subformula_list:\n\t            self._add_subformula_to_tree(tree, root, subformula)\n", "        return tree.__str__()\n\t    def _add_subformula_to_tree(self, tree, root, formula):\n\t        \"\"\"\n\t        Helper function for recursively parsing subformulas to create\n\t        a Tree object for visualizing this formula.\n\t        \"\"\"\n\t        if formula.is_predicate():\n\t            tree.create_node(formula.__str__(), parent=root)\n\t        else:\n\t            new_node = tree.create_node(formula.combination_type, parent=root)\n", "            for subformula in formula.subformula_list:\n\t                self._add_subformula_to_tree(tree, new_node, subformula)\n\t    def transform2tree(self):\n\t        tree=Tree()\n\t        root = tree.create_node(self.combination_type)\n\t        for subformula in self.subformula_list:\n\t            self._add_subformula_to_tree(tree, root, subformula)\n\t        return tree\n\t    def countleaves(self):\n\t        self.count=0\n", "        self.countleaf(self,self.count)\n\t    def countleaf(self,formula,count):\n\t        for i, subformula in enumerate(formula.subformula_list):\n\t            if subformula.is_predicate():\n\t                self.count = self.count +1\n\t            else:\n\t                self.countleaf(subformula,self.count)\n\tdef flattenmat(l):\n\t    for el in l:\n\t        if isinstance(el, collections.abc.Iterable) and not isinstance(el, (str, bytes)):\n", "            yield from flattenmat(el)\n\t        else:\n\t            yield el\n\tdef smoothmin(mode,k, a):\n\t        length = len(a)\n\t        #print(a,length)\n\t        for i in range(length):\n\t            a[i] = - k * a[i]\n\t        a= np.array(list(flattenmat(a)))\n\t        if mode ==\"mellowmin\":\n", "            return - (logsumexp(a)-np.log(length)) / k\n\t        else:\n\t            return - logsumexp(a) / k\n"]}
{"filename": "STLCCP/STL/predicate.py", "chunked_list": ["import numpy as np\n\tfrom .formula import STLFormula\n\tclass NonlinearPredicate(STLFormula):\n\t    \"\"\"\n\t    A nonlinear STL predicate:math:`\\pi` defined by\n\t    .. math::\n\t        g(y_t) \\geq 0\n\t    where :math:`y_t \\in \\mathbb{R}^d` is the value of the signal\n\t    at a given timestep :math:`t`, and :math:`g : \\mathbb{R}^d \\\\to \\mathbb{R}`.\n\t    :param g:       A function mapping the signal at a given timestep to\n", "                    a scalar value.\n\t    :param d:       An integer expressing the dimension of the signal y.\n\t    :param name:    (optional) a string used to identify this predicate.\n\t    \"\"\"\n\t    def __init__(self, g, d, name=None):\n\t        self.d = d\n\t        self.name = name\n\t        self.g = g\n\t    def negation(self):\n\t        if self.name is None:\n", "            newname = None\n\t        else:\n\t            newname = \"not \" + self.name\n\t        negative_g = lambda y : -self.g(y)\n\t        return NonlinearPredicate(negative_g, self.d, name=newname)\n\t    def robustness(self, y, t,k,mode):\n\t        assert isinstance(y, np.ndarray), \"y must be a numpy array\"\n\t        assert isinstance(t, int), \"timestep t must be an integer\"\n\t        assert y.shape[0] == self.d, \"y must be of shape (d,T)\"\n\t        assert y.shape[1] > t, \"requested timestep %s, but y only has %s timesteps\" % (t, y.shape[1])\n", "        return np.array([-self.g(y[:,t])]) # minus is not needed since we reverse the formula\n\t    def orig_robustness(self, y, t):\n\t        assert isinstance(y, np.ndarray), \"y must be a numpy array\"\n\t        assert isinstance(t, int), \"timestep t must be an integer\"\n\t        assert y.shape[0] == self.d, \"y must be of shape (d,T)\"\n\t        assert y.shape[1] > t, \"requested timestep %s, but y only has %s timesteps\" % (t, y.shape[1])\n\t        return np.array([self.g(y[:,t])])\n\t    def is_predicate(self):\n\t        return True\n\t    def is_state_formula(self):\n", "        return True\n\t    def is_disjunctive_state_formula(self):\n\t        return True\n\t    def is_conjunctive_state_formula(self):\n\t        return True\n\t    def get_all_inequalities(self):\n\t        raise NotImplementedError(\"linear inequalities are not defined for nonlinear predicates\")\n\t    def __str__(self):\n\t        if self.name is None:\n\t            return \"{ Nonlinear Predicate }\"\n", "        else:\n\t            return \"{ Predicate \" + self.name + \" }\"\n\tclass LinearPredicate(STLFormula):\n\t    \"\"\"\n\t    A linear STL predicate :math:`\\pi` defined by\n\t    .. math::\n\t        a^Ty_t - b \\geq 0\n\t    where :math:`y_t \\in \\mathbb{R}^d` is the value of the signal\n\t    at a given timestep :math:`t`, :math:`a \\in \\mathbb{R}^d`,\n\t    and :math:`b \\in \\mathbb{R}`.\n", "    :param a:       a numpy array or list representing the vector :math:`a`\n\t    :param b:       a list, numpy array, or scalar representing :math:`b`\n\t    :param name:    (optional) a string used to identify this predicate.\n\t    \"\"\"\n\t    def __init__(self, a, b, name=None):\n\t        # Convert provided constraints to numpy arrays\n\t        self.a = np.asarray(a).reshape((-1,1))\n\t        self.b = np.atleast_1d(b)\n\t        # Some dimension-related sanity checks\n\t        assert (self.a.shape[1] == 1), \"a must be of shape (d,1)\"\n", "        assert (self.b.shape == (1,)), \"b must be of shape (1,)\"\n\t        # Store the dimensionality of y_t\n\t        self.d = self.a.shape[0]\n\t        # A unique string describing this predicate\n\t        self.name = name\n\t    def negation(self):\n\t        if self.name is None:\n\t            newname = None\n\t        else:\n\t            newname = \"not \" + self.name\n", "        return LinearPredicate(-self.a, -self.b, name=newname)\n\t    def robustness(self, y, t,k,mode):\n\t        assert isinstance(y, np.ndarray), \"y must be a numpy array\"\n\t        assert isinstance(t, int), \"timestep t must be an integer\"\n\t        assert y.shape[0] == self.d, \"y must be of shape (d,T)\"\n\t        assert y.shape[1] > t, \"requested timestep %s, but y only has %s timesteps\" % (t, y.shape[1])\n\t        return self.b - self.a.T@y[:,t] # since we reverse!\n\t    def orig_robustness(self, y, t):\n\t        assert isinstance(y, np.ndarray), \"y must be a numpy array\"\n\t        assert isinstance(t, int), \"timestep t must be an integer\"\n", "        assert y.shape[0] == self.d, \"y must be of shape (d,T)\"\n\t        assert y.shape[1] > t, \"requested timestep %s, but y only has %s timesteps\" % (t, y.shape[1])\n\t        return self.a.T@y[:,t] - self.b\n\t    def is_predicate(self):\n\t        return True\n\t    def is_state_formula(self):\n\t        return True\n\t    def is_disjunctive_state_formula(self):\n\t        return True\n\t    def is_conjunctive_state_formula(self):\n", "        return True\n\t    def get_all_inequalities(self):\n\t        A = -self.a.T\n\t        b = -self.b\n\t        return (A,b)\n\t    def __str__(self):\n\t        if self.name is None:\n\t            return \"{ Predicate %s*y >= %s }\" % (self.a, self.b)\n\t            #return \"Predicate\"\n\t        else:\n", "            return \"{ Predicate \" + self.name + \" }\"\n"]}
{"filename": "STLCCP/STL/__init__.py", "chunked_list": ["from .formula import STLTree, STLFormula\n\tfrom .predicate import LinearPredicate, NonlinearPredicate\n"]}
{"filename": "examples/either_or.py", "chunked_list": ["#!/usr/bin/env python\n\timport cvxpy\n\timport csv\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\tfrom STLCCP.benchmarks import EitherOr\n\tfrom STLCCP.solver import *\n\timport matplotlib.patches as mpatches\n\tfrom typing import Tuple\n\timport time\n", "import os\n\tpath = \"./fig_either\"\n\tos.makedirs(path, exist_ok=True)\n\t# Specification Parameters\n\tgoal = (7,8,8,9)     # (xmin, xmax, ymin, ymax)\n\ttarget_one = (1,2,6,7)\n\ttarget_two = (7,8,4.5,5.5)\n\tobstacle = (3,5,4,6)\n\tdwell_time = 5\n\tfor i in range(1):\n", "    T = i * 25 + 50\n\t    # Create the specification and system\n\t    scenario = EitherOr(goal, target_one, target_two, obstacle, T, dwell_time)\n\t    spec = scenario.GetSpecification()\n\t    sys = scenario.GetSystem()\n\t    # Simplification of the robustness\n\t    spec.transform2tree().to_graphviz(path+\"/notsimplify_either\")\n\t    spec.simplify()\n\t    spec.transform2tree().to_graphviz(path+\"/simplify_either\")\n\t    # Specify any additional running cost\n", "    quad = 1e-3\n\t    Q = quad*np.diag([0,0,1,1])   # just penalize high velocities\n\t    R = quad*np.eye(2)\n\t    # Initial state\n\t    x0 = np.array([2.0,2.0,0.0,0.0])\n\t    # Set bounds on state and control variables\n\t    u_min = np.array([-0.2,-0.2])\n\t    u_max = np.array([0.2, 0.2])\n\t    x_min = np.array([0.0, 0.0, -1.0, -1.0])\n\t    x_max = np.array([10.0, 10.0, 1.0, 1.0])\n", "    # the parameter below determines how many samples we collect with random initial values on variables.\n\t    ccp_times = 1\n\t    for j in range(ccp_times):  \n\t        initial_guess = None\n\t        status = None \n\t        solve_alltime = 0.0\n\t        # the parameter below determines determines which of lse, mellowmin with lse warm startn, etc. to select \n\t        # please see Section 7-F of our journal paper. \n\t        warmstart = 0\n\t        # Set \"warmstart = 0\" if you want to just solve \"lse\" smoothed program.\n", "        # Set \"warmstart = 1\" if you want to use \"mellowmin smoothed program with a warm-start solution of lse\" smoothed program (lse->mellwmin)\".\n\t        # \"warmstart >= 2\" means (lse->mellwmin->lse->...). \n\t        for l in range(warmstart+1):\n\t            if l % 2 == 0:\n\t                mode = \"lse\"\n\t                tempk=10.0\n\t            else:\n\t                mode = \"mellowmin\"\n\t                tempk=1000.0\n\t            solver = CCPSTLSolver(spec, sys, x0, T, k=tempk, mode=mode, verbose=True) \n", "            # Add bounds\n\t            solver.AddControlBounds(u_min, u_max)\n\t            solver.AddStateBounds(x_min, x_max)\n\t            # Add quadratic running cost (optional)\n\t            solver.AddQuadraticCost(Q,R)\n\t            # Solve the optimization problem\n\t            # weight parameter (default is \"tree\")\n\t                # \"tree\": tree weighted penalty\n\t                # \"decay\": tree weighted penalty with deacay\n\t                # \"50\", \"smallest\": penalize equally using the weight 50 or the smallest number of child nodes\n", "            x, u,y, rho_orig,solve_time,initial_guess,status = solver.Solve(initial_guess=initial_guess, weight=\"tree\")\n\t            solve_alltime += solve_time\n\t            # Csv data\n\t            base = os.path.join(path, str(T)+ \"quad\" + str(quad))\n\t            csvfile = os.path.join(base + \".csv\")\n\t            array = []\n\t            array.extend([solve_alltime, rho_orig, T, tempk])\n\t            arr = np.array(array)\n\t            with open(csvfile,\"a\") as f:\n\t                    np.savetxt(f, [arr], delimiter=\",\",fmt=\"%.5f\")\n", "        # Plot the solution\n\t        filename = os.path.join(base + \".pdf\") \n\t        if (x is not None) and (rho_orig>0):\n\t            for t in range(T+1):\n\t                plt.scatter(x[0,t].value,x[1,t].value, c=\"b\")\n\t                if t!=T:\n\t                    left = np.array([x[0,t].value,x[0,t+1].value])\n\t                    height = np.array([x[1,t].value,x[1,t+1].value])\n\t                    plt.plot(left, height, c=\"royalblue\")\n\t        plt.savefig(filename)\n", "    ax = plt.gca()\n\t    scenario.add_to_plot(ax)\n\t    plt.savefig(filename)\n\tplt.show()"]}
{"filename": "examples/door_puzzle.py", "chunked_list": ["#!/usr/bin/env python\n\timport cvxpy\n\timport csv\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\tfrom STLCCP.benchmarks import DoorPuzzle\n\tfrom STLCCP.solver import *\n\tfrom treelib import Tree\n\timport matplotlib.patches as mpatches\n\tfrom typing import Tuple\n", "import time\n\timport os\n\tpath = \"./fig_door\"\n\tos.makedirs(path, exist_ok=True)\n\t# Specification parameters\n\tN_pairs = 2\n\t# Run with different horizon settings\n\tfor i in range(1):\n\t    T = i * 25 + 50\n\t    # Create the specification and system\n", "    scenario = DoorPuzzle(T, N_pairs)\n\t    spec = scenario.GetSpecification()\n\t    sys = scenario.GetSystem()\n\t    # Simplification of the robustness\n\t    spec.transform2tree().to_graphviz(path+\"/notsimplify_door\")\n\t    spec.simplify()\n\t    spec.transform2tree().to_graphviz(path+\"/simplify_door\")\n\t    # Specify any additional running cost \n\t    quad = 1e-2\n\t    Q = quad*np.diag([0,0,1,1])   # just penalize high velocities\n", "    R = quad*np.eye(2)\n\t    # Initial state\n\t    x0 = np.array([6.0,1.0,0,0])\n\t    # Set bounds on state and control variables\n\t    u_min = np.array([-0.5,-0.5])\n\t    u_max = np.array([0.5, 0.5])\n\t    x_min = np.array([0., 0., -2.0, -2.0])\n\t    x_max = np.array([15., 10., 2.0, 2.0])\n\t    # the parameter below determines how many samples we collect with random initial values on variables.\n\t    ccp_times = 1\n", "    for j in range(ccp_times): \n\t        initial_guess = None\n\t        status = None \n\t        solve_alltime = 0.0\n\t        # the parameter below determines determines which of lse, mellowmin with lse warm startn, etc. to select \n\t        # please see Section 7-F of our journal paper. \n\t        warmstart = 0\n\t        # Set \"warmstart = 0\" if you want to just solve \"lse\" smoothed program.\n\t        # Set \"warmstart = 1\" if you want to use \"mellowmin smoothed program with a warm-start solution of lse\" smoothed program (lse->mellwmin)\".\n\t        # \"warmstart >= 2\" means (lse->mellwmin->lse->...). \n", "        for l in range(warmstart+1):\n\t            if l % 2 == 0:\n\t                mode = \"lse\"\n\t                tempk=10.0\n\t            else:\n\t                mode = \"mellowmin\"\n\t                tempk=1000.0\n\t            solver = CCPSTLSolver(spec, sys, x0, T, k=tempk, mode=mode, verbose=True) \n\t            # Add bounds\n\t            solver.AddControlBounds(u_min, u_max)\n", "            solver.AddStateBounds(x_min, x_max)\n\t            # Add quadratic running cost (optional)\n\t            solver.AddQuadraticCost(Q,R)\n\t            # Solve the optimization problem\n\t            # weight parameter (default is \"tree\")\n\t                # \"tree\": tree weighted penalty\n\t                # \"decay\": tree weighted penalty with deacay\n\t                # \"50\", \"smallest\": penalize equally using the weight 50 or the smallest number of child nodes\n\t            x, u,y, rho_orig,solve_time,initial_guess,status = solver.Solve(initial_guess=initial_guess, weight=\"tree\")\n\t            solve_alltime += solve_time\n", "            # Csv data\n\t            base = os.path.join(path, str(T)+ \"quad\" + str(quad))\n\t            csvfile = os.path.join(base + \".csv\")\n\t            array = []\n\t            array.extend([solve_alltime, rho_orig, T, tempk])\n\t            arr = np.array(array)\n\t            with open(csvfile,\"a\") as f:\n\t                    np.savetxt(f, [arr], delimiter=\",\",fmt=\"%.5f\")\n\t        # Plot the solution\n\t        filename = os.path.join(base + \".pdf\") \n", "        if (x is not None) and (rho_orig>0):\n\t            for t in range(T+1):\n\t                plt.scatter(x[0,t].value,x[1,t].value, c=\"b\")\n\t                if t!=T:\n\t                    left = np.array([x[0,t].value,x[0,t+1].value])\n\t                    height = np.array([x[1,t].value,x[1,t+1].value])\n\t                    plt.plot(left, height, c=\"royalblue\")\n\t        plt.savefig(filename)\n\t    ax = plt.gca()\n\t    scenario.add_to_plot(ax)\n", "    plt.savefig(filename)\n\tplt.show()"]}
{"filename": "examples/narrow_passage.py", "chunked_list": ["#!/usr/bin/env python\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\tfrom STLCCP.benchmarks import NarrowPassage\n\tfrom STLCCP.solver import *\n\timport cvxpy\n\timport matplotlib.patches as mpatches\n\tfrom typing import Tuple\n\timport time\n\timport csv\n", "import os\n\tpath = \"./fig_narrow\"\n\tos.makedirs(path, exist_ok=True)\n\tfor i in range(1):\n\t    T = i * 25 + 50\n\t    # Create the specification and define the dynamics\n\t    scenario = NarrowPassage(T)\n\t    sys = scenario.GetSystem()\n\t    spec = scenario.GetSpecification()\n\t    spec.transform2tree().to_graphviz(path+\"/notsimplify_narrow\")\n", "    spec.simplify()\n\t    spec.transform2tree().to_graphviz(path+\"/simplify_narrow\")\n\t    # Specify any additional running cost (this helps the numerics in\n\t    # a gradient-based method)\n\t    quad = 1e-3\n\t    Q = quad*np.diag([0,0,1,1])   # just penalize high velocities\n\t    R = quad*np.eye(2)\n\t    # Initial state\n\t    x0 = np.array([3.0,3.6,0,0])\n\t    # Set bounds on state and control variables\n", "    u_min = np.array([-0.2,-0.2])\n\t    u_max = np.array([0.2, 0.2])\n\t    x_min = np.array([0.0, 0.0, -1.0, -1.0])\n\t    x_max = np.array([10.0, 10.0, 1.0, 1.0])\n\t   # the parameter below determines how many samples we collect with random initial values on variables.\n\t    ccp_times = 1\n\t    for j in range(ccp_times):  \n\t        initial_guess = None\n\t        status = None \n\t        solve_alltime = 0.0\n", "        # the parameter below determines determines which of lse, mellowmin with lse warm startn, etc. to select \n\t        # please see Section 7-F of our journal paper. \n\t        warmstart = 0\n\t        # Set \"warmstart = 0\" if you want to just solve \"lse\" smoothed program.\n\t        # Set \"warmstart = 1\" if you want to use \"mellowmin smoothed program with a warm-start solution of lse\" smoothed program (lse->mellwmin)\".\n\t        # \"warmstart >= 2\" means (lse->mellwmin->lse->...). \n\t        for l in range(warmstart+1):\n\t            if l % 2 == 0:\n\t                mode = \"lse\"\n\t                tempk=10.0\n", "            else:\n\t                mode = \"mellowmin\"\n\t                tempk=1000.0\n\t            solver = CCPSTLSolver(spec, sys, x0, T, k=tempk, mode=mode, verbose=True) \n\t            # Add bounds\n\t            solver.AddControlBounds(u_min, u_max)\n\t            solver.AddStateBounds(x_min, x_max)\n\t            # Add quadratic running cost (optional)\n\t            solver.AddQuadraticCost(Q,R)\n\t            # Solve the optimization problem\n", "            # weight parameter (default is \"tree\")\n\t                # \"tree\": tree weighted penalty\n\t                # \"decay\": tree weighted penalty with deacay\n\t                # \"50\", \"smallest\": penalize equally using the weight 50 or the smallest number of child nodes\n\t            x, u,y, rho_orig,solve_time,initial_guess,status = solver.Solve(initial_guess=initial_guess, weight=\"tree\")\n\t            solve_alltime += solve_time\n\t            # Csv data\n\t            base = os.path.join(path, str(T)+ \"quad\" + str(quad))\n\t            csvfile = os.path.join(base + \".csv\")\n\t            array = []\n", "            array.extend([solve_alltime, rho_orig, T, tempk])\n\t            arr = np.array(array)\n\t            with open(csvfile,\"a\") as f:\n\t                    np.savetxt(f, [arr], delimiter=\",\",fmt=\"%.5f\")\n\t        # Plot the solution\n\t        filename = os.path.join(base + \".pdf\") \n\t        if (x is not None) and (rho_orig>0):\n\t            for t in range(T+1):\n\t                plt.scatter(x[0,t].value,x[1,t].value, c=\"b\")\n\t                if t!=T:\n", "                    left = np.array([x[0,t].value,x[0,t+1].value])\n\t                    height = np.array([x[1,t].value,x[1,t+1].value])\n\t                    plt.plot(left, height, c=\"royalblue\")\n\t        plt.savefig(filename)\n\t    ax = plt.gca()\n\t    scenario.add_to_plot(ax)\n\t    plt.savefig(filename)\n\tplt.show()\n"]}
{"filename": "examples/reach_avoid.py", "chunked_list": ["#!/usr/bin/env python\n\timport csv\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\tfrom treelib import Tree\n\tfrom STLCCP.benchmarks import ReachAvoid\n\tfrom STLCCP.solver import *\n\timport cvxpy\n\timport matplotlib.patches as mpatches\n\tfrom typing import Tuple\n", "import time\n\timport os\n\tpath = \"./fig_reach\"\n\tos.makedirs(path, exist_ok=True)\n\t# Specification Parameters\n\tgoal_bounds = (7,8,8,9)     # (xmin, xmax, ymin, ymax)\n\tobstacle_bounds = (3,5,4,6)\n\tfor i in range(1):\n\t    T = i * 25 + 50\n\t    # Define the specification and system dynamics\n", "    scenario = ReachAvoid(goal_bounds, obstacle_bounds, T)\n\t    sys = scenario.GetSystem()\n\t    spec = scenario.GetSpecification()\n\t    spec.transform2tree().to_graphviz(path+\"/notsimplify_reachavoid\")\n\t    spec.simplify()\n\t    spec.transform2tree().to_graphviz(path+\"/simplify_reachavoid\")\n\t    # Specify any additional running cost\n\t    quad = 1e-3\n\t    Q = quad*np.diag([0,0,1,1])   # just penalize high velocities\n\t    R = quad*np.eye(2)\n", "    # Initial state\n\t    x0 = np.array([1.0,2.0,0.0,0])\n\t    # Set bounds on state and control variables\n\t    u_min = np.array([-0.5,-0.5])\n\t    u_max = np.array([0.5, 0.5])\n\t    x_min = np.array([0.0, 0.0, -1.0, -1.0])\n\t    x_max = np.array([10.0, 10.0, 1.0, 1.0])\n\t    # the parameter below determines how many samples we collect with random initial values on variables.\n\t    ccp_times = 1\n\t    for j in range(ccp_times): \n", "        initial_guess = None\n\t        status = None \n\t        solve_alltime = 0.0\n\t        # the parameter below determines determines which of lse, mellowmin with lse warm startn, etc. to select \n\t        # please see Section 7-F of our journal paper. \n\t        warmstart = 0\n\t        # Set \"warmstart = 0\" if you want to just solve \"lse\" smoothed program.\n\t        # Set \"warmstart = 1\" if you want to use \"mellowmin smoothed program with a warm-start solution of lse\" smoothed program (lse->mellwmin)\".\n\t        # \"warmstart >= 2\" means (lse->mellwmin->lse->...). \n\t        for l in range(warmstart+1):\n", "            if l % 2 == 0:\n\t                mode = \"lse\"\n\t                tempk=10.0\n\t            else:\n\t                mode = \"mellowmin\"\n\t                tempk=1000.0\n\t            solver = CCPSTLSolver(spec, sys, x0, T, k=tempk, mode=mode, verbose=True) \n\t            # Add bounds\n\t            solver.AddControlBounds(u_min, u_max)\n\t            solver.AddStateBounds(x_min, x_max)\n", "            # Add quadratic running cost (optional)\n\t            solver.AddQuadraticCost(Q,R)\n\t            # Solve the optimization problem\n\t            # weight parameter (default is \"tree\")\n\t                # \"tree\": tree weighted penalty\n\t                # \"decay\": tree weighted penalty with deacay\n\t                # \"50\", \"smallest\": penalize equally using the weight 50 or the smallest number of child nodes\n\t            x, u,y, rho_orig,solve_time,initial_guess,status = solver.Solve(initial_guess=initial_guess, weight=\"tree\")\n\t            solve_alltime += solve_time\n\t            # Csv data\n", "            base = os.path.join(path, str(T)+ \"quad\" + str(quad))\n\t            csvfile = os.path.join(base + \".csv\")\n\t            array = []\n\t            array.extend([solve_alltime, rho_orig, T, tempk])\n\t            arr = np.array(array)\n\t            with open(csvfile,\"a\") as f:\n\t                    np.savetxt(f, [arr], delimiter=\",\",fmt=\"%.5f\")\n\t        # Plot the solution\n\t        filename = os.path.join(base + \".pdf\") \n\t        if (x is not None) and (rho_orig>0):\n", "            for t in range(T+1):\n\t                plt.scatter(x[0,t].value,x[1,t].value, c=\"b\")\n\t                if t!=T:\n\t                    left = np.array([x[0,t].value,x[0,t+1].value])\n\t                    height = np.array([x[1,t].value,x[1,t+1].value])\n\t                    plt.plot(left, height, c=\"royalblue\")\n\t        plt.savefig(filename)\n\t    ax = plt.gca()\n\t    scenario.add_to_plot(ax)\n\t    plt.savefig(filename)\n", "plt.show()"]}
{"filename": "examples/stepping_stones.py", "chunked_list": ["#!/usr/bin/env python\n\t##\n\t#\n\t# Set up, solve, and plot the solution for a reachability\n\t# problem where the robot must navigate over a stepping\n\t# stones in order to reach a goal.\n\t#\n\t##\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n", "from STLCCP.benchmarks import SteppingStones\n\tfrom STLCCP.solver import *\n\timport cvxpy\n\timport matplotlib.patches as mpatches\n\tfrom typing import Tuple\n\timport time\n\timport csv\n\timport os\n\tpath = \"./fig_stone\"\n\tos.makedirs(path, exist_ok=True)\n", "# Specification Parameters\n\tnum_stones = 10\n\tfor i in range(1):\n\t    T = i * 25 + 25\n\t    # Define the specification and system dynamics\n\t    scenario = SteppingStones(num_stones, T, seed=1)\n\t    spec = scenario.GetSpecification()\n\t    spec.transform2tree().to_graphviz(path+\"/notsimplify_narrow\")\n\t    spec.simplify()\n\t    spec.transform2tree().to_graphviz(path+\"/simplify_narrow\")\n", "    sys = scenario.GetSystem()\n\t    # Specify any additional running cost (this helps the numerics in\n\t    # a gradient-based method)\n\t    quad = 1e-2\n\t    Q = quad*np.diag([0,0,1,1])   # just penalize high velocities\n\t    R = quad*np.eye(2)\n\t    # Initial state\n\t    x0 = np.array([2.0,1.3,0,0])\n\t    # Set bounds on state and control variables\n\t    u_min = np.array([-0.5,-0.5])\n", "    u_max = np.array([0.5, 0.5])\n\t    x_min = np.array([0.0, 0.0, -1.0, -1.0])\n\t    x_max = np.array([10.0, 10.0, 1.0, 1.0])\n\t   # the parameter below determines how many samples we collect with random initial values on variables.\n\t    ccp_times = 2\n\t    for j in range(ccp_times): \n\t        initial_guess = None\n\t        status = None \n\t        solve_alltime = 0.0\n\t        # the parameter below determines determines which of lse, mellowmin with lse warm startn, etc. to select \n", "        # please see Section 7-F of our journal paper. \n\t        warmstart = 0\n\t        # Set \"warmstart = 0\" if you want to just solve \"lse\" smoothed program.\n\t        # Set \"warmstart = 1\" if you want to use \"mellowmin smoothed program with a warm-start solution of lse\" smoothed program (lse->mellwmin)\".\n\t        # \"warmstart >= 2\" means (lse->mellwmin->lse->...). \n\t        for l in range(warmstart+1):\n\t            if l % 2 == 0:\n\t                mode = \"lse\"\n\t                tempk=10.0\n\t            else:\n", "                mode = \"mellowmin\"\n\t                tempk=1000.0\n\t            solver = CCPSTLSolver(spec, sys, x0, T, k=tempk, mode=mode, verbose=True) \n\t            # Add bounds\n\t            solver.AddControlBounds(u_min, u_max)\n\t            solver.AddStateBounds(x_min, x_max)\n\t            # Add quadratic running cost (optional)\n\t            solver.AddQuadraticCost(Q,R)\n\t            # Solve the optimization problem\n\t            # weight parameter (default is \"tree\")\n", "                # \"tree\": tree weighted penalty\n\t                # \"decay\": tree weighted penalty with deacay\n\t                # \"50\", \"smallest\": penalize equally using the weight 50 or the smallest number of child nodes\n\t            x, u,y, rho_orig,solve_time,initial_guess,status = solver.Solve(initial_guess=initial_guess, weight=\"tree\")\n\t            solve_alltime += solve_time\n\t            # Csv data\n\t            base = os.path.join(path, str(T)+ \"quad\" + str(quad))\n\t            csvfile = os.path.join(base + \".csv\")\n\t            array = []\n\t            array.extend([solve_alltime, rho_orig, T, tempk])\n", "            arr = np.array(array)\n\t            with open(csvfile,\"a\") as f:\n\t                    np.savetxt(f, [arr], delimiter=\",\",fmt=\"%.5f\")\n\t        # Plot the solution\n\t        filename = os.path.join(base + \".pdf\") \n\t        if (x is not None): # and (rho_orig>0):\n\t            for t in range(T+1):\n\t                plt.scatter(x[0,t].value,x[1,t].value, c=\"b\")\n\t                if t!=T:\n\t                    left = np.array([x[0,t].value,x[0,t+1].value])\n", "                    height = np.array([x[1,t].value,x[1,t+1].value])\n\t                    plt.plot(left, height, c=\"royalblue\")\n\t        plt.savefig(filename)\n\t    ax = plt.gca()\n\t    scenario.add_to_plot(ax)\n\t    plt.savefig(filename)\n\tplt.show()"]}
{"filename": "examples/many_target.py", "chunked_list": ["#!/usr/bin/env python\n\timport csv\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\tfrom STLCCP.benchmarks import RandomMultitarget\n\tfrom STLCCP.solver import *\n\timport matplotlib.patches as mpatches\n\tfrom typing import Tuple\n\timport time\n\timport os\n", "path = \"./fig_many\"\n\tos.makedirs(path, exist_ok=True)\n\t# Specification parameters\n\tnum_obstacles = 1\n\tnum_groups = 5\n\ttargets_per_group = 2\n\tfor i in range(1):\n\t    T = i * 25 + 100\n\t    # Define the specification and system dynamics\n\t    scenario = RandomMultitarget(\n", "            num_obstacles, num_groups, targets_per_group, T, seed=0)\n\t    sys = scenario.GetSystem()\n\t    spec = scenario.GetSpecification()\n\t    spec.transform2tree().to_graphviz(path+\"/notsimplify_many\")\n\t    spec.simplify()\n\t    spec.transform2tree().to_graphviz(path+\"/simplify_many\")\n\t    # Specify any additional running cost (this helps the numerics in\n\t    # a gradient-based method)\n\t    quad = 1e-3\n\t    Q = quad*np.diag([0,0,1,1])   # just penalize high velocities\n", "    R = quad*np.eye(2)\n\t    # Initial state\n\t    x0 = np.array([5.0,2.0, 0.0,0.0])\n\t    # Set bounds on state and control variables\n\t    u_min = np.array([-0.2,-0.2])\n\t    u_max = np.array([0.2, 0.2])\n\t    x_min = np.array([0.0, 0.0, -1.0, -1.0])\n\t    x_max = np.array([10.0, 10.0, 1.0, 1.0])\n\t    # the parameter below determines how many samples we collect with random initial values on variables.\n\t    ccp_times = 5\n", "    for j in range(ccp_times): \n\t        initial_guess = None\n\t        status = None \n\t        solve_alltime = 0.0\n\t        # the parameter below determines determines which of lse, mellowmin with lse warm startn, etc. to select \n\t        # please see Section 7-F of our journal paper. \n\t        warmstart = 0\n\t        # Set \"warmstart = 0\" if you want to just solve \"lse\" smoothed program.\n\t        # Set \"warmstart = 1\" if you want to use \"mellowmin smoothed program with a warm-start solution of lse\" smoothed program (lse->mellwmin)\".\n\t        # \"warmstart >= 2\" means (lse->mellwmin->lse->...). \n", "        for l in range(warmstart+1):\n\t            if l % 2 == 0:\n\t                mode = \"lse\"\n\t                tempk=10.0\n\t            else:\n\t                mode = \"mellowmin\"\n\t                tempk=1000.0\n\t            solver = CCPSTLSolver(spec, sys, x0, T, k=tempk, mode=mode, verbose=True) \n\t            # Add bounds\n\t            solver.AddControlBounds(u_min, u_max)\n", "            solver.AddStateBounds(x_min, x_max)\n\t            # Add quadratic running cost (optional)\n\t            solver.AddQuadraticCost(Q,R)\n\t            # Solve the optimization problem\n\t            # weight parameter (default is \"tree\")\n\t                # \"tree\": tree weighted penalty\n\t                # \"decay\": tree weighted penalty with deacay\n\t                # \"50\", \"smallest\": penalize equally using the weight 50 or the smallest number of child nodes\n\t            x, u,y, rho_orig,solve_time,initial_guess,status = solver.Solve(initial_guess=initial_guess, weight=\"tree\")\n\t            solve_alltime += solve_time\n", "            # Csv data\n\t            base = os.path.join(path, str(T)+ \"quad\" + str(quad))\n\t            csvfile = os.path.join(base + \".csv\")\n\t            array = []\n\t            array.extend([solve_alltime, rho_orig, T, tempk])\n\t            arr = np.array(array)\n\t            with open(csvfile,\"a\") as f:\n\t                    np.savetxt(f, [arr], delimiter=\",\",fmt=\"%.5f\")\n\t        # Plot the solution\n\t        filename = os.path.join(base + \".pdf\") \n", "        if (x is not None) and (rho_orig>0):\n\t            for t in range(T+1):\n\t                plt.scatter(x[0,t].value,x[1,t].value, c=\"b\")\n\t                if t!=T:\n\t                    left = np.array([x[0,t].value,x[0,t+1].value])\n\t                    height = np.array([x[1,t].value,x[1,t+1].value])\n\t                    plt.plot(left, height, c=\"royalblue\")\n\t        plt.savefig(filename)\n\t    ax = plt.gca()\n\t    scenario.add_to_plot(ax)\n", "    plt.savefig(filename)\n\tplt.show()\n"]}
