{"filename": "zxlive/graphview.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\tfrom typing import Optional\n\timport math\n\timport random\n\tfrom PySide6.QtCore import QRect, QSize, QPointF, Signal, Qt, QRectF, QLineF, QTimeLine\n\tfrom PySide6.QtWidgets import QGraphicsView, QGraphicsPathItem, QRubberBand, QGraphicsEllipseItem, QGraphicsItem\n\tfrom PySide6.QtGui import QPen, QColor, QPainter, QPainterPath, QTransform, QMouseEvent, QWheelEvent, QBrush, QShortcut, QKeySequence\n\tfrom .graphscene import GraphScene, VItem, EItem\n", "from dataclasses import dataclass\n\tfrom .common import  GraphT, SCALE, OFFSET_X, OFFSET_Y, MIN_ZOOM, MAX_ZOOM\n\tfrom .vitem import PHASE_ITEM_Z\n\tfrom . import animations as anims\n\tclass GraphTool:\n\t    Selection = 1\n\t    MagicWand = 2\n\t@dataclass\n\tclass WandTrace:\n\t    start: QPointF\n", "    end: QPointF\n\t    hit: dict[VItem | EItem, list[QPointF]]\n\t    def __init__(self, start: QPointF) -> None:\n\t        self.start = start\n\t        self.hit = {}\n\t        self.end = start\n\tWAND_COLOR = \"#500050\"\n\tWAND_WIDTH = 3.0\n\tZOOMFACTOR = 0.002 # Specifies how sensitive zooming with the mousewheel is\n\tGRID_SCALE = SCALE / 2\n", "class GraphView(QGraphicsView):\n\t    \"\"\"QtWidget containing a graph\n\t    This widget is view associated with a graph. However, most of the\n\t    interesting stuff happens in `GraphScene`.\n\t    \"\"\"\n\t    wand_trace_finished = Signal(object)\n\t    def __init__(self, graph_scene: GraphScene) -> None:\n\t        self.graph_scene = graph_scene\n\t        self.tool = GraphTool.Selection\n\t        super().__init__(self.graph_scene)\n", "        self.setMouseTracking(True)\n\t        self.setRenderHint(QPainter.RenderHint.Antialiasing)\n\t        # self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorViewCenter)\n\t        self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)\n\t        #self.setDragMode(QGraphicsView.DragMode.ScrollHandDrag) # This has to be enabled based on keyboard shortcuts\n\t        # We implement the rubberband logic ourselves. Note that there is also\n\t        # the option to set `self.setDragMode(QGraphicsView.RubberBandDrag)`,\n\t        # but that doesn't seem to play nicely with selection in the GraphScene,\n\t        # presumably because it uses the coordinate system from this QGraphicsView\n\t        # and not the one from the GraphScene...\n", "        self.rubberband = QRubberBand(QRubberBand.Shape.Rectangle, self)\n\t        self.wand_trace: Optional[WandTrace] = None\n\t        self.wand_path: Optional[QGraphicsPathItem] = None\n\t        self.centerOn(OFFSET_X,OFFSET_Y)\n\t        self.sparkle_mode = False\n\t        QShortcut(QKeySequence(\"Ctrl+Shift+Alt+S\"), self).activated.connect(self._toggle_sparkles)\n\t    def _toggle_sparkles(self) -> None:\n\t        self.sparkle_mode = not self.sparkle_mode\n\t    def set_graph(self, g: GraphT) -> None:\n\t        self.graph_scene.set_graph(g)\n", "    def update_graph(self, g: GraphT, select_new: bool = False) -> None:\n\t        self.graph_scene.update_graph(g, select_new)\n\t    def mousePressEvent(self, e: QMouseEvent) -> None:\n\t        if self.tool == GraphTool.Selection and Qt.KeyboardModifier.ShiftModifier & e.modifiers():\n\t            e.setModifiers(e.modifiers() | Qt.KeyboardModifier.ControlModifier)\n\t        super().mousePressEvent(e)\n\t        if e.button() == Qt.MouseButton.LeftButton and not self.graph_scene.items(self.mapToScene(e.pos()), deviceTransform=QTransform()):\n\t            if self.tool == GraphTool.Selection:\n\t                self._rubberband_start = e.pos()\n\t                self.rubberband.setGeometry(QRect(self._rubberband_start, QSize()))\n", "                self.rubberband.show()\n\t            elif self.tool == GraphTool.MagicWand:\n\t                pos = self.mapToScene(e.pos())\n\t                self.wand_trace = WandTrace(pos)\n\t                self.wand_path = QGraphicsPathItem()\n\t                self.graph_scene.addItem(self.wand_path)\n\t                pen = QPen(QColor(WAND_COLOR), WAND_WIDTH)\n\t                self.wand_path.setPen(pen)\n\t                path = QPainterPath()\n\t                path.moveTo(pos)\n", "                self.wand_path.setPath(path)\n\t                self.wand_path.show()\n\t                if self.sparkle_mode:\n\t                    self._emit_sparkles(pos, 10)\n\t        else:\n\t            e.ignore()\n\t    def mouseMoveEvent(self, e: QMouseEvent) -> None:\n\t        super().mouseMoveEvent(e)\n\t        if self.tool == GraphTool.Selection:\n\t            if self.rubberband.isVisible():\n", "                self.rubberband.setGeometry(QRect(self._rubberband_start, e.pos()).normalized())\n\t        elif self.tool == GraphTool.MagicWand:\n\t            if self.wand_trace is not None:\n\t                assert self.wand_path is not None\n\t                pos = self.mapToScene(e.pos())\n\t                prev = self.wand_trace.end\n\t                self.wand_trace.end = pos\n\t                path = self.wand_path.path()\n\t                path.lineTo(pos)\n\t                self.wand_path.setPath(path)\n", "                for i in range(10):\n\t                    t = i / 9\n\t                    ipos = QPointF(pos * t + prev * (1.0 - t))\n\t                    if self.sparkle_mode:\n\t                        self._emit_sparkles(ipos, 1)\n\t                    items = self.graph_scene.items(ipos)\n\t                    for item in items:\n\t                        if isinstance(item, VItem) and item not in self.wand_trace.hit:\n\t                            anims.anticipate_fuse(item)\n\t                        if item is not self.wand_path and isinstance(item, (VItem, EItem)):\n", "                            if item not in self.wand_trace.hit:\n\t                                self.wand_trace.hit[item] = []\n\t                            self.wand_trace.hit[item].append(ipos)\n\t        else:\n\t            e.ignore()\n\t    def mouseReleaseEvent(self, e: QMouseEvent) -> None:\n\t        if self.tool == GraphTool.Selection and Qt.KeyboardModifier.ShiftModifier & e.modifiers():\n\t            e.setModifiers(e.modifiers() | Qt.KeyboardModifier.ControlModifier)\n\t        super().mouseReleaseEvent(e)\n\t        if e.button() == Qt.MouseButton.LeftButton:\n", "            if self.tool == GraphTool.Selection:\n\t                if self.rubberband.isVisible():\n\t                    self.rubberband.hide()\n\t                    key_modifiers = e.modifiers()\n\t                    if not(Qt.KeyboardModifier.ShiftModifier & key_modifiers or Qt.KeyboardModifier.ControlModifier & key_modifiers):\n\t                        self.graph_scene.clearSelection()\n\t                    rect = self.rubberband.geometry()\n\t                    items = [it for it in self.graph_scene.items(self.mapToScene(rect).boundingRect()) if isinstance(it, VItem)]\n\t                    for it in items:\n\t                        it.setSelected(not (len(items) == 1 or e.modifiers() & Qt.KeyboardModifier.ShiftModifier) or not it.isSelected())\n", "            elif self.tool == GraphTool.MagicWand:\n\t                if self.wand_trace is not None:\n\t                    assert self.wand_path is not None\n\t                    for item in self.wand_trace.hit:\n\t                        if isinstance(item, VItem):\n\t                            anims.back_to_default(item)\n\t                    self.wand_path.hide()\n\t                    self.graph_scene.removeItem(self.wand_path)\n\t                    self.wand_path = None\n\t                    self.wand_trace_finished.emit(self.wand_trace)\n", "                    self.wand_trace = None\n\t        else:\n\t            e.ignore()\n\t    def wheelEvent(self, event: QWheelEvent) -> None:\n\t        # This event captures mousewheel scrolls\n\t        # We do this to allow for zooming\n\t        # If control is pressed, we want to zoom\n\t        if event.modifiers() == Qt.KeyboardModifier.ControlModifier:\n\t            ydelta = event.angleDelta().y()\n\t            self.zoom(ydelta)\n", "        else:\n\t            super().wheelEvent(event)\n\t    def zoom(self, ydelta: float) -> None:\n\t        # Set Anchors\n\t        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.NoAnchor)\n\t        self.setResizeAnchor(QGraphicsView.ViewportAnchor.NoAnchor)\n\t        # Save the scene pos\n\t        old_pos = self.mapToScene(self.viewport().rect().center())\n\t        zoom_factor = 1.0\n\t        if ydelta > 0:\n", "            zoom_factor = 1 + ZOOMFACTOR * ydelta\n\t        elif ydelta < 0:\n\t            zoom_factor = 1/(1 - ZOOMFACTOR * ydelta)\n\t        current_zoom = self.transform().m11()\n\t        if current_zoom * zoom_factor < MIN_ZOOM:\n\t            return\n\t        elif current_zoom * zoom_factor > MAX_ZOOM:\n\t            return\n\t        self.scale(zoom_factor, zoom_factor)\n\t        # Get the new position\n", "        new_pos = self.mapToScene(self.viewport().rect().center())\n\t        # Move scene to old position\n\t        delta = new_pos - old_pos\n\t        self.translate(delta.x(), delta.y())\n\t    def zoom_out(self) -> None:\n\t        self.zoom(-100)\n\t    def zoom_in(self) -> None:\n\t        self.zoom(100)\n\t    def fit_view(self) -> None:\n\t        self.fitInView(self.graph_scene.itemsBoundingRect(), Qt.AspectRatioMode.KeepAspectRatio)\n", "        current_zoom = self.transform().m11()\n\t        print(current_zoom)\n\t        if current_zoom < MIN_ZOOM:\n\t            self.scale(MIN_ZOOM / current_zoom, MIN_ZOOM / current_zoom)\n\t        else:\n\t            if current_zoom > MAX_ZOOM:\n\t                self.scale(MAX_ZOOM / current_zoom, MAX_ZOOM / current_zoom)\n\t    def drawBackground(self, painter: QPainter, rect: QRectF | QRect) -> None:\n\t        # First draw blank white background\n\t        painter.setBrush(QColor(255, 255, 255, 255))\n", "        painter.setPen(QPen(Qt.PenStyle.NoPen))\n\t        painter.drawRect(rect)\n\t        # Calculate grid lines\n\t        lines, thick_lines = [], []\n\t        for x in range(int(rect.left() / GRID_SCALE), math.ceil(rect.right() / GRID_SCALE) + 1):\n\t            line = QLineF(x * GRID_SCALE, rect.top(), x * GRID_SCALE, rect.bottom())\n\t            if x % 4 == 0:\n\t                thick_lines.append(line)\n\t            else:\n\t                lines.append(line)\n", "        for y in range(int(rect.top() / GRID_SCALE), math.ceil(rect.bottom() / GRID_SCALE) + 1):\n\t            line = QLineF(rect.left(), y * GRID_SCALE, rect.right(), y * GRID_SCALE)\n\t            if y % 4 == 0:\n\t                thick_lines.append(line)\n\t            else:\n\t                lines.append(line)\n\t        # Draw grid lines\n\t        painter.setPen(QPen(QColor(240, 240, 240), 1, Qt.PenStyle.SolidLine))\n\t        painter.drawLines(lines)\n\t        painter.setPen(QPen(QColor(240, 240, 240), 2, Qt.PenStyle.SolidLine))\n", "        painter.drawLines(thick_lines)\n\t    def _emit_sparkles(self, pos: QPointF, mult: int) -> None:\n\t        for _ in range(mult * SPARKLE_COUNT):\n\t            angle = random.random() * 2 * math.pi\n\t            speed = random.random() * (SPARKLE_MAX_SPEED - SPARKLE_MIN_SPEED) + SPARKLE_MIN_SPEED\n\t            x = speed * math.cos(angle)\n\t            y = speed * math.sin(angle)\n\t            Sparkle(pos.x(), pos.y(), x, y, SPARKLE_FADE, self.graph_scene)\n\tSPARKLE_COLOR = \"#900090\"\n\tSPARKLE_COUNT = 1\n", "SPARKLE_MAX_SPEED = 200.0\n\tSPARKLE_MIN_SPEED = 100.0\n\tSPARKLE_FADE = 20.0\n\tclass Sparkle(QGraphicsEllipseItem):\n\t    def __init__(self, x: float, y: float, vx: float, vy: float, vo: float, scene: GraphScene) -> None:\n\t        super().__init__(\n\t            -0.05 * SCALE, -0.05 * SCALE, 0.1 * SCALE, 0.1 * SCALE\n\t        )\n\t        self.vx, self.vy, self.vo = vx, vy, vo\n\t        self.prev_value = 0.0\n", "        self.setPos(x, y)\n\t        self.setZValue(PHASE_ITEM_Z)\n\t        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, False)\n\t        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, False)\n\t        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, False)\n\t        self.setBrush(QBrush(QColor(SPARKLE_COLOR)))\n\t        self.setPen(QPen(Qt.PenStyle.NoPen))\n\t        scene.addItem(self)\n\t        self.timer = QTimeLine(1000)\n\t        self.timer.valueChanged.connect(self._timer_step)\n", "        self.timer.start()\n\t        self.show()\n\t    def _timer_step(self, value: float) -> None:\n\t        dt = value - self.prev_value\n\t        self.prev_value = value\n\t        self.setX(self.x() + dt * self.vx)\n\t        self.setY(self.y() + dt * self.vy)\n\t        self.setOpacity(max(self.opacity() - dt * self.vo, 0.0))\n\t        if value == 1.0:\n\t            self.scene().removeItem(self)\n"]}
{"filename": "zxlive/rules.py", "chunked_list": ["from statistics import fmean\n\tfrom typing import List\n\tfrom pyzx.utils import EdgeType, VertexType\n\tfrom .common import VT, ET, GraphT\n\tdef check_bialgebra(g:GraphT, v_list: List[VT]) -> bool:\n\t    phases = g.phases()\n\t    x_vertices = []\n\t    z_vertices = []\n\t    for v in v_list:\n\t        if phases[v] != 0:\n", "            return False\n\t        if g.type(v) == VertexType.X:\n\t            x_vertices.append(v)\n\t        elif g.type(v) == VertexType.Z:\n\t            z_vertices.append(v)\n\t        else:\n\t            return False\n\t    if z_vertices == [] or x_vertices == []:\n\t        return False\n\t    # all x vertices are connected to all z vertices\n", "    for x in x_vertices:\n\t        for z in z_vertices:\n\t            if x not in g.neighbors(z):\n\t                return False\n\t            if g.edge_type(g.edge(x, z)) != EdgeType.SIMPLE:\n\t                return False\n\t    # not connected among themselves\n\t    for vs in [x_vertices, z_vertices]:\n\t        for v1 in vs:\n\t            for v2 in vs:\n", "                if v1 != v2 and v1 in g.neighbors(v2):\n\t                    return False\n\t    return True\n\tdef bialgebra(g:GraphT, v_list:List[VT]) -> None:\n\t    '''\n\t    g: BaseGraph[[VT,ET]]\n\t    v_list: list of vertex where bialgebra needs to be applied\n\t    returns: The graph with bialgebra rule applied if the vertices\n\t    provided can be simplified by this rule\n\t    '''\n", "    if not check_bialgebra(g, v_list):\n\t        return\n\t    x_vertices = list(filter(lambda v: g.type(v) == VertexType.X, v_list))\n\t    z_vertices = list(filter(lambda v: g.type(v) == VertexType.Z, v_list))\n\t    nodes = []\n\t    nt: VertexType.Type\n\t    for nt, vs in [(VertexType.Z, x_vertices), (VertexType.X, z_vertices)]:  # type: ignore\n\t        q = fmean([g.qubit(x) for x in vs])\n\t        r = fmean([g.row(x) for x in vs])\n\t        node = g.add_vertex(nt, q, r)\n", "        nodes.append(node)\n\t        for v in vs:\n\t            for n in g.neighbors(v):\n\t                g.add_edge(g.edge(node, n), EdgeType.SIMPLE) # type: ignore\n\t            g.remove_vertex(v)\n\t    g.add_edge(g.edge(nodes[0], nodes[1]), EdgeType.SIMPLE)\n"]}
{"filename": "zxlive/construct.py", "chunked_list": ["from typing import List\n\tfrom pyzx.utils import EdgeType, VertexType\n\tfrom .common import GraphT, Graph\n\tdef construct_circuit() -> GraphT:\n\t    qubits = 4\n\t    vlist = [\n\t        (0, 0, 1), (1, 1, 2), (2, 2, 1), (3, 3, 1), (4, 0, 1), (5, 1, 1),\n\t        (6, 2, 2), (7, 3, 1), (8, 0, 1), (9, 1, 2), (10, 2, 1), (11, 3, 1),\n\t        (12, 0, 2), (13, 1, 2), (14, 2, 1), (15, 3, 2)]\n\t    elist = [\n", "        (0, 4, 0), (0, 1, 0), (1, 5, 0), (1, 6, 0), (2, 6, 0), (3, 7, 0),\n\t        (5, 9, 1), (4, 8, 0), (6, 10, 0), (7, 11, 0), (8, 12, 0), (8, 13, 0),\n\t        (9, 13, 1), (9, 14, 1), (10, 13, 0), (10, 14, 0), (11, 15, 0),\n\t        (11, 14, 0)]\n\t    nvertices = len(vlist) + (2 * qubits)\n\t    ty: List[VertexType.Type] = [VertexType.BOUNDARY] * nvertices\n\t    nvlist: list[tuple[int, int, VertexType.Type]] = []\n\t    # Adding inputs nodes to the nvlist.\n\t    for i in range(qubits):\n\t        nvlist.append((i, i, VertexType.BOUNDARY))\n", "        ty[i] = VertexType.BOUNDARY\n\t    # Adding the actual vertices to the nvlist.\n\t    for vert in vlist:\n\t        # print(vert[2])\n\t        if vert[2] == 1:\n\t            ty[vert[0]+qubits] = VertexType.Z\n\t            # print(ty)\n\t        elif vert[2] == 2:\n\t            ty[vert[0]+qubits] = VertexType.X\n\t        nvlist.append((vert[0]+qubits, vert[1], ty[i+qubits-1]))\n", "    # Adding the output nodes to the nvlist.\n\t    for i in range(qubits):\n\t        nvlist.append((nvertices - qubits + i, i, VertexType.BOUNDARY))\n\t        ty[nvertices - qubits + i] = VertexType.BOUNDARY\n\t    nelist = []\n\t    # Updating the user provided elist to include input indices\n\t    for edge in elist:\n\t        nelist.append((edge[0]+qubits, edge[1]+qubits, edge[2]))\n\t    # Adding the edges between inputs nodes and output nodes to internal nodes\n\t    for i in range(qubits):\n", "        nelist.append((i, i+qubits, 0))\n\t        nelist.append((nvertices - qubits + i, nvertices - (2*qubits) + i, 0))\n\t    cur_row = [1] * qubits\n\t    g = Graph()\n\t    assert isinstance(g, GraphT)\n\t    # Adding vertices to the graph\n\t    for (i, qu, tp) in nvlist:\n\t        rw = cur_row[qu]\n\t        g.add_vertex(ty[i], qu, rw)\n\t        cur_row[qu] += 1\n", "    es1 = [edge[:2] for edge in nelist if not edge[2]]\n\t    es2 = [edge[:2] for edge in nelist if edge[2]]\n\t    # TODO: add the phase part\n\t    # for w, phase in phases.items():\n\t    #     g.set_phase(w,phase)\n\t    g.add_edges(es1, EdgeType.SIMPLE)\n\t    g.add_edges(es2, EdgeType.HADAMARD)\n\t    inputs = []\n\t    outputs = []\n\t    for i in range(qubits):\n", "        inputs.append(i)\n\t        outputs.append(nvertices-qubits+i)\n\t    g.set_inputs(tuple(inputs))\n\t    g.set_outputs(tuple(outputs))\n\t    return g\n"]}
{"filename": "zxlive/__main__.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom zxlive import app\n\tif __name__ == '__main__':\n\t    app.main()\n"]}
{"filename": "zxlive/app.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\tfrom PySide6.QtWidgets import QApplication\n\timport sys\n\tsys.path.insert(0,'../pyzx') # So that it can find a local copy of pyzx\n\tfrom .mainwindow import MainWindow\n\tclass ZXLive(QApplication):\n\t    \"\"\"The main ZX Live application\n\t    ...\n", "    \"\"\"\n\t    def __init__(self) -> None:\n\t        super().__init__(sys.argv)\n\t        self.setApplicationName('ZX Live')\n\t        self.setDesktopFileName('ZX Live')\n\t        self.main_window = MainWindow()\n\t        self.lastWindowClosed.connect(self.quit)\n\tdef main() -> None:\n\t    \"\"\"Main entry point for ZX Live\"\"\"\n\t    zxl = ZXLive()\n", "    zxl.exec_()\n"]}
{"filename": "zxlive/proof.py", "chunked_list": ["import json\n\tfrom typing import NamedTuple, Union, Any\n\tfrom PySide6.QtCore import QAbstractListModel, QModelIndex, QPersistentModelIndex, Qt\n\tfrom PySide6.QtGui import QFont\n\tfrom pyzx.graph import GraphDiff\n\tfrom zxlive.common import GraphT\n\tclass Rewrite(NamedTuple):\n\t    \"\"\"A rewrite turns a graph into another graph.\"\"\"\n\t    rule: str  # Name of the rule that was applied to get to this step\n\t    diff: GraphDiff  # Diff from the last step to this step\n", "    def to_json(self) -> str:\n\t        \"\"\"Serializes the rewrite to JSON.\"\"\"\n\t        return json.dumps({\n\t            \"rule\": self.rule,\n\t            \"diff\": self.diff.to_json()\n\t        })\n\t    @staticmethod\n\t    def from_json(json_str: str) -> \"Rewrite\":\n\t        \"\"\"Deserializes the rewrite from JSON.\"\"\"\n\t        d = json.loads(json_str)\n", "        return Rewrite(\n\t            rule=d[\"rule\"],\n\t            diff=GraphDiff.from_json(d[\"diff\"])\n\t        )\n\tclass ProofModel(QAbstractListModel):\n\t    \"\"\"List model capturing the individual steps in a proof.\n\t    There is a row for each graph in the proof sequence. Furthermore, we store the\n\t    rewrite that was used to go from one graph to next.\n\t    \"\"\"\n\t    graphs: list[GraphT]  # n graphs\n", "    steps: list[Rewrite]  # n-1 rewrite steps\n\t    def __init__(self, start_graph: GraphT):\n\t        super().__init__()\n\t        self.graphs = [start_graph]\n\t        self.steps = []\n\t    def set_data(self, graphs: list[GraphT], steps: list[Rewrite]) -> None:\n\t        \"\"\"Sets the model data.\n\t        Can be used to load the model from a saved state.\n\t        \"\"\"\n\t        assert len(steps) == len(graphs) - 1\n", "        self.beginResetModel()\n\t        self.graphs = graphs\n\t        self.steps = steps\n\t        self.endResetModel()\n\t    def data(self, index: Union[QModelIndex, QPersistentModelIndex], role: int=Qt.ItemDataRole.DisplayRole) -> Any:\n\t        \"\"\"Overrides `QAbstractItemModel.data` to populate a view with rewrite steps\"\"\"\n\t        if index.row() >= len(self.graphs) or index.column() >= 1:\n\t            return None\n\t        if role == Qt.ItemDataRole.DisplayRole:\n\t            if index.row() == 0:\n", "                return \"START\"\n\t            else:\n\t                return self.steps[index.row()-1].rule\n\t        elif role == Qt.ItemDataRole.FontRole:\n\t            return QFont(\"monospace\", 12)\n\t    def headerData(self, section: int, orientation: Qt.Orientation,\n\t                   role: int = Qt.ItemDataRole.DisplayRole) -> Any:\n\t        \"\"\"Overrides `QAbstractItemModel.headerData`.\n\t        Indicates that this model doesn't have a header.\n\t        \"\"\"\n", "        return None\n\t    def columnCount(self, index: Union[QModelIndex, QPersistentModelIndex] = QModelIndex()) -> int:\n\t        \"\"\"The number of columns\"\"\"\n\t        return 1\n\t    def rowCount(self, index: Union[QModelIndex, QPersistentModelIndex] = QModelIndex()) -> int:\n\t        \"\"\"The number of rows\"\"\"\n\t        # This is a quirk of Qt list models: Since they are based on tree models, the\n\t        # user has to specify the index of the parent. In a list, we always expect the\n\t        # parent to be `None` or the empty `QModelIndex()`\n\t        if not index or not index.isValid():\n", "            return len(self.graphs)\n\t        else:\n\t            return 0\n\t    def add_rewrite(self, rewrite: Rewrite, new_graph: GraphT) -> None:\n\t        \"\"\"Adds a rewrite step to the model.\"\"\"\n\t        self.beginInsertRows(QModelIndex(), len(self.graphs), len(self.graphs))\n\t        self.graphs.append(new_graph)\n\t        self.steps.append(rewrite)\n\t        self.endInsertRows()\n\t    def pop_rewrite(self) -> tuple[Rewrite, GraphT]:\n", "        \"\"\"Removes the latest rewrite from the model.\n\t        Returns the rewrite and the graph that previously resulted from this rewrite.\n\t        \"\"\"\n\t        self.beginRemoveRows(QModelIndex(), len(self.graphs) - 1, len(self.graphs) - 1)\n\t        rewrite = self.steps.pop()\n\t        graph = self.graphs.pop()\n\t        self.endRemoveRows()\n\t        return rewrite, graph\n\t    def get_graph(self, index: int) -> GraphT:\n\t        \"\"\"Returns the grap at a given position in the proof.\"\"\"\n", "        copy = self.graphs[index].copy()\n\t        assert isinstance(copy, GraphT)\n\t        return copy\n\t    def to_json(self) -> str:\n\t        \"\"\"Serializes the model to JSON.\"\"\"\n\t        initial_graph_tikz = self.graphs[0].to_tikz()\n\t        proof_steps = []\n\t        for step in self.steps:\n\t            proof_steps.append(step.to_json())\n\t        return json.dumps({\n", "            \"initial_graph\": initial_graph_tikz,\n\t            \"proof_steps\": proof_steps\n\t        })\n\t    @staticmethod\n\t    def from_json(json_str: str) -> \"ProofModel\":\n\t        \"\"\"Deserializes the model from JSON.\"\"\"\n\t        d = json.loads(json_str)\n\t        initial_graph = GraphT.from_tikz(d[\"initial_graph\"])\n\t        assert isinstance(initial_graph, GraphT)\n\t        model = ProofModel(initial_graph)\n", "        for step in d[\"proof_steps\"]:\n\t            rewrite = Rewrite.from_json(step)\n\t            rewritten_graph = rewrite.diff.apply_diff(model.graphs[-1])\n\t            assert isinstance(rewritten_graph, GraphT)\n\t            model.add_rewrite(rewrite, rewritten_graph)\n\t        return model\n"]}
{"filename": "zxlive/eitem.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\tfrom typing import Optional, Any, TYPE_CHECKING\n\tfrom PySide6.QtCore import QPointF\n\tfrom PySide6.QtWidgets import QGraphicsEllipseItem, QGraphicsPathItem, QGraphicsItem, \\\n\t    QGraphicsSceneMouseEvent, QStyleOptionGraphicsItem, QWidget, QStyle\n\tfrom PySide6.QtGui import QPen, QBrush,  QPainter, QColor, QPainterPath\n\tfrom pyzx import EdgeType\n\tfrom .common import SCALE, VT, ET, GraphT\n", "from .vitem import VItem, EITEM_Z\n\tif TYPE_CHECKING:\n\t    from .graphscene import GraphScene\n\tHAD_EDGE_BLUE = \"#0077ff\"\n\tclass EItem(QGraphicsPathItem):\n\t    \"\"\"A QGraphicsItem representing an edge\"\"\"\n\t    def __init__(self, graph_scene: GraphScene, e: ET, s_item: VItem, t_item: VItem) -> None:\n\t        super().__init__()\n\t        self.setZValue(EITEM_Z)\n\t        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, True)\n", "        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)\n\t        self.graph_scene = graph_scene\n\t        self.e = e\n\t        self.s_item = s_item\n\t        self.t_item = t_item\n\t        s_item.adj_items.add(self)\n\t        t_item.adj_items.add(self)\n\t        self.selection_node = QGraphicsEllipseItem(-0.1 * SCALE, -0.1 * SCALE, 0.2 * SCALE, 0.2 * SCALE)\n\t        pen = QPen()\n\t        pen.setWidthF(4)\n", "        pen.setColor(QColor('#0022FF'))\n\t        self.selection_node.setPen(pen)\n\t        self.selection_node.setOpacity(0.5)\n\t        # self.selection_node.setVisible(False)\n\t        self.refresh()\n\t    @property\n\t    def g(self) -> GraphT:\n\t        return self.graph_scene.g\n\t    def refresh(self) -> None:\n\t        \"\"\"Call whenever source or target moves or edge data changes\"\"\"\n", "        # set color/style according to edge type\n\t        pen = QPen()\n\t        pen.setWidthF(3)\n\t        if self.g.edge_type(self.e) == EdgeType.HADAMARD:\n\t            pen.setColor(QColor(HAD_EDGE_BLUE))\n\t            pen.setDashPattern([4.0, 2.0])\n\t        else:\n\t            pen.setColor(QColor(\"#000000\"))\n\t        self.setPen(QPen(pen))\n\t        # set path as a straight line from source to target\n", "        path = QPainterPath()\n\t        path.moveTo(self.s_item.pos())\n\t        path.lineTo(self.t_item.pos())\n\t        self.setPath(path)\n\t        avg_x = 0.5*(self.s_item.pos().x() + self.t_item.pos().x())\n\t        avg_y = 0.5*(self.s_item.pos().y() + self.t_item.pos().y())\n\t        self.selection_node.setPos(avg_x,avg_y)\n\t        if self.isSelected():\n\t            self.selection_node.setVisible(True)\n\t        else:\n", "            self.selection_node.setVisible(False)\n\t    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: Optional[QWidget] = None) -> None:\n\t        # By default, Qt draws a dashed rectangle around selected items.\n\t        # We have our own implementation to draw selected vertices, so\n\t        # we intercept the selected option here.\n\t        option.state &= ~QStyle.StateFlag.State_Selected\n\t        super().paint(painter, option, widget)\n\t    def itemChange(self, change: QGraphicsItem.GraphicsItemChange, value: Any) -> Any:\n\t        # Intercept selection- and position-has-changed events to call `refresh`.\n\t        # Note that the position and selected values are already updated when\n", "        # this event fires.\n\t        if change in (QGraphicsItem.GraphicsItemChange.ItemSelectedHasChanged, QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged):\n\t            self.refresh()\n\t        return super().itemChange(change, value)\n\t    def mousePressEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        super().mousePressEvent(e)\n\t        self.refresh()\n\t# TODO: This is essentially a clone of EItem. We should common it up!\n\tclass EDragItem(QGraphicsPathItem):\n\t    \"\"\"A QGraphicsItem representing an edge in construction during a drag\"\"\"\n", "    def __init__(self, g: GraphT, ety: EdgeType.Type, start: VItem, mouse_pos: QPointF) -> None:\n\t        super().__init__()\n\t        self.setZValue(EITEM_Z)\n\t        self.g = g\n\t        self.ety = ety\n\t        self.start = start\n\t        self.mouse_pos = mouse_pos\n\t        self.refresh()\n\t    def refresh(self) -> None:\n\t        \"\"\"Call whenever source or target moves or edge data changes\"\"\"\n", "        # set color/style according to edge type\n\t        pen = QPen()\n\t        pen.setWidthF(3)\n\t        if self.ety == EdgeType.HADAMARD:\n\t            pen.setColor(QColor(\"#0077ff\"))\n\t            pen.setDashPattern([4.0, 2.0])\n\t        else:\n\t            pen.setColor(QColor(\"#000000\"))\n\t        self.setPen(QPen(pen))\n\t        # set path as a straight line from source to target\n", "        path = QPainterPath()\n\t        path.moveTo(self.start.pos())\n\t        path.lineTo(self.mouse_pos)\n\t        self.setPath(path)\n"]}
{"filename": "zxlive/proof_panel.py", "chunked_list": ["from __future__ import annotations\n\timport copy\n\tfrom typing import Iterator, Union, cast\n\timport pyzx\n\tfrom PySide6.QtCore import QPointF, QPersistentModelIndex, Qt, \\\n\t    QModelIndex, QItemSelection, QRect, QSize\n\tfrom PySide6.QtGui import QVector2D, QFont, QColor, QPainter, QPen, QFontMetrics, QIcon\n\tfrom PySide6.QtWidgets import QWidget, QToolButton, QHBoxLayout, QListView, \\\n\t    QStyledItemDelegate, QStyleOptionViewItem, QStyle, QAbstractItemView\n\tfrom pyzx import VertexType, basicrules\n", "from .common import ET, VT, GraphT, SCALE, pos_from_view, pos_to_view\n\tfrom .base_panel import BasePanel, ToolbarSection\n\tfrom .commands import AddRewriteStep, GoToRewriteStep, MoveNodeInStep\n\tfrom .graphscene import GraphScene\n\tfrom .graphview import WandTrace, GraphTool\n\tfrom .eitem import EItem\n\tfrom .proof import ProofModel\n\tfrom .utils import get_data\n\tfrom .vitem import VItem, ZX_GREEN, DragState\n\tfrom . import proof_actions\n", "from . import animations as anims\n\tclass ProofPanel(BasePanel):\n\t    \"\"\"Panel for the proof mode of ZX live.\"\"\"\n\t    def __init__(self, graph: GraphT) -> None:\n\t        self.graph_scene = GraphScene()\n\t        self.graph_scene.vertices_moved.connect(self._vert_moved)\n\t        # TODO: Right now this calls for every single vertex selected, even if we select many at the same time\n\t        self.graph_scene.selectionChanged.connect(self.update_on_selection)\n\t        self.graph_scene.vertex_double_clicked.connect(self._vert_double_clicked)\n\t        super().__init__(graph, self.graph_scene)\n", "        self.init_action_groups()\n\t        self.graph_view.wand_trace_finished.connect(self._wand_trace_finished)\n\t        self.graph_scene.vertex_dragged.connect(self._vertex_dragged)\n\t        self.graph_scene.vertex_dropped_onto.connect(self._vertex_dropped_onto)\n\t        self.step_view = QListView(self)\n\t        self.proof_model = ProofModel(self.graph_view.graph_scene.g)\n\t        self.step_view.setModel(self.proof_model)\n\t        self.step_view.setPalette(QColor(255, 255, 255))\n\t        self.step_view.setSpacing(0)\n\t        self.step_view.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)\n", "        self.step_view.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)\n\t        self.step_view.setItemDelegate(ProofStepItemDelegate())\n\t        self.step_view.setCurrentIndex(self.proof_model.index(0, 0))\n\t        self.step_view.selectionModel().selectionChanged.connect(self._proof_step_selected)\n\t        self.step_view.viewport().setAttribute(Qt.WidgetAttribute.WA_Hover)\n\t        self.splitter.addWidget(self.step_view)\n\t    def _toolbar_sections(self) -> Iterator[ToolbarSection]:\n\t        icon_size = QSize(32, 32)\n\t        self.selection = QToolButton(self, checkable=True, checked=True)\n\t        self.magic_wand = QToolButton(self, checkable=True)\n", "        self.selection.setIcon(QIcon(get_data(\"icons/tikzit-tool-select.svg\")))\n\t        self.magic_wand.setIcon(QIcon(get_data(\"icons/magic-wand.svg\")))\n\t        self.selection.setIconSize(icon_size)\n\t        self.magic_wand.setIconSize(icon_size)\n\t        self.selection.setToolTip(\"Select (s)\")\n\t        self.magic_wand.setToolTip(\"Magic Wand (w)\")\n\t        self.selection.setShortcut(\"s\")\n\t        self.magic_wand.setShortcut(\"w\")\n\t        self.selection.clicked.connect(self._selection_clicked)\n\t        self.magic_wand.clicked.connect(self._magic_wand_clicked)\n", "        yield ToolbarSection(self.selection, self.magic_wand, exclusive=True)\n\t        self.identity_choice = (\n\t            QToolButton(self, text=\"Z\", checkable=True, checked=True),\n\t            QToolButton(self, text=\"X\", checkable=True)\n\t        )\n\t        yield ToolbarSection(*self.identity_choice, exclusive=True)\n\t    def init_action_groups(self) -> None:\n\t        self.action_groups = [proof_actions.ProofActionGroup(*proof_actions.rewrites).copy()]\n\t        for group in reversed(self.action_groups):\n\t            hlayout = QHBoxLayout()\n", "            group.init_buttons(self)\n\t            for action in group.actions:\n\t                assert action.button is not None\n\t                hlayout.addWidget(action.button)\n\t            hlayout.addStretch()\n\t            widget = QWidget()\n\t            widget.setLayout(hlayout)\n\t            self.layout().insertWidget(1, widget)\n\t    def parse_selection(self) -> tuple[list[VT], list[ET]]:\n\t        selection = list(self.graph_scene.selected_vertices)\n", "        g = self.graph_scene.g\n\t        edges = []\n\t        for e in g.edges():\n\t            s,t = g.edge_st(e)\n\t            if s in selection and t in selection:\n\t                edges.append(e)\n\t        return selection, edges\n\t    def update_on_selection(self) -> None:\n\t        selection, edges = self.parse_selection()\n\t        g = self.graph_scene.g\n", "        for group in self.action_groups:\n\t            group.update_active(g,selection,edges)\n\t    def _vert_moved(self, vs: list[tuple[VT, float, float]]) -> None:\n\t        cmd = MoveNodeInStep(self.graph_view, vs, self.step_view)\n\t        self.undo_stack.push(cmd)\n\t    def _selection_clicked(self) -> None:\n\t        self.graph_view.tool = GraphTool.Selection\n\t    def _magic_wand_clicked(self) -> None:\n\t        self.graph_view.tool = GraphTool.MagicWand\n\t    def _vertex_dragged(self, state: DragState, v: VT, w: VT) -> None:\n", "        if state == DragState.Onto:\n\t            if pyzx.basicrules.check_fuse(self.graph, v, w):\n\t                anims.anticipate_fuse(self.graph_scene.vertex_map[w])\n\t            elif pyzx.basicrules.check_strong_comp(self.graph, v, w):\n\t                anims.anticipate_strong_comp(self.graph_scene.vertex_map[w])\n\t        else:\n\t            anims.back_to_default(self.graph_scene.vertex_map[w])\n\t    def _vertex_dropped_onto(self, v: VT, w: VT) -> None:\n\t        if pyzx.basicrules.check_fuse(self.graph, v, w):\n\t            g = copy.deepcopy(self.graph)\n", "            pyzx.basicrules.fuse(g, w, v)\n\t            anim = anims.fuse(self.graph_scene.vertex_map[v], self.graph_scene.vertex_map[w])\n\t            cmd = AddRewriteStep(self.graph_view, g, self.step_view, \"fuse spiders\")\n\t            self.undo_stack.push(cmd, anim_before=anim)\n\t        elif pyzx.basicrules.check_strong_comp(self.graph, v, w):\n\t            g = copy.deepcopy(self.graph)\n\t            pyzx.basicrules.strong_comp(g, w, v)\n\t            anim = anims.strong_comp(self.graph, g, w, self.graph_scene)\n\t            cmd = AddRewriteStep(self.graph_view, g, self.step_view, \"bialgebra\")\n\t            self.undo_stack.push(cmd, anim_after=anim)\n", "    def _wand_trace_finished(self, trace: WandTrace) -> None:\n\t        if self._magic_slice(trace):\n\t            return\n\t        elif self._magic_identity(trace):\n\t            return\n\t    def _magic_identity(self, trace: WandTrace) -> bool:\n\t        if len(trace.hit) != 1 or not all(isinstance(item, EItem) for item in trace.hit):\n\t            return False\n\t        # We know that the type of `item` is `EItem` because of the check above\n\t        item = cast(EItem, next(iter(trace.hit)))\n", "        pos = trace.hit[item][-1]\n\t        pos = QPointF(*pos_from_view(pos.x(), pos.y())) * SCALE\n\t        s = self.graph.edge_s(item.e)\n\t        t = self.graph.edge_t(item.e)\n\t        if self.identity_choice[0].isChecked():\n\t            vty: VertexType.Type = VertexType.Z\n\t        elif self.identity_choice[1].isChecked():\n\t            vty = VertexType.X\n\t        else:\n\t            raise ValueError(\"Neither of the spider types are checked.\")\n", "        new_g = copy.deepcopy(self.graph)\n\t        v = new_g.add_vertex(vty, row=pos.x()/SCALE, qubit=pos.y()/SCALE)\n\t        new_g.add_edge(self.graph.edge(s, v), self.graph.edge_type(item.e))\n\t        new_g.add_edge(self.graph.edge(v, t))\n\t        new_g.remove_edge(item.e)\n\t        anim = anims.add_id(v, self.graph_scene)\n\t        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"remove identity\")\n\t        self.undo_stack.push(cmd, anim_after=anim)\n\t        return True\n\t    def _magic_slice(self, trace: WandTrace) -> bool:\n", "        def cross(a: QPointF, b: QPointF) -> float:\n\t            return a.y() * b.x() - a.x() * b.y()\n\t        filtered = [item for item in trace.hit if isinstance(item, VItem)]\n\t        if len(filtered) != 1:\n\t            return False\n\t        item = filtered[0]\n\t        vertex = item.v\n\t        if self.graph.type(vertex) not in (VertexType.Z, VertexType.X):\n\t            return False\n\t        if basicrules.check_remove_id(self.graph, vertex):\n", "            self._remove_id(vertex)\n\t            return True\n\t        start = trace.hit[item][0]\n\t        end = trace.hit[item][-1]\n\t        if start.y() > end.y():\n\t            start, end = end, start\n\t        pos = QPointF(*pos_to_view(self.graph.row(vertex), self.graph.qubit(vertex)))\n\t        left, right = [], []\n\t        for neighbor in self.graph.neighbors(vertex):\n\t            npos = QPointF(*pos_to_view(self.graph.row(neighbor), self.graph.qubit(neighbor)))\n", "            # Compute whether each neighbor is inside the entry and exit points\n\t            i1 = cross(start - pos, npos - pos) * cross(start - pos, end - pos) >= 0\n\t            i2 = cross(end - pos, npos - pos) * cross(end - pos, start - pos) >= 0\n\t            inside = i1 and i2\n\t            if inside:\n\t                left.append(neighbor)\n\t            else:\n\t                right.append(neighbor)\n\t        mouse_dir = ((start + end) * (1/2)) - pos\n\t        self._unfuse(vertex, left, mouse_dir)\n", "        return True\n\t    def _remove_id(self, v: VT) -> None:\n\t        new_g = copy.deepcopy(self.graph)\n\t        basicrules.remove_id(new_g, v)\n\t        anim = anims.remove_id(self.graph_scene.vertex_map[v])\n\t        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"id\")\n\t        self.undo_stack.push(cmd, anim_before=anim)\n\t    def _unfuse(self, v: VT, left_neighbours: list[VT], mouse_dir: QPointF) -> None:\n\t        def snap_vector(v: QVector2D) -> None:\n\t            if abs(v.x()) > abs(v.y()):\n", "                v.setY(0.0)\n\t            else:\n\t                v.setX(0.0)\n\t            if not v.isNull():\n\t                v.normalize()\n\t        # Compute the average position of left vectors\n\t        pos = QPointF(self.graph.row(v), self.graph.qubit(v))\n\t        avg_left = QVector2D()\n\t        for n in left_neighbours:\n\t            npos = QPointF(self.graph.row(n), self.graph.qubit(n))\n", "            dir = QVector2D(npos - pos).normalized()\n\t            avg_left += dir\n\t        avg_left.normalize()\n\t        # And snap it to the grid\n\t        snap_vector(avg_left)\n\t        # Same for right vectors\n\t        avg_right = QVector2D()\n\t        for n in self.graph.neighbors(v):\n\t            if n in left_neighbours: continue\n\t            npos = QPointF(self.graph.row(n), self.graph.qubit(n))\n", "            dir = QVector2D(npos - pos).normalized()\n\t            avg_right += dir\n\t        avg_right.normalize()\n\t        snap_vector(avg_right)\n\t        if avg_right.isNull():\n\t            avg_right = -avg_left\n\t        elif avg_left.isNull():\n\t            avg_left = -avg_right\n\t        dist = 0.25 if QVector2D.dotProduct(avg_left, avg_right) != 0 else 0.35\n\t        # Put the phase on the left hand side if the mouse direction is further\n", "        # away from the average direction of the left neighbours than the right.\n\t        phase_left = QVector2D.dotProduct(QVector2D(mouse_dir), avg_left) \\\n\t            <= QVector2D.dotProduct(QVector2D(mouse_dir), avg_right)\n\t        new_g = copy.deepcopy(self.graph)\n\t        left_vert = new_g.add_vertex(self.graph.type(v),\n\t                                     qubit=self.graph.qubit(v) + dist*avg_left.y(),\n\t                                     row=self.graph.row(v) + dist*avg_left.x())\n\t        new_g.set_row(v, self.graph.row(v) + dist*avg_right.x())\n\t        new_g.set_qubit(v, self.graph.qubit(v) + dist*avg_right.y())\n\t        for neighbor in left_neighbours:\n", "            new_g.add_edge((neighbor, left_vert),\n\t                           self.graph.edge_type((v, neighbor)))\n\t            new_g.remove_edge((v, neighbor))\n\t        new_g.add_edge((v, left_vert))\n\t        if phase_left:\n\t            new_g.set_phase(left_vert, new_g.phase(v))\n\t            new_g.set_phase(v, 0)\n\t        anim = anims.unfuse(self.graph, new_g, v, self.graph_scene)\n\t        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"unfuse\")\n\t        self.undo_stack.push(cmd, anim_after=anim)\n", "    def _vert_double_clicked(self, v: VT) -> None:\n\t        if self.graph.type(v) == VertexType.BOUNDARY:\n\t            return\n\t        new_g = copy.deepcopy(self.graph)\n\t        basicrules.color_change(new_g, v)\n\t        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"color change\")\n\t        self.undo_stack.push(cmd)\n\t    def _proof_step_selected(self, selected: QItemSelection, deselected: QItemSelection) -> None:\n\t        if not selected or not deselected:\n\t            return\n", "        cmd = GoToRewriteStep(self.graph_view, self.step_view, deselected.first().topLeft().row(), selected.first().topLeft().row())\n\t        self.undo_stack.push(cmd)\n\tclass ProofStepItemDelegate(QStyledItemDelegate):\n\t    \"\"\"This class controls the painting of items in the proof steps list view.\n\t    We paint a \"git-style\" line with circles to denote individual steps in a proof.\n\t    \"\"\"\n\t    line_width = 3\n\t    line_padding = 13\n\t    vert_padding = 10\n\t    circle_radius = 4\n", "    circle_radius_selected = 6\n\t    circle_outline_width = 3\n\t    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index: Union[QModelIndex, QPersistentModelIndex]) -> None:\n\t        painter.save()\n\t        # Draw background\n\t        painter.setPen(Qt.GlobalColor.transparent)\n\t        if option.state & QStyle.StateFlag.State_Selected:\n\t            painter.setBrush(QColor(204, 232, 255))\n\t        elif option.state & QStyle.StateFlag.State_MouseOver:\n\t            painter.setBrush(QColor(229, 243, 255))\n", "        else:\n\t            painter.setBrush(Qt.GlobalColor.white)\n\t        painter.drawRect(option.rect)\n\t        # Draw line\n\t        is_last = index.row() == index.model().rowCount() - 1\n\t        line_rect = QRect(\n\t            self.line_padding,\n\t            option.rect.y(),\n\t            self.line_width,\n\t            option.rect.height() if not is_last else option.rect.height() / 2\n", "        )\n\t        painter.setBrush(Qt.GlobalColor.black)\n\t        painter.drawRect(line_rect)\n\t        # Draw circle\n\t        painter.setPen(QPen(Qt.GlobalColor.black, self.circle_outline_width))\n\t        painter.setBrush(QColor(ZX_GREEN))\n\t        circle_radius = self.circle_radius_selected if option.state & QStyle.StateFlag.State_Selected else self.circle_radius\n\t        painter.drawEllipse(\n\t            QPointF(self.line_padding + self.line_width / 2, option.rect.y() + option.rect.height() / 2),\n\t            circle_radius,\n", "            circle_radius\n\t        )\n\t        # Draw text\n\t        text = index.data(Qt.ItemDataRole.DisplayRole)\n\t        text_height = QFontMetrics(option.font).height()\n\t        text_rect = QRect(\n\t            option.rect.x() + self.line_width + 2 * self.line_padding,\n\t            option.rect.y() + option.rect.height() / 2 - text_height / 2,\n\t            option.rect.width(),\n\t            text_height\n", "        )\n\t        if option.state & QStyle.State_Selected:\n\t            option.font.setWeight(QFont.Weight.Bold)\n\t        painter.setFont(option.font)\n\t        painter.setPen(Qt.GlobalColor.black)\n\t        painter.setBrush(Qt.GlobalColor.black)\n\t        painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft, text)\n\t        painter.restore()\n\t    def sizeHint(self, option: QStyleOptionViewItem, index: QModelIndex | QPersistentModelIndex) -> QSize:\n\t        size = super().sizeHint(option, index)\n", "        return QSize(size.width(), size.height() + 2 * self.vert_padding)\n\t    # def createEditor(self, parent: QWidget, option: QStyleOptionViewItem, index: QModelIndex | QPersistentModelIndex) -> QWidget:\n\t    #     return False\n"]}
{"filename": "zxlive/animations.py", "chunked_list": ["import itertools\n\timport random\n\tfrom typing import Optional, Callable\n\tfrom PySide6.QtCore import QEasingCurve, QPointF, QAbstractAnimation, \\\n\t    QParallelAnimationGroup\n\tfrom PySide6.QtGui import QUndoStack, QUndoCommand\n\tfrom .common import VT, GraphT, pos_to_view\n\tfrom .graphscene import GraphScene\n\tfrom .vitem import VItem, VItemAnimation, VITEM_UNSELECTED_Z, VITEM_SELECTED_Z\n\tclass AnimatedUndoStack(QUndoStack):\n", "    \"\"\"An undo stack that can play animations between actions.\"\"\"\n\t    # Command that has not yet been pushed to the base stack because an\n\t    # animation is still playing\n\t    queued_cmd: Optional[QUndoCommand] = None\n\t    # Animation that is currently playing\n\t    running_anim: Optional[QAbstractAnimation] = None\n\t    def push(self, cmd: QUndoCommand, anim_before: Optional[QAbstractAnimation] = None,\n\t             anim_after: Optional[QAbstractAnimation] = None) -> None:\n\t        # Stop previously running animation\n\t        if self.running_anim:\n", "            self.running_anim.stop()\n\t            self.running_anim = None\n\t        # If there is still a queued command, perform it first immediately\n\t        if self.queued_cmd:\n\t            self._push_now(self.queued_cmd)\n\t        if anim_before:\n\t            self.queued_cmd = cmd\n\t            anim_before.finished.connect(lambda: self._push_now(cmd, anim_after))\n\t            anim_before.start()\n\t            self.running_anim = anim_before\n", "        else:\n\t            self._push_now(cmd, anim_after)\n\t    def undo(self) -> None:\n\t        # Stop previously running animation\n\t        if self.running_anim:\n\t            self.running_anim.stop()\n\t            self.running_anim = None\n\t        # If there is still a queued command, perform it first immediately\n\t        if self.queued_cmd:\n\t            self._push_now(self.queued_cmd)\n", "        super().undo()\n\t    def _push_now(self, cmd: QUndoCommand, anim_after: Optional[QAbstractAnimation] = None) -> None:\n\t        self.queued_cmd = None\n\t        super().push(cmd)\n\t        if anim_after:\n\t            anim_after.start()\n\t            self.running_anim = anim_after\n\tdef scale(it: VItem, target: float, duration: int, ease: QEasingCurve, start: Optional[float] = None) -> VItemAnimation:\n\t    anim = VItemAnimation(it, VItem.Properties.Scale)\n\t    anim.setDuration(duration)\n", "    anim.setStartValue(start or it.scale())\n\t    # Important: end value must be a float, otherwise the animation doesn't work because\n\t    # start and end have different types\n\t    anim.setEndValue(float(target))\n\t    anim.setEasingCurve(ease)\n\t    return anim\n\tdef move(it: VItem, target: QPointF, duration: int, ease: QEasingCurve, start: Optional[QPointF] = None) -> VItemAnimation:\n\t    anim = VItemAnimation(it, VItem.Properties.Position, refresh=True)\n\t    anim.setDuration(duration)\n\t    anim.setStartValue(start or it.pos())\n", "    anim.setEndValue(target)\n\t    anim.setEasingCurve(ease)\n\t    return anim\n\tdef morph_graph(start: GraphT, end: GraphT, scene: GraphScene, to_start: Callable[[VT], Optional[VT]],\n\t                to_end: Callable[[VT], Optional[VT]], duration: int, ease: QEasingCurve) -> QAbstractAnimation:\n\t    \"\"\"Morphs a graph into another graph by moving the vertices.\"\"\"\n\t    moves = set()\n\t    for v in itertools.chain(iter(start.vertices()), iter(end.vertices())):\n\t        if v not in start.graph:\n\t            if u := to_start(v):\n", "                moves.add((v, u, v))\n\t        elif v not in end.graph:\n\t            if u := to_end(v):\n\t                moves.add((v, v, u))\n\t        elif start.row(v) != end.row(v) or start.qubit(v) != end.qubit(v):\n\t            moves.add((v, v, v))\n\t    group = QParallelAnimationGroup()\n\t    for v, start_pos, end_pos in moves:\n\t        anim = VItemAnimation(v, VItem.Properties.Position, scene, refresh=True)\n\t        anim.setDuration(duration)\n", "        anim.setStartValue(QPointF(*pos_to_view(start.row(start_pos), start.qubit(start_pos))))\n\t        anim.setEndValue(QPointF(*pos_to_view(end.row(end_pos), end.qubit(end_pos))))\n\t        anim.setEasingCurve(ease)\n\t        group.addAnimation(anim)\n\t    return group\n\tdef shake(it: VItem, amount: float, duration: int) -> None:\n\t    center = it.pos()\n\t    anim = VItemAnimation(it, VItem.Properties.Position, refresh=False)\n\t    anim.setLoopCount(-1)  # Infinite looping\n\t    anim.setEasingCurve(QEasingCurve.Type.InOutExpo)\n", "    anim.setDuration(duration)\n\t    def set_random_params() -> None:\n\t        dx = (2 * random.random() - 1) * amount\n\t        dy = (2 * random.random() - 1) * amount\n\t        anim.setStartValue(it.pos())\n\t        anim.setEndValue(QPointF(center.x() + dx, center.y() + dy))\n\t    def state_changed(state: QAbstractAnimation.State) -> None:\n\t        if state == QAbstractAnimation.State.Stopped:\n\t            it.setPos(center)\n\t    set_random_params()\n", "    anim.currentLoopChanged.connect(set_random_params)\n\t    anim.stateChanged.connect(state_changed)\n\t    anim.start()\n\tdef anticipate_fuse(it: VItem) -> None:\n\t    \"\"\"Animation that is played when a fuseable spider is dragged onto a vertex.\"\"\"\n\t    scale(it, target=1.25, duration=100, ease=QEasingCurve(QEasingCurve.Type.OutInQuad)).start()\n\tdef fuse(dragged: VItem, target: VItem) -> QAbstractAnimation:\n\t    \"\"\"Animation that is played when a fuseable spider is dropped onto a vertex.\"\"\"\n\t    group = QParallelAnimationGroup()\n\t    group.addAnimation(move(dragged, target=target.pos(), duration=100, ease=QEasingCurve(QEasingCurve.Type.OutQuad)))\n", "    group.addAnimation(scale(target, target=1, duration=100, ease=QEasingCurve(QEasingCurve.Type.InBack)))\n\t    def set_z(state: QAbstractAnimation.State) -> None:\n\t        if state == QAbstractAnimation.State.Running:\n\t            target.setZValue(VITEM_SELECTED_Z+1)\n\t        elif state == QAbstractAnimation.State.Stopped:\n\t            target.setZValue(VITEM_UNSELECTED_Z)\n\t    group.stateChanged.connect(set_z)\n\t    return group\n\tdef anticipate_strong_comp(it: VItem) -> None:\n\t    \"\"\"Animation that is played when a bialgebra-capable spider is dragged onto a\n", "    vertex.\"\"\"\n\t    scale(it, target=1.25, duration=100, ease=QEasingCurve(QEasingCurve.Type.OutInQuad)).start()\n\t    # shake(it, amount=1.0, duration=70)  # TODO: This could be improved...\n\tdef strong_comp(before: GraphT, after: GraphT, target: VT, scene: GraphScene) -> QAbstractAnimation:\n\t    \"\"\"Animation that is played when a bialgebra-capable spider is dropped onto a\n\t    vertex.\"\"\"\n\t    return morph_graph(before, after, scene, to_start=lambda _: target,\n\t                       to_end=lambda _: None, duration=150, ease=QEasingCurve(QEasingCurve.Type.OutQuad))\n\tdef back_to_default(it: VItem) -> None:\n\t    \"\"\"Stops all running animations on an VItem and animates all properties back to\n", "    their default values.\"\"\"\n\t    for anim in it.active_animations.copy():\n\t        anim.stop()\n\t    scale(it, target=1, duration=250, ease=QEasingCurve(QEasingCurve.Type.InOutQuad)).start()\n\tdef remove_id(it: VItem) -> VItemAnimation:\n\t    \"\"\"Animation that is played when an identity spider is removed using\n\t    the magic wand.\"\"\"\n\t    anim = VItemAnimation(it, VItem.Properties.Scale)\n\t    anim.setDuration(200)\n\t    anim.setStartValue(it.scale())\n", "    anim.setEndValue(0.0)\n\t    anim.setEasingCurve(QEasingCurve.Type.InBack)\n\t    return anim\n\tdef add_id(v: VT, scene: GraphScene) -> VItemAnimation:\n\t    \"\"\"Animation that is played when an identity spider is added using\n\t    the magic wand.\"\"\"\n\t    anim = VItemAnimation(v, VItem.Properties.Scale, scene)\n\t    anim.setDuration(500)\n\t    anim.setStartValue(0.0)\n\t    anim.setEndValue(1.0)\n", "    anim.setEasingCurve(QEasingCurve.Type.OutElastic)\n\t    return anim\n\tdef unfuse(before: GraphT, after: GraphT, src: VT, scene: GraphScene) -> QAbstractAnimation:\n\t    \"\"\"Animation that is played when a spider is unfused using the magic wand.\"\"\"\n\t    return morph_graph(before, after, scene, to_start=lambda _: src, to_end=lambda _: None,\n\t                       duration=700, ease=QEasingCurve(QEasingCurve.Type.OutElastic))\n"]}
{"filename": "zxlive/graphscene.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\tfrom typing import Optional, Iterator, Iterable, Dict\n\tfrom PySide6.QtCore import Qt, Signal\n\tfrom PySide6.QtGui import QBrush, QColor, QTransform\n\tfrom PySide6.QtWidgets import QGraphicsScene, QGraphicsSceneMouseEvent, QGraphicsItem\n\tfrom pyzx.graph.base import EdgeType\n\tfrom pyzx.graph import GraphDiff\n\tfrom pyzx.graph.graph_s import GraphS\n", "from .common import VT, ET, GraphT, ToolType, pos_from_view, OFFSET_X, OFFSET_Y\n\tfrom .vitem import VItem\n\tfrom .eitem import EItem, EDragItem\n\tclass GraphScene(QGraphicsScene):\n\t    \"\"\"The main class responsible for drawing/editing graphs\"\"\"\n\t    g: GraphT\n\t    # Signals to handle double-clicking and moving of vertices.\n\t    # Note that we have to set the argument types to `object`,\n\t    # otherwise it doesn't work for some reason...\n\t    vertex_double_clicked = Signal(object)  # Actual type: VT\n", "    vertices_moved = Signal(object)  # Actual type: list[tuple[VT, float, float]]\n\t    # Triggers when a vertex is dragged onto or off of another vertex\n\t    # Actual types: DragState, VT, VT\n\t    vertex_dragged = Signal(object, object, object)\n\t    # Triggers when a vertex is dropped onto another vertex. Actual types: VT, VT\n\t    vertex_dropped_onto = Signal(object, object)\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        self.setSceneRect(0, 0, 2*OFFSET_X, 2*OFFSET_Y)\n\t        self.setBackgroundBrush(QBrush(QColor(255, 255, 255)))\n", "        self.vertex_map: Dict[VT, VItem] = {}\n\t        self.edge_map: Dict[ET, EItem] = {}\n\t    @property\n\t    def selected_vertices(self) -> Iterator[VT]:\n\t        \"\"\"An iterator over all currently selected vertices.\"\"\"\n\t        return (it.v for it in self.selectedItems() if isinstance(it, VItem))\n\t    @property\n\t    def selected_edges(self) -> Iterator[ET]:\n\t        return (it.e for it in self.selectedItems() if isinstance(it, EItem))\n\t    def select_vertices(self, vs: Iterable[VT]) -> None:\n", "        \"\"\"Selects the given collection of vertices.\"\"\"\n\t        self.clearSelection()\n\t        vs = set(vs)\n\t        for it in self.items():\n\t            if isinstance(it, VItem) and it.v in vs:\n\t                it.setSelected(True)\n\t                vs.remove(it.v)\n\t    def set_graph(self, g: GraphT) -> None:\n\t        \"\"\"Set the PyZX graph for the scene.\n\t        If the scene already contains a graph, it will be replaced.\"\"\"\n", "        self.g = g\n\t        # Stop all animations\n\t        for it in self.items():\n\t            if isinstance(it, VItem):\n\t                for anim in it.active_animations.copy():\n\t                    anim.stop()\n\t        self.clear()\n\t        self.add_items()\n\t        self.invalidate()\n\t    def update_graph(self, new: GraphT, select_new: bool = False) -> None:\n", "        \"\"\"Update the PyZX graph for the scene.\n\t        This will update the scene to match the given graph. It will\n\t        try to reuse existing QGraphicsItem's as much as possible.\n\t        The selection is carried over to the updated graph.\n\t        :param new: The new graph to update to.\n\t        :param select_new: If True, add all new vertices to the selection set.\"\"\"\n\t        selected_vertices = set(self.selected_vertices)\n\t        diff = GraphDiff(self.g, new)\n\t        removed_edges = set(diff.removed_edges)\n\t        for v in diff.removed_verts:\n", "            v_item = self.vertex_map[v]\n\t            if v_item.phase_item:\n\t                self.removeItem(v_item.phase_item)\n\t            for anim in v_item.active_animations.copy():\n\t                anim.stop()\n\t            for e in self.g.incident_edges(v):\n\t                removed_edges.add(e)\n\t            selected_vertices.discard(v)\n\t            self.removeItem(v_item)\n\t        for e in removed_edges:\n", "            e_item = self.edge_map[e]\n\t            if e_item.selection_node:\n\t                self.removeItem(e_item.selection_node)\n\t            self.removeItem(e_item)\n\t        new_g = diff.apply_diff(self.g)\n\t        assert isinstance(new_g, GraphS)\n\t        self.g = new_g\n\t        # g now contains the new graph,\n\t        # but we still need to update the scene\n\t        # However, the new vertices and edges automatically follow the new graph structure\n", "        for v in diff.new_verts:\n\t            v_item = VItem(self, v)\n\t            self.vertex_map[v] = v_item\n\t            self.addItem(v_item)\n\t            self.addItem(v_item.phase_item)\n\t            if select_new:\n\t                selected_vertices.add(v)\n\t        for e in diff.new_edges:\n\t            s, t = self.g.edge_st(e)\n\t            e_item = EItem(self, e, self.vertex_map[s], self.vertex_map[t])\n", "            self.edge_map[e] = e_item\n\t            self.addItem(e_item)\n\t            self.addItem(e_item.selection_node)\n\t        # So we only have to make sure that the existing vertices and edges\n\t        # are updated to match the new graph structure\n\t        for v in diff.changed_vertex_types:\n\t            self.vertex_map[v].refresh()\n\t        for v in diff.changed_phases:\n\t            self.vertex_map[v].refresh()\n\t        for v in diff.changed_pos:\n", "            v_item = self.vertex_map[v]\n\t            for anim in v_item.active_animations.copy():\n\t                anim.stop()\n\t            v_item.set_pos_from_graph()\n\t        for e in diff.changed_edge_types:\n\t            self.edge_map[e].refresh()\n\t        self.select_vertices(selected_vertices)\n\t    def add_items(self) -> None:\n\t        \"\"\"Add QGraphicsItem's for all vertices and edges in the graph\"\"\"\n\t        self.vertex_map = {}\n", "        for v in self.g.vertices():\n\t            vi = VItem(self, v)\n\t            self.vertex_map[v] = vi\n\t            self.addItem(vi)  # add the vertex to the scene\n\t            self.addItem(vi.phase_item)  # add the phase label to the scene\n\t        self.edge_map = {}\n\t        for e in self.g.edges():\n\t            s, t = self.g.edge_st(e)\n\t            ei = EItem(self, e, self.vertex_map[s], self.vertex_map[t])\n\t            self.addItem(ei)\n", "            self.addItem(ei.selection_node)\n\t            self.edge_map[e] = ei\n\t    def select_all(self) -> None:\n\t        \"\"\"Selects all vertices and edges in the scene.\"\"\"\n\t        for it in self.items():\n\t            it.setSelected(True)\n\tclass EditGraphScene(GraphScene):\n\t    \"\"\"A graph scene tracking additional mouse events for graph editing.\"\"\"\n\t    # Signals to handle addition of vertices and edges.\n\t    # Note that we have to set the argument types to `object`,\n", "    # otherwise it doesn't work for some reason...\n\t    vertex_added = Signal(object, object)  # Actual types: float, float\n\t    edge_added = Signal(object, object)  # Actual types: VT, VT\n\t    # Currently selected edge type for preview when dragging\n\t    # to add a new edge\n\t    curr_ety: EdgeType.Type\n\t    curr_tool: ToolType\n\t    # The vertex a right mouse button drag was initiated on\n\t    _drag: Optional[EDragItem]\n\t    def __init__(self) -> None:\n", "        super().__init__()\n\t        self.curr_ety = EdgeType.SIMPLE\n\t        self.curr_tool = ToolType.SELECT\n\t        self._drag = None\n\t        self._is_dragging = False\n\t        self._is_mouse_pressed = False\n\t    def mousePressEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        # Right-press on a vertex means the start of a drag for edge adding\n\t        super().mousePressEvent(e)\n\t        if (self.curr_tool == ToolType.EDGE) or \\\n", "            (self.curr_tool == ToolType.SELECT and e.button() == Qt.MouseButton.RightButton):\n\t            if self.items(e.scenePos(), deviceTransform=QTransform()):\n\t                for it in self.items(e.scenePos(), deviceTransform=QTransform()):\n\t                    if isinstance(it, VItem):\n\t                        self._drag = EDragItem(self.g, self.curr_ety, it, e.scenePos())\n\t                        self._drag.start.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, False)\n\t                        self.addItem(self._drag)\n\t        else:\n\t            e.ignore()\n\t        self._is_mouse_pressed = True\n", "    def mouseMoveEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        super().mouseMoveEvent(e)\n\t        if self._drag:\n\t            self._drag.mouse_pos = e.scenePos()\n\t            self._drag.refresh()\n\t        else:\n\t            e.ignore()\n\t        if self._is_mouse_pressed:\n\t            self._is_dragging = True\n\t    def mouseReleaseEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n", "        super().mouseReleaseEvent(e)\n\t        isRightClickOnSelectTool = (self.curr_tool == ToolType.SELECT and \\\n\t                                    e.button() == Qt.MouseButton.RightButton)\n\t        if self._drag and (self.curr_tool == ToolType.EDGE or isRightClickOnSelectTool):\n\t            self._drag.start.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, True)\n\t            self.add_edge(e)\n\t        elif not self._is_dragging and (self.curr_tool == ToolType.VERTEX or isRightClickOnSelectTool):\n\t            self.add_vertex(e)\n\t        else:\n\t            e.ignore()\n", "        self._is_mouse_pressed = False\n\t        self._is_dragging = False\n\t    def add_vertex(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        p = e.scenePos()\n\t        self.vertex_added.emit(*pos_from_view(p.x(), p.y()))\n\t    def add_edge(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        assert self._drag is not None\n\t        self.removeItem(self._drag)\n\t        for it in self.items(e.scenePos(), deviceTransform=QTransform()):\n\t            # TODO: Think about if we want to allow self loops here?\n", "            #  For example, if had edge is selected this would mean that\n\t            #  right clicking adds pi to the phase...\n\t            if isinstance(it, VItem) and it != self._drag.start:\n\t                self.edge_added.emit(self._drag.start.v, it.v)\n\t        self._drag = None\n"]}
{"filename": "zxlive/__init__.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom . import app\n\tfrom .graphview import GraphView\n"]}
{"filename": "zxlive/utils.py", "chunked_list": ["import os\n\t_ROOT = os.path.abspath(os.path.dirname(__file__))\n\tdef get_data(path: str) -> str:\n\t    return os.path.join(_ROOT, path)\n"]}
{"filename": "zxlive/vitem.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\tfrom enum import Enum\n\tfrom typing import Optional, Set, Any, TYPE_CHECKING, Union\n\tfrom PySide6.QtCore import Qt, QPointF, QVariantAnimation, QAbstractAnimation\n\tfrom PySide6.QtGui import QPen, QBrush,  QPainter, QColor, QFont, QPainterPath\n\tfrom PySide6.QtWidgets import QWidget, QGraphicsPathItem, QGraphicsTextItem, QGraphicsItem, \\\n\t     QStyle, QStyleOptionGraphicsItem, QGraphicsSceneMouseEvent\n\tfrom pyzx.graph.base import VertexType\n", "from pyzx.utils import phase_to_s\n\tfrom .common import VT, ET, GraphT, SCALE, pos_to_view, pos_from_view\n\tif TYPE_CHECKING:\n\t    from .eitem import EItem\n\t    from .graphscene import GraphScene\n\tZX_GREEN = \"#ccffcc\"\n\tZX_GREEN_PRESSED = \"#64BC90\"\n\tZX_RED = \"#ff8888\"\n\tZX_RED_PRESSED = \"#bb0f0f\"\n\tH_YELLOW = \"#ffff00\"\n", "H_YELLOW_PRESSED = \"#f1c232\"\n\t# Z values for different items. We use those to make sure that edges\n\t# are drawn below vertices and selected vertices above unselected\n\t# vertices during movement. Phase items are drawn on the very top.\n\tEITEM_Z = -1\n\tVITEM_UNSELECTED_Z = 0\n\tVITEM_SELECTED_Z = 1\n\tPHASE_ITEM_Z = 2\n\tclass DragState(Enum):\n\t        \"\"\"A vertex can be dragged onto another vertex, or if it was dragged onto\n", "         before, it can be dragged off of it again.\"\"\"\n\t        Onto = 0\n\t        OffOf = 1\n\tclass VItem(QGraphicsPathItem):\n\t    \"\"\"A QGraphicsItem representing a single vertex\"\"\"\n\t    v: VT\n\t    phase_item: PhaseItem\n\t    adj_items: Set[EItem]  # Connected edges\n\t    graph_scene: GraphScene\n\t    halftone = \"1000100010001000\" #QPixmap(\"images/halftone.png\")\n", "    # Set of animations that are currently running on this vertex\n\t    active_animations: set[VItemAnimation]\n\t    # Position before starting a drag-move\n\t    _old_pos: Optional[QPointF]\n\t    # Vertex we are currently dragged on top of\n\t    _dragged_on: Optional[VItem]\n\t    class Properties(Enum):\n\t        \"\"\"Properties of a VItem that can be animated.\"\"\"\n\t        Position = 0\n\t        Scale = 1\n", "        Rect = 2\n\t    def __init__(self, graph_scene: GraphScene, v: VT) -> None:\n\t        super().__init__()\n\t        self.setZValue(VITEM_UNSELECTED_Z)\n\t        self.graph_scene = graph_scene\n\t        self.v = v\n\t        self.setPos(*pos_to_view(self.g.row(v), self.g.qubit(v)))\n\t        self.adj_items: Set[EItem] = set()\n\t        self.phase_item = PhaseItem(self)\n\t        self.active_animations = set()\n", "        self._old_pos = None\n\t        self._dragged_on = None\n\t        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, True)\n\t        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, True)\n\t        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)\n\t        pen = QPen()\n\t        pen.setWidthF(3)\n\t        pen.setColor(QColor(\"black\"))\n\t        self.setPen(pen)\n\t        path = QPainterPath()\n", "        if self.g.type(self.v) == VertexType.H_BOX:\n\t            path.addRect(-0.2 * SCALE, -0.2 * SCALE, 0.4 * SCALE, 0.4 * SCALE)\n\t        else:\n\t            path.addEllipse(-0.2 * SCALE, -0.2 * SCALE, 0.4 * SCALE, 0.4 * SCALE)\n\t        self.setPath(path)\n\t        self.refresh()\n\t    @property\n\t    def g(self) -> GraphT:\n\t        return self.graph_scene.g\n\t    @property\n", "    def is_dragging(self) -> bool:\n\t        return self._old_pos is not None\n\t    @property\n\t    def is_animated(self) -> bool:\n\t        return len(self.active_animations) > 0\n\t    def refresh(self) -> None:\n\t        \"\"\"Call this method whenever a vertex moves or its data changes\"\"\"\n\t        if not self.isSelected():\n\t            t = self.g.type(self.v)\n\t            if t == VertexType.Z:\n", "                self.setBrush(QBrush(QColor(ZX_GREEN)))\n\t            elif t == VertexType.X:\n\t                self.setBrush(QBrush(QColor(ZX_RED)))\n\t            elif t == VertexType.H_BOX:\n\t                self.setBrush(QBrush(QColor(H_YELLOW)))\n\t            else:\n\t                self.setBrush(QBrush(QColor(\"#000000\")))\n\t            pen = QPen()\n\t            pen.setWidthF(3)\n\t            pen.setColor(QColor(\"black\"))\n", "            self.setPen(pen)\n\t        if self.isSelected():\n\t            pen = QPen()\n\t            pen.setWidthF(5)\n\t            t = self.g.type(self.v)\n\t            if t == VertexType.Z:\n\t                brush = QBrush(QColor(ZX_GREEN_PRESSED))\n\t                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n\t                self.setBrush(brush)\n\t            elif t == VertexType.X:\n", "                brush = QBrush(QColor(ZX_RED_PRESSED))\n\t                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n\t                self.setBrush(brush)\n\t            elif t == VertexType.H_BOX:\n\t                brush = QBrush(QColor(H_YELLOW_PRESSED))\n\t                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n\t                self.setBrush(brush)\n\t            else:\n\t                brush = QBrush(QColor(\"#444444\"))\n\t                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n", "                self.setBrush(brush)\n\t                pen.setColor(QColor(\"#444444\"))\n\t            self.setPen(pen)\n\t        if self.phase_item:\n\t            self.phase_item.refresh()\n\t        for e_item in self.adj_items:\n\t            e_item.refresh()\n\t    def set_pos_from_graph(self) -> None:\n\t        self.setPos(*pos_to_view(self.g.row(self.v), self.g.qubit(self.v)))\n\t    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: Optional[QWidget] = None) -> None:\n", "        # By default, Qt draws a dashed rectangle around selected items.\n\t        # We have our own implementation to draw selected vertices, so\n\t        # we intercept the selected option here.\n\t        option.state &= ~QStyle.StateFlag.State_Selected\n\t        super().paint(painter, option, widget)\n\t    def itemChange(self, change: QGraphicsItem.GraphicsItemChange, value: Any) -> Any:\n\t        # Snap items to grid on movement by intercepting the position-change\n\t        # event and returning a new position\n\t        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange and not self.is_animated:\n\t            assert isinstance(value, QPointF)\n", "            grid_size = SCALE / 8\n\t            x = round(value.x() / grid_size) * grid_size\n\t            y = round(value.y() / grid_size) * grid_size\n\t            return QPointF(x, y)\n\t        # When selecting/deselecting items, we move them to the front/back\n\t        if change == QGraphicsItem.GraphicsItemChange.ItemSelectedChange:\n\t            assert isinstance(value, int)  # 0 or 1\n\t            self.setZValue(VITEM_SELECTED_Z if value else VITEM_UNSELECTED_Z)\n\t            return value\n\t        # Intercept selection- and position-has-changed events to call `refresh`.\n", "        # Note that the position and selected values are already updated when\n\t        # this event fires.\n\t        if change in (QGraphicsItem.GraphicsItemChange.ItemSelectedHasChanged, QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged):\n\t            # If we're being animated, the animation will decide for itself whether we\n\t            # should be refreshed or not\n\t            if not self.is_animated:\n\t                self.refresh()\n\t        return super().itemChange(change, value)\n\t    def mouseDoubleClickEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        super().mouseDoubleClickEvent(e)\n", "        if self.is_animated:\n\t            return\n\t        scene = self.scene()\n\t        if TYPE_CHECKING: assert isinstance(scene, GraphScene)\n\t        scene.vertex_double_clicked.emit(self.v)\n\t    def mousePressEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        super().mousePressEvent(e)\n\t        if self.is_animated:\n\t            return\n\t        self._old_pos = self.pos()\n", "    def mouseMoveEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        super().mouseMoveEvent(e)\n\t        if self.is_animated:\n\t            return\n\t        scene = self.scene()\n\t        if TYPE_CHECKING: assert isinstance(scene, GraphScene)\n\t        if self.is_dragging and len(scene.selectedItems()) == 1:\n\t            reset = True\n\t            for it in scene.items():\n\t                if not it.sceneBoundingRect().intersects(self.sceneBoundingRect()):\n", "                    continue\n\t                if it == self._dragged_on:\n\t                    reset = False\n\t                elif isinstance(it, VItem) and it != self:\n\t                    scene.vertex_dragged.emit(DragState.Onto, self.v, it.v)\n\t                    # If we previously hovered over a vertex, notify the scene that we\n\t                    # are no longer\n\t                    if self._dragged_on is not None:\n\t                        scene.vertex_dragged.emit(DragState.OffOf, self.v, self._dragged_on.v)\n\t                    self._dragged_on = it\n", "                    return\n\t            if reset and self._dragged_on is not None:\n\t                scene.vertex_dragged.emit(DragState.OffOf, self.v, self._dragged_on.v)\n\t                self._dragged_on = None\n\t        e.ignore()\n\t    def mouseReleaseEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n\t        # Unfortunately, Qt does not provide a \"MoveFinished\" event, so we have to\n\t        # manually detect mouse releases.\n\t        super().mouseReleaseEvent(e)\n\t        if self.is_animated:\n", "            return\n\t        if e.button() == Qt.MouseButton.LeftButton:\n\t            if self._old_pos != self.pos():\n\t                scene = self.scene()\n\t                if TYPE_CHECKING: assert isinstance(scene, GraphScene)\n\t                if self._dragged_on is not None and len(scene.selectedItems()) == 1:\n\t                    scene.vertex_dropped_onto.emit(self.v, self._dragged_on.v)\n\t                else:\n\t                    scene.vertices_moved.emit([\n\t                        (it.v, *pos_from_view(it.pos().x(),it.pos().y()))\n", "                        for it in scene.selectedItems() if isinstance(it, VItem)\n\t                    ])\n\t                self._dragged_on = None\n\t                self._old_pos = None\n\t        else:\n\t            e.ignore()\n\tclass VItemAnimation(QVariantAnimation):\n\t    \"\"\"Animator for vertex graphics items.\n\t    This animator lets the vertex know that its being animated which stops any\n\t    interaction with the user and disables grid snapping. Furthermore, this animator\n", "    ensures that it's not garbage collected until the animation is finished, so there is\n\t    no need to hold onto a reference of this class.\"\"\"\n\t    _it: Optional[VItem]\n\t    prop: VItem.Properties\n\t    refresh: bool  # Whether the item is refreshed at each frame\n\t    v: Optional[VT]\n\t    def __init__(self, item: Union[VItem, VT], property: VItem.Properties,\n\t                 scene: Optional[GraphScene] = None, refresh: bool = False) -> None:\n\t        super().__init__()\n\t        self.v = None\n", "        self._it = None\n\t        self.scene: Optional[GraphScene] = None\n\t        if refresh and property != VItem.Properties.Position:\n\t            raise ValueError(\"Only position animations require refresh\")\n\t        if isinstance(item, VItem):\n\t            self._it = item\n\t        elif scene is None:\n\t            raise ValueError(\"Scene is required to obtain VItem from vertex id\")\n\t        else:\n\t            self.v = item\n", "            self.scene = scene\n\t        self.prop = property\n\t        self.refresh = refresh\n\t        self.stateChanged.connect(self._on_state_changed)\n\t    @property\n\t    def it(self) -> VItem:\n\t        if self._it is None and self.scene is not None and self.v is not None:\n\t            self._it = self.scene.vertex_map[self.v]\n\t        assert self._it is not None\n\t        return self._it\n", "    def _on_state_changed(self, state: QAbstractAnimation.State) -> None:\n\t        if state == QAbstractAnimation.State.Running and self not in self.it.active_animations:\n\t            # Stop all animations that target the same property\n\t            for anim in self.it.active_animations.copy():\n\t                if anim.prop == self.prop:\n\t                    anim.stop()\n\t            self.it.active_animations.add(self)\n\t        elif state == QAbstractAnimation.State.Stopped:\n\t            self.it.active_animations.remove(self)\n\t        elif state == QAbstractAnimation.State.Paused:\n", "            # TODO: Once we use pausing, we should decide what to do here.\n\t            #   Note that we cannot just remove ourselves from the set since the garbage\n\t            #   collector will eat us in that case. We'll probably need something like\n\t            #   `it.paused_animations`\n\t            pass\n\t    def updateCurrentValue(self, value: Any) -> None:\n\t        if self.state() != QAbstractAnimation.State.Running:\n\t            return\n\t        if self.prop == VItem.Properties.Position:\n\t            self.it.setPos(value)\n", "        elif self.prop == VItem.Properties.Scale:\n\t            self.it.setScale(value)\n\t        elif self.prop == VItem.Properties.Rect:\n\t            self.it.setPath(value)\n\t        if self.refresh:\n\t            self.it.refresh()\n\tclass PhaseItem(QGraphicsTextItem):\n\t    \"\"\"A QGraphicsItem representing a phase label\"\"\"\n\t    def __init__(self, v_item: VItem) -> None:\n\t        super().__init__()\n", "        self.setZValue(PHASE_ITEM_Z)\n\t        self.setDefaultTextColor(QColor(\"#006bb3\"))\n\t        self.setFont(QFont(\"monospace\"))\n\t        self.v_item = v_item\n\t        self.refresh()\n\t    def refresh(self) -> None:\n\t        \"\"\"Call this when a vertex moves or its phase changes\"\"\"\n\t        phase = self.v_item.g.phase(self.v_item.v)\n\t        # phase = self.v_item.v\n\t        self.setPlainText(phase_to_s(phase, self.v_item.g.type(self.v_item.v)))\n", "        if self.v_item.g.type(self.v_item.v) == VertexType.BOUNDARY:\n\t            self.setPlainText(str(int(self.v_item.g.qubit(self.v_item.v))))\n\t        p = self.v_item.pos()\n\t        self.setPos(p.x(), p.y() - 0.6 * SCALE)\n"]}
{"filename": "zxlive/proof_actions.py", "chunked_list": ["import copy\n\tfrom dataclasses import dataclass, field, replace\n\tfrom typing import Callable, Literal, List, Optional, TYPE_CHECKING\n\timport networkx as nx\n\tfrom networkx.algorithms.isomorphism import GraphMatcher, categorical_node_match\n\timport numpy as np\n\timport pyzx\n\tfrom pyzx.utils import VertexType, EdgeType\n\tfrom shapely import Polygon\n\tfrom PySide6.QtWidgets import QPushButton, QButtonGroup\n", "from . import animations as anims\n\tfrom .commands import AddRewriteStep\n\tfrom .common import ET, Graph, GraphT, VT\n\tif TYPE_CHECKING:\n\t    from .proof_panel import ProofPanel\n\toperations = pyzx.editor.operations\n\tMatchType = Literal[1, 2]\n\t# Copied from pyzx.editor_actions\n\tMATCHES_VERTICES: MatchType = 1\n\tMATCHES_EDGES: MatchType = 2\n", "@dataclass\n\tclass ProofAction(object):\n\t    name: str\n\t    matcher: Callable[[GraphT, Callable], List]\n\t    rule: Callable[[GraphT, List], pyzx.rules.RewriteOutputType[ET,VT]]\n\t    match_type: MatchType\n\t    tooltip: str\n\t    button: Optional[QPushButton] = field(default=None, init=False)\n\t    @classmethod\n\t    def from_dict(cls, d: dict) -> \"ProofAction\":\n", "          return cls(d['text'], d['matcher'], d['rule'], d['type'], d['tooltip'])\n\t    def do_rewrite(self, panel: \"ProofPanel\") -> None:\n\t        verts, edges = panel.parse_selection()\n\t        g = copy.deepcopy(panel.graph_scene.g)\n\t        if self.match_type == MATCHES_VERTICES:\n\t            matches = self.matcher(g, lambda v: v in verts)\n\t        else:\n\t            matches = self.matcher(g, lambda e: e in edges)\n\t        etab, rem_verts, rem_edges, check_isolated_vertices = self.rule(g, matches)\n\t        g.remove_edges(rem_edges)\n", "        g.remove_vertices(rem_verts)\n\t        g.add_edge_table(etab)\n\t        cmd = AddRewriteStep(panel.graph_view, g, panel.step_view, self.name)\n\t        if self.name == operations['spider']['text']:\n\t            anim = anims.fuse(panel.graph_scene.vertex_map[verts[0]], panel.graph_scene.vertex_map[verts[1]])\n\t            panel.undo_stack.push(cmd, anim_before=anim)\n\t        elif self.name == operations['to_z']['text']:\n\t            print('To do: animate ' + self.name)\n\t            panel.undo_stack.push(cmd)\n\t        elif self.name == operations['to_x']['text']:\n", "            print('To do: animate ' + self.name)\n\t            panel.undo_stack.push(cmd)\n\t        elif self.name == operations['rem_id']['text']:\n\t            anim = anims.remove_id(panel.graph_scene.vertex_map[verts[0]])\n\t            panel.undo_stack.push(cmd, anim_before=anim)\n\t        elif self.name == operations['copy']['text']:\n\t            anim = anims.strong_comp(panel.graph, g, verts[0], panel.graph_scene)\n\t            panel.undo_stack.push(cmd, anim_after=anim)\n\t            # print('To do: animate ' + self.name)\n\t            # panel.undo_stack.push(cmd)\n", "        elif self.name == operations['pauli']['text']:\n\t            print('To do: animate ' + self.name)\n\t            panel.undo_stack.push(cmd)\n\t        elif self.name == operations['bialgebra']['text']:\n\t            anim = anims.strong_comp(panel.graph, g, verts[0], panel.graph_scene)\n\t            panel.undo_stack.push(cmd, anim_after=anim)\n\t        else:\n\t            panel.undo_stack.push(cmd)\n\t    def update_active(self, g: GraphT, verts: List[VT], edges: List[ET]) -> None:\n\t        if self.match_type == MATCHES_VERTICES:\n", "            matches = self.matcher(g, lambda v: v in verts)\n\t        else:\n\t            matches = self.matcher(g, lambda e: e in edges)\n\t        if self.button is None: return\n\t        if matches:\n\t            self.button.setEnabled(True)\n\t        else:\n\t            self.button.setEnabled(False)\n\tclass ProofActionGroup(object):\n\t    def __init__(self, *actions: ProofAction) -> None:\n", "        self.actions = actions\n\t        self.btn_group: Optional[QButtonGroup] = None\n\t        self.parent_panel = None\n\t    def copy(self) -> \"ProofActionGroup\":\n\t        copied_actions = []\n\t        for action in self.actions:\n\t            action_copy = replace(action)\n\t            action_copy.button = None\n\t            copied_actions.append(action_copy)\n\t        return ProofActionGroup(*copied_actions)\n", "    def init_buttons(self, parent: \"ProofPanel\") -> None:\n\t        self.btn_group = QButtonGroup(parent, exclusive=False)\n\t        def create_rewrite(action: ProofAction, parent: \"ProofPanel\") -> Callable[[], None]: # Needed to prevent weird bug with closures in signals\n\t            def rewriter() -> None:\n\t                action.do_rewrite(parent)\n\t            return rewriter\n\t        for action in self.actions:\n\t            if action.button is not None: continue\n\t            btn = QPushButton(action.name, parent)\n\t            btn.setMaximumWidth(150)\n", "            btn.setStatusTip(action.tooltip)\n\t            btn.setEnabled(False)\n\t            btn.clicked.connect(create_rewrite(action, parent))\n\t            self.btn_group.addButton(btn)\n\t            action.button = btn\n\t    def update_active(self, g: GraphT, verts: List[VT], edges: List[ET]) -> None:\n\t        for action in self.actions:\n\t            action.update_active(g, verts, edges)\n\tdef to_networkx(graph: Graph) -> nx.Graph:\n\t    G = nx.Graph()\n", "    v_data = {v: {\"type\": graph.type(v),\n\t                  \"phase\": graph.phase(v),}\n\t              for v in graph.vertices()}\n\t    for i, input_vertex in enumerate(graph.inputs()):\n\t        v_data[input_vertex][\"boundary_index\"] = f'input_{i}'\n\t    for i, output_vertex in enumerate(graph.outputs()):\n\t        v_data[output_vertex][\"boundary_index\"] = f'output_{i}'\n\t    G.add_nodes_from([(v, v_data[v]) for v in graph.vertices()])\n\t    G.add_edges_from([(*v, {\"type\": graph.edge_type(v)}) for v in  graph.edges()])\n\t    return G\n", "def create_subgraph(graph: Graph, verts: List[VT]) -> nx.Graph:\n\t    graph_nx = to_networkx(graph)\n\t    subgraph_nx = nx.Graph(graph_nx.subgraph(verts))\n\t    boundary_mapping = {}\n\t    i = 0\n\t    for v in verts:\n\t        for vn in graph.neighbors(v):\n\t            if vn not in verts:\n\t                boundary_node = 'b' + str(i)\n\t                boundary_mapping[boundary_node] = vn\n", "                subgraph_nx.add_node(boundary_node, type=VertexType.BOUNDARY)\n\t                subgraph_nx.add_edge(v, boundary_node, type=EdgeType.SIMPLE)\n\t                i += 1\n\t    return subgraph_nx, boundary_mapping\n\tdef custom_matcher(graph: Graph, in_selection: Callable[[VT], bool], lhs_graph: nx.Graph) -> List[VT]:\n\t    verts = [v for v in graph.vertices() if in_selection(v)]\n\t    subgraph_nx, _ = create_subgraph(graph, verts)\n\t    graph_matcher = GraphMatcher(lhs_graph, subgraph_nx,\\\n\t        node_match=categorical_node_match(['type', 'phase'], default=[1, 0]))\n\t    if graph_matcher.is_isomorphic():\n", "        return verts\n\t    return []\n\tdef custom_rule(graph: Graph, vertices: List[VT], lhs_graph: nx.Graph, rhs_graph: nx.Graph) -> pyzx.rules.RewriteOutputType[ET,VT]:\n\t    subgraph_nx, boundary_mapping = create_subgraph(graph, vertices)\n\t    graph_matcher = GraphMatcher(lhs_graph, subgraph_nx,\\\n\t        node_match=categorical_node_match(['type', 'phase'], default=[1, 0]))\n\t    matching = list(graph_matcher.match())[0]\n\t    vertices_to_remove = []\n\t    for v in matching:\n\t        if subgraph_nx.nodes()[matching[v]]['type'] != VertexType.BOUNDARY:\n", "            vertices_to_remove.append(matching[v])\n\t    boundary_vertex_map = {}\n\t    for v in rhs_graph.nodes():\n\t        if rhs_graph.nodes()[v]['type'] == VertexType.BOUNDARY:\n\t            for x, data in lhs_graph.nodes(data=True):\n\t                if data['type'] == VertexType.BOUNDARY and \\\n\t                    data['boundary_index'] == rhs_graph.nodes()[v]['boundary_index']:\n\t                    boundary_vertex_map[v] = boundary_mapping[matching[x]]\n\t                    break\n\t    vertex_positions = get_vertex_positions(graph, rhs_graph, boundary_vertex_map)\n", "    vertex_map = boundary_vertex_map\n\t    for v in rhs_graph.nodes():\n\t        if rhs_graph.nodes()[v]['type'] != VertexType.BOUNDARY:\n\t            vertex_map[v] = graph.add_vertex(ty = rhs_graph.nodes()[v]['type'],\n\t                                             row = vertex_positions[v][0],\n\t                                             qubit = vertex_positions[v][1],\n\t                                             phase = rhs_graph.nodes()[v]['phase'],)\n\t    # create etab to add edges\n\t    etab = {}\n\t    for v1, v2, data in rhs_graph.edges(data=True):\n", "        v1 = vertex_map[v1]\n\t        v2 = vertex_map[v2]\n\t        if (v1, v2) not in etab: etab[(v1, v2)] = [0, 0]\n\t        etab[(v1, v2)][data['type']-1] += 1\n\t    return etab, vertices_to_remove, [], True\n\tdef get_vertex_positions(graph, rhs_graph, boundary_vertex_map):\n\t    pos_dict = {v: (graph.row(m), graph.qubit(m)) for v, m in boundary_vertex_map.items()}\n\t    coords = np.array(list(pos_dict.values()))\n\t    center = np.mean(coords, axis=0)\n\t    angles = np.arctan2(coords[:,1]-center[1], coords[:,0]-center[0])\n", "    coords = coords[np.argsort(-angles)]\n\t    try:\n\t        area = Polygon(coords).area\n\t    except:\n\t        area = 1\n\t    k = (area ** 0.5) / len(rhs_graph)\n\t    return nx.spring_layout(rhs_graph, k=k, pos=pos_dict, fixed=boundary_vertex_map.keys())\n\tdef create_custom_matcher(lhs_graph: Graph) -> Callable[[Graph, Callable[[VT], bool]], List[VT]]:\n\t    lhs_graph.auto_detect_io()\n\t    return lambda g, selection: custom_matcher(g, selection, to_networkx(lhs_graph))\n", "def create_custom_rule(lhs_graph: Graph, rhs_graph: Graph) -> Callable[[Graph, List[VT]], pyzx.rules.RewriteOutputType[ET,VT]]:\n\t    lhs_graph.auto_detect_io()\n\t    rhs_graph.auto_detect_io()\n\t    return lambda g, verts: custom_rule(g, verts, to_networkx(lhs_graph), to_networkx(rhs_graph))\n\tspider_fuse = ProofAction.from_dict(operations['spider'])\n\tto_z = ProofAction.from_dict(operations['to_z'])\n\tto_x = ProofAction.from_dict(operations['to_x'])\n\trem_id = ProofAction.from_dict(operations['rem_id'])\n\tcopy_action = ProofAction.from_dict(operations['copy'])\n\tpauli = ProofAction.from_dict(operations['pauli'])\n", "bialgebra = ProofAction.from_dict(operations['bialgebra'])\n\trewrites = [spider_fuse, to_z, to_x, rem_id, copy_action, pauli, bialgebra]\n"]}
{"filename": "zxlive/dialogs.py", "chunked_list": ["from __future__ import annotations\n\tfrom enum import Enum\n\tfrom typing import Optional, Tuple\n\tfrom dataclasses import dataclass\n\tfrom PySide6.QtCore import QFile, QIODevice, QTextStream\n\tfrom PySide6.QtWidgets import QWidget, QFileDialog, QMessageBox, QDialog, QFormLayout, QLineEdit, QTextEdit, QPushButton, QDialogButtonBox\n\timport numpy as np\n\tfrom pyzx import Circuit, extract_circuit\n\tfrom pyzx.graph.base import BaseGraph\n\tfrom zxlive import proof_actions\n", "from zxlive.proof import ProofModel\n\tfrom .common import VT,ET, GraphT, Graph\n\tclass FileFormat(Enum):\n\t    \"\"\"Supported formats for importing/exporting diagrams.\"\"\"\n\t    All = \"zxg *.json *.qasm *.tikz *.zxp\", \"All Supported Formats\"\n\t    QGraph = \"zxg\", \"QGraph\"  # \"file extension\", \"format name\"\n\t    QASM = \"qasm\", \"QASM\"\n\t    TikZ = \"tikz\", \"TikZ\"\n\t    Json = \"json\", \"JSON\"\n\t    ZXProof = \"zxp\", \"ZXProof\"\n", "    _value_: str\n\t    def __new__(cls, *args, **kwds):  # type: ignore\n\t        obj = object.__new__(cls)\n\t        obj._value_ = args[0]  # Use extension as `_value_`\n\t        return obj\n\t    def __init__(self, _extension: str, name: str) -> None:\n\t        # Ignore extension param since it's already set by `__new__`\n\t        self._name = name\n\t    @property\n\t    def extension(self) -> str:\n", "        \"\"\"The file extension for this format.\n\t        The extension is returned *without* a leading dot.\"\"\"\n\t        return self._value_\n\t    @property\n\t    def name(self) -> str:\n\t        \"\"\"The text used to display this file format.\"\"\"\n\t        return self._name_\n\t    @property\n\t    def filter(self) -> str:\n\t        \"\"\"The filter string for this file type.\n", "        Used by `QFileDialog` to filter the shown file extensions.\"\"\"\n\t        return f\"{self.name} (*.{self.extension})\"\n\t@dataclass\n\tclass ImportGraphOutput:\n\t    file_type: FileFormat\n\t    file_path: str\n\t    g: GraphT\n\t@dataclass\n\tclass ImportProofOutput:\n\t    file_type: FileFormat\n", "    file_path: str\n\t    p: ProofModel\n\tdef show_error_msg(title: str, description: Optional[str] = None) -> None:\n\t    \"\"\"Displays an error message box.\"\"\"\n\t    msg = QMessageBox()\n\t    msg.setText(title)\n\t    msg.setIcon(QMessageBox.Icon.Critical)\n\t    if description is not None:\n\t        msg.setInformativeText(description)\n\t    msg.exec()\n", "def import_diagram_dialog(parent: QWidget) -> Optional[ImportGraphOutput | ImportProofOutput]:\n\t    \"\"\"Shows a dialog to import a diagram from disk.\n\t    Returns the imported graph or `None` if the import failed.\"\"\"\n\t    file_path, selected_filter = QFileDialog.getOpenFileName(\n\t        parent=parent,\n\t        caption=\"Open File\",\n\t        filter=\";;\".join([f.filter for f in FileFormat]),\n\t    )\n\t    if selected_filter == \"\":\n\t        # This happens if the user clicks on cancel\n", "        return None\n\t    selected_format = next(f for f in FileFormat if f.filter == selected_filter)\n\t    file = QFile(file_path)\n\t    if not file.open(QIODevice.OpenModeFlag.ReadOnly | QIODevice.OpenModeFlag.Text):\n\t        show_error_msg(\"Could not open file\")\n\t        return None\n\t    stream = QTextStream(file)\n\t    data = stream.readAll()\n\t    file.close()\n\t    ext = file_path.split(\".\")[-1]\n", "    selected_format = next(f for f in FileFormat if f.filter == selected_filter)\n\t    if selected_format == FileFormat.All:\n\t        selected_format = next(f for f in FileFormat if f.extension == ext)\n\t    # TODO: This would be nicer with match statements...\n\t    try:\n\t        if selected_format == FileFormat.ZXProof:\n\t            return ImportProofOutput(selected_format, file_path, ProofModel.from_json(data))\n\t        elif selected_format in (FileFormat.QGraph, FileFormat.Json):\n\t            return ImportGraphOutput(selected_format, file_path, Graph.from_json(data))  # type: ignore # This is something that needs to be better annotated in PyZX\n\t        elif selected_format == FileFormat.QASM:\n", "            return ImportGraphOutput(selected_format, file_path, Circuit.from_qasm(data).to_graph()) # type: ignore\n\t        elif selected_format == FileFormat.TikZ:\n\t            return ImportGraphOutput(selected_format, file_path, Graph.from_tikz(data))  # type: ignore\n\t        else:\n\t            assert selected_format == FileFormat.All\n\t            try:\n\t                circ = Circuit.load(file_path)\n\t                return ImportGraphOutput(FileFormat.QASM, file_path, circ.to_graph())  # type: ignore\n\t            except TypeError:\n\t                try:\n", "                    return ImportGraphOutput(FileFormat.QGraph, file_path, Graph.from_json(data))  # type: ignore\n\t                except Exception:\n\t                    try:\n\t                        return ImportGraphOutput(FileFormat.TikZ, file_path, Graph.from_tikz(data))  # type: ignore\n\t                    except:\n\t                        show_error_msg(f\"Failed to import {selected_format.name} file\", \"Couldn't determine filetype.\")\n\t                        return None\n\t    except Exception as e:\n\t        show_error_msg(f\"Failed to import {selected_format.name} file\", str(e))\n\t        return None\n", "def write_to_file(file_path: str, data: str) -> bool:\n\t    file = QFile(file_path)\n\t    if not file.open(QIODevice.OpenModeFlag.WriteOnly | QIODevice.OpenModeFlag.Text):\n\t        show_error_msg(\"Could not write to file\")\n\t        return False\n\t    out = QTextStream(file)\n\t    out << data\n\t    file.close()\n\t    return True\n\tdef get_file_path_and_format(parent: QWidget, filter: str) -> Optional[Tuple[str, FileFormat]]:\n", "    file_path, selected_filter = QFileDialog.getSaveFileName(\n\t        parent=parent,\n\t        caption=\"Save File\",\n\t        filter=filter,\n\t    )\n\t    if selected_filter == \"\":\n\t        # This happens if the user clicks on cancel\n\t        return None\n\t    ext = file_path.split(\".\")[-1]\n\t    selected_format = next(f for f in FileFormat if f.filter == selected_filter)\n", "    if selected_format == FileFormat.All:\n\t        selected_format = next(f for f in FileFormat if f.extension == ext)\n\t    # Add file extension if it's not already there\n\t    if file_path.split(\".\")[-1].lower() != selected_format.extension:\n\t        file_path += \".\" + selected_format.extension\n\t    return file_path, selected_format\n\tdef export_diagram_dialog(graph: GraphT, parent: QWidget) -> Optional[Tuple[str, FileFormat]]:\n\t    file_path_and_format = get_file_path_and_format(parent, \";;\".join([f.filter for f in FileFormat if f != FileFormat.ZXProof]))\n\t    if file_path_and_format is None or not file_path_and_format[0]:\n\t        return None\n", "    file_path, selected_format = file_path_and_format\n\t    if selected_format in (FileFormat.QGraph, FileFormat.Json):\n\t        data = graph.to_json()\n\t    elif selected_format == FileFormat.QASM:\n\t        try:\n\t            circuit = extract_circuit(graph)\n\t        except Exception as e:\n\t            show_error_msg(\"Failed to convert the diagram to a circuit\", str(e))\n\t            return None\n\t        data = circuit.to_qasm()\n", "    else:\n\t        assert selected_format == FileFormat.TikZ\n\t        data = graph.to_tikz()\n\t    if not write_to_file(file_path, data):\n\t        return None\n\t    return file_path, selected_format\n\tdef export_proof_dialog(proof_model: ProofModel, parent: QWidget) -> Optional[Tuple[str, FileFormat]]:\n\t    file_path_and_format = get_file_path_and_format(parent, FileFormat.ZXProof.filter)\n\t    if file_path_and_format is None or not file_path_and_format[0]:\n\t        return None\n", "    file_path, selected_format = file_path_and_format\n\t    data = proof_model.to_json()\n\t    if not write_to_file(file_path, data):\n\t        return None\n\t    return file_path, selected_format\n\tdef create_new_rewrite(parent) -> None:\n\t    dialog = QDialog()\n\t    parent.rewrite_form = QFormLayout(dialog)\n\t    name = QLineEdit()\n\t    parent.rewrite_form.addRow(\"Name\", name)\n", "    description = QTextEdit()\n\t    parent.rewrite_form.addRow(\"Description\", description)\n\t    left_button = QPushButton(\"Left-hand side of the rule\")\n\t    right_button = QPushButton(\"Right-hand side of the rule\")\n\t    parent.left_graph = None\n\t    parent.right_graph = None\n\t    def get_file(self, button, side) -> None:\n\t        out = import_diagram_dialog(self)\n\t        if out is not None:\n\t            button.setText(out.file_path)\n", "            if side == \"left\":\n\t                self.left_graph = out.g\n\t            else:\n\t                self.right_graph = out.g\n\t    left_button.clicked.connect(lambda: get_file(parent, left_button, \"left\"))\n\t    right_button.clicked.connect(lambda: get_file(parent, right_button, \"right\"))\n\t    parent.rewrite_form.addRow(left_button)\n\t    parent.rewrite_form.addRow(right_button)\n\t    button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)\n\t    parent.rewrite_form.addRow(button_box)\n", "    def add_rewrite() -> None:\n\t        if parent.left_graph is None or parent.right_graph is None:\n\t            return\n\t        parent.left_graph.auto_detect_io()\n\t        parent.right_graph.auto_detect_io()\n\t        left_matrix, right_matrix = parent.left_graph.to_matrix(), parent.right_graph.to_matrix()\n\t        if not np.allclose(left_matrix, right_matrix):\n\t            if np.allclose(left_matrix / np.linalg.norm(left_matrix), right_matrix / np.linalg.norm(right_matrix)):\n\t                show_error_msg(\"Warning!\", \"The left-hand side and right-hand side of the rule differ by a scalar.\")\n\t            else:\n", "                show_error_msg(\"Warning!\", \"The left-hand side and right-hand side of the rule have different semantics.\")\n\t        rewrite = proof_actions.ProofAction.from_dict({\n\t            \"text\":name.text(),\n\t            \"tooltip\":description.toPlainText(),\n\t            \"matcher\": proof_actions.create_custom_matcher(parent.left_graph),\n\t            \"rule\": proof_actions.create_custom_rule(parent.left_graph, parent.right_graph),\n\t            \"type\": proof_actions.MATCHES_VERTICES,\n\t        })\n\t        proof_actions.rewrites.append(rewrite)\n\t        dialog.accept()\n", "    button_box.accepted.connect(add_rewrite)\n\t    button_box.rejected.connect(dialog.reject)\n\t    if not dialog.exec(): return\n"]}
{"filename": "zxlive/commands.py", "chunked_list": ["from dataclasses import dataclass, field\n\tfrom fractions import Fraction\n\tfrom typing import Optional, Iterable, Set, Union, List, Any\n\timport copy\n\tfrom PySide6.QtCore import QItemSelection, QModelIndex, QItemSelectionModel, \\\n\t    QSignalBlocker\n\tfrom PySide6.QtGui import QUndoCommand\n\tfrom PySide6.QtWidgets import QListView\n\tfrom pyzx import basicrules\n\tfrom pyzx.graph import GraphDiff\n", "from pyzx.utils import EdgeType, VertexType\n\tfrom .common import VT, ET, GraphT\n\tfrom .graphview import GraphView\n\tfrom .proof import ProofModel, Rewrite\n\t@dataclass\n\tclass BaseCommand(QUndoCommand):\n\t    \"\"\"Abstract base class for all commands.\n\t    Each command has a reference to the graph view whose graph it\n\t    modifies. This allows the command to notify the view that the\n\t    graph has changed and requires redrawing.\"\"\"\n", "    graph_view: GraphView\n\t    def __post_init__(self) -> None:\n\t        # We need to make sure that `__init__` of the super `QUndoCommand`\n\t        # is being called, but a normal dataclass doesn't do that.\n\t        # Overriding `__init__` also doesn't work since the command sub-\n\t        # dataclasses don't call modified super constructors. Thus, we\n\t        # hook it into `__post_init__`.\n\t        super().__init__()\n\t        self.g = copy.deepcopy(self.graph_view.graph_scene.g)\n\t    def update_graph_view(self, select_new: bool = False) -> None:\n", "        \"\"\"Notifies the graph view that graph needs to be redrawn.\n\t        :param select_new: If True, add all new vertices to the selection set.\n\t        \"\"\"\n\t        # TODO: For performance reasons, we should track which parts\n\t        #  of the graph have changed and only update those. For example\n\t        #  we could store \"dirty flags\" for each node/edge.\n\t        self.graph_view.update_graph(self.g, select_new)\n\t@dataclass\n\tclass SetGraph(BaseCommand):\n\t    \"\"\"Replaces the current graph with an entirely new graph.\"\"\"\n", "    new_g: GraphT\n\t    old_g: Optional[GraphT] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        assert self.old_g is not None\n\t        self.graph_view.set_graph(self.old_g)\n\t    def redo(self) -> None:\n\t        self.old_g = self.graph_view.graph_scene.g\n\t        self.graph_view.set_graph(self.new_g)\n\t@dataclass\n\tclass UpdateGraph(BaseCommand):\n", "    \"\"\"Updates the current graph with a modified one.\n\t    It will try to reuse existing QGraphicsItem's as much as possible.\"\"\"\n\t    new_g: GraphT\n\t    old_g: Optional[GraphT] = field(default=None, init=False)\n\t    old_selected: Optional[Set[VT]] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        assert self.old_g is not None and self.old_selected is not None\n\t        self.g = self.old_g\n\t        self.update_graph_view()\n\t        self.graph_view.graph_scene.select_vertices(self.old_selected)\n", "    def redo(self) -> None:\n\t        self.old_g = self.graph_view.graph_scene.g\n\t        self.old_selected = set(self.graph_view.graph_scene.selected_vertices)\n\t        self.g = self.new_g\n\t        self.update_graph_view(True)\n\t@dataclass\n\tclass ChangeNodeColor(BaseCommand):\n\t    \"\"\"Changes the color of a set of spiders.\"\"\"\n\t    vs: Iterable[VT]\n\t    vty: VertexType.Type\n", "    _old_vtys: Optional[list[VertexType]] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        assert self._old_vtys is not None\n\t        for v, old_vty in zip(self.vs, self._old_vtys):  # TODO: strict=True in Python 3.10\n\t            self.g.set_type(v, old_vty)\n\t        self.update_graph_view()\n\t    def redo(self) -> None:\n\t        self._old_vtys = [self.g.type(v) for v in self.vs]\n\t        for v in self.vs:\n\t            self.g.set_type(v, self.vty)\n", "        self.update_graph_view()\n\t@dataclass\n\tclass ChangeEdgeColor(BaseCommand):\n\t    \"\"\"Changes the color of a set of edges\"\"\"\n\t    es: Iterable[ET]\n\t    ety: EdgeType.Type\n\t    _old_etys: Optional[list[EdgeType]] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        assert self._old_etys is not None\n\t        for e, old_ety in zip(self.es, self._old_etys):  # TODO: strict=True in Python 3.10\n", "            self.g.set_edge_type(e, old_ety)\n\t        self.update_graph_view()\n\t    def redo(self) -> None:\n\t        self._old_etys = [self.g.edge_type(e) for e in self.es]\n\t        for e in self.es:\n\t            self.g.set_edge_type(e, self.ety)\n\t        self.update_graph_view()\n\t@dataclass\n\tclass AddNode(BaseCommand):\n\t    \"\"\"Adds a new spider at a given position.\"\"\"\n", "    x: float\n\t    y: float\n\t    vty: VertexType.Type\n\t    _added_vert: Optional[VT] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        assert self._added_vert is not None\n\t        self.g.remove_vertex(self._added_vert)\n\t        self.update_graph_view()\n\t    def redo(self) -> None:\n\t        self._added_vert = self.g.add_vertex(self.vty, self.y, self.x)\n", "        self.update_graph_view()\n\t@dataclass\n\tclass AddEdge(BaseCommand):\n\t    \"\"\"Adds an edge between two spiders.\"\"\"\n\t    u: VT\n\t    v: VT\n\t    ety: EdgeType.Type\n\t    _old_ety: Optional[EdgeType.Type] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        u, v = self.u, self.v\n", "        e = self.g.edge(u, v)\n\t        if self._old_ety:\n\t            self.g.add_edge(e, self._old_ety)\n\t        else:\n\t            self.g.remove_edge(e)\n\t        self.update_graph_view()\n\t    def redo(self) -> None:\n\t        u, v = self.u, self.v\n\t        e = self.g.edge(u, v)\n\t        if self.g.connected(u, v):\n", "            self._old_ety = self.g.edge_type(e)\n\t            self.g.set_edge_type(e, self.ety)\n\t        else:\n\t            self._old_ety = None\n\t            self.g.add_edge(e, self.ety)\n\t        self.update_graph_view()\n\t@dataclass\n\tclass MoveNode(BaseCommand):\n\t    \"\"\"Updates the location of a collection of nodes.\"\"\"\n\t    vs: list[tuple[VT, float, float]]\n", "    _old_positions: Optional[list[tuple[float, float]]] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        assert self._old_positions is not None\n\t        for (v, _, _), (x, y) in zip(self.vs, self._old_positions):\n\t            self.g.set_row(v, x)\n\t            self.g.set_qubit(v, y)\n\t        self.update_graph_view()\n\t    def redo(self) -> None:\n\t        self._old_positions = []\n\t        for v, x, y in self.vs:\n", "            self._old_positions.append((self.g.row(v), self.g.qubit(v)))\n\t            self.g.set_row(v, x)\n\t            self.g.set_qubit(v, y)\n\t        self.update_graph_view()\n\t@dataclass\n\tclass AddIdentity(BaseCommand):\n\t    \"\"\"Adds an X or Z identity spider on an edge between two vertices.\"\"\"\n\t    u: VT\n\t    v: VT\n\t    vty: VertexType.Type\n", "    _new_vert: Optional[VT] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        u, v, w = self.u, self.v, self._new_vert\n\t        assert w is not None\n\t        g = self.g\n\t        et = g.edge_type(g.edge(v, w))\n\t        g.remove_edge(g.edge(u, w))\n\t        g.remove_edge(g.edge(v, w))\n\t        g.remove_vertex(w)\n\t        g.add_edge(g.edge(u, v), et)\n", "        self.update_graph_view()\n\t    def redo(self) -> None:\n\t        u, v = self.u, self.v\n\t        g = self.g\n\t        uv = g.edge(u, v)\n\t        r = 0.5 * (g.row(u) + g.row(v))\n\t        q = 0.5 * (g.qubit(u) + g.qubit(v))\n\t        self._new_vert = g.add_vertex(self.vty, q, r, 0)\n\t        g.add_edge(g.edge(u, self._new_vert))\n\t        g.add_edge(g.edge(v, self._new_vert), g.edge_type(uv))\n", "        g.remove_edge(uv)\n\t        self.update_graph_view()\n\t@dataclass\n\tclass ChangePhase(BaseCommand):\n\t    \"\"\"Updates the phase of a spider.\"\"\"\n\t    v: VT\n\t    new_phase: Union[Fraction, int]\n\t    _old_phase: Optional[Union[Fraction, int]] = field(default=None, init=False)\n\t    def undo(self) -> None:\n\t        assert self._old_phase is not None\n", "        self.g.set_phase(self.v, self._old_phase)\n\t        self.update_graph_view()\n\t    def redo(self) -> None:\n\t        self._old_phase = self.g.phase(self.v)\n\t        self.g.set_phase(self.v, self.new_phase)\n\t        self.update_graph_view()\n\t@dataclass\n\tclass ChangeColor(BaseCommand):\n\t    \"\"\"Applies the color-change rule on a set of vertices.\n\t    Changes the spider type using Hadamard conjugation.\"\"\"\n", "    vs: Iterable[VT]\n\t    def toggle(self) -> None:\n\t        for v in self.vs:\n\t            basicrules.color_change(self.g, v)\n\t        self.update_graph_view()\n\t    undo = redo = toggle\n\t@dataclass\n\tclass AddRewriteStep(SetGraph):\n\t    \"\"\"Adds a new rewrite to the proof.\n\t    The rewrite is inserted after the currently selected step. In particular, it\n", "    replaces all rewrites that were previously after the current selection.\n\t    \"\"\"\n\t    step_view: QListView\n\t    name: str\n\t    diff: Optional[GraphDiff] = None\n\t    _old_selected: Optional[int] = field(default=None, init=False)\n\t    _old_steps: list[tuple[Rewrite, GraphT]] = field(default_factory=list, init=False)\n\t    @property\n\t    def proof_model(self) -> ProofModel:\n\t        model = self.step_view.model()\n", "        assert isinstance(model, ProofModel)\n\t        return model\n\t    def redo(self) -> None:\n\t        # Remove steps from the proof model until we're at the currently selected step\n\t        self._old_selected = self.step_view.currentIndex().row()\n\t        self._old_steps = []\n\t        for _ in range(self.proof_model.rowCount() - self._old_selected - 1):\n\t            self._old_steps.append(self.proof_model.pop_rewrite())\n\t        diff = self.diff or GraphDiff(self.g, self.new_g)\n\t        self.proof_model.add_rewrite(Rewrite(self.name, diff), self.new_g)\n", "        # Select the added step\n\t        idx = self.step_view.model().index(self.proof_model.rowCount() - 1, 0, QModelIndex())\n\t        self.step_view.selectionModel().blockSignals(True)\n\t        self.step_view.setCurrentIndex(idx)\n\t        self.step_view.selectionModel().blockSignals(False)\n\t        super().redo()\n\t    def undo(self) -> None:\n\t        # Undo the rewrite\n\t        self.step_view.selectionModel().blockSignals(True)\n\t        self.proof_model.pop_rewrite()\n", "        self.step_view.selectionModel().blockSignals(False)\n\t        # Add back steps that were previously removed\n\t        for rewrite, graph in reversed(self._old_steps):\n\t            self.proof_model.add_rewrite(rewrite, graph)\n\t        # Select the previously selected step\n\t        assert self._old_selected is not None\n\t        idx = self.step_view.model().index(self._old_selected, 0, QModelIndex())\n\t        self.step_view.selectionModel().blockSignals(True)\n\t        self.step_view.setCurrentIndex(idx)\n\t        self.step_view.selectionModel().blockSignals(False)\n", "        super().undo()\n\t@dataclass\n\tclass GoToRewriteStep(SetGraph):\n\t    \"\"\"Shows the graph at some step in the proof.\n\t    Undoing returns to the previously selected proof step.\n\t    \"\"\"\n\t    def __init__(self, graph_view: GraphView, step_view: QListView, old_step: int, step: int) -> None:\n\t        proof_model = step_view.model()\n\t        assert isinstance(proof_model, ProofModel)\n\t        SetGraph.__init__(self, graph_view, proof_model.get_graph(step))\n", "        self.step_view = step_view\n\t        self.step = step\n\t        self.old_step = old_step\n\t    def redo(self) -> None:\n\t        idx = self.step_view.model().index(self.step, 0, QModelIndex())\n\t        self.step_view.clearSelection()\n\t        self.step_view.selectionModel().blockSignals(True)\n\t        self.step_view.setCurrentIndex(idx)\n\t        self.step_view.selectionModel().blockSignals(False)\n\t        self.step_view.update(idx)\n", "        super().redo()\n\t    def undo(self) -> None:\n\t        idx = self.step_view.model().index(self.old_step, 0, QModelIndex())\n\t        self.step_view.clearSelection()\n\t        self.step_view.selectionModel().blockSignals(True)\n\t        self.step_view.setCurrentIndex(idx)\n\t        self.step_view.selectionModel().blockSignals(False)\n\t        self.step_view.update(idx)\n\t        super().undo()\n\t@dataclass\n", "class MoveNodeInStep(MoveNode):\n\t    step_view: QListView\n\t    def redo(self) -> None:\n\t        super().redo()\n\t        model = self.step_view.model()\n\t        assert isinstance(model, ProofModel)\n\t        model.graphs[self.step_view.currentIndex().row()] = self.g\n\t    def undo(self) -> None:\n\t        super().undo()\n\t        model = self.step_view.model()\n", "        assert isinstance(model, ProofModel)\n\t        model.graphs[self.step_view.currentIndex().row()] = self.g\n"]}
{"filename": "zxlive/common.py", "chunked_list": ["from enum import IntEnum\n\tfrom typing import Final\n\tfrom typing_extensions import TypeAlias\n\timport pyzx\n\tVT: TypeAlias = int\n\tET: TypeAlias = tuple[int,int]\n\tGraphT: TypeAlias = pyzx.graph.graph_s.GraphS\n\tclass ToolType(IntEnum):\n\t    SELECT = 0\n\t    VERTEX = 1\n", "    EDGE = 2\n\tfrom pyzx.graph.graph_s import GraphS as Graph\n\tSCALE: Final = 60.0\n\t# Offsets should be a multiple of SCALE for grid snapping to work properly\n\tOFFSET_X: Final = 300 * SCALE\n\tOFFSET_Y: Final = 300 * SCALE\n\tMIN_ZOOM = 0.05\n\tMAX_ZOOM = 10.0\n\tdef pos_to_view(x:float,y: float) -> tuple[float, float]:\n\t    return (x * SCALE + OFFSET_X, y * SCALE + OFFSET_Y)\n", "def pos_from_view(x:float,y: float) -> tuple[float, float]:\n\t    return ((x-OFFSET_X) / SCALE, (y-OFFSET_Y) / SCALE)\n\tdef pos_to_view_int(x:float,y: float) -> tuple[int, int]:\n\t    return (int(x * SCALE + OFFSET_X), int(y * SCALE + OFFSET_Y))\n\tdef pos_from_view_int(x:float,y: float) -> tuple[int, int]:\n\t    return (int((x - OFFSET_X) / SCALE), int((y - OFFSET_Y) / SCALE))\n\tdef view_to_length(width:float,height:float)-> tuple[float, float]:\n\t    return (width / SCALE, height / SCALE)\n"]}
{"filename": "zxlive/base_panel.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom typing import Iterator, Sequence, Optional\n\tfrom PySide6.QtWidgets import QWidget, QVBoxLayout, QToolBar, QToolButton, QButtonGroup, \\\n\t    QHBoxLayout, QSplitter\n\tfrom pyzx.graph import Graph\n\tfrom pyzx.graph.graph_s import GraphS\n\tfrom .common import GraphT\n\tfrom .graphscene import GraphScene\n\tfrom .graphview import GraphView\n\tfrom .commands import SetGraph\n", "from .dialogs import FileFormat\n\tfrom .animations import AnimatedUndoStack\n\t@dataclass\n\tclass ToolbarSection:\n\t    \"\"\"The data needed to construct a section in the panel toolbar.\n\t    Contains a sequence of buttons that should be added in the section.\n\t    If the buttons are checkable, we can optionally allow only one of them\n\t    to be selected at any given time by setting `exclusive=True`.\"\"\"\n\t    buttons: Sequence[QToolButton]\n\t    exclusive: bool = False\n", "    def __init__(self, *args: QToolButton, exclusive: bool = False) -> None:\n\t        self.buttons = args\n\t        self.exclusive = exclusive\n\tclass BasePanel(QWidget):\n\t    \"\"\"Base class implementing functionality shared between the edit and\n\t    proof panels.\"\"\"\n\t    graph_scene: GraphScene\n\t    graph_view: GraphView\n\t    toolbar: QToolBar\n\t    undo_stack: AnimatedUndoStack\n", "    file_path: Optional[str]\n\t    file_type: Optional[FileFormat]\n\t    def __init__(self, graph: GraphT, graph_scene: GraphScene) -> None:\n\t        super().__init__()\n\t        self.graph_scene = graph_scene\n\t        self.graph_view = GraphView(self.graph_scene)\n\t        self.undo_stack = AnimatedUndoStack(self)\n\t        # Use box layout that fills the entire tab\n\t        self.setLayout(QVBoxLayout())\n\t        self.layout().setSpacing(0)\n", "        self.toolbar = QToolBar()\n\t        self.layout().addWidget(self.toolbar)\n\t        self.splitter = QSplitter(self)\n\t        self.layout().addWidget(self.splitter)\n\t        self.splitter.addWidget(self.graph_view)\n\t        self.graph_view.set_graph(graph)\n\t        self.file_path = None\n\t        self.file_type = None\n\t        self._populate_toolbar()\n\t    @property\n", "    def graph(self) -> GraphT:\n\t        return self.graph_scene.g\n\t    def _populate_toolbar(self) -> None:\n\t        for section in self._toolbar_sections():\n\t            group = QButtonGroup(self, exclusive=section.exclusive)\n\t            for btn in section.buttons:\n\t                self.toolbar.addWidget(btn)\n\t                group.addButton(btn)\n\t            self.toolbar.addSeparator()\n\t    def _toolbar_sections(self) -> Iterator[ToolbarSection]:\n", "        raise NotImplementedError\n\t    def clear_graph(self) -> None:\n\t        empty_graph = Graph()\n\t        assert isinstance(empty_graph, GraphS)\n\t        cmd = SetGraph(self.graph_view, empty_graph)\n\t        self.undo_stack.push(cmd)\n\t    def select_all(self) -> None:\n\t        self.graph_scene.select_all()\n\t    def deselect_all(self) -> None:\n\t        self.graph_scene.clearSelection()\n", "    def copy_selection(self) -> GraphT:\n\t        selection = list(self.graph_scene.selected_vertices)\n\t        copied_graph = self.graph.subgraph_from_vertices(selection)\n\t        assert isinstance(copied_graph, GraphS)\n\t        return copied_graph\n"]}
{"filename": "zxlive/edit_panel.py", "chunked_list": ["import copy\n\tfrom fractions import Fraction\n\tfrom typing import Iterator, TypedDict, Callable\n\tfrom PySide6.QtCore import Signal, QSize, Qt\n\tfrom PySide6.QtWidgets import QToolButton, QInputDialog, QSplitter, QListView, QListWidget, QListWidgetItem\n\tfrom PySide6.QtGui import QShortcut, QIcon, QPen, QPainter, QColor, QPixmap\n\tfrom pyzx import EdgeType, VertexType\n\tfrom sympy import sympify\n\tfrom .vitem import ZX_GREEN, ZX_RED, H_YELLOW\n\tfrom .eitem import HAD_EDGE_BLUE\n", "from .utils import get_data\n\tfrom .common import VT, GraphT, ToolType\n\tfrom .base_panel import BasePanel, ToolbarSection\n\tfrom .commands import (\n\t    AddEdge, AddNode, MoveNode, SetGraph, UpdateGraph, ChangePhase, ChangeNodeColor,\n\t    ChangeEdgeColor)\n\tfrom .dialogs import show_error_msg\n\tfrom .graphscene import EditGraphScene\n\tclass DrawPanelNodeType(TypedDict):\n\t    text: str\n", "    type: VertexType.Type\n\t    icon: tuple[str, str]\n\tVERTICES: dict[str, DrawPanelNodeType] = {\n\t    \"Z\": {\"text\": \"Z spider\", \"type\": VertexType.Z, \"icon\": (\"circle\", ZX_GREEN)},\n\t    \"X\": {\"text\": \"X spider\", \"type\": VertexType.X, \"icon\": (\"circle\", ZX_RED)},\n\t    \"H\": {\"text\": \"H box\", \"type\": VertexType.H_BOX, \"icon\": (\"square\", H_YELLOW)},\n\t    \"T\": {\"text\": \"boundary\", \"type\": VertexType.BOUNDARY, \"icon\": (\"circle\", \"black\")},\n\t}\n\tEDGES: dict[str, DrawPanelNodeType] = {\n\t    \"SIMPLE\": {\"text\": \"Simple\", \"type\": EdgeType.SIMPLE, \"icon\": (\"line\", \"black\")},\n", "    \"HADAMARD\": {\"text\": \"Hadamard\", \"type\": EdgeType.HADAMARD, \"icon\": (\"dashed_line\", HAD_EDGE_BLUE)},\n\t}\n\tclass GraphEditPanel(BasePanel):\n\t    \"\"\"Panel for the edit mode of ZX live.\"\"\"\n\t    graph_scene: EditGraphScene\n\t    start_derivation_signal = Signal(object)\n\t    _curr_ety: EdgeType.Type\n\t    _curr_vty: VertexType.Type\n\t    def __init__(self, graph: GraphT) -> None:\n\t        self.graph_scene = EditGraphScene()\n", "        self.graph_scene.vertices_moved.connect(self._vert_moved)\n\t        self.graph_scene.vertex_double_clicked.connect(self._vert_double_clicked)\n\t        self.graph_scene.vertex_added.connect(self._add_vert)\n\t        self.graph_scene.edge_added.connect(self._add_edge)\n\t        self._curr_vty = VertexType.Z\n\t        self._curr_ety = EdgeType.SIMPLE\n\t        super().__init__(graph, self.graph_scene)\n\t        self.sidebar = QSplitter(self)\n\t        self.sidebar.setOrientation(Qt.Vertical)\n\t        self.splitter.addWidget(self.sidebar)\n", "        self.vertex_list = self.create_list_widget(VERTICES, self._vty_clicked)\n\t        self.edge_list = self.create_list_widget(EDGES, self._ety_clicked)\n\t        self.sidebar.addWidget(self.vertex_list)\n\t        self.sidebar.addWidget(self.edge_list)\n\t    def create_list_widget(self, data: dict[str, DrawPanelNodeType], onclick: Callable[[EdgeType.Type], None]) -> QListWidget:\n\t        list_widget = QListWidget(self)\n\t        list_widget.setResizeMode(QListView.ResizeMode.Adjust)\n\t        list_widget.setViewMode(QListView.ViewMode.IconMode)\n\t        list_widget.setMovement(QListView.Movement.Static)\n\t        list_widget.setUniformItemSizes(True)\n", "        list_widget.setGridSize(QSize(60, 64))\n\t        list_widget.setWordWrap(True)\n\t        list_widget.setIconSize(QSize(24, 24))\n\t        for value in data.values():\n\t            icon = self.create_icon(*value[\"icon\"])\n\t            item = QListWidgetItem(icon, value[\"text\"])\n\t            item.setData(Qt.UserRole, value[\"type\"])\n\t            list_widget.addItem(item)\n\t        list_widget.itemClicked.connect(lambda x: onclick(x.data(Qt.UserRole)))\n\t        list_widget.setCurrentItem(list_widget.item(0))\n", "        return list_widget\n\t    def create_icon(self, shape: str, color: str) -> QIcon:\n\t        icon = QIcon()\n\t        pixmap = QPixmap(64, 64)\n\t        pixmap.fill(Qt.transparent)\n\t        painter = QPainter(pixmap)\n\t        painter.setRenderHint(QPainter.Antialiasing)\n\t        painter.setPen(QPen(QColor(\"black\"), 6))\n\t        painter.setBrush(QColor(color))\n\t        if shape == \"circle\":\n", "            painter.drawEllipse(4, 4, 56, 56)\n\t        elif shape == \"square\":\n\t            painter.drawRect(4, 4, 56, 56)\n\t        elif shape == \"line\":\n\t            painter.drawLine(0, 32, 64, 32)\n\t        elif shape == \"dashed_line\":\n\t            painter.setPen(QPen(QColor(color), 6, Qt.DashLine))\n\t            painter.drawLine(0, 32, 64, 32)\n\t        painter.end()\n\t        icon.addPixmap(pixmap)\n", "        return icon\n\t    def _toolbar_sections(self) -> Iterator[ToolbarSection]:\n\t        # Toolbar section for select, node, edge\n\t        icon_size = QSize(32, 32)\n\t        self.select = QToolButton(self, checkable=True, checked=True)  # Selected by default\n\t        self.vertex = QToolButton(self, checkable=True)\n\t        self.edge = QToolButton(self, checkable=True)\n\t        self.select.setToolTip(\"Select (s)\")\n\t        self.vertex.setToolTip(\"Add Vertex (v)\")\n\t        self.edge.setToolTip(\"Add Edge (e)\")\n", "        self.select.setIcon(QIcon(get_data(\"icons/tikzit-tool-select.svg\")))\n\t        self.vertex.setIcon(QIcon(get_data(\"icons/tikzit-tool-node.svg\")))\n\t        self.edge.setIcon(QIcon(get_data(\"icons/tikzit-tool-edge.svg\")))\n\t        self.select.setShortcut(\"s\")\n\t        self.vertex.setShortcut(\"v\")\n\t        self.edge.setShortcut(\"e\")\n\t        self.select.setIconSize(icon_size)\n\t        self.vertex.setIconSize(icon_size)\n\t        self.edge.setIconSize(icon_size)\n\t        self.select.clicked.connect(lambda: self._tool_clicked(ToolType.SELECT))\n", "        self.vertex.clicked.connect(lambda: self._tool_clicked(ToolType.VERTEX))\n\t        self.edge.clicked.connect(lambda: self._tool_clicked(ToolType.EDGE))\n\t        yield ToolbarSection(self.select, self.vertex, self.edge, exclusive=True)\n\t        self.start_derivation = QToolButton(self, text=\"Start Derivation\")\n\t        self.start_derivation.clicked.connect(self._start_derivation)\n\t        yield ToolbarSection(self.start_derivation)\n\t    def _tool_clicked(self, tool: ToolType) -> None:\n\t        self.graph_scene.curr_tool = tool\n\t    def _vty_clicked(self, vty: VertexType.Type) -> None:\n\t        self._curr_vty = vty\n", "        selected = list(self.graph_scene.selected_vertices)\n\t        if len(selected) > 0:\n\t            cmd = ChangeNodeColor(self.graph_view, selected, vty)\n\t            self.undo_stack.push(cmd)\n\t    def _ety_clicked(self, ety: EdgeType.Type) -> None:\n\t        self._curr_ety = ety\n\t        self.graph_scene.curr_ety = ety\n\t        selected = list(self.graph_scene.selected_edges)\n\t        if len(selected) > 0:\n\t            cmd = ChangeEdgeColor(self.graph_view, selected, ety)\n", "            self.undo_stack.push(cmd)\n\t    def _add_vert(self, x: float, y: float) -> None:\n\t        cmd = AddNode(self.graph_view, x, y, self._curr_vty)\n\t        self.undo_stack.push(cmd)\n\t    def _add_edge(self, u: VT, v: VT) -> None:\n\t        cmd = AddEdge(self.graph_view, u, v, self._curr_ety)\n\t        self.undo_stack.push(cmd)\n\t    def _vert_moved(self, vs: list[tuple[VT, float, float]]) -> None:\n\t        cmd = MoveNode(self.graph_view, vs)\n\t        self.undo_stack.push(cmd)\n", "    def _vert_double_clicked(self, v: VT) -> None:\n\t        if self.graph.type(v) == VertexType.BOUNDARY:\n\t            input_, ok = QInputDialog.getText(\n\t                self, \"Input Dialog\", \"Enter Qubit Index:\"\n\t            )\n\t            try:\n\t                input_ = int(input_.strip())\n\t                self.graph.set_qubit(v, input_)\n\t            except ValueError:\n\t                show_error_msg(\"Wrong Input Type\", \"Please enter a valid input (e.g. 1, 2)\")\n", "            return\n\t        input_, ok = QInputDialog.getText(\n\t            self, \"Input Dialog\", \"Enter Desired Phase Value:\"\n\t        )\n\t        if not ok:\n\t            return\n\t        try:\n\t            new_phase = string_to_phase(input_)\n\t        except ValueError:\n\t            show_error_msg(\"Wrong Input Type\", \"Please enter a valid input (e.g. 1/2, 2)\")\n", "            return\n\t        cmd = ChangePhase(self.graph_view, v, new_phase)\n\t        self.undo_stack.push(cmd)\n\t    def paste_graph(self, graph: GraphT) -> None:\n\t        if graph is None: return\n\t        new_g = copy.deepcopy(self.graph_scene.g)\n\t        new_verts, new_edges = new_g.merge(graph.translate(0.5,0.5))\n\t        cmd = UpdateGraph(self.graph_view,new_g)\n\t        self.undo_stack.push(cmd)\n\t        self.graph_scene.select_vertices(new_verts)\n", "    def delete_selection(self) -> None:\n\t        selection = list(self.graph_scene.selected_vertices)\n\t        selected_edges = list(self.graph_scene.selected_edges)\n\t        if not selection and not selected_edges: return\n\t        new_g = copy.deepcopy(self.graph_scene.g)\n\t        self.graph_scene.clearSelection()\n\t        new_g.remove_edges(selected_edges)\n\t        new_g.remove_vertices(selection)\n\t        cmd = SetGraph(self.graph_view,new_g) if len(selection) > 128 \\\n\t            else UpdateGraph(self.graph_view,new_g)\n", "        self.undo_stack.push(cmd)\n\t    def _start_derivation(self) -> None:\n\t        self.start_derivation_signal.emit(copy.deepcopy(self.graph_scene.g))\n\tdef string_to_phase(string: str) -> Fraction:\n\t    if not string: \n\t        return Fraction(0)\n\t    try:\n\t        s = string.lower().replace(' ', '')\n\t        s = s.replace('\\u03c0', '').replace('pi', '')\n\t        if '.' in s or 'e' in s:\n", "            return Fraction(float(s))\n\t        elif '/' in s:\n\t            a, b = s.split(\"/\", 2)\n\t            if not a:\n\t                return Fraction(1, int(b))\n\t            if a == '-':\n\t                a = '-1'\n\t            return Fraction(int(a), int(b))\n\t        else:\n\t            return Fraction(int(s))\n", "    except ValueError:\n\t        return sympify(string)\n"]}
{"filename": "zxlive/mainwindow.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n\t#     Copyright (C) 2023 - Aleks Kissinger\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#    http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\tfrom typing import Callable, Optional, TypedDict\n\timport copy\n\tfrom PySide6.QtCore import QFile, QFileInfo, QTextStream, QIODevice, QSettings, QByteArray, QEvent\n\tfrom PySide6.QtGui import QAction, QKeySequence, QCloseEvent\n\tfrom PySide6.QtWidgets import QMessageBox, QMainWindow, QWidget, QVBoxLayout, QTabWidget\n\tfrom pyzx.graph.base import BaseGraph\n\tfrom .commands import AddRewriteStep\n", "from .base_panel import BasePanel\n\tfrom .edit_panel import GraphEditPanel\n\tfrom .proof_panel import ProofPanel\n\tfrom .construct import *\n\tfrom .dialogs import ImportGraphOutput, create_new_rewrite, export_proof_dialog, import_diagram_dialog, export_diagram_dialog, show_error_msg, FileFormat\n\tfrom .common import GraphT\n\tfrom pyzx import Graph, simplify, Circuit\n\tclass MainWindow(QMainWindow):\n\t    \"\"\"A simple window containing a single `GraphView`\n\t    This is just an example, and should be replaced with\n", "    something more sophisticated.\n\t    \"\"\"\n\t    edit_panel: GraphEditPanel\n\t    proof_panel: ProofPanel\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        conf = QSettings(\"zxlive\", \"zxlive\")\n\t        self.setWindowTitle(\"zxlive\")\n\t        w = QWidget(self)\n\t        w.setLayout(QVBoxLayout())\n", "        self.setCentralWidget(w)\n\t        w.layout().setContentsMargins(0, 0, 0, 0)\n\t        w.layout().setSpacing(0)\n\t        self.resize(1200, 800)\n\t        # restore the window from the last time it was opened\n\t        geom = conf.value(\"main_window_geometry\")\n\t        if geom and isinstance(geom, QByteArray):\n\t            self.restoreGeometry(geom)\n\t        self.show()\n\t        tab_widget = QTabWidget()\n", "        w.layout().addWidget(tab_widget)\n\t        tab_widget.setTabsClosable(True)\n\t        tab_widget.currentChanged.connect(self.tab_changed)\n\t        tab_widget.tabCloseRequested.connect(lambda i: tab_widget.removeTab(i))\n\t        self.tab_widget = tab_widget\n\t        # Currently the copied part is stored internally, and is not made available to the clipboard.\n\t        # We could do this by using pyperclip.\n\t        self.copied_graph: Optional[GraphT] = None\n\t        menu = self.menuBar()\n\t        new_graph = self._new_action(\"&New\", self.new_graph, QKeySequence.StandardKey.New,\n", "            \"Reinitialize with an empty graph\")\n\t        open_file = self._new_action(\"&Open...\", self.open_file, QKeySequence.StandardKey.Open,\n\t            \"Open a file-picker dialog to choose a new diagram\")\n\t        close_action = self._new_action(\"Close\", self.close_action, QKeySequence.StandardKey.Close,\n\t            \"Closes the window\")\n\t        close_action.setShortcuts([QKeySequence(QKeySequence.StandardKey.Close), QKeySequence(\"Ctrl+W\")])\n\t        # TODO: We should remember if we have saved the diagram before,\n\t        # and give an open to overwrite this file with a Save action\n\t        save_file = self._new_action(\"&Save\", self.save_file, QKeySequence.StandardKey.Save,\n\t            \"Save the diagram by overwriting the previous loaded file.\")\n", "        save_as = self._new_action(\"Save &as...\", self.save_as, QKeySequence.StandardKey.SaveAs,\n\t            \"Opens a file-picker dialog to save the diagram in a chosen file format\")\n\t        file_menu = menu.addMenu(\"&File\")\n\t        file_menu.addAction(new_graph)\n\t        file_menu.addAction(open_file)\n\t        file_menu.addSeparator()\n\t        file_menu.addAction(close_action)\n\t        file_menu.addAction(save_file)\n\t        file_menu.addAction(save_as)\n\t        undo = self._new_action(\"Undo\", self.undo, QKeySequence.StandardKey.Undo,\n", "            \"Undoes the last action\")\n\t        redo = self._new_action(\"Redo\", self.redo, QKeySequence.StandardKey.Redo,\n\t            \"Redoes the last action\")\n\t        cut_action = self._new_action(\"Cut\", self.cut_graph,QKeySequence.StandardKey.Cut,\n\t            \"Cut the selected part of the diagram\")\n\t        copy_action = self._new_action(\"&Copy\", self.copy_graph,QKeySequence.StandardKey.Copy,\n\t            \"Copy the selected part of the diagram\")\n\t        paste_action = self._new_action(\"Paste\", self.paste_graph,QKeySequence.StandardKey.Paste,\n\t            \"Paste the copied part of the diagram\")\n\t        delete_action = self._new_action(\"Delete\", self.delete_graph,QKeySequence.StandardKey.Delete,\n", "            \"Delete the selected part of the diagram\")\n\t        delete_action.setShortcuts([QKeySequence(QKeySequence.StandardKey.Delete),QKeySequence(\"Backspace\")])\n\t        new_tab = self._new_action(\"new_tab\", self.new_graph, QKeySequence.StandardKey.AddTab,\n\t            \"Create a new tab\")\n\t        self.addAction(new_tab)\n\t        select_all = self._new_action(\"Select &All\", self.select_all, QKeySequence.StandardKey.SelectAll, \"Select all\")\n\t        deselect_all = self._new_action(\"&Deselect All\", self.deselect_all, QKeySequence.StandardKey.Deselect, \"Deselect all\")\n\t        deselect_all.setShortcuts([QKeySequence(QKeySequence.StandardKey.Deselect), QKeySequence(\"Ctrl+D\")])\n\t        edit_menu = menu.addMenu(\"&Edit\")\n\t        edit_menu.addAction(undo)\n", "        edit_menu.addAction(redo)\n\t        edit_menu.addSeparator()\n\t        edit_menu.addAction(cut_action)\n\t        edit_menu.addAction(copy_action)\n\t        edit_menu.addAction(paste_action)\n\t        edit_menu.addAction(delete_action)\n\t        edit_menu.addSeparator()\n\t        edit_menu.addAction(select_all)\n\t        edit_menu.addAction(deselect_all)\n\t        zoom_in  = self._new_action(\"Zoom in\", self.zoom_in,   QKeySequence.StandardKey.ZoomIn,\"Zooms in by a fixed amount\")\n", "        zoom_out = self._new_action(\"Zoom out\", self.zoom_out, QKeySequence.StandardKey.ZoomOut, \"Zooms out by a fixed amount\")\n\t        zoom_in.setShortcuts([QKeySequence(QKeySequence.StandardKey.ZoomIn), QKeySequence(\"Ctrl+=\")])\n\t        fit_view = self._new_action(\"Fit view\", self.fit_view, QKeySequence(\"C\"), \"Fits the view to the diagram\")\n\t        self.addAction(zoom_in)\n\t        self.addAction(zoom_out)\n\t        self.addAction(fit_view)\n\t        view_menu = menu.addMenu(\"&View\")\n\t        view_menu.addAction(zoom_in)\n\t        view_menu.addAction(zoom_out)\n\t        view_menu.addAction(fit_view)\n", "        new_rewrite = self._new_action(\"Create new rewrite\", lambda: create_new_rewrite(self), None, \"Create a new rewrite\")\n\t        rewrite_menu = menu.addMenu(\"&Rewrite\")\n\t        rewrite_menu.addAction(new_rewrite)\n\t        simplify_actions = []\n\t        for simp in simplifications.values():\n\t            simplify_actions.append(self._new_action(simp[\"text\"], self.apply_pyzx_reduction(simp), None, simp[\"tool_tip\"]))\n\t        self.simplify_menu = menu.addMenu(\"&Simplify\")\n\t        for action in simplify_actions:\n\t            self.simplify_menu.addAction(action)\n\t        self.simplify_menu.menuAction().setVisible(False)\n", "        graph = construct_circuit()\n\t        self.new_graph(graph)\n\t    def _new_action(self,name:str,trigger:Callable,shortcut:QKeySequence | QKeySequence.StandardKey | None,tooltip:str) -> QAction:\n\t        action = QAction(name, self)\n\t        action.setStatusTip(tooltip)\n\t        action.triggered.connect(trigger)\n\t        if shortcut:\n\t            action.setShortcut(shortcut)\n\t        return action\n\t    @property\n", "    def active_panel(self) -> Optional[BasePanel]:\n\t        current_widget = self.tab_widget.currentWidget()\n\t        if current_widget is not None:\n\t            assert isinstance(current_widget, BasePanel)\n\t            return current_widget\n\t        return None\n\t    def closeEvent(self, e: QCloseEvent) -> None:\n\t        while self.active_panel is not None:  # We close all the tabs and ask the user if they want to save progress\n\t            success = self.close_action()\n\t            if not success:\n", "                e.ignore()  # Abort the closing\n\t                return\n\t        # save the shape/size of this window on close\n\t        conf = QSettings(\"zxlive\", \"zxlive\")\n\t        conf.setValue(\"main_window_geometry\", self.saveGeometry())\n\t        e.accept()\n\t    def undo(self,e: QEvent) -> None:\n\t        if self.active_panel is None: return\n\t        self.active_panel.undo_stack.undo()\n\t    def redo(self,e: QEvent) -> None:\n", "        if self.active_panel is None: return\n\t        self.active_panel.undo_stack.redo()\n\t    def update_tab_name(self, clean:bool) -> None:\n\t        i = self.tab_widget.currentIndex()\n\t        name = self.tab_widget.tabText(i)\n\t        if name.endswith(\"*\"): name = name[:-1]\n\t        if not clean: name += \"*\"\n\t        self.tab_widget.setTabText(i,name)\n\t    def tab_changed(self, i: int) -> None:\n\t        if isinstance(self.active_panel, ProofPanel):\n", "            self.simplify_menu.menuAction().setVisible(True)\n\t        else:\n\t            self.simplify_menu.menuAction().setVisible(False)\n\t    def open_file(self) -> None:\n\t        out = import_diagram_dialog(self)\n\t        if out is not None:\n\t            assert self.active_panel is not None\n\t            name = QFileInfo(out.file_path).baseName()\n\t            if isinstance(out, ImportGraphOutput):\n\t                self.new_graph(out.g, name)\n", "            else:\n\t                graph = out.p.graphs[-1]\n\t                self.new_deriv(graph, name)\n\t                proof_panel: BasePanel = self.active_panel\n\t                proof_panel.proof_model = out.p\n\t                proof_panel.step_view.setModel(proof_panel.proof_model)\n\t                proof_panel.step_view.setCurrentIndex(proof_panel.proof_model.index(len(proof_panel.proof_model.steps), 0))\n\t                proof_panel.step_view.selectionModel().selectionChanged.connect(proof_panel._proof_step_selected)\n\t            self.active_panel.file_path = out.file_path\n\t            self.active_panel.file_type = out.file_type\n", "    def close_action(self) -> bool:\n\t        assert self.active_panel is not None\n\t        i = self.tab_widget.currentIndex()\n\t        if i == -1: # no tabs open\n\t            self.close()\n\t        if not self.active_panel.undo_stack.isClean():\n\t            name = self.tab_widget.tabText(i).replace(\"*\",\"\")\n\t            answer = QMessageBox.question(self, \"Save Changes\",\n\t                            f\"Do you wish to save your changes to {name} before closing?\",\n\t                            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel)\n", "            if answer == QMessageBox.StandardButton.Cancel: return False\n\t            if answer == QMessageBox.StandardButton.Yes:\n\t                val = self.save_file()\n\t                if not val: return False\n\t        self.tab_widget.tabCloseRequested.emit(i)\n\t        return True\n\t    def save_file(self) -> bool:\n\t        assert self.active_panel is not None\n\t        if self.active_panel.file_path is None:\n\t            return self.save_as()\n", "        if self.active_panel.file_type == FileFormat.QASM:\n\t            show_error_msg(\"Can't save to circuit file\",\n\t                \"You imported this file from a circuit description. You can currently only save it in a graph format.\")\n\t            return self.save_as()\n\t        if isinstance(self.active_panel, ProofPanel):\n\t            data = self.active_panel.proof_model.to_json()\n\t        elif self.active_panel.file_type in (FileFormat.QGraph, FileFormat.Json):\n\t            data = self.active_panel.graph.to_json()\n\t        elif self.active_panel.file_type == FileFormat.TikZ:\n\t            data = self.active_panel.graph.to_tikz()\n", "        else:\n\t            raise TypeError(\"Unknown file format\", self.active_panel.file_type)\n\t        file = QFile(self.active_panel.file_path)\n\t        if not file.open(QIODevice.OpenModeFlag.WriteOnly | QIODevice.OpenModeFlag.Text):\n\t            show_error_msg(\"Could not write to file\")\n\t            return False\n\t        out = QTextStream(file)\n\t        out << data\n\t        file.close()\n\t        self.active_panel.undo_stack.setClean()\n", "        return True\n\t    def save_as(self) -> bool:\n\t        assert self.active_panel is not None\n\t        if isinstance(self.active_panel, ProofPanel):\n\t            out = export_proof_dialog(self.active_panel.proof_model, self)\n\t        else:\n\t            out = export_diagram_dialog(self.active_panel.graph_scene.g, self)\n\t        if out is None: return False\n\t        file_path, file_type = out\n\t        self.active_panel.file_path = file_path\n", "        self.active_panel.file_type = file_type\n\t        self.active_panel.undo_stack.setClean()\n\t        name = QFileInfo(file_path).baseName()\n\t        i = self.tab_widget.currentIndex()\n\t        self.tab_widget.setTabText(i,name)\n\t        return True\n\t    def cut_graph(self) -> None:\n\t        assert self.active_panel is not None\n\t        if isinstance(self.active_panel, GraphEditPanel):\n\t            self.copied_graph = self.active_panel.copy_selection()\n", "            self.active_panel.delete_selection()\n\t    def copy_graph(self) -> None:\n\t        assert self.active_panel is not None\n\t        self.copied_graph = self.active_panel.copy_selection()\n\t    def paste_graph(self) -> None:\n\t        assert self.active_panel is not None\n\t        if isinstance(self.active_panel, GraphEditPanel) and self.copied_graph is not None:\n\t            self.active_panel.paste_graph(self.copied_graph)\n\t    def delete_graph(self) -> None:\n\t        assert self.active_panel is not None\n", "        if isinstance(self.active_panel, GraphEditPanel):\n\t            self.active_panel.delete_selection()\n\t    def new_graph(self, graph:Optional[GraphT] = None, name:Optional[str]=None) -> None:\n\t        graph = graph or Graph()\n\t        panel = GraphEditPanel(graph)\n\t        panel.start_derivation_signal.connect(self.new_deriv)\n\t        if name is None: name = \"New Graph\"\n\t        self.tab_widget.addTab(panel, name)\n\t        self.tab_widget.setCurrentWidget(panel)\n\t        panel.undo_stack.cleanChanged.connect(self.update_tab_name)\n", "    def new_deriv(self, graph:GraphT, name:Optional[str]=None) -> None:\n\t        panel = ProofPanel(graph)\n\t        if name is None: name = \"New Proof\"\n\t        self.tab_widget.addTab(panel, name)\n\t        self.tab_widget.setCurrentWidget(panel)\n\t        panel.undo_stack.cleanChanged.connect(self.update_tab_name)\n\t    def select_all(self) -> None:\n\t        assert self.active_panel is not None\n\t        self.active_panel.select_all()\n\t    def deselect_all(self) -> None:\n", "        assert self.active_panel is not None\n\t        self.active_panel.deselect_all()\n\t    def zoom_in(self) -> None:\n\t        assert self.active_panel is not None\n\t        self.active_panel.graph_view.zoom_in()\n\t    def zoom_out(self) -> None:\n\t        assert self.active_panel is not None\n\t        self.active_panel.graph_view.zoom_out()\n\t    def fit_view(self) -> None:\n\t        assert self.active_panel is not None\n", "        self.active_panel.graph_view.fit_view()\n\t    def apply_pyzx_reduction(self, reduction: SimpEntry) -> Callable[[],None]:\n\t        def reduce() -> None:\n\t            assert self.active_panel is not None\n\t            old_graph = self.active_panel.graph\n\t            new_graph = copy.deepcopy(old_graph)\n\t            reduction[\"function\"](new_graph)\n\t            cmd = AddRewriteStep(self.active_panel.graph_view, new_graph, self.active_panel.step_view, reduction[\"text\"])\n\t            self.active_panel.undo_stack.push(cmd)\n\t        return reduce\n", "class SimpEntry(TypedDict):\n\t    text: str\n\t    tool_tip: str\n\t    function: Callable[[BaseGraph], int | None | BaseGraph] | Callable[[BaseGraph | Circuit], int]\n\tsimplifications: dict[str, SimpEntry] = {\n\t    'bialg_simp': {\"text\": \"bialg_simp\", \"tool_tip\":\"bialg_simp\", \"function\": simplify.bialg_simp,},\n\t    'spider_simp': {\"text\": \"spider_simp\", \"tool_tip\":\"spider_simp\", \"function\": simplify.spider_simp},\n\t    'id_simp': {\"text\": \"id_simp\", \"tool_tip\":\"id_simp\", \"function\": simplify.id_simp},\n\t    'phase_free_simp': {\"text\": \"phase_free_simp\", \"tool_tip\":\"phase_free_simp\", \"function\": simplify.phase_free_simp},\n\t    'pivot_simp': {\"text\": \"pivot_simp\", \"tool_tip\":\"pivot_simp\", \"function\": simplify.pivot_simp},\n", "    'pivot_gadget_simp': {\"text\": \"pivot_gadget_simp\", \"tool_tip\":\"pivot_gadget_simp\", \"function\": simplify.pivot_gadget_simp},\n\t    'pivot_boundary_simp': {\"text\": \"pivot_boundary_simp\", \"tool_tip\":\"pivot_boundary_simp\", \"function\": simplify.pivot_boundary_simp},\n\t    'gadget_simp': {\"text\": \"gadget_simp\", \"tool_tip\":\"gadget_simp\", \"function\": simplify.gadget_simp},\n\t    'lcomp_simp': {\"text\": \"lcomp_simp\", \"tool_tip\":\"lcomp_simp\", \"function\": simplify.lcomp_simp},\n\t    'clifford_simp': {\"text\": \"clifford_simp\", \"tool_tip\":\"clifford_simp\", \"function\": simplify.clifford_simp},\n\t    'tcount': {\"text\": \"tcount\", \"tool_tip\":\"tcount\", \"function\": simplify.tcount},\n\t    'to_gh': {\"text\": \"to_gh\", \"tool_tip\":\"to_gh\", \"function\": simplify.to_gh},\n\t    'to_rg': {\"text\": \"to_rg\", \"tool_tip\":\"to_rg\", \"function\": simplify.to_rg},\n\t    'full_reduce': {\"text\": \"full_reduce\", \"tool_tip\":\"full_reduce\", \"function\": simplify.full_reduce},\n\t    'teleport_reduce': {\"text\": \"teleport_reduce\", \"tool_tip\":\"teleport_reduce\", \"function\": simplify.teleport_reduce},\n", "    'reduce_scalar': {\"text\": \"reduce_scalar\", \"tool_tip\":\"reduce_scalar\", \"function\": simplify.reduce_scalar},\n\t    'supplementarity_simp': {\"text\": \"supplementarity_simp\", \"tool_tip\":\"supplementarity_simp\", \"function\": simplify.supplementarity_simp},\n\t    'to_clifford_normal_form_graph': {\"text\": \"to_clifford_normal_form_graph\", \"tool_tip\":\"to_clifford_normal_form_graph\", \"function\": simplify.to_clifford_normal_form_graph},\n\t}"]}
