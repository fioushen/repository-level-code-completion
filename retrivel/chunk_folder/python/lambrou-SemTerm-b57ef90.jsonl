{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\tsetup(\n\t    name=\"semterm\",\n\t    version=\"0.5.0\",\n\t    description=\"The Semantic Terminal\",\n\t    long_description=\"The Semantic Terminal\",\n\t    author=\"Lambrou\",\n\t    author_email=\"alexanderlambrou0602@gmail.com\",\n\t    packages=find_packages(),\n\t    include_package_data=True,\n", "    entry_points={\n\t        \"console_scripts\": [\n\t            \"semterm = semterm.main:main\",\n\t        ],\n\t    },\n\t    install_requires=[\n\t        \"langchain\",\n\t        \"tiktoken\",\n\t        \"pexpect\",\n\t        \"pydantic\",\n", "        \"openai\",\n\t    ],\n\t)\n"]}
{"filename": "semterm/main.py", "chunked_list": ["from semterm.config.Config import Config\n\tfrom semterm.agent.MrklAgent import MrklAgent\n\tfrom semterm.UI.UserInterface import UserInterface\n\tdef main():\n\t    config = Config()\n\t    agent = MrklAgent(config)\n\t    UserInterface(agent).start()\n\tif __name__ == \"__main__\":\n\t    main()  # pragma: no cover\n"]}
{"filename": "semterm/__init__.py", "chunked_list": []}
{"filename": "semterm/terminal/TerminalOutputParser.py", "chunked_list": ["import json\n\tfrom abc import ABC\n\tfrom typing import Union\n\tfrom langchain.agents.conversational_chat.output_parser import ConvoOutputParser\n\tfrom langchain.schema import AgentAction, AgentFinish\n\tfrom semterm.agent.TerminalAgentPrompt import FORMAT_INSTRUCTIONS\n\tfrom semterm.langchain_extensions.schema import AgentMistake\n\tclass TerminalOutputParser(ConvoOutputParser, ABC):\n\t    def get_format_instructions(self) -> str:\n\t        return FORMAT_INSTRUCTIONS\n", "    def parse(self, text: str) -> Union[AgentAction, AgentFinish]:\n\t        text = text.strip().replace(\"\\xa0\", \" \")\n\t        start_positions = [i for i, c in enumerate(text) if c == \"{\"]\n\t        end_positions = [i for i, c in enumerate(text) if c == \"}\"]\n\t        for start in start_positions:\n\t            for end in end_positions:\n\t                if start < end:  # ensure the end position is after the start\n\t                    try:\n\t                        cleaned_output = text[start : end + 1]\n\t                        response = json.loads(cleaned_output)\n", "                        action, action_input = (\n\t                            response[\"action\"],\n\t                            response[\"action_input\"],\n\t                        )\n\t                        if action == \"Final Answer\":\n\t                            return AgentFinish({\"output\": action_input}, text)\n\t                        else:\n\t                            return AgentAction(action, action_input, text)\n\t                    except json.JSONDecodeError:\n\t                        return AgentMistake(text, text)\n", "        # If we reach this point, no valid JSON was found in the text\n\t        return AgentFinish({\"output\": text}, text)\n"]}
{"filename": "semterm/terminal/SemanticTerminalProcess.py", "chunked_list": ["import getpass\n\timport re\n\timport signal\n\tfrom typing import Any\n\timport pexpect as pexpect\n\timport tiktoken\n\tfrom langchain.utilities import BashProcess\n\tfrom langchain.text_splitter import TokenTextSplitter\n\tclass SemanticTerminalProcess(BashProcess):\n\t    model_name: str = \"gpt-3.5-turbo\"\n", "    chunk_size: int = 500\n\t    def __init__(self, pid, print_terminal_output=True, timeout=20):\n\t        self.print_terminal_output = print_terminal_output\n\t        self.timeout = timeout\n\t        self.pid = pid\n\t        self.prompt = pid\n\t        self.process = self._initialize_persistent_process()\n\t        self.last_command_output = \"\"\n\t        self.incorrect_password_attempts = 0\n\t    def _initialize_persistent_process(self) -> pexpect.spawn:\n", "        process = pexpect.spawn(\n\t            \"bash\",\n\t            encoding=\"utf-8\",\n\t        )\n\t        process.expect(r\"\\$\")\n\t        process.sendline(\"PS1=\" + self.prompt)\n\t        process.expect_exact(self.prompt, timeout=10)\n\t        return process\n\t    @staticmethod\n\t    def _tiktoken_encoder(text: str, **kwargs: Any) -> int:\n", "        encoder = tiktoken.encoding_for_model(SemanticTerminalProcess.model_name)\n\t        return len(encoder.encode(text, **kwargs))\n\t    @staticmethod\n\t    def _get_last_n_tokens(text: str, n: int = chunk_size, overlap: int = 200) -> str:\n\t        \"\"\"Return last n tokens from the output.\"\"\"\n\t        text_splitter = TokenTextSplitter(\n\t            model_name=SemanticTerminalProcess.model_name,\n\t            chunk_size=n,\n\t            chunk_overlap=overlap,\n\t        )\n", "        split_text = text_splitter.split_text(text)\n\t        last = split_text[-1]\n\t        if SemanticTerminalProcess._tiktoken_encoder(last) < n:\n\t            return last\n\t        else:\n\t            return \"Truncated Output: ...\" + \"\".join(split_text[-2:])\n\t    def process_output(self, output: str, command: str) -> str:\n\t        \"\"\"Process the output.\"\"\"\n\t        return output\n\t    def _run_persistent(self, command: str) -> str:\n", "        \"\"\"Run commands and return final output.\"\"\"\n\t        self.command = command\n\t        if self.process is None:\n\t            raise ValueError(\"Process not initialized\")\n\t        print(\"semterm > \" + command)\n\t        try:\n\t            self.process.sendline(command)\n\t            self.process.expect([command, self.prompt], timeout=self.timeout)\n\t            self.last_command_output = self._handle_stdout(command)\n\t        except Exception as e:  # noqa - LLM is extremely error prone at the moment.\n", "            self.last_command_output = (\n\t                \"The last command resulted in an error. Error: \",\n\t                str(e),\n\t            )\n\t        if self.print_terminal_output:\n\t            print(self.last_command_output)\n\t        return SemanticTerminalProcess._get_last_n_tokens(self.last_command_output)\n\t    def _handle_stdout(self, command):\n\t        response = self._handle_terminal_expects(command)\n\t        return self._handle_terminal_response(command, response)\n", "    def _handle_terminal_response(self, command, response):\n\t        if response == \"password_request\":\n\t            return self._handle_password_request(command)\n\t        if response == \"incorrect_password\":\n\t            if self.incorrect_password_attempts > 2:\n\t                return \"Too many bad pass attempts.\"\n\t            self.incorrect_password_attempts += 1\n\t            return self._handle_password_request(command, self.incorrect_password_attempts)\n\t        elif response == \"prompt\":\n\t            return self.process.before\n", "        elif response == \"EOF\":\n\t            return f\"Process exited with error status: \" \\\n\t                   f\"{self.process.exitstatus}\"\n\t        elif response == \"TIMEOUT\":\n\t            return f\"Timeout reached. Most recent output: \" \\\n\t                   f\"{self.process.buffer}\"\n\t    def _handle_password_request(self, command, try_count=0):\n\t        try:\n\t            try_text = f\"{try_count} / 3 Attempts\\n\" if try_count > 0 else f\"\\n\"\n\t            signal.signal(signal.SIGINT, self.keyboard_interrupt_handler)\n", "            try:\n\t                self.process.expect_exact(':', timeout=1)\n\t            except pexpect.exceptions.TIMEOUT:  # pragma: no cover\n\t                pass\n\t            self.process.sendline(\n\t                getpass.getpass(\n\t                    try_text +\n\t                    f\"semterm is requesting your password to run the following command: {command}\\n\"\n\t                    f\"If you trust semterm, please enter your password below:\\n\"\n\t                    f\"(CTRL+C to Dismiss) Password for {getpass.getuser()}: \",\n", "                )\n\t            )\n\t            return self._handle_stdout(command)\n\t        except KeyboardInterrupt:\n\t            self.process.sendintr()\n\t            print(\"KeyboardInterrupt: Password not sent.\")\n\t            return \"User aborted password request.\"\n\t        finally:\n\t            signal.signal(signal.SIGINT, signal.default_int_handler)\n\t    def _handle_terminal_expects(self, command: str) -> str:\n", "        password_regex = re.compile(\n\t            r\"(password for|Enter password|Password:|'s password:)\", re.IGNORECASE\n\t        )\n\t        incorrect_password_regex = re.compile(\n\t            r\"(?i)(?!.*attempts)(incorrect password|password incorrect|wrong password|try \"\n\t            r\"again|wrong|incorrect)\"\n\t        )\n\t        expect_dict = {\n\t            \"prompt\": self.prompt,\n\t            \"password_request\": password_regex,\n", "            \"incorrect_password\": incorrect_password_regex,\n\t            \"EOF\": pexpect.EOF,\n\t            \"TIMEOUT\": pexpect.TIMEOUT,\n\t        }\n\t        list_index = self.process.expect(\n\t            list(expect_dict.values()), timeout=self.timeout\n\t        )\n\t        return list(expect_dict.keys())[list_index]\n\t    def get_most_recent_output(self):\n\t        return self.process.buffer\n", "    @staticmethod\n\t    def keyboard_interrupt_handler(sig, frame):\n\t        print(\"\\nPassword request cancelled.\")\n\t        raise KeyboardInterrupt\n"]}
{"filename": "semterm/terminal/SemanticTerminalManager.py", "chunked_list": ["from uuid import uuid4\n\tfrom semterm.terminal.SemanticTerminalProcess import SemanticTerminalProcess\n\tclass SemanticTerminalManager:\n\t    def __init__(self):\n\t        self.processes = {}\n\t    def create_process(self, print_terminal_output=True, timeout=20):\n\t        process = SemanticTerminalProcess(str(uuid4()), print_terminal_output, timeout)\n\t        self.processes[process.pid] = process\n\t        return process\n\t    def get_process(self, pid):\n", "        return self.processes.get(pid)\n\t    def get_most_recent_output(self, pid):\n\t        process = self.get_process(pid)\n\t        if process is not None:\n\t            return process.get_most_recent_output()\n"]}
{"filename": "semterm/terminal/__init__.py", "chunked_list": []}
{"filename": "semterm/terminal/TerminalTool.py", "chunked_list": ["from typing import Dict, Any, Union, Tuple, Sequence\n\tfrom uuid import uuid4\n\tfrom inspect import signature\n\tfrom langchain.tools.base import BaseTool\n\tfrom pydantic.decorator import validate_arguments\n\tfrom semterm.terminal.SemanticTerminalManager import SemanticTerminalManager\n\tclass TerminalTool(BaseTool):\n\t    name: str = \"Terminal\"\n\t    description: str = (\n\t        \"Executes commands in a terminal. Input should be valid commands, and the output will be any \"\n", "        \"output from running that command. If you are asked to do perform a task, it is likely the setup for the task \"\n\t        \"has not been done yet. \"\n\t        \"If you are unsure, use the Human tool to verify with the human that they want you to run all setup commands \"\n\t        \"as well. \"\n\t    )\n\t    manager: SemanticTerminalManager = SemanticTerminalManager()\n\t    @property\n\t    def func(self):\n\t        return self.manager.create_process().run\n\t    @property\n", "    def args(self) -> dict:\n\t        if self.args_schema is not None:\n\t            return self.args_schema.schema()[\"properties\"]\n\t        else:\n\t            inferred_model = validate_arguments(self.func).model\n\t            schema = inferred_model.schema()[\"properties\"]\n\t            valid_keys = signature(self.func).parameters\n\t            return {k: schema[k] for k in valid_keys if k not in (\"run_manager\", \"callbacks\")}\n\t    def _run(self, *args: Any, **kwargs: Any) -> str:\n\t        \"\"\"Use the tool.\"\"\"\n", "        return self.func(*args, **kwargs)\n\t    async def _arun(self, *args: Any, **kwargs: Any) -> str:  # pragma: no cover\n\t        \"\"\"Use the tool asynchronously.\"\"\"\n\t        if self.coroutine:\n\t            return await self.coroutine(*args, **kwargs)\n\t        raise NotImplementedError(\"Tool does not support async\")\n\t    def _to_args_and_kwargs(\n\t        self, tool_input: Union[str, Dict, list[str]]\n\t    ) -> Tuple[Tuple, Dict]:\n\t        \"\"\"Convert tool input to pydantic model.\"\"\"\n", "        args, kwargs = self._to_args_and_kwargs_b_compat(tool_input)\n\t        # For backwards compatibility. The tool must be run with a single input\n\t        all_args = list(args) + list(kwargs.values())\n\t        if len(all_args) != 1:\n\t            raise ValueError(\n\t                f\"Too many arguments to single-input tool {self.name}.\"\n\t                f\" Args: {all_args}\"\n\t            )\n\t        return tuple(all_args), {}\n\t    @staticmethod\n", "    def _to_args_and_kwargs_b_compat(\n\t        run_input: Union[str, Dict, list[str]]\n\t    ) -> Tuple[Sequence, dict]:\n\t        # For backwards compatability, if run_input is a string,\n\t        # pass as a positional argument.\n\t        if isinstance(run_input, str):\n\t            return (run_input,), {}\n\t        if isinstance(run_input, list):\n\t            return [], {\"command\": \";\".join(run_input)}\n\t        else:\n", "            return [], run_input\n"]}
{"filename": "semterm/UI/__init__.py", "chunked_list": []}
{"filename": "semterm/UI/UserInterface.py", "chunked_list": ["from semterm.agent.MrklAgent import MrklAgent\n\tclass UserInterface:\n\t    def __init__(self, agent: MrklAgent):\n\t        self.agent = agent\n\t    def start(self):\n\t        while True:\n\t            user_input = input(\"You > \")\n\t            if user_input.lower() == \"exit\":\n\t                break\n\t            response = self.agent.run(user_input)\n", "            print(\"\\rsemterm > \", response)\n"]}
{"filename": "semterm/config/Config.py", "chunked_list": ["import configparser\n\timport os\n\tclass Config:\n\t    def __init__(self):\n\t        self.config = configparser.ConfigParser()\n\t        self.config.read(Config.get_config_file_path())\n\t    def get(self):\n\t        return self.config\n\t    @staticmethod\n\t    def get_config_file_path():\n", "        src_dir = os.path.dirname(os.path.abspath(__file__))\n\t        config_file = os.path.join(src_dir, \"config.ini\")\n\t        return config_file\n"]}
{"filename": "semterm/config/__init__.py", "chunked_list": []}
{"filename": "semterm/output_discriminator/OutputDiscriminator.py", "chunked_list": []}
{"filename": "semterm/output_discriminator/OutputDiscriminatorPrompt.py", "chunked_list": []}
{"filename": "semterm/agent/TerminalAgentPrompt.py", "chunked_list": ["# flake8: noqa\n\tPREFIX = \"\"\"You are a Semantic Terminal. Users will ask for you to perform tasks, expecting you to use the Terminal \n\ttool. Use it often and go above and beyond in completing the users request. Remember that you don't have to run all your commands in one go. You can run a command, look at the \n\toutput, and then run a new command based on that output. You can also use the Terminal tool to run multiple commands.\n\tIf you need to install a program to use it, use the Human tool to get permission from the user and then install it.\n\tYour current directory is {current_directory}\n\t\"\"\"\n\tFORMAT_INSTRUCTIONS = \"\"\"Begin Response Format instructions. ---\n\tRespond to the user in one of two formats:\n\t**Option 1:**\n", "Use this if you want to use a tool.\n\tJSON formatted in the following schema:\n\tThought: Here is where you will plan out your next steps\n\t```json\n\t{{{{\n\t    \"action\": string \\\\ The action to take. Must be one of {tool_names}\n\t    \"action_input\": string or list of strings \\\\ The input to the action\n\t}}}}\n\t```\n\t**Option #2:**\n", "Use this if you want to respond directly to the human. JSON formatted in the following schema:\n\tThought: Here is where you will plan out your next steps\n\t```json\n\t{{{{\n\t    \"action\": \"Final Answer\",\n\t    \"action_input\": string \\\\ Use this to give a final answer or ask a question.\n\t}}}}\n\t```\n\t\"\"\"\n\tSUFFIX = \"\"\"You can use tools to complete tasks the user asks you to do. The tools you can use are:\n", "{{tools}}\n\t{format_instructions}\n\tUSER'S INPUT ---------\n\t{{{{input}}}}\n\tPlan out what you will do to complete the task and then respond with an action.\n\t\"\"\"\n\tTEMPLATE_TOOL_RESPONSE = \"\"\"Observation: \n\t{observation}\n\tUsing the information above, plan out what you will do next to complete the task and then complete it.\n\t\"\"\"\n"]}
{"filename": "semterm/agent/TerminalAgent.py", "chunked_list": ["import os\n\tfrom abc import ABC\n\tfrom typing import Sequence, Optional, List, Tuple, Any\n\tfrom langchain import BasePromptTemplate\n\tfrom langchain.agents import (\n\t    ConversationalChatAgent,\n\t    AgentOutputParser,\n\t)\n\tfrom langchain.tools import BaseTool\n\tfrom pydantic import Field\n", "from .TerminalAgentPrompt import (\n\t    PREFIX,\n\t    SUFFIX,\n\t    TEMPLATE_TOOL_RESPONSE,\n\t)\n\tfrom langchain.schema import (\n\t    AgentAction,\n\t    BaseOutputParser,\n\t    BaseMessage,\n\t    AIMessage,\n", "    SystemMessage,\n\t)\n\tfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\tclass TerminalAgent(ConversationalChatAgent, ABC):\n\t    output_parser: AgentOutputParser = Field(default_factory=TerminalOutputParser)\n\t    @classmethod\n\t    def create_prompt(\n\t        cls,\n\t        tools: Sequence[BaseTool],\n\t        system_message: str = PREFIX.format(current_directory=os.getcwd()),\n", "        human_message: str = SUFFIX,\n\t        input_variables: Optional[List[str]] = None,\n\t        output_parser: Optional[BaseOutputParser] = None,\n\t    ) -> BasePromptTemplate:\n\t        return super().create_prompt(\n\t            tools=tools,\n\t            system_message=system_message,\n\t            human_message=human_message,\n\t            input_variables=input_variables,\n\t            output_parser=output_parser or cls._get_default_output_parser(),\n", "        )\n\t    def _construct_scratchpad(\n\t        self, intermediate_steps: List[Tuple[AgentAction, str]]\n\t    ) -> List[BaseMessage]:\n\t        thoughts: List[BaseMessage] = []\n\t        for action, observation in intermediate_steps:\n\t            if action.tool == \"Human\":\n\t                thoughts.append(AIMessage(content=action.tool_input))\n\t                continue\n\t            if isinstance(action.tool_input, list):\n", "                observation = observation.replace(\";\".join(action.tool_input), \"\")\n\t            else:\n\t                observation = observation.replace(action.tool_input, \"\")\n\t            thoughts.append(AIMessage(content=action.log))\n\t            system_message = SystemMessage(\n\t                content=TEMPLATE_TOOL_RESPONSE.format(observation=observation)\n\t            )\n\t            thoughts.append(system_message)\n\t        return thoughts\n"]}
{"filename": "semterm/agent/__init__.py", "chunked_list": []}
{"filename": "semterm/agent/TerminalAgentExecutor.py", "chunked_list": ["from abc import ABC\n\tfrom typing import Dict, List, Tuple, Union, Optional\n\tfrom langchain.agents import AgentExecutor\n\tfrom langchain.agents.tools import InvalidTool\n\tfrom langchain.callbacks.manager import CallbackManagerForChainRun\n\tfrom langchain.schema import AgentAction, AgentFinish\n\tfrom langchain.tools import BaseTool\n\tfrom semterm.langchain_extensions.schema import AgentMistake\n\tclass TerminalAgentExecutor(AgentExecutor, ABC):\n\t    def _take_next_step(\n", "        self,\n\t        name_to_tool_map: Dict[str, BaseTool],\n\t        color_mapping: Dict[str, str],\n\t        inputs: Dict[str, str],\n\t        intermediate_steps: List[Tuple[AgentAction, str]],\n\t        run_manager: Optional[CallbackManagerForChainRun] = None,\n\t    ) -> Union[\n\t        AgentFinish, List[Tuple[AgentAction, str]], List[Tuple[AgentMistake, str]]\n\t    ]:\n\t        \"\"\"Take a single step in the thought-action-observation loop.\n", "        Override this to take control of how the agent makes and acts on choices.\n\t        \"\"\"\n\t        # Call the LLM to see what to do.\n\t        output = self.agent.plan(intermediate_steps, **inputs)\n\t        result = []\n\t        actions: List[AgentAction]\n\t        # If the tool chosen is the finishing tool, then we end and return.\n\t        if isinstance(output, AgentFinish):\n\t            return output\n\t        if isinstance(output, (AgentAction, AgentMistake)):\n", "            actions = [output]\n\t        for agent_action in actions:\n\t            if run_manager:\n\t                run_manager.on_agent_action(  # pragma: no cover\n\t                    agent_action,\n\t                    verbose=self.verbose,\n\t                    color=\"green\",\n\t                )\n\t            # Otherwise we lookup the tool\n\t            if agent_action.tool in name_to_tool_map:\n", "                tool = name_to_tool_map[agent_action.tool]\n\t                return_direct = tool.return_direct\n\t                color = color_mapping[agent_action.tool]\n\t                tool_run_kwargs = self.agent.tool_run_logging_kwargs()\n\t                if return_direct:\n\t                    tool_run_kwargs[\"llm_prefix\"] = \"\"\n\t                # We then call the tool on the tool input to get an observation\n\t                observation = tool.run(\n\t                    agent_action.tool_input,\n\t                    verbose=self.verbose,\n", "                    color=color,\n\t                    **tool_run_kwargs,\n\t                )\n\t            else:\n\t                tool_run_kwargs = self.agent.tool_run_logging_kwargs()\n\t                observation = InvalidTool().run(\n\t                    agent_action.tool,\n\t                    verbose=self.verbose,\n\t                    color=None,\n\t                    **tool_run_kwargs,\n", "                )\n\t            result.append((agent_action, observation))\n\t        return result\n"]}
{"filename": "semterm/agent/MrklAgent.py", "chunked_list": ["import os\n\tfrom langchain.agents import load_tools\n\tfrom langchain.chat_models import ChatOpenAI\n\tfrom langchain.memory import ConversationEntityMemory\n\tfrom semterm.agent.TerminalAgentPrompt import PREFIX\n\tfrom semterm.config.Config import Config\n\tfrom semterm.agent.TerminalAgent import TerminalAgent\n\tfrom semterm.agent.TerminalAgentExecutor import TerminalAgentExecutor\n\tfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\tfrom semterm.terminal.TerminalTool import TerminalTool\n", "from semterm.terminal.SemanticTerminalManager import SemanticTerminalManager\n\tfrom semterm.langchain_extensions.tools import MistakeTool, TerminalHumanTool\n\tclass MrklAgent:\n\t    def __init__(self, config: Config):\n\t        config = config.get()\n\t        self.verbose = config.getboolean(\"DEFAULT\", \"verbose\")\n\t        self.max_iterations = config.getint(\"DEFAULT\", \"max_iterations\")\n\t        self.timeout = config.getint(\"DEFAULT\", \"timeout\")\n\t        self.print_terminal_output = config.getboolean(\n\t            \"DEFAULT\", \"print_terminal_output\"\n", "        )\n\t        self.llm = ChatOpenAI(temperature=0)\n\t        self.tools = self.load_tools()\n\t        self.memory = self.initialize_memory()\n\t        self.terminal_agent = self.initialize_agent()\n\t        self.terminal_agent_executor = self.initialize_executor()\n\t    def load_tools(self):\n\t        tools = [\n\t            TerminalTool(manager=SemanticTerminalManager()),\n\t            TerminalHumanTool(),\n", "            MistakeTool(),\n\t        ]\n\t        return tools\n\t    def initialize_memory(self):\n\t        return ConversationEntityMemory(\n\t            llm=self.llm,\n\t            return_messages=True,\n\t            chat_history_key=\"chat_history\",\n\t        )\n\t    def initialize_agent(self):\n", "        return TerminalAgent.from_llm_and_tools(\n\t            self.llm,\n\t            self.tools,\n\t            memory=self.memory,\n\t            system_message=PREFIX.format(current_directory=os.getcwd()),\n\t            output_parser=TerminalOutputParser(),\n\t            verbose=self.verbose,\n\t        )\n\t    def initialize_executor(self):\n\t        return TerminalAgentExecutor.from_agent_and_tools(\n", "            self.terminal_agent,\n\t            self.tools,\n\t            memory=self.memory,\n\t            max_iterations=self.max_iterations,\n\t            verbose=self.verbose,\n\t        )\n\t    def run(self, user_input):\n\t        return self.terminal_agent_executor.run(input=user_input)\n"]}
{"filename": "semterm/langchain_extensions/schema.py", "chunked_list": ["from typing import NamedTuple\n\tclass AgentMistake(NamedTuple):\n\t    \"\"\"Class to use when an agent made a mistake and needs to be informed.\"\"\"\n\t    tool_input: str\n\t    log: str\n\t    tool: str = \"mistake_tool\"\n"]}
{"filename": "semterm/langchain_extensions/__init__.py", "chunked_list": []}
{"filename": "semterm/langchain_extensions/tools.py", "chunked_list": ["from abc import ABC\n\tfrom typing import Optional\n\tfrom langchain.callbacks.manager import (\n\t    CallbackManagerForToolRun,\n\t)\n\tfrom langchain.tools import BaseTool, HumanInputRun\n\tclass MistakeTool(BaseTool):\n\t    \"\"\"Tool that is run when invalid tool name is encountered by agent.\"\"\"\n\t    name = \"mistake_tool\"\n\t    description = \"DO NOT USE.\"  # For the agent to know not to use it.\n", "    def _run(self, agent_input: str) -> str:\n\t        \"\"\"Use the tool.\"\"\"\n\t        return (\n\t            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n\t        )\n\t    async def _arun(self, agent_input: str) -> str:\n\t        \"\"\"Use the tool asynchronously.\"\"\"\n\t        return (\n\t            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n\t        )\n", "class TerminalHumanTool(HumanInputRun, ABC):\n\t    description = (\n\t        \"You can ask a human for guidance when you think you \"\n\t        \"got stuck or you are not sure what to do next. \"\n\t        \"The input should be a question for the human.\"\n\t        \"NEVER ask the user for their password.\"\n\t        \"Example: \"\n\t        \"```json\"\n\t        '{{\"action\": \"Human\", \"action_input\": \"What is the meaning of life?\"}}'\n\t        \"```\"\n", "    )\n\t    def _run(\n\t        self,\n\t        query: str,\n\t        run_manager: Optional[CallbackManagerForToolRun] = None,\n\t    ) -> str:\n\t        \"\"\"Use the Human input tool.\"\"\"\n\t        if \"password\" in query.lower():\n\t            return (\n\t                f\"You should never use this tool to ask the user their password. \"\n", "                f\"If you are not trying to get the user's password, just replace the \"\n\t                f\"word 'password' with 'passphrase' or something else.\"\n\t            )\n\t        self.prompt_func(\"semterm > \" + query)\n\t        return input(\"You > \")\n"]}
{"filename": "tests/test_main.py", "chunked_list": ["from unittest.mock import MagicMock, patch\n\timport semterm.main as semterm_main\n\tfrom semterm.UI.UserInterface import UserInterface\n\tfrom semterm.agent.MrklAgent import MrklAgent\n\tfrom semterm.config.Config import Config\n\tdef test_main():\n\t    with patch(\"semterm.main.Config\", MagicMock(spec=Config)) as config_mock, patch(\n\t        \"semterm.main.MrklAgent\", MagicMock(spec=MrklAgent)\n\t    ) as agent_mock, patch(\n\t        \"semterm.main.UserInterface\", MagicMock(spec=UserInterface)\n", "    ) as ui_mock:\n\t        semterm_main.main()\n\t    # Check that the classes are instantiated and the start method is called on the UserInterface instance\n\t    config_mock.assert_called_once()\n\t    agent_mock.assert_called_once_with(config=config_mock.return_value)\n\t    ui_mock.assert_called_once_with(agent=agent_mock.return_value)\n\t    ui_mock.return_value.start.assert_called_once()\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/conftest.py", "chunked_list": ["import os\n\tfrom unittest.mock import MagicMock\n\timport pytest\n\tfrom langchain.base_language import BaseLanguageModel\n\tfrom langchain.schema import BaseMemory, LLMResult, Generation\n\tfrom langchain.tools import BaseTool\n\tfrom semterm.agent.TerminalAgent import TerminalAgent\n\tfrom semterm.agent.TerminalAgentPrompt import PREFIX\n\tfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\t@pytest.fixture\n", "def mock_tools():\n\t    tools = [MagicMock(spec=BaseTool) for _ in range(3)]\n\t    # Set custom name and description for each tool\n\t    for idx, tool in enumerate(tools):\n\t        tool.name = f\"Tool{idx + 1}\"\n\t        tool.description = f\"Tool{idx + 1} description\"\n\t    return tools\n\t@pytest.fixture\n\tdef terminal_agent(mock_tools, monkeypatch):\n\t    memory_mock = MagicMock(spec=BaseMemory)\n", "    system_message = PREFIX.format(current_directory=os.getcwd())\n\t    output_parser_mock = MagicMock(spec=TerminalOutputParser)\n\t    verbose_mock = False\n\t    def mock_generate_prompt(*args, **kwargs):\n\t        return LLMResult(generations=[[Generation(text=\"Hello\")]])\n\t    llm_mock = MagicMock(spec=BaseLanguageModel)\n\t    llm_mock.generate_prompt = mock_generate_prompt\n\t    # Instantiate the TerminalAgent using the from_llm_and_tools method\n\t    terminal_agent_instance = TerminalAgent.from_llm_and_tools(\n\t        llm=llm_mock,\n", "        tools=mock_tools,\n\t        memory=memory_mock,\n\t        system_message=system_message,\n\t        output_parser=output_parser_mock,\n\t        verbose=verbose_mock,\n\t    )\n\t    return terminal_agent_instance\n"]}
{"filename": "tests/tools/test_tools.py", "chunked_list": ["from unittest.mock import patch\n\timport pytest\n\tfrom semterm.langchain_extensions.tools import MistakeTool, TerminalHumanTool\n\tclass TestMistakeTool:\n\t    @pytest.fixture\n\t    def mistake_tool(self):\n\t        return MistakeTool()\n\t    def test_run(self, mistake_tool):\n\t        agent_input = \"invalid_input\"\n\t        expected_output = (\n", "            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n\t        )\n\t        output = mistake_tool.run(agent_input)\n\t        assert output == expected_output\n\t    @pytest.mark.asyncio\n\t    async def test_arun(self, mistake_tool):\n\t        agent_input = \"invalid_input\"\n\t        expected_output = (\n\t            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n\t        )\n", "        output = await mistake_tool.arun(agent_input)\n\t        assert output == expected_output\n\tclass TestTerminalHumanTool:\n\t    @pytest.fixture\n\t    def human_tool(self):\n\t        return TerminalHumanTool()\n\t    def test_run(self, human_tool):\n\t        agent_input = \"What is the meaning of life?\"\n\t        expected_output = \"You > \"\n\t        with patch(\"builtins.input\", return_value=expected_output):\n", "            output = human_tool.run(agent_input)\n\t        assert output == expected_output\n\t    def test_run_with_password_request(self, human_tool):\n\t        agent_input = \"What is your password?\"\n\t        expected_output = (\n\t            f\"You should never use this tool to ask the user their password. \"\n\t            f\"If you are not trying to get the user's password, just replace the \"\n\t            f\"word 'password' with 'passphrase' or something else.\"\n\t        )\n\t        output = human_tool.run(agent_input)\n", "        assert output == expected_output\n"]}
{"filename": "tests/tools/__init__.py", "chunked_list": []}
{"filename": "tests/terminal/test_TerminalOutputParser.py", "chunked_list": ["import pytest\n\tfrom typing import Union\n\tfrom langchain.schema import AgentAction, AgentFinish\n\tfrom semterm.agent.TerminalAgentPrompt import FORMAT_INSTRUCTIONS\n\tfrom semterm.langchain_extensions.schema import AgentMistake\n\tfrom semterm.terminal.TerminalOutputParser import (\n\t    TerminalOutputParser,\n\t)\n\tclass TestTerminalOutputParser:\n\t    @pytest.fixture\n", "    def parser(self):\n\t        return TerminalOutputParser()\n\t    def test_get_format_instructions(self, parser):\n\t        assert parser.get_format_instructions() == FORMAT_INSTRUCTIONS\n\t    @pytest.mark.parametrize(\n\t        \"text, expected\",\n\t        [\n\t            (\n\t                '{\"action\": \"Final Answer\", \"action_input\": \"42\"}',\n\t                AgentFinish(\n", "                    {\"output\": \"42\"}, '{\"action\": \"Final Answer\", \"action_input\": \"42\"}'\n\t                ),\n\t            ),\n\t            (\n\t                'Something before {\"action\": \"Test Action\", \"action_input\": \"test input\"} and after',\n\t                AgentAction(\n\t                    \"Test Action\",\n\t                    \"test input\",\n\t                    'Something before {\"action\": \"Test Action\", \"action_input\": \"test input\"} and after',\n\t                ),\n", "            ),\n\t            (\n\t                \"This is a text without valid JSON\",\n\t                AgentFinish(\n\t                    {\"output\": \"This is a text without valid JSON\"},\n\t                    \"This is a text without valid JSON\",\n\t                ),\n\t            ),\n\t            (\n\t                \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n", "                AgentMistake(\n\t                    \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n\t                    \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n\t                ),\n\t            ),\n\t        ],\n\t    )\n\t    def test_parse(self, parser, text: str, expected: Union[AgentAction, AgentFinish]):\n\t        result = parser.parse(text)\n\t        assert result == expected\n"]}
{"filename": "tests/terminal/test_SemanticTerminalManager.py", "chunked_list": ["import pytest\n\tfrom unittest.mock import MagicMock\n\tfrom semterm.terminal.SemanticTerminalManager import SemanticTerminalManager\n\tfrom semterm.terminal.SemanticTerminalProcess import SemanticTerminalProcess\n\tclass TestSemanticTerminalManager:\n\t    @pytest.fixture\n\t    def semantic_terminal_manager(self):\n\t        return SemanticTerminalManager()\n\t    @pytest.fixture\n\t    def mock_semantic_terminal_process(self, monkeypatch):\n", "        mock_instance = MagicMock()\n\t        mock_instance.pid = \"mock_pid\"\n\t        monkeypatch.setattr(\n\t            SemanticTerminalProcess, \"__new__\", MagicMock(return_value=mock_instance)\n\t        )\n\t        return mock_instance\n\t    def test_create_process(self, semantic_terminal_manager):\n\t        process = semantic_terminal_manager.create_process()\n\t        assert process.pid in semantic_terminal_manager.processes\n\t    def test_get_process(self, semantic_terminal_manager):\n", "        process = semantic_terminal_manager.create_process()\n\t        fetched_process = semantic_terminal_manager.get_process(process.pid)\n\t        assert process == fetched_process\n\t    def test_get_most_recent_output(self, semantic_terminal_manager, monkeypatch):\n\t        monkeypatch.setattr(\n\t            SemanticTerminalProcess,\n\t            \"get_most_recent_output\",\n\t            MagicMock(return_value=\"test_output\"),\n\t        )\n\t        process = semantic_terminal_manager.create_process()\n", "        output = semantic_terminal_manager.get_most_recent_output(process.pid)\n\t        assert output == \"test_output\"\n\t    def test_get_most_recent_output_invalid_pid(self, semantic_terminal_manager):\n\t        output = semantic_terminal_manager.get_most_recent_output(\"invalid_pid\")\n\t        assert output is None\n"]}
{"filename": "tests/terminal/__init__.py", "chunked_list": []}
{"filename": "tests/terminal/test_TerminalTool.py", "chunked_list": ["from contextlib import contextmanager\n\timport pytest\n\tfrom unittest.mock import MagicMock, patch, Mock, create_autospec\n\tfrom pydantic import BaseModel\n\tfrom pydantic.decorator import validate_arguments\n\tfrom semterm.terminal import TerminalTool, SemanticTerminalManager\n\tfrom semterm.terminal.SemanticTerminalProcess import SemanticTerminalProcess\n\tclass MockSemanticTerminalManager(SemanticTerminalManager.SemanticTerminalManager):\n\t    def __init__(self, *args, **kwargs):\n\t        super().__init__(*args, **kwargs)\n", "    def create_process(self, *args, **kwargs):\n\t        return MockSemanticTerminalProcess()\n\tclass MockSemanticTerminalProcess(SemanticTerminalProcess):\n\t    def __init__(self, *args, **kwargs):\n\t        pass\n\t    def _initialize_persistent_process(self):\n\t        return None\n\t    def run(self, *args, **kwargs):\n\t        return \"Mocked response\"\n\t    def _run(self, *args, **kwargs):\n", "        return \"Mocked response\"\n\tclass TestTerminalTool:\n\t    @pytest.fixture(autouse=True)\n\t    def setup_terminal_tool(self):\n\t        self.terminal_tool = TerminalTool.TerminalTool(\n\t            manager=MockSemanticTerminalManager()\n\t        )\n\t    def test_func(self):\n\t        func = self.terminal_tool.func\n\t        assert func() == \"Mocked response\"\n", "    def test_run(self):\n\t        result = self.terminal_tool._run(\"example_command\")\n\t        assert result == \"Mocked response\"\n\t    def test_args_with_args_schema(self):\n\t        class ArgsSchema(BaseModel):\n\t            arg1: int\n\t            arg2: str\n\t        self.terminal_tool.args_schema = ArgsSchema\n\t        expected_args = {\n\t            \"arg1\": {\"title\": \"Arg1\", \"type\": \"integer\"},\n", "            \"arg2\": {\"title\": \"Arg2\", \"type\": \"string\"},\n\t        }\n\t        assert self.terminal_tool.args == expected_args\n\t    def test_args_without_args_schema(self):\n\t        def dummy_function(arg1: int, arg2: str):\n\t            return \"Dummy response\"\n\t        type(self.terminal_tool).func = property(lambda _: dummy_function)\n\t        expected_args = {\n\t            \"arg1\": {\"title\": \"Arg1\", \"type\": \"integer\"},\n\t            \"arg2\": {\"title\": \"Arg2\", \"type\": \"string\"},\n", "        }\n\t        assert self.terminal_tool.args == expected_args\n\t    def test_to_args_and_kwargs(self):\n\t        args, kwargs = self.terminal_tool._to_args_and_kwargs(\"example_command\")\n\t        assert args == (\"example_command\",)\n\t        assert kwargs == {}\n\t        args, kwargs = self.terminal_tool._to_args_and_kwargs({\"key\": \"value\"})\n\t        assert args == (\"value\",)\n\t        assert kwargs == {}\n\t        args, kwargs = self.terminal_tool._to_args_and_kwargs([\"command1\", \"command2\"])\n", "        assert args == (\"command1;command2\",)\n\t        assert kwargs == {}\n\t        with pytest.raises(ValueError, match=r\"Too many arguments\"):\n\t            self.terminal_tool._to_args_and_kwargs(\n\t                {\"command1\": \"value\", \"command2\": \"value\"}\n\t            )\n\t    def test_to_args_and_kwargs_b_compat(self):\n\t        args, kwargs = self.terminal_tool._to_args_and_kwargs_b_compat(\n\t            \"example_command\"\n\t        )\n", "        assert args == (\"example_command\",)\n\t        assert kwargs == {}\n\t        args, kwargs = self.terminal_tool._to_args_and_kwargs_b_compat({\"key\": \"value\"})\n\t        assert args == []\n\t        assert kwargs == {\"key\": \"value\"}\n\t        args, kwargs = self.terminal_tool._to_args_and_kwargs_b_compat(\n\t            [\"command1\", \"command2\"]\n\t        )\n\t        assert args == []\n\t        assert kwargs == {\"command\": \"command1;command2\"}\n"]}
{"filename": "tests/terminal/test_SemanticTerminalProcess.py", "chunked_list": ["import types\n\timport pexpect\n\timport pytest\n\tfrom unittest.mock import MagicMock, patch, call\n\tfrom semterm.terminal.SemanticTerminalProcess import (\n\t    SemanticTerminalProcess,\n\t    TokenTextSplitter,\n\t)\n\tclass TestSemanticTerminalProcess:\n\t    @pytest.fixture\n", "    def semantic_terminal_process(self, monkeypatch):\n\t        original_method = SemanticTerminalProcess._initialize_persistent_process\n\t        monkeypatch.setattr(\n\t            SemanticTerminalProcess,\n\t            \"_initialize_persistent_process\",\n\t            MagicMock(return_value=MagicMock()),\n\t        )\n\t        instance = SemanticTerminalProcess(pid=\"test_pid\")\n\t        instance.original_initialize_persistent_process = types.MethodType(\n\t            original_method, instance\n", "        )\n\t        return instance\n\t    def test_initialize_persistent_process(\n\t            self, semantic_terminal_process, monkeypatch\n\t    ):\n\t        semantic_terminal_process._initialize_persistent_process = (\n\t            semantic_terminal_process.original_initialize_persistent_process\n\t        )\n\t        spawn_mock = MagicMock()\n\t        monkeypatch.setattr(pexpect, \"spawn\", spawn_mock)\n", "        semantic_terminal_process._initialize_persistent_process()\n\t        spawn_mock.assert_called_with(\"bash\", encoding=\"utf-8\")\n\t        spawn_mock.return_value.expect.assert_called_with(r\"\\$\")\n\t        spawn_mock.return_value.sendline.assert_called_with(\n\t            \"PS1=\" + semantic_terminal_process.prompt\n\t        )\n\t        spawn_mock.return_value.expect_exact.assert_called_with(\n\t            semantic_terminal_process.prompt, timeout=10\n\t        )\n\t    def test_tiktoken_encoder(self, semantic_terminal_process):\n", "        with patch(\"tiktoken.Encoding.encode\") as encode_mock:\n\t            encode_mock.return_value = \"test_encoded_value\" * 10\n\t            result = SemanticTerminalProcess._tiktoken_encoder(\"test_text\")\n\t            assert result == 10 * len(\"test_encoded_value\")\n\t    def test_get_last_n_tokens(self, semantic_terminal_process, monkeypatch):\n\t        text_splitter_mock = MagicMock()\n\t        monkeypatch.setattr(TokenTextSplitter, \"split_text\", text_splitter_mock)\n\t        text_splitter_mock.return_value = [\"sample1\", \"sample2\", \"sample3\"]\n\t        encoding_mock = MagicMock()\n\t        monkeypatch.setattr(SemanticTerminalProcess, \"_tiktoken_encoder\", encoding_mock)\n", "        encoding_mock.return_value = 100\n\t        result = SemanticTerminalProcess._get_last_n_tokens(\"some_text\", 250)\n\t        assert result == \"sample3\"\n\t    def test_get_last_n_tokens_last_two(self, semantic_terminal_process, monkeypatch):\n\t        text_splitter_mock = MagicMock()\n\t        monkeypatch.setattr(TokenTextSplitter, \"split_text\", text_splitter_mock)\n\t        text_splitter_mock.return_value = [\"sample1\", \"sample2\", \"sample3\"]\n\t        encoding_mock = MagicMock()\n\t        monkeypatch.setattr(SemanticTerminalProcess, \"_tiktoken_encoder\", encoding_mock)\n\t        encoding_mock.return_value = 100\n", "        result = SemanticTerminalProcess._get_last_n_tokens(\"some_text\", 2, 1)\n\t        assert result == \"Truncated Output: ...sample2sample3\"\n\t    def test_process_output(self, semantic_terminal_process):\n\t        output = \"output\"\n\t        command = \"command\"\n\t        result = semantic_terminal_process.process_output(output, command)\n\t        assert result == output\n\t    def test_run_persistent_basic_command(self, semantic_terminal_process, monkeypatch):\n\t        semantic_terminal_process.process = MagicMock()\n\t        semantic_terminal_process.process.after = \"test_prompt\"\n", "        semantic_terminal_process.process.expect.return_value = 0\n\t        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n\t        semantic_terminal_process._run_persistent(\"ls\")\n\t        semantic_terminal_process.process.sendline.assert_has_calls(\n\t            [call(\"ls\")], any_order=False\n\t        )\n\t        assert semantic_terminal_process.prompt in semantic_terminal_process.process.expect.call_args[0][0]\n\t    def test_run_persistent_elevated_command(self, semantic_terminal_process, monkeypatch):\n\t        fake_password = \"password123\"\n\t        semantic_terminal_process.process = MagicMock()\n", "        semantic_terminal_process.process.after = \"test_prompt\"\n\t        semantic_terminal_process.process.expect.return_value = 1\n\t        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n\t        monkeypatch.setattr(\"getpass.getpass\", MagicMock(return_value=fake_password))\n\t        semantic_terminal_process._run_persistent(\"sudo ls\")\n\t        semantic_terminal_process.process.sendline.assert_has_calls(\n\t            [call(\"sudo ls\"), call(fake_password)], any_order=False\n\t        )\n\t        assert semantic_terminal_process.prompt in semantic_terminal_process.process.expect.call_args[0][0]\n\t    def test_run_persistent_not_init(self, semantic_terminal_process, monkeypatch):\n", "        semantic_terminal_process.process = None\n\t        with pytest.raises(ValueError, match=r\"not initialized\"):\n\t            semantic_terminal_process._run_persistent(\"ls\")\n\t    def test_run_persistent_exception(self, semantic_terminal_process, monkeypatch):\n\t        semantic_terminal_process.process = MagicMock()\n\t        semantic_terminal_process.process.sendline = MagicMock()\n\t        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n\t        semantic_terminal_process.process.expect.side_effect = Exception(\n\t            \"Test Exception\"\n\t        )\n", "        result = semantic_terminal_process._run_persistent(\"test_command\")\n\t        assert result.startswith(\n\t            \"The last command resulted in an error. Error: Test Exception\"\n\t        )\n\t    def test_run_persistent_pexpect_eof(self, semantic_terminal_process, monkeypatch):\n\t        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n\t        semantic_terminal_process.process = MagicMock()\n\t        semantic_terminal_process.process.sendline = MagicMock()\n\t        semantic_terminal_process.process.expect.return_value = None\n\t        semantic_terminal_process.process.after = pexpect.EOF\n", "        semantic_terminal_process.process.exitstatus = 1\n\t        result = semantic_terminal_process._run_persistent(\"test_command\")\n\t        assert result.startswith(\"Process exited with error status: 1\")\n\t    def test_handle_terminal_response_EOF(self, semantic_terminal_process):\n\t        command = \"command\"\n\t        response = \"EOF\"\n\t        semantic_terminal_process.process = MagicMock()\n\t        semantic_terminal_process.process.exitstatus = 1\n\t        result = semantic_terminal_process._handle_terminal_response(command, response)\n\t        assert result == \"Process exited with error status: 1\"\n", "    def test_handle_terminal_response_TIMEOUT(self, semantic_terminal_process):\n\t        command = \"command\"\n\t        response = \"TIMEOUT\"\n\t        semantic_terminal_process.process = MagicMock()\n\t        semantic_terminal_process.process.buffer = \"test buffer\"\n\t        result = semantic_terminal_process._handle_terminal_response(command, response)\n\t        assert result == \"Timeout reached. Most recent output: test buffer\"\n\t    @patch.object(SemanticTerminalProcess, '_handle_stdout', return_value='test')\n\t    @patch('getpass.getpass', return_value='password')\n\t    def test_handle_password_request_keyboard_interrupt(self, mock_getpass, mock_handle_stdout, semantic_terminal_process):\n", "        command = \"command\"\n\t        semantic_terminal_process.process.sendline.side_effect = self.raise_keyboard_interrupt\n\t        result = semantic_terminal_process._handle_password_request(command)\n\t        semantic_terminal_process.process.sendintr.assert_called_once()\n\t        assert result == \"User aborted password request.\"\n\t    def raise_keyboard_interrupt(*args, **kwargs):\n\t        raise KeyboardInterrupt\n\t    def test_keyboard_interrupt_handler(self):\n\t        with pytest.raises(KeyboardInterrupt):\n\t            SemanticTerminalProcess.keyboard_interrupt_handler(1, 2)\n", "    def test_handle_terminal_response_password_request(self, semantic_terminal_process):\n\t        command = \"command\"\n\t        response = \"password_request\"\n\t        semantic_terminal_process._handle_password_request = MagicMock(return_value=\"test\")\n\t        result = semantic_terminal_process._handle_terminal_response(command, response)\n\t        assert result == \"test\"\n\t    def test_handle_terminal_response_incorrect_password_exceeded_attempts(self, semantic_terminal_process):\n\t        command = \"command\"\n\t        response = \"incorrect_password\"\n\t        semantic_terminal_process.incorrect_password_attempts = 3\n", "        result = semantic_terminal_process._handle_terminal_response(command, response)\n\t        assert result == \"Too many bad pass attempts.\"\n\t    def test_handle_terminal_response_incorrect_password_within_attempts(self, semantic_terminal_process):\n\t        command = \"command\"\n\t        response = \"incorrect_password\"\n\t        semantic_terminal_process.incorrect_password_attempts = 2\n\t        semantic_terminal_process._handle_password_request = MagicMock(return_value=\"test\")\n\t        result = semantic_terminal_process._handle_terminal_response(command, response)\n\t        assert result == \"test\"\n\t        assert semantic_terminal_process.incorrect_password_attempts == 3\n", "    def test_get_most_recent_output(self, semantic_terminal_process):\n\t        semantic_terminal_process.process = MagicMock()\n\t        semantic_terminal_process.process.buffer = \"test_output\"\n\t        result = semantic_terminal_process.get_most_recent_output()\n\t        assert result == \"test_output\"\n"]}
{"filename": "tests/UI/test_UserInterface.py", "chunked_list": ["from unittest.mock import patch\n\tfrom semterm.UI.UserInterface import UserInterface\n\tclass TestUserInterface:\n\t    @patch(\"semterm.agent.MrklAgent.MrklAgent\")\n\t    @patch(\"builtins.print\")\n\t    @patch(\"builtins.input\", side_effect=[\"Hello\", \"exit\"])\n\t    def test_start(self, mock_input, mock_print, mock_mrkl_agent):\n\t        mock_mrkl_agent.return_value.run.side_effect = lambda x: f\"Mock response: {x}\"\n\t        user_interface = UserInterface(mock_mrkl_agent())\n\t        user_interface.start()\n", "        mock_input.assert_any_call(\"You > \")\n\t        mock_print.assert_any_call(\"\\rsemterm > \", \"Mock response: Hello\")\n\t        assert mock_input.call_count == 2\n\t        assert mock_print.call_count == 1\n"]}
{"filename": "tests/UI/__init__.py", "chunked_list": []}
{"filename": "tests/config/test_Config.py", "chunked_list": ["import os\n\timport configparser\n\tfrom semterm.config.Config import Config\n\tfrom unittest.mock import patch\n\timport pytest\n\tclass TestConfig:\n\t    @pytest.fixture(scope=\"class\", autouse=True)\n\t    def temp_dir(self, tmpdir_factory):\n\t        tmpdir = tmpdir_factory.mktemp(\"config\")\n\t        tmp_config_file = tmpdir.join(\"config.ini\")\n", "        tmp_config_file.write(\"[example]\\nkey=value\\n\")\n\t        return tmp_config_file\n\t    def test_config_initialization(self, temp_dir):\n\t        # Patch the get_config_file_path to return the path of the temporary config file\n\t        with patch(\n\t            \"semterm.config.Config.Config.get_config_file_path\",\n\t            return_value=temp_dir.strpath,\n\t        ):\n\t            config = Config()\n\t        # Check if the config object is an instance of configparser.ConfigParser\n", "        assert isinstance(config.config, configparser.ConfigParser)\n\t        # Test if the config file is read correctly\n\t        assert config.config.get(\"example\", \"key\") == \"value\"\n\t    def test_get_config_file_path(self, temp_dir):\n\t        # Patch the get_config_file_path to return the path of the temporary config file\n\t        with patch(\n\t            \"semterm.config.Config.Config.get_config_file_path\",\n\t            return_value=temp_dir.strpath,\n\t        ):\n\t            config = Config()\n", "            actual_path = config.get_config_file_path()\n\t        # Check if the mocked get_config_file_path method returns the path of the temporary config file\n\t        assert actual_path == temp_dir.strpath\n\t    def test_get(self):\n\t        config = Config()\n\t        assert isinstance(config.get(), configparser.ConfigParser)\n"]}
{"filename": "tests/agent/test_TerminalAgentExecutor.py", "chunked_list": ["from abc import ABC\n\timport pytest\n\tfrom unittest.mock import MagicMock, patch\n\tfrom langchain.schema import (\n\t    AgentAction,\n\t    AgentFinish,\n\t    BaseMemory,\n\t    SystemMessage,\n\t)\n\tfrom langchain.tools import BaseTool\n", "from pydantic.typing import NoneType\n\tfrom semterm.agent.TerminalAgent import TerminalAgent\n\tfrom semterm.agent.TerminalAgentExecutor import TerminalAgentExecutor\n\tfrom semterm.langchain_extensions.schema import AgentMistake\n\tclass MockTool(BaseTool, ABC):\n\t    name = \"mock_tool\"\n\t    description = \"Mock tool for testing purposes.\"\n\t    def _run(self, *args, **kwargs):\n\t        pass\n\t    def _arun(self):\n", "        pass\n\tclass TestTerminalAgentExecutor:\n\t    @pytest.fixture\n\t    def executor(self, mock_tools, terminal_agent):\n\t        memory = MagicMock(spec=BaseMemory)\n\t        return TerminalAgentExecutor.from_agent_and_tools(\n\t            terminal_agent,\n\t            [MockTool(name=\"Tool1\"), MockTool(name=\"Tool2\"), MockTool(name=\"Tool3\")],\n\t            max_iterations=10,\n\t            verbose=True,\n", "            memory=memory,\n\t        )\n\t    @patch.object(\n\t        TerminalAgent,\n\t        \"plan\",\n\t        return_value=AgentFinish(\n\t            return_values={\"output\": \"42\"},\n\t            log='{\"action\": \"Final Answer\", \"action_input\": \"42\"}',\n\t        ),\n\t    )\n", "    def test_take_next_step_returns_finish(self, plan_mock, executor):\n\t        # Test that _take_next_step returns AgentFinish when the output is an instance of AgentFinish\n\t        output = AgentFinish(\n\t            {\"output\": \"42\"}, '{\"action\": \"Final Answer\", \"action_input\": \"42\"}'\n\t        )\n\t        result = executor._take_next_step({}, {}, {}, [])\n\t        assert result == output\n\t    @patch.object(\n\t        TerminalAgent,\n\t        \"plan\",\n", "        return_value=AgentAction(tool=\"tool1\", tool_input=\"input1\", log=\"input1\"),\n\t    )\n\t    @patch.object(MockTool, \"run\", return_value=\"observation1\")\n\t    def test_take_next_step_returns_actions(self, run_mock, plan_mock, executor):\n\t        # Test that _take_next_step returns a list of AgentAction and observation tuples\n\t        name_to_tool_map = {\"tool1\": MockTool()}\n\t        color_mapping = {\"tool1\": \"red\"}\n\t        inputs = {\"input1\": \"value1\"}\n\t        intermediate_steps = []\n\t        result = executor._take_next_step(\n", "            name_to_tool_map, color_mapping, inputs, intermediate_steps\n\t        )\n\t        assert len(result) == 1\n\t        assert isinstance(result[0][0], AgentAction)\n\t        assert result[0][0].tool == \"tool1\"\n\t        assert result[0][0].tool_input == \"input1\"\n\t        assert isinstance(result[0][1], str)\n\t        assert result[0][1] == \"observation1\"\n\t    @patch.object(\n\t        TerminalAgent,\n", "        \"plan\",\n\t        return_value=AgentMistake(\n\t            log=\"Invalid input\", tool_input=\"input1\", tool=\"tool1\"\n\t        ),\n\t    )\n\t    def test_take_next_step_returns_mistakes(self, plan_mock, executor):\n\t        # Test that _take_next_step returns a list of AgentMistake and observation tuples\n\t        name_to_tool_map = {\"tool1\": MockTool()}\n\t        color_mapping = {\"tool1\": \"red\"}\n\t        inputs = {\"chat_history\": [SystemMessage(content=\"Hello\")], \"input\": \"value1\"}\n", "        intermediate_steps = []\n\t        result = executor._take_next_step(\n\t            name_to_tool_map,\n\t            color_mapping,\n\t            inputs,\n\t            intermediate_steps,\n\t        )\n\t        assert len(result) == 1\n\t        assert isinstance(result[0][0], AgentMistake)\n\t        assert result[0][0].log == \"Invalid input\"\n", "        assert result[0][0].tool_input == \"input1\"\n\t        assert result[0][0].tool == \"tool1\"\n\t        assert isinstance(result[0][1], NoneType)\n\t    @patch.object(\n\t        TerminalAgent,\n\t        \"plan\",\n\t        return_value=AgentAction(\n\t            log=\"Unknown tool\", tool_input=\"input1\", tool=\"unknown_tool\"\n\t        ),\n\t    )\n", "    def test_take_next_step_returns_invalid_tool(self, plan_mock, executor):\n\t        # Test that _take_next_step returns a list of AgentMistake and observation tuples\n\t        name_to_tool_map = {\"tool1\": MockTool()}\n\t        color_mapping = {\"tool1\": \"red\"}\n\t        inputs = {\n\t            \"chat_history\": [SystemMessage(content=\"Hello\")],\n\t            \"input\": \"value1\",\n\t        }\n\t        intermediate_steps = []\n\t        result = executor._take_next_step(\n", "            name_to_tool_map,\n\t            color_mapping,\n\t            inputs,\n\t            intermediate_steps,\n\t        )\n\t        assert len(result) == 1\n\t        assert isinstance(result[0][0], AgentAction)\n\t        assert result[0][0].log == \"Unknown tool\"\n\t        assert result[0][0].tool_input == \"input1\"\n\t        assert result[0][0].tool == \"unknown_tool\"\n", "        assert result[0][1] == \"unknown_tool is not a valid tool, try another one.\"\n\t    @patch.object(\n\t        TerminalAgent,\n\t        \"plan\",\n\t        return_value=AgentAction(log=\"input1\", tool_input=\"input1\", tool=\"tool1\"),\n\t    )\n\t    def test_take_next_step_returns_directly(self, plan_mock, executor):\n\t        name_to_tool_map = {\"tool1\": MockTool(return_direct=True)}\n\t        color_mapping = {\"tool1\": \"green\"}\n\t        inputs = {\n", "            \"chat_history\": [SystemMessage(content=\"Hello\")],\n\t            \"input\": \"value1\",\n\t        }\n\t        intermediate_steps = []\n\t        result = executor._take_next_step(\n\t            name_to_tool_map,\n\t            color_mapping,\n\t            inputs,\n\t            intermediate_steps,\n\t        )\n", "        assert len(result) == 1\n\t        assert isinstance(result[0][0], AgentAction)\n\t        assert result[0][0].log == \"input1\"\n\t        assert result[0][0].tool_input == \"input1\"\n\t        assert result[0][0].tool == \"tool1\"\n\t        assert result[0][1] == None\n"]}
{"filename": "tests/agent/test_MrklAgent.py", "chunked_list": ["from functools import partial\n\timport pytest\n\tfrom unittest.mock import MagicMock, patch\n\tfrom langchain.agents import Agent, AgentExecutor\n\tfrom langchain.base_language import BaseLanguageModel\n\tfrom langchain.schema import BaseMemory\n\tfrom langchain.tools import BaseTool\n\tfrom semterm.agent.TerminalAgent import TerminalAgent\n\tfrom semterm.agent.TerminalAgentExecutor import TerminalAgentExecutor\n\tfrom semterm.config.Config import Config\n", "from semterm.agent.MrklAgent import MrklAgent\n\tfrom semterm.langchain_extensions.tools import MistakeTool\n\tfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\tfrom semterm.terminal.TerminalTool import TerminalTool\n\tclass TestMrklAgent:\n\t    @pytest.fixture\n\t    def mrkl_agent(self, monkeypatch):\n\t        config_mock = MagicMock(spec=Config)\n\t        config_parser_mock = MagicMock()\n\t        config_parser_mock.getboolean.return_value = False\n", "        config_parser_mock.getint.return_value = 10\n\t        config_mock.get.return_value = config_parser_mock\n\t        # Store the original methods as attributes of the instance\n\t        original_load_tools = MrklAgent.load_tools\n\t        original_initialize_memory = MrklAgent.initialize_memory\n\t        original_initialize_agent = MrklAgent.initialize_agent\n\t        original_initialize_executor = MrklAgent.initialize_executor\n\t        monkeypatch.setattr(MrklAgent, \"load_tools\", MagicMock())\n\t        monkeypatch.setattr(MrklAgent, \"initialize_memory\", MagicMock())\n\t        monkeypatch.setattr(MrklAgent, \"initialize_agent\", MagicMock())\n", "        monkeypatch.setattr(MrklAgent, \"initialize_executor\", MagicMock())\n\t        chat_openai_mock = MagicMock()\n\t        monkeypatch.setattr(\"semterm.agent.MrklAgent.ChatOpenAI\", chat_openai_mock)\n\t        agent = MrklAgent(config=config_mock)\n\t        agent.original_load_tools = partial(original_load_tools, agent)\n\t        agent.original_initialize_memory = partial(original_initialize_memory, agent)\n\t        agent.original_initialize_agent = partial(original_initialize_agent, agent)\n\t        agent.original_initialize_executor = partial(\n\t            original_initialize_executor, agent\n\t        )\n", "        return agent\n\t    def test_load_tools(self, mrkl_agent, monkeypatch):\n\t        load_tools_mock = MagicMock(return_value=[MagicMock(spec=BaseTool)])\n\t        terminal_tool_mock = MagicMock(spec=TerminalTool)\n\t        mistake_tool_mock = MagicMock(spec=MistakeTool)\n\t        monkeypatch.setattr(\"langchain.agents.load_tools\", load_tools_mock)\n\t        monkeypatch.setattr(\n\t            \"semterm.terminal.TerminalTool.TerminalTool\", terminal_tool_mock\n\t        )\n\t        monkeypatch.setattr(\n", "            \"semterm.langchain_extensions.tools.MistakeTool\", mistake_tool_mock\n\t        )\n\t        tools = mrkl_agent.original_load_tools()\n\t        assert isinstance(tools, list)\n\t        assert all(isinstance(tool, BaseTool) for tool in tools)\n\t        assert any(isinstance(tool, TerminalTool) for tool in tools)\n\t    def test_initialize_memory(self, mrkl_agent, monkeypatch):\n\t        base_language_model_mock = MagicMock(spec=BaseLanguageModel)\n\t        monkeypatch.setattr(\n\t            \"langchain.base_language.BaseLanguageModel\",\n", "            MagicMock(return_value=base_language_model_mock),\n\t        )\n\t        # Set the MagicMock instance as the 'llm' attribute of mrkl_agent\n\t        mrkl_agent.llm = base_language_model_mock\n\t        memory = mrkl_agent.original_initialize_memory()\n\t        assert isinstance(memory, BaseMemory)\n\t    def test_initialize_agent(self, mrkl_agent, monkeypatch):\n\t        # Mock the objects used by the method\n\t        base_language_model_mock = MagicMock(spec=BaseLanguageModel)\n\t        terminal_agent_mock = MagicMock(spec=TerminalAgent)\n", "        terminal_output_parser_mock = MagicMock(spec=TerminalOutputParser)\n\t        # Set the MagicMock instances as the attributes of mrkl_agent\n\t        mrkl_agent.llm = base_language_model_mock\n\t        mrkl_agent.tools = [MagicMock(spec=BaseTool)]\n\t        mrkl_agent.memory = MagicMock(spec=BaseMemory)\n\t        mrkl_agent.verbose = False\n\t        # Mock the constructors and methods\n\t        monkeypatch.setattr(\n\t            \"langchain.base_language.BaseLanguageModel\",\n\t            MagicMock(return_value=base_language_model_mock),\n", "        )\n\t        monkeypatch.setattr(\n\t            \"semterm.agent.TerminalAgent.TerminalAgent.from_llm_and_tools\",\n\t            MagicMock(return_value=terminal_agent_mock),\n\t        )\n\t        monkeypatch.setattr(\n\t            \"semterm.terminal.TerminalOutputParser\", terminal_output_parser_mock\n\t        )\n\t        agent = mrkl_agent.original_initialize_agent()\n\t        # Assert that the agent is an instance of a subclass of the Agent class\n", "        assert issubclass(agent.__class__, Agent)\n\t    def test_initialize_executor(self, mrkl_agent, monkeypatch):\n\t        # Mock the objects used by the method\n\t        terminal_agent_executor_mock = MagicMock(spec=TerminalAgentExecutor)\n\t        # Set the MagicMock instances as the attributes of mrkl_agent\n\t        mrkl_agent.terminal_agent = MagicMock(spec=TerminalAgent)\n\t        mrkl_agent.tools = [MagicMock(spec=BaseTool)]\n\t        mrkl_agent.memory = MagicMock(spec=BaseMemory)\n\t        mrkl_agent.max_iterations = 10\n\t        mrkl_agent.verbose = False\n", "        # Mock the constructors and methods\n\t        monkeypatch.setattr(\n\t            \"semterm.agent.TerminalAgentExecutor.TerminalAgentExecutor.from_agent_and_tools\",\n\t            MagicMock(return_value=terminal_agent_executor_mock),\n\t        )\n\t        executor = mrkl_agent.original_initialize_executor()\n\t        # Assert that the executor is an instance of a subclass of the BaseExecutor class\n\t        assert issubclass(executor.__class__, AgentExecutor)\n\t    def test_run(self, mrkl_agent):\n\t        user_input = \"test_input\"\n", "        mrkl_agent.terminal_agent_executor.run = MagicMock()\n\t        mrkl_agent.run(user_input)\n\t        mrkl_agent.terminal_agent_executor.run.assert_called_with(input=user_input)\n"]}
{"filename": "tests/agent/test_TerminalAgent.py", "chunked_list": ["import os\n\timport pytest\n\tfrom unittest.mock import MagicMock\n\tfrom langchain.base_language import BaseLanguageModel\n\tfrom langchain.prompts import SystemMessagePromptTemplate\n\tfrom langchain.tools import BaseTool\n\tfrom langchain.schema import (\n\t    AgentAction,\n\t    BaseMessage,\n\t    AIMessage,\n", "    SystemMessage,\n\t    BaseMemory,\n\t)\n\tfrom semterm.agent.TerminalAgent import TerminalAgent\n\tfrom semterm.agent.TerminalAgentPrompt import PREFIX, SUFFIX\n\tfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\tclass TestTerminalAgent:\n\t    def test_create_prompt(self, terminal_agent, mock_tools):\n\t        system_message = PREFIX.format(current_directory=os.getcwd())\n\t        human_message = SUFFIX\n", "        input_variables = [\"input\", \"chat_history\", \"agent_scratchpad\"]\n\t        prompt = TerminalAgent.create_prompt(\n\t            tools=mock_tools,\n\t            system_message=system_message,\n\t            human_message=human_message,\n\t            input_variables=input_variables,\n\t        )\n\t        # Extract properties from the returned ChatPromptTemplate\n\t        system_message_from_prompt = prompt.messages[0].format_messages()[0].content\n\t        human_message_from_prompt = (\n", "            prompt.messages[2].format_messages(input=\"test input\")[0].content\n\t        )\n\t        # Assert that the properties have the expected values\n\t        assert system_message_from_prompt == system_message\n\t        assert all(tool.name in human_message_from_prompt for tool in mock_tools)\n\t        assert all(tool.description in human_message_from_prompt for tool in mock_tools)\n\t        assert prompt.input_variables == input_variables\n\t    def test_construct_scratchpad(self, terminal_agent):\n\t        intermediate_steps = [\n\t            (AgentAction(tool=\"Human\", tool_input=\"cd ..\", log=\"cd ..\"), \"\"),\n", "            (\n\t                AgentAction(\n\t                    tool=\"TerminalTool\", tool_input=\"ls\", log=\"ls command executed\"\n\t                ),\n\t                \"file1 file2\",\n\t            ),\n\t            (\n\t                AgentAction(\n\t                    tool=\"TerminalTool\",\n\t                    tool_input=[\"cd ..\", \"ls\"],\n", "                    log=\"['cd ..', 'ls']\",\n\t                ),\n\t                \"file1 file2\",\n\t            ),\n\t        ]\n\t        scratchpad = terminal_agent._construct_scratchpad(intermediate_steps)\n\t        assert isinstance(scratchpad, list)\n\t        assert all(isinstance(msg, BaseMessage) for msg in scratchpad)\n\t        assert len(scratchpad) == 5\n\t        assert isinstance(scratchpad[0], AIMessage)\n", "        assert scratchpad[0].content == \"cd ..\"\n\t        assert isinstance(scratchpad[1], AIMessage)\n\t        assert scratchpad[1].content == \"ls command executed\"\n\t        assert isinstance(scratchpad[2], SystemMessage)\n\t        assert scratchpad[2].content.startswith(\"Observation:\")\n\t        assert isinstance(scratchpad[3], AIMessage)\n\t        assert scratchpad[3].content == \"['cd ..', 'ls']\"\n"]}
{"filename": "tests/agent/__init__.py", "chunked_list": []}
{"filename": "tests/agent/test_TerminalAgentPrompt.py", "chunked_list": ["import semterm.agent.TerminalAgentPrompt as TerminalAgentPrompt\n\tdef test_terminal_agent_prompt_constants():\n\t    assert hasattr(\n\t        TerminalAgentPrompt, \"TEMPLATE_TOOL_RESPONSE\"\n\t    ), \"TEMPLATE_TOOL_RESPONSE constant not found.\"\n\t    assert hasattr(TerminalAgentPrompt, \"SUFFIX\"), \"SUFFIX constant not found.\"\n\t    assert hasattr(\n\t        TerminalAgentPrompt, \"FORMAT_INSTRUCTIONS\"\n\t    ), \"FORMAT_INSTRUCTIONS constant not found.\"\n\t    assert hasattr(TerminalAgentPrompt, \"PREFIX\"), \"PREFIX constant not found.\"\n"]}
