{"filename": "filter_ideas.py", "chunked_list": ["import openai\n\timport json\n\timport concurrent\n\timport random\n\tnum_voters = 6\n\tdef filter_ideas(ideas, criteria):\n\t    all_ideas = []\n\t    with concurrent.futures.ThreadPoolExecutor() as executor:\n\t        # Use a list comprehension to create a list of two Future objects\n\t        future_list = [\n", "            executor.submit(pick_five, ideas, criteria) for _ in range(num_voters)\n\t        ]\n\t        # As the futures complete, extend `all_ideas` with their results\n\t        for future in concurrent.futures.as_completed(future_list):\n\t            all_ideas.extend(future.result())\n\t    counts = [(idea, all_ideas.count(idea)) for idea in set(all_ideas)]\n\t    sorted_by_votes = sorted(counts, key=lambda x: x[1], reverse=True)\n\t    return sorted_by_votes\n\tdef format_ideas(ideas):\n\t    return \"\\n\".join([f\"{i}. {idea}\" for i, idea in enumerate(ideas, start=1)])\n", "def pick_five(ideas, criteria):\n\t    shuffled_ideas = ideas\n\t    random.shuffle(shuffled_ideas)\n\t    prompt = f\"\"\"You are an AI writing assistant helping an author filter through their story concepts to find the ideas with the most potential.\n\tThe following is a list of ideas for an illustrated children's book:\n\t{format_ideas(ideas)}\n\tPick the five {criteria}.\"\"\"\n\t    unformatted_five_ideas = openai.ChatCompletion.create(\n\t        model=\"gpt-3.5-turbo\",\n\t        messages=[\n", "            {\"role\": \"user\", \"content\": prompt},\n\t        ],\n\t        n=1,\n\t        temperature=1,\n\t    )\n\t    five_titles_list = openai.ChatCompletion.create(\n\t        model=\"gpt-3.5-turbo\",\n\t        messages=[\n\t            {\"role\": \"user\", \"content\": prompt},\n\t            unformatted_five_ideas.choices[0].message,\n", "            {\n\t                \"role\": \"user\",\n\t                \"content\": \"\"\"Reformat the titles of your chosen five ideas into a json list format.\n\tOutput json ONLY - your output will be directly parsed so it must have NO other text such as a preamble.\"\"\",\n\t            },\n\t        ],\n\t        n=1,\n\t        temperature=0,\n\t    )\n\t    try:\n", "        return json.loads(five_titles_list.choices[0].message.content)\n\t    except:\n\t        print(f\"Could not parse as JSON: {five_titles_list.choices[0].message.content}\")\n\t        return []\n"]}
{"filename": "parsing_utils.py", "chunked_list": ["import re\n\tdef parse_numbered_list(response):\n\t    # Response is a string with a numbered list of items\n\t    # Match the start of each list element\n\t    # Regex explanation:\n\t    # ^(\\d+) - Match a number at the start of a line\n\t    # [^\\w\\n] - Match a non-word character (e.g. a period, colon, or close parenthesis)\n\t    matches = re.finditer(r\"^(\\d+)[^\\w\\n]\", response, re.MULTILINE)\n\t    # Extract indices and sort them\n\t    indices = [match.start() for match in matches]\n", "    indices.append(len(response))\n\t    indices.sort()\n\t    # Extract items using indices\n\t    items = [\n\t        response[indices[i] : indices[i + 1]].strip() for i in range(len(indices) - 1)\n\t    ]\n\t    # Remove the number, punctuation, and leading whitespace from each item\n\t    items = [re.sub(r\"^\\d+[^\\w\\n]\\s*\", \"\", item, flags=re.MULTILINE) for item in items]\n\t    if len(items) != 3:\n\t        return []\n", "    return items\n"]}
{"filename": "write_story.py", "chunked_list": ["import os\n\timport sys\n\tfrom collections import defaultdict\n\tfrom fuzzywuzzy import fuzz\n\timport openai\n\tfrom dotenv import load_dotenv\n\tfrom ideation import Ideation\n\tfrom filter_ideas import filter_ideas\n\tfrom outline_story import Outliner\n\tfrom draft_story import Drafter\n", "from story_development.development_ga import DevelopmentGA\n\tdef print_numbered_list(label, list):\n\t    print(f\"\\n{label}:\\n\")\n\t    for i, item in enumerate(list, start=1):\n\t        print(f\"{i}. {item}\")\n\tdef get_full_idea(ideas, title):\n\t    return max(\n\t        [(idea, fuzz.partial_ratio(idea, title)) for idea in ideas], key=lambda x: x[1]\n\t    )[0]\n\tload_dotenv()\n", "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\tif len(sys.argv) != 2:\n\t    print(f\"wrong number of args, expected 1, got {len(sys.argv)}\")\n\t    exit()\n\t# Collect (optional) user-specified conditioning information, e.g. target audience, characters, setting, visual style, plot elements, etc.\n\tconditioning_info = sys.argv[1]\n\tprint(f\"Generating a story conditioned on:\\n{conditioning_info}\")\n\t# Come up with a bunch of ideas\n\tideas = Ideation(conditioning_info).make_ideas(3)\n\tprint_numbered_list(\"Generated ideas\", ideas)\n", "# Find the best ideas\n\tmost_creative = filter_ideas(\n\t    ideas, \"most creative, surprising, and unexpected ideas that excite the imagination\"\n\t)\n\tprint_numbered_list(\"Most creative ideas\", most_creative)\n\tbest_fit = filter_ideas(\n\t    ideas, \"ideas that best fit the client's constraints:\\n{conditioning_info}\"\n\t)\n\tprint_numbered_list(\"Most targeted ideas\", best_fit)\n\tcutest = filter_ideas(ideas, \"cutest and most adorable stories\")\n", "print_numbered_list(\"Cutest ideas\", cutest)\n\t# Combine the weighted vote counts from each filter\n\tcombined_vote_counts = defaultdict(float)\n\tfor weight, votes in zip([0.5, 0.3, 0.2], [most_creative, best_fit, cutest]):\n\t    for idea, count in votes:\n\t        combined_vote_counts[idea] += count * weight\n\t# Sort the combined vote counts in descending order\n\tsorted_by_combined_votes = sorted(\n\t    combined_vote_counts.items(), key=lambda x: x[1], reverse=True\n\t)\n", "print_numbered_list(\"Overall best ideas\", sorted_by_combined_votes)\n\tselected_title = sorted_by_combined_votes[0][0]\n\tselected_idea = get_full_idea(ideas, selected_title)\n\tprint(f\"\\nSelected idea:\\n\")\n\tprint(selected_idea)\n\tpremise = f\"{selected_title}: {selected_idea}\"\n\toutliner = Outliner(conditioning_info, premise)\n\tinitial_ideas = outliner.outline(1)\n\tprint(\"\\n\\nNotes:\\n\\n\")\n\tprint(initial_ideas[0])\n", "ga = DevelopmentGA(conditioning_info, premise, initial_ideas)\n\tbest_individual = ga.evolve(0, 1, 2)\n\tstories = Drafter(conditioning_info, best_individual.get_notes()).draft()\n\tprint(f\"\\nPotential stories:\\n\")\n\tprint(\"\\n\\n========\\n\\n\".join(story for story in stories))\n\t# Write a more detailed story description\n\t# Split the story up into pages, each with a couple lines of story and a brief image description.\n\t# Produce an illustration for each page. Special care will need to be taken to get (semi) consistent characters and settings.\n\t# Format the series of pages into a book.\n"]}
{"filename": "ideation.py", "chunked_list": ["import re\n\timport openai\n\tdef parse_ideas(texts):\n\t    # The regular expression pattern:\n\t    # It looks for a number followed by a '.', ':', or ')' (with optional spaces)\n\t    # and then captures any text until it finds a newline character or the end of the string\n\t    pattern = re.compile(r\"\\d[\\.\\:\\)]\\s*(.*?)(?=\\n\\d|$)\", re.MULTILINE)\n\t    # Find all matches using the 'findall' method\n\t    matches = []\n\t    for text in texts:\n", "        matches = matches + pattern.findall(text)\n\t    # Return the matches\n\t    return matches\n\tclass Ideation:\n\t    def __init__(self, conditioning_info):\n\t        self.conditioning_info = conditioning_info\n\t    def outline_prompt(self):\n\t        return f\"\"\"You are an AI storybook writer. You write engaging, creative, and highly diverse content for illustrated books for children.\n\tThe first step in your process is ideation - workshop a bunch of ideas and find the ones with that special spark.\n\tYour client has provided some constraints for you to satisfy, but within those constraints you have total artistic control, so get creative with it!\n", "Client constraints:\n\t{self.conditioning_info}\n\tEach idea should have a title and a 2-3 sentence premise mentioning the protagonist, the setting, and the conflict, while also highlighting what makes the story interesting.\n\tHere's an example of a successful premise:\n\t“Romeo and Juliet\": Two teens, Romeo and Juliet, pursue their forbidden love with each other—to the chagrin of their rival families. When Juliet must choose between her family and her heart, both lovers must find a way to stay united, even if fate won't allow it.\n\tCome up with a numbered list of eight of your best ideas. Focus on variety within the scope of the client's requests.\n\t\"\"\"\n\t    def make_ideas(self, n):\n\t        response = openai.ChatCompletion.create(\n\t            model=\"gpt-3.5-turbo\",\n", "            messages=[\n\t                {\"role\": \"user\", \"content\": self.outline_prompt()},\n\t            ],\n\t            n=n,\n\t            temperature=1,\n\t        )\n\t        return parse_ideas([choice.message.content for choice in response.choices])\n"]}
{"filename": "outline_story.py", "chunked_list": ["import openai\n\tclass Outliner:\n\t    def __init__(self, conditioning_info, premise):\n\t        self.conditioning_info = conditioning_info\n\t        self.premise = premise\n\t    def outline_prompt(self):\n\t        return f\"\"\"You are an AI storyteller who specializes in illustrated books for young children. You are fleshing out a story premise for a client today.\n\tThe client's requirements are:\n\t{self.conditioning_info}\n\tThe story premise is:\n", "{self.premise}\n\tFirst, expand that quick premise into a more detailed form, including:\n\t- What characters are involved in the story? What are their motivations? How might they interact with and relate to one another?\n\t- What settings and environments will the story take place in? What makes them unique? How do they relate to the premise and the characters?\n\t- What are the main themes and messages in the story?\n\tThen, given that information, write an outline for the story.\n\tFollow a classic narrative structure: exposition, rising action, climax, falling action, and resolution.\n\tEnsure that the story has a clear message and a logical progression.\n\t\"\"\"\n\t    def outline(self, n=1):\n", "        response = openai.ChatCompletion.create(\n\t            model=\"gpt-3.5-turbo\",\n\t            messages=[\n\t                {\"role\": \"user\", \"content\": self.outline_prompt()},\n\t            ],\n\t            n=n,\n\t            temperature=1,\n\t        )\n\t        return [choice.message.content for choice in response.choices]\n"]}
{"filename": "draft_story.py", "chunked_list": ["import openai\n\tclass Drafter:\n\t    def __init__(self, conditioning_info, outline):\n\t        self.conditioning_info = conditioning_info\n\t        self.outline = outline\n\t    def draft_prompt(self):\n\t        return f\"\"\"You are an award-winning author of illustrated children's books. You have been contracted by a client to write a custom book for them.\n\tThey gave you these requiremnts: {self.conditioning_info}\n\tThe following is a story outline you came up with for the book:\n\t{self.outline}\n", "Compose a rough draft of the book itself. Your draft should be a sequence of page descriptions, where each page has:\n\t- a composition,\n\t- the contents of any text paragraphs on the page, and\n\t- a brief description of the illustration.\"\"\"\n\t    def draft(self):\n\t        response = openai.ChatCompletion.create(\n\t            model=\"gpt-3.5-turbo\",\n\t            messages=[\n\t                {\"role\": \"user\", \"content\": self.draft_prompt()},\n\t            ],\n", "            n=2,\n\t            temperature=1,\n\t        )\n\t        return [choice.message.content for choice in response.choices]\n"]}
{"filename": "story_development/test_themes.py", "chunked_list": ["import openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom story_development.themes import Themes\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\tconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\n\tpremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\n\toutline = \"\"\"Expanded Story Premise:\n\tCharacters:\n", "- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n\t- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n\t- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\tSetting:\n\t- A small village surrounded by lush green forests and meadows.\n\t- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n\t- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\tThemes:\n\t- Caring for nature and its creatures.\n\t- Empathy and understanding.\n", "- Overcoming fears.\n\tOutline:\n\tExposition:\n\t- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n\t- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\tRising Action:\n\t- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n\t- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\tClimax:\n\t- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n", "- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\tFalling Action:\n\t- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n\t- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\tResolution:\n\t- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n\t- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\n\tthemes = Themes(conditioning_info, premise, outline)\n\tthemes.score(verbose=True, n=3)\n\trecommendations = themes.make_recommendations(1, verbose=True)\n", "[print(recommendation) for recommendation in recommendations]\n"]}
{"filename": "story_development/test_apply_recommendation.py", "chunked_list": ["import openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom ga.individual import Individual\n\tfrom story_development.characters import Characters\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\tconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\n\tpremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\n\toutline = \"\"\"Expanded Story Premise:\n", "Characters:\n\t- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n\t- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n\t- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\tSetting:\n\t- A small village surrounded by lush green forests and meadows.\n\t- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n\t- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\tThemes:\n\t- Caring for nature and its creatures.\n", "- Empathy and understanding.\n\t- Overcoming fears.\n\tOutline:\n\tExposition:\n\t- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n\t- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\tRising Action:\n\t- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n\t- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\tClimax:\n", "- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n\t- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\tFalling Action:\n\t- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n\t- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\tResolution:\n\t- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n\t- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\n\tcharacters = Characters(conditioning_info, premise, outline)\n\tindividual = Individual(characters)\n", "recommendation = \"\"\"Combine Abuela and the Butterfly Keeper into one character - a wise, caring grandmother who is also an expert on butterflies. This would reduce redundancy and make her character more unique. She can guide Juan throughout the story, teaching him about the importance of butterflies while also offering him a chance to learn from her expertise.\"\"\"\n\tprint(individual.apply_recommendation(characters, recommendation, verbose=True))\n"]}
{"filename": "story_development/characters.py", "chunked_list": ["from ga.category import Category\n\tclass Characters(Category):\n\t    def __init__(self, conditioning_info, premise, notes):\n\t        Category.__init__(self, conditioning_info, premise, notes)\n\t    def category_name(self):\n\t        return \"characters\"\n\t    def best_possible_score(self):\n\t        return 25\n\t    def rubric(self):\n\t        return \"\"\"An ideal cast of characters will:\n", "- Be memorable and original\n\t- Have distinct characterization and roles, with minimal redundancy\n\t- Be relatable for the target audience\n\t- Have clear motivations, goals, and, for the main characters, growth\n\t- Have age-appropriate complexity and depth\"\"\"\n\t    def recommendations_reminder(self):\n\t        return \"\"\"Remember that combining characters, distilling overly complex characters, and simplifying for the target audience are often important too, not only adding things. Don't be afraid to recommend big changes.\"\"\"\n"]}
{"filename": "story_development/test_outline.py", "chunked_list": ["import openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom story_development.outline import Outline\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\tconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\n\tpremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\n\toutline = \"\"\"Expanded Story Premise:\n\tCharacters:\n", "- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n\t- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n\t- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\tSetting:\n\t- A small village surrounded by lush green forests and meadows.\n\t- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n\t- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\tThemes:\n\t- Caring for nature and its creatures.\n\t- Empathy and understanding.\n", "- Overcoming fears.\n\tOutline:\n\tExposition:\n\t- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n\t- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\tRising Action:\n\t- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n\t- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\tClimax:\n\t- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n", "- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\tFalling Action:\n\t- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n\t- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\tResolution:\n\t- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n\t- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\n\toutline = Outline(conditioning_info, premise, outline)\n\toutline.score(verbose=True, n=3)\n\trecommendations = outline.make_recommendations(1, verbose=True)\n", "[print(recommendation) for recommendation in recommendations]\n"]}
{"filename": "story_development/setting.py", "chunked_list": ["from ga.category import Category\n\tclass Setting(Category):\n\t    def __init__(self, conditioning_info, premise, notes):\n\t        Category.__init__(self, conditioning_info, premise, notes)\n\t    def category_name(self):\n\t        return \"setting\"\n\t    def best_possible_score(self):\n\t        return 25\n\t    def rubric(self):\n\t        return \"\"\"An ideal setting:\n", "- excites the imagination with originality and depth\n\t- has excellent potential for illustration\n\t- is relatable and appropriate for the target audience\n\t- demonstrates themes or conflict with illustrative or contrasting setting elements\n\t- has well-differentiated locations with distinct story roles and contrasting characteristics (give a 5/5 if it has only one location)\"\"\"\n\t    def recommendations_reminder(self):\n\t        return \"\"\"Prefer to keep things simple - replacing, simplifying, or deleting a location, or combining two redundant locations - instead of adding more stuff. Don't be afraid to recommend big changes. Remember, these are early story notes, so focus on the core elements. Descriptive language and non-story-relevant details will happen later.\"\"\"\n"]}
{"filename": "story_development/test_characters.py", "chunked_list": ["import openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom story_development.characters import Characters\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\tconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\n\tpremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\n\toutline = \"\"\"Expanded Story Premise:\n\tCharacters:\n", "- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n\t- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n\t- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\tSetting:\n\t- A small village surrounded by lush green forests and meadows.\n\t- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n\t- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\tThemes:\n\t- Caring for nature and its creatures.\n\t- Empathy and understanding.\n", "- Overcoming fears.\n\tOutline:\n\tExposition:\n\t- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n\t- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\tRising Action:\n\t- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n\t- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\tClimax:\n\t- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n", "- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\tFalling Action:\n\t- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n\t- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\tResolution:\n\t- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n\t- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\n\tcharacters = Characters(conditioning_info, premise, outline)\n\tcharacters.score(verbose=True, n=1)\n\trecommendation = characters.make_recommendation(verbose=True)\n"]}
{"filename": "story_development/development_ga.py", "chunked_list": ["import openai\n\tfrom ga.ga import GeneticAlgorithmBase\n\tfrom ga.individual import Individual\n\tfrom outline_story import Outliner\n\tfrom story_development.characters import Characters\n\tfrom story_development.outline import Outline\n\tfrom story_development.setting import Setting\n\tfrom story_development.themes import Themes\n\tclass DevelopmentGA(GeneticAlgorithmBase):\n\t    def __init__(self, conditioning_info, premise, inital_ideas):\n", "        self.conditioning_info = conditioning_info\n\t        self.premise = premise\n\t        initial_population = [self.make_individual(idea) for idea in inital_ideas]\n\t        GeneticAlgorithmBase.__init__(self, initial_population)\n\t    def make_individual(self, notes):\n\t        return Individual(\n\t            [\n\t                Characters(self.conditioning_info, self.premise, notes),\n\t                Setting(self.conditioning_info, self.premise, notes),\n\t                Themes(self.conditioning_info, self.premise, notes),\n", "                Outline(self.conditioning_info, self.premise, notes),\n\t            ]\n\t        )\n\t    def compute_fitness(self, individual):\n\t        if not individual.is_scored():\n\t            individual.score()\n\t        return individual.total_score()\n\t    def mutate(self, individual):\n\t        category, recommendation = individual.make_recommendation()\n\t        print(f\"Got recommendation for {category.category_name()}: {recommendation}\")\n", "        mutated_notes = individual.apply_recommendation(category, recommendation)\n\t        print(f\"Revised notes: {mutated_notes}\")\n\t        return self.make_individual(mutated_notes)\n\t    def crossover(self, parent1, parent2):\n\t        # Given two individuals, parent1 as the primary and parent2 as the secondary\n\t        # Identify the best things about parent2, based on the feedback\n\t        # Update parent1 to incorporate those best things\n\t        raise NotImplementedError(\n\t            \"Derived classes must implement the crossover operator\"\n\t        )\n"]}
{"filename": "story_development/themes.py", "chunked_list": ["from ga.category import Category\n\tclass Themes(Category):\n\t    def __init__(self, conditioning_info, premise, notes):\n\t        Category.__init__(self, conditioning_info, premise, notes)\n\t    def category_name(self):\n\t        return \"themes\"\n\t    def best_possible_score(self):\n\t        return 20\n\t    def rubric(self):\n\t        return \"\"\"Ideal themes are:\n", "- Relevant and engaging for the target audience (see client requirements above)\n\t- Clearly shown by and well-explored in the events of the story\n\t- Positive, empowering, and educational\n\t- Respectful of diversity, avoiding stereotypes and cultural insensitivity\"\"\"\n\t    def recommendations_reminder(self):\n\t        return \"\"\"Remember that combining themes, distilling overly complex themes, and simplifying for the target audience are often important too, not only adding things. Don't be afraid to recommend big changes.\"\"\"\n"]}
{"filename": "story_development/outline.py", "chunked_list": ["from ga.category import Category\n\tclass Outline(Category):\n\t    def __init__(self, conditioning_info, premise, notes):\n\t        Category.__init__(self, conditioning_info, premise, notes)\n\t    def category_name(self):\n\t        return \"outline\"\n\t    def best_possible_score(self):\n\t        return 25\n\t    def rubric(self):\n\t        return \"\"\"An ideal outline:\n", "- Conflict and tension: Has a clear and compelling central conflict that creates tension\n\t- Resolution: Resolves its central conflict in a satisfying and logical manner that does not feel abrupt or unjustified\n\t- Pacing: Is ruthlessly edited and engagingly paced; every event is critical to the story\n\t- Narrative consistency: Follows a logical progression, with no plot holes, non sequitors, or unfulfilled promises\n\t- Character-driven: Drives plot by the actions decisions of characters, not external events or coincidences\"\"\"\n\t    def recommendations_reminder(self):\n\t        return \"\"\"Remember that eliminating or combining redundant events, refocusing on the central conflict, and simplifying concepts for the target audience are often important too, not only adding more things. Don't be afraid to recommend big changes. Finally, remember that this is just an outline, so focus on the core elements of the plot; descriptive language will happen later.\"\"\"\n"]}
{"filename": "story_development/test_feedback.py", "chunked_list": ["import openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom story_development.development_ga import DevelopmentGA\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\tconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\n\tpremise = \"\\\"The Butterfly Keeper\\\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.\"\n\toutline = \"\"\"Expanded Story Premise:\n\tCharacters:\n", "- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n\t- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n\t- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\tSetting:\n\t- A small village surrounded by lush green forests and meadows.\n\t- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n\t- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\tThemes:\n\t- Caring for nature and its creatures.\n\t- Empathy and understanding.\n", "- Overcoming fears.\n\tOutline:\n\tExposition:\n\t- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n\t- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\tRising Action:\n\t- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n\t- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\tClimax:\n\t- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n", "- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\tFalling Action:\n\t- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n\t- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\tResolution:\n\t- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n\t- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\n\tga = DevelopmentGA(conditioning_info, premise, [outline])\n\tga.get_feedback(outline, verbose=True)"]}
{"filename": "story_development/test_setting.py", "chunked_list": ["import openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom story_development.setting import Setting\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\tconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\n\tpremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\n\toutline = \"\"\"Expanded Story Premise:\n\tCharacters:\n", "- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n\t- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n\t- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\tSetting:\n\t- A small village surrounded by lush green forests and meadows.\n\t- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n\t- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\tThemes:\n\t- Caring for nature and its creatures.\n\t- Empathy and understanding.\n", "- Overcoming fears.\n\tOutline:\n\tExposition:\n\t- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n\t- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\tRising Action:\n\t- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n\t- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\tClimax:\n\t- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n", "- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\tFalling Action:\n\t- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n\t- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\tResolution:\n\t- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n\t- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\n\tsetting = Setting(conditioning_info, premise, outline)\n\tsetting.score(verbose=True, n=3)\n\trecommendations = setting.make_recommendations(1, verbose=True)\n", "[print(recommendation) for recommendation in recommendations]\n"]}
{"filename": "ga/category.py", "chunked_list": ["import openai\n\timport random\n\timport re\n\tclass Category:\n\t    def __init__(self, conditioning_info, premise, notes):\n\t        self.conditioning_info = conditioning_info\n\t        self.premise = premise\n\t        self.notes = notes\n\t    def category_name(self):\n\t        raise NotImplementedError(\"Derived classes must define a category name\")\n", "    def best_possible_score(self):\n\t        raise NotImplementedError(\"Derived classes must define the best possible score\")\n\t    def rubric(self):\n\t        raise NotImplementedError(\"Derived classes must define the rubric\")\n\t    def recommendations_reminder(self):\n\t        raise NotImplementedError(\n\t            \"Derived classes must define the recommendations reminder\"\n\t        )\n\t    def scoring_prompt(self):\n\t        return f\"\"\"I'm working on an illustrated children's story for a client.\n", "They gave me a premise:\n\t{self.premise}\n\tThey gave me other requirements:\n\t{self.conditioning_info}\n\tI have elaborated on the premise, producing these notes:\n\t{self.notes}\n\tCritique this story's {self.category_name()} based on this rubric.\n\t{self.rubric()}\n\tFollow the list structure of the rubric. For each item, discuss things the story's {self.category_name()} do well and things they do poorly in that respect, then lastly score that item out of 5. Be as harsh as possible!\n\tEnd your review with \"Overall Score: <sum of item scores>/{self.best_possible_score()}\". N/A for any item should count as a 5.\"\"\"\n", "    def score(self, verbose=False, n=1):\n\t        self.scores = []\n\t        prompt = self.scoring_prompt()\n\t        if verbose:\n\t            print(prompt)\n\t        response = openai.ChatCompletion.create(\n\t            model=\"gpt-3.5-turbo\",\n\t            messages=[\n\t                {\"role\": \"user\", \"content\": prompt},\n\t            ],\n", "            n=n,\n\t            temperature=1,\n\t        )\n\t        if verbose:\n\t            [print(choice.message.content) for choice in response.choices]\n\t        scores = [\n\t            self.parse_score(prompt, choice.message.content)\n\t            for choice in response.choices\n\t        ]\n\t        scores = [score for score in scores if score is not None]\n", "        actual = len(scores)\n\t        if actual < n:\n\t            print(\n\t                f\"WARNING: Only {actual} scores could be parsed of the {n} responses.\"\n\t            )\n\t            self.score(verbose, n - actual)\n\t        self.scores.extend(scores)\n\t    def is_scored(self):\n\t        return hasattr(self, \"scores\")\n\t    def average_score(self):\n", "        return sum([int(score[\"score\"]) for score in self.scores]) / len(self.scores)\n\t    def normalized_score(self):\n\t        return self.average_score() / self.best_possible_score()\n\t    def parse_score(self, prompt, response):\n\t        score_regex = re.compile(\n\t            r\"Overall Score:\\s*(\\d{1,2}(?:\\.\\d{1,2})?)/\"\n\t            + f\"{self.best_possible_score()}\"\n\t        )\n\t        match = score_regex.search(response)\n\t        if not match:\n", "            print(f\"WARNING: Could not parse score from response: {response}\")\n\t            return None\n\t        overall_score = float(match.group(1))\n\t        return {\n\t            \"conversation\": [\n\t                {\"role\": \"user\", \"content\": prompt},\n\t                {\"role\": \"assistant\", \"content\": response},\n\t            ],\n\t            \"score\": overall_score,\n\t        }\n", "    def recommendations_prompt(self):\n\t        return f\"\"\"Based on your feedback, give three independent, detailed recommendations for how to improve the outline.\n\tEach recommendation should solve a problem highlighted above and specify every detail on what should be changed and how. DO NOT list multiple alternatives, options, or examples; give one detailed, concrete solution.\n\tEach recommendation should be independent of the others, as they will be evaluated separately.\n\t{self.recommendations_reminder()}\n\tGive your recommendations in a numbered list format. Omit preface, omit a summary, and omit other notes; include only the list itself.\"\"\"\n\t    def make_recommendation(self, verbose=False):\n\t        # Choose a score to improve on, weighted by mismatch between score and best possible score\n\t        num_missing_points = self.best_possible_score() * len(self.scores) - sum(\n\t            [score[\"score\"] for score in self.scores]\n", "        )\n\t        missing_point = random.uniform(0, num_missing_points)\n\t        current = 0\n\t        for score in self.scores:\n\t            current += self.best_possible_score() - score[\"score\"]\n\t            if current > missing_point:\n\t                return self.make_recommendation_from_score(score, verbose)\n\t    def make_recommendation_from_score(self, score, verbose=False):\n\t        prompt = self.recommendations_prompt()\n\t        if verbose:\n", "            print(prompt)\n\t        recommendations = openai.ChatCompletion.create(\n\t            model=\"gpt-3.5-turbo\",\n\t            messages=score[\"conversation\"] + [{\"role\": \"user\", \"content\": prompt}],\n\t            n=1,\n\t            temperature=1,\n\t        )\n\t        if verbose:\n\t            print(recommendations.choices[0].message.content)\n\t        pick_best_prompt = \"Which of those is the best recommendation? Repeat the recommendation, without the number and without any other preface text.\"\n", "        best_recommendation = openai.ChatCompletion.create(\n\t            model=\"gpt-3.5-turbo\",\n\t            messages=score[\"conversation\"]\n\t            + [{\"role\": \"user\", \"content\": prompt}]\n\t            + [recommendations.choices[0].message]\n\t            + [{\"role\": \"user\", \"content\": pick_best_prompt}],\n\t            n=1,\n\t            temperature=1,\n\t        )\n\t        if verbose:\n", "            print(best_recommendation.choices[0].message.content)\n\t        return best_recommendation.choices[0].message.content\n\t    def apply_recommendation_prompt(self, recommendation):\n\t        return f\"\"\"I'm working on an illustrated children's story for a client.\n\tThey gave me a premise:\n\t{self.premise}\n\tThey gave me other requirements:\n\t{self.conditioning_info}\n\tI have elaborated on the premise, producing these notes:\n\t====== ORIGINAL NOTES ======\n", "{self.notes}\n\t====== END ORIGINAL NOTES ======\n\tI received this feedback on the story's {self.category_name()}:\n\t{recommendation}\n\tRevise the notes to incorporate this feedback.\n\tBegin your response by strategizing how you will change the story notes based on the feedback. In addition to an overall plan, also carefully identify and resolve ambiguity in the recommendation. How are other aspects of the story impacted by the recommendation? Is there anything the recommendation doesn't specify adequately? Resolve that ambiguity before starting the revised notes, to ensure they are self-consistent, specific and fully meet the recommendation's objective.\n\tThen write your revised notes, wrapped in \"====== REVISED NOTES ======\" and \"====== END REVISED NOTES ======\".\"\"\"\n"]}
{"filename": "ga/ga.py", "chunked_list": ["import random\n\t# Implements a basic genetic algorithm. Derived classes must implement the various operators.\n\tclass GeneticAlgorithmBase:\n\t    def __init__(self, initial_population):\n\t        self.population = initial_population\n\t        self.population_size = len(initial_population)\n\t        self.fitness_cache = {}\n\t    # Memoize fitness calculations\n\t    def fitness(self, individual):\n\t        if individual not in self.fitness_cache:\n", "            self.fitness_cache[individual] = self.compute_fitness(individual)\n\t        return self.fitness_cache[individual]\n\t    def compute_fitness(self, individual):\n\t        raise NotImplementedError(\"Derived classes must implement the fitness function\")\n\t    def mutate(self, individual):\n\t        raise NotImplementedError(\"Derived classes must implement the mutation operator\")\n\t    def crossover(self, parent1, parent2):\n\t        raise NotImplementedError(\"Derived classes must implement the crossover operator\")\n\t    # Select parents randomly, proportional to their fitness\n\t    # todo - tournament selection is probably better. Interpreting the fitness value as ~probability is an unprincipled hack.\n", "    # Or culling to top-k, copying all of those, and then *also* picking some parents from that set?\n\t    def select_parents(self):\n\t        total_fitness = sum(self.fitness(individual) for individual in self.population)\n\t        pick = random.uniform(0, total_fitness)\n\t        current = 0\n\t        for individual in self.population:\n\t            current += self.fitness(individual)\n\t            if current > pick:\n\t                return individual\n\t        return self.population[-1]\n", "    def evolve(self, crossover_prob, mutation_prob, generations):\n\t        for _ in range(generations):\n\t            new_population = []\n\t            for _ in range(self.population_size):\n\t                parent1 = self.select_parents()\n\t                parent2 = self.select_parents()\n\t                if random.random() < crossover_prob:\n\t                    offspring = self.crossover(parent1, parent2)\n\t                else:\n\t                    offspring = random.choice([parent1, parent2])\n", "                if random.random() < mutation_prob:\n\t                    offspring = self.mutate(offspring)\n\t                new_population.append(offspring)\n\t            self.population = new_population\n\t            # self.fitness_cache = {} # clearing memoization cache probably not needed? We are cloning so keeping it helps\n\t        best_individual = max(self.population, key=self.fitness)\n\t        return best_individual\n"]}
{"filename": "ga/individual.py", "chunked_list": ["import random\n\timport openai\n\tclass Individual:\n\t    def __init__(self, categories):\n\t        self.categories = categories\n\t    def get_notes(self):\n\t        return self.categories[0].notes\n\t    def is_scored(self):\n\t        return all(category.is_scored() for category in self.categories)\n\t    def score(self, verbose=False, n=3):\n", "        for category in self.categories:\n\t            print(f\"====== Scoring {category.category_name()} ======\")\n\t            category.score(verbose=verbose, n=n)\n\t            print(\n\t                f\"Average score for {category.category_name()}: {category.average_score()}/{category.best_possible_score()}\"\n\t            )\n\t    def total_score(self):\n\t        return sum(category.average_score() for category in self.categories)\n\t    def normalized_score(self):\n\t        return sum(category.normalized_score() for category in self.categories) / len(\n", "            self.categories\n\t        )\n\t    def best_possible_score(self):\n\t        return sum(category.best_possible_score() for category in self.categories)\n\t    def make_recommendation(self, verbose=False):\n\t        num_missing_points = self.best_possible_score() - self.total_score()\n\t        # Pick a category to improve on, weighted by how many points they're missing\n\t        # Categories with worse scores (more missing points) are probably easier to improve\n\t        missing_point = random.uniform(0, num_missing_points)\n\t        current = 0\n", "        for category in self.categories:\n\t            current += category.best_possible_score() - category.average_score()\n\t            if current > missing_point:\n\t                return category, category.make_recommendation(verbose=verbose)\n\t    def apply_recommendation(self, category, recommendation, verbose=False):\n\t        # Given the premise, conditioning info, and notes, apply the recommendation to make new notes\n\t        prompt = category.apply_recommendation_prompt(recommendation)\n\t        if verbose:\n\t            print(prompt)\n\t        application = openai.ChatCompletion.create(\n", "            model=\"gpt-3.5-turbo\",\n\t            messages=[{\"role\": \"user\", \"content\": prompt}],\n\t            n=1,\n\t            temperature=1,\n\t        )\n\t        if verbose:\n\t            print(application.choices[0].message.content)\n\t        revised_notes_begin = \"====== REVISED NOTES ======\"\n\t        revised_notes_end = \"====== END REVISED NOTES ======\"\n\t        # Extract the revised notes from the response\n", "        revised_notes = (\n\t            application.choices[0]\n\t            .message.content.split(revised_notes_begin)[1]\n\t            .split(revised_notes_end)[0]\n\t        )\n\t        # Sanity check: make sure the revised notes are different from the original notes, and long enough to maybe be notes\n\t        if (\n\t            revised_notes == category.notes\n\t            or len(revised_notes) < len(category.notes) / 2\n\t        ):\n", "            return self.apply_recommendation(category, recommendation, verbose=verbose)\n\t        return revised_notes\n"]}
{"filename": "pitching/test_pitching_server.py", "chunked_list": ["import openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom example_app.backend.server import WebSocketServer\n\tfrom pitching.make_premise import make_premise, function_registry\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\t# Create task graphs\n\toverall_graph = make_premise(2)\n\toverall_graph.graph_input = {\n", "    \"conditioning_info\": \"The client is a dog food company. The story should help sell their dog food.\"\n\t}\n\tserver = WebSocketServer(overall_graph, function_registry())\n\tprint(\"Created server.\")\n\tserver.run()\n"]}
{"filename": "pitching/pick_best_idea.py", "chunked_list": ["from collections import defaultdict\n\tfrom typing import Any, Iterable\n\tfrom fuzzywuzzy import fuzz  # type: ignore\n\tfrom llmtaskgraph.task_graph import TaskGraph, GraphContext\n\tfrom llmtaskgraph.task import TaskGraphTask, PythonTask\n\tfrom llmtaskgraph.function_registry import FunctionRegistry\n\tfrom pitching.score_ideas import (\n\t    score_ideas,\n\t    function_registry as score_ideas_function_registry,\n\t)\n", "def init_most_creative(context: GraphContext) -> dict[str, str | list[str]]:\n\t    return {\n\t        \"criteria\": \"most creative, surprising, and unexpected ideas that excite the imagination\",\n\t        \"ideas\": context.graph_input()[\"ideas\"],\n\t    }\n\tdef init_best_fit(context: GraphContext) -> dict[str, str | list[str]]:\n\t    return {\n\t        \"criteria\": f\"\"\"ideas that best fit the client's constraints:\\n{context.graph_input()[\"conditioning_info\"]}\"\"\",\n\t        \"ideas\": context.graph_input()[\"ideas\"],\n\t    }\n", "def init_cutest(context: GraphContext) -> dict[str, str | list[str]]:\n\t    return {\n\t        \"criteria\": \"cutest and most adorable stories\",\n\t        \"ideas\": context.graph_input()[\"ideas\"],\n\t    }\n\tdef weighted_sum(\n\t    context: GraphContext,\n\t    most_creative: list[tuple[str, int]],\n\t    best_fit: list[tuple[str, int]],\n\t    cutest: list[tuple[str, int]],\n", ") -> str:\n\t    ideas = context.graph_input()[\"ideas\"]\n\t    weights = [0.5, 0.3, 0.2]\n\t    votes = [most_creative, best_fit, cutest]\n\t    combined_vote_counts: dict[str, float] = defaultdict(float)\n\t    for weight, vote in zip(weights, votes):\n\t        for idea, count in vote:\n\t            combined_vote_counts[idea] += count * weight\n\t    print_numbered_list(\"Most creative\", most_creative)\n\t    print_numbered_list(\"Best fit\", best_fit)\n", "    print_numbered_list(\"Cutest\", cutest)\n\t    selected_title = max(combined_vote_counts.items(), key=lambda x: x[1])[0]\n\t    # Find the idea that best matches the selected title\n\t    matches: Iterable[tuple[str, float]] = [\n\t        (idea, fuzz.partial_ratio(idea, selected_title)) for idea in ideas  # type: ignore\n\t    ]\n\t    selected_idea: str = max(\n\t        matches,\n\t        key=lambda x: x[1],\n\t    )[0]\n", "    return selected_idea\n\tregistry = FunctionRegistry()\n\tinit_most_creative_id = registry.register(init_most_creative)\n\tinit_best_fit_id = registry.register(init_best_fit)\n\tinit_cutest_id = registry.register(init_cutest)\n\tweighted_sum_id = registry.register(weighted_sum)\n\tregistry = registry.merge(score_ideas_function_registry())\n\tdef function_registry() -> FunctionRegistry:\n\t    return registry.copy()\n\tdef pick_best_idea() -> TaskGraph:\n", "    task_graph = TaskGraph()\n\t    most_creative = TaskGraphTask(\n\t        score_ideas(10),\n\t        init_most_creative_id,\n\t    )\n\t    task_graph.add_task(most_creative)\n\t    best_fit = TaskGraphTask(\n\t        score_ideas(10),\n\t        init_best_fit_id,\n\t    )\n", "    task_graph.add_task(best_fit)\n\t    cutest = TaskGraphTask(\n\t        score_ideas(10),\n\t        init_cutest_id,\n\t    )\n\t    task_graph.add_task(cutest)\n\t    task_graph.add_output_task(\n\t        PythonTask(weighted_sum_id, most_creative, best_fit, cutest)\n\t    )\n\t    return task_graph\n", "def print_numbered_list(label: str, list: list[Any]) -> None:\n\t    print(f\"\\n{label}:\\n\")\n\t    for i, item in enumerate(list, start=1):\n\t        print(f\"{i}. {item}\")\n"]}
{"filename": "pitching/test_pitching.py", "chunked_list": ["import asyncio\n\timport json\n\timport openai\n\timport os\n\tfrom dotenv import load_dotenv\n\tfrom llmtaskgraph.task_graph import TaskGraph\n\tfrom pitching.make_premise import make_premise, function_registry\n\tload_dotenv()\n\topenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\t# Create task graphs\n", "overall_graph = make_premise(2)\n\tconditioning_info = \"The client is a dog food company. The story should help sell their dog food by manipulating the readers.\"\n\tprint(\"Graph constructed:\")\n\tprint(json.dumps(overall_graph.to_json()))\n\toverall_graph_2 = TaskGraph.from_json(overall_graph.to_json())\n\toverall_graph_2.graph_input = {\"conditioning_info\": conditioning_info}\n\tbest_idea: str = asyncio.run(overall_graph_2.run(function_registry()))\n\tprint(best_idea)\n\tprint(json.dumps(overall_graph_2.to_json()))\n"]}
{"filename": "pitching/make_premise.py", "chunked_list": ["from llmtaskgraph.task import TaskGraphTask\n\tfrom llmtaskgraph.task_graph import GraphContext, TaskGraph\n\tfrom llmtaskgraph.function_registry import FunctionRegistry, forward_graph_input\n\tfrom pitching.ideation import (\n\t    make_ideas,\n\t    function_registry as make_ideas_function_registry,\n\t)\n\tfrom pitching.pick_best_idea import (\n\t    pick_best_idea,\n\t    function_registry as pick_best_idea_function_registry,\n", ")\n\tdef init_pick_best(\n\t    context: GraphContext, ideas: list[str]\n\t) -> dict[str, str | list[str]]:\n\t    return {\n\t        \"conditioning_info\": context.graph_input()[\"conditioning_info\"],\n\t        \"ideas\": ideas,\n\t    }\n\tregistry = FunctionRegistry()\n\tinit_pick_best_id = registry.register(init_pick_best)\n", "def function_registry() -> FunctionRegistry:\n\t    return registry.merge(pick_best_idea_function_registry()).merge(\n\t        make_ideas_function_registry()\n\t    )\n\tdef make_premise(num_idea_sets: int) -> TaskGraph:\n\t    overall_graph = TaskGraph()\n\t    make_ideas_task = TaskGraphTask(make_ideas(num_idea_sets), forward_graph_input)\n\t    overall_graph.add_task(make_ideas_task)\n\t    overall_graph.add_output_task(\n\t        TaskGraphTask(\n", "            pick_best_idea(),\n\t            init_pick_best_id,\n\t            make_ideas_task,\n\t        )\n\t    )\n\t    return overall_graph\n"]}
{"filename": "pitching/ideation.py", "chunked_list": ["from llmtaskgraph.task import LLMTask, PythonTask\n\tfrom llmtaskgraph.task_graph import GraphContext, TaskGraph\n\tfrom llmtaskgraph.function_registry import FunctionRegistry, FunctionId, openai_chat\n\timport re\n\tdef parse_ideas(response: str) -> list[str]:\n\t    # The regular expression pattern:\n\t    # It looks for a number followed by a '.', ':', or ')' (with optional spaces)\n\t    # and then captures any text until it finds a newline character or the end of the string\n\t    pattern = re.compile(r\"\\d[\\.\\:\\)]\\s*(.*?)(?=\\n\\d|$)\", re.MULTILINE)\n\t    return pattern.findall(response)\n", "def make_eight_ideas(context: GraphContext) -> str:\n\t    return f\"\"\"You are an AI storybook writer. You write engaging, creative, and highly diverse content for illustrated books for children.\n\tThe first step in your process is ideation - workshop a bunch of ideas and find the ones with that special spark.\n\tYour client has provided some constraints for you to satisfy, but within those constraints you have total artistic control, so get creative with it!\n\tClient constraints:\n\t{context.graph_input()[\"conditioning_info\"]}\n\tEach idea should have a title and a 2-3 sentence premise mentioning the protagonist, the setting, and the conflict, while also highlighting what makes the story interesting.\n\tHere's an example of a successful premise:\n\t“Romeo and Juliet\": Two teens, Romeo and Juliet, pursue their forbidden love with each other—to the chagrin of their rival families. When Juliet must choose between her family and her heart, both lovers must find a way to stay united, even if fate won't allow it.\n\tCome up with a numbered list of eight of your best ideas. Focus on variety within the scope of the client's requests.\n", "\"\"\"\n\tdef join_ideas(*idea_lists: list[str]) -> list[str]:\n\t    ideas: list[str] = []\n\t    for idea_list in idea_lists:\n\t        ideas.extend(idea_list)\n\t    return ideas\n\tregistry = FunctionRegistry()\n\tmake_eight_ideas_id: FunctionId[[], str] = registry.register(make_eight_ideas)\n\tparse_ideas_id: FunctionId[[str], list[str]] = registry.register_no_context(parse_ideas)\n\tjoin_ideas_id: FunctionId[[list[str]], list[str]] = registry.register_no_context(\n", "    join_ideas\n\t)\n\tdef function_registry() -> FunctionRegistry:\n\t    return registry.copy()\n\tdef make_ideas(num_idea_sets: int) -> TaskGraph:\n\t    make_ideas = TaskGraph()\n\t    ideation_tasks: list[LLMTask] = []\n\t    for _ in range(num_idea_sets):\n\t        ideation_task = LLMTask(\n\t            make_eight_ideas_id,\n", "            openai_chat,\n\t            {\"model\": \"gpt-3.5-turbo\", \"n\": 1, \"temperature\": 1},\n\t            parse_ideas_id,\n\t        )\n\t        ideation_tasks.append(ideation_task)\n\t        make_ideas.add_task(ideation_task)\n\t    make_ideas.add_output_task(PythonTask(join_ideas_id, *ideation_tasks))\n\t    return make_ideas\n"]}
{"filename": "pitching/score_ideas.py", "chunked_list": ["from llmtaskgraph.task import PythonTask, LLMTask\n\tfrom llmtaskgraph.task_graph import GraphContext, TaskGraph\n\tfrom llmtaskgraph.function_registry import (\n\t    FunctionRegistry,\n\t    openai_chat,\n\t    dont_parse,\n\t    parse_json,\n\t)\n\timport random\n\tdef pick_top_five(context: GraphContext) -> str:\n", "    def format_ideas(ideas: list[str]) -> str:\n\t        shuffled_ideas = ideas\n\t        random.shuffle(shuffled_ideas)\n\t        return \"\\n\".join(\n\t            [f\"{i}. {idea}\" for i, idea in enumerate(shuffled_ideas, start=1)]\n\t        )\n\t    return f\"\"\"You are an AI writing assistant helping an author filter through their story concepts to find the ideas with the most potential.\n\tThe following is a list of ideas for an illustrated children's book:\n\t{format_ideas(context.graph_input()[\"ideas\"])}\n\tPick the five {context.graph_input()[\"criteria\"]}.\"\"\"\n", "def extract_titles(top_five: str) -> str:\n\t    return f\"\"\"Extract the titles of the below five story premises into a json list format:\n\t{top_five}\n\tOutput json ONLY - your output will be directly parsed so it must have NO other text such as a preamble.\"\"\"\n\tdef tally_votes(*idea_lists: list[str]) -> list[tuple[str, int]]:\n\t    all_ideas: list[str] = []\n\t    for idea_list in idea_lists:\n\t        all_ideas.extend(idea_list)\n\t    counts = [(idea, all_ideas.count(idea)) for idea in set(all_ideas)]\n\t    sorted_by_votes = sorted(counts, key=lambda x: x[1], reverse=True)\n", "    return sorted_by_votes\n\tregistry = FunctionRegistry()\n\tpick_top_five_id = registry.register(pick_top_five)\n\textract_titles_id = registry.register_no_context(extract_titles)\n\ttally_votes_id = registry.register_no_context(tally_votes)\n\tdef function_registry() -> FunctionRegistry:\n\t    return registry.copy()\n\tdef score_ideas(num_voters: int) -> TaskGraph:\n\t    task_graph = TaskGraph()\n\t    titles_tasks: list[LLMTask] = []\n", "    for _ in range(num_voters):\n\t        # Pick the top five ideas\n\t        top_five = LLMTask(\n\t            pick_top_five_id,\n\t            openai_chat,\n\t            {\"model\": \"gpt-3.5-turbo\", \"n\": 1, \"temperature\": 1},\n\t            dont_parse,\n\t        )\n\t        task_graph.add_task(top_five)\n\t        # Extract the list of titles\n", "        extract_titles = LLMTask(\n\t            extract_titles_id,\n\t            openai_chat,\n\t            {\"model\": \"gpt-3.5-turbo\", \"n\": 1, \"temperature\": 0},\n\t            parse_json,\n\t            top_five,\n\t        )\n\t        task_graph.add_task(extract_titles)\n\t        titles_tasks.append(extract_titles)\n\t    task_graph.add_output_task(PythonTask(tally_votes_id, *titles_tasks))\n", "    return task_graph\n"]}
