{"filename": "Alphassembly/assembler/assembler.py", "chunked_list": ["from lib2to3.pytree import Node\n\tfrom math import log\n\tfrom tokenize import Token\n\tfrom consts import *\n\tfrom nodes import *\n\timport struct\n\tclass Assembler:\n\t    def __init__(self, nodes):\n\t        self.nodes = nodes\n\t        self.labels = {}\n", "        self.binary = bytearray()\n\t        self.idx = 0\n\t        self.variables = {}\n\t        self.var_idx = 0\n\t    def visit(self, node):\n\t        if node == None:\n\t            return\n\t        method_name = f'visit_{type(node).__name__}'\n\t        method = getattr(self, method_name, self.no_visit_method)\n\t        return method(node)\n", "    def no_visit_method(self, node):\n\t        raise Exception(f'No visit_{type(node).__name__} method defined')\n\t    def assemble(self):\n\t        self.fixlabel = True\n\t        self.flag = True\n\t        for node in self.nodes:\n\t            self.idx += 1\n\t            self.visit(node)\n\t        self.binary = bytearray()\n\t        self.idx = 0\n", "        for node in self.nodes:\n\t            self.idx += 1\n\t            self.visit(node)\n\t        self.binary = bytearray()\n\t        self.idx = 0\n\t        for node in self.nodes:\n\t            self.idx += 1\n\t            self.visit(node)\n\t        self.binary = bytearray()\n\t        self.fixlabel = False        \n", "        self.flag = False\n\t        self.idx = 0\n\t        for node in self.nodes:\n\t            self.idx += 1\n\t            self.visit(node)\n\t        self.binary.append(0)\n\t        return self.binary\n\t    def make_variable(self, varname):\n\t        if varname not in self.variables:\n\t            pass\n", "        else:\n\t            self.idx += 2\n\t            self.binary.append(4)\n\t            self.make_int32(self.variables[varname])\n\t            return\n\t        self.variables[varname] = self.var_idx\n\t        self.idx += 2\n\t        self.binary.append(4)\n\t        self.make_int32(self.var_idx)\n\t        self.var_idx += 1\n", "    def bytes_needed(self, n):\n\t        if n == 0:\n\t            return 1\n\t        elif n is None:\n\t            return 1\n\t        return int(log(n, 256)) + 1\n\t    def make_int32(self, integer, label=None):\n\t        if integer is None:\n\t            integer = 0\n\t        if label:\n", "            if label in self.labels.keys():\n\t                self.idx += 1\n\t                integer = self.labels[label]\n\t        needed_bytes = self.bytes_needed(integer)\n\t        if needed_bytes == 0:\n\t            needed_bytes = 1\n\t        self.idx += needed_bytes\n\t        if needed_bytes > 1 and self.fixlabel:\n\t            for label in self.labels:\n\t                if self.labels[label] > self.idx:\n", "                    self.labels[label] += needed_bytes-1\n\t        self.binary.append(needed_bytes)\n\t        self.binary.extend(integer.to_bytes(needed_bytes, 'little'))\n\t    def make_double64(self, float):\n\t        if float > 1.7976931348623157E+308:\n\t            raise Exception(\"Float too big\")\n\t        needed_bytes = 8\n\t        if needed_bytes == 0:\n\t            needed_bytes = 1\n\t        self.idx += needed_bytes\n", "        self.binary.extend(struct.pack(\"d\", float))\n\t    def make_string(self, string):\n\t        for char in string:\n\t            self.binary.append(ord(char))\n\t        self.binary.append(0)\n\t    def make_arg(self, val, jmp=False):\n\t        pc = False\n\t        if type(val) is ListNode:\n\t            self.make_list(val)\n\t        elif val.type == TT_IDENTIFIER:\n", "            if val.value in REGISTERS:\n\t                self.idx += 2\n\t                self.binary.append(1)\n\t                self.binary.append(REGISTERS[val.value])\n\t            else:\n\t                #try:\n\t                #    if self.bytes_needed(self.labels[val.value]) == 2:\n\t                #        pass\n\t                #    elif self.bytes_needed(self.labels[val.value]) == 3:\n\t                #        self.idx -= 1\n", "                #    elif self.bytes_needed(self.labels[val.value]) == 4:\n\t                #        self.idx -= 2\n\t                #    else:\n\t               #         self.idx += 1\n\t               # except KeyError:\n\t               #     pass\n\t               if not jmp:\n\t                    self.idx += 1\n\t                    self.binary.append(2)\n\t                    self.make_int32(None, label=val.value)\n", "               else:\n\t                   if self.labels.get(val.value):\n\t                        self.idx += 1\n\t                        #if self.bytes_needed(self.labels[val.value]) == 2:\n\t                        #    pass\n\t                        #elif self.bytes_needed(self.labels[val.value]) == 3:\n\t                        #    self.idx -= 1\n\t                        #elif self.bytes_needed(self.labels[val.value]) == 4:\n\t                        #    self.idx -= 2\n\t                        #else:\n", "                        #    self.idx += 1\n\t                        self.binary.append(2)\n\t                        if self.labels.get(val.value):\n\t                                self.make_int32(None, label = val.value)\n\t                #raise Exception(f\"Register: {val.value} not found\")\n\t        elif val.type == TT_INT:\n\t            if self.bytes_needed(val.value) == 2:\n\t                pass\n\t            elif self.bytes_needed(val.value) == 3:\n\t                self.idx -= 1\n", "            elif self.bytes_needed(val.value) == 4:\n\t                self.idx -= 2\n\t            else:\n\t                self.idx += 1\n\t            self.idx += self.bytes_needed(val.value)\n\t            self.binary.append(2)\n\t            self.make_int32(val.value)\n\t        elif val.type == TT_FLOAT:\n\t            self.idx += 1\n\t            self.binary.append(5)\n", "            self.make_double64(val.value)\n\t        elif val.type == TT_STRING:\n\t            self.idx += len(val.value) + 2\n\t            self.binary.append(3)\n\t            self.make_string(val.value)\n\t        elif val.type == TT_VARIABLE:\n\t            self.make_variable(val.value)\n\t    def make_register(self, val):\n\t        if val.type == TT_IDENTIFIER:\n\t            if val.value in REGISTERS:\n", "                self.idx += 2\n\t                self.binary.append(1)\n\t                self.binary.append(REGISTERS[val.value])\n\t            else:\n\t                raise Exception(f\"Register: '{val.value}' not found\")\n\t    def make_op(self, val):\n\t        self.idx += 1\n\t        if val.type == TT_EE:\n\t            self.binary.append(1)\n\t        elif val.type == TT_NE:\n", "            self.binary.append(2)\n\t        elif val.type == TT_GT:\n\t            self.binary.append(3)\n\t        elif val.type == TT_GTE:\n\t            self.binary.append(4)\n\t        elif val.type == TT_LT:\n\t            self.binary.append(5)\n\t        elif val.type == TT_LTE:\n\t            self.binary.append(6)\n\t        else:\n", "            raise Exception(f\"Unrecognized operator: '{val.type}'\")\n\t    def make_list(self, node):\n\t        self.idx += 2\n\t        self.binary.append(6)\n\t        self.make_int32(len(node.nodes_list))\n\t        for node in node.nodes_list:\n\t            val = self.visit(node)\n\t            self.make_arg(val)\n\t    ###################################\n\t    def visit_LoadNode(self, node):\n", "        string = node.string.value\n\t        self.binary.append(9)\n\t        self.make_string(string)\n\t        self.idx += len(string) + 1\n\t    def visit_PrintNode(self, node):\n\t        self.binary.append(8)\n\t    def visit_DoneNode(self, node):\n\t        self.binary.append(7)\n\t    def visit_PopNode(self, node):\n\t        self.binary.append(6)\n", "        if not node.reg == None:\n\t            self.make_register(node.reg)\n\t        else:\n\t            self.idx += 1\n\t            self.binary.append(0)\n\t    def visit_DivNode(self, node):\n\t        self.binary.append(5)\n\t        if node.val1.type == TT_IDENTIFIER:\n\t            if node.val1.value in REGISTERS:\n\t                self.idx += 2\n", "                self.binary.append(1)\n\t                self.binary.append(REGISTERS[node.val1.value])\n\t        elif node.val1.type == TT_VARIABLE:\n\t            self.make_variable(node.val1.value)\n\t        else:\n\t            raise Exception(\"Left operand must be a register or variable\")\n\t        self.make_arg(node.val2)\n\t    def visit_MulNode(self, node):\n\t        self.binary.append(4)\n\t        if node.val1.type == TT_IDENTIFIER:\n", "            if node.val1.value in REGISTERS:\n\t                self.idx += 2\n\t                self.binary.append(1)\n\t                self.binary.append(REGISTERS[node.val1.value])\n\t        elif node.val1.type == TT_VARIABLE:\n\t            self.make_variable(node.val1.value)\n\t        else:\n\t            raise Exception(\"Left operand must be a register or variable\")\n\t        self.make_arg(node.val2)\n\t    def visit_SubNode(self, node):\n", "        self.binary.append(3)\n\t        if node.val1.type == TT_IDENTIFIER:\n\t            if node.val1.value in REGISTERS:\n\t                self.idx += 2\n\t                self.binary.append(1)\n\t                self.binary.append(REGISTERS[node.val1.value])\n\t        elif node.val1.type == TT_VARIABLE:\n\t            self.make_variable(node.val1.value)\n\t        else:\n\t            raise Exception(\"Left operand must be a register or variable\")\n", "        self.make_arg(node.val2)\n\t    def visit_AddNode(self, node):\n\t        self.binary.append(2)\n\t        if node.val1.type == TT_IDENTIFIER:\n\t            if node.val1.value in REGISTERS:\n\t                self.idx += 2\n\t                self.binary.append(1)\n\t                self.binary.append(REGISTERS[node.val1.value])\n\t        elif node.val1.type == TT_VARIABLE:\n\t            self.make_variable(node.val1.value)\n", "        else:\n\t            raise Exception(\"Left operand must be a register or variable\")\n\t        self.make_arg(node.val2)\n\t    def visit_ModuloNode(self, node):\n\t        self.binary.append(21)\n\t        if node.val1.type == TT_IDENTIFIER:\n\t            if node.val1.value in REGISTERS:\n\t                self.idx += 2\n\t                self.binary.append(1)\n\t                self.binary.append(REGISTERS[node.val1.value])\n", "        elif node.val1.type == TT_VARIABLE:\n\t            self.make_variable(node.val1.value)\n\t        else:\n\t            raise Exception(\"Left operand must be a register or variable\")\n\t        self.make_arg(node.val2)\n\t    def visit_PowNode(self, node):\n\t        self.binary.append(23)\n\t        if node.val1.type == TT_IDENTIFIER:\n\t            if node.val1.value in REGISTERS:\n\t                self.idx += 2\n", "                self.binary.append(1)\n\t                self.binary.append(REGISTERS[node.val1.value])\n\t        elif node.val1.type == TT_VARIABLE:\n\t            self.make_variable(node.val1.value)\n\t        else:\n\t            raise Exception(\"Left operand must be a register or variable\")\n\t        self.make_arg(node.val2)\n\t    def visit_PushNode(self, node):\n\t        if type(node.value) is not ListNode:\n\t            value = node.value.value or None\n", "            type_ = node.value.type or None\n\t        self.binary.append(1)\n\t        # TODO: test if this works (pushing list)\n\t        if type(node.value) is ListNode:\n\t            self.make_list(node.value)\n\t        elif type_ == TT_INT:\n\t            self.binary.append(2)\n\t            self.make_int32(value)\n\t            self.idx += self.bytes_needed(value) + 1\n\t            self.idx -= self.bytes_needed(value) - 1\n", "        elif type_ == TT_FLOAT:\n\t            self.binary.append(5)\n\t            self.make_double64(value)\n\t            self.idx += 1\n\t        elif type_ == TT_IDENTIFIER:\n\t            self.binary.append(1)\n\t            if value in REGISTERS:\n\t                if value == \"ax\":\n\t                    self.binary.append(0xa)\n\t                if value == \"bx\":\n", "                    self.binary.append(0xb)\n\t                if value == \"cx\":\n\t                    self.binary.append(0xc)\n\t                if value == \"dx\":\n\t                    self.binary.append(0xd)\n\t                if value == \"sp\":\n\t                    self.binary.append(0xe)\n\t            else:\n\t                raise Exception(f\"Register not found: {value}\")\n\t            self.idx += 2\n", "        elif type_ == TT_VARIABLE:\n\t            self.make_variable(value)\n\t    def visit_LabelNode(self, node):\n\t        self.idx -= 1\n\t        if self.flag:\n\t            self.labels[node.name.value] = self.idx\n\t    def visit_JumpNode(self, node):\n\t        #label = self.labels.get(node.label.value, None) or 0\n\t        #if type(node.label.value) is str and label is None:\n\t        #    raise Exception(\"Label not found\")\n", "        self.binary.append(10)\n\t        self.make_arg(node.label, jmp=True)\n\t    def visit_JeNode(self, node):\n\t        self.idx += 1\n\t        label = self.labels.get(node.label.value, None) or 0\n\t        if type(node.label.value) is str and label is None:\n\t            raise Exception(\"Label not found\")\n\t        self.binary.append(13)\n\t        self.make_int32(label)\n\t        self.make_arg(node.argument)\n", "    def visit_JnNode(self, node):\n\t        self.idx += 1\n\t        label = self.labels.get(node.label.value, None) or 0\n\t        if type(node.label.value) is str and label is None:\n\t            raise Exception(\"Label not found\")\n\t        self.binary.append(14)\n\t        self.make_int32(label)\n\t        self.make_arg(node.argument)\n\t    def visit_JgNode(self, node):\n\t        self.idx += 1\n", "        label = self.labels.get(node.label.value, None) or 0\n\t        if type(node.label.value) is str and label is None:\n\t            raise Exception(\"Label not found\")\n\t        self.binary.append(15)\n\t        self.make_int32(label)\n\t        self.make_arg(node.argument)\n\t    def visit_JlNode(self, node):\n\t        label = self.labels.get(node.label.value, None) or 0\n\t        if type(node.label.value) is str and label is None:\n\t            raise Exception(\"Label not found\")\n", "        self.binary.append(16)\n\t        self.make_int32(label)\n\t        self.make_arg(node.argument)\n\t    def visit_JtNode(self, node):\n\t        self.idx += 1\n\t        label = self.labels.get(node.label.value, None) or 0\n\t        if type(node.label.value) is str and label is None:\n\t            raise Exception(\"Label not found\")\n\t        self.binary.append(19)\n\t        self.make_int32(label)\n", "    def visit_JfNode(self, node):\n\t        self.idx += 1\n\t        label = self.labels.get(node.label.value, None) or 0\n\t        if type(node.label.value) is str and label is None:\n\t            raise Exception(\"Label not found\")\n\t        self.binary.append(20)\n\t        self.make_int32(label)\n\t    def visit_CallNode(self, node):\n\t        #label = self.labels.get(node.label.value, None) or 0\n\t        #if type(node.label.value) is str and label is None:\n", "        #    raise Exception(\"Label not found\")\n\t        self.binary.append(11)\n\t        self.make_arg(node.label, jmp=True)\n\t        #self.make_int32(label)\n\t    def visit_RetNode(self, node):\n\t        self.binary.append(12)\n\t    def visit_MovNode(self, node):\n\t        # 1 register\n\t        # 2 int\n\t        # 3 str\n", "        # 4 variable\n\t        # 5 float\n\t        # 6 list\n\t        self.binary.append(17)\n\t        if node.left.type == TT_IDENTIFIER:\n\t            if node.left.value in REGISTERS:\n\t                self.idx += 2\n\t                self.binary.append(1)\n\t                if node.left.value == \"ax\":\n\t                    self.binary.append(0xa)\n", "                elif node.left.value == \"bx\":\n\t                    self.binary.append(0xb)\n\t                elif node.left.value == \"cx\":\n\t                    self.binary.append(0xc)\n\t                elif node.left.value == \"dx\":\n\t                    self.binary.append(0xd)\n\t                elif node.left.value == \"sp\":\n\t                    self.binary.append(0xe)\n\t            else:\n\t                raise Exception(f\"Register: {node.left.value} not found\")\n", "        elif node.left.type == TT_INT:\n\t            raise Exception(\"Cannot copy value to an integer\")\n\t        elif node.left.type == TT_FLOAT:\n\t            raise Exception(\"Cannot copy value to a float\")\n\t        elif node.left.type == TT_STRING:\n\t            raise Exception(\"Cannot copy value to a string\")\n\t        elif node.left.type == TT_VARIABLE:\n\t            self.make_variable(node.left.value)\n\t        else:\n\t            # can only happend when moving to a list\n", "            raise Exception(\"Cannot copy value to a list\")\n\t        self.make_arg(node.right)\n\t    def visit_StringNode(self, node):\n\t        return node.tok\n\t    def visit_IntegerNode(self, node):\n\t        return node.tok\n\t    def visit_FloatNode(self, node):\n\t        return node.tok\n\t    def visit_RegisterNode(self, node):\n\t        return node.tok\n", "    def visit_VariableNode(self, node):\n\t        return node.tok\n\t    def visit_ListNode(self, node):\n\t        return node\n\t    def visit_CmpNode(self, node):\n\t        cases = node.cases\n\t        self.idx += 1\n\t        self.binary.append(18)\n\t        i = 0\n\t        while True:\n", "            case = cases[i]\n\t            left = self.visit(case[0])\n\t            middle = case[1]\n\t            right = self.visit(case[2])\n\t            self.make_arg(left)\n\t            self.make_op(middle)\n\t            self.make_arg(right)\n\t            i += 1\n\t            if i >= len(cases):\n\t                break\n", "            if cases[i] == TT_AND:\n\t                self.idx += 1\n\t                self.binary.append(1)\n\t                i += 1\n\t            elif cases[i] == TT_OR:\n\t                self.idx += 1\n\t                self.binary.append(2)\n\t                i += 1\n\t        self.binary.append(0)\n\t    def visit_EOFNode(self, node):\n", "        self.idx -= 1\n\t        pass\n\t    def visit_BCallNode(self, node):\n\t        self.binary.append(22)\n\t    def visit_TestNode(self, node):\n\t        self.binary.append(24)\n\t        if node.left.type == TT_IDENTIFIER:\n\t            if node.left.value in REGISTERS:\n\t                self.idx += 1\n\t                if node.left.value == \"ax\":\n", "                    self.binary.append(0xa)\n\t                elif node.left.value == \"bx\":\n\t                    self.binary.append(0xb)\n\t                elif node.left.value == \"cx\":\n\t                    self.binary.append(0xc)\n\t                elif node.left.value == \"dx\":\n\t                    self.binary.append(0xd)\n\t                elif node.left.value == \"sp\":\n\t                    self.binary.append(0xe)\n\t            else:\n", "                raise Exception(f\"Register: {node.left.value} not found\")\n\t        elif node.left.type == TT_INT:\n\t            raise Exception(\"Cannot copy value to an integer\")\n\t        elif node.left.type == TT_FLOAT:\n\t            raise Exception(\"Cannot copy value to a float\")\n\t        elif node.left.type == TT_STRING:\n\t            raise Exception(\"Cannot copy value to a string\")\n\t        elif node.left.type == TT_VARIABLE:\n\t            self.make_variable(node.left.value)\n\t        else:\n", "            # can only happend when moving to a list\n\t            raise Exception(\"Cannot copy value to a list\")\n\t        self.make_arg(node.right)\n\t        # TODO: Finish implementation of test instruction\n\t    def visit_PtNode(self, node):\n\t        self.binary.append(25)\n\t        if node.target.type == TT_VARIABLE:\n\t            self.make_variable(node.target.value)\n\t        else:\n\t            raise Exception(\"Can only point to a variable\") # TODO: maybe change this in the future if needed\n", "        if node.storage.type == TT_VARIABLE:\n\t            self.make_variable(node.storage.value)\n\t        else:\n\t            raise Exception(\"Can only store a pointer in a variable\")\n\t    def visit_SptNode(self, node):\n\t        self.binary.append(26)\n\t        if node.target.type == TT_IDENTIFIER:\n\t            if node.target.type in REGISTERS:\n\t                self.make_register(node.target)\n\t            else:\n", "                raise Exception(f\"Register: {node.target.value} not found\")\n\t        elif node.target.type == TT_VARIABLE:\n\t            self.make_variable(node.target.value)\n\t        else:\n\t            raise Exception(\"Can only set a pointer value in a variable or a register\")\n\t        self.make_arg(node.arg)"]}
{"filename": "Alphassembly/assembler/lexer.py", "chunked_list": ["from consts import *\n\tclass Token:\n\t    def __init__(self, type_, value=None):\n\t        self.type = type_\n\t        self.value = value\n\t    def matches(self, type_, value):\n\t        return self.type == type_ and self.value == value\n\t    def __repr__(self):\n\t        if self.value: return f'{self.type}:{self.value}'\n\t        return f'{self.type}'\n", "class Lexer:\n\t    def __init__(self, text):\n\t        self.current_char = None\n\t        self.text = text\n\t        self.idx = -1\n\t        self.ln = 0\n\t        self.advance()\n\t    def advance(self):\n\t        self.idx += 1\n\t        self.current_char = self.text[self.idx] if self.idx < len(self.text) else None\n", "        if self.current_char == \"\\n\":\n\t            self.ln += 1\n\t    def make_tokens(self):\n\t        tokens = []\n\t        while self.current_char != None:\n\t            if self.current_char in \" \\t\":\n\t                self.advance()\n\t            elif self.current_char in \"#\":\n\t                sln = self.ln\n\t                while self.ln == sln:\n", "                    self.advance()\n\t            elif self.current_char == \"\\n\":\n\t                tokens.append(Token(TT_NEWLINE))\n\t                self.advance()\n\t            elif self.current_char in DIGITS:\n\t                tokens.append(self.make_number())\n\t            elif self.current_char == '\"' or self.current_char == \"'\":\n\t                tokens.append(self.make_string())\n\t            elif self.current_char in LETTERS + \"_.\":\n\t                toks = self.make_keyword()\n", "                for tok in toks:\n\t                    tokens.append(tok)\n\t            elif self.current_char in ',':\n\t                tokens.append(Token(TT_COMMA))\n\t                self.advance()\n\t            elif self.current_char == '!':\n\t                token = self.make_not_equals()\n\t                tokens.append(token)\n\t            elif self.current_char == '=':\n\t                tokens.append(self.make_equals())\n", "            elif self.current_char == '<':\n\t                tokens.append(self.make_less_than())\n\t            elif self.current_char == '>':\n\t                tokens.append(self.make_greater_than())\n\t            elif self.current_char == '&':\n\t                self.advance()\n\t                if self.current_char == '&':\n\t                    tokens.append(Token(TT_AND))\n\t                    self.advance()\n\t                else:\n", "                    raise Exception(f\"Illegal character: '{self.current_char}'\")\n\t            elif self.current_char == '|':\n\t                self.advance()\n\t                if self.current_char == '|':\n\t                    tokens.append(Token(TT_OR))\n\t                    self.advance()\n\t                else:\n\t                    raise Exception(f\"Illegal character: '{self.current_char}'\")\n\t            elif self.current_char == '[':\n\t                tokens.append(self.make_variable())\n", "            elif self.current_char == '{':\n\t                tokens.append(Token(TT_LCURLY))\n\t                self.advance()\n\t            elif self.current_char == '}':\n\t                tokens.append(Token(TT_RCURLY))\n\t                self.advance()\n\t            else:\n\t                raise Exception(f\"Illegal character: '{self.current_char}'\")\n\t        tokens.append(Token(TT_EOF))\n\t        return tokens\n", "    def make_variable(self):\n\t        var_name = ''\n\t        self.advance()\n\t        while self.current_char != ']':\n\t            if self.current_char == '\\n':\n\t                raise Exception(f\"Expected ']' line: {self.ln}\")\n\t            elif self.current_char == ']':\n\t                break\n\t            var_name += self.current_char\n\t            self.advance()\n", "        self.advance()\n\t        return Token(TT_VARIABLE, var_name)\n\t    def make_keyword(self):\n\t        id_str = ''\n\t        tokens = []\n\t        while self.current_char != None and self.current_char in LETTERS_DIGITS + '._:':\n\t            id_str += self.current_char\n\t            self.advance()\n\t        if id_str in KEYWORDS:\n\t            tok_type = TT_KEYWORD\n", "            tokens.append(Token(tok_type, id_str))\n\t        else:\n\t            if not id_str[len(id_str)-1] == \":\": \n\t                tokens.append(Token(TT_IDENTIFIER, id_str))\n\t                return tokens\n\t        if not id_str in KEYWORDS:\n\t            strlen = len(id_str)\n\t            i = 1\n\t            for char in id_str:\n\t                if char == \":\":\n", "                    if i != strlen:\n\t                        raise SyntaxError(f\"Illegal character at line {self.ln}\")\n\t                    else:\n\t                        tokens.append(Token(TT_LABEL))\n\t                        tokens.append(Token(TT_STRING, id_str[0:-1]))\n\t                i += 1\n\t        return tokens\n\t    def make_number(self):\n\t        num_str = ''\n\t        dot_count = 0\n", "        i = 0\n\t        while self.current_char != None and self.current_char in DIGITS + '-.':\n\t            if self.current_char == '.':\n\t                if dot_count == 1: break\n\t                dot_count += 1\n\t            num_str += self.current_char\n\t            self.advance()\n\t            i += 1\n\t        if dot_count == 0:\n\t            return Token(TT_INT, int(num_str))\n", "        else:\n\t            return Token(TT_FLOAT, float(num_str))\n\t    def make_string(self):\n\t        string = ''\n\t        start_char = self.current_char\n\t        escape_character = False\n\t        self.advance()\n\t        escape_characters = {\n\t            'n': '\\n',\n\t            't': '\\t',\n", "            '\"': '\"',\n\t            \"'\": \"'\",\n\t            \"\\\\\": \"\\\\\"\n\t        }\n\t        while self.current_char != None and (self.current_char != start_char or escape_character):\n\t            if escape_character:\n\t                string += escape_characters.get(self.current_char, self.current_char)\n\t            else:\n\t                if self.current_char == \"\\\\\":\n\t                    escape_character = True\n", "                    self.advance()\n\t                    continue\n\t                else:\n\t                    string += self.current_char\n\t            self.advance()\n\t            escape_character = False\n\t        self.advance()\n\t        return Token(TT_STRING, string)\n\t    def make_not_equals(self):\n\t        self.advance()\n", "        if self.current_char == '=':\n\t            self.advance()\n\t            return Token(TT_NE)\n\t        self.advance()\n\t        raise Exception(\"Expected '='\")\n\t    def make_equals(self):\n\t        self.advance()\n\t        if self.current_char == '=':\n\t            self.advance()\n\t            return Token(TT_EE)\n", "        raise Exception(\"Expected '='\")\n\t    def make_less_than(self):\n\t        tok_type = TT_LT\n\t        self.advance()\n\t        if self.current_char == '=':\n\t            self.advance()\n\t            tok_type = TT_LTE\n\t        return Token(tok_type)\n\t    def make_greater_than(self):\n\t        tok_type = TT_GT\n", "        self.advance()\n\t        if self.current_char == '=':\n\t            self.advance()\n\t            tok_type = TT_GTE\n\t        return Token(tok_type)\n"]}
{"filename": "Alphassembly/assembler/main.py", "chunked_list": ["import sys\n\timport clog\n\tfrom lexer import *\n\tfrom parser_ import *\n\tfrom assembler import *\n\tif len(sys.argv) == 1:\n\t    raise Exception(\"No file to compile\")\n\tif len(sys.argv) == 2:\n\t    outfile = \"a.asb\"\n\tif len(sys.argv) >= 3:\n", "    outfile = sys.argv[2]\n\tclog.log(f\"Compiling to {outfile}\")\n\ttry:\n\t    f = open(sys.argv[1], \"r\")\n\texcept Exception as e:\n\t    print(e)\n\t    exit(1)\n\tscript = \"\"\n\tfor i in f.readlines():\n\t    script += i\n", "script += '\\n'\n\tlexer = Lexer(script)\n\ttokens = lexer.make_tokens()\n\tf.close()\n\tparser = Parser(tokens)\n\tast = parser.parse()\n\tassembler = Assembler(ast)\n\tbinary = assembler.assemble()\n\tf = open(outfile, \"wb\")\n\tf.write(binary)\n", "f.close()\n"]}
{"filename": "Alphassembly/assembler/consts.py", "chunked_list": ["import string\n\tTT_OP = \"OP\"\n\tTT_STRING = \"STRING\"\n\tTT_IDENTIFIER = \"IDENTIFIER\"\n\tTT_INT = \"INT\"\n\tTT_FLOAT = \"FLOAT\"\n\tTT_NEWLINE = \"NEWLINE\"\n\tTT_KEYWORD = \"KEYWORD\"\n\tTT_DOUBLECOLON = \"DOUBLECOLON\"\n\tTT_LABEL = \"LABEL\"\n", "TT_COMMA = \"COMMA\"\n\tTT_EE = 'EE'\n\tTT_NE = 'NE'\n\tTT_LT = 'LT'\n\tTT_GT = 'GT'\n\tTT_LTE = 'LTE'\n\tTT_GTE = 'GTE'\n\tTT_AND = 'AND'\n\tTT_OR = 'OR'\n\tTT_VARIABLE = \"VARIABLE\"\n", "TT_LCURLY = \"LCURLY\"\n\tTT_RCURLY = \"RCURLY\"\n\tTT_EOF = \"EOF\"\n\tDIGITS = '0123456789'\n\tLETTERS = string.ascii_letters\n\tLETTERS_DIGITS = LETTERS + DIGITS\n\tKEYWORDS = [\n\t    \"push\",\n\t    \"pop\",\n\t    \"add\",\n", "    \"sub\",\n\t    \"mul\",\n\t    \"div\",\n\t    \"done\",\n\t    \"print\",\n\t    \"ld\",\n\t    \"jmp\",\n\t    \"call\",\n\t    \"ret\",\n\t    \"je\",\n", "    \"jn\",\n\t    \"jg\",\n\t    \"jl\",\n\t    \"mov\",\n\t    \"cmp\",\n\t    \"jt\",\n\t    \"jf\",\n\t    \"mod\",\n\t    \"bcall\",\n\t    \"pow\",\n", "    \"test\",\n\t    \"pt\",\n\t    \"spt\"\n\t]\n\tREGISTERS = {\n\t    \"ax\": 0xa,\n\t    \"bx\": 0xb,\n\t    \"cx\": 0xc,\n\t    \"dx\": 0xd,\n\t    \"sp\": 0xe\n", "}"]}
{"filename": "Alphassembly/assembler/clog.py", "chunked_list": ["import colorama\n\tcolorama.init()\n\tyellow_f = colorama.Fore.LIGHTYELLOW_EX\n\tred_f = colorama.Fore.LIGHTRED_EX\n\tgreen_f = colorama.Fore.LIGHTGREEN_EX\n\treset_f = colorama.Fore.RESET\n\tdef log(msg):\n\t    print(f\"{green_f}INFO:{reset_f} {msg}\")\n\tdef warning(msg):\n\t    print(f\"{yellow_f}WARNING:{reset_f} {msg}\")\n", "def error(msg):\n\t    print(f\"{red_f}ERROR:{reset_f} {msg}\")\n"]}
{"filename": "Alphassembly/assembler/run_tests.py", "chunked_list": ["from concurrent.futures import process\n\timport os\n\timport clog\n\timport subprocess as sp\n\timport sys\n\tdef test(filename):\n\t    split_text = os.path.splitext(filename)\n\t    extless = split_text[0]\n\t    if split_text[-1] == \".as\":\n\t        stdout = []\n", "        stderr = []\n\t        clog.log(f\"Compiling to tests/{extless}.asb\")\n\t        proc = sp.run([sys.executable, \n\t                        f\"main.py\", f\"tests/{filename}\", f\"tests/{extless}.asb\"],\n\t                        capture_output=True)\n\t        [stdout.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stdout.splitlines()]\n\t        [stderr.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stderr.splitlines()]\n\t        ret = proc.returncode\n\t        clog.log(f\"Running tests/{extless}.asb\")\n\t        proc = sp.run([\"C:\\\\Users\\\\gamed\\\\Documents\\\\projs\\\\alphassembly\\\\Alphassembly\\\\Alphassembly\\\\bin\\Debug\\\\net5.0\\\\Alphassembly.exe\", \n", "                       f\"tests\\\\{extless}.asb\"],\n\t                      capture_output=True)\n\t        [stdout.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stdout.splitlines()]\n\t        [stderr.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stderr.splitlines()]\n\t        ret = proc.returncode if ret == 0 else ret\n\t        with open(f\"tests/{extless}.txt\", \"w\") as log:\n\t            if not ret == 0:\n\t                log.write(f\"This test failed with exit code: {ret}\\n\\n\")\n\t            else:\n\t                log.write(f\"This test succeded with exit code: {ret}\\n\\n\")\n", "            log.write(\"stdout:\\n\")\n\t            log.writelines(stdout)\n\t            log.write(\"\\nstderr:\\n\")\n\t            log.writelines(stderr)\n\t        if ret != 0:\n\t            clog.error(f\"Test of {filename} failed with exit code: {ret}\")\n\t            return ret\n\t    return 0\n\terrors = 0\n\tfor file in os.listdir(\"tests\"):\n", "    if test(file) != 0:\n\t        errors += 1\n\tmsg = \" errors\" if errors >= 2 or errors == 0 else \" error\"\n\tprint(f\"\\nTesting ended with {errors}\" + msg)\n\tif errors != 0:\n\t    print(\"See text files in the tests directory to see what caused the error(s)\")\n"]}
{"filename": "Alphassembly/assembler/parser_.py", "chunked_list": ["from consts import *\n\tfrom nodes import *\n\tclass Parser:\n\t    def __init__(self, tokens):\n\t        self.tokens = tokens\n\t        self.current_tok = None\n\t        self.tok_idx = -1\n\t        self.advance()\n\t    def advance(self):\n\t        self.tok_idx += 1\n", "        self.current_tok = self.tokens[self.tok_idx]\n\t    def parse(self):\n\t        return self.statements()\n\t    ###############################\n\t    def statement(self):\n\t        if self.current_tok.matches(TT_KEYWORD, \"ld\"):\n\t            self.advance()\n\t            val = self.current_tok\n\t            self.advance()\n\t            return LoadNode(val)\n", "        elif self.current_tok.matches(TT_KEYWORD, \"print\"):\n\t            self.advance()\n\t            return PrintNode()\n\t        elif self.current_tok.matches(TT_KEYWORD, \"done\"):\n\t            self.advance()\n\t            return DoneNode()\n\t        elif self.current_tok.matches(TT_KEYWORD, \"pop\"):\n\t            self.advance()\n\t            arg = None\n\t            if self.current_tok.type == TT_IDENTIFIER:\n", "                arg = self.current_tok\n\t                self.advance()\n\t            return PopNode(arg)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"div\"):\n\t            self.advance()\n\t            val1 = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n", "            val2 = self.current_tok\n\t            self.advance()\n\t            return DivNode(val1, val2)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"mul\"):\n\t            self.advance()\n\t            val1 = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n", "            val2 = self.current_tok\n\t            self.advance()\n\t            return MulNode(val1, val2)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"sub\"):\n\t            self.advance()\n\t            val1 = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n", "            val2 = self.current_tok\n\t            self.advance()\n\t            return SubNode(val1, val2)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"add\"):\n\t            self.advance()\n\t            val1 = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n", "            val2 = self.current_tok\n\t            self.advance()\n\t            return AddNode(val1, val2)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"mod\"):\n\t            self.advance()\n\t            val1 = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n", "            val2 = self.current_tok\n\t            self.advance()\n\t            return ModuloNode(val1, val2)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"push\"):\n\t            self.advance()\n\t            if self.current_tok.type != TT_LCURLY:\n\t                value = self.current_tok\n\t                self.advance()\n\t            else:\n\t                value = self.expr()                \n", "            return PushNode(value)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"jmp\"):\n\t            self.advance()\n\t            label = self.current_tok\n\t            if self.current_tok.type == TT_LABEL:\n\t                raise Exception(f\"Expected identifier\")\n\t            self.advance()\n\t            return JumpNode(label)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"je\"):\n\t            self.advance()\n", "            label = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            argument = self.current_tok\n\t            self.advance()\n\t            return JeNode(label, argument)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"jn\"):\n\t            self.advance()\n", "            label = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            argument = self.current_tok\n\t            self.advance()\n\t            return JnNode(label, argument)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"jl\"):\n\t            self.advance()\n", "            label = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            argument = self.current_tok\n\t            self.advance()\n\t            return JlNode(label, argument)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"jg\"):\n\t            self.advance()\n", "            label = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            argument = self.current_tok\n\t            self.advance()\n\t            return JgNode(label, argument)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"jt\"):\n\t            self.advance()\n", "            label = self.current_tok\n\t            self.advance()\n\t            return JtNode(label)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"jf\"):\n\t            self.advance()\n\t            label = self.current_tok\n\t            self.advance()\n\t            return JfNode(label)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"call\"):\n\t            self.advance()\n", "            label = self.current_tok\n\t            self.advance()\n\t            return CallNode(label)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"bcall\"):\n\t            self.advance()\n\t            return BCallNode()\n\t        elif self.current_tok.matches(TT_KEYWORD, \"ret\"):\n\t            self.advance()\n\t            return RetNode()\n\t        elif self.current_tok.type == TT_LABEL:\n", "            self.advance()\n\t            name = self.current_tok\n\t            self.advance()\n\t            return LabelNode(name)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"mov\"):\n\t            self.advance()\n\t            target = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n", "            self.advance()\n\t            if self.current_tok.type != TT_LCURLY:\n\t                value = self.current_tok\n\t                self.advance()\n\t            else:\n\t                value = self.expr()\n\t            # when you mov from labels:\n\t            # mov ax, label\n\t            try:\n\t                if value.type == TT_KEYWORD:\n", "                    value.type = TT_IDENTIFIER\n\t            except AttributeError:\n\t                pass\n\t            return MovNode(target, value)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"cmp\"):\n\t            self.advance()\n\t            cases = []\n\t            while True:\n\t                left = self.expr()\n\t                middle = self.current_tok\n", "                self.advance()\n\t                right = self.expr()\n\t                cases.append((left, middle, right))\n\t                if self.current_tok.type == TT_AND:\n\t                    cases.append(TT_AND)\n\t                    self.advance()\n\t                elif self.current_tok.type == TT_OR:\n\t                    cases.append(TT_OR)\n\t                    self.advance()\n\t                else:\n", "                    break\n\t            return CmpNode(cases)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"pow\"):\n\t            self.advance()\n\t            val1 = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            val2 = self.current_tok\n", "            self.advance()\n\t            return PowNode(val1, val2)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"test\"):\n\t            self.advance()\n\t            target = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n\t                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            if self.current_tok.type != TT_LCURLY:\n", "                value = self.current_tok\n\t                self.advance()\n\t            else:\n\t                value = self.expr()\n\t            return TestNode(target, value)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"pt\"):\n\t            self.advance()\n\t            target = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n", "                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            storage = self.current_tok\n\t            self.advance()\n\t            return PtNode(target, storage)\n\t        elif self.current_tok.matches(TT_KEYWORD, \"spt\"):\n\t            self.advance()\n\t            target = self.current_tok\n\t            self.advance()\n\t            if not self.current_tok.type == TT_COMMA:\n", "                raise Exception(f\"Expected ','\")\n\t            self.advance()\n\t            arg = self.current_tok\n\t            self.advance()\n\t            return SptNode(target, arg)\n\t        elif self.current_tok.matches(TT_EOF, None):\n\t            return EOFNode()\n\t        else:\n\t            return self.expr()\n\t            #raise Exception(f\"Unknown instruction: {self.current_tok.value}\")\n", "    def statements(self):\n\t        statements = []\n\t        while self.current_tok.type == TT_NEWLINE:\n\t            self.advance()\n\t        statements.append(self.statement())\n\t        more_statements = True\n\t        while True:\n\t            newline_count = 0\n\t            while self.current_tok.type == TT_NEWLINE:\n\t                self.advance()\n", "                newline_count += 1\n\t            if newline_count == 0:\n\t                more_statements = False\n\t            if not more_statements: break\n\t            statements.append(self.statement())\n\t        return statements\n\t    def expr(self):\n\t        tok = self.current_tok\n\t        if self.current_tok.type == TT_STRING:\n\t            self.advance()\n", "            return StringNode(tok)\n\t        elif self.current_tok.type == TT_INT:\n\t            self.advance()\n\t            return IntegerNode(tok)\n\t        elif self.current_tok.type == TT_FLOAT:\n\t            self.advance()\n\t            return FloatNode(tok)\n\t        elif self.current_tok.type == TT_IDENTIFIER:\n\t            if self.current_tok.value in REGISTERS:\n\t                self.advance()\n", "                return RegisterNode(tok)\n\t            else:\n\t                raise Exception(f\"Unexpected identifier: {self.current_tok.value}\")\n\t        elif self.current_tok.type == TT_VARIABLE:\n\t            self.advance()\n\t            return VariableNode(tok)\n\t        elif self.current_tok.type == TT_LCURLY:\n\t            self.advance()\n\t            lst = []\n\t            if self.current_tok.type != TT_RCURLY:\n", "                lst.append(self.expr())\n\t                if self.current_tok.type == TT_RCURLY:\n\t                    self.advance()\n\t                    return ListNode(lst)\n\t                elif self.current_tok.type == TT_COMMA:\n\t                    while self.current_tok.type != TT_NEWLINE:\n\t                        self.advance()\n\t                        lst.append(self.expr())\n\t                        if self.current_tok.type == TT_RCURLY:\n\t                            self.advance()\n", "                            return ListNode(lst)\n\t                    raise Exception(\"Expected '}'\")\n\t                else:\n\t                    raise Exception(\"expected '}' or ','\")\n\t            else:\n\t                self.advance()\n\t                return ListNode([])\n\t        else:\n\t            raise Exception(\"Syntax Error\")"]}
{"filename": "Alphassembly/assembler/nodes.py", "chunked_list": ["class EOFNode:\n\t    def __init__(self):\n\t        pass\n\tclass SptNode:\n\t    def __init__(self, target, arg):\n\t        self.target = target\n\t        self.arg = arg\n\tclass PtNode:\n\t    def __init__(self, target, storage):\n\t        self.target = target\n", "        self.storage = storage\n\tclass BCallNode:\n\t    def __init__(self):\n\t        pass\n\tclass ModuloNode:\n\t    def __init__(self, val1, val2):\n\t        self.val1 = val1\n\t        self.val2 = val2\n\tclass LoadNode:\n\t    def __init__(self, string):\n", "        self.string = string\n\tclass PrintNode:\n\t    def __init__(self):\n\t        pass\n\tclass StringNode:\n\t    def __init__(self, val):\n\t        self.tok = val\n\tclass VariableNode:\n\t    def __init__(self, tok) -> None:\n\t        self.tok = tok\n", "class IntegerNode:\n\t    def __init__(self, val):\n\t        self.tok = val\n\tclass FloatNode:\n\t    def __init__(self, val):\n\t        self.tok = val\n\tclass RegisterNode:\n\t    def __init__(self, val):\n\t        self.tok = val\n\tclass CmpNode:\n", "    def __init__(self, cases):\n\t        self.cases = cases\n\tclass DoneNode:\n\t    def __init__(self):\n\t        pass\n\tclass PopNode:\n\t    def __init__(self, reg):\n\t        self.reg = reg\n\tclass DivNode:\n\t    def __init__(self, val1, val2):\n", "        self.val1 = val1\n\t        self.val2 = val2\n\tclass MulNode:\n\t    def __init__(self, val1, val2):\n\t        self.val1 = val1\n\t        self.val2 = val2\n\tclass SubNode:\n\t    def __init__(self, val1, val2):\n\t        self.val1 = val1\n\t        self.val2 = val2\n", "class AddNode:\n\t    def __init__(self, val1, val2):\n\t        self.val1 = val1\n\t        self.val2 = val2\n\tclass PowNode:\n\t    def __init__(self, val1, val2):\n\t        self.val1 = val1\n\t        self.val2 = val2\n\tclass PushNode:\n\t    def __init__(self, value):\n", "        self.value = value\n\tclass LabelNode:\n\t    def __init__(self, name):\n\t        self.name = name\n\tclass JumpNode:\n\t    def __init__(self, label):\n\t        self.label = label\n\tclass JeNode:\n\t    def __init__(self, label, argument):\n\t        self.label = label\n", "        self.argument = argument\n\tclass JnNode:\n\t    def __init__(self, label, argument):\n\t        self.label = label\n\t        self.argument = argument\n\tclass JgNode:\n\t    def __init__(self, label, argument):\n\t        self.label = label\n\t        self.argument = argument\n\tclass JlNode:\n", "    def __init__(self, label, argument):\n\t        self.label = label\n\t        self.argument = argument\n\tclass JtNode:\n\t    def __init__(self, label):\n\t        self.label = label\n\tclass JfNode:\n\t    def __init__(self, label):\n\t        self.label = label\n\tclass CallNode:\n", "    def __init__(self, label):\n\t        self.label = label\n\tclass RetNode:\n\t    def __init__(self):\n\t        pass\n\tclass MovNode:\n\t    def __init__(self, left, right):\n\t        self.left = left\n\t        self.right = right\n\tclass ListNode:\n", "    def __init__(self, nodes_list):\n\t        self.nodes_list = nodes_list\n\tclass TestNode:\n\t    def __init__(self, left, right):\n\t        self.left = left\n\t        self.right = right\n"]}
{"filename": "Alphassembly/assembler/glang/glc.py", "chunked_list": ["import getopt\n\timport sys\n\timport clog\n\timport utils\n\timport os\n\tfrom builtins_ import *\n\tfrom modules.consts import TT_KEYWORD, TT_STRING, TT_EOF, TT_KEYWORD, TT_NEWLINE\n\tfrom modules import lexer, _parser, codegen, errors, nodes, consts\n\t# glang Compiler\n\t# glc\n", "try:\n\t    opts, args = getopt.getopt(sys.argv[1:], \"o:I:shr\")\n\texcept getopt.GetoptError as e:\n\t    clog.error(e)\n\t    exit(1)\n\tHELP = \"\"\"\\\n\tUsage: glc [options] file...\n\t  -o <file>         Place the output into <file>\n\t  -I <directory>    Add <directory> to include search path .\\\\std is added by default\n\t  -s                Doesn't print compilation information\n", "  -r                Compile program and run afterwards\n\t  -h                Displays this message\\\n\t\"\"\"\n\t# argument parsing\n\tsilent = False\n\trun = False\n\toutput = \"a.asb\"\n\tinclude = ['.\\\\', '.\\\\std\\\\']\n\tfor opt in opts:\n\t    if opt[0] == '-h':\n", "        print(HELP)\n\t        exit()\n\t    elif opt[0] == '-o':\n\t        output = opt[1]\n\t    elif opt[0] == '-s':\n\t        silent = True\n\t    elif opt[0] == '-r':\n\t        run = True\n\t    elif opt[0] == '-I':\n\t        if opt[1][-1] != '\\\\':\n", "            opt[1] += '\\\\'\n\t        include.append(opt[1])\n\tif len(args) < 1:\n\t    utils.error(\"no input files\")\n\t    utils.fail(1)\n\telif len(args) > 1:\n\t    utils.error(\"more than 1 input files not supported yet\")\n\t    utils.fail(1)\n\tdef assemble(filename):\n\t    # switch this to an cx_Freeze executable in PATH\n", "    cmd(f\"..\\\\main.py {filename} {output}\", f\"alsm {filename} {output}\")\n\tdef cmd(command, message=None):\n\t    if not silent:\n\t        if message is None:\n\t            clog.log(f\"[CMD] {command}\")\n\t        else:\n\t            clog.log(f\"[CMD] {message}\")\n\t    os.system(command)\n\tdef preprocess(tokens):\n\t    i = 0\n", "    included_files = []\n\t    while i < len(tokens):\n\t        token = tokens[i]\n\t        if token.matches(TT_KEYWORD, 'include'):\n\t            token = tokens[i+1]\n\t            if token.type != TT_STRING:\n\t                return None, errors.InvalidSyntaxError(token.pos_start,\n\t                                                       token.pos_end,\n\t                                                       \"Expected string\")\n\t            del tokens[i]\n", "            inc = token\n\t            del tokens[i]\n\t            if not inc.value in included_files:\n\t                for path in include:\n\t                    try:\n\t                        f = open(path + inc.value, \"r\")\n\t                        f.close()\n\t                        f = path + inc.value\n\t                        included_files.append(inc.value)\n\t                        break\n", "                    except FileNotFoundError:\n\t                        f = None\n\t                if f is None:\n\t                    return None, errors.IncludeError(inc.pos_start,\n\t                                            inc.pos_end,\n\t                                            f\"File not found {inc.value} in the include path\")\n\t                with open(f, \"r\") as file:\n\t                    text = \"\"\n\t                    for char in file.readlines():\n\t                        text += char\n", "                text += '\\n'\n\t                lex = lexer.Lexer(inc.value, text)\n\t                toks = lex.make_tokens()\n\t                temp = tokens\n\t                tokens = toks[0]\n\t                tokens.extend(temp)\n\t                i = -1\n\t        i += 1\n\t    temp_tokens = []\n\t    i = 0\n", "    while i <= len(tokens)-1:\n\t        token = tokens[i]\n\t        if token.type == TT_EOF and i != len(tokens)-1:\n\t            pass\n\t        elif token.matches(TT_KEYWORD, 'end'):\n\t            temp_tokens.append(lexer.Token(TT_KEYWORD, 'end', pos_start=token.pos_start,\n\t                                           pos_end=token.pos_end))\n\t            temp_tokens.append(lexer.Token(TT_NEWLINE, pos_start=token.pos_start,\n\t                                           pos_end=token.pos_end))\n\t        else:\n", "            temp_tokens.append(token)\n\t        i += 1\n\t    tokens = temp_tokens\n\t    return tokens, None\n\tdef compile():\n\t    with open(args[0], \"r\") as f:\n\t        text = \"\"\n\t        for char in f.readlines():\n\t            text += char\n\t    try:\n", "        text += '\\n'\n\t        lex = lexer.Lexer(args[0], text)\n\t        tokens, error = lex.make_tokens()\n\t        if error:\n\t            utils.errorp(error)\n\t            utils.fail(1)\n\t    except Exception as e:\n\t        utils.errorp(e)\n\t        utils.fail(1)\n\t    try:\n", "        tokens, error = preprocess(tokens)\n\t        if error:\n\t            utils.errorp(error)\n\t            utils.fail(1)\n\t    except Exception as e:\n\t        utils.errorp(e)\n\t        utils.fail(1)\n\t    out = os.path.splitext(output)[0]\n\t    if not silent:\n\t        clog.log(f\"Generating {out}.as\")\n", "    try:\n\t        parser = _parser.Parser(tokens)\n\t        result = parser.parse()\n\t        try:\n\t            if result.error:\n\t                utils.errorp(result.error)\n\t                utils.fail(1)\n\t        except AttributeError:\n\t            pass\n\t        ast, call_nodes, var_accesses = result\n", "    except Exception as e:\n\t        utils.errorp(e)\n\t        utils.fail(1)\n\t    if ast.error:\n\t        utils.errorp(ast.error)\n\t        utils.fail(1)\n\t    init = \"\"\n\t    init += \"mov [true], 1\\n\"\n\t    init += \"mov [false], 0\\n\\n\"\n\t    for text in BUILTINS:\n", "        init += text\n\t    # dead code elimination\n\t    for node in ast.node:\n\t        if isinstance(node, nodes.FuncDefNode):\n\t            if not node.func_name_tok.value in call_nodes \\\n\t                and not node.func_name_tok.value in var_accesses:\n\t                ast.node.remove(node)\n\t    #try:\n\t    cdgen = codegen.Codegen()\n\t    result = cdgen.emit(ast.node)\n", "    result, error = result.value, result.error\n\t    #except Exception as e:\n\t    #    utils.errorp(e)\n\t    #    utils.fail(1)\n\t    if error:\n\t        utils.errorp(error)\n\t        utils.fail(1)\n\t    result = init + cdgen.hoisted_definitions + result\n\t    with open(out + \".as\", \"w\") as o:\n\t        o.write(result)\n", "    try:\n\t        assemble(out + \".as\")\n\t    except Exception as e:\n\t        utils.errorp(e)\n\t        utils.fail(1)\n\t    if run:\n\t        cmd(f'..\\\\..\\\\bin\\\\Debug\\\\net5.0\\\\Alphassembly.exe {output}')\n\tcompile()\n"]}
{"filename": "Alphassembly/assembler/glang/clog.py", "chunked_list": ["import colorama\n\tcolorama.init()\n\tyellow_f = colorama.Fore.LIGHTYELLOW_EX\n\tred_f = colorama.Fore.LIGHTRED_EX\n\tgreen_f = colorama.Fore.LIGHTGREEN_EX\n\treset_f = colorama.Fore.RESET\n\tdef log(msg):\n\t    print(f\"{green_f}INFO:{reset_f} {msg}\")\n\tdef warning(msg):\n\t    print(f\"{yellow_f}WARNING:{reset_f} {msg}\")\n", "def error(msg):\n\t    print(f\"{red_f}ERROR:{reset_f} {msg}\")\n"]}
{"filename": "Alphassembly/assembler/glang/utils.py", "chunked_list": ["import clog\n\terrors = 0\n\tdef error(msg):\n\t    global errors\n\t    errors += 1\n\t    clog.error(msg)\n\tdef errorp(msg):\n\t    \"\"\"only prints the error without clog.error\"\"\"\n\t    global errors\n\t    errors += 1\n", "    print(msg)\n\tdef fail(code=0):\n\t    print(\"Compilation terminated due to previous error(s).\")\n\t    exit(code)\n"]}
{"filename": "Alphassembly/assembler/glang/builtins_.py", "chunked_list": ["# builtins tuple\n\t# list of things the compiler uses\n\t# see builtins/ for readable code version\n\tBUILTINS = (\n\t    \"\"\"\"\"\"\n\t)"]}
{"filename": "Alphassembly/assembler/glang/modules/lexer.py", "chunked_list": ["from tokenize import Double\n\tfrom .position import *\n\tfrom .errors import *\n\tfrom .consts import *\n\tclass Token:\n\t    def __init__(self, type_, value=None, pos_start=None, pos_end=None):\n\t        self.type = type_\n\t        self.value = value\n\t        if pos_start:\n\t            self.pos_start = pos_start.copy()\n", "            self.pos_end = pos_start.copy()\n\t            self.pos_end.advance()\n\t        if pos_end:\n\t            self.pos_end = pos_end.copy()\n\t    def matches(self, type_, value):\n\t        return self.type == type_ and self.value == value\n\t    def __repr__(self):\n\t        if self.value: return f'{self.type}:{self.value}'\n\t        return f'{self.type}'\n\tclass Lexer:\n", "    def __init__(self, fn, text):\n\t        self.fn = fn\n\t        self.text = text\n\t        self.pos = Position(-1, 0, -1, fn, text)\n\t        self.current_char = None\n\t        self.advance()\n\t    def advance(self):\n\t        self.pos.advance(self.current_char)\n\t        self.current_char = self.text[self.pos.idx] if self.pos.idx < len(self.text) else None\n\t    def make_tokens(self):\n", "        tokens = []\n\t        while self.current_char is not None:\n\t            if self.current_char in ' \\t':\n\t                self.advance()\n\t            elif self.current_char == '#':\n\t                self.advance()\n\t                while self.current_char != '\\n':\n\t                    self.advance()\n\t                self.advance()\n\t            elif self.current_char in ';\\n':\n", "                tokens.append(Token(TT_NEWLINE, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char in DIGITS:\n\t                tokens.append(self.make_number())\n\t            elif self.current_char in LETTERS:\n\t                toks = self.make_identifier()\n\t                for tok in toks:\n\t                    tokens.append(tok)\n\t            elif self.current_char in '\\'\"':\n\t                tokens.append(self.make_string())\n", "            elif self.current_char == ',':\n\t                tokens.append(Token(TT_COMMA, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == ',':\n\t                tokens.append(Token(TT_COMMA, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == '+':\n\t                tokens.append(Token(TT_PLUS, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == '-':\n", "                tokens.append(Token(TT_MINUS, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == '*':\n\t                if len(self.text) > 1 and self.text[self.pos.idx + 1] == \"*\":\n\t                    pos_start = self.pos.copy()\n\t                    self.advance()\n\t                    tokens.append(Token(TT_POW, pos_start=pos_start, pos_end=self.pos))\n\t                else:\n\t                    tokens.append(Token(TT_MUL, pos_start=self.pos))\n\t                self.advance()\n", "            elif self.current_char == '/':\n\t                tokens.append(Token(TT_DIV, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == '%':\n\t                tokens.append(Token(TT_MOD, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == '!':\n\t                token, error = self.make_not_equals()\n\t                if error: return [], error\n\t                tokens.append(token)\n", "            elif self.current_char == '=':\n\t                tokens.append(self.make_equals())\n\t            elif self.current_char == '<':\n\t                tokens.append(self.make_less_than())\n\t            elif self.current_char == '>':\n\t                tokens.append(self.make_greater_than())\n\t            elif self.current_char == '(':\n\t                tokens.append(Token(TT_LPAREN, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == ')':\n", "                tokens.append(Token(TT_RPAREN, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == '[':\n\t                tokens.append(Token(TT_LSQUARE, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == ']':\n\t                tokens.append(Token(TT_RSQUARE, pos_start=self.pos))\n\t                self.advance()\n\t            elif self.current_char == ':':\n\t                tokens.append(Token(TT_DCOLON, pos_start=self.pos))\n", "                self.advance()\n\t            elif self.current_char == '.':\n\t                tokens.append(Token(TT_DOT, pos_start=self.pos))\n\t                self.advance()\n\t            else:\n\t                pos_start = self.pos.copy()\n\t                char = self.current_char\n\t                self.advance()\n\t                return [], IllegalCharError(pos_start, self.pos, \"'\" + char + \"'\")\n\t        tokens.append(Token(TT_EOF, pos_start=self.pos))\n", "        return tokens, None\n\t    def make_not_equals(self):\n\t        pos_start = self.pos.copy()\n\t        self.advance()\n\t        if self.current_char == '=':\n\t            self.advance()\n\t            return Token(TT_NE, pos_start=pos_start, pos_end=self.pos), None\n\t        self.advance()\n\t        return None, ExpectedCharError(pos_start, self.pos, \"'=' (after '!')\")\n\t    def make_equals(self):\n", "        tok_type = TT_EQ\n\t        pos_start = self.pos.copy()\n\t        self.advance()\n\t        if self.current_char == '=':\n\t            self.advance()\n\t            tok_type = TT_EE\n\t        return Token(tok_type, pos_start=pos_start, pos_end=self.pos)\n\t    def make_less_than(self):\n\t        tok_type = TT_LT\n\t        pos_start = self.pos.copy()\n", "        self.advance()\n\t        if self.current_char == '=':\n\t            self.advance()\n\t            tok_type = TT_LTE\n\t        return Token(tok_type, pos_start=pos_start, pos_end=self.pos)\n\t    def make_greater_than(self):\n\t        tok_type = TT_GT\n\t        pos_start = self.pos.copy()\n\t        self.advance()\n\t        if self.current_char == '=':\n", "            self.advance()\n\t            tok_type = TT_GTE\n\t        return Token(tok_type, pos_start=pos_start, pos_end=self.pos)\n\t    def make_number(self):\n\t        num_str = ''\n\t        dot_count = 0\n\t        pos_start = self.pos.copy()\n\t        while self.current_char is not None and self.current_char in DIGITS + '.':\n\t            if self.current_char == '.':\n\t                if dot_count == 1: break\n", "                dot_count += 1\n\t            num_str += self.current_char\n\t            self.advance()\n\t        if dot_count == 0:\n\t            return Token(TT_INT, int(num_str), pos_start, self.pos)\n\t        else:\n\t            return Token(TT_FLOAT, str(num_str), pos_start, self.pos)\n\t    def make_string(self):\n\t        string = ''\n\t        pos_start = self.pos.copy()\n", "        start_char = self.current_char\n\t        escape_character = False\n\t        self.advance()\n\t        escape_characters = {\n\t            'n': '\\\\n',\n\t            't': '\\\\t',\n\t            '\"': '\\\\\"',\n\t            \"'\": \"\\\\'\",\n\t            \"\\\\\": \"\\\\\\\\\",\n\t            \"b\": \"\\b\",\n", "            \"f\": \"\\f\",\n\t            \"r\": \"\\r\",\n\t            \"v\": \"\\v\"\n\t        }\n\t        while self.current_char != None and (self.current_char != start_char or escape_character):\n\t            if escape_character:\n\t                string += escape_characters.get(self.current_char, self.current_char)\n\t            else:\n\t                if self.current_char == '\\\\':\n\t                    escape_character = True\n", "                    self.advance()\n\t                    continue\n\t                else:\n\t                    string += self.current_char\n\t            self.advance()\n\t            escape_character = False\n\t        self.advance()\n\t        return Token(TT_STRING, string, pos_start, self.pos)\n\t    def make_identifier(self):\n\t        id_str = ''\n", "        pos_start = self.pos.copy()\n\t        tokens = []\n\t        postokens = []\n\t        while self.current_char != None and self.current_char in LETTERS_DIGITS + '_[]':\n\t            if self.current_char == '[':\n\t                postokens.append(Token(TT_LSQUARE, pos_start=pos_start))\n\t                self.advance()\n\t                continue\n\t            elif self.current_char == ']':\n\t                postokens.append(Token(TT_RSQUARE, pos_start=pos_start))\n", "                self.advance()\n\t                continue\n\t            id_str += self.current_char\n\t            self.advance()\n\t        tok_type = TT_KEYWORD if id_str in KEYWORDS else TT_IDENTIFIER\n\t        tokens.append(Token(tok_type, id_str, pos_start, self.pos))\n\t        [tokens.append(tok) for tok in postokens]\n\t        return tokens\n"]}
{"filename": "Alphassembly/assembler/glang/modules/codegen.py", "chunked_list": ["from asyncio import ReadTransport\n\tfrom doctest import OutputChecker\n\tfrom .errors import *\n\tfrom .ctresult import *\n\tfrom .consts import *\n\tfrom .nodes import *\n\tfrom .builtins import *\n\tfrom .lexer import Token\n\tclass Codegen:\n\t    def __init__(self):\n", "        self.label_idx = 0\n\t        self.var_idx = 0\n\t        self.loopsc = []\n\t        self.loopsb = []\n\t        self.loop_breakc = False\n\t        self.class_bcall = '18'\n\t        self.class_definitions = {}\n\t        self.hoisted_definitions = ''\n\t    def emit(self, node):\n\t        method_name = f'emit_{type(node).__name__}'\n", "        method = getattr(self, method_name, self.no_emit_method)\n\t        return method(node)\n\t    def no_emit_method(self, node):\n\t        raise Exception(f\"No emit_{type(node).__name__} method defined\")\n\t    def emit_list(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        for element_node in node:\n\t            output += res.register(self.emit(element_node))\n\t            if res.should_return(): return res\n", "        return res.success(output)\n\t    def emit_StringNode(self, node):\n\t        res = CTResult()\n\t        output = \"mov ax, \"\n\t        output += '\"' + node.tok.value + '\"\\n'\n\t        return res.success(output)\n\t    def emit_IntegerNode(self, node):\n\t        res = CTResult()\n\t        output = \"mov ax, \"\n\t        output += str(node.tok.value) + '\\n'\n", "        return res.success(output)\n\t    def emit_FloatNode(self, node):\n\t        res = CTResult()\n\t        output = \"mov ax, \"\n\t        output += str(node.tok.value) + '\\n'\n\t        return res.success(output)\n\t    def emit_ListNode(self, node):\n\t        res = CTResult()\n\t        # TODO: implement this\n\t        output = \"\"\n", "        length = len(node.element_nodes)\n\t        variables = []\n\t        # make list of arguments\n\t        for _ in range(length):\n\t            variables.append(self.var_idx)\n\t            self.var_idx += 1\n\t        i = 0\n\t        for var in variables:\n\t            output += res.register(self.emit(node.element_nodes[i]))\n\t            if res.error: return res\n", "            output += f\"mov [.V{var}], ax\\n\"\n\t            i += 1\n\t        output += 'mov ax, {'\n\t        i = 0\n\t        for var in variables:\n\t            output += f\"[.V{var}]\"\n\t            if not i == len(variables)-1:\n\t                output += ', '\n\t            i += 1\n\t        output += '}\\n'\n", "        #print(output)\n\t        #exit()\n\t        return res.success(output)\n\t    def emit_VarAssignNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        if type(node.var_name_tok) is BinOpNode:\n\t            if type(node.var_name_tok.left_node) is not VarAccessNode:\n\t                node.var_name_tok.left_node = VarAccessNode(node.var_name_tok.left_node.tok)\n\t            output += res.register(self.emit(node.value_node))\n", "            if res.error: return res\n\t            output += f\"push ax\\n\"\n\t            self.class_bcall = '17'\n\t            output += res.register(self.emit(node.var_name_tok))\n\t            if res.error: return res\n\t            self.class_bcall = '18'\n\t            return res.success(output)\n\t        output += res.register(self.emit(node.value_node))\n\t        if res.error: return res\n\t        output += f\"mov [{node.var_name_tok.value}], ax\\n\"\n", "        return res.success(output)\n\t    def emit_VarAccessNode(self, node):\n\t        res = CTResult()\n\t        return res.success(f\"mov ax, [{node.var_name_tok.value}]\\n\")\n\t    def op_op(self, node):\n\t        output = \"\"\n\t        op = \"\"\n\t        # TODO:\n\t        # make this to put it in a variable instead\n\t        # as it wont work when calling functions for example\n", "        # can probably be done for just functions\n\t        if node.op_tok.type == TT_EE:\n\t            op = \"== \"\n\t        elif node.op_tok.type == TT_NE:\n\t            op = \"!= \"\n\t        elif node.op_tok.type == TT_LT:\n\t            op = \"< \"\n\t        elif node.op_tok.type == TT_GT:\n\t            op = \"> \"\n\t        elif node.op_tok.type == TT_LTE:\n", "            op = \"<= \"\n\t        elif node.op_tok.type == TT_GTE:\n\t            op = \">= \"\n\t        if op != \"\":\n\t            if type(node.left_node) is not VarAccessNode and type(node.left_node) is not StringNode:\n\t                output += f\"{node.left_node.tok.value} \"\n\t            elif type(node.left_node) is StringNode:\n\t                output += f\"\\\"{node.left_node.tok.value}\\\" \"\n\t            elif type(node.left_node) is VarAccessNode:\n\t                output += f\"[{node.left_node.var_name_tok.value}] \"\n", "            output += op\n\t            if type(node.right_node) is not VarAccessNode and type(node.right_node) is not StringNode:\n\t                output += f\"{node.right_node.tok.value} \"\n\t            elif type(node.right_node) is StringNode:\n\t                output += f\"\\\"{node.right_node.tok.value}\\\" \"\n\t            elif type(node.right_node) is VarAccessNode:\n\t                output += f\"[{node.right_node.var_name_tok.value}] \"\n\t        return output\n\t    def andor_op(self, node, a=False):\n\t        res = CTResult()\n", "        if not a:\n\t            output = \"cmp \"\n\t        else:\n\t            output = \"\"\n\t        lnode = node.left_node\n\t        rnode = node.right_node\n\t        if lnode.op_tok.matches(TT_KEYWORD, 'and'):\n\t            output += res.register(self.andor_op(lnode, True)) + \"&& \"\n\t            if res.error: return res\n\t        elif lnode.op_tok.matches(TT_KEYWORD, 'or'):\n", "            output += res.register(self.andor_op(lnode, True)) + \"|| \"\n\t            if res.error: return res\n\t        output += self.op_op(lnode)\n\t        if node.op_tok.matches(TT_KEYWORD, 'and') and not lnode.op_tok.matches(TT_KEYWORD, 'and'):\n\t            if output[-3:-1] in ('&&', '||'):\n\t                output = output[:-3]\n\t            output += \"&& \"\n\t        if node.op_tok.matches(TT_KEYWORD, 'or') and not lnode.op_tok.matches(TT_KEYWORD, 'or'):\n\t            if output[-3:-1] in ('&&', '||'):\n\t                output = output[:-3]\n", "            output += \"|| \"\n\t        output += self.op_op(rnode)\n\t        return res.success(output)\n\t    def class_def(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        last_node = node.right_node\n\t        while type(last_node) is BinOpNode:\n\t            last_node = last_node.right_node\n\t        nd, _ = node.remove_last_node()\n", "        self.class_bcall = '18'\n\t        output += res.register(self.emit(nd))\n\t        if res.error: return res\n\t        self.class_bcall = '17'\n\t        output += 'push ax\\n'\n\t        output += f'mov ax, \"{last_node.var_name_tok.value}\"\\n'\n\t        output += 'push ax\\n'\n\t        #output += 'mov ax, 17\\n'\n\t        #output += 'bcall\\n'\n\t        return res.success(output)\n", "    def class_access(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        i = 0\n\t        right = node.right_node\n\t        while type(right) is BinOpNode:\n\t            right = right.right_node\n\t            i += 1\n\t        output += res.register(self.emit(node.left_node))\n\t        if res.error: return res\n", "        output += 'push ax\\n'\n\t        right = node.right_node\n\t        if type(right) is BinOpNode:\n\t            left = node.right_node.left_node\n\t        while type(right) is BinOpNode:\n\t            if type(right) is BinOpNode:\n\t                left = right.left_node\n\t                right = right.right_node\n\t            output += f'mov ax, \"{left.var_name_tok.value}\"\\n'\n\t            output += f'push ax\\n'\n", "            output += f'mov ax, {self.class_bcall}\\n'\n\t            output += 'bcall\\n'\n\t            output += f'push ax\\n'\n\t        if type(node.right_node) is CallNode:            \n\t            output += f'mov ax, \"{node.right_node.node_to_call.var_name_tok.value}\"\\n'\n\t            output += 'push ax\\n'\n\t        elif type(node.right_node) is not BinOpNode:\n\t            output += f'mov ax, \"{node.right_node.var_name_tok.value}\"\\n'\n\t            output += f'push ax\\n'\n\t        else:\n", "            output += f'mov ax, \"{right.var_name_tok.value}\"\\n'\n\t            output += f'push ax\\n'\n\t        return res.success(output)\n\t    def emit_BinOpNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        if not node.op_tok.value in ('and', 'or', 'DOT') and not node.op_tok.type in (TT_DOT):\n\t            if res.should_return(): return res\n\t            output += res.register(self.emit(node.right_node))\n\t            if node.op_tok.type in (TT_PLUS, TT_MINUS, TT_MUL, TT_DIV, TT_MOD):\n", "                output += \"push ax\\n\"\n\t            else:\n\t                output += \"mov bx, ax\\n\"\n\t                output += \"push ax\\n\"\n\t            output += res.register(self.emit(node.left_node))\n\t            if res.should_return(): return res\n\t        else:\n\t            if node.op_tok.matches(TT_KEYWORD, 'and') or node.op_tok.matches(TT_KEYWORD, 'or'):\n\t                output += res.register(self.emit(node.left_node))\n\t                if res.error: return res\n", "                left_var = self.var_idx\n\t                self.var_idx += 1\n\t                output += \"test ax, ax\\n\"\n\t                output += f\"mov [.V{left_var}], ax\\n\"\n\t                output += res.register(self.emit(node.right_node))\n\t                if res.error: return res\n\t                right_var = self.var_idx\n\t                self.var_idx += 1\n\t                output += \"test ax, ax\\n\"\n\t                output += f\"mov [.V{right_var}], ax\\n\"\n", "                # allows for something like this:\n\t                # 1 and 1 | 1 or 2 | foo() and bar()\n\t                if type(node.right_node) is not BinOpNode:\n\t                    varname = Token(TT_IDENTIFIER, f'.V{right_var}',\n\t                                    node.right_node.pos_start,\n\t                                    node.right_node.pos_start)\n\t                    node.right_node = BinOpNode(VarAccessNode(varname), Token(TT_NE, None,\n\t                                                                       node.right_node.pos_start, \n\t                                                                       node.right_node.pos_end),\n\t                                                                       IntegerNode(Token(TT_INT, 0,\n", "                                                                                         node.right_node.pos_start,\n\t                                                                                         node.right_node.pos_end)))\n\t                if type(node.left_node) is not BinOpNode:\n\t                    varname = Token(TT_IDENTIFIER, f'.V{left_var}',\n\t                                    node.left_node.pos_start,\n\t                                    node.left_node.pos_start)\n\t                    node.left_node = BinOpNode(VarAccessNode(varname), Token(TT_NE, None,\n\t                                                                       node.left_node.pos_start, \n\t                                                                       node.left_node.pos_end),\n\t                                                                       IntegerNode(Token(TT_INT, 0,\n", "                                                                                         node.left_node.pos_start,\n\t                                                                                         node.left_node.pos_end)))\n\t                output += res.register(self.andor_op(node)) + '\\n'\n\t                if res.error: return res\n\t                l0 = self.label_idx\n\t                self.label_idx += 1\n\t                l1 = self.label_idx\n\t                self.label_idx += 1\n\t                l2 = self.label_idx\n\t                self.label_idx += 1\n", "                output += f\"jt .L{l0}\\n\"\n\t                output += f\"jmp .L{l1}\\n\"\n\t                output += f\".L{l0}:\\n\"\n\t                output += f\"    mov ax, 1\\n\"\n\t                output += f\"    jmp .L{l2}\\n\"\n\t                output += f\".L{l1}:\\n\"\n\t                output += f\"    mov ax, 0\\n\"\n\t                output += f\".L{l2}:\\n\"\n\t                return res.success(output)\n\t        if node.op_tok.type == TT_DOT:\n", "            if self.class_bcall == '18':\n\t                output += res.register(self.class_access(node))\n\t            else:\n\t                output += res.register(self.class_def(node))\n\t            if res.error: return res\n\t            output += f'mov ax, {self.class_bcall}\\n'\n\t            output += 'bcall\\n'\n\t            if type(node.right_node) is CallNode:\n\t                tempvar = self.var_idx\n\t                output += f'mov [.V{tempvar}], ax\\n'\n", "                self.var_idx += 1\n\t                for arg in node.right_node.arg_nodes[::-1]:\n\t                    output += res.register(self.emit(arg))\n\t                    if res.error: return res\n\t                    output += 'push ax\\n'\n\t                output += res.register(self.emit(node.left_node))\n\t                if res.error: return res\n\t                output += 'push ax\\n'\n\t                output += f'call [.V{tempvar}]\\n'\n\t        elif node.op_tok.type == TT_PLUS:\n", "            output += \"add ax, sp\\n\"\n\t            output += \"pop\\n\"\n\t        elif node.op_tok.type == TT_MINUS:\n\t            output += \"sub ax, sp\\n\"\n\t            output += \"pop\\n\"\n\t        elif node.op_tok.type == TT_MUL:\n\t            output += \"mul ax, sp\\n\"\n\t            output += \"pop\\n\"\n\t        elif node.op_tok.type == TT_DIV:\n\t            output += \"div ax, sp\\n\"\n", "            output += \"pop\\n\"\n\t        elif node.op_tok.type == TT_POW:\n\t            output += \"pow ax, sp\\n\"\n\t            output += \"pop\\n\"\n\t        elif node.op_tok.type == TT_MOD:\n\t            output += \"mod ax, sp\\n\"\n\t            output += \"pop\\n\"\n\t        elif node.op_tok.type == TT_EE:\n\t            l0 = self.label_idx\n\t            self.label_idx += 1\n", "            l1 = self.label_idx\n\t            self.label_idx += 1\n\t            l2 = self.label_idx\n\t            self.label_idx += 1\n\t            output += \"pop\\n\"\n\t            output += \"cmp ax == bx\\n\"\n\t            output += f\"jt .L{l0}\\n\"\n\t            output += f\"jmp .L{l1}\\n\"            \n\t            output += f\".L{l0}:\\n\"\n\t            output += f\"    mov ax, 1\\n\"\n", "            output += f\"    jmp .L{l2}\\n\"\n\t            output += f\".L{l1}:\\n\"\n\t            output += f\"    mov ax, 0\\n\"\n\t            output += f\".L{l2}:\\n\"\n\t        elif node.op_tok.type == TT_NE:\n\t            l0 = self.label_idx\n\t            self.label_idx += 1\n\t            l1 = self.label_idx\n\t            self.label_idx += 1\n\t            l2 = self.label_idx\n", "            self.label_idx += 1\n\t            output += \"pop\\n\"\n\t            output += \"cmp ax != bx\\n\"\n\t            output += f\"jt .L{l0}\\n\"\n\t            output += f\"jmp .L{l1}\\n\"            \n\t            output += f\".L{l0}:\\n\"\n\t            output += f\"    mov ax, 1\\n\"\n\t            output += f\"    jmp .L{l2}\\n\"\n\t            output += f\".L{l1}:\\n\"\n\t            output += f\"    mov ax, 0\\n\"\n", "            output += f\".L{l2}:\\n\"\n\t        elif node.op_tok.type == TT_LT:\n\t            l0 = self.label_idx\n\t            self.label_idx += 1\n\t            l1 = self.label_idx\n\t            self.label_idx += 1\n\t            l2 = self.label_idx\n\t            self.label_idx += 1\n\t            output += \"pop\\n\"\n\t            output += \"cmp ax < bx\\n\"\n", "            output += f\"jt .L{l0}\\n\"\n\t            output += f\"jmp .L{l1}\\n\"            \n\t            output += f\".L{l0}:\\n\"\n\t            output += f\"    mov ax, 1\\n\"\n\t            output += f\"    jmp .L{l2}\\n\"\n\t            output += f\".L{l1}:\\n\"\n\t            output += f\"    mov ax, 0\\n\"\n\t            output += f\".L{l2}:\\n\"\n\t        elif node.op_tok.type == TT_GT:\n\t            l0 = self.label_idx\n", "            self.label_idx += 1\n\t            l1 = self.label_idx\n\t            self.label_idx += 1\n\t            l2 = self.label_idx\n\t            self.label_idx += 1\n\t            output += \"pop\\n\"\n\t            output += \"cmp ax > bx\\n\"\n\t            output += f\"jt .L{l0}\\n\"\n\t            output += f\"jmp .L{l1}\\n\"            \n\t            output += f\".L{l0}:\\n\"\n", "            output += f\"    mov ax, 1\\n\"\n\t            output += f\"    jmp .L{l2}\\n\"\n\t            output += f\".L{l1}:\\n\"\n\t            output += f\"    mov ax, 0\\n\"\n\t            output += f\".L{l2}:\\n\"\n\t        elif node.op_tok.type == TT_LTE:\n\t            l0 = self.label_idx\n\t            self.label_idx += 1\n\t            l1 = self.label_idx\n\t            self.label_idx += 1\n", "            l2 = self.label_idx\n\t            self.label_idx += 1\n\t            output += \"pop\\n\"\n\t            output += \"cmp ax <= bx\\n\"\n\t            output += f\"jt .L{l0}\\n\"\n\t            output += f\"jmp .L{l1}\\n\"            \n\t            output += f\".L{l0}:\\n\"\n\t            output += f\"    mov ax, 1\\n\"\n\t            output += f\"    jmp .L{l2}\\n\"\n\t            output += f\".L{l1}:\\n\"\n", "            output += f\"    mov ax, 0\\n\"\n\t            output += f\".L{l2}:\\n\"\n\t        elif node.op_tok.type == TT_GTE:\n\t            l0 = self.label_idx\n\t            self.label_idx += 1\n\t            l1 = self.label_idx\n\t            self.label_idx += 1\n\t            l2 = self.label_idx\n\t            self.label_idx += 1\n\t            output += \"pop\\n\"\n", "            output += \"cmp ax >= bx\\n\"\n\t            output += f\"jt .L{l0}\\n\"\n\t            output += f\"jmp .L{l1}\\n\"            \n\t            output += f\".L{l0}:\\n\"\n\t            output += f\"    mov ax, 1\\n\"\n\t            output += f\"    jmp .L{l2}\\n\"\n\t            output += f\".L{l1}:\\n\"\n\t            output += f\"    mov ax, 0\\n\"\n\t            output += f\".L{l2}:\\n\"\n\t        return res.success(output)\n", "    def emit_UnaryOpNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        output += res.register(self.emit(node.node))\n\t        if res.error: return res\n\t        if node.op_tok.type == TT_MINUS:\n\t            output += \"mov bx, 0\\n\"\n\t            output += \"sub bx, 1\\n\"\n\t            output += \"mul ax, bx\\n\"\n\t        elif node.op_tok.type == TT_MUL:\n", "            var = self.var_idx\n\t            self.var_idx += 1\n\t            output += res.register(self.emit(node.node))\n\t            if res.error: return res\n\t            output += f'mov [.V{var}], ax\\n'\n\t            output += f\"pt [.V{var}], [.Vptr]\\n\"\n\t            output += \"mov ax, [.Vptr]\\n\"\n\t        return res.success(output)\n\t    def emit_IfNode(self, node):\n\t        res = CTResult()\n", "        output = \"\"\n\t        l0 = self.label_idx\n\t        end = l0\n\t        self.label_idx += 1\n\t        l0 = self.label_idx\n\t        else_l0 = l0\n\t        self.label_idx += 1\n\t        l0 = self.label_idx\n\t        for case in node.cases:\n\t            l0 = self.label_idx\n", "            self.label_idx += 1\n\t            l1 = self.label_idx\n\t            self.label_idx += 1\n\t            output += res.register(self.emit(case[0]))\n\t            if res.error: return res\n\t            output += \"test ax, ax\\n\"\n\t            output += \"cmp ax != 0\\n\"\n\t            output += f\"jt .L{l1}\\n\"\n\t            output += f\"jmp .L{l0}\\n\"\n\t            output += f\".L{l1}:\\n\"\n", "            output += res.register(self.emit(case[1]))\n\t            if res.error: return res\n\t            output += f\"jmp .L{end}\\n\"\n\t            output += f\".L{l0}:\\n\"\n\t        output += f\".L{else_l0}:\\n\"\n\t        if node.else_case:\n\t            output += res.register(self.emit(node.else_case[0]))\n\t            if res.error: return res\n\t        output += f\".L{end}:\\n\"\n\t        return res.success(output)\n", "    def emit_ContinueNode(self, node):\n\t        if not self.loop_breakc:\n\t            return CTResult().failure(CTError(node.pos_start,\n\t                                       node.pos_end,\n\t                                       \"Cannot continue outside of a loop\"))\n\t        return CTResult().success(f\"jmp .L{self.loopsc[-1]}\\n\")\n\t    def emit_BreakNode(self, node):\n\t        if not self.loop_breakc:\n\t            return CTResult().failure(CTError(node.pos_start,\n\t                                       node.pos_end,\n", "                                       \"Cannot break outside of a loop\"))\n\t        return CTResult().success(f\"jmp .L{self.loopsb[-1]}\\n\")\n\t    def emit_WhileNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        l0 = self.label_idx\n\t        self.label_idx += 1\n\t        l1 = self.label_idx\n\t        self.label_idx += 1\n\t        continue_label = l0\n", "        break_label = l1\n\t        self.loopsc.append(continue_label)\n\t        self.loopsb.append(break_label)\n\t        output += f\".L{l0}:\\n\"\n\t        output += res.register(self.emit(node.condition_node))\n\t        if res.error: return res\n\t        #output += \"cmp ax != 0\\n\"\n\t        #output += f\"jf .L{l1}\\n\"\n\t        output += \"test ax, ax\\n\"\n\t        output += \"cmp ax == 1\\n\"\n", "        output += f\"jf .L{l1}\\n\" \n\t        for node in node.body_node:\n\t            self.loop_breakc = True\n\t            if type(node) is not CallNode:\n\t                output += res.register(self.emit(node))\n\t                if res.error: return res\n\t            else:\n\t                self.loop_breakc = False\n\t                output += res.register(self.emit(node))\n\t                if res.should_return(): return res\n", "        del self.loopsc[-1]\n\t        del self.loopsb[-1]\n\t        output += f\"jmp .L{l0}\\n\"\n\t        output += f\".L{l1}:\\n\"\n\t        return res.success(output)\n\t    def emit_ForNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        l0 = self.label_idx\n\t        self.label_idx += 1\n", "        l1 = self.label_idx\n\t        self.label_idx += 1\n\t        continue_label = self.label_idx\n\t        self.label_idx += 1\n\t        break_label = self.label_idx\n\t        self.label_idx += 1\n\t        self.loopsc.append(continue_label)\n\t        self.loopsb.append(break_label)\n\t        var_name = node.var_name_tok.value\n\t        output += res.register(self.emit(node.start_value_node))\n", "        if res.error: return res\n\t        output += f\"mov [{node.var_name_tok.value}], ax\\n\"\n\t        end_value = self.var_idx\n\t        self.var_idx += 1\n\t        step_value = self.var_idx\n\t        self.var_idx += 1\n\t        output += res.register(self.emit(node.end_value_node))\n\t        if res.error: return res\n\t        output += f\"mov [.V{end_value}], ax\\n\"\n\t        if node.step_value_node:\n", "            output += res.register(self.emit(node.step_value_node))\n\t            if res.error: return res\n\t            output += f\"mov [.V{step_value}], ax\\n\"\n\t        else:\n\t            output += f\"mov [.V{step_value}], 1\\n\"\n\t        output += f\"jmp .L{l1}\\n\"\n\t        output += f\".L{l0}:\\n\"\n\t        for node in node.body_node:\n\t            self.loop_breakc = True\n\t            if type(node) is not CallNode:\n", "                output += res.register(self.emit(node))\n\t                if res.error: return res\n\t            else:\n\t                self.loop_breakc = False\n\t                output += res.register(self.emit(node))\n\t                if res.error: return res\n\t        del self.loopsc[-1]\n\t        del self.loopsb[-1]\n\t        output += f\".L{continue_label}:\\n\"\n\t        output += f\"add [{var_name}], [.V{step_value}]\\n\"\n", "        l2 = self.label_idx\n\t        self.label_idx += 1\n\t        l3 = self.label_idx\n\t        self.label_idx += 1\n\t        output += f\".L{l1}:\\n\"\n\t        output += f\"cmp [.V{step_value}] >= 0\\n\"\n\t        output += f\"jt .L{l2}\\n\"\n\t        output += f\"jmp .L{l3}\\n\"\n\t        output += f\".L{l2}:\\n\"\n\t        output += f\"cmp [{var_name}] < [.V{end_value}]\\n\"\n", "        output += f\"jt .L{l0}\\n\"\n\t        output += f\".L{l3}:\\n\"\n\t        output += f\"cmp [{var_name}] > [.V{end_value}]\\n\"\n\t        output += f\"jt .L{l0}\\n\"\n\t        output += f\".L{break_label}:\\n\"\n\t        return res.success(output)\n\t    def emit_CallNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        if type(node.node_to_call) is not VarAccessNode:\n", "            return res.failure(CTError(node.node_to_call.pos_start,\n\t                                       node.node_to_call.pos_end,\n\t                                       \"Function name is not an identifier\"))\n\t        func_name = node.node_to_call.var_name_tok.value or None\n\t        if not func_name in BUILTINS:\n\t            for node_ in node.arg_nodes[::-1]:\n\t                output += res.register(self.emit(node_))\n\t                output += \"push ax\\n\"\n\t            output += res.register(self.emit(node.node_to_call))\n\t            if res.error: return res\n", "            output += \"call ax\\n\"\n\t        else:\n\t            if not func_name in (\"asm\", \"ref\", \"new\"):\n\t                arg_len = len(node.arg_nodes)\n\t                for node in node.arg_nodes[::-1]:\n\t                    output += res.register(self.emit(node))\n\t                    output += \"push ax\\n\"\n\t                output += res.register(BUILTINS[func_name].execute(arg_len))\n\t            else:\n\t                if func_name == \"asm\":\n", "                    # TODO: return error if arg len is not 1\n\t                    args = node.arg_nodes[0]\n\t                    output += res.register(BUILTINS[func_name].execute(1, args.tok.value, True))\n\t                elif func_name == \"ref\":\n\t                    arg = node.arg_nodes[0]\n\t                    output += res.register(BUILTINS[func_name].execute(1, arg.var_name_tok.value, True))\n\t                elif func_name == \"new\":\n\t                    args_len = len(node.arg_nodes)\n\t                    if args_len < 1:\n\t                        return res.failure(CTError(\n", "                        node.pos_start, node.pos_end,\n\t                        f\"{1 - len(args_len)} too few args passed into new()\"\n\t                    ))\n\t                    arg = node.arg_nodes[0]\n\t                    args = node.arg_nodes[1:]\n\t                    if type(arg) is not ClassNode:\n\t                        return res.failure(CTError(\n\t                            arg.pos_start, arg.pos_end,\n\t                            f\"Expected class\"\n\t                        ))\n", "                    if arg.var_name_tok.value not in self.class_definitions.keys():\n\t                        return res.failure(CTError(\n\t                            arg.pos_start, arg.pos_end,\n\t                            f\"class {arg.var_name_tok.value} not found\"\n\t                        ))\n\t                    #value\n\t                    #variable\n\t                    #attr\n\t                    class_name = arg.var_name_tok.value\n\t                    output += f'mov [.temp{class_name}], \\'object {class_name}\\'\\n'\n", "                    for property, value in self.class_definitions[class_name]:\n\t                        #value\n\t                        if value is None:\n\t                            output += f'mov ax, 0\\n'\n\t                        else:\n\t                            output += res.register(self.emit(value))\n\t                            if res.error: return res\n\t                        output += 'push ax\\n'\n\t                        #variable\n\t                        output += f'mov ax, [.temp{class_name}]\\n'\n", "                        output += 'push ax\\n'\n\t                        #attr\n\t                        output += res.register(self.emit(property))\n\t                        if res.error: return res\n\t                        output += 'push ax\\n'\n\t                        output += 'mov ax, 17\\n'\n\t                        output += 'bcall\\n'\n\t                    methods = self.class_definitions[f'.{class_name}methods'] or None\n\t                    c_id = str(self.var_idx)\n\t                    self.var_idx += 1\n", "                    if methods and methods.element_nodes:\n\t                        for node in methods.element_nodes:\n\t                            func_name = node.func_name_tok.value\n\t                            try:\n\t                                emit = False\n\t                                _ = node.func_name_tok.set\n\t                                c_id = node.func_name_tok.c_id\n\t                            except AttributeError:\n\t                                emit = True\n\t                                func_name = '.' + func_name + c_id\n", "                                node.func_name_tok.value = func_name\n\t                                setattr(node.func_name_tok, 'set', True)\n\t                                setattr(node.func_name_tok, 'c_id', c_id)\n\t                            if func_name == '.constructor' + c_id:\n\t                                if len(node.arg_name_toks) < 1:\n\t                                    return res.failure(CTError(node.func_name_tok.pos_start, node.func_name_tok.pos_end,\n\t                                                            'Class construtor must have at least one argument'))\n\t                                node.body_node.append(ReturnNode(VarAccessNode(node.arg_name_toks[0]),\n\t                                                                 pos_start=node.arg_name_toks[0].pos_start,\n\t                                                                 pos_end=node.arg_name_toks[0].pos_end))\n", "                            # Avoid redefining already defined methods\n\t                            if emit:\n\t                                output += res.register(self.emit(node))\n\t                                if res.error: return res\n\t                            #value\n\t                            output += f'mov ax, [{func_name}]\\n'\n\t                            output += 'push ax\\n'\n\t                            #variable\n\t                            output += f'mov ax, [.temp{class_name}]\\n'\n\t                            output += 'push ax\\n'\n", "                            #attr\n\t                            output += f'mov ax, \\'{func_name[1:-len(c_id)]}\\'\\n'\n\t                            output += 'push ax\\n'\n\t                            output += 'mov ax, 17\\n'\n\t                            output += 'bcall\\n'\n\t                            if func_name == '.constructor' + c_id:\n\t                                for arg in args[::-1]:\n\t                                    output += res.register(self.emit(arg))\n\t                                    if res.error: return res\n\t                                    output += 'push ax\\n'\n", "                                output += f'mov ax, [.temp{class_name}]\\n'\n\t                                output += 'push ax\\n'\n\t                                output += f'call [.constructor{c_id}]\\n'\n\t                                output += f'mov [.temp{class_name}], ax\\n'\n\t                    output += f'mov ax, [.temp{class_name}]\\n'\n\t        return res.success(output)\n\t    def emit_ReturnNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        if node.node_to_return:\n", "            output += res.register(self.emit(node.node_to_return))\n\t            if res.error: return res\n\t        else:\n\t            output += \"mov ax, 0\\n\"\n\t        output += \"ret\\n\"\n\t        return res.success(output)\n\t    def emit_FuncDefNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        l0 = self.label_idx\n", "        self.label_idx += 1\n\t        self.hoisted_definitions += 'mov ax, \"function\"\\n'\n\t        self.hoisted_definitions += 'push ax\\n'\n\t        self.hoisted_definitions += f\"mov [{node.func_name_tok.value}], {node.func_name_tok.value}\\n\"\n\t        self.hoisted_definitions += f\"mov ax, [{node.func_name_tok.value}]\\n\"\n\t        self.hoisted_definitions += 'push ax\\n'\n\t        self.hoisted_definitions += \"mov ax, '.type'\\n\"\n\t        self.hoisted_definitions += \"push ax\\n\"\n\t        self.hoisted_definitions += \"mov ax, 17\\n\"\n\t        self.hoisted_definitions += \"bcall\\n\"\n", "        output += f\"jmp .L{l0}\\n\"\n\t        output += f\"{node.func_name_tok.value}:\\n\"\n\t        for arg in node.arg_name_toks:\n\t            output += f\"mov [{arg.value}], sp\\n\"\n\t            output += f\"pop\\n\"\n\t        output += res.register(self.emit(node.body_node))\n\t        if res.error: return res\n\t        output += f\"mov ax, 0\\n\"\n\t        output += f\"ret\\n\"\n\t        output += f\".L{l0}:\\n\"\n", "        return res.success(output)\n\t    def emit_Classnode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        return res.success(output)\n\t    def emit_ClassAssignNode(self, node):\n\t        res = CTResult()\n\t        output = \"\"\n\t        class_name = node.var_name_tok.value\n\t        self.class_definitions[class_name] = node.value_node.element_nodes\n", "        self.class_definitions[f'.{class_name}methods'] = node.methods\n\t        return res.success(output)\n"]}
{"filename": "Alphassembly/assembler/glang/modules/consts.py", "chunked_list": ["import string\n\tLETTERS = string.ascii_letters\n\tDIGITS = string.digits\n\tLETTERS_DIGITS = LETTERS + DIGITS\n\tTT_INT = 'INT'\n\tTT_FLOAT = 'FLOAT'\n\tTT_STRING = 'STRING'\n\tTT_IDENTIFIER = 'IDENTIFIER'\n\tTT_KEYWORD = 'KEYWORD'\n\tTT_PLUS = 'PLUS'\n", "TT_MINUS = 'MINUS'\n\tTT_MUL = 'MUL'\n\tTT_DIV = 'DIV'\n\tTT_POW = 'POW'\n\tTT_MOD = 'MOD'\n\tTT_EQ = 'EQ'\n\tTT_LPAREN = 'LPAREN'\n\tTT_RPAREN = 'RPAREN'\n\tTT_RSQUARE = 'RSQUARE'\n\tTT_LSQUARE = 'LSQUARE'\n", "TT_COMMA = 'COMMA'\n\tTT_NEWLINE = 'NEWLINE'\n\tTT_EE = 'EE'\n\tTT_NE = 'NE'\n\tTT_LT = 'LT'\n\tTT_GT = 'GT'\n\tTT_LTE = 'LTE'\n\tTT_GTE = 'GTE'\n\tTT_DCOLON = 'DCOLON'\n\tTT_DOT = 'DOT'\n", "TT_EOF = 'EOF'\n\tKEYWORDS = [\n\t    'var',\n\t    'if',\n\t    'else',\n\t    'elif',\n\t    'end',\n\t    'and',\n\t    'or',\n\t    'for',\n", "    'to',\n\t    'step',\n\t    'continue',\n\t    'break',\n\t    'while',\n\t    'def',\n\t    'return',\n\t    'include',\n\t    'class'\n\t]\n"]}
{"filename": "Alphassembly/assembler/glang/modules/errors.py", "chunked_list": ["from .strings_with_arrows import *\n\tclass Error:\n\t    def __init__(self, pos_start, pos_end, error_name, details):\n\t        self.pos_start = pos_start\n\t        self.pos_end = pos_end\n\t        self.error_name = error_name\n\t        self.details = details\n\t    def __str__(self):\n\t        result = f'{self.error_name}: {self.details}\\n'\n\t        result += f'File {self.pos_start.fn}, line {self.pos_start.ln + 1}'\n", "        result += '\\n\\n' + string_with_arrows(self.pos_start.ftxt, self.pos_start, self.pos_end)\n\t        return result\n\tclass IllegalCharError(Error):\n\t    def __init__(self, pos_start, pos_end, details):\n\t        super().__init__(pos_start, pos_end, 'Illegal Character', details)\n\tclass ExpectedCharError(Error):\n\t    def __init__(self, pos_start, pos_end, details):\n\t        super().__init__(pos_start, pos_end, 'Expected Character', details)\n\tclass InvalidSyntaxError(Error):\n\t    def __init__(self, pos_start, pos_end, details=''):\n", "        super().__init__(pos_start, pos_end, 'Invalid Syntax', details)\n\tclass CTError(Error):\n\t    def __init__(self, pos_start, pos_end, details=''):\n\t        super().__init__(pos_start, pos_end, 'Compile time error', details)\n\tclass IncludeError(Error):\n\t    def __init__(self, pos_start, pos_end, details=''):\n\t        super().__init__(pos_start, pos_end, 'Include error', details)\n"]}
{"filename": "Alphassembly/assembler/glang/modules/builtin_function.py", "chunked_list": ["from .errors import *\n\tfrom .ctresult import *\n\tclass BaseFunction():\n\t    def __init__(self, name):\n\t        self.name = name or \"<anonymous>\"\n\t    def check_args(self, arg_names, args_len):\n\t        res = CTResult()\n\t        if args_len > len(arg_names):\n\t            return res.failure(CTError(\n\t            self.pos_start, self.pos_end,\n", "            f\"{args_len - len(arg_names)} too many args passed into {self}\",\n\t            self.context\n\t        ))\n\t        if args_len < len(arg_names):\n\t            return res.failure(CTError(\n\t            self.pos_start, self.pos_end,\n\t            f\"{len(arg_names) - len(args_len)} too few args passed into {self}\",\n\t            self.context\n\t        ))\n\t        return res.success(None)\n", "    def populate_args(self, arg_names, args_len):\n\t        output = \"\"\n\t        for i in range(args_len):\n\t            arg_name = arg_names[i]\n\t            output += f\"mov [.V{arg_name}], sp\\n\"\n\t            output += f\"pop\\n\"\n\t        return output\n\t    def check_and_populate_args(self, arg_names, args_len):\n\t        res = CTResult()\n\t        output = \"\"\n", "        res.register(self.check_args(arg_names, args_len))\n\t        if res.should_return(): return res\n\t        output += self.populate_args(arg_names, args_len)\n\t        return res.success(output)\n\tclass BuiltinFunction(BaseFunction):\n\t    def __init__(self, name):\n\t        super().__init__(name)\n\t    def execute(self, args_len, args=None, p=False):\n\t        res = CTResult()\n\t        output = \"\"\n", "        method_name = f'execute_{self.name}'\n\t        method = getattr(self, method_name, self.no_visit_method)\n\t        if not p:\n\t            output += res.register(self.check_and_populate_args(method.arg_names, args_len))\n\t            if res.error: return res\n\t            output += res.register(method())\n\t            if res.error: return res\n\t        else:\n\t            output += res.register(method(args))\n\t        return res.success(output)\n", "    def no_visit_method(self, node, context):\n\t        raise Exception(f'No execute_{self.name} method defined')\n\t    def copy(self):\n\t        copy = BuiltinFunction(self.name)\n\t        copy.set_context(self.context)\n\t        copy.set_pos(self.pos_start, self.pos_end)\n\t        return copy\n\t    def __repr__(self):\n\t        return f\"<built-in function {self.name}>\"\n\t    def execute_print(self):\n", "        output = \"\"\n\t        output += \"push [.Vvalue]\\n\"\n\t        output += \"print\\n\"\n\t        output += \"pop\\n\"\n\t        return CTResult().success(output)\n\t    execute_print.arg_names = ['value']\n\t    def execute_exit(self):\n\t        output = \"\"\n\t        output += \"push [.Vretcode]\\n\"\n\t        output += \"done\\n\"\n", "        return CTResult().success(output)\n\t    execute_exit.arg_names = ['retcode']\n\t    def execute_asm(self, arg):\n\t        output = \"\"\n\t        output += f\"{arg}\\n\"\n\t        return CTResult().success(output)\n\t    def execute_ref(self, arg): # TODO: this does not work as .Vvalue is used multiple times\n\t        output = \"\"\n\t        # get the name of the variable that needs to be pointed to\n\t        output += f\"pt [{arg}], [.Vptr]\\n\"\n", "        output += \"mov ax, [.Vptr]\\n\"\n\t        return CTResult().success(output)\n\t    execute_ref.arg_names = ['ptr']\n"]}
{"filename": "Alphassembly/assembler/glang/modules/parse_result.py", "chunked_list": ["class ParseResult:\n\t    def __init__(self):\n\t        self.error = None\n\t        self.node = None\n\t        self.last_registered_advance_count = 0\n\t        self.advance_count = 0\n\t        self.to_reverse_count = 0\n\t    def register_advancement(self):\n\t        self.last_registered_advance_count = 1\n\t        self.advance_count += 1\n", "    def try_register(self, res):\n\t        if res.error:\n\t            self.to_reverse_count = res.advance_count\n\t            return None\n\t        return self.register(res)\n\t    def register(self, res):\n\t        self.last_registered_advance_count = res.advance_count\n\t        self.advance_count += res.advance_count\n\t        if res.error: self.error = res.error\n\t        return res.node\n", "    def success(self, node):\n\t        self.node = node\n\t        return self\n\t    def failure(self, error):\n\t        if not self.error or self.last_registered_advance_count == 0:\n\t            self.error = error\n\t        return self\n"]}
{"filename": "Alphassembly/assembler/glang/modules/_parser.py", "chunked_list": ["from .nodes import *\n\tfrom .errors import *\n\tfrom .consts import *\n\tfrom .parse_result import *\n\tclass Parser:\n\t    def __init__(self, tokens):\n\t        self.current_tok = None\n\t        self.tokens = tokens\n\t        self.tok_idx = -1\n\t        self.advance()\n", "        self.call_nodes = []\n\t        self.var_accesses = []\n\t        self.current_func_name = None\n\t    def advance(self):\n\t        self.tok_idx += 1\n\t        if self.tok_idx < len(self.tokens):\n\t            self.current_tok = self.tokens[self.tok_idx]\n\t        return self.current_tok\n\t    def reverse(self, amount=1):\n\t        self.tok_idx -= amount\n", "        self.update_current_tok()\n\t        return self.current_tok\n\t    def update_current_tok(self):\n\t        if self.tok_idx >= 0 and self.tok_idx < len(self.tokens):\n\t            self.current_tok = self.tokens[self.tok_idx]\n\t    def parse(self):\n\t        res = self.statements()\n\t        if not res.error and self.current_tok.type != TT_EOF:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n", "                \"Syntax error\"\n\t            ))\n\t        return res, self.call_nodes, self.var_accesses\n\t    def statements(self):\n\t        res = ParseResult()\n\t        statements = []\n\t        pos_start = self.current_tok.pos_start.copy()\n\t        while self.current_tok.type == TT_NEWLINE:\n\t            res.register_advancement()\n\t            self.advance()\n", "        statement = res.register(self.statement())\n\t        if res.error: return res\n\t        statements.append(statement)\n\t        more_statements = True\n\t        while True:\n\t            newline_count = 0\n\t            while self.current_tok.type == TT_NEWLINE:\n\t                res.register_advancement()\n\t                self.advance()\n\t                newline_count += 1\n", "            if newline_count == 0:\n\t                more_statements = False\n\t            if not more_statements: break\n\t            statement = res.try_register(self.statement())\n\t            if not statement:\n\t                self.reverse(res.to_reverse_count)\n\t                more_statements = False\n\t                continue\n\t            statements.append(statement)\n\t        return res.success(statements)\n", "    def statement(self):\n\t        res = ParseResult()\n\t        pos_start = self.current_tok.pos_start.copy()\n\t        # return, continue break and stuff can be added here\n\t        if self.current_tok.matches(TT_KEYWORD, 'var'):\n\t            res.register_advancement()\n\t            self.advance()\n\t            if self.current_tok.type != TT_IDENTIFIER:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n", "                    \"Expected identifier\"\n\t                ))\n\t            var_name = self.current_tok\n\t            res.register_advancement()\n\t            self.advance()\n\t            expr = None\n\t            if self.current_tok.type == TT_DOT:\n\t                if self.current_tok.type == TT_DOT:\n\t                    left = var_name\n\t                    op_tok = self.current_tok\n", "                    res.register_advancement()\n\t                    self.advance()\n\t                    right = res.register(self.call())\n\t                    if res.error: return res\n\t                    var_name = BinOpNode(StringNode(left), op_tok, right)\n\t            if self.current_tok.type != TT_EQ:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    \"Expected '='\"\n\t                ))\n", "            res.register_advancement()\n\t            self.advance()\n\t            expr = res.register(self.expr())\n\t            if res.error: return res\n\t            return res.success(VarAssignNode(var_name, expr))\n\t        elif self.current_tok.matches(TT_KEYWORD, 'return'):\n\t            res.register_advancement()\n\t            self.advance()\n\t            expr = res.try_register(self.expr())\n\t            if not expr:\n", "                self.reverse(res.to_reverse_count)\n\t            return res.success(ReturnNode(expr, pos_start, self.current_tok.pos_start.copy()))\n\t        elif self.current_tok.matches(TT_KEYWORD, 'class'):\n\t            res.register_advancement()\n\t            self.advance()\n\t            class_name = self.current_tok\n\t            if not class_name.type == TT_IDENTIFIER:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    f\"Expected identifier but got {class_name.type}\"\n", "                ))\n\t            res.register_advancement()\n\t            self.advance()\n\t            if self.current_tok.type == TT_DCOLON:\n\t                res.register_advancement()\n\t                self.advance()\n\t                if self.current_tok.type != TT_NEWLINE:\n\t                    return res.failure(InvalidSyntaxError(\n\t                        self.current_tok.pos_start, self.current_tok.pos_end,\n\t                        f\"Expected newline but got {self.current_tok.type}\"\n", "                    ))\n\t                res.register_advancement()\n\t                self.advance()\n\t                properties = [(StringNode(Token(TT_STRING, '.type',\n\t                                                self.current_tok.pos_start,\n\t                                                self.current_tok.pos_end)),\n\t                                                StringNode(Token(TT_STRING, 'object',\n\t                                                                 self.current_tok.pos_start,\n\t                                                                 self.current_tok.pos_end)))]\n\t                methods = []\n", "                while self.current_tok.type in (TT_IDENTIFIER, TT_KEYWORD):\n\t                    property_ = self.current_tok\n\t                    val = None\n\t                    if self.current_tok.matches(TT_KEYWORD, 'def'):\n\t                        methods.append(res.register(self.func_def()))\n\t                        if res.error: return res\n\t                        if self.current_tok.type != TT_NEWLINE:\n\t                            return res.failure(InvalidSyntaxError(\n\t                                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                                f\"Expected newline but got {self.current_tok}\"\n", "                            ))\n\t                        while self.current_tok.type == TT_NEWLINE:\n\t                            res.register_advancement()\n\t                            self.advance()\n\t                        continue\n\t                    elif self.current_tok.matches(TT_KEYWORD, 'end'):\n\t                        break\n\t                    elif self.current_tok.type == TT_KEYWORD:\n\t                        return res.failure(InvalidSyntaxError(\n\t                            self.current_tok.pos_start, self.current_tok.pos_end,\n", "                            f\"Expected def or identifier but got {self.current_tok}\"\n\t                        ))\n\t                    res.register_advancement()\n\t                    self.advance()\n\t                    if self.current_tok.type == TT_EQ:\n\t                        res.register_advancement()\n\t                        self.advance()\n\t                        val = res.register(self.expr())\n\t                        if res.error: return res\n\t                    if self.current_tok.type != TT_NEWLINE:\n", "                        return res.failure(InvalidSyntaxError(\n\t                            self.current_tok.pos_start, self.current_tok.pos_end,\n\t                            f\"Expected newline but got {self.current_tok}\"\n\t                        ))\n\t                    while self.current_tok.type == TT_NEWLINE:\n\t                        res.register_advancement()\n\t                        self.advance()\n\t                    properties.append((StringNode(property_), val))\n\t                while self.current_tok.type == TT_NEWLINE:\n\t                    res.register_advancement()\n", "                    self.advance()\n\t                if not self.current_tok.matches(TT_KEYWORD, 'end'):\n\t                    return res.failure(InvalidSyntaxError(\n\t                        self.current_tok.pos_start, self.current_tok.pos_end,\n\t                        f\"Expected end but got {self.current_tok}\"\n\t                    ))\n\t                res.register_advancement()\n\t                self.advance()\n\t                methods = None if methods == [] else methods\n\t                return res.success(ClassAssignNode(class_name, \n", "                                                   ListNode(properties,\n\t                                                                        pos_start=self.current_tok.pos_start,\n\t                                                                        pos_end=self.current_tok.pos_end),\n\t                                                    ListNode(methods,\n\t                                                                        pos_start=self.current_tok.pos_start,\n\t                                                                        pos_end=self.current_tok.pos_end)))\n\t            return res.success(ClassNode(class_name))\n\t        expr = res.register(self.expr())\n\t        if res.error:\n\t            return res.failure(InvalidSyntaxError(\n", "                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                \"InvalidSyntaxError\"\n\t            ))\n\t        return res.success(expr)\n\t    def expr(self):\n\t        res = ParseResult()\n\t        node = res.register(self.bin_op(self.comp_expr, ((TT_KEYWORD, 'and'), (TT_KEYWORD, 'or'))))\n\t        if res.error:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n", "                \"InvalidSyntaxError\"\n\t            ))\n\t        return res.success(node)\n\t    def comp_expr(self):\n\t        res = ParseResult()\n\t        node = res.register(self.bin_op(self.arith_expr, (TT_EE, TT_NE, TT_LT, TT_GT, TT_LTE, TT_GTE)))\n\t        if res.error:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                \"InvalidSyntaxError\"\n", "            ))\n\t        return res.success(node)\n\t    def arith_expr(self):\n\t        return self.bin_op(self.term, (TT_PLUS, TT_MINUS))\n\t    def term(self):\n\t        return self.bin_op(self.factor, (TT_MUL, TT_DIV))\n\t    def factor(self):\n\t        res = ParseResult()\n\t        tok = self.current_tok\n\t        if tok.type in (TT_PLUS, TT_MINUS, TT_MUL):\n", "            res.register_advancement()\n\t            self.advance()\n\t            factor = res.register(self.factor())\n\t            if res.error: return res\n\t            return res.success(UnaryOpNode(tok, factor))\n\t        return self.power()\n\t    # only added because is a requirement\n\t    # TODO: Add functions\n\t    def call(self):\n\t        res = ParseResult()\n", "        atom = res.register(self.atom())\n\t        if res.error: return res\n\t        if self.current_tok.type == TT_LPAREN:\n\t            res.register_advancement()\n\t            self.advance()\n\t            arg_nodes = []\n\t            if self.current_tok.type == TT_RPAREN:\n\t                res.register_advancement()\n\t                self.advance()\n\t            else:\n", "                arg_nodes.append(res.register(self.expr()))\n\t                if res.error:\n\t                    return res.failure(InvalidSyntaxError(\n\t                        self.current_tok.pos_start, self.current_tok.pos_end,\n\t                        \"InvalidSyntaxError\"\n\t                    ))\n\t                while self.current_tok.type == TT_COMMA:\n\t                    res.register_advancement()\n\t                    self.advance()\n\t                    arg_nodes.append(res.register(self.expr()))\n", "                    if res.error: return res\n\t                if self.current_tok.type != TT_RPAREN:\n\t                    return res.failure(InvalidSyntaxError(\n\t                        self.current_tok.pos_start, self.current_tok.pos_end,\n\t                        f\"Expected ',' or ')'\"\n\t                    ))\n\t                res.register_advancement()\n\t                self.advance()\n\t            node = CallNode(atom, arg_nodes)\n\t            self.call_nodes.append(node.node_to_call.var_name_tok.value)\\\n", "                if not node.node_to_call.var_name_tok.value in self.call_nodes else None in self.call_nodes\n\t            return res.success(node)\n\t        elif self.current_tok.type == TT_DOT:\n\t            left = atom\n\t            op_tok = self.current_tok\n\t            res.register_advancement()\n\t            self.advance()\n\t            right = res.register(self.call())\n\t            if res.error: return res\n\t            return res.success(BinOpNode(left, op_tok, right))\n", "        return res.success(atom)\n\t    def power(self):\n\t        return self.bin_op(self.call, (TT_POW, TT_MOD), self.factor)\n\t    def atom(self):\n\t        res = ParseResult()\n\t        tok = self.current_tok\n\t        pos_start = self.current_tok.pos_start.copy()\n\t        if tok.type == TT_INT:\n\t            res.register_advancement()\n\t            self.advance()\n", "            return res.success(IntegerNode(tok))\n\t        elif tok.type == TT_FLOAT:\n\t            res.register_advancement()\n\t            self.advance()\n\t            return res.success(FloatNode(tok))\n\t        elif tok.type == TT_STRING:\n\t            res.register_advancement()\n\t            self.advance()\n\t            return res.success(StringNode(tok))\n\t        elif tok.type == TT_IDENTIFIER:\n", "            res.register_advancement()\n\t            self.advance()\n\t            self.var_accesses.append(tok.value)\n\t            return res.success(VarAccessNode(tok))\n\t        elif tok.type == TT_LPAREN:\n\t            res.register_advancement()\n\t            self.advance()\n\t            expr = res.register(self.expr())\n\t            if res.error: return res\n\t            if self.current_tok.type == TT_RPAREN:\n", "                res.register_advancement()\n\t                self.advance()\n\t                return res.success(expr)\n\t            else:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    \"Expected ')'\"\n\t                ))\n\t        elif tok.type == TT_LSQUARE:\n\t            list_expr = res.register(self.list_expr())\n", "            if res.error: return res\n\t            return res.success(list_expr)\n\t        elif tok.matches(TT_KEYWORD, 'if'):\n\t            if_expr = res.register(self.if_expr())\n\t            if res.error: return res\n\t            return res.success(if_expr)\n\t        elif tok.matches(TT_KEYWORD, 'for'):\n\t            for_expr = res.register(self.for_expr())\n\t            if res.error: return res\n\t            return res.success(for_expr)\n", "        elif self.current_tok.matches(TT_KEYWORD, 'continue'):\n\t            res.register_advancement()\n\t            self.advance()\n\t            return res.success(ContinueNode(pos_start, self.current_tok.pos_start.copy()))\n\t        elif self.current_tok.matches(TT_KEYWORD, 'break'):\n\t            res.register_advancement()\n\t            self.advance()\n\t            return res.success(BreakNode(pos_start, self.current_tok.pos_start.copy()))\n\t        elif tok.matches(TT_KEYWORD, 'while'):\n\t            while_expr = res.register(self.while_expr())\n", "            if res.error: return res\n\t            return res.success(while_expr)\n\t        elif tok.matches(TT_KEYWORD, 'def'):\n\t            func_def = res.register(self.func_def())\n\t            if res.error: return res\n\t            return res.success(func_def)\n\t        elif tok.matches(TT_KEYWORD, 'class'):\n\t            class_node = res.register(self.statement())\n\t            if res.error: return res\n\t            return res.success(class_node)\n", "        return res.failure(InvalidSyntaxError(\n\t            tok.pos_start, tok.pos_end,\n\t            \"InvalidSyntaxError\"\n\t        ))\n\t    def list_expr(self):\n\t        res = ParseResult()\n\t        elements_nodes = []\n\t        pos_start = self.current_tok.pos_start.copy()\n\t        if self.current_tok.type != TT_LSQUARE:\n\t            return res.failure(InvalidSyntaxError(\n", "                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected '['\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type == TT_RSQUARE:\n\t            res.register_advancement()\n\t            self.advance()\n\t        else:\n\t            elements_nodes.append(res.register(self.expr()))\n", "            if res.error:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    \"Unexpected token\"\n\t                ))\n\t            while self.current_tok.type == TT_COMMA:\n\t                res.register_advancement()\n\t                self.advance()\n\t                elements_nodes.append(res.register(self.expr()))\n\t                if res.error: return res\n", "            if self.current_tok.type != TT_RSQUARE:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    f\"Expected ',' or ']'\"\n\t                ))\n\t            res.register_advancement()\n\t            self.advance()\n\t        return res.success(ListNode(\n\t            elements_nodes,\n\t            pos_start,\n", "            self.current_tok.pos_end.copy()\n\t        ))\n\t    def if_expr(self):\n\t        res = ParseResult()\n\t        all_cases = res.register(self.if_expr_cases('if'))\n\t        if res.error: return res\n\t        cases, else_case = all_cases\n\t        return res.success(IfNode(cases, else_case))\n\t    def if_expr_b(self):\n\t        return self.if_expr_cases('elif')\n", "    def if_expr_c(self):\n\t        res = ParseResult()\n\t        else_case = None\n\t        if self.current_tok.matches(TT_KEYWORD, 'else'):\n\t            res.register_advancement()\n\t            self.advance()\n\t            if self.current_tok.type != TT_DCOLON:\n\t                return res.failure(InvalidSyntaxError(\n\t                        self.current_tok.pos_start, self.current_tok.pos_end,\n\t                        \"Expected ':'\"\n", "                    ))\n\t            res.register_advancement()\n\t            self.advance()\n\t            if self.current_tok.type == TT_NEWLINE:\n\t                res.register_advancement()\n\t                self.advance()\n\t                statements = res.register(self.statements())\n\t                if res.error: return res\n\t                else_case = (statements, True)\n\t                if self.current_tok.matches(TT_KEYWORD, 'end'):\n", "                    res.register_advancement()\n\t                    self.advance()\n\t                else:\n\t                    return res.failure(InvalidSyntaxError(\n\t                        self.current_tok.pos_start, self.current_tok.pos_end,\n\t                        \"Expected 'end'\"\n\t                    ))\n\t            else:\n\t                expr = res.register(self.statement())\n\t                if res.error: return res\n", "                else_case = (expr, False)\n\t        return res.success(else_case)\n\t    def if_expr_b_or_c(self):\n\t        res = ParseResult()\n\t        cases, else_case = [], None\n\t        if self.current_tok.matches(TT_KEYWORD, 'elif'):\n\t            all_cases = res.register(self.if_expr_b())\n\t            if res.error: return res\n\t            cases, else_case = all_cases\n\t        else:\n", "            else_case = res.register(self.if_expr_c())\n\t            if res.error: return res\n\t        return res.success((cases, else_case))\n\t    def if_expr_cases(self, case_keyword):\n\t        res = ParseResult()\n\t        cases = []\n\t        else_case = None\n\t        if not self.current_tok.matches(TT_KEYWORD, case_keyword):\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n", "                f\"Expected '{case_keyword}'\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        condition = res.register(self.statement())\n\t        if res.error: return res\n\t        if not self.current_tok.type == TT_DCOLON:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected ':'\"\n", "            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type == TT_NEWLINE:\n\t            res.register_advancement()\n\t            self.advance()\n\t            statements = res.register(self.statements())\n\t            if res.error: return res\n\t            cases.append((condition, statements, True))\n\t            if self.current_tok.matches(TT_KEYWORD, 'end'):\n", "                res.register_advancement()\n\t                self.advance()\n\t            else:\n\t                all_cases = res.register(self.if_expr_b_or_c())\n\t                if res.error: return res\n\t                new_cases, else_case = all_cases\n\t                cases.extend(new_cases)\n\t        else:\n\t            expr = res.register(self.statement())\n\t            if res.error: return res\n", "            cases.append((condition, expr, False))\n\t            all_cases = res.register(self.if_expr_b_or_c())\n\t            if res.error: return res\n\t            new_cases, else_case = all_cases\n\t            cases.extend(new_cases)\n\t        return res.success((cases, else_case))\n\t    def for_expr(self):\n\t        res = ParseResult()\n\t        if not self.current_tok.matches(TT_KEYWORD, 'for'):\n\t            return res.failure(InvalidSyntaxError(\n", "                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected 'for'\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type != TT_IDENTIFIER:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected identifier\"\n\t            ))\n", "        var_name = self.current_tok\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type != TT_EQ:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected '='\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n", "        start_value = res.register(self.expr())\n\t        if res.error: return res\n\t        if not self.current_tok.matches(TT_KEYWORD, 'to'):\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected 'to'\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        end_value = res.register(self.expr())\n", "        if res.error: return res\n\t        if self.current_tok.matches(TT_KEYWORD, 'step'):\n\t            res.register_advancement()\n\t            self.advance()\n\t            step_value = res.register(self.expr())\n\t            if res.error: return res\n\t        else:\n\t            step_value = None\n\t        if not self.current_tok.type == TT_DCOLON:\n\t            return res.failure(InvalidSyntaxError(\n", "                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected ':'\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type == TT_NEWLINE:\n\t            res.register_advancement()\n\t            self.advance()\n\t            body = res.register(self.statements())\n\t            if res.error: return res\n", "            if not self.current_tok.matches(TT_KEYWORD, 'end'):\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    f\"Expected 'end'\"\n\t                ))\n\t            res.register_advancement()\n\t            self.advance()\n\t            return res.success(ForNode(var_name, start_value, end_value, step_value, body, True))\n\t        body = res.register(self.statement())\n\t        if res.error: return res\n", "        return res.success(ForNode(var_name, start_value, end_value, step_value, body, False))\n\t    ################################\n\t    def bin_op(self, func_a, ops, func_b=None):\n\t        if func_b == None:\n\t            func_b = func_a\n\t        res = ParseResult()\n\t        left = res.register(func_a())\n\t        if res.error: return res\n\t        while self.current_tok.type in ops or (self.current_tok.type, self.current_tok.value) in ops:\n\t            op_tok = self.current_tok\n", "            res.register_advancement()\n\t            self.advance()\n\t            right = res.register(func_b())\n\t            if res.error: return res\n\t            left = BinOpNode(left, op_tok, right)\n\t        return res.success(left)\n\t    def while_expr(self):\n\t        res = ParseResult()\n\t        if not self.current_tok.matches(TT_KEYWORD, 'while'):\n\t            return res.failure(InvalidSyntaxError(\n", "                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected 'while'\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        condition = res.register(self.expr())\n\t        if res.error: return res\n\t        if not self.current_tok.type == TT_DCOLON:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n", "                f\"Expected ':'\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type == TT_NEWLINE:\n\t            res.register_advancement()\n\t            self.advance()\n\t            body = res.register(self.statements())\n\t            if res.error: return res\n\t            if not self.current_tok.matches(TT_KEYWORD, 'end'):\n", "                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    f\"Expected 'end'\"\n\t                ))\n\t            res.register_advancement()\n\t            self.advance()\n\t            return res.success(WhileNode(condition, body, True))\n\t        body = res.register(self.statement())\n\t        if res.error: return res\n\t        return res.success(WhileNode(condition, body, False))\n", "    def func_def(self):\n\t        res = ParseResult()\n\t        res.register_advancement()\n\t        self.advance()\n\t        func_name = self.current_tok\n\t        self.current_func_name = func_name.value\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type != TT_LPAREN:\n\t            return res.failure(InvalidSyntaxError(\n", "                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                \"Expected '('\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        arg_name_toks = []\n\t        if self.current_tok.type == TT_IDENTIFIER:\n\t            arg_name_toks.append(self.current_tok)\n\t            res.register_advancement()\n\t            self.advance()\n", "            while self.current_tok.type == TT_COMMA:\n\t                res.register_advancement()\n\t                self.advance()\n\t                if self.current_tok.type != TT_IDENTIFIER:\n\t                    return res.failure(InvalidSyntaxError(\n\t                        self.current_tok.pos_start, self.current_tok.pos_end,\n\t                        \"Expected argument name\"\n\t                    ))\n\t                arg_name_toks.append(self.current_tok)\n\t                res.register_advancement()\n", "                self.advance()\n\t            if self.current_tok.type != TT_RPAREN:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n\t                    f\"Expected ',' or ')'\"\n\t                ))\n\t        else:\n\t            if self.current_tok.type != TT_RPAREN:\n\t                return res.failure(InvalidSyntaxError(\n\t                    self.current_tok.pos_start, self.current_tok.pos_end,\n", "                    \"Expected identifier or ')'\"\n\t                ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        if self.current_tok.type != TT_DCOLON:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected ':'\"\n\t            ))\n\t        res.register_advancement()\n", "        self.advance()\n\t        if self.current_tok.type != TT_NEWLINE:\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected NEWLINE\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        body = res.register(self.statements())\n\t        if res.error: return res\n", "        if not self.current_tok.matches(TT_KEYWORD, 'end'):\n\t            return res.failure(InvalidSyntaxError(\n\t                self.current_tok.pos_start, self.current_tok.pos_end,\n\t                f\"Expected 'end'\"\n\t            ))\n\t        res.register_advancement()\n\t        self.advance()\n\t        return res.success(FuncDefNode(\n\t            func_name,\n\t            arg_name_toks,\n", "            body,\n\t            False\n\t        ))\n"]}
{"filename": "Alphassembly/assembler/glang/modules/strings_with_arrows.py", "chunked_list": ["def string_with_arrows(text, pos_start, pos_end):\n\t    result = ''\n\t    # Calculate indices\n\t    idx_start = max(text.rfind('\\n', 0, pos_start.idx), 0)\n\t    idx_end = text.find('\\n', idx_start + 1)\n\t    if idx_end < 0: idx_end = len(text)\n\t    # Generate each line\n\t    line_count = pos_end.ln - pos_start.ln + 1\n\t    for i in range(line_count):\n\t        # Calculate line columns\n", "        line = text[idx_start:idx_end]\n\t        col_start = pos_start.col if i == 0 else 0\n\t        col_end = pos_end.col if i == line_count - 1 else len(line) - 1\n\t        # Append to result\n\t        result += line + '\\n'\n\t        result += ' ' * col_start + '^' * (col_end - col_start)\n\t        # Re-calculate indices\n\t        idx_start = idx_end\n\t        idx_end = text.find('\\n', idx_start + 1)\n\t        if idx_end < 0: idx_end = len(text)\n", "    return result.replace('\\t', '')"]}
{"filename": "Alphassembly/assembler/glang/modules/ctresult.py", "chunked_list": ["class CTResult:\n\t    def __init__(self):\n\t        self.reset()\n\t    def reset(self):\n\t        self.value = None\n\t        self.error = None\n\t        self.func_return_value = None\n\t        self.loop_should_continue = False\n\t        self.loop_should_break = False\n\t    def register(self, res):\n", "        self.error = res.error\n\t        self.func_return_value = res.func_return_value\n\t        self.loop_should_continue = res.loop_should_continue\n\t        self.loop_should_break = res.loop_should_break\n\t        if res.value is None: res.value = \"\"\n\t        return res.value\n\t    def success(self, value):\n\t        self.reset()\n\t        self.value = value\n\t        return self\n", "    def success_return(self, value):\n\t        self.reset()\n\t        self.func_return_value = value\n\t        return self\n\t    def success_continue(self):\n\t        self.reset()\n\t        self.loop_should_continue = True\n\t        return self\n\t    def success_break(self):\n\t        self.reset()\n", "        self.loop_should_break = True\n\t        return self\n\t    def failure(self, error):\n\t        self.reset()\n\t        self.error = error\n\t        return self\n\t    def should_return(self):\n\t        # Note: this will allow you to continue and break outside the current function\n\t        return (\n\t            self.error\n", "        )"]}
{"filename": "Alphassembly/assembler/glang/modules/builtins.py", "chunked_list": ["from .builtin_function import *\n\tBuiltinFunction.print = BuiltinFunction(\"print\")\n\tBuiltinFunction.exit = BuiltinFunction(\"exit\")\n\tBuiltinFunction.asm = BuiltinFunction(\"asm\")\n\tBuiltinFunction.ref = BuiltinFunction(\"ref\")\n\t# add argc and argv functions\n\tBUILTINS = {\n\t    \"print\": BuiltinFunction.print,\n\t    \"exit\": BuiltinFunction.exit,\n\t    \"asm\": BuiltinFunction.asm,\n", "    \"ref\": BuiltinFunction.ref,\n\t    'new': None # done in codegen\n\t}"]}
{"filename": "Alphassembly/assembler/glang/modules/position.py", "chunked_list": ["class Position:\n\t    def __init__(self, idx, ln, col, fn, ftxt):\n\t        self.idx = idx\n\t        self.ln = ln\n\t        self.col = col\n\t        self.fn = fn\n\t        self.ftxt = ftxt\n\t    def advance(self, current_char=None):\n\t        self.idx += 1\n\t        self.col += 1\n", "        if current_char == '\\n':\n\t            self.ln += 1\n\t            self.col = 0\n\t        return self\n\t    def copy(self):\n\t        return Position(self.idx, self.ln, self.col, self.fn, self.ftxt)\n"]}
{"filename": "Alphassembly/assembler/glang/modules/nodes.py", "chunked_list": ["from .consts import *\n\tfrom .lexer import *\n\tclass IntegerNode:\n\t    def __init__(self, tok):\n\t        self.tok = tok\n\t        self.pos_start = self.tok.pos_start\n\t        self.pos_end = self.tok.pos_end\n\t    def __repr__(self):\n\t        return f'{self.tok}'\n\tclass StringNode:\n", "    def __init__(self, tok):\n\t        self.tok = tok\n\t        self.pos_start = self.tok.pos_start\n\t        self.pos_end = self.tok.pos_end\n\t    def __repr__(self):\n\t        return f'{self.tok}'\n\tclass FloatNode:\n\t    def __init__(self, tok):\n\t        self.tok = tok\n\t        self.pos_start = self.tok.pos_start\n", "        self.pos_end = self.tok.pos_end\n\t    def __repr__(self):\n\t        return f'{self.tok}'\n\tclass ListNode:\n\t    def __init__(self, element_nodes, pos_start, pos_end):\n\t        self.element_nodes = element_nodes\n\t        self.pos_start = pos_start\n\t        self.pos_end = pos_end\n\tclass VarAccessNode:\n\t    def __init__(self, var_name_tok):\n", "        self.var_name_tok = var_name_tok\n\t        self.pos_start = self.var_name_tok.pos_start\n\t        self.pos_end = self.var_name_tok.pos_end\n\tclass VarAssignNode:\n\t    def __init__(self, var_name_tok, value_node):\n\t        self.var_name_tok = var_name_tok\n\t        self.value_node = value_node\n\t        self.pos_start = self.var_name_tok.pos_start\n\t        self.pos_end = self.value_node.pos_end\n\tclass BinOpNode:\n", "    def __init__(self, left_node, op_tok, right_node):\n\t        self.left_node = left_node\n\t        self.op_tok = op_tok\n\t        self.right_node = right_node\n\t        self.pos_start = self.left_node.pos_start\n\t        self.pos_end = self.right_node.pos_end\n\t    def __repr__(self):\n\t        return f'({self.left_node}, {self.op_tok}, {self.right_node})'\n\t    def remove_last_node(self):\n\t        if not isinstance(self.right_node, BinOpNode):\n", "            # if the right node is not a BinOpNode, then it is the last node\n\t            return self.left_node, None\n\t        # recursively remove the last node from the right subtree\n\t        new_right_node, op_tok = self.right_node.remove_last_node()\n\t        # create a new BinOpNode with the updated right subtree\n\t        new_node = BinOpNode(self.left_node, self.op_tok, new_right_node)\n\t        return new_node, op_tok\n\tclass UnaryOpNode:\n\t    def __init__(self, op_tok, node):\n\t        self.op_tok = op_tok\n", "        self.node = node\n\t        self.pos_start = self.op_tok.pos_start\n\t        self.pos_end = node.pos_end\n\t        def __repr__(self):\n\t            return f'({self.op_tok}, {self.node})'\n\tclass IfNode:\n\t    def __init__(self, cases, else_case):\n\t        self.cases = cases\n\t        self.else_case = else_case\n\t        self.pos_start = self.cases[0][0].pos_start\n", "        if type((self.else_case or self.cases[len(self.cases) - 1])[0]) is not list:\n\t            self.pos_end = (self.else_case or self.cases[len(self.cases) - 1])[0].pos_end\n\t        else:\n\t            self.pos_end = (self.else_case or self.cases[len(self.cases) - 1])[0][-1].pos_end\n\tclass CallNode:\n\t    def __init__(self, node_to_call, arg_nodes):\n\t        self.node_to_call = node_to_call\n\t        self.arg_nodes = arg_nodes\n\t        self.pos_start = self.node_to_call.pos_start\n\t        if len(self.arg_nodes) > 0:\n", "            self.pos_end = self.arg_nodes[len(self.arg_nodes) - 1].pos_end\n\t        else:\n\t            self.pos_end = self.node_to_call.pos_end\n\tclass ForNode:\n\t    def __init__(self, var_name_tok, start_value_node, end_value_node, step_value_node, body_node, should_return_null):\n\t        self.var_name_tok = var_name_tok\n\t        self.start_value_node = start_value_node\n\t        self.end_value_node = end_value_node\n\t        self.step_value_node = step_value_node\n\t        self.body_node = body_node\n", "        self.should_return_null = should_return_null\n\t        self.pos_start = self.var_name_tok.pos_start\n\t        self.pos_end = self.body_node[-1].pos_end\n\tclass ContinueNode:\n\t    def __init__(self, pos_start, pos_end):\n\t        self.pos_start = pos_start\n\t        self.pos_end = pos_end\n\tclass BreakNode:\n\t    def __init__(self, pos_start, pos_end):\n\t        self.pos_start = pos_start\n", "        self.pos_end = pos_end\n\tclass WhileNode:\n\t    def __init__(self, condition_node, body_node, should_return_null):\n\t        self.condition_node = condition_node\n\t        self.body_node = body_node\n\t        self.should_return_null = should_return_null\n\t        self.pos_start = self.condition_node.pos_start\n\t        self.pos_end = self.body_node[-1].pos_end\n\tclass ReturnNode:\n\t    def __init__(self, node_to_return, pos_start, pos_end):\n", "        self.node_to_return = node_to_return\n\t        self.pos_start = pos_start\n\t        self.pos_end = pos_end\n\tclass FuncDefNode:\n\t    def __init__(self, func_name_tok, arg_name_toks, body_node, should_auto_return):\n\t        self.func_name_tok = func_name_tok\n\t        self.arg_name_toks = arg_name_toks\n\t        self.body_node = body_node\n\t        self.should_auto_return = should_auto_return\n\t        if self.func_name_tok:\n", "            self.pos_start = self.func_name_tok.pos_start\n\t        elif len(self.arg_name_toks) > 0:\n\t            self.pos_start = self.arg_name_toks[0].pos_start\n\t        else:\n\t            self.pos_start = self.body_node.pos_start\n\t        self.pos_end = self.body_node[-1].pos_end\n\tclass UnaryOpNode:\n\t    def __init__(self, op_tok, node):\n\t        self.op_tok = op_tok\n\t        self.node = node\n", "        self.pos_start = self.op_tok.pos_start\n\t        self.pos_end = node.pos_end\n\t        def __repr__(self):\n\t            return f'({self.op_tok}, {self.node})'\n\tclass ClassNode:\n\t    def __init__(self, var_name_tok):\n\t        self.var_name_tok = var_name_tok\n\t        self.pos_start = self.var_name_tok.pos_start\n\t        self.pos_end = self.pos_start\n\tclass ClassAssignNode:\n", "    def __init__(self, var_name_tok, properties, methods=None):\n\t        self.var_name_tok = var_name_tok\n\t        self.value_node = properties\n\t        self.methods = methods \n\t        self.pos_start = self.var_name_tok.pos_start\n\t        self.pos_end = self.value_node.pos_end\n"]}
