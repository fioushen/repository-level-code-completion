{"filename": "tests/test_examples.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\tfrom examples import hello_world, psycopg2_connect, server_utilisation, sqlalchemy_orm, sqlalchemy_raw\n\tdef test_hello_world():\n\t    hello_world.main()\n\tdef test_psycopg2_connect():\n\t    psycopg2_connect.main()\n\tdef test_server_utilisation():\n\t    server_utilisation.main(duration_sec=2.0)\n\tdef test_sqlalchemy_orm():\n", "    sqlalchemy_orm.main()\n\tdef test_sqlalchemy_raw():\n\t    sqlalchemy_raw.main()\n"]}
{"filename": "tests/test_types.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport re\n\timport questdb_connect as qdbc\n\tdef test_resolve_type_from_name():\n\t    for type_class in qdbc.QUESTDB_TYPES:\n\t        resolved_class = qdbc.resolve_type_from_name(type_class.__visit_name__)\n\t        assert type_class.__visit_name__ == resolved_class.__visit_name__\n\t        assert isinstance(type_class(), resolved_class)\n\t        assert isinstance(resolved_class(), type_class)\n", "    for n in range(1, 61):\n\t        g_name = qdbc.geohash_type_name(n)\n\t        g_class = qdbc.resolve_type_from_name(g_name)\n\t        assert isinstance(g_class(), qdbc.geohash_class(n))\n\tdef test_superset_default_mappings():\n\t    default_column_type_mappings = (\n\t        (re.compile(\"^LONG256\", re.IGNORECASE), qdbc.Long256),\n\t        (re.compile(\"^BOOLEAN\", re.IGNORECASE), qdbc.Boolean),\n\t        (re.compile(\"^BYTE\", re.IGNORECASE), qdbc.Byte),\n\t        (re.compile(\"^SHORT\", re.IGNORECASE), qdbc.Short),\n", "        (re.compile(\"^INT\", re.IGNORECASE), qdbc.Int),\n\t        (re.compile(\"^LONG\", re.IGNORECASE), qdbc.Long),\n\t        (re.compile(\"^FLOAT\", re.IGNORECASE), qdbc.Float),\n\t        (re.compile(\"^DOUBLE'\", re.IGNORECASE), qdbc.Double),\n\t        (re.compile(\"^SYMBOL\", re.IGNORECASE), qdbc.Symbol),\n\t        (re.compile(\"^STRING\", re.IGNORECASE), qdbc.String),\n\t        (re.compile(\"^UUID\", re.IGNORECASE), qdbc.UUID),\n\t        (re.compile(\"^CHAR\", re.IGNORECASE), qdbc.Char),\n\t        (re.compile(\"^TIMESTAMP\", re.IGNORECASE), qdbc.Timestamp),\n\t        (re.compile(\"^DATE\", re.IGNORECASE), qdbc.Date)\n", "    )\n\t    for type_class in qdbc.QUESTDB_TYPES:\n\t        for pattern, _expected_type in default_column_type_mappings:\n\t            matching_name = pattern.match(type_class.__visit_name__)\n\t            if matching_name:\n\t                resolved_class = qdbc.resolve_type_from_name(matching_name.group(0))\n\t                assert type_class.__visit_name__ == resolved_class.__visit_name__\n\t                assert isinstance(type_class(), resolved_class)\n\t                assert isinstance(resolved_class(), type_class)\n\t                break\n", "    geohash_pattern = re.compile(r\"^GEOHASH\\(\\d+[b|c]\\)\", re.IGNORECASE)\n\t    for n in range(1, 61):\n\t        g_name = qdbc.geohash_type_name(n)\n\t        matching_name = geohash_pattern.match(g_name).group(0)\n\t        assert matching_name == g_name\n\t        g_class = qdbc.resolve_type_from_name(g_name)\n\t        assert isinstance(g_class(), qdbc.geohash_class(n))\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n"]}
{"filename": "tests/test_superset.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport datetime\n\tfrom unittest import mock\n\timport pytest\n\tfrom qdb_superset.db_engine_specs.questdb import QuestDbEngineSpec\n\tfrom questdb_connect.types import QUESTDB_TYPES, Timestamp\n\tfrom sqlalchemy import column, literal_column\n\tfrom sqlalchemy.types import TypeEngine\n\tdef test_build_sqlalchemy_uri():\n", "    request_uri = QuestDbEngineSpec.build_sqlalchemy_uri(\n\t        {\n\t            \"host\": \"localhost\",\n\t            \"port\": \"8812\",\n\t            \"username\": \"admin\",\n\t            \"password\": \"quest\",\n\t            \"database\": \"main\",\n\t        }\n\t    )\n\t    assert request_uri == \"questdb://admin:quest@localhost:8812/main\"\n", "def test_default_schema_for_query():\n\t    assert QuestDbEngineSpec.get_default_schema_for_query(\"main\", None) == None\n\tdef test_get_text_clause():\n\t    sql_clause = \"SELECT * FROM public.mytable t1\"\n\t    sql_clause += \" JOIN public.myclient t2 ON t1.id = t2.id\"\n\t    expected_clause = \"SELECT * FROM mytable t1 JOIN myclient t2 ON t1.id = t2.id\"\n\t    actual_clause = str(QuestDbEngineSpec.get_text_clause(sql_clause))\n\t    print(f\"sql: {sql_clause}, ex: {expected_clause}, ac: {actual_clause}\")\n\t    assert expected_clause == actual_clause\n\tdef test_epoch_to_dttm():\n", "    assert QuestDbEngineSpec.epoch_to_dttm() == \"{col} * 1000000\"\n\t@pytest.mark.parametrize(\n\t    (\"target_type\", \"expected_result\", \"dttm\"),\n\t    [\n\t        (\n\t                \"Date\",\n\t                \"TO_DATE('2023-04-28', 'YYYY-MM-DD')\",\n\t                datetime.datetime(2023, 4, 28, 23, 55, 59, 281567),\n\t        ),\n\t        (\n", "                \"DateTime\",\n\t                \"TO_TIMESTAMP('2023-04-28T23:55:59.281567', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ')\",\n\t                datetime.datetime(2023, 4, 28, 23, 55, 59, 281567),\n\t        ),\n\t        (\n\t                \"TimeStamp\",\n\t                \"TO_TIMESTAMP('2023-04-28T23:55:59.281567', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ')\",\n\t                datetime.datetime(2023, 4, 28, 23, 55, 59, 281567),\n\t        ),\n\t        (\"UnknownType\", None, datetime.datetime(2023, 4, 28, 23, 55, 59, 281567)),\n", "    ],\n\t)\n\tdef test_convert_dttm(target_type, expected_result, dttm) -> None:\n\t    # datetime(year, month, day, hour, minute, second, microsecond)\n\t    for target in (\n\t            target_type,\n\t            target_type.upper(),\n\t            target_type.lower(),\n\t            target_type.capitalize(),\n\t    ):\n", "        assert expected_result == QuestDbEngineSpec.convert_dttm(\n\t            target_type=target, dttm=dttm\n\t        )\n\tdef test_get_datatype():\n\t    assert QuestDbEngineSpec.get_datatype(\"int\") == \"INT\"\n\t    assert QuestDbEngineSpec.get_datatype([\"int\"]) == \"['int']\"\n\tdef test_get_column_spec():\n\t    for native_type in QUESTDB_TYPES:\n\t        column_spec = QuestDbEngineSpec.get_column_spec(native_type.__visit_name__)\n\t        assert native_type == column_spec.sqla_type\n", "        assert native_type != Timestamp or column_spec.is_dttm\n\tdef test_get_sqla_column_type():\n\t    for native_type in QUESTDB_TYPES:\n\t        column_type = QuestDbEngineSpec.get_sqla_column_type(native_type.__visit_name__)\n\t        assert isinstance(column_type, TypeEngine.__class__)\n\tdef test_get_allow_cost_estimate():\n\t    assert not QuestDbEngineSpec.get_allow_cost_estimate(extra=None)\n\tdef test_get_view_names():\n\t    assert set() == QuestDbEngineSpec.get_view_names(\"main\", None, None)\n\tdef test_get_table_names():\n", "    inspector = mock.Mock()\n\t    inspector.get_table_names = mock.Mock(\n\t        return_value=[\"public.table\", \"table_2\", '\"public.table_3\"']\n\t    )\n\t    pg_result = QuestDbEngineSpec.get_table_names(\n\t        database=mock.ANY, schema=\"public\", inspector=inspector\n\t    )\n\t    assert {\"table\", '\"public.table_3\"', \"table_2\"} == pg_result\n\tdef test_time_exp_literal_no_grain(test_engine):\n\t    col = literal_column(\"COALESCE(a, b)\")\n", "    expr = QuestDbEngineSpec.get_timestamp_expr(col, None, None)\n\t    result = str(expr.compile(None, dialect=test_engine.dialect))\n\t    assert \"COALESCE(a, b)\" == result\n\tdef test_time_ex_lowr_col_no_grain(test_engine):\n\t    col = column(\"lower_case\")\n\t    expr = QuestDbEngineSpec.get_timestamp_expr(col, None, None)\n\t    result = str(expr.compile(None, dialect=test_engine.dialect))\n\t    assert \"lower_case\" == result\n"]}
{"filename": "tests/test_dialect.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport datetime\n\timport questdb_connect as qdbc\n\timport sqlalchemy as sqla\n\tfrom sqlalchemy.orm import Session\n\tfrom tests.conftest import ALL_TYPES_TABLE_NAME, collect_select_all, collect_select_all_raw_connection\n\tdef test_insert(test_engine, test_model):\n\t    with test_engine.connect() as conn:\n\t        assert test_engine.dialect.has_table(conn, ALL_TYPES_TABLE_NAME)\n", "        assert not test_engine.dialect.has_table(conn, 'scorchio')\n\t        now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n\t        now_date = now.date()\n\t        expected = (\"(True, 8, 12, 13, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n\t                    \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                    \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n\t                    \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n\t                    \"(True, 8, 12, 13, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n\t                    \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                    \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n", "                    \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\")\n\t        insert_stmt = sqla.insert(test_model).values(\n\t            col_boolean=True,\n\t            col_byte=8,\n\t            col_short=12,\n\t            col_int=13,\n\t            col_long=14,\n\t            col_float=15.234,\n\t            col_double=16.88993244,\n\t            col_symbol='coconut',\n", "            col_string='banana',\n\t            col_char='C',\n\t            col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n\t            col_date=now_date,\n\t            col_ts=now,\n\t            col_geohash='dfvgsj2vptwu',\n\t            col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n\t        )\n\t        conn.execute(insert_stmt)\n\t        conn.execute(sqla.insert(test_model), {\n", "            'col_boolean': True,\n\t            'col_byte': 8,\n\t            'col_short': 12,\n\t            'col_int': 13,\n\t            'col_long': 14,\n\t            'col_float': 15.234,\n\t            'col_double': 16.88993244,\n\t            'col_symbol': 'coconut',\n\t            'col_string': 'banana',\n\t            'col_char': 'C',\n", "            'col_uuid': '6d5eb038-63d1-4971-8484-30c16e13de5b',\n\t            'col_date': now_date,\n\t            'col_ts': now,\n\t            'col_geohash': 'dfvgsj2vptwu',\n\t            'col_long256': '0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n\t        })\n\t        assert collect_select_all(conn, expected_rows=2) == expected\n\t    assert collect_select_all_raw_connection(test_engine, expected_rows=2) == expected\n\tdef test_inspect(test_engine, test_model):\n\t    now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n", "    now_date = now.date()\n\t    session = Session(test_engine)\n\t    try:\n\t        session.add(test_model(\n\t            col_boolean=True,\n\t            col_byte=8,\n\t            col_short=12,\n\t            col_int=0,\n\t            col_long=14,\n\t            col_float=15.234,\n", "            col_double=16.88993244,\n\t            col_symbol='coconut',\n\t            col_string='banana',\n\t            col_char='C',\n\t            col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n\t            col_date=now_date,\n\t            col_ts=now,\n\t            col_geohash='dfvgsj2vptwu',\n\t            col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n\t        ))\n", "        session.commit()\n\t    finally:\n\t        if session:\n\t            session.close()\n\t    metadata = sqla.MetaData()\n\t    table = sqla.Table(ALL_TYPES_TABLE_NAME, metadata, autoload_with=test_engine)\n\t    table_columns = str([(col.name, col.type, col.primary_key) for col in table.columns])\n\t    assert table_columns == str([\n\t        ('col_boolean', qdbc.Boolean(), False),\n\t        ('col_byte', qdbc.Byte(), False),\n", "        ('col_short', qdbc.Short(), False),\n\t        ('col_int', qdbc.Int(), False),\n\t        ('col_long', qdbc.Long(), False),\n\t        ('col_float', qdbc.Float(), False),\n\t        ('col_double', qdbc.Double(), False),\n\t        ('col_symbol', qdbc.Symbol(), False),\n\t        ('col_string', qdbc.String(), False),\n\t        ('col_char', qdbc.Char(), False),\n\t        ('col_uuid', qdbc.UUID(), False),\n\t        ('col_date', qdbc.Date(), False),\n", "        ('col_ts', qdbc.Timestamp(), True),\n\t        ('col_geohash', qdbc.GeohashInt(), False),\n\t        ('col_long256', qdbc.Long256(), False)\n\t    ])\n\tdef test_multiple_insert(test_engine, test_model):\n\t    now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n\t    now_date = now.date()\n\t    session = Session(test_engine)\n\t    num_rows = 3\n\t    expected = (\"(True, 8, 12, 2, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n", "                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n\t                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n\t                \"(True, 8, 12, 1, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n\t                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n\t                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n\t                \"(True, 8, 12, 0, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n\t                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n", "                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\")\n\t    try:\n\t        for idx in range(num_rows):\n\t            session.add(test_model(\n\t                col_boolean=True,\n\t                col_byte=8,\n\t                col_short=12,\n\t                col_int=idx,\n\t                col_long=14,\n\t                col_float=15.234,\n", "                col_double=16.88993244,\n\t                col_symbol='coconut',\n\t                col_string='banana',\n\t                col_char='C',\n\t                col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n\t                col_date=now_date,\n\t                col_ts=now,\n\t                col_geohash='dfvgsj2vptwu',\n\t                col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n\t            ))\n", "            session.commit()\n\t        assert collect_select_all(session, expected_rows=num_rows) == expected\n\t    finally:\n\t        if session:\n\t            session.close()\n\t        assert collect_select_all_raw_connection(test_engine, expected_rows=num_rows) == expected\n\tdef test_bulk_insert(test_engine, test_model):\n\t    now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n\t    now_date = now.date()\n\t    session = Session(test_engine)\n", "    num_rows = 3\n\t    expected = (\"(True, 8, 12, 2, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n\t                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n\t                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n\t                \"(True, 8, 12, 1, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n\t                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n\t                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n\t                \"(True, 8, 12, 0, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n", "                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n\t                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n\t                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\")\n\t    models = [\n\t        test_model(\n\t            col_boolean=True,\n\t            col_byte=8,\n\t            col_short=12,\n\t            col_int=idx,\n\t            col_long=14,\n", "            col_float=15.234,\n\t            col_double=16.88993244,\n\t            col_symbol='coconut',\n\t            col_string='banana',\n\t            col_char='C',\n\t            col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n\t            col_date=now_date,\n\t            col_ts=now,\n\t            col_geohash='dfvgsj2vptwu',\n\t            col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n", "        ) for idx in range(num_rows)\n\t    ]\n\t    try:\n\t        session.bulk_save_objects(models)\n\t        session.commit()\n\t        assert collect_select_all(session, expected_rows=num_rows) == expected\n\t    finally:\n\t        if session:\n\t            session.close()\n\t        assert collect_select_all_raw_connection(test_engine, expected_rows=num_rows) == expected\n", "def test_functions(test_engine):\n\t    with test_engine.connect() as conn:\n\t        expected = [row[0] for row in conn.execute(\"SELECT name FROM functions()\").fetchall()]\n\t        assert qdbc.get_functions_list() == expected\n\tdef test_keywords(test_engine):\n\t    with test_engine.connect() as conn:\n\t        expected = [row[0] for row in conn.execute(\"SELECT keyword FROM keywords()\").fetchall()]\n\t        assert qdbc.get_keywords_list() == expected\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport os\n\tfrom typing import NamedTuple\n\timport pytest\n\timport questdb_connect as qdbc\n\tfrom sqlalchemy import Column, MetaData, text\n\tfrom sqlalchemy.orm import declarative_base\n\tos.environ.setdefault('SQLALCHEMY_SILENCE_UBER_WARNING', '1')\n\tALL_TYPES_TABLE_NAME = 'all_types_table'\n", "METRICS_TABLE_NAME = 'metrics_table'\n\tclass TestConfig(NamedTuple):\n\t    host: str\n\t    port: int\n\t    username: str\n\t    password: str\n\t    database: str\n\t    __test__ = True\n\t@pytest.fixture(scope='session', autouse=True, name='test_config')\n\tdef test_config_fixture() -> TestConfig:\n", "    return TestConfig(\n\t        host=os.environ.get('QUESTDB_CONNECT_HOST', 'localhost'),\n\t        port=int(os.environ.get('QUESTDB_CONNECT_PORT', '8812')),\n\t        username=os.environ.get('QUESTDB_CONNECT_USER', 'admin'),\n\t        password=os.environ.get('QUESTDB_CONNECT_PASSWORD', 'quest'),\n\t        database=os.environ.get('QUESTDB_CONNECT_DATABASE', 'main')\n\t    )\n\t@pytest.fixture(scope='module', name='test_engine')\n\tdef test_engine_fixture(test_config: TestConfig):\n\t    engine = None\n", "    try:\n\t        engine = qdbc.create_engine(\n\t            test_config.host,\n\t            test_config.port,\n\t            test_config.username,\n\t            test_config.password,\n\t            test_config.database)\n\t        return engine\n\t    finally:\n\t        if engine:\n", "            engine.dispose()\n\t            del engine\n\t@pytest.fixture(autouse=True, name='test_model')\n\tdef test_model_fixture(test_engine):\n\t    Base = declarative_base(metadata=MetaData())\n\t    class TableModel(Base):\n\t        __tablename__ = ALL_TYPES_TABLE_NAME\n\t        __table_args__ = (qdbc.QDBTableEngine(ALL_TYPES_TABLE_NAME, 'col_ts', qdbc.PartitionBy.DAY, is_wal=True),)\n\t        col_boolean = Column('col_boolean', qdbc.Boolean)\n\t        col_byte = Column('col_byte', qdbc.Byte)\n", "        col_short = Column('col_short', qdbc.Short)\n\t        col_int = Column('col_int', qdbc.Int)\n\t        col_long = Column('col_long', qdbc.Long)\n\t        col_float = Column('col_float', qdbc.Float)\n\t        col_double = Column('col_double', qdbc.Double)\n\t        col_symbol = Column('col_symbol', qdbc.Symbol)\n\t        col_string = Column('col_string', qdbc.String)\n\t        col_char = Column('col_char', qdbc.Char)\n\t        col_uuid = Column('col_uuid', qdbc.UUID)\n\t        col_date = Column('col_date', qdbc.Date)\n", "        col_ts = Column('col_ts', qdbc.Timestamp, primary_key=True)\n\t        col_geohash = Column('col_geohash', qdbc.GeohashInt)\n\t        col_long256 = Column('col_long256', qdbc.Long256)\n\t    Base.metadata.drop_all(test_engine)\n\t    Base.metadata.create_all(test_engine)\n\t    return TableModel\n\t@pytest.fixture(autouse=True, name='test_metrics')\n\tdef test_metrics_fixture(test_engine):\n\t    Base = declarative_base(metadata=MetaData())\n\t    class TableMetrics(Base):\n", "        __tablename__ = METRICS_TABLE_NAME\n\t        __table_args__ = (qdbc.QDBTableEngine(METRICS_TABLE_NAME, 'ts', qdbc.PartitionBy.HOUR, is_wal=True),)\n\t        source = Column(qdbc.Symbol)\n\t        attr_name = Column(qdbc.Symbol)\n\t        attr_value = Column(qdbc.Double)\n\t        ts = Column(qdbc.Timestamp, primary_key=True)\n\t    Base.metadata.drop_all(test_engine)\n\t    Base.metadata.create_all(test_engine)\n\t    return TableMetrics\n\tdef collect_select_all(session, expected_rows) -> str:\n", "    while True:\n\t        rs = session.execute(text(f'select * from public.{ALL_TYPES_TABLE_NAME} order by 1 asc'))\n\t        if rs.rowcount == expected_rows:\n\t            return '\\n'.join(str(row) for row in rs)\n\tdef collect_select_all_raw_connection(test_engine, expected_rows) -> str:\n\t    conn = test_engine.raw_connection()\n\t    try:\n\t        while True:\n\t            with conn.cursor() as cursor:\n\t                cursor.execute(f'select * from public.{ALL_TYPES_TABLE_NAME} order by 1 asc')\n", "                if cursor.rowcount == expected_rows:\n\t                    return '\\n'.join(str(row) for row in cursor)\n\t    finally:\n\t        if conn:\n\t            conn.close()\n"]}
{"filename": "src/examples/server_utilisation.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport datetime\n\timport enum\n\timport os\n\timport random\n\timport time\n\tos.environ.setdefault(\"SQLALCHEMY_SILENCE_UBER_WARNING\", \"1\")\n\timport questdb_connect as qdbc\n\tfrom sqlalchemy import Column, MetaData, create_engine\n", "from sqlalchemy.orm import Session, declarative_base\n\tclass BaseEnum(enum.Enum):\n\t    @classmethod\n\t    def rand(cls):\n\t        return cls._value2member_map_[random.randint(0, len(cls._member_map_) - 1)]\n\tclass Nodes(BaseEnum):\n\t    NODE0 = 0\n\t    NODE1 = 1\n\tclass Metrics(BaseEnum):\n\t    CPU = 0\n", "    RAM = 1\n\t    HDD0 = 2\n\t    HDD1 = 3\n\t    NETWORK = 4\n\tBase = declarative_base(metadata=MetaData())\n\tclass NodeMetrics(Base):\n\t    __tablename__ = \"node_metrics\"\n\t    __table_args__ = (\n\t        qdbc.QDBTableEngine(\"node_metrics\", \"ts\", qdbc.PartitionBy.HOUR, is_wal=True),\n\t    )\n", "    source = Column(qdbc.Symbol)  # Nodes\n\t    attr_name = Column(qdbc.Symbol)  # Metrics\n\t    attr_value = Column(qdbc.Double)\n\t    ts = Column(qdbc.Timestamp, primary_key=True)\n\tdef main(duration_sec: float = 10.0):\n\t    end_time = time.time() + max(duration_sec - 0.5, 2.0)\n\t    engine = create_engine(\"questdb://localhost:8812/main\")\n\t    session = Session(engine)\n\t    max_batch_size = 3000\n\t    try:\n", "        Base.metadata.drop_all(engine)\n\t        Base.metadata.create_all(engine)\n\t        batch_size = 0\n\t        while time.time() < end_time:\n\t            node = Nodes.rand()\n\t            session.add(\n\t                NodeMetrics(\n\t                    source=node.name,\n\t                    attr_name=Metrics.rand().name,\n\t                    attr_value=random.random() * node.value * random.randint(1, 100),\n", "                    ts=datetime.datetime.utcnow(),\n\t                )\n\t            )\n\t            batch_size += 1\n\t            if batch_size > max_batch_size:\n\t                session.commit()\n\t                batch_size = 0\n\t        if batch_size > 0:\n\t            session.commit()\n\t    finally:\n", "        if session:\n\t            session.close()\n\t        if engine:\n\t            engine.dispose()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/examples/hello_world.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport datetime\n\timport os\n\tos.environ.setdefault(\"SQLALCHEMY_SILENCE_UBER_WARNING\", \"1\")\n\timport questdb_connect as qdbc\n\tfrom sqlalchemy import Column, MetaData, create_engine, insert\n\tfrom sqlalchemy.orm import declarative_base\n\tBase = declarative_base(metadata=MetaData())\n\tclass Signal(Base):\n", "    __tablename__ = \"signal\"\n\t    __table_args__ = (\n\t        qdbc.QDBTableEngine(\"signal\", \"ts\", qdbc.PartitionBy.HOUR, is_wal=True),\n\t    )\n\t    source = Column(qdbc.Symbol)\n\t    value = Column(qdbc.Double)\n\t    ts = Column(qdbc.Timestamp, primary_key=True)\n\tdef main():\n\t    engine = create_engine(\"questdb://localhost:8812/main\")\n\t    try:\n", "        Base.metadata.create_all(engine)\n\t        with engine.connect() as conn:\n\t            conn.execute(\n\t                insert(Signal).values(\n\t                    source=\"coconut\", value=16.88993244, ts=datetime.datetime.utcnow()\n\t                )\n\t            )\n\t    finally:\n\t        if engine:\n\t            engine.dispose()\n", "if __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/examples/sqlalchemy_raw.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport sqlalchemy as sqla\n\tdef main():\n\t    print(f\"SqlAlchemy {sqla.__version__}\")\n\t    table_name = \"sqlalchemy_raw\"\n\t    engine = sqla.create_engine(\"questdb://localhost:8812/main\", echo=True, future=True)\n\t    try:\n\t        with engine.connect() as conn:\n\t            conn.execute(sqla.text(f\"DROP TABLE IF EXISTS {table_name}\"))\n", "            conn.execute(\n\t                sqla.text(f\"CREATE TABLE IF NOT EXISTS {table_name} (x int, y int)\")\n\t            )\n\t            conn.execute(\n\t                sqla.text(f\"INSERT INTO {table_name} (x, y) VALUES (:x, :y)\"),\n\t                [{\"x\": 1, \"y\": 1}, {\"x\": 2, \"y\": 4}],\n\t            )\n\t            conn.commit()\n\t            result = conn.execute(\n\t                sqla.text(f\"SELECT x, y FROM {table_name} WHERE y > :y\"), {\"y\": 2}\n", "            )\n\t            for row in result:\n\t                print(f\"x: {row.x}  y: {row.y}\")\n\t            result = conn.execute(sqla.text(f\"SELECT x, y FROM {table_name}\"))\n\t            for dict_row in result.mappings():\n\t                x = dict_row[\"x\"]\n\t                y = dict_row[\"y\"]\n\t                print(f\"x: {x}  y: {y}\")\n\t    finally:\n\t        if engine:\n", "            engine.dispose()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/examples/__init__.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport os\n\tCONNECTION_ATTRS = {\n\t    \"host\": os.environ.get(\"QUESTDB_CONNECT_HOST\", \"localhost\"),\n\t    \"port\": int(os.environ.get(\"QUESTDB_CONNECT_PORT\", \"8812\")),\n\t    \"username\": os.environ.get(\"QUESTDB_CONNECT_USER\", \"admin\"),\n\t    \"password\": os.environ.get(\"QUESTDB_CONNECT_PASSWORD\", \"quest\"),\n\t}\n"]}
{"filename": "src/examples/psycopg2_connect.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\t\"\"\"\n\tThis code connects to a running QuestDB instance and displays information\n\tabout the tables and partitions in the database. It uses two SQL statements\n\tto retrieve this information: \"tables()\" and \"table_partitions()\". The output\n\tis formatted and printed to the console.\n\t\"\"\"\n\timport json\n\tfrom questdb_connect import connect\n", "from examples import CONNECTION_ATTRS\n\tdef print_partition(row):\n\t    p_index, p_by, _, min_ts, max_ts, num_rows, _, p_size, *_ = row\n\t    print(\n\t        f\" - Partition {p_index} by {p_by} [{min_ts}, {max_ts}] {num_rows} rows {p_size}\"\n\t    )\n\tdef print_table(row):\n\t    table_id, table_name, ts_column, p_by, _, _, is_wal, dir_name = row\n\t    msg = \", \".join(\n\t        (\n", "            f\"Table id:{table_id}\",\n\t            f\"name:{table_name}\",\n\t            f\"ts-col:{ts_column}\",\n\t            f\"partition-by:{p_by}\",\n\t            f\"is-wal:{is_wal}\",\n\t            f\"dir-name:{dir_name}\",\n\t        )\n\t    )\n\t    print(msg)\n\tdef print_server_info(dsn_parameters):\n", "    print(f\"QuestDB server information: {json.dumps(dsn_parameters, indent=4)}\")\n\tdef main():\n\t    with connect(**CONNECTION_ATTRS) as conn:\n\t        print_server_info(conn.get_dsn_parameters())\n\t        with conn.cursor() as tables_cur, conn.cursor() as partitions_cur:\n\t            tables_cur.execute(\"tables()\")\n\t            for table_row in tables_cur.fetchall():\n\t                print_table(table_row)\n\t                partitions_cur.execute(f\"table_partitions('{table_row[1]}')\")\n\t                for partition_row in partitions_cur.fetchall():\n", "                    print_partition(partition_row)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/examples/sqlalchemy_orm.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport datetime\n\timport json\n\timport os\n\timport time\n\tos.environ.setdefault(\"SQLALCHEMY_SILENCE_UBER_WARNING\", \"1\")\n\timport questdb_connect as qdbc\n\tfrom sqlalchemy import Column, MetaData, insert, text\n\tfrom sqlalchemy.orm import declarative_base\n", "from examples import CONNECTION_ATTRS\n\tBase = declarative_base(metadata=MetaData())\n\ttable_name = \"all_types\"\n\tclass MyTable(Base):\n\t    __tablename__ = table_name\n\t    __table_args__ = (\n\t        qdbc.QDBTableEngine(table_name, \"col_ts\", qdbc.PartitionBy.DAY, is_wal=True),\n\t    )\n\t    col_boolean = Column(qdbc.Boolean)\n\t    col_byte = Column(qdbc.Byte)\n", "    col_short = Column(qdbc.Short)\n\t    col_int = Column(qdbc.Int)\n\t    col_long = Column(qdbc.Long)\n\t    col_float = Column(qdbc.Float)\n\t    col_double = Column(qdbc.Double)\n\t    col_symbol = Column(qdbc.Symbol)\n\t    col_string = Column(qdbc.String)\n\t    col_char = Column(qdbc.Char)\n\t    col_uuid = Column(qdbc.UUID)\n\t    col_date = Column(qdbc.Date)\n", "    col_ts = Column(qdbc.Timestamp, primary_key=True)\n\t    col_geohash = Column(qdbc.GeohashInt)\n\t    col_long256 = Column(qdbc.Long256)\n\tdef main():\n\t    # obtain the engine, which we will dispose of at the end in the finally\n\t    engine = qdbc.create_engine(**CONNECTION_ATTRS)\n\t    try:\n\t        # delete any previous existing 'all_types' table\n\t        while True:\n\t            try:\n", "                Base.metadata.drop_all(engine)\n\t                break\n\t            except Exception as see:\n\t                if \"Connection refused\" in str(see.orig):\n\t                    print(f\"awaiting for QuestDB to start\")\n\t                    time.sleep(3)\n\t                else:\n\t                    raise see\n\t        # create the 'all_types' table\n\t        Base.metadata.create_all(engine)\n", "        # connect with QuestDB\n\t        with engine.connect() as conn:\n\t            # insert a fully populated row\n\t            now = datetime.datetime(2023, 4, 22, 18, 10, 10, 765123)\n\t            conn.execute(\n\t                insert(MyTable).values(\n\t                    col_boolean=True,\n\t                    col_byte=8,\n\t                    col_short=12,\n\t                    col_int=13,\n", "                    col_long=14,\n\t                    col_float=15.234,\n\t                    col_double=16.88993244,\n\t                    col_symbol=\"coconut\",\n\t                    col_string=\"banana\",\n\t                    col_char=\"C\",\n\t                    col_uuid=\"6d5eb038-63d1-4971-8484-30c16e13de5b\",\n\t                    col_date=now.date(),\n\t                    col_ts=now,\n\t                    col_geohash=\"dfvgsj2vptwu\",\n", "                    col_long256=\"0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a\",\n\t                )\n\t            )\n\t            columns = [col.name for col in MyTable.__table__.columns]\n\t            while True:\n\t                rs = conn.execute(text(\"all_types\"))\n\t                if rs.rowcount:\n\t                    print(f\"rows: {rs.rowcount}\")\n\t                    for row in rs:\n\t                        print(json.dumps(dict(zip(columns, map(str, row))), indent=4))\n", "                    break\n\t    finally:\n\t        if engine:\n\t            engine.dispose()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/questdb_connect/table_engine.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport sqlalchemy\n\tfrom .common import PartitionBy\n\tclass QDBTableEngine(\n\t    sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.visitors.Traversible\n\t):\n\t    def __init__(\n\t        self,\n\t        table_name: str,\n", "        ts_col_name: str,\n\t        partition_by: PartitionBy = PartitionBy.DAY,\n\t        is_wal: bool = True,\n\t    ):\n\t        sqlalchemy.sql.visitors.Traversible.__init__(self)\n\t        self.name = table_name\n\t        self.ts_col_name = ts_col_name\n\t        self.partition_by = partition_by\n\t        self.is_wal = is_wal\n\t        self.compiled = None\n", "    def get_table_suffix(self):\n\t        if self.compiled is None:\n\t            self.compiled = \"\"\n\t            has_ts = self.ts_col_name is not None\n\t            is_partitioned = self.partition_by and self.partition_by != PartitionBy.NONE\n\t            if has_ts:\n\t                self.compiled += f'TIMESTAMP(\"{self.ts_col_name}\")'\n\t            if is_partitioned:\n\t                if not has_ts:\n\t                    raise sqlalchemy.exc.ArgumentError(\n", "                        None,\n\t                        \"Designated timestamp must be specified for partitioned table\",\n\t                    )\n\t                self.compiled += f\" PARTITION BY {self.partition_by.name}\"\n\t            if self.is_wal:\n\t                if not is_partitioned:\n\t                    raise sqlalchemy.exc.ArgumentError(\n\t                        None, \"WAL table requires designated timestamp and partition by\"\n\t                    )\n\t                if self.is_wal:\n", "                    self.compiled += \" WAL\"\n\t                else:\n\t                    self.compiled += \" BYPASS WAL\"\n\t        return self.compiled\n\t    def _set_parent(self, parent, **_kwargs):\n\t        parent.engine = self\n"]}
{"filename": "src/questdb_connect/compilers.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport abc\n\timport sqlalchemy\n\tfrom .common import quote_identifier, remove_public_schema\n\tfrom .types import QDBTypeMixin\n\tclass QDBDDLCompiler(sqlalchemy.sql.compiler.DDLCompiler, abc.ABC):\n\t    def visit_create_schema(self, create, **kw):\n\t        raise Exception(\"QuestDB does not support SCHEMAS, there is only 'public'\")\n\t    def visit_drop_schema(self, drop, **kw):\n", "        raise Exception(\"QuestDB does not support SCHEMAS, there is only 'public'\")\n\t    def visit_create_table(self, create, **kw):\n\t        table = create.element\n\t        create_table = f\"CREATE TABLE {quote_identifier(table.fullname)} (\"\n\t        create_table += \", \".join(\n\t            [self.get_column_specification(c.element) for c in create.columns]\n\t        )\n\t        return create_table + \") \" + table.engine.get_table_suffix()\n\t    def get_column_specification(self, column: sqlalchemy.Column, **_):\n\t        if not isinstance(column.type, QDBTypeMixin):\n", "            raise sqlalchemy.exc.ArgumentError(\n\t                \"Column type is not a valid QuestDB type\"\n\t            )\n\t        return column.type.column_spec(column.name)\n\tclass QDBSQLCompiler(sqlalchemy.sql.compiler.SQLCompiler, abc.ABC):\n\t    def _is_safe_for_fast_insert_values_helper(self):\n\t        return True\n\t    def visit_textclause(self, textclause, add_to_result_map=None, **kw):\n\t        textclause.text = remove_public_schema(textclause.text)\n\t        return super().visit_textclause(textclause, add_to_result_map, **kw)\n"]}
{"filename": "src/questdb_connect/types.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport enum\n\timport sqlalchemy\n\tfrom .common import quote_identifier\n\t_GEOHASH_BYTE_MAX = 8\n\t_GEOHASH_SHORT_MAX = 16\n\t_GEOHASH_INT_MAX = 32\n\t_GEOHASH_LONG_BITS = 60\n\t_TYPE_CACHE = {\n", "    # key:   '__visit_name__' of the implementor of QDBTypeMixin\n\t    # value: implementor class itself\n\t}\n\tdef geohash_type_name(bits):\n\t    if not isinstance(bits, int) or bits < 0 or bits > _GEOHASH_LONG_BITS:\n\t        raise sqlalchemy.exc.ArgumentError(\n\t            f\"geohash precision must be int [0, {_GEOHASH_LONG_BITS}]\"\n\t        )\n\t    if 0 < bits <= _GEOHASH_BYTE_MAX:\n\t        return f\"GEOHASH(8b)\"\n", "    elif _GEOHASH_BYTE_MAX < bits <= _GEOHASH_SHORT_MAX:\n\t        return \"GEOHASH(3c)\"\n\t    elif _GEOHASH_SHORT_MAX < bits <= _GEOHASH_INT_MAX:\n\t        return \"GEOHASH(6c)\"\n\t    return f\"GEOHASH(12c)\"\n\tdef geohash_class(bits):\n\t    if not isinstance(bits, int) or bits < 0 or bits > _GEOHASH_LONG_BITS:\n\t        raise sqlalchemy.exc.ArgumentError(\n\t            f\"geohash precision must be int [0, {_GEOHASH_LONG_BITS}]\"\n\t        )\n", "    if 0 < bits <= _GEOHASH_BYTE_MAX:\n\t        return GeohashByte\n\t    elif _GEOHASH_BYTE_MAX < bits <= _GEOHASH_SHORT_MAX:\n\t        return GeohashShort\n\t    elif _GEOHASH_SHORT_MAX < bits <= _GEOHASH_INT_MAX:\n\t        return GeohashInt\n\t    return GeohashLong\n\tclass QDBTypeMixin(sqlalchemy.types.TypeDecorator):\n\t    __visit_name__ = \"QDBTypeMixin\"\n\t    impl = sqlalchemy.types.String\n", "    cache_ok = True\n\t    @classmethod\n\t    def matches_type_name(cls, type_name):\n\t        return cls if type_name == cls.__visit_name__ else None\n\t    def column_spec(self, column_name):\n\t        return f\"{quote_identifier(column_name)} {self.__visit_name__}\"\n\t    def compile(self, dialect=None):\n\t        return self.__visit_name__\n\tclass Boolean(QDBTypeMixin):\n\t    __visit_name__ = \"BOOLEAN\"\n", "    impl = sqlalchemy.types.Boolean\n\t    type_code = 1\n\tclass Byte(QDBTypeMixin):\n\t    __visit_name__ = \"BYTE\"\n\t    impl = sqlalchemy.types.Integer\n\t    type_code = 2\n\tclass Short(QDBTypeMixin):\n\t    __visit_name__ = \"SHORT\"\n\t    type_code = 3\n\t    impl = sqlalchemy.types.Integer\n", "class Char(QDBTypeMixin):\n\t    __visit_name__ = \"CHAR\"\n\t    type_code = 4\n\tclass Int(QDBTypeMixin):\n\t    __visit_name__ = \"INT\"\n\t    type_code = 5\n\t    impl = sqlalchemy.types.Integer\n\tclass Long(QDBTypeMixin):\n\t    __visit_name__ = \"LONG\"\n\t    type_code = 6\n", "    impl = sqlalchemy.types.Integer\n\tclass Date(QDBTypeMixin):\n\t    __visit_name__ = \"DATE\"\n\t    type_code = 7\n\t    impl = sqlalchemy.types.Date\n\tclass Timestamp(QDBTypeMixin):\n\t    __visit_name__ = \"TIMESTAMP\"\n\t    type_code = 8\n\t    impl = sqlalchemy.types.DateTime\n\tclass Float(QDBTypeMixin):\n", "    __visit_name__ = \"FLOAT\"\n\t    type_code = 9\n\t    impl = sqlalchemy.types.Float\n\tclass Double(QDBTypeMixin):\n\t    __visit_name__ = \"DOUBLE\"\n\t    type_code = 10\n\t    impl = sqlalchemy.types.Float\n\tclass String(QDBTypeMixin):\n\t    __visit_name__ = \"STRING\"\n\t    type_code = 11\n", "class Symbol(QDBTypeMixin):\n\t    __visit_name__ = \"SYMBOL\"\n\t    type_code = 12\n\tclass Long256(QDBTypeMixin):\n\t    __visit_name__ = \"LONG256\"\n\t    type_code = 13\n\tclass GeohashByte(QDBTypeMixin):\n\t    __visit_name__ = geohash_type_name(8)\n\t    type_code = 14\n\tclass GeohashShort(QDBTypeMixin):\n", "    __visit_name__ = geohash_type_name(16)\n\t    type_code = 15\n\tclass GeohashInt(QDBTypeMixin):\n\t    __visit_name__ = geohash_type_name(32)\n\t    type_code = 16\n\tclass GeohashLong(QDBTypeMixin):\n\t    __visit_name__ = geohash_type_name(60)\n\t    type_code = 17\n\tclass UUID(QDBTypeMixin):\n\t    __visit_name__ = \"UUID\"\n", "    type_code = 19\n\tQUESTDB_TYPES = [\n\t    Long256,\n\t    Boolean,\n\t    Byte,\n\t    Short,\n\t    Char,\n\t    Int,\n\t    Long,\n\t    UUID,\n", "    Float,\n\t    Double,\n\t    Date,\n\t    Timestamp,\n\t    Symbol,\n\t    String,\n\t    GeohashByte,\n\t    GeohashInt,\n\t    GeohashShort,\n\t    GeohashLong,\n", "]\n\tdef resolve_type_from_name(type_name):\n\t    if not type_name:\n\t        return None\n\t    type_class = _TYPE_CACHE.get(type_name)\n\t    if not type_class:\n\t        for candidate_class in QUESTDB_TYPES:\n\t            type_class = candidate_class.matches_type_name(type_name)\n\t            if type_class:\n\t                _TYPE_CACHE[type_name] = type_class\n", "                break\n\t            elif (\n\t                \"GEOHASH\" in type_name.upper() and \"(\" in type_name and \")\" in type_name\n\t            ):\n\t                open_p = type_name.index(\"(\")\n\t                close_p = type_name.index(\")\")\n\t                description = type_name[open_p + 1 : close_p]\n\t                g_size = int(description[:-1])\n\t                if description[-1] in (\"C\", \"c\"):\n\t                    g_size *= 5\n", "                type_class = geohash_class(g_size)\n\t                break\n\t    return type_class\n"]}
{"filename": "src/questdb_connect/keywords_functions.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\tdef get_keywords_list(conn=None):\n\t    return __initialize_list(\n\t        conn, \"SELECT keyword FROM keywords()\", __keywords, __default_keywords\n\t    )\n\tdef get_functions_list(conn=None):\n\t    return __initialize_list(\n\t        conn, \"SELECT name FROM functions()\", __func_names, __default_func_names\n\t    )\n", "def __initialize_list(conn, sql_stmt, target_list, default_target_list):\n\t    if not target_list:\n\t        try:\n\t            with conn.cursor() as functions_cur:\n\t                functions_cur.execute(sql_stmt)\n\t                for func_row in functions_cur.fetchall():\n\t                    target_list.append(func_row[0])\n\t        except Exception as _ignore:\n\t            target_list.extend(default_target_list)\n\t    return target_list\n", "__func_names = []\n\t__default_func_names = [\n\t    \"abs\",\n\t    \"acos\",\n\t    \"all_tables\",\n\t    \"and\",\n\t    \"asin\",\n\t    \"atan\",\n\t    \"atan2\",\n\t    \"avg\",\n", "    \"base64\",\n\t    \"between\",\n\t    \"build\",\n\t    \"case\",\n\t    \"cast\",\n\t    \"ceil\",\n\t    \"ceiling\",\n\t    \"coalesce\",\n\t    \"concat\",\n\t    \"cos\",\n", "    \"cot\",\n\t    \"count\",\n\t    \"count_distinct\",\n\t    \"current_database\",\n\t    \"current_schema\",\n\t    \"current_schemas\",\n\t    \"current_user\",\n\t    \"date_trunc\",\n\t    \"dateadd\",\n\t    \"datediff\",\n", "    \"day\",\n\t    \"day_of_week\",\n\t    \"day_of_week_sunday_first\",\n\t    \"days_in_month\",\n\t    \"degrees\",\n\t    \"dump_memory_usage\",\n\t    \"dump_thread_stacks\",\n\t    \"extract\",\n\t    \"first\",\n\t    \"floor\",\n", "    \"flush_query_cache\",\n\t    \"format_type\",\n\t    \"haversine_dist_deg\",\n\t    \"hour\",\n\t    \"ilike\",\n\t    \"information_schema._pg_expandarray\",\n\t    \"isOrdered\",\n\t    \"is_leap_year\",\n\t    \"ksum\",\n\t    \"last\",\n", "    \"left\",\n\t    \"length\",\n\t    \"like\",\n\t    \"list\",\n\t    \"log\",\n\t    \"long_sequence\",\n\t    \"lower\",\n\t    \"lpad\",\n\t    \"ltrim\",\n\t    \"make_geohash\",\n", "    \"max\",\n\t    \"memory_metrics\",\n\t    \"micros\",\n\t    \"millis\",\n\t    \"min\",\n\t    \"minute\",\n\t    \"month\",\n\t    \"not\",\n\t    \"now\",\n\t    \"nsum\",\n", "    \"nullif\",\n\t    \"pg_advisory_unlock_all\",\n\t    \"pg_attrdef\",\n\t    \"pg_attribute\",\n\t    \"pg_catalog.age\",\n\t    \"pg_catalog.current_database\",\n\t    \"pg_catalog.current_schema\",\n\t    \"pg_catalog.current_schemas\",\n\t    \"pg_catalog.pg_attrdef\",\n\t    \"pg_catalog.pg_attribute\",\n", "    \"pg_catalog.pg_class\",\n\t    \"pg_catalog.pg_database\",\n\t    \"pg_catalog.pg_description\",\n\t    \"pg_catalog.pg_get_expr\",\n\t    \"pg_catalog.pg_get_keywords\",\n\t    \"pg_catalog.pg_get_partkeydef\",\n\t    \"pg_catalog.pg_get_userbyid\",\n\t    \"pg_catalog.pg_index\",\n\t    \"pg_catalog.pg_inherits\",\n\t    \"pg_catalog.pg_is_in_recovery\",\n", "    \"pg_catalog.pg_locks\",\n\t    \"pg_catalog.pg_namespace\",\n\t    \"pg_catalog.pg_roles\",\n\t    \"pg_catalog.pg_shdescription\",\n\t    \"pg_catalog.pg_table_is_visible\",\n\t    \"pg_catalog.pg_type\",\n\t    \"pg_catalog.txid_current\",\n\t    \"pg_catalog.version\",\n\t    \"pg_class\",\n\t    \"pg_database\",\n", "    \"pg_description\",\n\t    \"pg_get_expr\",\n\t    \"pg_get_keywords\",\n\t    \"pg_get_partkeydef\",\n\t    \"pg_index\",\n\t    \"pg_inherits\",\n\t    \"pg_is_in_recovery\",\n\t    \"pg_locks\",\n\t    \"pg_namespace\",\n\t    \"pg_postmaster_start_time\",\n", "    \"pg_proc\",\n\t    \"pg_range\",\n\t    \"pg_roles\",\n\t    \"pg_type\",\n\t    \"position\",\n\t    \"power\",\n\t    \"radians\",\n\t    \"reader_pool\",\n\t    \"regexp_replace\",\n\t    \"replace\",\n", "    \"right\",\n\t    \"rnd_bin\",\n\t    \"rnd_boolean\",\n\t    \"rnd_byte\",\n\t    \"rnd_char\",\n\t    \"rnd_date\",\n\t    \"rnd_double\",\n\t    \"rnd_float\",\n\t    \"rnd_geohash\",\n\t    \"rnd_int\",\n", "    \"rnd_log\",\n\t    \"rnd_long\",\n\t    \"rnd_long256\",\n\t    \"rnd_short\",\n\t    \"rnd_str\",\n\t    \"rnd_symbol\",\n\t    \"rnd_timestamp\",\n\t    \"rnd_uuid4\",\n\t    \"round\",\n\t    \"round_down\",\n", "    \"round_half_even\",\n\t    \"round_up\",\n\t    \"row_number\",\n\t    \"rpad\",\n\t    \"rtrim\",\n\t    \"second\",\n\t    \"session_user\",\n\t    \"simulate_crash\",\n\t    \"sin\",\n\t    \"size_pretty\",\n", "    \"split_part\",\n\t    \"sqrt\",\n\t    \"starts_with\",\n\t    \"stddev_samp\",\n\t    \"string_agg\",\n\t    \"strpos\",\n\t    \"substring\",\n\t    \"sum\",\n\t    \"switch\",\n\t    \"sysdate\",\n", "    \"systimestamp\",\n\t    \"table_columns\",\n\t    \"table_partitions\",\n\t    \"table_writer_metrics\",\n\t    \"tables\",\n\t    \"tan\",\n\t    \"timestamp_ceil\",\n\t    \"timestamp_floor\",\n\t    \"timestamp_sequence\",\n\t    \"timestamp_shuffle\",\n", "    \"to_char\",\n\t    \"to_date\",\n\t    \"to_long128\",\n\t    \"to_lowercase\",\n\t    \"to_pg_date\",\n\t    \"to_str\",\n\t    \"to_timestamp\",\n\t    \"to_timezone\",\n\t    \"to_uppercase\",\n\t    \"to_utc\",\n", "    \"touch\",\n\t    \"trim\",\n\t    \"txid_current\",\n\t    \"typeOf\",\n\t    \"upper\",\n\t    \"version\",\n\t    \"wal_tables\",\n\t    \"week_of_year\",\n\t    \"year\",\n\t]\n", "__keywords = []\n\t__default_keywords = [\n\t    \"add\",\n\t    \"all\",\n\t    \"alter\",\n\t    \"and\",\n\t    \"as\",\n\t    \"asc\",\n\t    \"asof\",\n\t    \"backup\",\n", "    \"between\",\n\t    \"by\",\n\t    \"cache\",\n\t    \"capacity\",\n\t    \"case\",\n\t    \"cast\",\n\t    \"column\",\n\t    \"columns\",\n\t    \"copy\",\n\t    \"create\",\n", "    \"cross\",\n\t    \"database\",\n\t    \"default\",\n\t    \"delete\",\n\t    \"desc\",\n\t    \"distinct\",\n\t    \"drop\",\n\t    \"else\",\n\t    \"end\",\n\t    \"except\",\n", "    \"exists\",\n\t    \"fill\",\n\t    \"foreign\",\n\t    \"from\",\n\t    \"grant\",\n\t    \"group\",\n\t    \"header\",\n\t    \"if\",\n\t    \"in\",\n\t    \"index\",\n", "    \"inner\",\n\t    \"insert\",\n\t    \"intersect\",\n\t    \"into\",\n\t    \"isolation\",\n\t    \"join\",\n\t    \"key\",\n\t    \"latest\",\n\t    \"limit\",\n\t    \"lock\",\n", "    \"lt\",\n\t    \"nan\",\n\t    \"natural\",\n\t    \"nocache\",\n\t    \"none\",\n\t    \"not\",\n\t    \"null\",\n\t    \"on\",\n\t    \"only\",\n\t    \"or\",\n", "    \"order\",\n\t    \"outer\",\n\t    \"over\",\n\t    \"partition\",\n\t    \"primary\",\n\t    \"references\",\n\t    \"rename\",\n\t    \"repair\",\n\t    \"right\",\n\t    \"sample\",\n", "    \"select\",\n\t    \"show\",\n\t    \"splice\",\n\t    \"system\",\n\t    \"table\",\n\t    \"tables\",\n\t    \"then\",\n\t    \"to\",\n\t    \"transaction\",\n\t    \"truncate\",\n", "    \"type\",\n\t    \"union\",\n\t    \"unlock\",\n\t    \"update\",\n\t    \"values\",\n\t    \"when\",\n\t    \"where\",\n\t    \"with\",\n\t    \"writer\",\n\t]\n"]}
{"filename": "src/questdb_connect/identifier_preparer.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport abc\n\timport sqlalchemy\n\tfrom .common import quote_identifier\n\tdef _none(_ignore):\n\t    return None\n\t_special_chars = {\n\t    \"(\",\n\t    \")\",\n", "    \"[\",\n\t    \"[]\",\n\t    \"{\",\n\t    \"}\",\n\t    \"'\",\n\t    '\"',\n\t    \":\",\n\t    \";\",\n\t    \".\",\n\t    \"!\",\n", "    \"%\",\n\t    \"&\",\n\t    \"*\",\n\t    \"$\",\n\t    \"@\",\n\t    \"~\",\n\t    \"^\",\n\t    \"-\",\n\t    \"?\",\n\t    \"/\",\n", "    \"\\\\\",\n\t    \" \",\n\t    \"\\t\",\n\t    \"\\r\",\n\t    \"\\n\",\n\t}\n\tdef _has_special_char(_value):\n\t    for candidate in _value:\n\t        if candidate in _special_chars:\n\t            return True\n", "    return False\n\tclass QDBIdentifierPreparer(sqlalchemy.sql.compiler.IdentifierPreparer, abc.ABC):\n\t    schema_for_object = staticmethod(_none)\n\t    def __init__(\n\t        self,\n\t        dialect,\n\t        initial_quote='\"',\n\t        final_quote=None,\n\t        escape_quote='\"',\n\t        quote_case_sensitive_collations=False,\n", "        omit_schema=True,\n\t    ):\n\t        super().__init__(\n\t            dialect=dialect,\n\t            initial_quote=initial_quote,\n\t            final_quote=final_quote,\n\t            escape_quote=escape_quote,\n\t            quote_case_sensitive_collations=quote_case_sensitive_collations,\n\t            omit_schema=omit_schema,\n\t        )\n", "    def quote_identifier(self, value):\n\t        return quote_identifier(value)\n\t    def _requires_quotes(self, _value):\n\t        return _value and _has_special_char(_value)\n\t    def format_schema(self, name):\n\t        \"\"\"Prepare a quoted schema name.\"\"\"\n\t        return \"\"\n\t    def format_table(self, table, use_schema=True, name=None):\n\t        \"\"\"Prepare a quoted table and schema name.\"\"\"\n\t        return quote_identifier(name if name else table.name)\n"]}
{"filename": "src/questdb_connect/dialect.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport abc\n\timport sqlalchemy\n\tfrom sqlalchemy.dialects.postgresql.psycopg2 import PGDialect_psycopg2\n\tfrom sqlalchemy.sql.compiler import GenericTypeCompiler\n\tfrom .compilers import QDBDDLCompiler, QDBSQLCompiler\n\tfrom .identifier_preparer import QDBIdentifierPreparer\n\tfrom .inspector import QDBInspector\n\t# ===== SQLAlchemy Dialect ======\n", "# https://docs.sqlalchemy.org/en/14/ apache-superset requires SQLAlchemy 1.4\n\tdef connection_uri(\n\t    host: str, port: str, username: str, password: str, database: str = \"main\"\n\t):\n\t    return f\"questdb://{username}:{password}@{host}:{port}/{database}\"\n\tdef create_engine(\n\t    host: str, port: int, username: str, password: str, database: str = \"main\"\n\t):\n\t    return sqlalchemy.create_engine(\n\t        connection_uri(host, port, username, password, database),\n", "        future=False,\n\t        hide_parameters=False,\n\t        implicit_returning=False,\n\t        isolation_level=\"REPEATABLE READ\",\n\t    )\n\tclass QuestDBDialect(PGDialect_psycopg2, abc.ABC):\n\t    name = \"questdb\"\n\t    psycopg2_version = (2, 9)\n\t    default_schema_name = \"public\"\n\t    statement_compiler = QDBSQLCompiler\n", "    ddl_compiler = QDBDDLCompiler\n\t    type_compiler = GenericTypeCompiler\n\t    inspector = QDBInspector\n\t    preparer = QDBIdentifierPreparer\n\t    supports_schemas = False\n\t    supports_statement_cache = False\n\t    supports_server_side_cursors = False\n\t    supports_native_boolean = True\n\t    supports_views = False\n\t    supports_empty_insert = False\n", "    supports_multivalues_insert = True\n\t    supports_comments = True\n\t    inline_comments = False\n\t    postfetch_lastrowid = False\n\t    non_native_boolean_check_constraint = False\n\t    max_identifier_length = 255\n\t    _user_defined_max_identifier_length = 255\n\t    _has_native_hstore = False\n\t    supports_is_distinct_from = False\n\t    @classmethod\n", "    def dbapi(cls):\n\t        import questdb_connect as dbapi\n\t        return dbapi\n\t    def get_schema_names(self, conn, **kw):\n\t        return [\"public\"]\n\t    def get_table_names(self, conn, schema=None, **kw):\n\t        return [row.table for row in self._exec(conn, \"SHOW TABLES\")]\n\t    def has_table(self, conn, table_name, schema=None):\n\t        return self._exec(conn, f\"tables() WHERE name='{table_name}'\").rowcount == 1\n\t    @sqlalchemy.engine.reflection.cache\n", "    def get_columns(self, conn, table_name, schema=None, **kw):\n\t        return self.inspector.format_table_columns(\n\t            table_name, self._exec(conn, f\"table_columns('{table_name}')\")\n\t        )\n\t    def get_pk_constraint(self, conn, table_name, schema=None, **kw):\n\t        return []\n\t    def get_foreign_keys(\n\t        self,\n\t        conn,\n\t        table_name,\n", "        schema=None,\n\t        postgresql_ignore_search_path=False,\n\t        **kw,\n\t    ):\n\t        return []\n\t    def get_temp_table_names(self, conn, **kw):\n\t        return []\n\t    def get_view_names(self, conn, schema=None, **kw):\n\t        return []\n\t    def get_temp_view_names(self, conn, schema=None, **kw):\n", "        return []\n\t    def get_view_definition(self, conn, view_name, schema=None, **kw):\n\t        pass\n\t    def get_indexes(self, conn, table_name, schema=None, **kw):\n\t        return []\n\t    def get_unique_constraints(self, conn, table_name, schema=None, **kw):\n\t        return []\n\t    def get_check_constraints(self, conn, table_name, schema=None, **kw):\n\t        return []\n\t    def has_sequence(self, conn, sequence_name, schema=None, **_kw):\n", "        return False\n\t    def do_begin_twophase(self, conn, xid):\n\t        raise NotImplementedError\n\t    def do_prepare_twophase(self, conn, xid):\n\t        raise NotImplementedError\n\t    def do_rollback_twophase(self, conn, xid, is_prepared=True, recover=False):\n\t        raise NotImplementedError\n\t    def do_commit_twophase(self, conn, xid, is_prepared=True, recover=False):\n\t        raise NotImplementedError\n\t    def do_recover_twophase(self, conn):\n", "        raise NotImplementedError\n\t    def set_isolation_level(self, dbapi_conn, level):\n\t        pass\n\t    def get_isolation_level(self, dbapi_conn):\n\t        return None\n\t    def _exec(self, conn, sql_query):\n\t        return conn.execute(sqlalchemy.text(sql_query))\n"]}
{"filename": "src/questdb_connect/__init__.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport os\n\timport time\n\timport psycopg2\n\tfrom questdb_connect.common import PartitionBy, remove_public_schema\n\tfrom questdb_connect.compilers import QDBDDLCompiler, QDBSQLCompiler\n\tfrom questdb_connect.dialect import QuestDBDialect, connection_uri, create_engine\n\tfrom questdb_connect.identifier_preparer import QDBIdentifierPreparer\n\tfrom questdb_connect.inspector import QDBInspector\n", "from questdb_connect.keywords_functions import get_functions_list, get_keywords_list\n\tfrom questdb_connect.table_engine import QDBTableEngine\n\tfrom questdb_connect.types import (\n\t    QUESTDB_TYPES,\n\t    UUID,\n\t    Boolean,\n\t    Byte,\n\t    Char,\n\t    Date,\n\t    Double,\n", "    Float,\n\t    GeohashByte,\n\t    GeohashInt,\n\t    GeohashLong,\n\t    GeohashShort,\n\t    Int,\n\t    Long,\n\t    Long256,\n\t    QDBTypeMixin,\n\t    Short,\n", "    String,\n\t    Symbol,\n\t    Timestamp,\n\t    geohash_class,\n\t    geohash_type_name,\n\t    resolve_type_from_name,\n\t)\n\t# QuestDB timestamps: https://questdb.io/docs/guides/working-with-timestamps-timezones/\n\t# The native timestamp format used by QuestDB is a Unix timestamp in microsecond resolution.\n\t# Although timestamps in nanoseconds will be parsed, the output will be truncated to\n", "# microseconds. QuestDB does not store time zone information alongside timestamp values\n\t# and therefore it should be assumed that all timestamps are in UTC.\n\tos.environ[\"TZ\"] = \"UTC\"\n\ttime.tzset()\n\t# ===== DBAPI =====\n\t# https://peps.python.org/pep-0249/\n\tapilevel = \"2.0\"\n\tthreadsafety = 2\n\tparamstyle = \"pyformat\"\n\tclass Error(Exception):\n", "    pass\n\tclass Cursor(psycopg2.extensions.cursor):\n\t    def execute(self, query, vars=None):\n\t        \"\"\"execute(query, vars=None) -- Execute query with bound vars.\"\"\"\n\t        return super().execute(remove_public_schema(query), vars)\n\tdef cursor_factory(*args, **kwargs):\n\t    return Cursor(*args, **kwargs)\n\tdef connect(**kwargs):\n\t    host = kwargs.get(\"host\") or \"127.0.0.1\"\n\t    port = kwargs.get(\"port\") or 8812\n", "    user = kwargs.get(\"username\") or \"admin\"\n\t    password = kwargs.get(\"password\") or \"quest\"\n\t    database = kwargs.get(\"database\") or \"main\"\n\t    conn = psycopg2.connect(\n\t        cursor_factory=cursor_factory,\n\t        host=host,\n\t        port=port,\n\t        user=user,\n\t        password=password,\n\t        database=database,\n", "    )\n\t    # retrieve and cache function names and keywords lists\n\t    get_keywords_list(conn)\n\t    get_functions_list(conn)\n\t    return conn\n"]}
{"filename": "src/questdb_connect/common.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport enum\n\timport re\n\tclass PartitionBy(enum.Enum):\n\t    DAY = 0\n\t    MONTH = 1\n\t    YEAR = 2\n\t    NONE = 3\n\t    HOUR = 4\n", "    WEEK = 5\n\tdef remove_public_schema(query):\n\t    if query and isinstance(query, str) and \"public\" in query:\n\t        return re.sub(_PUBLIC_SCHEMA_FILTER, \"\", query)\n\t    return query\n\tdef quote_identifier(identifier: str):\n\t    if not identifier:\n\t        return None\n\t    first = 0\n\t    last = len(identifier)\n", "    if identifier[first] in _QUOTES:\n\t        first += 1\n\t    if identifier[last - 1] in _QUOTES:\n\t        last -= 1\n\t    return f'\"{identifier[first:last]}\"'\n\t_PUBLIC_SCHEMA_FILTER = re.compile(\n\t    r\"(')?(public(?(1)\\1|)\\.)\", re.IGNORECASE | re.MULTILINE\n\t)\n\t_QUOTES = (\"'\", '\"')\n"]}
{"filename": "src/questdb_connect/inspector.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\timport abc\n\timport sqlalchemy\n\tfrom .common import PartitionBy\n\tfrom .table_engine import QDBTableEngine\n\tfrom .types import resolve_type_from_name\n\tclass QDBInspector(sqlalchemy.engine.reflection.Inspector, abc.ABC):\n\t    def reflecttable(\n\t        self,\n", "        table,\n\t        include_columns,\n\t        exclude_columns=(),\n\t        resolve_fks=True,\n\t        _extend_on=None,\n\t    ):\n\t        # backward compatibility SQLAlchemy 1.3\n\t        return self.reflect_table(\n\t            table, include_columns, exclude_columns, resolve_fks, _extend_on\n\t        )\n", "    def reflect_table(\n\t        self,\n\t        table,\n\t        include_columns=None,\n\t        exclude_columns=None,\n\t        resolve_fks=False,\n\t        _extend_on=None,\n\t    ):\n\t        table_name = table.name\n\t        result_set = self.bind.execute(f\"tables() WHERE name = '{table_name}'\")\n", "        if not result_set:\n\t            self._panic_table(table_name)\n\t        table_attrs = result_set.first()\n\t        if table_attrs:\n\t            col_ts_name = table_attrs[\"designatedTimestamp\"]\n\t            partition_by = PartitionBy[table_attrs[\"partitionBy\"]]\n\t            is_wal = True if table_attrs[\"walEnabled\"] else False\n\t        else:\n\t            col_ts_name = None\n\t            partition_by = PartitionBy.NONE\n", "            is_wal = True\n\t        for row in self.bind.execute(f\"table_columns('{table_name}')\"):\n\t            col_name = row[0]\n\t            if include_columns and col_name not in include_columns:\n\t                continue\n\t            if exclude_columns and col_name in exclude_columns:\n\t                continue\n\t            col_type = resolve_type_from_name(row[1])\n\t            if col_ts_name and col_ts_name.upper() == col_name.upper():\n\t                table.append_column(\n", "                    sqlalchemy.Column(col_name, col_type, primary_key=True)\n\t                )\n\t            else:\n\t                table.append_column(sqlalchemy.Column(col_name, col_type))\n\t        table.engine = QDBTableEngine(table_name, col_ts_name, partition_by, is_wal)\n\t        table.metadata = sqlalchemy.MetaData()\n\t    def get_columns(self, table_name, schema=None, **kw):\n\t        result_set = self.bind.execute(f\"table_columns('{table_name}')\")\n\t        return self.format_table_columns(table_name, result_set)\n\t    def get_schema_names(self):\n", "        return [\"public\"]\n\t    def format_table_columns(self, table_name, result_set):\n\t        if not result_set:\n\t            self._panic_table(table_name)\n\t        return [\n\t            {\n\t                \"name\": row[0],\n\t                \"type\": resolve_type_from_name(row[1])(),\n\t                \"nullable\": True,\n\t                \"autoincrement\": False,\n", "            }\n\t            for row in result_set\n\t        ]\n\t    def _panic_table(self, table_name):\n\t        raise sqlalchemy.orm.exc.NoResultFound(f\"Table '{table_name}' does not exist\")\n"]}
{"filename": "src/qdb_superset/__init__.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n"]}
{"filename": "src/qdb_superset/db_engine_specs/__init__.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n"]}
{"filename": "src/qdb_superset/db_engine_specs/questdb.py", "chunked_list": ["#\n\t#     ___                  _   ____  ____\n\t#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n\t#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n\t#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n\t#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n\t#\n\t#  Copyright (c) 2014-2019 Appsicle\n\t#  Copyright (c) 2019-2023 QuestDB\n\t#\n", "#  Licensed under the Apache License, Version 2.0 (the \"License\");\n\t#  you may not use this file except in compliance with the License.\n\t#  You may obtain a copy of the License at\n\t#\n\t#  http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t#  Unless required by applicable law or agreed to in writing, software\n\t#  distributed under the License is distributed on an \"AS IS\" BASIS,\n\t#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t#  See the License for the specific language governing permissions and\n", "#  limitations under the License.\n\t#\n\tfrom __future__ import annotations\n\timport re\n\tfrom datetime import datetime\n\tfrom typing import Any\n\timport questdb_connect.types as qdbc_types\n\tfrom flask_babel import gettext as __\n\tfrom marshmallow import fields, Schema\n\tfrom questdb_connect.common import remove_public_schema\n", "from sqlalchemy.engine.base import Engine\n\tfrom sqlalchemy.engine.reflection import Inspector\n\tfrom sqlalchemy.sql.expression import text, TextClause\n\tfrom sqlalchemy.types import TypeEngine\n\tfrom superset.db_engine_specs.base import (\n\t    BaseEngineSpec,\n\t    BasicParametersMixin,\n\t    BasicParametersType,\n\t)\n\tfrom superset.utils import core as utils\n", "from superset.utils.core import GenericDataType\n\tclass QuestDbParametersSchema(Schema):\n\t    username = fields.String(\n\t        description=__(\"username\"),\n\t        dump_default=\"admin\",\n\t        load_default=\"admin\",\n\t    )\n\t    password = fields.String(\n\t        description=__(\"password\"),\n\t        dump_default=\"quest\",\n", "        load_default=\"quest\",\n\t    )\n\t    host = fields.String(\n\t        description=__(\"host\"),\n\t        dump_default=\"host.docker.internal\",\n\t        load_default=\"host.docker.internal\",\n\t    )\n\t    port = fields.Integer(\n\t        description=__(\"port\"),\n\t        dump_default=\"8812\",\n", "        load_default=\"8812\",\n\t    )\n\t    database = fields.String(\n\t        description=__(\"database\"),\n\t        dump_default=\"main\",\n\t        load_default=\"main\",\n\t    )\n\tclass QuestDbEngineSpec(BaseEngineSpec, BasicParametersMixin):\n\t    engine = \"questdb\"\n\t    engine_name = \"QuestDB\"\n", "    default_driver = \"psycopg2\"\n\t    encryption_parameters = {\"sslmode\": \"prefer\"}\n\t    sqlalchemy_uri_placeholder = \"questdb://username:password@host:port/database\"\n\t    parameters_schema = QuestDbParametersSchema()\n\t    time_groupby_inline = False\n\t    allows_hidden_cc_in_orderby = True\n\t    time_secondary_columns = True\n\t    try_remove_schema_from_table_name = True\n\t    max_column_name_length = 120\n\t    supports_dynamic_schema = False\n", "    top_keywords: set[str] = set({})\n\t    # https://en.wikipedia.org/wiki/ISO_8601#Durations\n\t    # https://questdb.io/docs/reference/function/date-time/#date_trunc\n\t    _time_grain_expressions = {\n\t        None: \"{col}\",\n\t        \"PT1S\": \"DATE_TRUNC('second', {col})\",\n\t        \"PT1M\": \"DATE_TRUNC('minute', {col})\",\n\t        \"PT1H\": \"DATE_TRUNC('hour', {col})\",\n\t        \"P1D\": \"DATE_TRUNC('day', {col})\",\n\t        \"P1W\": \"DATE_TRUNC('week', {col})\",\n", "        \"P1M\": \"DATE_TRUNC('month', {col})\",\n\t        \"P1Y\": \"DATE_TRUNC('year', {col})\",\n\t        \"P3M\": \"DATE_TRUNC('quarter', {col})\",\n\t    }\n\t    column_type_mappings = (\n\t        (\n\t            re.compile(\"^LONG256\", re.IGNORECASE),\n\t            qdbc_types.Long256,\n\t            GenericDataType.STRING,\n\t        ),\n", "        (\n\t            re.compile(\"^BOOLEAN\", re.IGNORECASE),\n\t            qdbc_types.Boolean,\n\t            GenericDataType.BOOLEAN,\n\t        ),\n\t        (\n\t            re.compile(\"^BYTE\", re.IGNORECASE),\n\t            qdbc_types.Byte,\n\t            GenericDataType.NUMERIC,\n\t        ),\n", "        (\n\t            re.compile(\"^SHORT\", re.IGNORECASE),\n\t            qdbc_types.Short,\n\t            GenericDataType.NUMERIC,\n\t        ),\n\t        (re.compile(\"^INT\", re.IGNORECASE), qdbc_types.Int, GenericDataType.NUMERIC),\n\t        (\n\t            re.compile(\"^LONG\", re.IGNORECASE),\n\t            qdbc_types.Long,\n\t            GenericDataType.NUMERIC,\n", "        ),\n\t        (\n\t            re.compile(\"^FLOAT\", re.IGNORECASE),\n\t            qdbc_types.Float,\n\t            GenericDataType.NUMERIC,\n\t        ),\n\t        (\n\t            re.compile(\"^DOUBLE'\", re.IGNORECASE),\n\t            qdbc_types.Double,\n\t            GenericDataType.NUMERIC,\n", "        ),\n\t        (\n\t            re.compile(\"^SYMBOL\", re.IGNORECASE),\n\t            qdbc_types.Symbol,\n\t            GenericDataType.STRING,\n\t        ),\n\t        (\n\t            re.compile(\"^STRING\", re.IGNORECASE),\n\t            qdbc_types.String,\n\t            GenericDataType.STRING,\n", "        ),\n\t        (\n\t            re.compile(\"^UUID\", re.IGNORECASE),\n\t            qdbc_types.UUID,\n\t            GenericDataType.STRING,\n\t        ),\n\t        (\n\t            re.compile(\"^CHAR\", re.IGNORECASE),\n\t            qdbc_types.Char,\n\t            GenericDataType.STRING,\n", "        ),\n\t        (\n\t            re.compile(\"^TIMESTAMP\", re.IGNORECASE),\n\t            qdbc_types.Timestamp,\n\t            GenericDataType.TEMPORAL,\n\t        ),\n\t        (\n\t            re.compile(\"^DATE\", re.IGNORECASE),\n\t            qdbc_types.Date,\n\t            GenericDataType.TEMPORAL,\n", "        ),\n\t        (\n\t            re.compile(r\"^GEOHASH\\(\\d+[b|c]\\)\", re.IGNORECASE),\n\t            qdbc_types.GeohashLong,\n\t            GenericDataType.STRING,\n\t        ),\n\t    )\n\t    @classmethod\n\t    def build_sqlalchemy_uri(\n\t        cls,\n", "        parameters: BasicParametersType,\n\t        encrypted_extra: dict[str, str] | None = None,\n\t    ) -> str:\n\t        host = parameters.get(\"host\")\n\t        port = parameters.get(\"port\")\n\t        username = parameters.get(\"username\")\n\t        password = parameters.get(\"password\")\n\t        database = parameters.get(\"database\")\n\t        return f\"questdb://{username}:{password}@{host}:{port}/{database}\"\n\t    @classmethod\n", "    def get_default_schema_for_query(cls, database, query) -> str | None:\n\t        \"\"\"Return the default schema for a given query.\"\"\"\n\t        return None\n\t    @classmethod\n\t    def epoch_to_dttm(cls) -> str:\n\t        \"\"\"SQL expression that converts epoch (seconds) to datetime that can be used\n\t        in a query. The reference column should be denoted as `{col}` in the return\n\t        expression, e.g. \"FROM_UNIXTIME({col})\"\n\t        :return: SQL Expression\n\t        \"\"\"\n", "        return \"{col} * 1000000\"\n\t    @classmethod\n\t    def convert_dttm(\n\t        cls, target_type: str, dttm: datetime, db_extra: dict[str, Any] | None = None\n\t    ) -> str | None:\n\t        \"\"\"Convert a Python `datetime` object to a SQL expression.\n\t        :param target_type: The target type of expression\n\t        :param dttm: The datetime object\n\t        :return: The SQL expression\n\t        \"\"\"\n", "        type_u = target_type.upper()\n\t        if type_u == \"DATE\":\n\t            return f\"TO_DATE('{dttm.date().isoformat()}', 'YYYY-MM-DD')\"\n\t        if type_u in (\"DATETIME\", \"TIMESTAMP\"):\n\t            dttm_formatted = dttm.isoformat(sep=\"T\", timespec=\"microseconds\")\n\t            return f\"TO_TIMESTAMP('{dttm_formatted}', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ')\"\n\t        return None\n\t    @classmethod\n\t    def get_datatype(cls, type_code: Any) -> str | None:\n\t        \"\"\"Change column type code from cursor description to string representation.\n", "        :param type_code: Type code from cursor description\n\t        :return: String representation of type code\n\t        \"\"\"\n\t        if type_code and isinstance(type_code, str):\n\t            return type_code.upper()\n\t        return str(type_code)\n\t    @classmethod\n\t    def get_column_spec(\n\t        cls,\n\t        native_type: str | None,\n", "        db_extra: dict[str, Any] | None = None,\n\t        source: utils.ColumnTypeSource = utils.ColumnTypeSource.GET_TABLE,\n\t    ) -> utils.ColumnSpec | None:\n\t        \"\"\"Get generic type related specs regarding a native column type.\n\t        :param native_type: Native database type\n\t        :param db_extra: The database extra object\n\t        :param source: Type coming from the database table or cursor description\n\t        :return: ColumnSpec object\n\t        \"\"\"\n\t        sqla_type = qdbc_types.resolve_type_from_name(native_type)\n", "        if not sqla_type:\n\t            return BaseEngineSpec.get_column_spec(native_type, db_extra, source)\n\t        name_u = sqla_type.__visit_name__\n\t        generic_type = GenericDataType.STRING\n\t        if name_u == \"BOOLEAN\":\n\t            generic_type = GenericDataType.BOOLEAN\n\t        elif name_u in (\"BYTE\", \"SHORT\", \"INT\", \"LONG\", \"FLOAT\", \"DOUBLE\"):\n\t            generic_type = GenericDataType.NUMERIC\n\t        elif name_u in (\"SYMBOL\", \"STRING\", \"CHAR\", \"LONG256\", \"UUID\"):\n\t            generic_type = GenericDataType.STRING\n", "        elif name_u in (\"DATE\", \"TIMESTAMP\"):\n\t            generic_type = GenericDataType.TEMPORAL\n\t        elif \"GEOHASH\" in name_u and \"(\" in name_u and \")\" in name_u:\n\t            generic_type = GenericDataType.STRING\n\t        return utils.ColumnSpec(\n\t            sqla_type,\n\t            generic_type,\n\t            generic_type == GenericDataType.TEMPORAL,\n\t        )\n\t    @classmethod\n", "    def get_sqla_column_type(\n\t        cls,\n\t        native_type: str | None,\n\t        db_extra: dict[str, Any] | None = None,\n\t        source: utils.ColumnTypeSource = utils.ColumnTypeSource.GET_TABLE,\n\t    ) -> TypeEngine | None:\n\t        \"\"\"Converts native database type to sqlalchemy column type.\n\t        :param native_type: Native database type\n\t        :param db_extra: The database extra object\n\t        :param source: Type coming from the database table or cursor description\n", "        :return: ColumnSpec object\n\t        \"\"\"\n\t        return qdbc_types.resolve_type_from_name(native_type).impl\n\t    @classmethod\n\t    def select_star(  # pylint: disable=too-many-arguments\n\t        cls,\n\t        database: Any,\n\t        table_name: str,\n\t        engine: Engine,\n\t        schema: str | None = None,\n", "        limit: int = 100,\n\t        show_cols: bool = False,\n\t        indent: bool = True,\n\t        latest_partition: bool = True,\n\t        cols: list[dict[str, Any]] | None = None,\n\t    ) -> str:\n\t        \"\"\"Generate a \"SELECT * from table_name\" query with appropriate limit.\n\t        :param database: Database instance\n\t        :param table_name: Table name, unquoted\n\t        :param engine: SqlAlchemy Engine instance\n", "        :param schema: Schema, unquoted\n\t        :param limit: limit to impose on query\n\t        :param show_cols: Show columns in query; otherwise use \"*\"\n\t        :param indent: Add indentation to query\n\t        :param latest_partition: Only query the latest partition\n\t        :param cols: Columns to include in query\n\t        :return: SQL query\n\t        \"\"\"\n\t        return super().select_star(\n\t            database,\n", "            table_name,\n\t            engine,\n\t            None,\n\t            limit,\n\t            show_cols,\n\t            indent,\n\t            latest_partition,\n\t            cols,\n\t        )\n\t    @classmethod\n", "    def get_allow_cost_estimate(cls, extra: dict[str, Any]) -> bool:\n\t        return False\n\t    @classmethod\n\t    def get_view_names(\n\t        cls,\n\t        database,\n\t        inspector: Inspector,\n\t        schema: str | None,\n\t    ) -> set[str]:\n\t        return set()\n", "    @classmethod\n\t    def get_text_clause(cls, clause: str) -> TextClause:\n\t        \"\"\"\n\t        SQLAlchemy wrapper to ensure text clauses are escaped properly\n\t        :param clause: string clause with potentially unescaped characters\n\t        :return: text clause with escaped characters\n\t        \"\"\"\n\t        if cls.allows_escaped_colons:\n\t            clause = clause.replace(\":\", \"\\\\:\")\n\t        return text(remove_public_schema(clause))\n"]}
