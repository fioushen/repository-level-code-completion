{"filename": "autobean_format/formatter.py", "chunked_list": ["import io\n\tfrom autobean_refactor import models, parser as parser_lib\n\tfrom . import options_lib\n\tfrom . import formatters\n\tdef format(\n\t    model: models.RawModel,\n\t    parser: parser_lib.Parser,\n\t    options: options_lib.Options,\n\t    stream: io.StringIO,\n\t    *,\n", "    indent: int = 0,\n\t) -> None:\n\t    context = formatters.Context(parser=parser, options=options, indent=indent)\n\t    for token in formatters.format(model, context):\n\t        stream.write(token.raw_text)\n"]}
{"filename": "autobean_format/main.py", "chunked_list": ["import collections\n\timport dataclasses\n\timport difflib\n\timport fileinput\n\timport glob\n\timport io\n\timport os.path\n\timport sys\n\tfrom contextlib import nullcontext\n\tfrom typing import Iterable, Iterator\n", "from . import formatter, options_lib\n\tfrom autobean_refactor import models, parser as parser_lib\n\t@dataclasses.dataclass(frozen=True)\n\tclass _File:\n\t    filename: str\n\t    text: str\n\t    model: models.File\n\tdef _get_include_paths(path: str, file: models.File) -> Iterable[str]:\n\t    for directive in file.raw_directives:\n\t        if not isinstance(directive, models.Include):\n", "            continue\n\t        matches = glob.glob(os.path.join(os.path.dirname(path), directive.filename), recursive=True)\n\t        if not matches:\n\t            lineno = directive.token_store.get_position(directive.first_token).line\n\t            raise ValueError(f'No files match {directive.filename!r} ({path}:{lineno})')\n\t        yield from matches\n\tclass _FilesFormatter:\n\t    def __init__(self, options: options_lib.Options) -> None:\n\t        self._parser = parser_lib.Parser()\n\t        self._options = options\n", "    def load_files(self, filename: str) -> Iterator[_File]:\n\t        visited = set()\n\t        queue = collections.deque([filename])\n\t        while queue:\n\t            filename = queue.popleft()\n\t            if filename in visited:\n\t                continue\n\t            visited.add(filename)\n\t            with fileinput.input(files=filename, encoding='utf-8') as f:\n\t                text = ''.join(f)\n", "            model = self._parser.parse(text, models.File)\n\t            model.auto_claim_comments()\n\t            yield _File(filename=filename, text=text, model=model)\n\t            if self._options.recursive:\n\t                queue.extend(_get_include_paths(filename, model))\n\t    def format_file(self, file: _File) -> str:\n\t        stream = io.StringIO()\n\t        formatter.format(file.model, self._parser, self._options, stream)\n\t        return stream.getvalue()\n\t    def output_file(self, file: _File, formatted: str) -> None:\n", "        match self._options.output_mode:\n\t            case options_lib.OutputMode.STDOUT:\n\t                sys.stdout.write(formatted)\n\t                sys.stdout.flush()\n\t            case options_lib.OutputMode.DIFF:\n\t                diff = difflib.unified_diff(\n\t                    file.text.splitlines(keepends=True),\n\t                    formatted.splitlines(keepends=True),\n\t                    fromfile=file.filename,\n\t                    tofile=file.filename + ' (formatted)')\n", "                sys.stdout.writelines(diff)\n\t                sys.stdout.flush()\n\t            case options_lib.OutputMode.INPLACE:\n\t                with open(file.filename, 'w', encoding='utf-8') as f:\n\t                    f.write(formatted)\n\tdef main() -> None:\n\t    filename, options = options_lib.parse_args()\n\t    formatter = _FilesFormatter(options)\n\t    for file in formatter.load_files(filename):\n\t        formatted = formatter.format_file(file)\n", "        formatter.output_file(file, formatted)\n"]}
{"filename": "autobean_format/__init__.py", "chunked_list": []}
{"filename": "autobean_format/options_lib.py", "chunked_list": ["import argparse\n\timport dataclasses\n\timport enum\n\timport re\n\t_INDENT_REGEX = re.compile('[ \\t]+')\n\tclass OutputMode(enum.Enum):\n\t    STDOUT = 'stdout'\n\t    DIFF = 'diff'\n\t    INPLACE = 'inplace'\n\t    def __str__(self) -> str:\n", "        return self.value\n\tclass ThousandsSeparator(enum.Enum):\n\t    ADD = 'add'\n\t    REMOVE = 'remove'\n\t    KEEP = 'keep'\n\t    def __str__(self) -> str:\n\t        return self.value\n\t@dataclasses.dataclass(frozen=True)\n\tclass Options:\n\t    indent: str\n", "    currency_column: int\n\t    cost_column: int\n\t    output_mode: OutputMode\n\t    thousands_separator: ThousandsSeparator\n\t    spaces_in_braces: bool\n\t    sort: bool\n\t    recursive: bool\n\tdef _indent_type(value: str) -> str:\n\t    if not _INDENT_REGEX.fullmatch(value):\n\t        raise argparse.ArgumentTypeError(\n", "            f'Expected a string of spaces or tabs (not number). Got {value!r}.')\n\t    return value\n\tdef parse_args() -> tuple[str, Options]:\n\t    parser = argparse.ArgumentParser(\n\t        prog='autobean-format',\n\t        description='Formats beancount files',\n\t    )\n\t    parser.add_argument('filename', help=\"When filename is -, read standard input and disallow --recursive\")\n\t    parser.add_argument('--indent', type=_indent_type, default='    ', help='Indentation string. (default: 4 spaces)')\n\t    parser.add_argument('--currency-column', type=int, default=80, help='Column to align currencies to. (default: %(default)s)')\n", "    parser.add_argument('--cost-column', type=int, default=85, help='Column to align cost and price to. (default: %(default)s)')\n\t    output_mode = parser.add_argument('--output-mode', choices=OutputMode, type=OutputMode, default=OutputMode.STDOUT, help='Output mode. Print to stdout, print a patch file, or update file in place. (default: %(default)s)')\n\t    parser.add_argument('--thousands-separator', choices=ThousandsSeparator, type=ThousandsSeparator, default=ThousandsSeparator.KEEP, help='Add, remove, or keep thousand separators (default: %(default)s)')\n\t    parser.add_argument('--spaces-in-braces', action='store_true', help='Add spaces around content of braces if not empty. (default: false)')\n\t    parser.add_argument('--sort', action='store_true', help='Sort entries by date and time. (default: false)')\n\t    recursive = parser.add_argument('--recursive', action='store_true', help='Recursively format included files. (default: false)')\n\t    args = parser.parse_args()\n\t    if args.filename == '-':\n\t        if args.recursive:\n\t            raise argparse.ArgumentError(\n", "                recursive, 'not supported when reading from stin')\n\t        if args.output_mode == OutputMode.INPLACE:\n\t            raise argparse.ArgumentError(\n\t                output_mode, 'inplace not supported when reading from stin')\n\t    return args.filename, Options(\n\t        indent=args.indent,\n\t        currency_column=args.currency_column,\n\t        cost_column=args.cost_column,\n\t        output_mode=args.output_mode,\n\t        thousands_separator=args.thousands_separator,\n", "        spaces_in_braces=args.spaces_in_braces,\n\t        sort=args.sort,\n\t        recursive=args.recursive,\n\t    )\n"]}
{"filename": "autobean_format/formatters/base.py", "chunked_list": ["import dataclasses\n\timport io\n\tfrom typing import Any, Callable, Iterable, Iterator, Type, TypeVar\n\tfrom autobean_refactor import models, parser as parser_lib\n\tfrom .. import options_lib\n\t_M = TypeVar('_M', bound=models.RawModel)\n\t@dataclasses.dataclass(frozen=True)\n\tclass Context:\n\t    parser: parser_lib.Parser\n\t    options: options_lib.Options\n", "    indent: int\n\t    def with_indented(self, indented: bool) -> 'Context':\n\t        if not indented:\n\t            return self\n\t        return dataclasses.replace(self, indent=self.indent + 1)\n\t    def get_indent(self) -> str:\n\t        return self.options.indent * self.indent\n\t_Formatter = Callable[[_M, Context], Iterator[models.RawTokenModel]]\n\t_FORMATTERS = dict[Type[models.RawModel], _Formatter[Any]]()\n\tdef formatter(model_type: Type[_M]) -> Callable[[_Formatter[_M]], _Formatter[_M]]:\n", "    def decorator(formatter: _Formatter[_M]) -> _Formatter[_M]:\n\t        _FORMATTERS[model_type] = formatter\n\t        return formatter\n\t    return decorator\n\tdef format(model: models.RawModel, context: Context) -> Iterator[models.RawTokenModel]:\n\t    formatter = _FORMATTERS.get(type(model))\n\t    if formatter:\n\t        yield from formatter(model, context)\n\t    elif isinstance(model, models.RawTokenModel):\n\t        yield model\n", "    else:\n\t        for child, indented in model.iter_children_formatted():\n\t            yield from format(child, context.with_indented(indented))\n\tdef collect(children: Iterable[tuple[models.RawModel, bool]], context: Context) -> str:\n\t    stream = io.StringIO()\n\t    for child, indented in children:\n\t        for token in format(child, context.with_indented(indented)):\n\t            stream.write(token.raw_text)\n\t    return stream.getvalue()\n"]}
{"filename": "autobean_format/formatters/cost.py", "chunked_list": ["from typing import Iterator\n\tfrom autobean_refactor import models\n\tfrom . import base\n\tdef format_cost(cost: models.UnitCost | models.TotalCost, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    spaces_in_braces = context.options.spaces_in_braces and next(iter(cost.raw_components), None) is not None\n\t    for child, indented in cost.iter_children_formatted():\n\t        if spaces_in_braces and isinstance(child, models.RightBrace | models.DblRightBrace):\n\t            yield models.Whitespace.from_default()\n\t        yield from base.format(child, context.with_indented(indented))\n\t        if spaces_in_braces and isinstance(child, models.LeftBrace | models.DblLeftBrace):\n", "            yield models.Whitespace.from_default()\n\tbase.formatter(models.UnitCost)(format_cost)\n\tbase.formatter(models.TotalCost)(format_cost)\n"]}
{"filename": "autobean_format/formatters/balance.py", "chunked_list": ["from typing import Iterator\n\tfrom autobean_refactor import models\n\tfrom ..internal import alignment, iterating\n\tfrom . import base\n\t@base.formatter(models.Balance)\n\tdef format_balance(open: models.Balance, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    children_it = iterating.BufferedIterator(open.iter_children_formatted())\n\t    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Date)):\n\t        yield from base.format(child, context.with_indented(indented))\n\t    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n", "    header = context.parser.parse(line, models.Balance)\n\t    if padding := alignment.get_padding_align_left(header.raw_currency, context.options.currency_column):\n\t        header.raw_account.spacing_after += padding\n\t    yield from header.tokens\n\t    for child, indented in children_it:\n\t        yield from base.format(child, context.with_indented(indented))\n"]}
{"filename": "autobean_format/formatters/tokens.py", "chunked_list": ["import re\n\tfrom typing import Iterator\n\tfrom autobean_refactor import models\n\tfrom . import base\n\t_NARRATION_RE = re.compile(r';;(.*?)(?:;(.*))?')\n\t@base.formatter(models.Indent)\n\tdef format_indent(indent: models.Indent, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    yield models.Indent.from_value(context.get_indent())\n\t@base.formatter(models.BlockComment)\n\tdef format_block_comment(comment: models.BlockComment, context: base.Context) -> Iterator[models.RawTokenModel]:\n", "    yield models.BlockComment.from_value(\n\t        value=comment.value,\n\t        indent=context.get_indent())\n\t@base.formatter(models.InlineComment)\n\tdef format_inline_comment(comment: models.InlineComment, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    match = re.fullmatch(_NARRATION_RE, comment.raw_text)\n\t    if not match:\n\t        yield models.InlineComment.from_value(comment.value)\n\t        return\n\t    # autobean.narration\n", "    raw_text = ';;'\n\t    narration = match.group(1).strip()\n\t    if narration:\n\t        raw_text += ' ' + narration\n\t    comment_part = match.group(2)\n\t    if comment_part is not None:\n\t        raw_text += ' ;'\n\t        comment_value = comment_part.strip()\n\t        if comment_value:\n\t            raw_text += ' ' + comment_value\n", "    yield models.InlineComment.from_raw_text(raw_text)\n"]}
{"filename": "autobean_format/formatters/__init__.py", "chunked_list": ["from .base import *\n\tfrom . import tokens\n\tfrom . import balance\n\tfrom . import cost\n\tfrom . import file\n\tfrom . import number\n\tfrom . import open\n\tfrom . import posting\n\tfrom . import price\n"]}
{"filename": "autobean_format/formatters/open.py", "chunked_list": ["from typing import Iterator\n\tfrom autobean_refactor import models\n\tfrom ..internal import alignment, iterating\n\tfrom . import base\n\t@base.formatter(models.Open)\n\tdef format_open(open: models.Open, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    children_it = iterating.BufferedIterator(open.iter_children_formatted())\n\t    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Date)):\n\t        yield from base.format(child, context.with_indented(indented))\n\t    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n", "    header = context.parser.parse(line, models.Open)\n\t    if header.raw_currencies:\n\t        if padding := alignment.get_padding_align_left(header.raw_currencies[0], context.options.currency_column):\n\t            header.raw_currencies[0].spacing_before += padding\n\t    yield from header.tokens\n\t    for child, indented in children_it:\n\t        yield from base.format(child, context.with_indented(indented))\n"]}
{"filename": "autobean_format/formatters/price.py", "chunked_list": ["from typing import Iterator\n\tfrom autobean_refactor import models\n\tfrom ..internal import alignment, iterating\n\tfrom . import base\n\t@base.formatter(models.Price)\n\tdef format_price(open: models.Price, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    children_it = iterating.BufferedIterator(open.iter_children_formatted())\n\t    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Date)):\n\t        yield from base.format(child, context.with_indented(indented))\n\t    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n", "    header = context.parser.parse(line, models.Price)\n\t    if padding := alignment.get_padding_align_left(header.raw_amount.raw_currency, context.options.currency_column):\n\t        header.raw_amount.spacing_before += padding\n\t    yield from header.tokens\n\t    for child, indented in children_it:\n\t        yield from base.format(child, context.with_indented(indented))\n"]}
{"filename": "autobean_format/formatters/number.py", "chunked_list": ["from typing import Iterator\n\tfrom autobean_refactor import models\n\tfrom .. import options_lib\n\tfrom . import base\n\t@base.formatter(models.Number)\n\tdef format_number(number: models.Number, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    match context.options.thousands_separator:\n\t        case options_lib.ThousandsSeparator.ADD:\n\t            yield models.Number.from_raw_text(f'{number.value:,f}')\n\t        case options_lib.ThousandsSeparator.REMOVE:\n", "            yield models.Number.from_raw_text(f'{number.value:f}')\n\t        case _:\n\t            yield number\n"]}
{"filename": "autobean_format/formatters/posting.py", "chunked_list": ["from typing import Iterator\n\tfrom autobean_refactor import models\n\tfrom ..internal import alignment, iterating\n\tfrom . import base\n\t@base.formatter(models.Posting)\n\tdef format_posting(posting: models.Posting, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    children_it = iterating.BufferedIterator(posting.iter_children_formatted())\n\t    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Indent)):\n\t        yield from base.format(child, context.with_indented(indented))\n\t    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n", "    header = context.parser.parse(line, models.Posting)\n\t    if header.raw_currency:\n\t        if padding := alignment.get_padding_align_left(header.raw_currency, context.options.currency_column):\n\t            header.raw_account.spacing_after += padding\n\t    elif header.raw_number:\n\t        if padding := alignment.get_padding_align_right(header.raw_number, context.options.currency_column - 1):\n\t            header.raw_account.spacing_after += padding\n\t    if header.raw_cost:\n\t        if padding := alignment.get_padding_align_left(header.raw_cost, context.options.cost_column):\n\t            header.raw_cost.spacing_before += padding\n", "    elif header.raw_price:\n\t        if padding := alignment.get_padding_align_left(header.raw_price, context.options.cost_column):\n\t            header.raw_price.spacing_before += padding\n\t    yield from header.tokens\n\t    for child, indented in children_it:\n\t        yield from base.format(child, context.with_indented(indented))\n"]}
{"filename": "autobean_format/formatters/file.py", "chunked_list": ["from typing import Iterable, Iterator, Optional, Sequence, TypeAlias, TypeGuard, get_args\n\tfrom autobean_refactor import models\n\tfrom ..internal import sorting\n\tfrom . import base\n\t_TopLevelEntity: TypeAlias = models.Directive | models.BlockComment\n\t_Block: TypeAlias = Sequence[_TopLevelEntity]\n\t_BLANK_LINE_SURROUNDED = {\n\t    models.BlockComment,\n\t    models.IgnoredLine,\n\t    models.Transaction,\n", "}\n\tdef _get_category(model: _TopLevelEntity) -> str:\n\t    if isinstance(model, models.Pushtag | models.Poptag | models.Pushmeta | models.Popmeta):\n\t        return 'push_pop'\n\t    if isinstance(model, models.Open | models.Close | models.Commodity | models.Pad | models.Balance):\n\t        return 'declaration'\n\t    if isinstance(model, models.Plugin | models.Include | models.Option):\n\t        return 'directive'\n\t    return 'other'\n\tdef _should_split(prev: Optional[_TopLevelEntity], current: _TopLevelEntity) -> bool:\n", "    if prev is None:\n\t        return False\n\t    current_spacing = prev.spacing_after.count('\\n')\n\t    if current_spacing >= 2:\n\t        return True\n\t    if type(prev) in _BLANK_LINE_SURROUNDED or type(current) in _BLANK_LINE_SURROUNDED:\n\t        return True\n\t    if _get_category(prev) != _get_category(current):\n\t        return True\n\t    return False\n", "def _is_directive_or_comment(model: models.RawModel) -> TypeGuard[_TopLevelEntity]:\n\t    return isinstance(model, get_args(_TopLevelEntity))\n\tdef _partition(file: models.File, context: base.Context) -> list[_Block]:\n\t    prev = None\n\t    last_block = None\n\t    blocks: list[_Block] = []\n\t    for child, indented in file.iter_children_formatted():\n\t        if isinstance(child, models.Whitespace | models.Newline):\n\t            continue\n\t        assert _is_directive_or_comment(child)\n", "        assert not indented\n\t        if last_block is None or _should_split(prev, child):\n\t            last_block = [child]\n\t            blocks.append(last_block)\n\t        else:\n\t            last_block.append(child)\n\t        prev = child\n\t    return blocks\n\tdef _render(blocks: Iterable[_Block], context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    prev = None\n", "    for block in blocks:\n\t        if prev:\n\t            yield models.Newline.from_default()\n\t        for child in block:\n\t            yield from base.format(child, context)\n\t            yield models.Newline.from_default()\n\t        prev = block\n\t@base.formatter(models.File)\n\tdef format_file(file: models.File, context: base.Context) -> Iterator[models.RawTokenModel]:\n\t    blocks: list[_Block] = _partition(file, context)\n", "    if context.options.sort:\n\t        blocks = sorting.sort_blocks(blocks)\n\t    yield from _render(blocks, context)\n"]}
{"filename": "autobean_format/tests/numbers_test.py", "chunked_list": ["from autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestNumbers(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected', [\n\t        ('1-2+3', '1 - 2 + 3'),\n\t        ('1+2*3', '1 + 2 * 3'),\n\t        ('1     +  2  /  5', '1 + 2 / 5'),\n\t        ('--+-+2', '--+-+2'),\n\t        ('-(2)*-3 +- 5', '-(2) * -3 + -5'),\n", "        ('(1+2)*3', '(1 + 2) * 3'),\n\t    ])\n\t    def test_expr(self, src: str, expected: str) -> None:\n\t        assert self.format(src, models.NumberExpr) == expected\n"]}
{"filename": "autobean_format/tests/sorting_test.py", "chunked_list": ["import datetime\n\timport decimal\n\tfrom typing import Optional, Sequence, TypeAlias, cast, get_args\n\tfrom autobean_refactor import models\n\timport pytest\n\tfrom ..internal import sorting\n\tfrom . import base\n\t_Entry: TypeAlias = models.Balance | models.Close | models.Commodity | models.Pad | models.Event | models.Query | models.Price | models.Note | models.Document | models.Custom | models.Transaction\n\t_TopLevelEntity: TypeAlias = models.Directive | models.BlockComment\n\t_TestBlock: TypeAlias = list[str] | list[_TopLevelEntity]\n", "_PLUGIN = models.Plugin.from_value(name='test')\n\t_INCLUDE = models.Include.from_value(filename='test')\n\t_PUSHTAG = models.Pushtag.from_value(tag='test')\n\tdef build_dated_entry(entry: str) -> _TopLevelEntity:\n\t    parts = entry.split(' ', maxsplit=1)\n\t    date = datetime.datetime.strptime(parts[0], '%Y-%m-%d').date()\n\t    meta: dict[str, str | decimal.Decimal]\n\t    if len(parts) == 2:\n\t        meta = dict(time=parts[1] if ':' in parts[1] else decimal.Decimal(parts[1]))\n\t    else:\n", "        meta = {}\n\t    return models.Custom.from_value(date=date, type='test', values=(), meta=meta)\n\tdef unbuild_entity(entity: _TopLevelEntity) -> str | _TopLevelEntity:\n\t    if not isinstance(entity, get_args(_Entry)):\n\t        return entity\n\t    entry: _Entry = cast(_Entry, entity)\n\t    time = entry.meta.get('time')\n\t    if time is None:\n\t        return str(entry.date)\n\t    return f'{entry.date} {time}'\n", "def build_block(block: _TestBlock) -> list[_TopLevelEntity]:\n\t    if not block:\n\t        return []\n\t    if not isinstance(block[0], str):\n\t        return cast(list[_TopLevelEntity], block)\n\t    return [build_dated_entry(entry) for entry in cast(list[str], block)]\n\tdef build_blocks(blocks: list[_TestBlock]) -> list[list[_TopLevelEntity]]:\n\t    return [build_block(block) for block in blocks]\n\t# For better test output\n\tdef unbuild_blocks(\n", "        blocks: list[Sequence[models.Directive | models.BlockComment]]\n\t) -> list[list[str | _TopLevelEntity]]:\n\t    return [[unbuild_entity(entity) for entity in block] for block in blocks]\n\tclass TestSorting(base.BaseTest):\n\t    @pytest.mark.parametrize('blocks,sorted_blocks', [\n\t        pytest.param([], None, id='empty'),\n\t        pytest.param([['2000-01-01']], None, id='single'),\n\t        pytest.param([[_PLUGIN, _INCLUDE]], None, id='undated'),\n\t        pytest.param([['2000-01-01', '2000-01-01', '2000-01-02', '2000-01-03']], None, id='sorted'),\n\t        pytest.param(\n", "            [['2000-01-01', '2000-01-02 01:00', '2000-01-02 02:00', '2000-01-02 03:00', '2000-01-03']],\n\t            None,\n\t            id='sorted with time'),\n\t        pytest.param(\n\t            [['2000-01-01', '2000-01-02 01:00', '2000-01-02', '2000-01-02 02:00', '2000-01-02',\n\t              '2000-01-02 02:00', '2000-01-03']],\n\t            None,\n\t            id='sorted with optional time'),\n\t        pytest.param(\n\t            [['2000-01-01', '2000-01-02 01:00', '2000-01-02', '2000-01-02 02:00', '2000-01-02',\n", "              '2000-01-02 01:01', '2000-01-03']],\n\t            [['2000-01-01', '2000-01-02 01:00', '2000-01-02', '2000-01-02', '2000-01-02 01:01',\n\t              '2000-01-02 02:00', '2000-01-03']],\n\t            id='reorder one'),\n\t        pytest.param(\n\t            [['2000-01-05', '2000-01-04', '2000-01-03', '2000-01-02', '2000-01-01']],\n\t            [['2000-01-01', '2000-01-02', '2000-01-03', '2000-01-04', '2000-01-05']],\n\t            id='reversed',\n\t        ),\n\t        pytest.param(\n", "            [['2000-01-02', '2000-01-03'], ['2000-01-01', '2000-01-02 01:00']],\n\t            [['2000-01-01', '2000-01-02 01:00'], ['2000-01-02', '2000-01-03']],\n\t            id='reorder whole block',\n\t        ),\n\t        pytest.param(\n\t            [['2000-02-02', '2000-02-01'], [_PUSHTAG], ['2000-01-02', '2000-01-01']],\n\t            [['2000-02-01', '2000-02-02'], [_PUSHTAG], ['2000-01-01', '2000-01-02']],\n\t            id='no cross compartment',\n\t        ),\n\t        pytest.param(\n", "            [['2000-01-04'], ['2000-01-02'], [_INCLUDE], ['2000-01-03'], ['2000-01-01']],\n\t            [['2000-01-01'], ['2000-01-02'], [_INCLUDE], ['2000-01-03'], ['2000-01-04']],\n\t            id='retain undated directives'\n\t        ),\n\t        pytest.param(\n\t            [['2000-01-01', '2000-01-01', '2000-01-03', '2000-01-05'], ['2000-01-02', '2000-01-04', '2000-01-04', '2000-01-06', '2000-01-07']],\n\t            [['2000-01-01', '2000-01-01'], ['2000-01-02'], ['2000-01-03'], ['2000-01-04', '2000-01-04'], ['2000-01-05'], ['2000-01-06', '2000-01-07']],\n\t            id='split blocks',\n\t        ),\n\t        pytest.param(\n", "            [['2000-01-02', '2000-01-01'], ['2000-01-03', '2000-01-02']],\n\t            [['2000-01-01', '2000-01-02'], ['2000-01-02', '2000-01-03']],\n\t            id='keep blocks',\n\t        ),\n\t        pytest.param(\n\t            [['2000-01-01', '2000-01-01 02:00', '2000-01-01', '2000-01-01 08:00', '2000-01-01', '2000-01-01 04:00', '2000-01-01']],\n\t            [['2000-01-01', '2000-01-01 02:00', '2000-01-01', '2000-01-01', '2000-01-01 04:00', '2000-01-01', '2000-01-01 08:00']],\n\t            id='reorder with optional time',\n\t        ),\n\t        pytest.param(\n", "            [['2000-01-01 08:00', '2000-01-01 07:00:00', '2000-01-01 946706400', '2000-01-01 946702800000', '2000-01-01 946699200000000']],\n\t            [['2000-01-01 946699200000000', '2000-01-01 946702800000', '2000-01-01 946706400', '2000-01-01 07:00:00', '2000-01-01 08:00']],\n\t            id='distinct time units',\n\t        ),\n\t        pytest.param(\n\t            [['2000-01-02'], ['2000-01-02'], ['2000-01-01'], ['2000-01-01']],\n\t            [['2000-01-01'], ['2000-01-01'], ['2000-01-02'], ['2000-01-02']],\n\t            id='same sort key',\n\t        ),\n\t        pytest.param(\n", "            [['2000-01-01'], ['2000-01-04'], [_INCLUDE], ['2000-01-02'], ['2000-01-03']],\n\t            [['2000-01-01'], [_INCLUDE], ['2000-01-02'], ['2000-01-03'], ['2000-01-04']],\n\t            id='undated ambiguous in LIS',\n\t        ),\n\t        pytest.param(\n\t            [['2000-01-01'], ['2000-01-02 03:00'], ['2000-01-02'], ['2000-01-02'], ['2000-01-02 01:00'], ['2000-01-02 02:00']],\n\t            [['2000-01-01'], ['2000-01-02'], ['2000-01-02'], ['2000-01-02 01:00'], ['2000-01-02 02:00'], ['2000-01-02 03:00']],\n\t            id='untimed ambiguous in LIS',\n\t        ),\n\t    ])\n", "    def test_sort_blocks(self, blocks: list[_TestBlock], sorted_blocks: Optional[list[_TestBlock]]) -> None:\n\t        if sorted_blocks is None:\n\t            sorted_blocks = blocks\n\t        assert unbuild_blocks(sorting.sort_blocks(build_blocks(blocks))) == sorted_blocks\n"]}
{"filename": "autobean_format/tests/base.py", "chunked_list": ["import io\n\tfrom typing import Optional, Type\n\tfrom autobean_refactor import models, parser as parser_lib\n\tfrom autobean_format import formatter, options_lib\n\timport pytest\n\tDEFAULT_OPTIONS = options_lib.Options(\n\t    indent='    ',\n\t    currency_column=80,\n\t    cost_column=85,\n\t    output_mode=options_lib.OutputMode.STDOUT,\n", "    thousands_separator=options_lib.ThousandsSeparator.KEEP,\n\t    spaces_in_braces=False,\n\t    sort=False,\n\t    recursive=False,\n\t)\n\tclass BaseTest:\n\t    @pytest.fixture(autouse=True)\n\t    def _setup_parser(self, parser: parser_lib.Parser) -> None:\n\t        self.parser = parser\n\t    def _format(self, model: models.RawModel, options: options_lib.Options, *, indent: int) -> str:\n", "        stream = io.StringIO()\n\t        formatter.format(model, self.parser, options, stream, indent=indent)\n\t        return stream.getvalue()\n\t    def format(\n\t        self,\n\t        text: str,\n\t        model_type: Type[models.RawTreeModel],\n\t        options: Optional[options_lib.Options] = None,\n\t        indent: int = 0,\n\t    ) -> str:\n", "        model = self.parser.parse(text, model_type)\n\t        model.auto_claim_comments()\n\t        return self._format(model, options or DEFAULT_OPTIONS, indent=indent)\n\t    def format_token(\n\t        self,\n\t        text: str,\n\t        model_type: Type[models.RawTokenModel],\n\t        options: Optional[options_lib.Options] = None,\n\t    ) -> str:\n\t        model = self.parser.parse_token(text, model_type)\n", "        return self._format(model, options or DEFAULT_OPTIONS, indent=0)\n"]}
{"filename": "autobean_format/tests/tokens_test.py", "chunked_list": ["from typing import Type\n\tfrom autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestToken(base.BaseTest):\n\t    @pytest.mark.parametrize('model_type,src,expected', [\n\t        pytest.param(\n\t            models.InlineComment, ';!foo', '; !foo',\n\t            id='inline_comment',\n\t        ),\n", "        pytest.param(\n\t            models.InlineComment, ';!foo;bar', '; !foo;bar',\n\t            id='inline_comment and semicolon',\n\t        ),\n\t        pytest.param(\n\t            models.InlineComment, ';', ';',\n\t            id='inline_comment_empty',\n\t        ),\n\t        pytest.param(\n\t            models.InlineComment, ';;foo', ';; foo',\n", "            id='autobean.narration',\n\t        ),\n\t        pytest.param(\n\t            models.InlineComment, ';;', ';;',\n\t            id='empty autobean.narration',\n\t        ),\n\t        pytest.param(\n\t            models.InlineComment, ';;;', ';; ;',\n\t            id='empty autobean.narration and empty comment',\n\t        ),\n", "        pytest.param(\n\t            models.InlineComment, ';;;;;', ';; ; ;;',\n\t            id='empty autobean.narration and semicolons',\n\t        ),\n\t        pytest.param(\n\t            models.InlineComment, ';;foo;bar;baz', ';; foo ; bar;baz',\n\t            id='autobean.narration and comment',\n\t        ),\n\t    ])\n\t    def test_token(self, model_type: Type[models.RawTokenModel], src: str, expected: str) -> None:\n", "        assert self.format_token(src, model_type) == expected\n"]}
{"filename": "autobean_format/tests/file_test.py", "chunked_list": ["from autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestFile(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected', [\n\t        pytest.param(\n\t            '', '',\n\t            id='empty',\n\t        ),\n\t        pytest.param(\n", "            'include \"foo.bean\"',\n\t            'include \"foo.bean\"\\n',\n\t            id='trailing_newline_add',\n\t        ),\n\t        pytest.param(\n\t            'include \"foo.bean\"\\n',\n\t            'include \"foo.bean\"\\n',\n\t            id='trailing_newline_existing',\n\t        ),\n\t        pytest.param(\n", "            'include \"foo.bean\"\\n\\n\\n\\n\\n\\ninclude \"bar.bean\"\\n\\n\\n\\n\\n',\n\t            'include \"foo.bean\"\\n\\ninclude \"bar.bean\"\\n',\n\t            id='remove_blank_lines',\n\t        ),\n\t        pytest.param(\n\t            'include \"foo.bean\"\\n\\n; xxx\\n\\ninclude \"bar.bean\"\\n',\n\t            'include \"foo.bean\"\\n\\n; xxx\\n\\ninclude \"bar.bean\"\\n',\n\t            id='block_comment',\n\t        ),\n\t        pytest.param(\n", "            'include \"foo.bean\"\\n\\n    ; xxx\\n  ; yy\\n\\ninclude \"bar.bean\"\\n',\n\t            'include \"foo.bean\"\\n\\n; xxx\\n; yy\\n\\ninclude \"bar.bean\"\\n',\n\t            id='block_comment_dedent',\n\t        ),\n\t        pytest.param(\n\t            'include \"foo.bean\"\\n; xxx\\ninclude \"bar.bean\"\\n; yyy\\n',\n\t            'include \"foo.bean\"\\n; xxx\\ninclude \"bar.bean\"\\n; yyy\\n',\n\t            id='surrounding_comment',\n\t        ),\n\t        pytest.param(\n", "            'include \"foo.bean\"\\n*xxx\\ninclude \"bar.bean\"\\n',\n\t            'include \"foo.bean\"\\n\\n*xxx\\n\\ninclude \"bar.bean\"\\n',\n\t            id='add_blank_lines',\n\t        ),\n\t        pytest.param(\n\t            'include \"foo.bean\"\\n*xxx\\n',\n\t            'include \"foo.bean\"\\n\\n*xxx\\n',\n\t            id='add_blank_lines_last',\n\t        ),\n\t        pytest.param(\n", "            'include \"foo.bean\"\\nplugin \"foo\"\\n',\n\t            'include \"foo.bean\"\\nplugin \"foo\"\\n',\n\t            id='no_blank_lines_same_category',\n\t        ),\n\t        pytest.param(\n\t            'include \"foo.bean\"\\npushtag #foo\\n',\n\t            'include \"foo.bean\"\\n\\npushtag #foo\\n',\n\t            id='add_blank_lines_different_category',\n\t        ),\n\t        pytest.param(\n", "            '2000-01-01 open Assets:Foo\\n2000-01-01 pad Assets:Foo Equity:Opening-Balances\\n2000-01-02 balance Assets:Foo                                            100.00 USD\\n',\n\t            '2000-01-01 open Assets:Foo\\n2000-01-01 pad Assets:Foo Equity:Opening-Balances\\n2000-01-02 balance Assets:Foo                                            100.00 USD\\n',\n\t            id='open_pad_balance_together',\n\t        ),\n\t    ])\n\t    def test_file(self, src: str, expected: str) -> None:\n\t        assert self.format(src, models.File) == expected  \n"]}
{"filename": "autobean_format/tests/__init__.py", "chunked_list": []}
{"filename": "autobean_format/tests/posting_test.py", "chunked_list": ["from autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestPosting(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected', [\n\t        pytest.param(\n\t            '    Assets:Foo   1.23  USD  ',\n\t            '    Assets:Foo                                                             1.23 USD',\n\t            id='simple',\n\t        ),\n", "        pytest.param(\n\t            '    Assets:Foo       ',\n\t            '    Assets:Foo',\n\t            id='no_amount',\n\t        ),\n\t        pytest.param(\n\t            '    Assets:Foo   USD     ',\n\t            '    Assets:Foo                                                                  USD',\n\t            id='currency_only',\n\t        ),\n", "        pytest.param(\n\t            '    Assets:Foo   1.23     ',\n\t            '    Assets:Foo                                                             1.23',\n\t            id='number_only',\n\t        ),\n\t        pytest.param(\n\t            '    Assets:Foo   1.00  GBP  @@  1.23  USD  ',\n\t            '    Assets:Foo                                                             1.00 GBP  @@ 1.23 USD',\n\t            id='price_explicit',\n\t        ),\n", "        pytest.param(\n\t            '    Assets:Foo   1.00  GBP  @@  ',\n\t            '    Assets:Foo                                                             1.00 GBP  @@',\n\t            id='price_implicit',\n\t        ),\n\t        pytest.param(\n\t            '    Assets:Foo   @@',\n\t            '    Assets:Foo                                                                       @@',\n\t            id='price_no_amount',\n\t        ),\n", "        pytest.param(\n\t            '    Assets:Foo  1.00 GBP   {1.23 USD}   @ 1.23 USD  ',\n\t            '    Assets:Foo                                                             1.00 GBP  {1.23 USD} @ 1.23 USD',\n\t            id='cost_and_price',\n\t        ),\n\t        pytest.param(\n\t            '    Assets:Foo  1.00 GBP   {}   ',\n\t            '    Assets:Foo                                                             1.00 GBP  {}',\n\t            id='cost_implicit',\n\t        ),\n", "        pytest.param(\n\t            '    Assets:Foo  {}   ',\n\t            '    Assets:Foo                                                                       {}',\n\t            id='cost_no_amount',\n\t        ),\n\t    ])\n\t    def test_posting(self, src: str, expected: str) -> None:\n\t        assert self.format(src, models.Posting, indent=1) == expected\n"]}
{"filename": "autobean_format/tests/price_test.py", "chunked_list": ["from autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestPrice(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected', [\n\t        pytest.param(\n\t            '2000-01-01      price\\tGBP  1.23   USD',\n\t            '2000-01-01 price GBP                                                       1.23 USD',\n\t            id='simple',\n\t        ),\n", "        pytest.param(\n\t            '; aaa\\n2000-01-01      price\\tGBP  1.23   USD  ; xxx\\n; bbb',\n\t            '; aaa\\n2000-01-01 price GBP                                                       1.23 USD ; xxx\\n; bbb',\n\t            id='comment',\n\t        ),\n\t        pytest.param(\n\t            '2000-01-01 price GBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP   1.23   USD',\n\t            '2000-01-01 price GBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 1.23 USD',\n\t            id='no_align_currency_long_currency',\n\t        ),\n", "    ])\n\t    def test_price(self, src: str, expected: str) -> None:\n\t        assert self.format(src, models.Price) == expected  \n"]}
{"filename": "autobean_format/tests/number_test.py", "chunked_list": ["import dataclasses\n\tfrom autobean_refactor import models\n\timport pytest\n\tfrom .. import options_lib\n\tfrom . import base\n\tclass TestNumber(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected,mode', [\n\t        ('1234567890.0987654321', '1234567890.0987654321', 'keep'),\n\t        ('1,234,567,890.0987654321', '1,234,567,890.0987654321', 'keep'),\n\t        ('1234567890.0987654321', '1,234,567,890.0987654321', 'add'),\n", "        ('1234567890.0987654321', '1234567890.0987654321', 'remove'),\n\t        ('1,234,567,890.0987654321', '1234567890.0987654321', 'remove'),\n\t    ])\n\t    def test_thousands_separator(self, src: str, expected: str, mode: str) -> None:\n\t        options = dataclasses.replace(\n\t            base.DEFAULT_OPTIONS,\n\t            thousands_separator=options_lib.ThousandsSeparator(mode))\n\t        assert self.format_token(src, models.Number, options) == expected\n"]}
{"filename": "autobean_format/tests/cost_test.py", "chunked_list": ["import dataclasses\n\tfrom typing import Type\n\tfrom autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestCost(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected,model_type', [\n\t        ('  {  }  ', '{}', models.UnitCost),\n\t        ('  {1.00USD   }  ', '{1.00 USD}', models.UnitCost),\n\t        ('  {{1.00      USD}}  ', '{{1.00 USD}}', models.TotalCost),\n", "        ('  {{1.00      USD  ,   2000-01-01}}  ', '{{1.00 USD, 2000-01-01}}', models.TotalCost),\n\t    ])\n\t    def test_cost(self, src: str, expected: str, model_type: Type[models.UnitCost | models.TotalCost]) -> None:\n\t        assert self.format(src, model_type) == expected\n\t    @pytest.mark.parametrize('src,expected,model_type', [\n\t        ('  {  }  ', '{}', models.UnitCost),\n\t        ('  {1.00USD}  ', '{ 1.00 USD }', models.UnitCost),\n\t        ('  {{1.00      USD}}  ', '{{ 1.00 USD }}', models.TotalCost),\n\t        ('  {{1.00      USD  ,   2000-01-01}}  ', '{{ 1.00 USD, 2000-01-01 }}', models.TotalCost),\n\t    ])\n", "    def test_spaces_in_braces(self, src: str, expected: str, model_type: Type[models.UnitCost | models.TotalCost]) -> None:\n\t        options = dataclasses.replace(base.DEFAULT_OPTIONS, spaces_in_braces=True)\n\t        assert self.format(src, model_type, options) == expected\n"]}
{"filename": "autobean_format/tests/conftest.py", "chunked_list": ["from autobean_refactor import parser as parser_lib\n\timport pytest\n\t@pytest.fixture(scope='package')\n\tdef parser() -> parser_lib.Parser:\n\t    return parser_lib.Parser()\n"]}
{"filename": "autobean_format/tests/balance_test.py", "chunked_list": ["from autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestBalance(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected', [\n\t        pytest.param(\n\t            '2000-01-01      balance\\tAssets:Foo  1.23   USD',\n\t            '2000-01-01 balance Assets:Foo                                              1.23 USD',\n\t            id='simple',\n\t        ),\n", "        pytest.param(\n\t            '2000-01-01      balance\\tAssets:Foo  1.23  ~   0.00   USD',\n\t            '2000-01-01 balance Assets:Foo                                       1.23 ~ 0.00 USD',\n\t            id='tolerance',\n\t        ),\n\t        pytest.param(\n\t            '2000-01-01      balance\\tAssets:Foo  (1.23  *   0.00)   USD',\n\t            '2000-01-01 balance Assets:Foo                                     (1.23 * 0.00) USD',\n\t            id='expr',\n\t        ),\n", "        pytest.param(\n\t            '; aaa\\n2000-01-01      balance\\tAssets:Foo  1.23   USD  ; xxx\\n; bbb',\n\t            '; aaa\\n2000-01-01 balance Assets:Foo                                              1.23 USD ; xxx\\n; bbb',\n\t            id='comment',\n\t        ),\n\t        pytest.param(\n\t            '2000-01-01 balance Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo   1.23   USD',\n\t            '2000-01-01 balance Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 1.23 USD',\n\t            id='no_align_currency_long_account',\n\t        ),\n", "    ])\n\t    def test_balance(self, src: str, expected: str) -> None:\n\t        assert self.format(src, models.Balance) == expected  \n"]}
{"filename": "autobean_format/tests/open_test.py", "chunked_list": ["from autobean_refactor import models\n\timport pytest\n\tfrom . import base\n\tclass TestOpen(base.BaseTest):\n\t    @pytest.mark.parametrize('src,expected', [\n\t        pytest.param(\n\t            '2000-01-01      open\\tAssets:Foo  ',\n\t            '2000-01-01 open Assets:Foo',\n\t            id='simple',\n\t        ),\n", "        pytest.param(\n\t            '; aaa\\n2000-01-01      open\\tAssets:Foo  ; xxx\\n; bbb',\n\t            '; aaa\\n2000-01-01 open Assets:Foo ; xxx\\n; bbb',\n\t            id='comment',\n\t        ),\n\t        pytest.param(\n\t            '2000-01-01 open Assets:Foo   USD,GBP,  EUR',\n\t            '2000-01-01 open Assets:Foo                                                      USD, GBP, EUR',\n\t            id='align_currency',\n\t        ),\n", "        pytest.param(\n\t            '2000-01-01 open Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo   USD,GBP,  EUR',\n\t            '2000-01-01 open Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo USD, GBP, EUR',\n\t            id='no_align_currency_long_account',\n\t        ),\n\t        pytest.param(\n\t            '2000-01-01 open Assets:Foo\\n    foo: USD',\n\t            '2000-01-01 open Assets:Foo\\n    foo: USD',\n\t            id='no_align_meta_currency',\n\t        ),\n", "    ])\n\t    def test_open(self, src: str, expected: str) -> None:\n\t        assert self.format(src, models.Open) == expected  \n"]}
{"filename": "autobean_format/internal/iterating.py", "chunked_list": ["from typing import Callable, Iterable, Iterator, Optional, TypeVar\n\t_V = TypeVar('_V')\n\tclass BufferedIterator(Iterator[_V]):\n\t    def __init__(self, iterable: Iterable[_V]) -> None:\n\t        self._iterator = iter(iterable)\n\t        self._buffer = list[_V]()\n\t    def __iter__(self) -> Iterator[_V]:\n\t        return self\n\t    def __next__(self) -> _V:\n\t        if self._buffer:\n", "            return self._buffer.pop(0)\n\t        return next(self._iterator)\n\t    def _push(self, item: _V) -> None:\n\t        self._buffer.append(item)\n\t    def take_until(self, predicate: Callable[[_V], bool]) -> Iterator[_V]:\n\t        for item in self:\n\t            if predicate(item):\n\t                self._push(item)\n\t                return\n\t            yield item\n", "    def take_until_inclusive(self, predicate: Callable[[_V], bool]) -> Iterator[_V]:\n\t        for item in self:\n\t            yield item\n\t            if predicate(item):\n\t                return\n"]}
{"filename": "autobean_format/internal/chrono.py", "chunked_list": ["import datetime\n\timport decimal\n\tfrom typing import Optional\n\tdef _try_parse_time(time: str, format: str) -> Optional[datetime.time]:\n\t    try:\n\t        return datetime.datetime.strptime(time, format).time()\n\t    except ValueError:\n\t        return None\n\tdef try_normalize_timestring(date: datetime.date, s: str) -> Optional[int]:\n\t    \"\"\"Attempts to normalize time string into unix timestamp in microseconds.\"\"\"\n", "    time = _try_parse_time(s, '%H:%M:%S') or _try_parse_time(s, '%H:%M')\n\t    if time is None:\n\t        return None\n\t    dt = datetime.datetime.combine(date, time, tzinfo=datetime.timezone.utc)\n\t    return int(dt.timestamp() * 1000 * 1000)\n\tdef try_normalize_timestamp(timestamp: decimal.Decimal) -> Optional[int]:\n\t    \"\"\"Attempts to normalize timestamp into unix timestamp in microseconds.\"\"\"\n\t    if timestamp < 10 ** 8:\n\t        return None\n\t    elif timestamp < 10 ** 10:\n", "        return int(timestamp * 1000 * 1000)\n\t    elif timestamp < 10 ** 13:\n\t        return int(timestamp * 1000)\n\t    elif timestamp < 10 ** 16:\n\t        return int(timestamp)\n\t    else:\n\t        return None\n"]}
{"filename": "autobean_format/internal/__init__.py", "chunked_list": []}
{"filename": "autobean_format/internal/alignment.py", "chunked_list": ["from typing import Optional\n\tfrom autobean_refactor import models\n\tdef get_padding_align_left(model: models.RawModel, column: int) -> Optional[str]:\n\t    assert model.token_store\n\t    length = column - model.token_store.get_position(model.first_token).column\n\t    if length <= 0:\n\t        return None\n\t    return ' ' * length\n\tdef get_padding_align_right(model: models.RawModel, column: int) -> Optional[str]:\n\t    assert model.token_store\n", "    next_token = model.token_store.get_next(model.last_token)\n\t    assert next_token\n\t    length = column - model.token_store.get_position(next_token).column\n\t    if length <= 0:\n\t        return None\n\t    return ' ' * length\n"]}
{"filename": "autobean_format/internal/sorting.py", "chunked_list": ["\"\"\"Sorts entities in a less disruptive way.\n\t## Problems\n\tSorting beancount entities may sound as simple as `sorted(entities)` but doing it properly isn't trivial.\n\t* Establishing total order may not be possible.\n\t  * There may be undated entities (e.g. `include`)\n\t  * Ideally we also sort by time if specified in meta. But they may not be consistently specified.\n\t* Swapping entries inside and outside a pushtag / pushmeta block is not allowed.\n\t* Ideally we would like to reorder as few entities as possible.\n\t* Ideally we would like to keep the original block structure.\n\t## Solution\n", "In order to not disrupt existing formatting, we make the assumption that the majority of the file is already sorted\n\tand only a few entities need to be reordered. This assumption may not be true for all files, but when it isn't, we\n\treally don't know how to best preserve the existing formatting.\n\tThe sorting process is:\n\t1. Partition the file into blocks based on surrounding blank lines and entities types (pushpop / undated / dated).\n\t  1. For each dated block, sort entities with prudent sort.\n\t1. Partition the blocks into compartments of blocks, split by pushpop blocks.\n\t1. For each compartment:\n\t  1. Sort blocks with prudent sort.\n\tThe prudent sort process is:\n", "1. Identify the longest non-decreasing subsequence of entities and split out the rest.\n\t1. Sort the rest with simple sort by dicating a total order.\n\t1. Merge the sorted rest into the non-decreasing subsequence.\n\t  * When merging blocks, this may involve split some blocks when necessary.\n\t## Alternatives\n\tInstead of sorting each compartment separately, we could allow swapping entities before `pushtag #foo` and after\n\t`poptag #foo`, but we don't do it as it may be over-complexing due to possibly interleaving pushes.\n\tInstead of sorting out-of-order entities with simple sort, we could recurse with the same method, but we don't do it\n\tas it may be over-complexing and degraded performance.\n\t\"\"\"\n", "import abc\n\timport bisect\n\timport decimal\n\timport functools\n\timport heapq\n\timport itertools\n\tfrom typing import TYPE_CHECKING, Any, Generic, Iterable, Iterator, Optional, Self, Sequence, TypeAlias, TypeVar, cast, get_args\n\tfrom autobean_refactor import models\n\tfrom . import chrono\n\tif TYPE_CHECKING:\n", "    from _typeshed import SupportsDunderLT, SupportsDunderGT\n\t_T = TypeVar('_T')\n\t_O = TypeVar('_O', bound='_Ordered')\n\t_Entry: TypeAlias = models.Balance | models.Open | models.Close | models.Commodity | models.Pad | models.Event | models.Query | models.Price | models.Note | models.Document | models.Custom | models.Transaction\n\t_CompartmentSplitter: TypeAlias = models.Pushtag | models.Poptag | models.Pushmeta | models.Popmeta | models.BlockComment\n\t_TopLevelEntitiy = models.Directive | models.BlockComment\n\tclass _Ordered(Generic[_T], abc.ABC):\n\t    def __init__(self, value: _T) -> None:\n\t        self.value = value\n\t    # Note: a.more_successor_permissive_than(b) may not imply !(b.can_go_before(a))\n", "    @abc.abstractmethod\n\t    def more_successor_permissive_than(self, other: Self) -> bool:\n\t        \"\"\"Tests if successors permitted by this entity forms a proper superset of those permitted by the other entity.\"\"\"\n\t    # Note: may not be transitive\n\t    @abc.abstractmethod\n\t    def can_go_before(self, other: Self) -> bool:\n\t        \"\"\"Tests if this entity can go before the other entity.\"\"\"\n\t    @classmethod\n\t    @abc.abstractmethod\n\t    def min(cls, a: Self, b: Self) -> Self:\n", "        \"\"\"An associative function to summarize the lower bound for can_go_before.\n\t        Formally:\n\t        forall x: x.can_go_before(a) && x.can_go_before(b) <=> x.can_go_before(min(a, b))\n\t        \"\"\"\n\t    @classmethod\n\t    @abc.abstractmethod\n\t    def max(cls, a: Self, b: Self) -> Self:\n\t        \"\"\"An associative function to summarize the upper bound for can_go_before.\n\t        Formally:\n\t        forall x: a.can_go_before(x) && b.can_go_before(x) <=> max(a, b).can_go_before(x)\n", "        \"\"\"\n\t    @classmethod\n\t    @abc.abstractmethod\n\t    def merge(cls, sorted: list[Self], unsorted: list[Self]) -> Iterable[Self]:\n\t        \"\"\"Merges a sorted list with an unsorted list into a sorted list.\n\t        The original order of `sorted` must be preserved.\n\t        \"\"\"\n\t    @classmethod\n\t    def sort(cls, values: list[Self]) -> list[Self]:\n\t        if _is_ordered(values):\n", "            return values\n\t        sorted, unsorted = _split_sorted_unsorted(values)\n\t        return list(cls.merge(sorted, unsorted))\n\tdef _is_ordered(entities: Sequence[_Ordered[_T]]) -> bool:\n\t    if not entities:\n\t        return True\n\t    it = iter(entities)\n\t    running_max = next(it)\n\t    for entity in it:\n\t        if not running_max.can_go_before(entity):\n", "            return False\n\t        running_max = running_max.max(running_max, entity)\n\t    return True\n\tdef _split_sorted_unsorted(\n\t    entities: Sequence[_O],\n\t) -> tuple[list[_O], list[_O]]:\n\t    # (running max index, entity index) -> (prev running max index, prev entity index)\n\t    p = dict[tuple[int, int], tuple[int, int]]()\n\t    m = list[tuple[int, int]]()  # length -> (running max index, last entity index)\n\t    for i, entity in enumerate(entities):\n", "        # first element we cannot go after\n\t        j = bisect.bisect_left(m, True, key=lambda item: not entities[item[0]].can_go_before(entity))\n\t        while j >= 0 and (j == len(m) or entity.more_successor_permissive_than(entities[m[j][0]])):\n\t            running_max = i\n\t            if j:\n\t                if entity.max(entity, entities[m[j - 1][0]]) is not entity:\n\t                    running_max = m[j - 1][0]\n\t                p[(running_max, i)] = m[j - 1]\n\t            m[j:j+1] = [(running_max, i)]\n\t            j -= 1\n", "    last = m[-1] if m else None\n\t    sorted_i, sorted, unsorted = [], [], []\n\t    while last:\n\t        sorted_i.append(last[1])\n\t        last = p.get(last)\n\t    sorted_i.reverse()\n\t    sorted = [entities[i] for i in sorted_i]\n\t    j = 0\n\t    for i in range(len(entities)):\n\t        if j < len(sorted_i) and i == sorted_i[j]:\n", "            j += 1\n\t        else:\n\t            unsorted.append(entities[i])\n\t    return sorted, unsorted\n\tdef _get_entry_time(entry: _Entry) -> int | None:\n\t    time = entry.meta.get('time')\n\t    if isinstance(time, str):\n\t        return chrono.try_normalize_timestring(entry.date, time)\n\t    elif isinstance(time, decimal.Decimal):\n\t        return chrono.try_normalize_timestamp(time)\n", "    else:\n\t        return None\n\tdef _build_reversed_running_min(entities: Sequence[_O]) -> list[_O]:\n\t    reversed_running_min = list(entities)\n\t    for i in reversed(range(len(reversed_running_min) - 1)):\n\t        reversed_running_min[i] = reversed_running_min[i].min(\n\t            reversed_running_min[i], reversed_running_min[i + 1])\n\t    return reversed_running_min\n\tdef _merge_entries(sorted: Sequence['_OrderedEntry'], unsorted: Sequence['_OrderedEntry']) -> Iterator[Sequence['_OrderedEntry']]:\n\t    cursor_sorted, cursor_unsorted = 0, 0\n", "    reversed_running_min_unsorted = _build_reversed_running_min(unsorted)\n\t    while cursor_sorted < len(sorted) and cursor_unsorted < len(unsorted):\n\t        prev_cursor_sorted = cursor_sorted\n\t        while cursor_sorted < len(sorted) and sorted[cursor_sorted].can_go_before(reversed_running_min_unsorted[cursor_unsorted]):\n\t            cursor_sorted += 1\n\t        if cursor_sorted > prev_cursor_sorted:\n\t            yield sorted[prev_cursor_sorted:cursor_sorted]\n\t        if cursor_sorted == len(sorted):\n\t            break\n\t        prev_cursor_unsorted = cursor_unsorted\n", "        while cursor_unsorted < len(unsorted) and not sorted[cursor_sorted].can_go_before(reversed_running_min_unsorted[cursor_unsorted]):\n\t            cursor_unsorted += 1\n\t        yield unsorted[prev_cursor_unsorted:cursor_unsorted]\n\t    if cursor_sorted < len(sorted):\n\t        yield sorted[cursor_sorted:]\n\t    if cursor_unsorted < len(unsorted):\n\t        yield unsorted[cursor_unsorted:]\n\tclass _OrderedEntry(_Ordered[_Entry]):\n\t    def __init__(self, entry: _Entry) -> None:\n\t        super().__init__(entry)\n", "        self.date = entry.date\n\t        self.time = _get_entry_time(entry)\n\t    def more_successor_permissive_than(self, other: Self) -> bool:\n\t        return self.date < other.date or (self.date == other.date and (\n\t            self.time is None and other.time is not None or\n\t            self.time is not None and other.time is not None and self.time < other.time))\n\t    def can_go_before(self, other: Self) -> bool:\n\t        return self.date < other.date or (self.date == other.date and (\n\t            self.time is None or other.time is None or self.time <= other.time))\n\t    @classmethod\n", "    def min(cls, a: Self, b: Self) -> Self:\n\t        if a.date < b.date or (a.date == b.date and (\n\t                b.time is None or (a.time is not None and a.time < b.time))):\n\t            return a\n\t        return b\n\t    @classmethod\n\t    def max(cls, a: Self, b: Self) -> Self:\n\t        if a.date < b.date or (a.date == b.date and (\n\t                a.time is None or (b.time is not None and a.time < b.time))):\n\t            return b\n", "        return a\n\t    def simple_sort_key(self) -> Any:\n\t        return (self.date, self.time or 0)\n\t    @classmethod\n\t    def merge(cls, sorted: list['_OrderedEntry'], unsorted: list['_OrderedEntry']) -> Iterator['_OrderedEntry']:\n\t        unsorted.sort(key=lambda x: x.simple_sort_key())\n\t        return itertools.chain.from_iterable(_merge_entries(sorted, unsorted))\n\t_Block = Sequence[_OrderedEntry] | Sequence[_TopLevelEntitiy]\n\tclass _OrderedBlock(_Ordered[_Block]):\n\t    def __init__(self, block: _Block) -> None:\n", "        super().__init__(block)\n\t        self.entries = cast(Sequence[_OrderedEntry], block) if isinstance(block[0], _OrderedEntry) else None\n\t    @classmethod\n\t    def from_raw_block(cls, block: Sequence[_TopLevelEntitiy]) -> Self:\n\t        if isinstance(block[0], get_args(_Entry)):\n\t            return cls(_OrderedEntry.sort([\n\t                _OrderedEntry(entry) for entry in cast(list[_Entry], block)]))\n\t        else:\n\t            return cls(block)\n\t    @functools.cached_property\n", "    def _max(self) -> Optional['_OrderedEntry']:\n\t        if not self.entries:\n\t            return None\n\t        return functools.reduce(_OrderedEntry.max, self.entries)\n\t    @functools.cached_property\n\t    def _min(self) -> Optional['_OrderedEntry']:\n\t        if not self.entries:\n\t            return None\n\t        return functools.reduce(_OrderedEntry.min, self.entries)\n\t    @classmethod\n", "    def min(cls, a: Self, b: Self) -> Self:\n\t        if (not b._min or (a._min and _OrderedEntry.min(a._min, b._min) is a._min)):\n\t            return a\n\t        return b\n\t    @classmethod\n\t    def max(cls, a: Self, b: Self) -> Self:\n\t        if (not a._max or (b._max and _OrderedEntry.max(a._max, b._max) is b._max)):\n\t            return b\n\t        return a\n\t    def more_successor_permissive_than(self, other: Self) -> bool:\n", "        return bool(\n\t            not self._max and other._max or  # undated is more permissive than dated\n\t            self._max and other._max and self._max.more_successor_permissive_than(other._max)\n\t        )\n\t    def can_go_before(self, other: Self) -> bool:\n\t        return bool(not self._max or not other._min or self._max.can_go_before(other._min))\n\t    def simple_sort_key(self) -> Any:\n\t        assert self._min and self._max  # undated blocks must be part of sorted\n\t        return (self._min.simple_sort_key(), self._max.simple_sort_key())\n\t    @classmethod\n", "    def merge(cls, sorted: list['_OrderedBlock'], unsorted: list['_OrderedBlock']) -> Iterator['_OrderedBlock']:\n\t        keyed_unsorted = [(block.simple_sort_key(), i, block) for i, block in enumerate(unsorted)]\n\t        heapq.heapify(keyed_unsorted)\n\t        cursor_sorted = 0\n\t        while cursor_sorted < len(sorted) and keyed_unsorted:\n\t            if sorted[cursor_sorted].can_go_before(keyed_unsorted[0][2]):\n\t                yield sorted[cursor_sorted]\n\t                cursor_sorted += 1\n\t            elif keyed_unsorted[0][2].can_go_before(sorted[cursor_sorted]):\n\t                yield heapq.heappop(keyed_unsorted)[2]\n", "            else:\n\t                sorted_head_entries = sorted[cursor_sorted].entries\n\t                cursor_sorted += 1\n\t                unsorted_block = heapq.heappop(keyed_unsorted)\n\t                unsorted_head_entries = unsorted_block[2].entries\n\t                assert sorted_head_entries is not None\n\t                assert unsorted_head_entries is not None\n\t                split_blocks = _merge_entries(sorted_head_entries, unsorted_head_entries)\n\t                for block in split_blocks:\n\t                    ordered_block = _OrderedBlock(block)\n", "                    heapq.heappush(keyed_unsorted, (ordered_block.simple_sort_key(), unsorted_block[1], ordered_block))\n\t        if cursor_sorted < len(sorted):\n\t            yield from sorted[cursor_sorted:]\n\t        while keyed_unsorted:\n\t            yield heapq.heappop(keyed_unsorted)[2]\n\tdef _sort_compartment(blocks: list[_OrderedBlock]) -> list[Sequence[_TopLevelEntitiy]]:\n\t    blocks = _OrderedBlock.sort(blocks)\n\t    sorted_blocks = list[Sequence[_TopLevelEntitiy]]()\n\t    for ordered_block in blocks:\n\t        if ordered_block.entries is not None:\n", "            sorted_blocks.append([entry.value for entry in ordered_block.entries])\n\t        else:\n\t            sorted_blocks.append(cast(Sequence[_TopLevelEntitiy], ordered_block.value))\n\t    return sorted_blocks\n\tdef sort_blocks(blocks: Iterable[Sequence[_TopLevelEntitiy]]) -> list[Sequence[_TopLevelEntitiy]]:\n\t    results = []\n\t    compartment = list[_OrderedBlock]()\n\t    for block in blocks:\n\t        if isinstance(block[0], get_args(_CompartmentSplitter)):\n\t            results.extend(_sort_compartment(compartment))\n", "            compartment.clear()\n\t            results.append(block)\n\t        else:\n\t            compartment.append(_OrderedBlock.from_raw_block(block))\n\t    if compartment:\n\t        results.extend(_sort_compartment(compartment))\n\t    return results\n"]}
