{"filename": "tests/test_vmap_jvp.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\timport equinox as eqx\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n", "from .helpers import (\n\t    construct_matrix,\n\t    construct_singular_matrix,\n\t    make_jac_operator,\n\t    make_matrix_operator,\n\t    shaped_allclose,\n\t    solvers_tags_pseudoinverse,\n\t)\n\t@pytest.mark.parametrize(\"solver, tags, pseudoinverse\", solvers_tags_pseudoinverse)\n\t@pytest.mark.parametrize(\"make_operator\", (make_matrix_operator, make_jac_operator))\n", "@pytest.mark.parametrize(\"use_state\", (True, False))\n\t@pytest.mark.parametrize(\n\t    \"make_matrix\",\n\t    (\n\t        construct_matrix,\n\t        construct_singular_matrix,\n\t    ),\n\t)\n\tdef test_vmap_jvp(\n\t    getkey, solver, tags, make_operator, pseudoinverse, use_state, make_matrix\n", "):\n\t    if (make_matrix is construct_matrix) or pseudoinverse:\n\t        t_tags = (None,) * len(tags) if isinstance(tags, tuple) else None\n\t        if pseudoinverse:\n\t            jnp_solve1 = lambda mat, vec: jnp.linalg.lstsq(mat, vec)[0]\n\t        else:\n\t            jnp_solve1 = jnp.linalg.solve\n\t        if use_state:\n\t            def linear_solve1(operator, vector):\n\t                state = solver.init(operator, options={})\n", "                state_dynamic, state_static = eqx.partition(state, eqx.is_inexact_array)\n\t                state_dynamic = lax.stop_gradient(state_dynamic)\n\t                state = eqx.combine(state_dynamic, state_static)\n\t                return lx.linear_solve(operator, vector, state=state, solver=solver)\n\t        else:\n\t            linear_solve1 = ft.partial(lx.linear_solve, solver=solver)\n\t        for mode in (\"vec\", \"op\", \"op_vec\"):\n\t            if \"op\" in mode:\n\t                axis_size = 10\n\t                out_axes = eqx.if_array(0)\n", "            else:\n\t                axis_size = None\n\t                out_axes = None\n\t            def _make():\n\t                matrix, t_matrix = make_matrix(getkey, solver, tags, num=2)\n\t                operator, t_operator = eqx.filter_jvp(\n\t                    make_operator, (matrix, tags), (t_matrix, t_tags)\n\t                )\n\t                return matrix, t_matrix, operator, t_operator\n\t            matrix, t_matrix, operator, t_operator = eqx.filter_vmap(\n", "                _make, axis_size=axis_size, out_axes=out_axes\n\t            )()\n\t            if \"op\" in mode:\n\t                _, out_size, _ = matrix.shape\n\t            else:\n\t                out_size, _ = matrix.shape\n\t            if \"vec\" in mode:\n\t                vec = jr.normal(getkey(), (10, out_size))\n\t                t_vec = jr.normal(getkey(), (10, out_size))\n\t            else:\n", "                vec = jr.normal(getkey(), (out_size,))\n\t                t_vec = jr.normal(getkey(), (out_size,))\n\t            if mode == \"op\":\n\t                linear_solve2 = lambda op: linear_solve1(op, vector=vec)\n\t                jnp_solve2 = lambda mat: jnp_solve1(mat, vec)\n\t            elif mode == \"vec\":\n\t                linear_solve2 = lambda vector: linear_solve1(operator, vector)\n\t                jnp_solve2 = lambda vector: jnp_solve1(matrix, vector)\n\t            elif mode == \"op_vec\":\n\t                linear_solve2 = linear_solve1\n", "                jnp_solve2 = jnp_solve1\n\t            else:\n\t                assert False\n\t            for jvp_first in (True, False):\n\t                if jvp_first:\n\t                    linear_solve3 = ft.partial(eqx.filter_jvp, linear_solve2)\n\t                else:\n\t                    linear_solve3 = linear_solve2\n\t                linear_solve3 = eqx.filter_vmap(linear_solve3)\n\t                if not jvp_first:\n", "                    linear_solve3 = ft.partial(eqx.filter_jvp, linear_solve3)\n\t                linear_solve3 = eqx.filter_jit(linear_solve3)\n\t                jnp_solve3 = ft.partial(eqx.filter_jvp, jnp_solve2)\n\t                jnp_solve3 = eqx.filter_vmap(jnp_solve3)\n\t                jnp_solve3 = eqx.filter_jit(jnp_solve3)\n\t                if mode == \"op\":\n\t                    out, t_out = linear_solve3((operator,), (t_operator,))\n\t                    true_out, true_t_out = jnp_solve3((matrix,), (t_matrix,))\n\t                elif mode == \"vec\":\n\t                    out, t_out = linear_solve3((vec,), (t_vec,))\n", "                    true_out, true_t_out = jnp_solve3((vec,), (t_vec,))\n\t                elif mode == \"op_vec\":\n\t                    out, t_out = linear_solve3((operator, vec), (t_operator, t_vec))\n\t                    true_out, true_t_out = jnp_solve3((matrix, vec), (t_matrix, t_vec))\n\t                else:\n\t                    assert False\n\t                assert shaped_allclose(out.value, true_out, atol=1e-4)\n\t                assert shaped_allclose(t_out.value, true_t_out, atol=1e-4)\n"]}
{"filename": "tests/test_jvp_jvp.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\timport equinox as eqx\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n", "from .helpers import (\n\t    construct_matrix,\n\t    construct_singular_matrix,\n\t    make_jac_operator,\n\t    make_matrix_operator,\n\t    shaped_allclose,\n\t    solvers_tags_pseudoinverse,\n\t)\n\t@pytest.mark.parametrize(\"solver, tags, pseudoinverse\", solvers_tags_pseudoinverse)\n\t@pytest.mark.parametrize(\"make_operator\", (make_matrix_operator, make_jac_operator))\n", "@pytest.mark.parametrize(\"use_state\", (True, False))\n\t@pytest.mark.parametrize(\n\t    \"make_matrix\",\n\t    (\n\t        construct_matrix,\n\t        construct_singular_matrix,\n\t    ),\n\t)\n\tdef test_jvp_jvp(\n\t    getkey, solver, tags, pseudoinverse, make_operator, use_state, make_matrix\n", "):\n\t    t_tags = (None,) * len(tags) if isinstance(tags, tuple) else None\n\t    if (make_matrix is construct_matrix) or pseudoinverse:\n\t        matrix, t_matrix, tt_matrix, tt_t_matrix = construct_matrix(\n\t            getkey, solver, tags, num=4\n\t        )\n\t        t_make_operator = lambda p, t_p: eqx.filter_jvp(\n\t            make_operator, (p, tags), (t_p, t_tags)\n\t        )\n\t        tt_make_operator = lambda p, t_p, tt_p, tt_t_p: eqx.filter_jvp(\n", "            t_make_operator, (p, t_p), (tt_p, tt_t_p)\n\t        )\n\t        (operator, t_operator), (tt_operator, tt_t_operator) = tt_make_operator(\n\t            matrix, t_matrix, tt_matrix, tt_t_matrix\n\t        )\n\t        out_size, _ = matrix.shape\n\t        vec = jr.normal(getkey(), (out_size,))\n\t        t_vec = jr.normal(getkey(), (out_size,))\n\t        tt_vec = jr.normal(getkey(), (out_size,))\n\t        tt_t_vec = jr.normal(getkey(), (out_size,))\n", "        if use_state:\n\t            def linear_solve1(operator, vector):\n\t                state = solver.init(operator, options={})\n\t                state_dynamic, state_static = eqx.partition(state, eqx.is_inexact_array)\n\t                state_dynamic = lax.stop_gradient(state_dynamic)\n\t                state = eqx.combine(state_dynamic, state_static)\n\t                sol = lx.linear_solve(operator, vector, state=state, solver=solver)\n\t                return sol.value\n\t        else:\n\t            def linear_solve1(operator, vector):\n", "                sol = lx.linear_solve(operator, vector, solver=solver)\n\t                return sol.value\n\t        if pseudoinverse:\n\t            jnp_solve1 = lambda mat, vec: jnp.linalg.lstsq(mat, vec)[0]\n\t        else:\n\t            jnp_solve1 = jnp.linalg.solve\n\t        linear_solve2 = ft.partial(eqx.filter_jvp, linear_solve1)\n\t        jnp_solve2 = ft.partial(eqx.filter_jvp, jnp_solve1)\n\t        def _make_primal_tangents(mode):\n\t            lx_args = ([], [], operator, t_operator, tt_operator, tt_t_operator)\n", "            jnp_args = ([], [], matrix, t_matrix, tt_matrix, tt_t_matrix)\n\t            for (primals, ttangents, op, t_op, tt_op, tt_t_op) in (lx_args, jnp_args):\n\t                if \"op\" in mode:\n\t                    primals.append(op)\n\t                    ttangents.append(tt_op)\n\t                if \"vec\" in mode:\n\t                    primals.append(vec)\n\t                    ttangents.append(tt_vec)\n\t                if \"t_op\" in mode:\n\t                    primals.append(t_op)\n", "                    ttangents.append(tt_t_op)\n\t                if \"t_vec\" in mode:\n\t                    primals.append(t_vec)\n\t                    ttangents.append(tt_t_vec)\n\t            lx_out = tuple(lx_args[0]), tuple(lx_args[1])\n\t            jnp_out = tuple(jnp_args[0]), tuple(jnp_args[1])\n\t            return lx_out, jnp_out\n\t        modes = (\n\t            {\"op\"},\n\t            {\"vec\"},\n", "            {\"t_op\"},\n\t            {\"t_vec\"},\n\t            {\"op\", \"vec\"},\n\t            {\"op\", \"t_op\"},\n\t            {\"op\", \"t_vec\"},\n\t            {\"vec\", \"t_op\"},\n\t            {\"vec\", \"t_vec\"},\n\t            {\"op\", \"vec\", \"t_op\"},\n\t            {\"op\", \"vec\", \"t_vec\"},\n\t            {\"vec\", \"t_op\", \"t_vec\"},\n", "            {\"op\", \"vec\", \"t_op\", \"t_vec\"},\n\t        )\n\t        for mode in modes:\n\t            if mode == {\"op\"}:\n\t                linear_solve3 = lambda op: linear_solve2((op, vec), (t_operator, t_vec))\n\t                jnp_solve3 = lambda mat: jnp_solve2((mat, vec), (t_matrix, t_vec))\n\t            elif mode == {\"vec\"}:\n\t                linear_solve3 = lambda v: linear_solve2(\n\t                    (operator, v), (t_operator, t_vec)\n\t                )\n", "                jnp_solve3 = lambda v: jnp_solve2((matrix, v), (t_matrix, t_vec))\n\t            elif mode == {\"op\", \"vec\"}:\n\t                linear_solve3 = lambda op, v: linear_solve2(\n\t                    (op, v), (t_operator, t_vec)\n\t                )\n\t                jnp_solve3 = lambda mat, v: jnp_solve2((mat, v), (t_matrix, t_vec))\n\t            elif mode == {\"t_op\"}:\n\t                linear_solve3 = lambda t_op: linear_solve2(\n\t                    (operator, vec), (t_op, t_vec)\n\t                )\n", "                jnp_solve3 = lambda t_mat: jnp_solve2((matrix, vec), (t_mat, t_vec))\n\t            elif mode == {\"t_vec\"}:\n\t                linear_solve3 = lambda t_v: linear_solve2(\n\t                    (operator, vec), (t_operator, t_v)\n\t                )\n\t                jnp_solve3 = lambda t_v: jnp_solve2((matrix, vec), (t_matrix, t_v))\n\t            elif mode == {\"op\", \"vec\"}:\n\t                linear_solve3 = lambda op, v: linear_solve2(\n\t                    (op, v), (t_operator, t_vec)\n\t                )\n", "                jnp_solve3 = lambda mat, v: jnp_solve2((mat, v), (t_matrix, t_vec))\n\t            elif mode == {\"op\", \"t_op\"}:\n\t                linear_solve3 = lambda op, t_op: linear_solve2((op, vec), (t_op, t_vec))\n\t                jnp_solve3 = lambda mat, t_mat: jnp_solve2((mat, vec), (t_mat, t_vec))\n\t            elif mode == {\"op\", \"t_vec\"}:\n\t                linear_solve3 = lambda op, t_v: linear_solve2(\n\t                    (op, vec), (t_operator, t_v)\n\t                )\n\t                jnp_solve3 = lambda mat, t_v: jnp_solve2((mat, vec), (t_matrix, t_v))\n\t            elif mode == {\"vec\", \"t_op\"}:\n", "                linear_solve3 = lambda v, t_op: linear_solve2(\n\t                    (operator, v), (t_op, t_vec)\n\t                )\n\t                jnp_solve3 = lambda v, t_mat: jnp_solve2((matrix, v), (t_mat, t_vec))\n\t            elif mode == {\"vec\", \"t_vec\"}:\n\t                linear_solve3 = lambda v, t_v: linear_solve2(\n\t                    (operator, v), (t_operator, t_v)\n\t                )\n\t                jnp_solve3 = lambda v, t_v: jnp_solve2((matrix, v), (t_matrix, t_v))\n\t            elif mode == {\"op\", \"vec\", \"t_op\"}:\n", "                linear_solve3 = lambda op, v, t_op: linear_solve2(\n\t                    (op, v), (t_op, t_vec)\n\t                )\n\t                jnp_solve3 = lambda mat, v, t_mat: jnp_solve2((mat, v), (t_mat, t_vec))\n\t            elif mode == {\"op\", \"vec\", \"t_vec\"}:\n\t                linear_solve3 = lambda op, v, t_v: linear_solve2(\n\t                    (op, v), (t_operator, t_v)\n\t                )\n\t                jnp_solve3 = lambda mat, v, t_v: jnp_solve2((mat, v), (t_matrix, t_v))\n\t            elif mode == {\"vec\", \"t_op\", \"t_vec\"}:\n", "                linear_solve3 = lambda v, t_op, t_v: linear_solve2(\n\t                    (operator, v), (t_op, t_v)\n\t                )\n\t                jnp_solve3 = lambda v, t_mat, t_v: jnp_solve2((matrix, v), (t_mat, t_v))\n\t            elif mode == {\"op\", \"vec\", \"t_op\", \"t_vec\"}:\n\t                linear_solve3 = lambda op, v, t_op, t_v: linear_solve2(\n\t                    (op, v), (t_op, t_v)\n\t                )\n\t                jnp_solve3 = lambda mat, v, t_mat, t_v: jnp_solve2(\n\t                    (mat, v), (t_mat, t_v)\n", "                )\n\t            else:\n\t                assert False\n\t            linear_solve3 = ft.partial(eqx.filter_jvp, linear_solve3)\n\t            linear_solve3 = eqx.filter_jit(linear_solve3)\n\t            jnp_solve3 = ft.partial(eqx.filter_jvp, jnp_solve3)\n\t            jnp_solve3 = eqx.filter_jit(jnp_solve3)\n\t            (primal, tangent), (jnp_primal, jnp_tangent) = _make_primal_tangents(mode)\n\t            (out, t_out), (minus_out, tt_out) = linear_solve3(primal, tangent)\n\t            (true_out, true_t_out), (minus_true_out, true_tt_out) = jnp_solve3(\n", "                jnp_primal, jnp_tangent\n\t            )\n\t            assert shaped_allclose(out, true_out, atol=1e-4)\n\t            assert shaped_allclose(t_out, true_t_out, atol=1e-4)\n\t            assert shaped_allclose(tt_out, true_tt_out, atol=1e-4)\n\t            assert shaped_allclose(minus_out, minus_true_out, atol=1e-4)\n"]}
{"filename": "tests/test_misc.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport jax\n\timport jax.numpy as jnp\n\timport lineax as lx\n\timport lineax._misc as lx_misc\n\tdef test_inexact_asarray_no_copy():\n\t    x = jnp.array([1.0])\n\t    assert lx_misc.inexact_asarray(x) is x\n", "    y = jnp.array([1.0, 2.0])\n\t    assert jax.vmap(lx_misc.inexact_asarray)(y) is y\n\t# See JAX issue #15676\n\tdef test_inexact_asarray_jvp():\n\t    p, t = jax.jvp(lx_misc.inexact_asarray, (1.0,), (2.0,))\n\t    assert type(p) is not float\n\t    assert type(t) is not float\n\tdef test_zero_matrix():\n\t    A = lx.MatrixLinearOperator(jnp.zeros((2, 2)))\n\t    b = jnp.array([1.0, 2.0])\n", "    lx.linear_solve(A, b, lx.SVD())\n"]}
{"filename": "tests/__main__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport pathlib\n\timport subprocess\n\timport sys\n\there = pathlib.Path(__file__).resolve().parent\n\t# Each file is ran separately to avoid out-of-memorying.\n\trunning_out = 0\n\tfor file in here.iterdir():\n", "    if file.is_file() and file.name.startswith(\"test\"):\n\t        out = subprocess.run(f\"pytest {file}\", shell=True).returncode\n\t        running_out = max(running_out, out)\n\tsys.exit(running_out)\n"]}
{"filename": "tests/test_singular.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport contextlib\n\timport functools as ft\n\timport equinox as eqx\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n", "import lineax as lx\n\tfrom .helpers import (\n\t    construct_singular_matrix,\n\t    finite_difference_jvp,\n\t    make_jac_operator,\n\t    make_matrix_operator,\n\t    ops,\n\t    params,\n\t    shaped_allclose,\n\t    tol,\n", ")\n\t@pytest.mark.parametrize(\"make_operator,solver,tags\", params(only_pseudo=True))\n\t@pytest.mark.parametrize(\"ops\", ops)\n\tdef test_small_singular(make_operator, solver, tags, ops, getkey):\n\t    if jax.config.jax_enable_x64:  # pyright: ignore\n\t        tol = 1e-10\n\t    else:\n\t        tol = 1e-4\n\t    (matrix,) = construct_singular_matrix(getkey, solver, tags)\n\t    operator = make_operator(matrix, tags)\n", "    operator, matrix = ops(operator, matrix)\n\t    assert shaped_allclose(operator.as_matrix(), matrix, rtol=tol, atol=tol)\n\t    out_size, in_size = matrix.shape\n\t    true_x = jr.normal(getkey(), (in_size,))\n\t    b = matrix @ true_x\n\t    x = lx.linear_solve(operator, b, solver=solver, throw=False).value\n\t    jax_x, *_ = jnp.linalg.lstsq(matrix, b)\n\t    assert shaped_allclose(x, jax_x, atol=tol, rtol=tol)\n\tdef test_bicgstab_breakdown(getkey):\n\t    if jax.config.jax_enable_x64:  # pyright: ignore\n", "        tol = 1e-10\n\t    else:\n\t        tol = 1e-4\n\t    solver = lx.GMRES(atol=tol, rtol=tol, restart=2)\n\t    matrix = jr.normal(jr.PRNGKey(0), (100, 100))\n\t    true_x = jr.normal(jr.PRNGKey(0), (100,))\n\t    b = matrix @ true_x\n\t    operator = lx.MatrixLinearOperator(matrix)\n\t    # result != 0 implies lineax reported failure\n\t    lx_soln = lx.linear_solve(operator, b, solver, throw=False)\n", "    assert jnp.all(lx_soln.result != lx.RESULTS.successful)\n\tdef test_gmres_stagnation_or_breakdown(getkey):\n\t    if jax.config.jax_enable_x64:  # pyright: ignore\n\t        tol = 1e-10\n\t    else:\n\t        tol = 1e-4\n\t    solver = lx.GMRES(atol=tol, rtol=tol, restart=2)\n\t    matrix = jnp.array(\n\t        [\n\t            [0.15892892, 0.05884365, -0.60427412, 0.1891916],\n", "            [-1.5484863, 0.93608822, 1.94888868, 1.37069667],\n\t            [0.62687318, -0.13996738, -0.6824359, 0.30975754],\n\t            [-0.67428635, 1.52372255, -0.88277754, 0.69633816],\n\t        ]\n\t    )\n\t    true_x = jnp.array([0.51383273, 1.72983427, -0.43251078, -1.11764668])\n\t    b = matrix @ true_x\n\t    operator = lx.MatrixLinearOperator(matrix)\n\t    # result != 0 implies lineax reported failure\n\t    lx_soln = lx.linear_solve(operator, b, solver, throw=False)\n", "    assert jnp.all(lx_soln.result != lx.RESULTS.successful)\n\t@pytest.mark.parametrize(\n\t    \"solver\", (lx.AutoLinearSolver(well_posed=None), lx.QR(), lx.SVD())\n\t)\n\tdef test_nonsquare_pytree_operator1(solver):\n\t    x = [[1, 5.0, jnp.array(-1.0)], [jnp.array(-2), jnp.array(-2.0), 3.0]]\n\t    y = [3.0, 4]\n\t    struct = jax.eval_shape(lambda: y)\n\t    operator = lx.PyTreeLinearOperator(x, struct)\n\t    out = lx.linear_solve(operator, y, solver=solver).value\n", "    matrix = jnp.array([[1.0, 5.0, -1.0], [-2.0, -2.0, 3.0]])\n\t    true_out, _, _, _ = jnp.linalg.lstsq(matrix, jnp.array(y))\n\t    true_out = [true_out[0], true_out[1], true_out[2]]\n\t    assert shaped_allclose(out, true_out)\n\t@pytest.mark.parametrize(\n\t    \"solver\", (lx.AutoLinearSolver(well_posed=None), lx.QR(), lx.SVD())\n\t)\n\tdef test_nonsquare_pytree_operator2(solver):\n\t    x = [[1, jnp.array(-2)], [5.0, jnp.array(-2.0)], [jnp.array(-1.0), 3.0]]\n\t    y = [3.0, 4, 5.0]\n", "    struct = jax.eval_shape(lambda: y)\n\t    operator = lx.PyTreeLinearOperator(x, struct)\n\t    out = lx.linear_solve(operator, y, solver=solver).value\n\t    matrix = jnp.array([[1.0, -2.0], [5.0, -2.0], [-1.0, 3.0]])\n\t    true_out, _, _, _ = jnp.linalg.lstsq(matrix, jnp.array(y))\n\t    true_out = [true_out[0], true_out[1]]\n\t    assert shaped_allclose(out, true_out)\n\t@pytest.mark.parametrize(\"full_rank\", (True, False))\n\t@pytest.mark.parametrize(\"jvp\", (False, True))\n\t@pytest.mark.parametrize(\"wide\", (False, True))\n", "def test_qr_nonsquare_mat_vec(full_rank, jvp, wide, getkey):\n\t    if wide:\n\t        out_size = 3\n\t        in_size = 6\n\t    else:\n\t        out_size = 6\n\t        in_size = 3\n\t    matrix = jr.normal(getkey(), (out_size, in_size))\n\t    if full_rank:\n\t        context = contextlib.nullcontext()\n", "    else:\n\t        context = pytest.raises(Exception)\n\t        if wide:\n\t            matrix = matrix.at[:, 2:].set(0)\n\t        else:\n\t            matrix = matrix.at[2:, :].set(0)\n\t    vector = jr.normal(getkey(), (out_size,))\n\t    lx_solve = lambda mat, vec: lx.linear_solve(\n\t        lx.MatrixLinearOperator(mat), vec, lx.QR()\n\t    ).value\n", "    jnp_solve = lambda mat, vec: jnp.linalg.lstsq(mat, vec)[0]\n\t    if jvp:\n\t        lx_solve = eqx.filter_jit(ft.partial(eqx.filter_jvp, lx_solve))\n\t        jnp_solve = eqx.filter_jit(ft.partial(finite_difference_jvp, jnp_solve))\n\t        t_matrix = jr.normal(getkey(), (out_size, in_size))\n\t        t_vector = jr.normal(getkey(), (out_size,))\n\t        args = ((matrix, vector), (t_matrix, t_vector))\n\t    else:\n\t        args = (matrix, vector)\n\t    with context:\n", "        x = lx_solve(*args)  # pyright: ignore\n\t    if full_rank:\n\t        true_x = jnp_solve(*args)\n\t        assert shaped_allclose(x, true_x, atol=1e-4, rtol=1e-4)\n\t@pytest.mark.parametrize(\"full_rank\", (True, False))\n\t@pytest.mark.parametrize(\"jvp\", (False, True))\n\t@pytest.mark.parametrize(\"wide\", (False, True))\n\tdef test_qr_nonsquare_vec(full_rank, jvp, wide, getkey):\n\t    if wide:\n\t        out_size = 3\n", "        in_size = 6\n\t    else:\n\t        out_size = 6\n\t        in_size = 3\n\t    matrix = jr.normal(getkey(), (out_size, in_size))\n\t    if full_rank:\n\t        context = contextlib.nullcontext()\n\t    else:\n\t        context = pytest.raises(Exception)\n\t        if wide:\n", "            matrix = matrix.at[:, 2:].set(0)\n\t        else:\n\t            matrix = matrix.at[2:, :].set(0)\n\t    vector = jr.normal(getkey(), (out_size,))\n\t    lx_solve = lambda vec: lx.linear_solve(\n\t        lx.MatrixLinearOperator(matrix), vec, lx.QR()\n\t    ).value\n\t    jnp_solve = lambda vec: jnp.linalg.lstsq(matrix, vec)[0]\n\t    if jvp:\n\t        lx_solve = eqx.filter_jit(ft.partial(eqx.filter_jvp, lx_solve))\n", "        jnp_solve = eqx.filter_jit(ft.partial(finite_difference_jvp, jnp_solve))\n\t        t_vector = jr.normal(getkey(), (out_size,))\n\t        args = ((vector,), (t_vector,))\n\t    else:\n\t        args = (vector,)\n\t    with context:\n\t        x = lx_solve(*args)  # pyright: ignore\n\t    if full_rank:\n\t        true_x = jnp_solve(*args)\n\t        assert shaped_allclose(x, true_x, atol=1e-4, rtol=1e-4)\n", "_iterative_solvers = (\n\t    (lx.CG(rtol=tol, atol=tol), lx.positive_semidefinite_tag),\n\t    (lx.CG(rtol=tol, atol=tol, max_steps=512), lx.negative_semidefinite_tag),\n\t    (lx.GMRES(rtol=tol, atol=tol), ()),\n\t    (lx.BiCGStab(rtol=tol, atol=tol), ()),\n\t)\n\t@pytest.mark.parametrize(\"make_operator\", (make_matrix_operator, make_jac_operator))\n\t@pytest.mark.parametrize(\"solver, tags\", _iterative_solvers)\n\t@pytest.mark.parametrize(\"use_state\", (False, True))\n\tdef test_iterative_singular(getkey, solver, tags, use_state, make_operator):\n", "    (matrix,) = construct_singular_matrix(getkey, solver, tags)\n\t    operator = make_operator(matrix, tags)\n\t    out_size, _ = matrix.shape\n\t    vec = jr.normal(getkey(), (out_size,))\n\t    if use_state:\n\t        state = solver.init(operator, options={})\n\t        linear_solve = ft.partial(lx.linear_solve, state=state)\n\t    else:\n\t        linear_solve = lx.linear_solve\n\t    with pytest.raises(Exception):\n", "        linear_solve(operator, vec, solver)\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "tests/test_transpose.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport equinox as eqx\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n\tfrom .helpers import construct_matrix, params, shaped_allclose\n", "class TestTranspose:\n\t    @pytest.fixture(scope=\"class\")\n\t    def assert_transpose_fixture(_):\n\t        @eqx.filter_jit\n\t        def solve_transpose(operator, out_vec, in_vec, solver):\n\t            return jax.linear_transpose(\n\t                lambda v: lx.linear_solve(operator, v, solver).value, out_vec\n\t            )(in_vec)\n\t        def assert_transpose(operator, out_vec, in_vec, solver):\n\t            (out,) = solve_transpose(operator, out_vec, in_vec, solver)\n", "            true_out = lx.linear_solve(operator.T, in_vec, solver).value\n\t            assert shaped_allclose(out, true_out)\n\t        return assert_transpose\n\t    @pytest.mark.parametrize(\"make_operator,solver,tags\", params(only_pseudo=False))\n\t    def test_transpose(\n\t        _, make_operator, solver, tags, assert_transpose_fixture, getkey\n\t    ):\n\t        (matrix,) = construct_matrix(getkey, solver, tags)\n\t        operator = make_operator(matrix, tags)\n\t        out_size, in_size = matrix.shape\n", "        out_vec = jr.normal(getkey(), (out_size,))\n\t        in_vec = jr.normal(getkey(), (in_size,))\n\t        solver = lx.AutoLinearSolver(well_posed=True)\n\t        assert_transpose_fixture(operator, out_vec, in_vec, solver)\n\t    def test_pytree_transpose(_, assert_transpose_fixture):  # pyright: ignore\n\t        a = jnp.array\n\t        pytree = [[a(1), a(2), a(3)], [a(4), a(5), a(6)]]\n\t        output_structure = jax.eval_shape(lambda: [1, 2])\n\t        operator = lx.PyTreeLinearOperator(pytree, output_structure)\n\t        out_vec = [a(1.0), a(2.0)]\n", "        in_vec = [a(1.0), 2.0, 3.0]\n\t        solver = lx.AutoLinearSolver(well_posed=False)\n\t        assert_transpose_fixture(operator, out_vec, in_vec, solver)\n"]}
{"filename": "tests/test_vmap.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport equinox as eqx\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n\tfrom .helpers import (\n\t    construct_matrix,\n", "    construct_singular_matrix,\n\t    make_jac_operator,\n\t    make_matrix_operator,\n\t    shaped_allclose,\n\t    solvers_tags_pseudoinverse,\n\t)\n\t@pytest.mark.parametrize(\"make_operator\", (make_matrix_operator, make_jac_operator))\n\t@pytest.mark.parametrize(\"solver, tags, pseudoinverse\", solvers_tags_pseudoinverse)\n\t@pytest.mark.parametrize(\"use_state\", (True, False))\n\t@pytest.mark.parametrize(\n", "    \"make_matrix\",\n\t    (\n\t        construct_matrix,\n\t        construct_singular_matrix,\n\t    ),\n\t)\n\tdef test_vmap(\n\t    getkey, make_operator, solver, tags, pseudoinverse, use_state, make_matrix\n\t):\n\t    if (make_matrix is construct_matrix) or pseudoinverse:\n", "        def wrap_solve(matrix, vector):\n\t            operator = make_operator(matrix, tags)\n\t            if use_state:\n\t                state = solver.init(operator, options={})\n\t                return lx.linear_solve(operator, vector, solver, state=state).value\n\t            else:\n\t                return lx.linear_solve(operator, vector, solver).value\n\t        for op_axis, vec_axis in (\n\t            (None, 0),\n\t            (eqx.if_array(0), None),\n", "            (eqx.if_array(0), 0),\n\t        ):\n\t            if op_axis is None:\n\t                axis_size = None\n\t                out_axes = None\n\t            else:\n\t                axis_size = 10\n\t                out_axes = eqx.if_array(0)\n\t            (matrix,) = eqx.filter_vmap(\n\t                make_matrix, axis_size=axis_size, out_axes=out_axes\n", "            )(getkey, solver, tags)\n\t            out_dim = matrix.shape[-2]\n\t            if vec_axis is None:\n\t                vec = jr.normal(getkey(), (out_dim,))\n\t            else:\n\t                vec = jr.normal(getkey(), (10, out_dim))\n\t            jax_result, _, _, _ = eqx.filter_vmap(\n\t                jnp.linalg.lstsq, in_axes=(op_axis, vec_axis)\n\t            )(matrix, vec)\n\t            lx_result = eqx.filter_vmap(wrap_solve, in_axes=(op_axis, vec_axis))(\n", "                matrix, vec\n\t            )\n\t            assert shaped_allclose(lx_result, jax_result)\n"]}
{"filename": "tests/test_well_posed.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n\tfrom .helpers import (\n\t    construct_matrix,\n", "    ops,\n\t    params,\n\t    shaped_allclose,\n\t    solvers,\n\t)\n\t@pytest.mark.parametrize(\"make_operator,solver,tags\", params(only_pseudo=False))\n\t@pytest.mark.parametrize(\"ops\", ops)\n\tdef test_small_wellposed(make_operator, solver, tags, ops, getkey):\n\t    if jax.config.jax_enable_x64:  # pyright: ignore\n\t        tol = 1e-10\n", "    else:\n\t        tol = 1e-4\n\t    (matrix,) = construct_matrix(getkey, solver, tags)\n\t    operator = make_operator(matrix, tags)\n\t    operator, matrix = ops(operator, matrix)\n\t    assert shaped_allclose(operator.as_matrix(), matrix, rtol=tol, atol=tol)\n\t    out_size, _ = matrix.shape\n\t    true_x = jr.normal(getkey(), (out_size,))\n\t    b = matrix @ true_x\n\t    x = lx.linear_solve(operator, b, solver=solver).value\n", "    jax_x = jnp.linalg.solve(matrix, b)\n\t    assert shaped_allclose(x, true_x, atol=tol, rtol=tol)\n\t    assert shaped_allclose(x, jax_x, atol=tol, rtol=tol)\n\t@pytest.mark.parametrize(\"solver\", solvers)\n\tdef test_pytree_wellposed(solver, getkey):\n\t    if not isinstance(\n\t        solver,\n\t        (lx.Diagonal, lx.Triangular, lx.Tridiagonal, lx.Cholesky, lx.CG, lx.NormalCG),\n\t    ):\n\t        if jax.config.jax_enable_x64:  # pyright: ignore\n", "            tol = 1e-10\n\t        else:\n\t            tol = 1e-4\n\t        true_x = [jr.normal(getkey(), shape=(2, 4)), jr.normal(getkey(), (3,))]\n\t        pytree = [\n\t            [\n\t                jr.normal(getkey(), shape=(2, 4, 2, 4)),\n\t                jr.normal(getkey(), shape=(2, 4, 3)),\n\t            ],\n\t            [\n", "                jr.normal(getkey(), shape=(3, 2, 4)),\n\t                jr.normal(getkey(), shape=(3, 3)),\n\t            ],\n\t        ]\n\t        out_structure = jax.eval_shape(lambda: true_x)\n\t        operator = lx.PyTreeLinearOperator(pytree, out_structure)\n\t        b = operator.mv(true_x)\n\t        lx_x = lx.linear_solve(operator, b, solver, throw=False)\n\t        assert shaped_allclose(lx_x.value, true_x, atol=tol, rtol=tol)\n"]}
{"filename": "tests/test_operator.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import cast, Union\n\timport equinox as eqx\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n", "from .helpers import (\n\t    make_diagonal_operator,\n\t    make_operators,\n\t    make_tridiagonal_operator,\n\t    shaped_allclose,\n\t)\n\tdef test_ops(getkey):\n\t    matrix1 = lx.MatrixLinearOperator(jr.normal(getkey(), (3, 3)))\n\t    matrix2 = lx.MatrixLinearOperator(jr.normal(getkey(), (3, 3)))\n\t    scalar = jr.normal(getkey(), ())\n", "    add = matrix1 + matrix2\n\t    composed = matrix1 @ matrix2\n\t    mul = matrix1 * scalar\n\t    rmul = cast(lx.AbstractLinearOperator, scalar * matrix1)\n\t    div = matrix1 / scalar\n\t    vec = jr.normal(getkey(), (3,))\n\t    assert shaped_allclose(matrix1.mv(vec) + matrix2.mv(vec), add.mv(vec))\n\t    assert shaped_allclose(matrix1.mv(matrix2.mv(vec)), composed.mv(vec))\n\t    scalar_matvec = scalar * matrix1.mv(vec)\n\t    assert shaped_allclose(scalar_matvec, mul.mv(vec))\n", "    assert shaped_allclose(scalar_matvec, rmul.mv(vec))\n\t    assert shaped_allclose(matrix1.mv(vec) / scalar, div.mv(vec))\n\t    add_matrix = matrix1.as_matrix() + matrix2.as_matrix()\n\t    composed_matrix = matrix1.as_matrix() @ matrix2.as_matrix()\n\t    mul_matrix = scalar * matrix1.as_matrix()\n\t    div_matrix = matrix1.as_matrix() / scalar\n\t    assert shaped_allclose(add_matrix, add.as_matrix())\n\t    assert shaped_allclose(composed_matrix, composed.as_matrix())\n\t    assert shaped_allclose(mul_matrix, mul.as_matrix())\n\t    assert shaped_allclose(mul_matrix, rmul.as_matrix())\n", "    assert shaped_allclose(div_matrix, div.as_matrix())\n\t    assert shaped_allclose(add_matrix.T, add.T.as_matrix())\n\t    assert shaped_allclose(composed_matrix.T, composed.T.as_matrix())\n\t    assert shaped_allclose(mul_matrix.T, mul.T.as_matrix())\n\t    assert shaped_allclose(mul_matrix.T, rmul.T.as_matrix())\n\t    assert shaped_allclose(div_matrix.T, div.T.as_matrix())\n\t@pytest.mark.parametrize(\"make_operator\", make_operators)\n\tdef test_structures_vector(make_operator, getkey):\n\t    if make_operator is make_diagonal_operator:\n\t        matrix = jnp.eye(4)\n", "        tags = lx.diagonal_tag\n\t        in_size = out_size = 4\n\t    elif make_operator is make_tridiagonal_operator:\n\t        matrix = jnp.eye(4)\n\t        tags = lx.tridiagonal_tag\n\t        in_size = out_size = 4\n\t    else:\n\t        matrix = jr.normal(getkey(), (3, 5))\n\t        tags = ()\n\t        in_size = 5\n", "        out_size = 3\n\t    operator = make_operator(matrix, tags)\n\t    in_structure = jax.ShapeDtypeStruct((in_size,), jnp.float64)\n\t    out_structure = jax.ShapeDtypeStruct((out_size,), jnp.float64)\n\t    assert shaped_allclose(in_structure, operator.in_structure())\n\t    assert shaped_allclose(out_structure, operator.out_structure())\n\tdef _setup(matrix, tag: Union[object, frozenset[object]] = frozenset()):\n\t    for make_operator in make_operators:\n\t        if make_operator is make_diagonal_operator and tag != lx.diagonal_tag:\n\t            continue\n", "        if make_operator is make_tridiagonal_operator and tag not in (\n\t            lx.tridiagonal_tag,\n\t            lx.diagonal_tag,\n\t            lx.symmetric_tag,\n\t        ):\n\t            continue\n\t        operator = make_operator(matrix, tag)\n\t        yield operator\n\tdef _assert_except_diag(cond_fun, operators, flip_cond):\n\t    if flip_cond:\n", "        _cond_fun = cond_fun\n\t        cond_fun = lambda x: not _cond_fun(x)\n\t    for operator in operators:\n\t        if isinstance(operator, lx.DiagonalLinearOperator):\n\t            assert not cond_fun(operator)\n\t        else:\n\t            assert cond_fun(operator)\n\tdef test_linearise(getkey):\n\t    operators = _setup(jr.normal(getkey(), (3, 3)))\n\t    for operator in operators:\n", "        lx.linearise(operator)\n\tdef test_materialise(getkey):\n\t    operators = _setup(jr.normal(getkey(), (3, 3)))\n\t    for operator in operators:\n\t        lx.materialise(operator)\n\tdef test_diagonal(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    matrix_diag = jnp.diag(matrix)\n\t    operators = _setup(matrix)\n\t    for operator in operators:\n", "        assert jnp.allclose(lx.diagonal(operator), matrix_diag)\n\tdef test_is_symmetric(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    symmetric_operators = _setup(matrix.T @ matrix, lx.symmetric_tag)\n\t    for operator in symmetric_operators:\n\t        assert lx.is_symmetric(operator)\n\t    not_symmetric_operators = _setup(matrix)\n\t    _assert_except_diag(lx.is_symmetric, not_symmetric_operators, flip_cond=True)\n\tdef test_is_diagonal(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n", "    diagonal_operators = _setup(jnp.diag(jnp.diag(matrix)), lx.diagonal_tag)\n\t    for operator in diagonal_operators:\n\t        assert lx.is_diagonal(operator)\n\t    not_diagonal_operators = _setup(matrix)\n\t    _assert_except_diag(lx.is_diagonal, not_diagonal_operators, flip_cond=True)\n\tdef test_has_unit_diagonal(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    not_unit_diagonal = _setup(matrix)\n\t    for operator in not_unit_diagonal:\n\t        assert not lx.has_unit_diagonal(operator)\n", "    matrix_unit_diag = matrix.at[jnp.arange(3), jnp.arange(3)].set(1)\n\t    unit_diagonal = _setup(matrix_unit_diag, lx.unit_diagonal_tag)\n\t    _assert_except_diag(lx.has_unit_diagonal, unit_diagonal, flip_cond=False)\n\tdef test_is_lower_triangular(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    lower_triangular = _setup(jnp.tril(matrix), lx.lower_triangular_tag)\n\t    for operator in lower_triangular:\n\t        assert lx.is_lower_triangular(operator)\n\t    not_lower_triangular = _setup(matrix)\n\t    _assert_except_diag(lx.is_lower_triangular, not_lower_triangular, flip_cond=True)\n", "def test_is_upper_triangular(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    upper_triangular = _setup(jnp.triu(matrix), lx.upper_triangular_tag)\n\t    for operator in upper_triangular:\n\t        assert lx.is_upper_triangular(operator)\n\t    not_upper_triangular = _setup(matrix)\n\t    _assert_except_diag(lx.is_upper_triangular, not_upper_triangular, flip_cond=True)\n\tdef test_is_positive_semidefinite(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    not_positive_semidefinite = _setup(matrix)\n", "    for operator in not_positive_semidefinite:\n\t        assert not lx.is_positive_semidefinite(operator)\n\t    positive_semidefinite = _setup(matrix.T @ matrix, lx.positive_semidefinite_tag)\n\t    _assert_except_diag(\n\t        lx.is_positive_semidefinite, positive_semidefinite, flip_cond=False\n\t    )\n\tdef test_is_negative_semidefinite(getkey):\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    not_negative_semidefinite = _setup(matrix)\n\t    for operator in not_negative_semidefinite:\n", "        assert not lx.is_negative_semidefinite(operator)\n\t    negative_semidefinite = _setup(-matrix.T @ matrix, lx.negative_semidefinite_tag)\n\t    _assert_except_diag(\n\t        lx.is_negative_semidefinite, negative_semidefinite, flip_cond=False\n\t    )\n\tdef test_is_tridiagonal(getkey):\n\t    diag1 = jr.normal(getkey(), (5,))\n\t    diag2 = jr.normal(getkey(), (4,))\n\t    diag3 = jr.normal(getkey(), (4,))\n\t    op1 = lx.TridiagonalLinearOperator(diag1, diag2, diag3)\n", "    op2 = lx.IdentityLinearOperator(jax.eval_shape(lambda: diag1))\n\t    op3 = lx.MatrixLinearOperator(jnp.diag(diag1))\n\t    assert lx.is_tridiagonal(op1)\n\t    assert lx.is_tridiagonal(op2)\n\t    assert not lx.is_tridiagonal(op3)\n\tdef test_tangent_as_matrix(getkey):\n\t    def _list_setup(matrix):\n\t        return list(_setup(matrix))\n\t    matrix = jr.normal(getkey(), (3, 3))\n\t    t_matrix = jr.normal(getkey(), (3, 3))\n", "    operators, t_operators = eqx.filter_jvp(_list_setup, (matrix,), (t_matrix,))\n\t    for operator, t_operator in zip(operators, t_operators):\n\t        t_operator = lx.TangentLinearOperator(operator, t_operator)\n\t        if isinstance(operator, lx.DiagonalLinearOperator):\n\t            assert jnp.allclose(operator.as_matrix(), jnp.diag(jnp.diag(matrix)))\n\t            assert jnp.allclose(t_operator.as_matrix(), jnp.diag(jnp.diag(t_matrix)))\n\t        else:\n\t            assert jnp.allclose(operator.as_matrix(), matrix)\n\t            assert jnp.allclose(t_operator.as_matrix(), t_matrix)\n\tdef test_materialise_function_linear_operator(getkey):\n", "    x = (jr.normal(getkey(), (5, 9)), jr.normal(getkey(), (3,)))\n\t    input_structure = jax.eval_shape(lambda: x)\n\t    fn = lambda x: {\"a\": jnp.broadcast_to(jnp.sum(x[0]), (1, 2))}\n\t    output_structure = jax.eval_shape(fn, input_structure)\n\t    operator = lx.FunctionLinearOperator(fn, input_structure)\n\t    materialised_operator = lx.materialise(operator)\n\t    assert materialised_operator.in_structure() == input_structure\n\t    assert materialised_operator.out_structure() == output_structure\n\t    assert isinstance(materialised_operator, lx.PyTreeLinearOperator)\n\t    expected_struct = {\n", "        \"a\": (\n\t            jax.ShapeDtypeStruct((1, 2, 5, 9), jnp.float64),\n\t            jax.ShapeDtypeStruct((1, 2, 3), jnp.float64),\n\t        )\n\t    }\n\t    assert jax.eval_shape(lambda: materialised_operator.pytree) == expected_struct\n\tdef test_pytree_transpose(getkey):\n\t    out_struct = jax.eval_shape(lambda: ({\"a\": jnp.zeros((2, 3, 3))}, jnp.zeros((2,))))\n\t    in_struct = jax.eval_shape(lambda: {\"b\": jnp.zeros((4,))})\n\t    leaf1 = jr.normal(getkey(), (2, 3, 3, 4))\n", "    leaf2 = jr.normal(getkey(), (2, 4))\n\t    pytree = ({\"a\": {\"b\": leaf1}}, {\"b\": leaf2})\n\t    operator = lx.PyTreeLinearOperator(pytree, out_struct)\n\t    assert operator.in_structure() == in_struct\n\t    assert operator.out_structure() == out_struct\n\t    leaf1_T = jnp.moveaxis(leaf1, -1, 0)\n\t    leaf2_T = jnp.moveaxis(leaf2, -1, 0)\n\t    pytree_T = {\"b\": ({\"a\": leaf1_T}, leaf2_T)}\n\t    operator_T = operator.T\n\t    assert operator_T.in_structure() == out_struct\n", "    assert operator_T.out_structure() == in_struct\n\t    assert eqx.tree_equal(operator_T.pytree, pytree_T)\n"]}
{"filename": "tests/test_jvp.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\timport equinox as eqx\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n\tfrom .helpers import (\n", "    construct_matrix,\n\t    construct_singular_matrix,\n\t    finite_difference_jvp,\n\t    has_tag,\n\t    make_jac_operator,\n\t    make_matrix_operator,\n\t    shaped_allclose,\n\t    solvers_tags_pseudoinverse,\n\t)\n\t@pytest.mark.parametrize(\"make_operator\", (make_matrix_operator, make_jac_operator))\n", "@pytest.mark.parametrize(\"solver, tags, pseudoinverse\", solvers_tags_pseudoinverse)\n\t@pytest.mark.parametrize(\"use_state\", (True, False))\n\t@pytest.mark.parametrize(\n\t    \"make_matrix\",\n\t    (\n\t        construct_matrix,\n\t        construct_singular_matrix,\n\t    ),\n\t)\n\tdef test_jvp(\n", "    getkey, solver, tags, pseudoinverse, make_operator, use_state, make_matrix\n\t):\n\t    t_tags = (None,) * len(tags) if isinstance(tags, tuple) else None\n\t    if (make_matrix is construct_matrix) or pseudoinverse:\n\t        matrix, t_matrix = make_matrix(getkey, solver, tags, num=2)\n\t        out_size, _ = matrix.shape\n\t        vec = jr.normal(getkey(), (out_size,))\n\t        t_vec = jr.normal(getkey(), (out_size,))\n\t        if has_tag(tags, lx.unit_diagonal_tag):\n\t            # For all the other tags, A + εB with A, B \\in {matrices satisfying the tag}\n", "            # still satisfies the tag itself.\n\t            # This is the exception.\n\t            t_matrix.at[jnp.arange(3), jnp.arange(3)].set(0)\n\t        operator, t_operator = eqx.filter_jvp(\n\t            make_operator, (matrix, tags), (t_matrix, t_tags)\n\t        )\n\t        if use_state:\n\t            state = solver.init(operator, options={})\n\t            linear_solve = ft.partial(lx.linear_solve, state=state)\n\t        else:\n", "            linear_solve = lx.linear_solve\n\t        solve_vec_only = lambda v: linear_solve(operator, v, solver).value\n\t        solve_op_only = lambda op: linear_solve(op, vec, solver).value\n\t        solve_op_vec = lambda op, v: linear_solve(op, v, solver).value\n\t        vec_out, t_vec_out = eqx.filter_jvp(solve_vec_only, (vec,), (t_vec,))\n\t        op_out, t_op_out = eqx.filter_jvp(solve_op_only, (operator,), (t_operator,))\n\t        op_vec_out, t_op_vec_out = eqx.filter_jvp(\n\t            solve_op_vec,\n\t            (operator, vec),\n\t            (t_operator, t_vec),\n", "        )\n\t        (expected_op_out, *_), (t_expected_op_out, *_) = eqx.filter_jvp(\n\t            lambda op: jnp.linalg.lstsq(op, vec), (matrix,), (t_matrix,)\n\t        )\n\t        (expected_op_vec_out, *_), (t_expected_op_vec_out, *_) = eqx.filter_jvp(\n\t            jnp.linalg.lstsq, (matrix, vec), (t_matrix, t_vec)\n\t        )\n\t        # Work around JAX issue #14868.\n\t        if jnp.any(jnp.isnan(t_expected_op_out)):\n\t            _, (t_expected_op_out, *_) = finite_difference_jvp(\n", "                lambda op: jnp.linalg.lstsq(op, vec), (matrix,), (t_matrix,)\n\t            )\n\t        if jnp.any(jnp.isnan(t_expected_op_vec_out)):\n\t            _, (t_expected_op_vec_out, *_) = finite_difference_jvp(\n\t                jnp.linalg.lstsq, (matrix, vec), (t_matrix, t_vec)\n\t            )\n\t        pinv_matrix = jnp.linalg.pinv(matrix)\n\t        expected_vec_out = pinv_matrix @ vec\n\t        assert shaped_allclose(vec_out, expected_vec_out)\n\t        assert shaped_allclose(op_out, expected_op_out)\n", "        assert shaped_allclose(op_vec_out, expected_op_vec_out)\n\t        t_expected_vec_out = pinv_matrix @ t_vec\n\t        assert shaped_allclose(\n\t            matrix @ t_vec_out, matrix @ t_expected_vec_out, rtol=1e-3\n\t        )\n\t        assert shaped_allclose(t_op_out, t_expected_op_out, rtol=1e-3)\n\t        assert shaped_allclose(t_op_vec_out, t_expected_op_vec_out, rtol=1e-3)\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport dataclasses\n\timport random\n\timport jax\n\timport jax.random as jr\n\timport pytest\n\tjax.config.update(\"jax_enable_x64\", True)\n\t# This offers reproducability -- the initial seed is printed in the repr so we can see\n", "# it when a test fails.\n\t# Note the `eq=False`, which means that `_GetKey `objects have `__eq__` and `__hash__`\n\t# based on object identity.\n\t@dataclasses.dataclass(eq=False)\n\tclass _GetKey:\n\t    seed: int\n\t    call: int\n\t    key: jr.PRNGKeyArray\n\t    def __init__(self, seed: int):\n\t        self.seed = seed\n", "        self.call = 0\n\t        self.key = jr.PRNGKey(seed)\n\t    def __call__(self):\n\t        self.call += 1\n\t        return jr.fold_in(self.key, self.call)\n\t@pytest.fixture\n\tdef getkey():\n\t    return _GetKey(random.randint(0, 2**31 - 1))\n"]}
{"filename": "tests/helpers.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\timport math\n\timport operator\n\timport random\n\timport equinox.internal as eqxi\n\timport jax\n\timport jax.numpy as jnp\n", "import jax.random as jr\n\timport jax.tree_util as jtu\n\timport numpy as np\n\tfrom equinox.internal import ω\n\timport lineax as lx\n\tdef getkey():\n\t    return jr.PRNGKey(random.randint(0, 2**31 - 1))\n\t@ft.lru_cache(maxsize=None)\n\tdef _construct_matrix_impl(getkey, cond_cutoff, tags, size):\n\t    while True:\n", "        matrix = jr.normal(getkey(), (size, size))\n\t        if has_tag(tags, lx.diagonal_tag):\n\t            matrix = jnp.diag(jnp.diag(matrix))\n\t        if has_tag(tags, lx.symmetric_tag):\n\t            matrix = matrix + matrix.T\n\t        if has_tag(tags, lx.lower_triangular_tag):\n\t            matrix = jnp.tril(matrix)\n\t        if has_tag(tags, lx.upper_triangular_tag):\n\t            matrix = jnp.triu(matrix)\n\t        if has_tag(tags, lx.unit_diagonal_tag):\n", "            matrix = matrix.at[jnp.arange(size), jnp.arange(size)].set(1)\n\t        if has_tag(tags, lx.tridiagonal_tag):\n\t            diagonal = jnp.diag(jnp.diag(matrix))\n\t            upper_diagonal = jnp.diag(jnp.diag(matrix, k=1), k=1)\n\t            lower_diagonal = jnp.diag(jnp.diag(matrix, k=-1), k=-1)\n\t            matrix = lower_diagonal + diagonal + upper_diagonal\n\t        if has_tag(tags, lx.positive_semidefinite_tag):\n\t            matrix = matrix @ matrix.T\n\t        if has_tag(tags, lx.negative_semidefinite_tag):\n\t            matrix = -matrix @ matrix.T\n", "        if eqxi.unvmap_all(jnp.linalg.cond(matrix) < cond_cutoff):\n\t            break\n\t    return matrix\n\tdef construct_matrix(getkey, solver, tags, num=1, *, size=3):\n\t    if isinstance(solver, lx.NormalCG):\n\t        cond_cutoff = math.sqrt(1000)\n\t    else:\n\t        cond_cutoff = 1000\n\t    return tuple(\n\t        _construct_matrix_impl(getkey, cond_cutoff, tags, size) for _ in range(num)\n", "    )\n\tdef construct_singular_matrix(getkey, solver, tags, num=1):\n\t    matrices = construct_matrix(getkey, solver, tags, num)\n\t    if isinstance(solver, (lx.Diagonal, lx.CG, lx.BiCGStab, lx.GMRES)):\n\t        return tuple(matrix.at[0, :].set(0) for matrix in matrices)\n\t    else:\n\t        version = random.choice([0, 1, 2])\n\t        if version == 0:\n\t            return tuple(matrix.at[0, :].set(0) for matrix in matrices)\n\t        elif version == 1:\n", "            return tuple(matrix[1:, :] for matrix in matrices)\n\t        else:\n\t            return tuple(matrix[:, 1:] for matrix in matrices)\n\tif jax.config.jax_enable_x64:  # pyright: ignore\n\t    tol = 1e-12\n\telse:\n\t    tol = 1e-6\n\tsolvers_tags_pseudoinverse = [\n\t    (lx.AutoLinearSolver(well_posed=True), (), False),\n\t    (lx.AutoLinearSolver(well_posed=False), (), True),\n", "    (lx.Triangular(), lx.lower_triangular_tag, False),\n\t    (lx.Triangular(), lx.upper_triangular_tag, False),\n\t    (lx.Triangular(), (lx.lower_triangular_tag, lx.unit_diagonal_tag), False),\n\t    (lx.Triangular(), (lx.upper_triangular_tag, lx.unit_diagonal_tag), False),\n\t    (lx.Diagonal(), lx.diagonal_tag, False),\n\t    (lx.Diagonal(), (lx.diagonal_tag, lx.unit_diagonal_tag), False),\n\t    (lx.Tridiagonal(), lx.tridiagonal_tag, False),\n\t    (lx.LU(), (), False),\n\t    (lx.QR(), (), False),\n\t    (lx.SVD(), (), True),\n", "    (lx.BiCGStab(rtol=tol, atol=tol), (), False),\n\t    (lx.GMRES(rtol=tol, atol=tol), (), False),\n\t    (lx.NormalCG(rtol=tol, atol=tol), (), False),\n\t    (lx.CG(rtol=tol, atol=tol), lx.positive_semidefinite_tag, False),\n\t    (lx.CG(rtol=tol, atol=tol), lx.negative_semidefinite_tag, False),\n\t    (lx.NormalCG(rtol=tol, atol=tol), lx.negative_semidefinite_tag, False),\n\t    (lx.Cholesky(), lx.positive_semidefinite_tag, False),\n\t    (lx.Cholesky(), lx.negative_semidefinite_tag, False),\n\t]\n\tsolvers_tags = [(a, b) for a, b, _ in solvers_tags_pseudoinverse]\n", "solvers = [a for a, _, _ in solvers_tags_pseudoinverse]\n\tpseudosolvers_tags = [(a, b) for a, b, c in solvers_tags_pseudoinverse if c]\n\tdef _transpose(operator, matrix):\n\t    return operator.T, matrix.T\n\tdef _linearise(operator, matrix):\n\t    return lx.linearise(operator), matrix\n\tdef _materialise(operator, matrix):\n\t    return lx.materialise(operator), matrix\n\tops = (lambda x, y: (x, y), _transpose, _linearise, _materialise)\n\tdef params(only_pseudo):\n", "    for make_operator in make_operators:\n\t        for solver, tags, pseudoinverse in solvers_tags_pseudoinverse:\n\t            if only_pseudo and not pseudoinverse:\n\t                continue\n\t            if make_operator is make_diagonal_operator and tags != lx.diagonal_tag:\n\t                continue\n\t            if (\n\t                make_operator is make_tridiagonal_operator\n\t                and tags != lx.tridiagonal_tag\n\t            ):\n", "                continue\n\t            yield make_operator, solver, tags\n\tdef _shaped_allclose(x, y, **kwargs):\n\t    if type(x) is not type(y):\n\t        return False\n\t    if isinstance(x, jax.Array):\n\t        x = np.asarray(x)\n\t        y = np.asarray(y)\n\t    if isinstance(x, np.ndarray):\n\t        if np.issubdtype(x.dtype, np.inexact):\n", "            return (\n\t                x.shape == y.shape\n\t                and x.dtype == y.dtype\n\t                and np.allclose(x, y, **kwargs)\n\t            )\n\t        else:\n\t            return x.shape == y.shape and x.dtype == y.dtype and np.all(x == y)\n\t    elif isinstance(x, jax.ShapeDtypeStruct):\n\t        assert x.shape == y.shape and x.dtype == y.dtype\n\t    else:\n", "        return x == y\n\tdef shaped_allclose(x, y, **kwargs):\n\t    \"\"\"As `jnp.allclose`, except:\n\t    - It also supports PyTree arguments.\n\t    - It mandates that shapes match as well (no broadcasting)\n\t    \"\"\"\n\t    same_structure = jtu.tree_structure(x) == jtu.tree_structure(y)\n\t    allclose = ft.partial(_shaped_allclose, **kwargs)\n\t    return same_structure and jtu.tree_reduce(\n\t        operator.and_, jtu.tree_map(allclose, x, y), True\n", "    )\n\tdef has_tag(tags, tag):\n\t    return tag is tags or (isinstance(tags, tuple) and tag in tags)\n\tmake_operators = []\n\tdef _operators_append(x):\n\t    make_operators.append(x)\n\t    return x\n\t@_operators_append\n\tdef make_matrix_operator(matrix, tags):\n\t    return lx.MatrixLinearOperator(matrix, tags)\n", "@_operators_append\n\tdef make_trivial_pytree_operator(matrix, tags):\n\t    out_size, _ = matrix.shape\n\t    struct = jax.ShapeDtypeStruct((out_size,), matrix.dtype)\n\t    return lx.PyTreeLinearOperator(matrix, struct, tags)\n\t@_operators_append\n\tdef make_function_operator(matrix, tags):\n\t    fn = lambda x: matrix @ x\n\t    _, in_size = matrix.shape\n\t    in_struct = jax.ShapeDtypeStruct((in_size,), matrix.dtype)\n", "    return lx.FunctionLinearOperator(fn, in_struct, tags)\n\t@_operators_append\n\tdef make_jac_operator(matrix, tags):\n\t    out_size, in_size = matrix.shape\n\t    x = jr.normal(getkey(), (in_size,))\n\t    a = jr.normal(getkey(), (out_size,))\n\t    b = jr.normal(getkey(), (out_size, in_size))\n\t    c = jr.normal(getkey(), (out_size, in_size))\n\t    fn_tmp = lambda x, _: a + b @ x + c @ x**2\n\t    jac = jax.jacfwd(fn_tmp)(x, None)\n", "    diff = matrix - jac\n\t    fn = lambda x, _: a + (b + diff) @ x + c @ x**2\n\t    return lx.JacobianLinearOperator(fn, x, None, tags)\n\t@_operators_append\n\tdef make_diagonal_operator(matrix, tags):\n\t    assert tags == lx.diagonal_tag\n\t    diag = jnp.diag(matrix)\n\t    return lx.DiagonalLinearOperator(diag)\n\t@_operators_append\n\tdef make_tridiagonal_operator(matrix, tags):\n", "    diag1 = jnp.diag(matrix)\n\t    if tags == lx.tridiagonal_tag:\n\t        diag2 = jnp.diag(matrix, k=-1)\n\t        diag3 = jnp.diag(matrix, k=1)\n\t        return lx.TridiagonalLinearOperator(diag1, diag2, diag3)\n\t    elif tags == lx.diagonal_tag:\n\t        diag2 = diag3 = jnp.zeros(matrix.shape[0] - 1)\n\t        return lx.TaggedLinearOperator(\n\t            lx.TridiagonalLinearOperator(diag1, diag2, diag3), lx.diagonal_tag\n\t        )\n", "    elif tags == lx.symmetric_tag:\n\t        diag2 = diag3 = jnp.diag(matrix, k=1)\n\t        return lx.TaggedLinearOperator(\n\t            lx.TridiagonalLinearOperator(diag1, diag2, diag3), lx.symmetric_tag\n\t        )\n\t    else:\n\t        assert False, tags\n\t@_operators_append\n\tdef make_add_operator(matrix, tags):\n\t    matrix1 = 0.7 * matrix\n", "    matrix2 = 0.3 * matrix\n\t    operator = make_matrix_operator(matrix1, ()) + make_function_operator(matrix2, ())\n\t    return lx.TaggedLinearOperator(operator, tags)\n\t@_operators_append\n\tdef make_mul_operator(matrix, tags):\n\t    operator = make_jac_operator(0.7 * matrix, ()) / 0.7\n\t    return lx.TaggedLinearOperator(operator, tags)\n\t@_operators_append\n\tdef make_composed_operator(matrix, tags):\n\t    _, size = matrix.shape\n", "    diag = jr.normal(getkey(), (size,))\n\t    diag = jnp.where(jnp.abs(diag) < 0.05, 0.8, diag)\n\t    operator1 = make_trivial_pytree_operator(matrix / diag, ())\n\t    operator2 = lx.DiagonalLinearOperator(diag)\n\t    return lx.TaggedLinearOperator(operator1 @ operator2, tags)\n\t# Slightly sketchy approach to finite differences, in that this is pulled out of\n\t# Numerical Recipes.\n\t# I also don't know of a handling of the JVP case off the top of my head -- although\n\t# I'm sure it exists somewhere -- so I'm improvising a little here. (In particular\n\t# removing the usual \"(x + h) - x\" denominator.)\n", "def finite_difference_jvp(fn, primals, tangents):\n\t    out = fn(*primals)\n\t    # Choose ε to trade-off truncation error and floating-point rounding error.\n\t    max_leaves = [jnp.max(jnp.abs(p)) for p in jtu.tree_leaves(primals)] + [1]\n\t    scale = jnp.max(jnp.stack(max_leaves))\n\t    ε = np.sqrt(np.finfo(np.float64).eps) * scale\n\t    primals_ε = (ω(primals) + ε * ω(tangents)).ω\n\t    out_ε = fn(*primals_ε)\n\t    tangents_out = jtu.tree_map(lambda x, y: (x - y) / ε, out_ε, out)\n\t    return out, tangents_out\n"]}
{"filename": "tests/test_vmap_vmap.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport equinox as eqx\n\timport equinox.internal as eqxi\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n\tfrom .helpers import (\n", "    construct_matrix,\n\t    construct_singular_matrix,\n\t    make_jac_operator,\n\t    make_matrix_operator,\n\t    shaped_allclose,\n\t    solvers_tags_pseudoinverse,\n\t)\n\t@pytest.mark.parametrize(\"make_operator\", (make_matrix_operator, make_jac_operator))\n\t@pytest.mark.parametrize(\"solver, tags, pseudoinverse\", solvers_tags_pseudoinverse)\n\t@pytest.mark.parametrize(\"use_state\", (True, False))\n", "@pytest.mark.parametrize(\n\t    \"make_matrix\",\n\t    (\n\t        construct_matrix,\n\t        construct_singular_matrix,\n\t    ),\n\t)\n\tdef test_vmap_vmap(\n\t    getkey, make_operator, solver, tags, pseudoinverse, use_state, make_matrix\n\t):\n", "    if (make_matrix is construct_matrix) or pseudoinverse:\n\t        # combinations with nontrivial application across both vmaps\n\t        axes = [\n\t            (eqx.if_array(0), eqx.if_array(0), None, None),\n\t            (None, None, 0, 0),\n\t            (eqx.if_array(0), eqx.if_array(0), None, 0),\n\t            (eqx.if_array(0), eqx.if_array(0), 0, 0),\n\t            (None, eqx.if_array(0), 0, 0),\n\t        ]\n\t        for vmap2_op, vmap1_op, vmap2_vec, vmap1_vec in axes:\n", "            if vmap1_op is not None:\n\t                axis_size1 = 10\n\t                out_axis1 = eqx.if_array(0)\n\t            else:\n\t                axis_size1 = None\n\t                out_axis1 = None\n\t            if vmap2_op is not None:\n\t                axis_size2 = 10\n\t                out_axis2 = eqx.if_array(0)\n\t            else:\n", "                axis_size2 = None\n\t                out_axis2 = None\n\t            (matrix,) = eqx.filter_vmap(\n\t                eqx.filter_vmap(make_matrix, axis_size=axis_size1, out_axes=out_axis1),\n\t                axis_size=axis_size2,\n\t                out_axes=out_axis2,\n\t            )(getkey, solver, tags)\n\t            if vmap1_op is not None:\n\t                if vmap2_op is not None:\n\t                    _, _, out_size, _ = matrix.shape\n", "                else:\n\t                    _, out_size, _ = matrix.shape\n\t            else:\n\t                out_size, _ = matrix.shape\n\t            if vmap1_vec is None:\n\t                vec = jr.normal(getkey(), (out_size,))\n\t            elif (vmap1_vec is not None) and (vmap2_vec is None):\n\t                vec = jr.normal(getkey(), (10, out_size))\n\t            else:\n\t                vec = jr.normal(getkey(), (10, 10, out_size))\n", "            operator = eqx.filter_vmap(\n\t                eqx.filter_vmap(\n\t                    make_operator,\n\t                    in_axes=vmap1_op,\n\t                    out_axes=out_axis1,\n\t                ),\n\t                in_axes=vmap2_op,\n\t                out_axes=out_axis2,\n\t            )(matrix, tags)\n\t            if use_state:\n", "                def linear_solve(operator, vector):\n\t                    state = solver.init(operator, options={})\n\t                    return lx.linear_solve(operator, vector, state=state, solver=solver)\n\t            else:\n\t                def linear_solve(operator, vector):\n\t                    return lx.linear_solve(operator, vector, solver)\n\t            as_matrix_vmapped = eqx.filter_vmap(\n\t                eqx.filter_vmap(\n\t                    lambda x: x.as_matrix(),\n\t                    in_axes=vmap1_op,\n", "                    out_axes=eqxi.if_mapped(0),\n\t                ),\n\t                in_axes=vmap2_op,\n\t                out_axes=eqxi.if_mapped(0),\n\t            )(operator)\n\t            vmap1_axes = (vmap1_op, vmap1_vec)\n\t            vmap2_axes = (vmap2_op, vmap2_vec)\n\t            result = eqx.filter_vmap(\n\t                eqx.filter_vmap(linear_solve, in_axes=vmap1_axes), in_axes=vmap2_axes\n\t            )(operator, vec).value\n", "            solve_with = lambda x: eqx.filter_vmap(\n\t                eqx.filter_vmap(x, in_axes=vmap1_axes), in_axes=vmap2_axes\n\t            )(as_matrix_vmapped, vec)\n\t            if make_matrix is construct_singular_matrix:\n\t                true_result, _, _, _ = solve_with(jnp.linalg.lstsq)\n\t            else:\n\t                true_result = solve_with(jnp.linalg.solve)\n\t            assert shaped_allclose(result, true_result, rtol=1e-3)\n"]}
{"filename": "tests/test_solve.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport pytest\n\timport lineax as lx\n\tfrom .helpers import shaped_allclose\n\tdef test_gmres_large_dense(getkey):\n", "    if jax.config.jax_enable_x64:  # pyright: ignore\n\t        tol = 1e-10\n\t    else:\n\t        tol = 1e-4\n\t    solver = lx.GMRES(atol=tol, rtol=tol, restart=100)\n\t    matrix = jr.normal(getkey(), (100, 100))\n\t    operator = lx.MatrixLinearOperator(matrix)\n\t    true_x = jr.normal(getkey(), (100,))\n\t    b = matrix @ true_x\n\t    lx_soln = lx.linear_solve(operator, b, solver).value\n", "    assert shaped_allclose(lx_soln, true_x, atol=tol, rtol=tol)\n\tdef test_nontrivial_pytree_operator():\n\t    x = [[1, 5.0], [jnp.array(-2), jnp.array(-2.0)]]\n\t    y = [3, 4]\n\t    struct = jax.eval_shape(lambda: y)\n\t    operator = lx.PyTreeLinearOperator(x, struct)\n\t    out = lx.linear_solve(operator, y).value\n\t    true_out = [jnp.array(-3.25), jnp.array(1.25)]\n\t    assert shaped_allclose(out, true_out)\n\t@pytest.mark.parametrize(\"solver\", (lx.LU(), lx.QR(), lx.SVD()))\n", "def test_mixed_dtypes(solver):\n\t    f32 = lambda x: jnp.array(x, dtype=jnp.float32)\n\t    f64 = lambda x: jnp.array(x, dtype=jnp.float64)\n\t    x = [[f32(1), f64(5)], [f32(-2), f64(-2)]]\n\t    y = [f64(3), f64(4)]\n\t    struct = jax.eval_shape(lambda: y)\n\t    operator = lx.PyTreeLinearOperator(x, struct)\n\t    out = lx.linear_solve(operator, y, solver=solver).value\n\t    true_out = [f32(-3.25), f64(1.25)]\n\t    assert shaped_allclose(out, true_out)\n", "def test_mixed_dtypes_triangular():\n\t    f32 = lambda x: jnp.array(x, dtype=jnp.float32)\n\t    f64 = lambda x: jnp.array(x, dtype=jnp.float64)\n\t    x = [[f32(1), f64(0)], [f32(-2), f64(-2)]]\n\t    y = [f64(3), f64(4)]\n\t    struct = jax.eval_shape(lambda: y)\n\t    operator = lx.PyTreeLinearOperator(x, struct, lx.lower_triangular_tag)\n\t    out = lx.linear_solve(operator, y, solver=lx.Triangular()).value\n\t    true_out = [f32(3), f64(-5)]\n\t    assert shaped_allclose(out, true_out)\n", "def test_ad_closure_function_linear_operator(getkey):\n\t    def f(x, z):\n\t        def fn(y):\n\t            return x * y\n\t        op = lx.FunctionLinearOperator(fn, jax.eval_shape(lambda: z))\n\t        sol = lx.linear_solve(op, z).value\n\t        return jnp.sum(sol), sol\n\t    x = jr.normal(getkey(), (3,))\n\t    x = jnp.where(jnp.abs(x) < 1e-6, 0.7, x)\n\t    z = jr.normal(getkey(), (3,))\n", "    grad, sol = jax.grad(f, has_aux=True)(x, z)\n\t    assert shaped_allclose(grad, -z / (x**2))\n\t    assert shaped_allclose(sol, z / x)\n"]}
{"filename": "lineax/_solve.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport abc\n\timport functools as ft\n\tfrom typing import Any, Generic, Optional, TypeVar\n\tfrom typing_extensions import TypeAlias\n\timport equinox as eqx\n\timport equinox.internal as eqxi\n\timport jax\n", "import jax.core\n\timport jax.interpreters.ad as ad\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n\timport jax.tree_util as jtu\n\tfrom equinox.internal import ω\n\tfrom jaxtyping import Array, ArrayLike, PyTree\n\tfrom ._custom_types import sentinel\n\tfrom ._misc import inexact_asarray\n\tfrom ._operator import (\n", "    AbstractLinearOperator,\n\t    IdentityLinearOperator,\n\t    is_diagonal,\n\t    is_lower_triangular,\n\t    is_negative_semidefinite,\n\t    is_positive_semidefinite,\n\t    is_tridiagonal,\n\t    is_upper_triangular,\n\t    linearise,\n\t    TangentLinearOperator,\n", ")\n\tfrom ._solution import RESULTS, Solution\n\t#\n\t# _linear_solve_p\n\t#\n\tdef _to_shapedarray(x):\n\t    if isinstance(x, jax.ShapeDtypeStruct):\n\t        return jax.core.ShapedArray(x.shape, x.dtype)\n\t    else:\n\t        return x\n", "def _to_struct(x):\n\t    if isinstance(x, jax.core.ShapedArray):\n\t        return jax.ShapeDtypeStruct(x.shape, x.dtype)\n\t    elif isinstance(x, jax.core.AbstractValue):\n\t        raise NotImplementedError(\n\t            \"`lineax.linear_solve` only supports working with JAX arrays; not \"\n\t            f\"other abstract values. Got abstract value {x}.\"\n\t        )\n\t    else:\n\t        return x\n", "def _assert_false(x):\n\t    assert False\n\tdef _is_none(x):\n\t    return x is None\n\tdef _sum(*args):\n\t    return sum(args)\n\tdef _linear_solve_impl(_, state, vector, options, solver, throw, *, check_closure):\n\t    out = solver.compute(state, vector, options)\n\t    if check_closure:\n\t        out = eqxi.nontraceable(\n", "            out, name=\"lineax.linear_solve with respect to a closed-over value\"\n\t        )\n\t    solution, result, stats = out\n\t    has_nonfinites = jnp.any(\n\t        jnp.stack(\n\t            [jnp.any(jnp.invert(jnp.isfinite(x))) for x in jtu.tree_leaves(solution)]\n\t        )\n\t    )\n\t    result = RESULTS.where(\n\t        (result == RESULTS.successful) & has_nonfinites,\n", "        RESULTS.singular,\n\t        result,\n\t    )\n\t    if throw:\n\t        solution, result, stats = result.error_if(\n\t            (solution, result, stats),\n\t            result != RESULTS.successful,\n\t        )\n\t    return solution, result, stats\n\t@eqxi.filter_primitive_def\n", "def _linear_solve_abstract_eval(operator, state, vector, options, solver, throw):\n\t    state, vector, options, solver = jtu.tree_map(\n\t        _to_struct, (state, vector, options, solver)\n\t    )\n\t    out = eqx.filter_eval_shape(\n\t        _linear_solve_impl,\n\t        operator,\n\t        state,\n\t        vector,\n\t        options,\n", "        solver,\n\t        throw,\n\t        check_closure=False,\n\t    )\n\t    out = jtu.tree_map(_to_shapedarray, out)\n\t    return out\n\t@eqxi.filter_primitive_jvp\n\tdef _linear_solve_jvp(primals, tangents):\n\t    operator, state, vector, options, solver, throw = primals\n\t    t_operator, t_state, t_vector, t_options, t_solver, t_throw = tangents\n", "    jtu.tree_map(_assert_false, (t_state, t_options, t_solver, t_throw))\n\t    del t_state, t_options, t_solver, t_throw\n\t    # Note that we pass throw=True unconditionally to all the tangent solves, as there\n\t    # is nowhere we can pipe their error to.\n\t    # This is the primal solve so we can respect the original `throw`.\n\t    solution, result, stats = eqxi.filter_primitive_bind(\n\t        linear_solve_p, operator, state, vector, options, solver, throw\n\t    )\n\t    #\n\t    # Consider the primal problem of linearly solving for x in Ax=b.\n", "    # Let ^ denote pseudoinverses, ᵀ denote transposes, and ' denote tangents.\n\t    # The linear_solve routine returns specifically the pseudoinverse solution, i.e.\n\t    #\n\t    # x = A^b\n\t    #\n\t    # Therefore x' = A^'b + A^b'\n\t    #\n\t    # Now A^' = -A^A'A^ + A^A^ᵀAᵀ'(I - AA^) + (I - A^A)Aᵀ'A^ᵀA^\n\t    #\n\t    # (Source: https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Derivative)\n", "    #\n\t    # This results in:\n\t    #\n\t    # x' = A^(-A'x + A^ᵀAᵀ'(b - Ax) - Ay + b') + y\n\t    #\n\t    # where\n\t    #\n\t    # y = Aᵀ'A^ᵀx\n\t    #\n\t    # note that if A has linearly independent columns, then the y - A^Ay\n", "    # term disappears and gives\n\t    #\n\t    # x' = A^(-A'x + A^ᵀAᵀ'(b - Ax) + b')\n\t    #\n\t    # and if A has linearly independent rows, then the A^A^ᵀAᵀ'(b - Ax) term\n\t    # disappears giving:\n\t    #\n\t    # x' = A^(-A'x - Ay + b') + y\n\t    #\n\t    # if A has linearly independent rows and columns, then A is nonsingular and\n", "    #\n\t    # x' = A^(-A'x + b')\n\t    vecs = []\n\t    sols = []\n\t    if any(t is not None for t in jtu.tree_leaves(t_vector, is_leaf=_is_none)):\n\t        # b' term\n\t        vecs.append(\n\t            jtu.tree_map(eqxi.materialise_zeros, vector, t_vector, is_leaf=_is_none)\n\t        )\n\t    if any(t is not None for t in jtu.tree_leaves(t_operator, is_leaf=_is_none)):\n", "        t_operator = TangentLinearOperator(operator, t_operator)\n\t        t_operator = linearise(t_operator)  # optimise for matvecs\n\t        # -A'x term\n\t        vec = (-t_operator.mv(solution) ** ω).ω\n\t        vecs.append(vec)\n\t        allow_dependent_rows = solver.allow_dependent_rows(operator)\n\t        allow_dependent_columns = solver.allow_dependent_columns(operator)\n\t        if allow_dependent_rows or allow_dependent_columns:\n\t            operator_transpose = operator.transpose()\n\t            t_operator_transpose = t_operator.transpose()\n", "        if allow_dependent_rows:\n\t            lst_sqr_diff = (vector**ω - operator.mv(solution) ** ω).ω\n\t            tmp = t_operator_transpose.mv(lst_sqr_diff)  # pyright: ignore\n\t            state_transpose, options_transpose = solver.transpose(state, options)\n\t            tmp, _, _ = eqxi.filter_primitive_bind(\n\t                linear_solve_p,\n\t                operator_transpose,  # pyright: ignore\n\t                state_transpose,\n\t                tmp,\n\t                options_transpose,\n", "                solver,\n\t                True,\n\t            )\n\t            vecs.append(tmp)\n\t        if allow_dependent_columns:\n\t            state_transpose, options_transpose = solver.transpose(state, options)\n\t            tmp1, _, _ = eqxi.filter_primitive_bind(\n\t                linear_solve_p,\n\t                operator_transpose,  # pyright: ignore\n\t                state_transpose,\n", "                solution,\n\t                options_transpose,\n\t                solver,\n\t                True,\n\t            )\n\t            tmp2 = t_operator_transpose.mv(tmp1)  # pyright: ignore\n\t            # tmp2 is the y term\n\t            tmp3 = operator.mv(tmp2)\n\t            tmp4 = (-(tmp3**ω)).ω\n\t            # tmp4 is the Ay term\n", "            vecs.append(tmp4)\n\t            sols.append(tmp2)\n\t    vecs = jtu.tree_map(_sum, *vecs)\n\t    # the A^ term at the very beginning\n\t    sol, _, _ = eqxi.filter_primitive_bind(\n\t        linear_solve_p, operator, state, vecs, options, solver, True\n\t    )\n\t    sols.append(sol)\n\t    t_solution = jtu.tree_map(_sum, *sols)\n\t    out = solution, result, stats\n", "    t_out = (\n\t        t_solution,\n\t        jtu.tree_map(lambda _: None, result),\n\t        jtu.tree_map(lambda _: None, stats),\n\t    )\n\t    return out, t_out\n\tdef _is_undefined(x):\n\t    return isinstance(x, ad.UndefinedPrimal)\n\tdef _assert_defined(x):\n\t    assert not _is_undefined(x)\n", "def _keep_undefined(v, ct):\n\t    if _is_undefined(v):\n\t        return ct\n\t    else:\n\t        return None\n\t@eqxi.filter_primitive_transpose\n\tdef _linear_solve_transpose(inputs, cts_out):\n\t    cts_solution, _, _ = cts_out\n\t    operator, state, vector, options, solver, _ = inputs\n\t    jtu.tree_map(\n", "        _assert_defined, (operator, state, options, solver), is_leaf=_is_undefined\n\t    )\n\t    operator_transpose = operator.transpose()\n\t    state_transpose, options_transpose = solver.transpose(state, options)\n\t    cts_vector, _, _ = eqxi.filter_primitive_bind(\n\t        linear_solve_p,\n\t        operator_transpose,\n\t        state_transpose,\n\t        cts_solution,\n\t        options_transpose,\n", "        solver,\n\t        True,  # throw=True unconditionally: nowhere to pipe result to.\n\t    )\n\t    cts_vector = jtu.tree_map(\n\t        _keep_undefined, vector, cts_vector, is_leaf=_is_undefined\n\t    )\n\t    operator_none = jtu.tree_map(lambda _: None, operator)\n\t    state_none = jtu.tree_map(lambda _: None, state)\n\t    options_none = jtu.tree_map(lambda _: None, options)\n\t    solver_none = jtu.tree_map(lambda _: None, solver)\n", "    throw_none = None\n\t    return operator_none, state_none, cts_vector, options_none, solver_none, throw_none\n\t# Call with `check_closure=False` so that the autocreated vmap rule works.\n\tlinear_solve_p = eqxi.create_vprim(\n\t    \"linear_solve\",\n\t    eqxi.filter_primitive_def(ft.partial(_linear_solve_impl, check_closure=False)),\n\t    _linear_solve_abstract_eval,\n\t    _linear_solve_jvp,\n\t    _linear_solve_transpose,\n\t)\n", "# Then rebind so that the impl rule catches leaked-in tracers.\n\tlinear_solve_p.def_impl(\n\t    eqxi.filter_primitive_def(ft.partial(_linear_solve_impl, check_closure=True))\n\t)\n\teqxi.register_impl_finalisation(linear_solve_p)\n\t#\n\t# linear_solve\n\t#\n\t_SolverState = TypeVar(\"_SolverState\")\n\tclass AbstractLinearSolver(eqx.Module, Generic[_SolverState]):\n", "    \"\"\"Abstract base class for all linear solvers.\"\"\"\n\t    @abc.abstractmethod\n\t    def init(\n\t        self, operator: AbstractLinearOperator, options: dict[str, Any]\n\t    ) -> _SolverState:\n\t        \"\"\"Do any initial computation on just the `operator`.\n\t        For example, an LU solver would compute the LU decomposition of the operator\n\t        (and this does not require knowing the vector yet).\n\t        It is common to need to solve the linear system `Ax=b` multiple times in\n\t        succession, with the same operator `A` and multiple vectors `b`. This method\n", "        improves efficiency by making it possible to re-use the computation performed\n\t        on just the operator.\n\t        !!! Example\n\t            ```python\n\t            operator = lx.MatrixLinearOperator(...)\n\t            vector1 = ...\n\t            vector2 = ...\n\t            solver = lx.LU()\n\t            state = solver.init(operator, options={})\n\t            solution1 = lx.linear_solve(operator, vector1, solver, state=state)\n", "            solution2 = lx.linear_solve(operator, vector2, solver, state=state)\n\t            ```\n\t        **Arguments:**\n\t        - `operator`: a linear operator.\n\t        - `options`: a dictionary of any extra options that the solver may wish to\n\t            accept.\n\t        **Returns:**\n\t        A PyTree of arbitrary Python objects.\n\t        \"\"\"\n\t    @abc.abstractmethod\n", "    def compute(\n\t        self, state: _SolverState, vector: PyTree[Array], options: dict[str, Any]\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        \"\"\"Solves a linear system.\n\t        **Arguments:**\n\t        - `state`: as returned from [`lineax.AbstractLinearSolver.init`][].\n\t        - `vector`: the vector to solve against.\n\t        - `options`: a dictionary of any extra options that the solver may wish to\n\t            accept. For example, [`lineax.CG`][] accepts a `preconditioner` option.\n\t        **Returns:**\n", "        A 3-tuple of:\n\t        - The solution to the linear system.\n\t        - An integer indicating the success or failure of the solve. This is an integer\n\t            which may be converted to a human-readable error message via\n\t            `lx.RESULTS[...]`.\n\t        - A dictionary of an extra statistics about the solve, e.g. the number of steps\n\t            taken.\n\t        \"\"\"\n\t    @abc.abstractmethod\n\t    def allow_dependent_columns(self, operator: AbstractLinearOperator) -> bool:\n", "        \"\"\"Does this method ever produce non-NaN outputs for operators with linearly\n\t        dependent columns? (Even if only sometimes.)\n\t        If `True` then a more expensive backward pass is needed, to account for the\n\t        extra generality.\n\t        If you do not need to autodifferentiate through a custom linear solver then you\n\t        simply define this method as\n\t        ```python\n\t        class MyLinearSolver(AbstractLinearsolver):\n\t            def allow_dependent_columns(self, operator):\n\t                raise NotImplementedError\n", "        ```\n\t        **Arguments:**\n\t        - `operator`: a linear operator.\n\t        **Returns:**\n\t        Either `True` or `False`.\n\t        \"\"\"\n\t    @abc.abstractmethod\n\t    def allow_dependent_rows(self, operator: AbstractLinearOperator) -> bool:\n\t        \"\"\"Does this method ever produce non-NaN outputs for operators with\n\t        linearly dependent rows? (Even if only sometimes)\n", "        If `True` then a more expensive backward pass is needed, to account for the\n\t        extra generality.\n\t        If you do not need to autodifferentiate through a custom linear solver then you\n\t        simply define this method as\n\t        ```python\n\t        class MyLinearSolver(AbstractLinearsolver):\n\t            def allow_dependent_rows(self, operator):\n\t                raise NotImplementedError\n\t        ```\n\t        **Arguments:**\n", "        - `operator`: a linear operator.\n\t        **Returns:**\n\t        Either `True` or `False`.\n\t        \"\"\"\n\t    @abc.abstractmethod\n\t    def transpose(\n\t        self, state: _SolverState, options: dict[str, Any]\n\t    ) -> tuple[_SolverState, dict[str, Any]]:\n\t        \"\"\"Transposes the result of [`lineax.AbstractLinearSolver.init`][].\n\t        That is, it should be the case that\n", "        ```python\n\t        state_transpose, _ = solver.transpose(solver.init(operator, options), options)\n\t        state_transpose2 = solver.init(operator.T, options)\n\t        ```\n\t        must be identical to each other.\n\t        It is relatively common (in particular when differentiating through a linear\n\t        solve) to need to solve both `Ax = b` and `A^T x = b`. This method makes it\n\t        possible to avoid computing both `solver.init(operator)` and\n\t        `solver.init(operator.T)` if one can be cheaply computed from the other.\n\t        **Arguments:**\n", "        - `state`: as returned from `solver.init`.\n\t        - `options`: any extra options that were passed to `solve.init`.\n\t        **Returns:**\n\t        A 2-tuple of:\n\t        - The state of the transposed operator.\n\t        - The options for the transposed operator.\n\t        \"\"\"\n\t_qr_token = eqxi.str2jax(\"qr_token\")\n\t_diagonal_token = eqxi.str2jax(\"diagonal_token\")\n\t_well_posed_diagonal_token = eqxi.str2jax(\"well_posed_diagonal_token\")\n", "_tridiagonal_token = eqxi.str2jax(\"tridiagonal_token\")\n\t_triangular_token = eqxi.str2jax(\"triangular_token\")\n\t_cholesky_token = eqxi.str2jax(\"cholesky_token\")\n\t_lu_token = eqxi.str2jax(\"lu_token\")\n\t_svd_token = eqxi.str2jax(\"svd_token\")\n\t# Ugly delayed import because we have the dependency chain\n\t# linear_solve -> AutoLinearSolver -> {Cholesky,...} -> AbstractLinearSolver\n\t# but we want linear_solver and AbstractLinearSolver in the same file.\n\tdef _lookup(token) -> AbstractLinearSolver:\n\t    from . import _solver\n", "    _lookup_dict = {\n\t        _qr_token: _solver.QR(),\n\t        _diagonal_token: _solver.Diagonal(),\n\t        _well_posed_diagonal_token: _solver.Diagonal(well_posed=True),\n\t        _tridiagonal_token: _solver.Tridiagonal(),\n\t        _triangular_token: _solver.Triangular(),\n\t        _cholesky_token: _solver.Cholesky(),\n\t        _lu_token: _solver.LU(),\n\t        _svd_token: _solver.SVD(),\n\t    }\n", "    return _lookup_dict[token]\n\t_AutoLinearSolverState: TypeAlias = tuple[Any, Any]\n\tclass AutoLinearSolver(AbstractLinearSolver[_AutoLinearSolverState]):\n\t    \"\"\"Automatically determines a good linear solver based on the structure of the\n\t    operator.\n\t    - If `well_posed=True`:\n\t        - If the operator is diagonal, then use [`lineax.Diagonal`][].\n\t        - If the operator is tridiagonal, then use [`lineax.Tridiagonal`][].\n\t        - If the operator is triangular, then use [`lineax.Triangular`][].\n\t        - If the matrix is positive or negative definite, then use\n", "            [`lineax.Cholesky`][].\n\t        - Else use [`lineax.LU`][].\n\t    This is a good choice if you want to be certain that an error is raised for\n\t    ill-posed systems.\n\t    - If `well_posed=False`:\n\t        - If the operator is diagonal, then use [`lineax.Diagonal`][].\n\t        - Else use [`lineax.SVD`][].\n\t    This is a good choice if you want to be certain that you can handle ill-posed\n\t    systems.\n\t    - If `well_posed=None`:\n", "        - If the operator is non-square, then use [`lineax.QR`][].\n\t        - If the operator is diagonal, then use [`lineax.Diagonal`][].\n\t        - If the operator is tridiagonal, then use [`lineax.Tridiagonal`][].\n\t        - If the operator is triangular, then use [`lineax.Triangular`][].\n\t        - If the matrix is positive or negative definite, then use\n\t            [`lineax.Cholesky`][].\n\t        - Else, use [`lineax.LU`][].\n\t    This is a good choice if your primary concern is computational efficiency. It will\n\t    handle ill-posed systems as long as it is not computationally expensive to do so.\n\t    \"\"\"\n", "    well_posed: Optional[bool]\n\t    def _select_solver(self, operator: AbstractLinearOperator):\n\t        if self.well_posed is True:\n\t            if operator.in_size() != operator.out_size():\n\t                raise ValueError(\n\t                    \"Cannot use `AutoLinearSolver(well_posed=True)` with a non-square \"\n\t                    \"operator. If you are trying solve a least-squares problem then \"\n\t                    \"you should pass `solver=AutoLinearSolver(well_posed=False)`. By \"\n\t                    \"default `lineax.linear_solve` assumes that the operator is \"\n\t                    \"square and nonsingular.\"\n", "                )\n\t            if is_diagonal(operator):\n\t                token = _well_posed_diagonal_token\n\t            elif is_tridiagonal(operator):\n\t                token = _tridiagonal_token\n\t            elif is_lower_triangular(operator) or is_upper_triangular(operator):\n\t                token = _triangular_token\n\t            elif is_positive_semidefinite(operator) or is_negative_semidefinite(\n\t                operator\n\t            ):\n", "                token = _cholesky_token\n\t            else:\n\t                token = _lu_token\n\t        elif self.well_posed is False:\n\t            if is_diagonal(operator):\n\t                token = _diagonal_token\n\t            else:\n\t                # TODO: use rank-revealing QR instead.\n\t                token = _svd_token\n\t        elif self.well_posed is None:\n", "            if operator.in_size() != operator.out_size():\n\t                token = _qr_token\n\t            elif is_diagonal(operator):\n\t                token = _diagonal_token\n\t            elif is_tridiagonal(operator):\n\t                token = _tridiagonal_token\n\t            elif is_lower_triangular(operator) or is_upper_triangular(operator):\n\t                token = _triangular_token\n\t            elif is_positive_semidefinite(operator) or is_negative_semidefinite(\n\t                operator\n", "            ):\n\t                token = _cholesky_token\n\t            else:\n\t                token = _lu_token\n\t        else:\n\t            raise ValueError(f\"Invalid value `well_posed={self.well_posed}`.\")\n\t        return token\n\t    def select_solver(self, operator: AbstractLinearOperator) -> AbstractLinearSolver:\n\t        \"\"\"Check which solver that [`lineax.AutoLinearSolver`][] will dispatch to.\n\t        **Arguments:**\n", "        - `operator`: a linear operator.\n\t        **Returns:**\n\t        The linear solver that will be used.\n\t        \"\"\"\n\t        return _lookup(self._select_solver(operator))\n\t    def init(self, operator, options) -> _AutoLinearSolverState:\n\t        token = self._select_solver(operator)\n\t        return token, _lookup(token).init(operator, options)\n\t    def compute(\n\t        self,\n", "        state: _AutoLinearSolverState,\n\t        vector: PyTree[Array],\n\t        options: dict[str, Any],\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        token, state = state\n\t        solver = _lookup(token)\n\t        solution, result, _ = solver.compute(state, vector, options)\n\t        return solution, result, {}\n\t    def transpose(self, state: _AutoLinearSolverState, options: dict[str, Any]):\n\t        token, state = state\n", "        solver = _lookup(token)\n\t        transpose_state, transpose_options = solver.transpose(state, options)\n\t        transpose_state = (token, transpose_state)\n\t        return transpose_state, transpose_options\n\t    def allow_dependent_columns(self, operator: AbstractLinearOperator) -> bool:\n\t        token = self._select_solver(operator)\n\t        return _lookup(token).allow_dependent_columns(operator)\n\t    def allow_dependent_rows(self, operator: AbstractLinearOperator) -> bool:\n\t        token = self._select_solver(operator)\n\t        return _lookup(token).allow_dependent_rows(operator)\n", "AutoLinearSolver.__init__.__doc__ = \"\"\"**Arguments:**\n\t- `well_posed`: whether to only handle well-posed systems or not, as discussed above.\n\t\"\"\"\n\t# TODO(kidger): gmres, bicgstab\n\t# TODO(kidger): support auxiliary outputs\n\t@eqx.filter_jit\n\tdef linear_solve(\n\t    operator: AbstractLinearOperator,\n\t    vector: PyTree[ArrayLike],\n\t    solver: AbstractLinearSolver = AutoLinearSolver(well_posed=True),\n", "    *,\n\t    options: Optional[dict[str, Any]] = None,\n\t    state: PyTree[Any] = sentinel,\n\t    throw: bool = True,\n\t) -> Solution:\n\t    r\"\"\"Solves a linear system.\n\t    Given an operator represented as a matrix $A$, and a vector $b$: if the operator is\n\t    square and nonsingular (so that the problem is well-posed), then this returns the\n\t    usual solution $x$ to $Ax = b$, defined as $A^{-1}b$.\n\t    If the operator is overdetermined, then this either returns the least-squares\n", "    solution $\\min_x \\| Ax - b \\|_2$, or throws an error. (Depending on the choice of\n\t    solver.)\n\t    If the operator is underdetermined, then this either returns the minimum-norm\n\t    solution $\\min_x \\|x\\|_2 \\text{ subject to } Ax = b$, or throws an error. (Depending\n\t    on the choice of solver.)\n\t    !!! info\n\t        This function is equivalent to either `numpy.linalg.solve`, or to its\n\t        generalisation `numpy.linalg.lstsq`, depending on the choice of solver.\n\t    The default solver is `lineax.AutoLinearSolver(well_posed=True)`. This\n\t    automatically selects a solver depending on the structure (e.g. triangular) of your\n", "    problem, and will throw an error if your system is overdetermined or\n\t    underdetermined.\n\t    Use `lineax.AutoLinearSolver(well_posed=False)` if your system is known to be\n\t    overdetermined or underdetermined (although handling this case implies greater\n\t    computational cost).\n\t    !!! tip\n\t        These three kinds of solution to a linear system are collectively known as the\n\t        \"pseudoinverse solution\" to a linear system. That is, given our matrix $A$, let\n\t        $A^\\dagger$ denote the\n\t        [Moore--Penrose pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse)\n", "        of $A$. Then the usual/least-squares/minimum-norm solution are all equal to\n\t        $A^\\dagger b$.\n\t    **Arguments:**\n\t    - `operator`: a linear operator. This is the '$A$' in '$Ax = b$'.\n\t        Most frequently this operator is simply represented as a JAX matrix (i.e. a\n\t        rank-2 JAX array), but any [`lineax.AbstractLinearOperator`][] is supported.\n\t        Note that if it is a matrix, then it should be passed as an\n\t        [`lineax.MatrixLinearOperator`][], e.g.\n\t        ```python\n\t        matrix = jax.random.normal(key, (5, 5))  # JAX array of shape (5, 5)\n", "        operator = lx.MatrixLinearOperator(matrix)  # Wrap into a linear operator\n\t        solution = lx.linear_solve(operator, ...)\n\t        ```\n\t        rather than being passed directly.\n\t    - `vector`: the vector to solve against. This is the '$b$' in '$Ax = b$'.\n\t    - `solver`: the solver to use. Should be any [`lineax.AbstractLinearSolver`][].\n\t        The default is [`lineax.AutoLinearSolver`][] which behaves as discussed\n\t        above.\n\t        If the operator is overdetermined or underdetermined , then passing\n\t        [`lineax.SVD`][] is typical.\n", "    - `options`: Individual solvers may accept additional runtime arguments; for example\n\t        [`lineax.CG`][] allows for specifying a preconditioner. See each individual\n\t        solver's documentation for more details. Keyword only argument.\n\t    - `state`: If performing multiple linear solves with the same operator, then it is\n\t        possible to save re-use some computation between these solves, and to pass the\n\t        result of any intermediate computation in as this argument. See\n\t        [`lineax.AbstractLinearSolver.init`][] for more details. Keyword only\n\t        argument.\n\t    - `throw`: How to report any failures. (E.g. an iterative solver running out of\n\t        steps, or a well-posed-only solver being run with a singular operator.)\n", "        If `True` then a failure will raise an error. Note that errors are only reliably\n\t        raised on CPUs. If on GPUs then the error may only be printed to stderr, whilst\n\t        on TPUs then the behaviour is undefined.\n\t        If `False` then the returned solution object will have a `result` field\n\t        indicating whether any failures occured. (See [`lineax.Solution`][].)\n\t        Keyword only argument.\n\t    **Returns:**\n\t    An [`lineax.Solution`][] object containing the solution to the linear system.\n\t    \"\"\"  # noqa: E501\n\t    if eqx.is_array(operator):\n", "        raise ValueError(\n\t            \"`lineax.linear_solve(operator=...)` should be an \"\n\t            \"`AbstractLinearOperator`, not a raw JAX array. If you are trying to pass \"\n\t            \"a matrix then this should be passed as \"\n\t            \"`lineax.MatrixLinearOperator(matrix)`.\"\n\t        )\n\t    if options is None:\n\t        options = {}\n\t    vector = jtu.tree_map(inexact_asarray, vector)\n\t    vector_struct = jax.eval_shape(lambda: vector)\n", "    operator_out_structure = operator.out_structure()\n\t    # `is` to handle tracers\n\t    if eqx.tree_equal(vector_struct, operator_out_structure) is not True:\n\t        raise ValueError(\n\t            \"Vector and operator structures do not match. Got a vector with structure \"\n\t            f\"{vector_struct} and an operator with out-structure \"\n\t            f\"{operator_out_structure}\"\n\t        )\n\t    if isinstance(operator, IdentityLinearOperator):\n\t        return Solution(\n", "            value=vector,\n\t            result=RESULTS.successful,\n\t            state=state,\n\t            stats={},\n\t        )\n\t    if state == sentinel:\n\t        state = solver.init(operator, options)\n\t        dynamic_state, static_state = eqx.partition(state, eqx.is_array)\n\t        dynamic_state = lax.stop_gradient(dynamic_state)\n\t        state = eqx.combine(dynamic_state, static_state)\n", "    state = eqxi.nondifferentiable(state, name=\"`lineax.linear_solve(..., state=...)`\")\n\t    options = eqxi.nondifferentiable(\n\t        options, name=\"`lineax.linear_solve(..., options=...)`\"\n\t    )\n\t    solver = eqxi.nondifferentiable(\n\t        solver, name=\"`lineax.linear_solve(..., solver=...)`\"\n\t    )\n\t    solution, result, stats = eqxi.filter_primitive_bind(\n\t        linear_solve_p, operator, state, vector, options, solver, throw\n\t    )\n", "    # TODO: prevent forward-mode autodiff through stats\n\t    stats = eqxi.nondifferentiable_backward(stats)\n\t    return Solution(value=solution, result=result, state=state, stats=stats)\n"]}
{"filename": "lineax/_operator.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport abc\n\timport functools as ft\n\timport math\n\tfrom collections.abc import Callable\n\tfrom typing import (\n\t    Any,\n\t    Iterable,\n", "    NoReturn,\n\t    TypeVar,\n\t    Union,\n\t)\n\timport equinox as eqx\n\timport equinox.internal as eqxi\n\timport jax\n\timport jax.flatten_util as jfu\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n", "import jax.tree_util as jtu\n\timport numpy as np\n\tfrom equinox.internal import ω\n\tfrom jaxtyping import Array, ArrayLike, Float, PyTree, Scalar, Shaped  # pyright: ignore\n\tfrom ._custom_types import sentinel\n\tfrom ._misc import (\n\t    cached_eval_shape,\n\t    default_floating_dtype,\n\t    inexact_asarray,\n\t    jacobian,\n", "    NoneAux,\n\t)\n\tfrom ._tags import (\n\t    diagonal_tag,\n\t    lower_triangular_tag,\n\t    negative_semidefinite_tag,\n\t    positive_semidefinite_tag,\n\t    symmetric_tag,\n\t    transpose_tags,\n\t    tridiagonal_tag,\n", "    unit_diagonal_tag,\n\t    upper_triangular_tag,\n\t)\n\tdef _frozenset(x: Union[object, Iterable[object]]) -> frozenset[object]:\n\t    try:\n\t        iter_x = iter(x)  # pyright: ignore\n\t    except TypeError:\n\t        return frozenset([x])\n\t    else:\n\t        return frozenset(iter_x)\n", "class AbstractLinearOperator(eqx.Module):\n\t    \"\"\"Abstract base class for all linear operators.\n\t    Linear operators can act between PyTrees. Each `AbstractLinearOperator` is thought\n\t    of as a linear function `X -> Y`, where each element of `X` is as PyTree of\n\t    floating-point JAX arrays, and each element of `Y` is a PyTree of floating-point\n\t    JAX arrays.\n\t    Abstract linear operators support some operations:\n\t    ```python\n\t    op1 + op2  # addition of two operators\n\t    op1 @ op2  # composition of two operators.\n", "    op1 * 3.2  # multiplication by a scalar\n\t    op1 / 3.2  # division by a scalar\n\t    ```\n\t    \"\"\"\n\t    def __post_init__(self):\n\t        if is_symmetric(self):\n\t            # In particular, we check that dtypes match.\n\t            in_structure = self.in_structure()\n\t            out_structure = self.out_structure()\n\t            # `is` check to handle the possibility of a tracer.\n", "            if eqx.tree_equal(in_structure, out_structure) is not True:\n\t                raise ValueError(\n\t                    \"Symmetric matrices must have matching input and output \"\n\t                    f\"structures. Got input structure {in_structure} and output \"\n\t                    f\"structure {out_structure}.\"\n\t                )\n\t    @abc.abstractmethod\n\t    def mv(self, vector: PyTree[Float[Array, \" _b\"]]) -> PyTree[Float[Array, \" _a\"]]:\n\t        \"\"\"Computes a matrix-vector product between this operator and a `vector`.\n\t        **Arguments:**\n", "        - `vector`: Should be some PyTree of floating-point arrays, whose structure\n\t            should match `self.in_structure()`.\n\t        **Returns:**\n\t        A PyTree of floating-point arrays, with structure that matches\n\t        `self.out_structure()`.\n\t        \"\"\"\n\t    @abc.abstractmethod\n\t    def as_matrix(self) -> Float[Array, \"a b\"]:\n\t        \"\"\"Materialises this linear operator as a matrix.\n\t        Note that this can be a computationally (time and/or memory) expensive\n", "        operation, as many linear operators are defined implicitly, e.g. in terms of\n\t        their action on a vector.\n\t        **Arguments:** None.\n\t        **Returns:**\n\t        A 2-dimensional floating-point JAX array.\n\t        \"\"\"\n\t    @abc.abstractmethod\n\t    def transpose(self) -> \"AbstractLinearOperator\":\n\t        \"\"\"Transposes this linear operator.\n\t        This can be called as either `operator.T` or `operator.transpose()`.\n", "        **Arguments:** None.\n\t        **Returns:**\n\t        Another [`lineax.AbstractLinearOperator`][].\n\t        \"\"\"\n\t    @abc.abstractmethod\n\t    def in_structure(self) -> PyTree[jax.ShapeDtypeStruct]:\n\t        \"\"\"Returns the expected input structure of this linear operator.\n\t        **Arguments:** None.\n\t        **Returns:**\n\t        A PyTree of `jax.ShapeDtypeStruct`.\n", "        \"\"\"\n\t    @abc.abstractmethod\n\t    def out_structure(self) -> PyTree[jax.ShapeDtypeStruct]:\n\t        \"\"\"Returns the expected output structure of this linear operator.\n\t        **Arguments:** None.\n\t        **Returns:**\n\t        A PyTree of `jax.ShapeDtypeStruct`.\n\t        \"\"\"\n\t    def in_size(self) -> int:\n\t        \"\"\"Returns the total number of scalars in the input of this linear operator.\n", "        That is, the dimensionality of its input space.\n\t        **Arguments:** None.\n\t        **Returns:** An integer.\n\t        \"\"\"\n\t        leaves = jtu.tree_leaves(self.in_structure())\n\t        return sum(math.prod(leaf.shape) for leaf in leaves)  # pyright: ignore\n\t    def out_size(self) -> int:\n\t        \"\"\"Returns the total number of scalars in the output of this linear operator.\n\t        That is, the dimensionality of its output space.\n\t        **Arguments:** None.\n", "        **Returns:** An integer.\n\t        \"\"\"\n\t        leaves = jtu.tree_leaves(self.out_structure())\n\t        return sum(math.prod(leaf.shape) for leaf in leaves)  # pyright: ignore\n\t    @property\n\t    def T(self):\n\t        \"\"\"Equivalent to [`lineax.AbstractLinearOperator.transpose`][]\"\"\"\n\t        return self.transpose()\n\t    def __add__(self, other):\n\t        if not isinstance(other, AbstractLinearOperator):\n", "            raise ValueError(\"Can only add AbstractLinearOperators together.\")\n\t        return AddLinearOperator(self, other)\n\t    def __sub__(self, other):\n\t        if not isinstance(other, AbstractLinearOperator):\n\t            raise ValueError(\"Can only add AbstractLinearOperators together.\")\n\t        return AddLinearOperator(self, -other)\n\t    def __mul__(self, other):\n\t        other = jnp.asarray(other)\n\t        if other.shape != ():\n\t            raise ValueError(\"Can only multiply AbstractLinearOperators by scalars.\")\n", "        return MulLinearOperator(self, other)\n\t    def __rmul__(self, other):\n\t        return self * other\n\t    def __matmul__(self, other):\n\t        if not isinstance(other, AbstractLinearOperator):\n\t            raise ValueError(\"Can only compose AbstractLinearOperators together.\")\n\t        return ComposedLinearOperator(self, other)\n\t    def __truediv__(self, other):\n\t        other = jnp.asarray(other)\n\t        if other.shape != ():\n", "            raise ValueError(\"Can only divide AbstractLinearOperators by scalars.\")\n\t        return DivLinearOperator(self, other)\n\t    def __neg__(self):\n\t        return -1 * self\n\tclass MatrixLinearOperator(AbstractLinearOperator):\n\t    \"\"\"Wraps a 2-dimensional JAX array into a linear operator.\n\t    If the matrix has shape `(a, b)` then matrix-vector multiplication (`self.mv`) is\n\t    defined in the usual way: as performing a matrix-vector that accepts a vector of\n\t    shape `(a,)` and returns a vector of shape `(b,)`.\n\t    \"\"\"\n", "    matrix: Float[Array, \"a b\"]\n\t    tags: frozenset[object] = eqx.field(static=True)\n\t    def __init__(\n\t        self, matrix: Shaped[Array, \"a b\"], tags: Union[object, frozenset[object]] = ()\n\t    ):\n\t        \"\"\"**Arguments:**\n\t        - `matrix`: a two-dimensional JAX array. For an array with shape `(a, b)` then\n\t            this operator can perform matrix-vector products on a vector of shape\n\t            `(b,)` to return a vector of shape `(a,)`.\n\t        - `tags`: any tags indicating whether this matrix has any particular properties,\n", "            like symmetry or positive-definite-ness. Note that these properties are\n\t            unchecked and you may get incorrect values elsewhere if these tags are\n\t            wrong.\n\t        \"\"\"\n\t        if jnp.ndim(matrix) != 2:\n\t            raise ValueError(\n\t                \"`MatrixLinearOperator(matrix=...)` should be 2-dimensional.\"\n\t            )\n\t        if not jnp.issubdtype(matrix, jnp.inexact):\n\t            matrix = matrix.astype(jnp.float32)\n", "        self.matrix = matrix\n\t        self.tags = _frozenset(tags)\n\t    def mv(self, vector):\n\t        return jnp.matmul(self.matrix, vector, precision=lax.Precision.HIGHEST)\n\t    def as_matrix(self):\n\t        return self.matrix\n\t    def transpose(self):\n\t        if symmetric_tag in self.tags:\n\t            return self\n\t        return MatrixLinearOperator(self.matrix.T, transpose_tags(self.tags))\n", "    def in_structure(self):\n\t        _, in_size = jnp.shape(self.matrix)\n\t        return jax.ShapeDtypeStruct(shape=(in_size,), dtype=self.matrix.dtype)\n\t    def out_structure(self):\n\t        out_size, _ = jnp.shape(self.matrix)\n\t        return jax.ShapeDtypeStruct(shape=(out_size,), dtype=self.matrix.dtype)\n\tdef _matmul(matrix: ArrayLike, vector: ArrayLike) -> Array:\n\t    # matrix has structure [leaf(out), leaf(in)]\n\t    # vector has structure [leaf(in)]\n\t    # return has structure [leaf(out)]\n", "    return jnp.tensordot(\n\t        matrix, vector, axes=jnp.ndim(vector), precision=lax.Precision.HIGHEST\n\t    )\n\tdef _tree_matmul(matrix: PyTree[ArrayLike], vector: PyTree[ArrayLike]) -> PyTree[Array]:\n\t    # matrix has structure [tree(in), leaf(out), leaf(in)]\n\t    # vector has structure [tree(in), leaf(in)]\n\t    # return has structure [leaf(out)]\n\t    matrix = jtu.tree_leaves(matrix)\n\t    vector = jtu.tree_leaves(vector)\n\t    assert len(matrix) == len(vector)\n", "    return sum([_matmul(m, v) for m, v in zip(matrix, vector)])\n\t# Needed as static fields must be hashable and eq-able, and custom pytrees might have\n\t# e.g. define custom __eq__ methods.\n\t_T = TypeVar(\"_T\")\n\t_FlatPyTree = tuple[list[_T], jtu.PyTreeDef]\n\tdef _inexact_structure_impl2(x):\n\t    if jnp.issubdtype(x.dtype, jnp.inexact):\n\t        return x\n\t    else:\n\t        return x.astype(default_floating_dtype())\n", "def _inexact_structure_impl(x):\n\t    return jtu.tree_map(_inexact_structure_impl2, x)\n\tdef _inexact_structure(x: PyTree[jax.ShapeDtypeStruct]) -> PyTree[jax.ShapeDtypeStruct]:\n\t    return jax.eval_shape(_inexact_structure_impl, x)\n\tclass _Leaf:  # not a pytree\n\t    def __init__(self, value):\n\t        self.value = value\n\t# The `{input,output}_structure`s have to be static because otherwise abstract\n\t# evaluation rules will promote them to ShapedArrays.\n\tclass PyTreeLinearOperator(AbstractLinearOperator):\n", "    \"\"\"Represents a PyTree of floating-point JAX arrays as a linear operator.\n\t    This is basically a generalisation of [`lineax.MatrixLinearOperator`][], from\n\t    taking just a single array to take a PyTree-of-arrays. (And likewise from returning\n\t    a single array to returning a PyTree-of-arrays.)\n\t    Specifically, suppose we want this to be a linear operator `X -> Y`, for which\n\t    elements of `X` are PyTrees with structure `T` whose `i`th leaf is a floating-point\n\t    JAX array of shape `x_shape_i`, and elements of `Y` are PyTrees with structure `S`\n\t    whose `j`th leaf is a floating-point JAX array of has shape `y_shape_j`. Then the\n\t    input PyTree should have structure `T`-compose-`S`, and its `(i, j)`-th  leaf should\n\t    be a floating-point JAX array of shape `(*x_shape_i, *y_shape_j)`.\n", "    !!! Example\n\t        ```python\n\t        # Suppose `x` is a member of our input space, with the following pytree\n\t        # structure:\n\t        eqx.tree_pprint(x)  # [f32[5, 9], f32[3]]\n\t        # Suppose `y` is a member of our output space, with the following pytree\n\t        # structure:\n\t        eqx.tree_pprint(y)\n\t        # {\"a\": f32[1, 2]}\n\t        # then `pytree` should be a pytree with the following structure:\n", "        eqx.tree_pprint(pytree)  # {\"a\": [f32[1, 2, 5, 9], f32[1, 2, 3]]}\n\t        ```\n\t    \"\"\"\n\t    pytree: PyTree[Float[Array, \"...\"]]\n\t    output_structure: _FlatPyTree[jax.ShapeDtypeStruct] = eqx.field(static=True)\n\t    tags: frozenset[object] = eqx.field(static=True)\n\t    input_structure: _FlatPyTree[jax.ShapeDtypeStruct] = eqx.field(static=True)\n\t    def __init__(\n\t        self,\n\t        pytree: PyTree[ArrayLike],\n", "        output_structure: PyTree[jax.ShapeDtypeStruct],\n\t        tags: Union[object, frozenset[object]] = (),\n\t    ):\n\t        \"\"\"**Arguments:**\n\t        - `pytree`: this should be a PyTree, with structure as specified in\n\t            [`lineax.PyTreeLinearOperator`][].\n\t        - `out_structure`: the structure of the output space. This should be a PyTree of\n\t            `jax.ShapeDtypeStruct`s. (The structure of the input space is then\n\t            automatically derived from the structure of `pytree`.)\n\t        - `tags`: any tags indicating whether this operator has any particular\n", "            properties, like symmetry or positive-definite-ness. Note that these\n\t            properties are unchecked and you may get incorrect values elsewhere if these\n\t            tags are wrong.\n\t        \"\"\"\n\t        output_structure = _inexact_structure(output_structure)\n\t        self.pytree = jtu.tree_map(inexact_asarray, pytree)\n\t        self.output_structure = jtu.tree_flatten(output_structure)\n\t        self.tags = _frozenset(tags)\n\t        # self.out_structure() has structure [tree(out)]\n\t        # self.pytree has structure [tree(out), tree(in), leaf(out), leaf(in)]\n", "        def get_structure(struct, subpytree):\n\t            # subpytree has structure [tree(in), leaf(out), leaf(in)]\n\t            def sub_get_structure(leaf):\n\t                shape = jnp.shape(leaf)  # [leaf(out), leaf(in)]\n\t                ndim = len(struct.shape)\n\t                if shape[:ndim] != struct.shape:\n\t                    raise ValueError(\n\t                        \"`pytree` and `output_structure` are not consistent\"\n\t                    )\n\t                return jax.ShapeDtypeStruct(shape=shape[ndim:], dtype=jnp.dtype(leaf))\n", "            return _Leaf(jtu.tree_map(sub_get_structure, subpytree))\n\t        if output_structure is None:\n\t            # Implies that len(input_structures) > 0\n\t            raise ValueError(\"Cannot have trivial output_structure\")\n\t        input_structures = jtu.tree_map(get_structure, output_structure, self.pytree)\n\t        input_structures = jtu.tree_leaves(input_structures)\n\t        input_structure = input_structures[0].value\n\t        for val in input_structures[1:]:\n\t            if eqx.tree_equal(input_structure, val.value) is not True:\n\t                raise ValueError(\n", "                    \"`pytree` does not have a consistent `input_structure`\"\n\t                )\n\t        self.input_structure = jtu.tree_flatten(input_structure)\n\t    def mv(self, vector):\n\t        # vector has structure [tree(in), leaf(in)]\n\t        # self.out_structure() has structure [tree(out)]\n\t        # self.pytree has structure [tree(out), tree(in), leaf(out), leaf(in)]\n\t        # return has struture [tree(out), leaf(out)]\n\t        def matmul(_, matrix):\n\t            return _tree_matmul(matrix, vector)\n", "        return jtu.tree_map(matmul, self.out_structure(), self.pytree)\n\t    def as_matrix(self):\n\t        dtype = jnp.result_type(*jtu.tree_leaves(self.pytree))\n\t        def concat_in(struct, subpytree):\n\t            leaves = jtu.tree_leaves(subpytree)\n\t            assert all(\n\t                leaf.shape[: len(struct.shape)] == struct.shape for leaf in leaves\n\t            )\n\t            size = math.prod(struct.shape)\n\t            leaves = [\n", "                leaf.astype(dtype).reshape(size, -1) if leaf.size > 0 else leaf\n\t                for leaf in leaves\n\t            ]\n\t            return jnp.concatenate(leaves, axis=1)\n\t        matrix = jtu.tree_map(concat_in, self.out_structure(), self.pytree)\n\t        matrix = jtu.tree_leaves(matrix)\n\t        return jnp.concatenate(matrix, axis=0)\n\t    def transpose(self):\n\t        if symmetric_tag in self.tags:\n\t            return self\n", "        def _transpose(struct, subtree):\n\t            def _transpose_impl(leaf):\n\t                return jnp.moveaxis(leaf, source, dest)\n\t            source = list(range(struct.ndim))\n\t            dest = list(range(-struct.ndim, 0))\n\t            return jtu.tree_map(_transpose_impl, subtree)\n\t        pytree_transpose = jtu.tree_map(_transpose, self.out_structure(), self.pytree)\n\t        pytree_transpose = jtu.tree_transpose(\n\t            jtu.tree_structure(self.out_structure()),\n\t            jtu.tree_structure(self.in_structure()),\n", "            pytree_transpose,\n\t        )\n\t        return PyTreeLinearOperator(\n\t            pytree_transpose, self.in_structure(), transpose_tags(self.tags)\n\t        )\n\t    def in_structure(self):\n\t        leaves, treedef = self.input_structure\n\t        return jtu.tree_unflatten(treedef, leaves)\n\t    def out_structure(self):\n\t        leaves, treedef = self.output_structure\n", "        return jtu.tree_unflatten(treedef, leaves)\n\tclass _NoAuxIn(eqx.Module):\n\t    fn: Callable\n\t    args: Any\n\t    def __call__(self, x):\n\t        return self.fn(x, self.args)\n\tclass _NoAuxOut(eqx.Module):\n\t    fn: Callable\n\t    def __call__(self, x):\n\t        f, _ = self.fn(x)\n", "        return f\n\tclass _Unwrap(eqx.Module):\n\t    fn: Callable\n\t    def __call__(self, x):\n\t        (f,) = self.fn(x)\n\t        return f\n\tclass JacobianLinearOperator(AbstractLinearOperator):\n\t    \"\"\"Given a function `fn: X -> Y`, and a point `x in X`, then this defines the\n\t    linear operator (also a function `X -> Y`) given by the Jacobian `(d(fn)/dx)(x)`.\n\t    For example if the inputs and outputs are just arrays, then this is equivalent to\n", "    `MatrixLinearOperator(jax.jacfwd(fn)(x))`.\n\t    The Jacobian is not materialised; matrix-vector products, which are in fact\n\t    Jacobian-vector products, are computed using autodifferentiation, specifically\n\t    `jax.jvp`. Thus `JacobianLinearOperator(fn, x).mv(v)` is equivalent to\n\t    `jax.jvp(fn, (x,), (v,))`.\n\t    See also [`lineax.linearise`][], which caches the primal computation, i.e.\n\t    it returns `_, lin = jax.linearize(fn, x); FunctionLinearOperator(lin, ...)`\n\t    See also [`lineax.materialise`][], which materialises the whole Jacobian in\n\t    memory.\n\t    \"\"\"\n", "    fn: Callable[\n\t        [PyTree[Float[Array, \"...\"]], PyTree[Any]], PyTree[Float[Array, \"...\"]]\n\t    ]\n\t    x: PyTree[Float[Array, \"...\"]]\n\t    args: PyTree[Any]\n\t    tags: frozenset[object] = eqx.field(static=True)\n\t    def __init__(\n\t        self,\n\t        fn: Callable,\n\t        x: PyTree[ArrayLike],\n", "        args: PyTree[Any] = None,\n\t        tags: Union[object, Iterable[object]] = (),\n\t        _has_aux: bool = False,\n\t    ):\n\t        \"\"\"**Arguments:**\n\t        - `fn`: A function `(x, args) -> y`. The Jacobian `d(fn)/dx` is used as the\n\t            linear operator, and `args` are just any other arguments that should not be\n\t            differentiated.\n\t        - `x`: The point to evaluate `d(fn)/dx` at: `(d(fn)/dx)(x, args)`.\n\t        - `args`: As `x`; this is the point to evaluate `d(fn)/dx` at:\n", "            `(d(fn)/dx)(x, args)`.\n\t        - `tags`: any tags indicating whether this operator has any particular\n\t            properties, like symmetry or positive-definite-ness. Note that these\n\t            properties are unchecked and you may get incorrect values elsewhere if these\n\t            tags are wrong.\n\t        \"\"\"\n\t        if not _has_aux:\n\t            fn = NoneAux(fn)\n\t        # Flush out any closed-over values, so that we can safely pass `self`\n\t        # across API boundaries. (In particular, across `linear_solve_p`.)\n", "        # We don't use `jax.closure_convert` as that only flushes autodiffable\n\t        # (=floating-point) constants. It probably doesn't matter, but if `fn` is a\n\t        # PyTree capturing non-floating-point constants, we should probably continue\n\t        # to respect that, and keep any non-floating-point constants as part of the\n\t        # PyTree structure.\n\t        x = jtu.tree_map(inexact_asarray, x)\n\t        fn = eqx.filter_closure_convert(fn, x, args)\n\t        self.fn = fn\n\t        self.x = x\n\t        self.args = args\n", "        self.tags = _frozenset(tags)\n\t    def mv(self, vector):\n\t        fn = _NoAuxOut(_NoAuxIn(self.fn, self.args))\n\t        _, out = jax.jvp(fn, (self.x,), (vector,))\n\t        return out\n\t    def as_matrix(self):\n\t        return materialise(self).as_matrix()\n\t    def transpose(self):\n\t        if symmetric_tag in self.tags:\n\t            return self\n", "        fn = _NoAuxOut(_NoAuxIn(self.fn, self.args))\n\t        # Works because vjpfn is a PyTree\n\t        _, vjpfn = jax.vjp(fn, self.x)\n\t        vjpfn = _Unwrap(vjpfn)\n\t        return FunctionLinearOperator(\n\t            vjpfn, self.out_structure(), transpose_tags(self.tags)\n\t        )\n\t    def in_structure(self):\n\t        return jax.eval_shape(lambda: self.x)\n\t    def out_structure(self):\n", "        fn = _NoAuxOut(_NoAuxIn(self.fn, self.args))\n\t        return cached_eval_shape(fn, self.x)\n\t# `input_structure` must be static as with `JacobianLinearOperator`\n\tclass FunctionLinearOperator(AbstractLinearOperator):\n\t    \"\"\"Wraps a *linear* function `fn: X -> Y` into a linear operator. (So that\n\t    `self.mv(x)` is defined by `self.mv(x) == fn(x)`.)\n\t    See also [`lineax.materialise`][], which materialises the whole linear operator\n\t    in memory. (Similar to `.as_matrix()`.)\n\t    \"\"\"\n\t    fn: Callable[[PyTree[Float[Array, \"...\"]]], PyTree[Float[Array, \"...\"]]]\n", "    input_structure: _FlatPyTree[jax.ShapeDtypeStruct] = eqx.field(static=True)\n\t    tags: frozenset[object] = eqx.field(static=True)\n\t    def __init__(\n\t        self,\n\t        fn: Callable[[PyTree[Float[Array, \"...\"]]], PyTree[Float[Array, \"...\"]]],\n\t        input_structure: PyTree[jax.ShapeDtypeStruct],\n\t        tags: Union[object, Iterable[object]] = (),\n\t    ):\n\t        \"\"\"**Arguments:**\n\t        - `fn`: a linear function. Should accept a PyTree of floating-point JAX arrays,\n", "            and return a PyTree of floating-point JAX arrays.\n\t        - `input_structure`: A PyTree of `jax.ShapeDtypeStruct`s specifying the\n\t            structure of the input to the function. (When later calling `self.mv(x)`\n\t            then this should match the structure of `x`, i.e.\n\t            `jax.eval_shape(lambda: x)`.)\n\t        - `tags`: any tags indicating whether this operator has any particular\n\t            properties, like symmetry or positive-definite-ness. Note that these\n\t            properties are unchecked and you may get incorrect values elsewhere if these\n\t            tags are wrong.\n\t        \"\"\"\n", "        # See matching comment in JacobianLinearOperator.\n\t        fn = eqx.filter_closure_convert(fn, input_structure)\n\t        input_structure = _inexact_structure(input_structure)\n\t        self.fn = fn\n\t        self.input_structure = jtu.tree_flatten(input_structure)\n\t        self.tags = _frozenset(tags)\n\t    def mv(self, vector):\n\t        return self.fn(vector)\n\t    def as_matrix(self):\n\t        return materialise(self).as_matrix()\n", "    def transpose(self):\n\t        if symmetric_tag in self.tags:\n\t            return self\n\t        transpose_fn = jax.linear_transpose(self.fn, self.in_structure())\n\t        def _transpose_fn(vector):\n\t            (out,) = transpose_fn(vector)\n\t            return out\n\t        # Works because transpose_fn is a PyTree\n\t        return FunctionLinearOperator(\n\t            _transpose_fn, self.out_structure(), transpose_tags(self.tags)\n", "        )\n\t    def in_structure(self):\n\t        leaves, treedef = self.input_structure\n\t        return jtu.tree_unflatten(treedef, leaves)\n\t    def out_structure(self):\n\t        return cached_eval_shape(self.fn, self.in_structure())\n\t# `structure` must be static as with `JacobianLinearOperator`\n\tclass IdentityLinearOperator(AbstractLinearOperator):\n\t    \"\"\"Represents the identity transformation `X -> X`, where each `x in X` is some\n\t    PyTree of floating-point JAX arrays.\n", "    \"\"\"\n\t    input_structure: _FlatPyTree[jax.ShapeDtypeStruct] = eqx.field(static=True)\n\t    output_structure: _FlatPyTree[jax.ShapeDtypeStruct] = eqx.field(static=True)\n\t    def __init__(\n\t        self,\n\t        input_structure: PyTree[jax.ShapeDtypeStruct],\n\t        output_structure: PyTree[jax.ShapeDtypeStruct] = sentinel,\n\t    ):\n\t        \"\"\"**Arguments:**\n\t        - `input_structure`: A PyTree of `jax.ShapeDtypeStruct`s specifying the\n", "            structure of the the input space. (When later calling `self.mv(x)`\n\t            then this should match the structure of `x`, i.e.\n\t            `jax.eval_shape(lambda: x)`.)\n\t        - `output_structure`: A PyTree of `jax.ShapeDtypeStruct`s specifying the\n\t            structure of the the output space. If not passed then this defaults to the\n\t            same as `input_structure`. If passed then it must have the same number of\n\t            elements as `input_structure`, so that the operator is square.\n\t        \"\"\"\n\t        if output_structure is sentinel:\n\t            output_structure = input_structure\n", "        input_structure = _inexact_structure(input_structure)\n\t        output_structure = _inexact_structure(output_structure)\n\t        self.input_structure = jtu.tree_flatten(input_structure)\n\t        self.output_structure = jtu.tree_flatten(output_structure)\n\t        if self.in_size() != self.out_size():\n\t            raise ValueError(\n\t                \"input and output structures must have the same number of elements.\"\n\t            )\n\t    def mv(self, vector):\n\t        if jax.eval_shape(lambda: vector) != self.in_structure():\n", "            raise ValueError(\"Vector and operator structures do not match\")\n\t        return vector\n\t    def as_matrix(self):\n\t        return jnp.eye(self.in_size())\n\t    def transpose(self):\n\t        return self\n\t    def in_structure(self):\n\t        leaves, treedef = self.input_structure\n\t        return jtu.tree_unflatten(treedef, leaves)\n\t    def out_structure(self):\n", "        leaves, treedef = self.output_structure\n\t        return jtu.tree_unflatten(treedef, leaves)\n\t    @property\n\t    def tags(self):\n\t        return frozenset()\n\tclass DiagonalLinearOperator(AbstractLinearOperator):\n\t    \"\"\"As [`lineax.MatrixLinearOperator`][], but for specifically a diagonal matrix.\n\t    Only the diagonal of the matrix is stored (for memory efficiency). Matrix-vector\n\t    products are computed by doing a pointwise `diagonal * vector`, rather than a full\n\t    `matrix @ vector` (for speed).\n", "    \"\"\"\n\t    diagonal: Float[Array, \" size\"]\n\t    def __init__(self, diagonal: Shaped[Array, \" size\"]):\n\t        \"\"\"**Arguments:**\n\t        - `diagonal`: A rank-one JAX array, i.e. of shape `(a,)` for some `a`. This is\n\t            the diagonal of the matrix.\n\t        \"\"\"\n\t        self.diagonal = inexact_asarray(diagonal)\n\t    def mv(self, vector):\n\t        return self.diagonal * vector\n", "    def as_matrix(self):\n\t        return jnp.diag(self.diagonal)\n\t    def transpose(self):\n\t        return self\n\t    def in_structure(self):\n\t        (size,) = jnp.shape(self.diagonal)\n\t        return jax.ShapeDtypeStruct(shape=(size,), dtype=self.diagonal.dtype)\n\t    def out_structure(self):\n\t        (size,) = jnp.shape(self.diagonal)\n\t        return jax.ShapeDtypeStruct(shape=(size,), dtype=self.diagonal.dtype)\n", "class TridiagonalLinearOperator(AbstractLinearOperator):\n\t    \"\"\"As [`lineax.MatrixLinearOperator`][], but for specifically a tridiagonal\n\t    matrix.\n\t    \"\"\"\n\t    diagonal: Float[Array, \" size\"]\n\t    lower_diagonal: Float[Array, \" size-1\"]\n\t    upper_diagonal: Float[Array, \" size-1\"]\n\t    def __init__(\n\t        self,\n\t        diagonal: Float[Array, \" size\"],\n", "        lower_diagonal: Float[Array, \" size-1\"],\n\t        upper_diagonal: Float[Array, \" size-1\"],\n\t    ):\n\t        \"\"\"**Arguments:**\n\t        - `diagonal`: A rank-one JAX array. This is the diagonal of the matrix.\n\t        - `lower_diagonal`: A rank-one JAX array. This is the lower diagonal of the\n\t            matrix.\n\t        - `upper_diagonal`: A rank-one JAX array. This is the upper diagonal of the\n\t            matrix.\n\t        If `diagonal` has shape `(a,)` then `lower_diagonal` and `upper_diagonal` should\n", "        both have shape `(a - 1,)`.\n\t        \"\"\"\n\t        self.diagonal = inexact_asarray(diagonal)\n\t        self.lower_diagonal = inexact_asarray(lower_diagonal)\n\t        self.upper_diagonal = inexact_asarray(upper_diagonal)\n\t        (size,) = self.diagonal.shape\n\t        if self.lower_diagonal.shape != (size - 1,):\n\t            raise ValueError(\"lower_diagonal and diagonal do not have consistent size\")\n\t        if self.upper_diagonal.shape != (size - 1,):\n\t            raise ValueError(\"upper_diagonal and diagonal do not have consistent size\")\n", "    def mv(self, vector):\n\t        a = self.upper_diagonal * vector[1:]\n\t        b = self.diagonal * vector\n\t        c = self.lower_diagonal * vector[:-1]\n\t        return b.at[:-1].add(a).at[1:].add(c)\n\t    def as_matrix(self):\n\t        (size,) = jnp.shape(self.diagonal)\n\t        matrix = jnp.zeros((size, size), self.diagonal.dtype)\n\t        arange = np.arange(size)\n\t        matrix = matrix.at[arange, arange].set(self.diagonal)\n", "        matrix = matrix.at[arange[1:], arange[:-1]].set(self.lower_diagonal)\n\t        matrix = matrix.at[arange[:-1], arange[1:]].set(self.upper_diagonal)\n\t        return matrix\n\t    def transpose(self):\n\t        return TridiagonalLinearOperator(\n\t            self.diagonal, self.upper_diagonal, self.lower_diagonal\n\t        )\n\t    def in_structure(self):\n\t        (size,) = jnp.shape(self.diagonal)\n\t        return jax.ShapeDtypeStruct(shape=(size,), dtype=self.diagonal.dtype)\n", "    def out_structure(self):\n\t        (size,) = jnp.shape(self.diagonal)\n\t        return jax.ShapeDtypeStruct(shape=(size,), dtype=self.diagonal.dtype)\n\tclass TaggedLinearOperator(AbstractLinearOperator):\n\t    \"\"\"Wraps another linear operator and specifies that it has certain tags, e.g.\n\t    representing symmetry.\n\t    !!! Example\n\t        ```python\n\t        # Some other operator.\n\t        operator = lx.MatrixLinearOperator(some_jax_array)\n", "        # Now symmetric! But the type system doesn't know this.\n\t        sym_operator = operator + operator.T\n\t        assert lx.is_symmetric(sym_operator) == False\n\t        # We can declare that our operator has a particular property.\n\t        sym_operator = lx.TaggedLinearOperator(sym_operator, lx.symmetric_tag)\n\t        assert lx.is_symmetric(sym_operator) == True\n\t        ```\n\t    \"\"\"\n\t    operator: AbstractLinearOperator\n\t    tags: frozenset[object] = eqx.field(static=True)\n", "    def __init__(\n\t        self, operator: AbstractLinearOperator, tags: Union[object, Iterable[object]]\n\t    ):\n\t        \"\"\"**Arguments:**\n\t        - `operator`: some other linear operator to wrap.\n\t        - `tags`: any tags indicating whether this operator has any particular\n\t            properties, like symmetry or positive-definite-ness. Note that these\n\t            properties are unchecked and you may get incorrect values elsewhere if these\n\t            tags are wrong.\n\t        \"\"\"\n", "        self.operator = operator\n\t        self.tags = _frozenset(tags)\n\t    def mv(self, vector):\n\t        return self.operator.mv(vector)\n\t    def as_matrix(self):\n\t        return self.operator.as_matrix()\n\t    def transpose(self):\n\t        return TaggedLinearOperator(\n\t            self.operator.transpose(), transpose_tags(self.tags)\n\t        )\n", "    def in_structure(self):\n\t        return self.operator.in_structure()\n\t    def out_structure(self):\n\t        return self.operator.out_structure()\n\t#\n\t# All operators below here are private to lineax.\n\t#\n\tdef _is_none(x):\n\t    return x is None\n\tclass TangentLinearOperator(AbstractLinearOperator):\n", "    \"\"\"Internal to lineax. Used to represent the tangent (jvp) computation with\n\t    respect to the linear operator in a linear solve.\n\t    \"\"\"\n\t    primal: AbstractLinearOperator\n\t    tangent: AbstractLinearOperator\n\t    def __post_init__(self):\n\t        assert type(self.primal) is type(self.tangent)  # noqa: E721\n\t        super().__post_init__()\n\t    def mv(self, vector):\n\t        mv = lambda operator: operator.mv(vector)\n", "        out, t_out = eqx.filter_jvp(mv, (self.primal,), (self.tangent,))\n\t        return jtu.tree_map(eqxi.materialise_zeros, out, t_out, is_leaf=_is_none)\n\t    def as_matrix(self):\n\t        as_matrix = lambda operator: operator.as_matrix()\n\t        out, t_out = eqx.filter_jvp(as_matrix, (self.primal,), (self.tangent,))\n\t        return jtu.tree_map(eqxi.materialise_zeros, out, t_out, is_leaf=_is_none)\n\t    def transpose(self):\n\t        transpose = lambda operator: operator.transpose()\n\t        primal_out, tangent_out = eqx.filter_jvp(\n\t            transpose, (self.primal,), (self.tangent,)\n", "        )\n\t        return TangentLinearOperator(primal_out, tangent_out)\n\t    def in_structure(self):\n\t        return self.primal.in_structure()\n\t    def out_structure(self):\n\t        return self.primal.out_structure()\n\tclass AddLinearOperator(AbstractLinearOperator):\n\t    \"\"\"A linear operator formed by adding two other linear operators together.\n\t    !!! Example\n\t        ```python\n", "        x = MatrixLinearOperator(...)\n\t        y = MatrixLinearOperator(...)\n\t        assert isinstance(x + y, AddLinearOperator)\n\t        ```\n\t    \"\"\"\n\t    operator1: AbstractLinearOperator\n\t    operator2: AbstractLinearOperator\n\t    def __post_init__(self):\n\t        if self.operator1.in_structure() != self.operator2.in_structure():\n\t            raise ValueError(\"Incompatible linear operator structures\")\n", "        if self.operator1.out_structure() != self.operator2.out_structure():\n\t            raise ValueError(\"Incompatible linear operator structures\")\n\t        super().__post_init__()\n\t    def mv(self, vector):\n\t        mv1 = self.operator1.mv(vector)\n\t        mv2 = self.operator2.mv(vector)\n\t        return (mv1**ω + mv2**ω).ω\n\t    def as_matrix(self):\n\t        return self.operator1.as_matrix() + self.operator2.as_matrix()\n\t    def transpose(self):\n", "        return self.operator1.transpose() + self.operator2.transpose()\n\t    def in_structure(self):\n\t        return self.operator1.in_structure()\n\t    def out_structure(self):\n\t        return self.operator1.out_structure()\n\tclass MulLinearOperator(AbstractLinearOperator):\n\t    \"\"\"A linear operator formed by multiplying a linear operator by a scalar.\n\t    !!! Example\n\t        ```python\n\t        x = MatrixLinearOperator(...)\n", "        y = 0.5\n\t        assert isinstance(x * y, MulLinearOperator)\n\t        ```\n\t    \"\"\"\n\t    operator: AbstractLinearOperator\n\t    scalar: Scalar\n\t    def mv(self, vector):\n\t        return (self.operator.mv(vector) ** ω * self.scalar).ω\n\t    def as_matrix(self):\n\t        return self.operator.as_matrix() * self.scalar\n", "    def transpose(self):\n\t        return self.operator.transpose() * self.scalar\n\t    def in_structure(self):\n\t        return self.operator.in_structure()\n\t    def out_structure(self):\n\t        return self.operator.out_structure()\n\tclass DivLinearOperator(AbstractLinearOperator):\n\t    \"\"\"A linear operator formed by dividing a linear operator by a scalar.\n\t    !!! Example\n\t        ```python\n", "        x = MatrixLinearOperator(...)\n\t        y = 0.5\n\t        assert isinstance(x / y, DivLinearOperator)\n\t        ```\n\t    \"\"\"\n\t    operator: AbstractLinearOperator\n\t    scalar: Scalar\n\t    def mv(self, vector):\n\t        return (self.operator.mv(vector) ** ω / self.scalar).ω\n\t    def as_matrix(self):\n", "        return self.operator.as_matrix() / self.scalar\n\t    def transpose(self):\n\t        return self.operator.transpose() / self.scalar\n\t    def in_structure(self):\n\t        return self.operator.in_structure()\n\t    def out_structure(self):\n\t        return self.operator.out_structure()\n\tclass ComposedLinearOperator(AbstractLinearOperator):\n\t    \"\"\"A linear operator formed by composing (matrix-multiplying) two other linear\n\t    operators together.\n", "    !!! Example\n\t        ```python\n\t        x = MatrixLinearOperator(matrix1)\n\t        y = MatrixLinearOperator(matrix2)\n\t        composed = x @ y\n\t        assert isinstance(composed, ComposedLinearOperator)\n\t        assert jnp.allclose(composed.as_matrix(), matrix1 @ matrix2)\n\t        ```\n\t    \"\"\"\n\t    operator1: AbstractLinearOperator\n", "    operator2: AbstractLinearOperator\n\t    def __post_init__(self):\n\t        if self.operator1.in_structure() != self.operator2.out_structure():\n\t            raise ValueError(\"Incompatible linear operator structures\")\n\t        super().__post_init__()\n\t    def mv(self, vector):\n\t        return self.operator1.mv(self.operator2.mv(vector))\n\t    def as_matrix(self):\n\t        return jnp.matmul(\n\t            self.operator1.as_matrix(),\n", "            self.operator2.as_matrix(),\n\t            precision=lax.Precision.HIGHEST,\n\t        )\n\t    def transpose(self):\n\t        return self.operator2.transpose() @ self.operator1.transpose()\n\t    def in_structure(self):\n\t        return self.operator2.in_structure()\n\t    def out_structure(self):\n\t        return self.operator1.out_structure()\n\tclass AuxLinearOperator(AbstractLinearOperator):\n", "    \"\"\"Internal to lineax. Used to represent a linear operator with additional\n\t    metadata attached.\n\t    \"\"\"\n\t    operator: AbstractLinearOperator\n\t    aux: PyTree[Array]\n\t    def mv(self, vector):\n\t        return self.operator.mv(vector)\n\t    def as_matrix(self):\n\t        return self.operator.as_matrix()\n\t    def transpose(self):\n", "        return self.operator.transpose()\n\t    def in_structure(self):\n\t        return self.operator.in_structure()\n\t    def out_structure(self):\n\t        return self.operator.out_structure()\n\t#\n\t# Operations on `AbstractLinearOperator`s.\n\t# These are done through `singledispatch` rather than as methods.\n\t#\n\t# If an end user ever wanted to add something analogous to\n", "# `diagonal: AbstractLinearOperator -> Array`\n\t# then of course they don't get to edit our base class and add overloads to all\n\t# subclasses.\n\t# They'd have to use `singledispatch` to get the desired behaviour. (Or maybe just\n\t# hardcode compatibility with only some `AbstractLinearOperator` subclasses, eurgh.)\n\t# So for consistency we do the same thing here, rather than adding privileged behaviour\n\t# for just the operations we happen to support.\n\t#\n\t# (Something something Julia something something orphan problem etc.)\n\t#\n", "def _default_not_implemented(name: str, operator: AbstractLinearOperator) -> NoReturn:\n\t    msg = f\"`lineax.{name}` has not been implemented for {type(operator)}\"\n\t    if type(operator).__module__.startswith(\"lineax\"):\n\t        assert False, msg + \". Please file a bug against Lineax.\"\n\t    else:\n\t        raise NotImplementedError(msg)\n\t# linearise\n\t@ft.singledispatch\n\tdef linearise(operator: AbstractLinearOperator) -> AbstractLinearOperator:\n\t    \"\"\"Linearises a linear operator. This returns another linear operator.\n", "    Mathematically speaking this is just the identity function. And indeed most linear\n\t    operators will be returned unchanged.\n\t    For specifically [`lineax.JacobianLinearOperator`][], then this will cache the\n\t    primal pass, so that it does not need to be recomputed each time. That is, it uses\n\t    some memory to improve speed. (This is the precisely same distinction as `jax.jvp`\n\t    versus `jax.linearize`.)\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Another linear operator. Mathematically it performs matrix-vector products\n", "    (`operator.mv`) that produce the same results as the input `operator`.\n\t    \"\"\"\n\t    _default_not_implemented(\"linearise\", operator)\n\t@linearise.register(MatrixLinearOperator)\n\t@linearise.register(PyTreeLinearOperator)\n\t@linearise.register(FunctionLinearOperator)\n\t@linearise.register(IdentityLinearOperator)\n\t@linearise.register(DiagonalLinearOperator)\n\t@linearise.register(TridiagonalLinearOperator)\n\tdef _(operator):\n", "    return operator\n\t@linearise.register(JacobianLinearOperator)\n\tdef _(operator):\n\t    fn = _NoAuxIn(operator.fn, operator.args)\n\t    (_, aux), lin = jax.linearize(fn, operator.x)\n\t    lin = _NoAuxOut(lin)\n\t    out = FunctionLinearOperator(lin, operator.in_structure(), operator.tags)\n\t    return AuxLinearOperator(out, aux)\n\t# materialise\n\t@ft.singledispatch\n", "def materialise(operator: AbstractLinearOperator) -> AbstractLinearOperator:\n\t    \"\"\"Materialises a linear operator. This returns another linear operator.\n\t    Mathematically speaking this is just the identity function. And indeed most linear\n\t    operators will be returned unchanged.\n\t    For specifically [`lineax.JacobianLinearOperator`][] and\n\t    [`lineax.FunctionLinearOperator`][] then the linear operator is materialised in\n\t    memory. That is, it becomes defined as a matrix (or pytree of arrays), rather\n\t    than being defined only through its matrix-vector product\n\t    ([`lineax.AbstractLinearOperator.mv`][]).\n\t    Materialisation sometimes improves compile time or run time. It usually increases\n", "    memory usage.\n\t    For example:\n\t    ```python\n\t    large_function = ...\n\t    operator = lx.FunctionLinearOperator(large_function, ...)\n\t    # Option 1\n\t    out1 = operator.mv(vector1)  # Traces and compiles `large_function`\n\t    out2 = operator.mv(vector2)  # Traces and compiles `large_function` again!\n\t    out3 = operator.mv(vector3)  # Traces and compiles `large_function` a third time!\n\t    # All that compilation might lead to long compile times.\n", "    # If `large_function` takes a long time to run, then this might also lead to long\n\t    # run times.\n\t    # Option 2\n\t    operator = lx.materialise(operator)  # Traces and compiles `large_function` and\n\t                                           # stores the result as a matrix.\n\t    out1 = operator.mv(vector1)  # Each of these just computes a matrix-vector product\n\t    out2 = operator.mv(vector2)  # against the stored matrix.\n\t    out3 = operator.mv(vector3)  #\n\t    # Now, `large_function` is only compiled once, and only ran once.\n\t    # However, storing the matrix might take a lot of memory, and the initial\n", "    # computation may-or-may-not take a long time to run.\n\t    ```\n\t    Generally speaking it is worth first setting up your problem without\n\t    `lx.materialise`, and using it as an optional optimisation if you find that it\n\t    helps your particular problem.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Another linear operator. Mathematically it performs matrix-vector products\n\t    (`operator.mv`) that produce the same results as the input `operator`.\n", "    \"\"\"\n\t    _default_not_implemented(\"materialise\", operator)\n\t@materialise.register(MatrixLinearOperator)\n\t@materialise.register(PyTreeLinearOperator)\n\t@materialise.register(IdentityLinearOperator)\n\t@materialise.register(DiagonalLinearOperator)\n\t@materialise.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    return operator\n\t@materialise.register(JacobianLinearOperator)\n", "def _(operator):\n\t    fn = _NoAuxIn(operator.fn, operator.args)\n\t    jac, aux = jacobian(fn, operator.in_size(), operator.out_size(), has_aux=True)(\n\t        operator.x\n\t    )\n\t    out = PyTreeLinearOperator(jac, operator.out_structure(), operator.tags)\n\t    return AuxLinearOperator(out, aux)\n\t@materialise.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    flat, unravel = eqx.filter_eval_shape(jfu.ravel_pytree, operator.in_structure())\n", "    eye = jnp.eye(flat.size, dtype=flat.dtype)\n\t    jac = jax.vmap(lambda x: operator.fn(unravel(x)), out_axes=-1)(eye)\n\t    def batch_unravel(x):\n\t        assert x.ndim > 0\n\t        unravel_ = unravel\n\t        for _ in range(x.ndim - 1):\n\t            unravel_ = jax.vmap(unravel_)\n\t        return unravel_(x)\n\t    jac = jtu.tree_map(batch_unravel, jac)\n\t    return PyTreeLinearOperator(jac, operator.out_structure(), operator.tags)\n", "# diagonal\n\t@ft.singledispatch\n\tdef diagonal(operator: AbstractLinearOperator) -> Shaped[Array, \" size\"]:\n\t    \"\"\"Extracts the diagonal from a linear operator, and returns a vector.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    A rank-1 JAX array. (That is, it has shape `(a,)` for some integer `a`.)\n\t    For most operators this is just `jnp.diag(operator.as_matrix())`. Some operators\n\t    (e.g. [`lineax.DiagonalLinearOperator`][]) can have more efficient\n", "    implementations. If you don't know what kind of operator you might have, then this\n\t    function ensures that you always get the most efficient implementation.\n\t    \"\"\"\n\t    _default_not_implemented(\"diagonal\", operator)\n\t@diagonal.register(MatrixLinearOperator)\n\t@diagonal.register(PyTreeLinearOperator)\n\t@diagonal.register(JacobianLinearOperator)\n\t@diagonal.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return jnp.diag(operator.as_matrix())\n", "@diagonal.register(IdentityLinearOperator)\n\tdef _(operator):\n\t    return jnp.ones(operator.in_size())\n\t@diagonal.register(DiagonalLinearOperator)\n\t@diagonal.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    return operator.diagonal\n\t# tridiagonal\n\t@ft.singledispatch\n\tdef tridiagonal(\n", "    operator: AbstractLinearOperator,\n\t) -> tuple[Shaped[Array, \" size\"], Shaped[Array, \" size-1\"], Shaped[Array, \" size-1\"]]:\n\t    \"\"\"Extracts the diagonal, lower diagonal, and upper diagonal, from a linear\n\t    operator. Returns three vectors.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    A 3-tuple, consisting of:\n\t    - The diagonal of the matrix, represented as a vector.\n\t    - The lower diagonal of the matrix, represented as a vector.\n", "    - The upper diagonal of the matrix, represented as a vector.\n\t    If the diagonal has shape `(a,)` then the lower and upper diagonals will have shape\n\t    `(a - 1,)`.\n\t    For most operators these are computed by materialising the array and then extracting\n\t    the relevant elements, e.g. getting the main diagonal via\n\t    `jnp.diag(operator.as_matrix())`. Some operators (e.g.\n\t    [`lineax.TridiagonalLinearOperator`][]) can have more efficient implementations.\n\t    If you don't know what kind of operator you might have, then this function ensures\n\t    that you always get the most efficient implementation.\n\t    \"\"\"\n", "    _default_not_implemented(\"tridiagonal\", operator)\n\t@tridiagonal.register(MatrixLinearOperator)\n\t@tridiagonal.register(PyTreeLinearOperator)\n\t@tridiagonal.register(JacobianLinearOperator)\n\t@tridiagonal.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    matrix = operator.as_matrix()\n\t    assert matrix.ndim == 2\n\t    diagonal = jnp.diagonal(matrix, offset=0)\n\t    upper_diagonal = jnp.diagonal(matrix, offset=1)\n", "    lower_diagonal = jnp.diagonal(matrix, offset=-1)\n\t    return diagonal, lower_diagonal, upper_diagonal\n\t@tridiagonal.register(IdentityLinearOperator)\n\tdef _(operator):\n\t    size = operator.in_size()\n\t    diagonal = jnp.ones(size)\n\t    off_diagonal = jnp.zeros(size - 1)\n\t    return diagonal, off_diagonal, off_diagonal\n\t@tridiagonal.register(DiagonalLinearOperator)\n\tdef _(operator):\n", "    (size,) = operator.diagonal.shape\n\t    off_diagonal = jnp.zeros(size - 1)\n\t    return operator.diagonal, off_diagonal, off_diagonal\n\t@tridiagonal.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    return operator.diagonal, operator.lower_diagonal, operator.upper_diagonal\n\t# is_symmetric\n\t@ft.singledispatch\n\tdef is_symmetric(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as symmetric.\n", "    See [the documentation on linear operator tags](../api/tags.md) for more\n\t    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Either `True` or `False.`\n\t    \"\"\"\n\t    _default_not_implemented(\"is_symmetric\", operator)\n\t@is_symmetric.register(MatrixLinearOperator)\n\t@is_symmetric.register(PyTreeLinearOperator)\n", "@is_symmetric.register(JacobianLinearOperator)\n\t@is_symmetric.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return any(\n\t        tag in operator.tags\n\t        for tag in (\n\t            symmetric_tag,\n\t            positive_semidefinite_tag,\n\t            negative_semidefinite_tag,\n\t            diagonal_tag,\n", "        )\n\t    )\n\t@is_symmetric.register(IdentityLinearOperator)\n\tdef _(operator):\n\t    return eqx.tree_equal(operator.in_structure(), operator.out_structure()) is True\n\t@is_symmetric.register(DiagonalLinearOperator)\n\tdef _(operator):\n\t    return True\n\t@is_symmetric.register(TridiagonalLinearOperator)\n\tdef _(operator):\n", "    return False\n\t# is_diagonal\n\t@ft.singledispatch\n\tdef is_diagonal(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as diagonal.\n\t    See [the documentation on linear operator tags](../api/tags.md) for more\n\t    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n", "    Either `True` or `False.`\n\t    \"\"\"\n\t    _default_not_implemented(\"is_diagonal\", operator)\n\t@is_diagonal.register(MatrixLinearOperator)\n\t@is_diagonal.register(PyTreeLinearOperator)\n\t@is_diagonal.register(JacobianLinearOperator)\n\t@is_diagonal.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return diagonal_tag in operator.tags\n\t@is_diagonal.register(IdentityLinearOperator)\n", "@is_diagonal.register(DiagonalLinearOperator)\n\tdef _(operator):\n\t    return True\n\t@is_diagonal.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    return False\n\t# is_tridiagonal\n\t@ft.singledispatch\n\tdef is_tridiagonal(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as tridiagonal.\n", "    See [the documentation on linear operator tags](../api/tags.md) for more\n\t    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Either `True` or `False.`\n\t    \"\"\"\n\t    _default_not_implemented(\"is_tridiagonal\", operator)\n\t@is_tridiagonal.register(MatrixLinearOperator)\n\t@is_tridiagonal.register(PyTreeLinearOperator)\n", "@is_tridiagonal.register(JacobianLinearOperator)\n\t@is_tridiagonal.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return tridiagonal_tag in operator.tags or diagonal_tag in operator.tags\n\t@is_tridiagonal.register(IdentityLinearOperator)\n\t@is_tridiagonal.register(DiagonalLinearOperator)\n\t@is_tridiagonal.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    return True\n\t# has_unit_diagonal\n", "@ft.singledispatch\n\tdef has_unit_diagonal(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as having unit diagonal.\n\t    See [the documentation on linear operator tags](../api/tags.md) for more\n\t    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Either `True` or `False.`\n\t    \"\"\"\n", "    _default_not_implemented(\"has_unit_diagonal\", operator)\n\t@has_unit_diagonal.register(MatrixLinearOperator)\n\t@has_unit_diagonal.register(PyTreeLinearOperator)\n\t@has_unit_diagonal.register(JacobianLinearOperator)\n\t@has_unit_diagonal.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return unit_diagonal_tag in operator.tags\n\t@has_unit_diagonal.register(IdentityLinearOperator)\n\tdef _(operator):\n\t    return True\n", "@has_unit_diagonal.register(DiagonalLinearOperator)\n\t@has_unit_diagonal.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    # TODO: refine this\n\t    return False\n\t# is_lower_triangular\n\t@ft.singledispatch\n\tdef is_lower_triangular(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as lower triangular.\n\t    See [the documentation on linear operator tags](../api/tags.md) for more\n", "    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Either `True` or `False.`\n\t    \"\"\"\n\t    _default_not_implemented(\"is_lower_triangular\", operator)\n\t@is_lower_triangular.register(MatrixLinearOperator)\n\t@is_lower_triangular.register(PyTreeLinearOperator)\n\t@is_lower_triangular.register(JacobianLinearOperator)\n", "@is_lower_triangular.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return lower_triangular_tag in operator.tags\n\t@is_lower_triangular.register(IdentityLinearOperator)\n\t@is_lower_triangular.register(DiagonalLinearOperator)\n\tdef _(operator):\n\t    return True\n\t@is_lower_triangular.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    return False\n", "# is_upper_triangular\n\t@ft.singledispatch\n\tdef is_upper_triangular(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as upper triangular.\n\t    See [the documentation on linear operator tags](../api/tags.md) for more\n\t    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Either `True` or `False.`\n", "    \"\"\"\n\t    _default_not_implemented(\"is_upper_triangular\", operator)\n\t@is_upper_triangular.register(MatrixLinearOperator)\n\t@is_upper_triangular.register(PyTreeLinearOperator)\n\t@is_upper_triangular.register(JacobianLinearOperator)\n\t@is_upper_triangular.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return upper_triangular_tag in operator.tags\n\t@is_upper_triangular.register(IdentityLinearOperator)\n\t@is_upper_triangular.register(DiagonalLinearOperator)\n", "def _(operator):\n\t    return True\n\t@is_upper_triangular.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    return False\n\t# is_positive_semidefinite\n\t@ft.singledispatch\n\tdef is_positive_semidefinite(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as positive semidefinite.\n\t    See [the documentation on linear operator tags](../api/tags.md) for more\n", "    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n\t    Either `True` or `False.`\n\t    \"\"\"\n\t    _default_not_implemented(\"is_positive_semidefinite\", operator)\n\t@is_positive_semidefinite.register(MatrixLinearOperator)\n\t@is_positive_semidefinite.register(PyTreeLinearOperator)\n\t@is_positive_semidefinite.register(JacobianLinearOperator)\n", "@is_positive_semidefinite.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return positive_semidefinite_tag in operator.tags\n\t@is_positive_semidefinite.register(IdentityLinearOperator)\n\tdef _(operator):\n\t    return True\n\t@is_positive_semidefinite.register(DiagonalLinearOperator)\n\t@is_positive_semidefinite.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    # TODO: refine this\n", "    return False\n\t# is_negative_semidefinite\n\t@ft.singledispatch\n\tdef is_negative_semidefinite(operator: AbstractLinearOperator) -> bool:\n\t    \"\"\"Returns whether an operator is marked as negative semidefinite.\n\t    See [the documentation on linear operator tags](../api/tags.md) for more\n\t    information.\n\t    **Arguments:**\n\t    - `operator`: a linear operator.\n\t    **Returns:**\n", "    Either `True` or `False.`\n\t    \"\"\"\n\t    _default_not_implemented(\"is_negative_semidefinite\", operator)\n\t@is_negative_semidefinite.register(MatrixLinearOperator)\n\t@is_negative_semidefinite.register(PyTreeLinearOperator)\n\t@is_negative_semidefinite.register(JacobianLinearOperator)\n\t@is_negative_semidefinite.register(FunctionLinearOperator)\n\tdef _(operator):\n\t    return negative_semidefinite_tag in operator.tags\n\t@is_negative_semidefinite.register(IdentityLinearOperator)\n", "def _(operator):\n\t    return False\n\t@is_negative_semidefinite.register(DiagonalLinearOperator)\n\t@is_negative_semidefinite.register(TridiagonalLinearOperator)\n\tdef _(operator):\n\t    # TODO: refine this\n\t    return False\n\t# ops for wrapper operators\n\t@linearise.register(TaggedLinearOperator)\n\tdef _(operator):\n", "    return TaggedLinearOperator(linearise(operator.operator), operator.tags)\n\t@materialise.register(TaggedLinearOperator)\n\tdef _(operator):\n\t    return TaggedLinearOperator(materialise(operator.operator), operator.tags)\n\t@diagonal.register(TaggedLinearOperator)\n\tdef _(operator):\n\t    # Untagged; we might not have any of the properties our tags represent any more.\n\t    return diagonal(operator.operator)\n\t@tridiagonal.register(TaggedLinearOperator)\n\tdef _(operator):\n", "    return tridiagonal(operator.operator)\n\tfor transform in (linearise, materialise, diagonal):\n\t    @transform.register(TangentLinearOperator)\n\t    def _(operator, transform=transform):\n\t        primal_out, tangent_out = eqx.filter_jvp(\n\t            transform, (operator.primal,), (operator.tangent,)\n\t        )\n\t        return TangentLinearOperator(primal_out, tangent_out)\n\t    @transform.register(AddLinearOperator)  # pyright: ignore\n\t    def _(operator, transform=transform):\n", "        return transform(operator.operator1) + transform(operator.operator2)\n\t    @transform.register(MulLinearOperator)\n\t    def _(operator, transform=transform):\n\t        return transform(operator.operator) * operator.scalar\n\t    @transform.register(DivLinearOperator)\n\t    def _(operator, transform=transform):\n\t        return transform(operator.operator) / operator.scalar\n\t    @transform.register(AuxLinearOperator)  # pyright: ignore\n\t    def _(operator, transform=transform):\n\t        return transform(operator.operator)\n", "@tridiagonal.register(TangentLinearOperator)\n\tdef _(operator):\n\t    # this one I'm a bit uncertain about\n\t    primal_out, tangent_out = eqx.filter_jvp(\n\t        transform, (operator.primal,), (operator.tangent,)\n\t    )\n\t    return TangentLinearOperator(primal_out, tangent_out)\n\t@tridiagonal.register(AddLinearOperator)\n\tdef _(operator):\n\t    (diag1, lower1, upper1) = tridiagonal(operator.operator1)\n", "    (diag2, lower2, upper2) = tridiagonal(operator.operator2)\n\t    return (diag1 + diag2, lower1 + lower2, upper1 + upper2)\n\t@tridiagonal.register(MulLinearOperator)\n\tdef _(operator):\n\t    (diag, lower, upper) = tridiagonal(operator.operator)\n\t    return (diag * operator.scalar, lower * operator.scalar, upper * operator.scalar)\n\t@tridiagonal.register(DivLinearOperator)\n\tdef _(operator):\n\t    (diag, lower, upper) = tridiagonal(operator.operator)\n\t    return (diag / operator.scalar, lower / operator.scalar, upper / operator.scalar)\n", "@tridiagonal.register(AuxLinearOperator)\n\tdef _(operator):\n\t    return tridiagonal(operator.operator)\n\t@linearise.register(ComposedLinearOperator)\n\tdef _(operator):\n\t    return linearise(operator.operator1) @ linearise(operator.operator2)\n\t@materialise.register(ComposedLinearOperator)\n\tdef _(operator):\n\t    return materialise(operator.operator1) @ materialise(operator.operator2)\n\t@diagonal.register(ComposedLinearOperator)\n", "def _(operator):\n\t    return jnp.diag(operator.as_matrix())\n\t@tridiagonal.register(ComposedLinearOperator)\n\tdef _(operator):\n\t    matrix = operator.as_matrix()\n\t    assert matrix.ndim == 2\n\t    diagonal = jnp.diagonal(matrix, offset=0)\n\t    upper_diagonal = jnp.diagonal(matrix, offset=1)\n\t    lower_diagonal = jnp.diagonal(matrix, offset=-1)\n\t    return diagonal, lower_diagonal, upper_diagonal\n", "for check in (\n\t    is_symmetric,\n\t    is_diagonal,\n\t    has_unit_diagonal,\n\t    is_lower_triangular,\n\t    is_upper_triangular,\n\t    is_positive_semidefinite,\n\t    is_negative_semidefinite,\n\t    is_tridiagonal,\n\t):\n", "    @check.register(TangentLinearOperator)\n\t    def _(operator, check=check):\n\t        return check(operator.primal)\n\t    @check.register(MulLinearOperator)\n\t    @check.register(DivLinearOperator)\n\t    @check.register(AuxLinearOperator)\n\t    def _(operator, check=check):\n\t        return check(operator.operator)\n\tfor check, tag in (\n\t    (is_symmetric, symmetric_tag),\n", "    (is_diagonal, diagonal_tag),\n\t    (has_unit_diagonal, unit_diagonal_tag),\n\t    (is_lower_triangular, lower_triangular_tag),\n\t    (is_upper_triangular, upper_triangular_tag),\n\t    (is_positive_semidefinite, positive_semidefinite_tag),\n\t    (is_negative_semidefinite, negative_semidefinite_tag),\n\t    (is_tridiagonal, tridiagonal_tag),\n\t):\n\t    @check.register(TaggedLinearOperator)\n\t    def _(operator, check=check, tag=tag):\n", "        return (tag in operator.tags) or check(operator.operator)\n\tfor check in (\n\t    is_symmetric,\n\t    is_diagonal,\n\t    is_lower_triangular,\n\t    is_upper_triangular,\n\t    is_positive_semidefinite,\n\t    is_negative_semidefinite,\n\t    is_tridiagonal,\n\t):\n", "    @check.register(AddLinearOperator)\n\t    def _(operator, check=check):\n\t        return check(operator.operator1) and check(operator.operator2)\n\t@has_unit_diagonal.register(AddLinearOperator)\n\tdef _(operator):\n\t    return False\n\tfor check in (\n\t    is_symmetric,\n\t    is_diagonal,\n\t    is_lower_triangular,\n", "    is_upper_triangular,\n\t    is_positive_semidefinite,\n\t    is_negative_semidefinite,\n\t    is_tridiagonal,\n\t):\n\t    @check.register(ComposedLinearOperator)\n\t    def _(operator, check=check):\n\t        return check(operator.operator1) and check(operator.operator2)\n\t@has_unit_diagonal.register(ComposedLinearOperator)\n\tdef _(operator):\n", "    a = is_diagonal(operator)\n\t    b = is_lower_triangular(operator)\n\t    c = is_upper_triangular(operator)\n\t    d = has_unit_diagonal(operator.operator1)\n\t    e = has_unit_diagonal(operator.operator2)\n\t    return (a or b or c) and d and e\n"]}
{"filename": "lineax/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom . import internal as internal\n\tfrom ._operator import (\n\t    AbstractLinearOperator as AbstractLinearOperator,\n\t    AddLinearOperator as AddLinearOperator,\n\t    AuxLinearOperator as AuxLinearOperator,\n\t    ComposedLinearOperator as ComposedLinearOperator,\n\t    diagonal as diagonal,\n", "    DiagonalLinearOperator as DiagonalLinearOperator,\n\t    DivLinearOperator as DivLinearOperator,\n\t    FunctionLinearOperator as FunctionLinearOperator,\n\t    has_unit_diagonal as has_unit_diagonal,\n\t    IdentityLinearOperator as IdentityLinearOperator,\n\t    is_diagonal as is_diagonal,\n\t    is_lower_triangular as is_lower_triangular,\n\t    is_negative_semidefinite as is_negative_semidefinite,\n\t    is_positive_semidefinite as is_positive_semidefinite,\n\t    is_symmetric as is_symmetric,\n", "    is_tridiagonal as is_tridiagonal,\n\t    is_upper_triangular as is_upper_triangular,\n\t    JacobianLinearOperator as JacobianLinearOperator,\n\t    linearise as linearise,\n\t    materialise as materialise,\n\t    MatrixLinearOperator as MatrixLinearOperator,\n\t    MulLinearOperator as MulLinearOperator,\n\t    PyTreeLinearOperator as PyTreeLinearOperator,\n\t    TaggedLinearOperator as TaggedLinearOperator,\n\t    TangentLinearOperator as TangentLinearOperator,\n", "    tridiagonal as tridiagonal,\n\t    TridiagonalLinearOperator as TridiagonalLinearOperator,\n\t)\n\tfrom ._solution import RESULTS as RESULTS, Solution as Solution\n\tfrom ._solve import (\n\t    AbstractLinearSolver as AbstractLinearSolver,\n\t    AutoLinearSolver as AutoLinearSolver,\n\t    linear_solve as linear_solve,\n\t)\n\tfrom ._solver import (\n", "    BiCGStab as BiCGStab,\n\t    CG as CG,\n\t    Cholesky as Cholesky,\n\t    Diagonal as Diagonal,\n\t    GMRES as GMRES,\n\t    LU as LU,\n\t    NormalCG as NormalCG,\n\t    QR as QR,\n\t    SVD as SVD,\n\t    Triangular as Triangular,\n", "    Tridiagonal as Tridiagonal,\n\t)\n\tfrom ._tags import (\n\t    diagonal_tag as diagonal_tag,\n\t    lower_triangular_tag as lower_triangular_tag,\n\t    negative_semidefinite_tag as negative_semidefinite_tag,\n\t    positive_semidefinite_tag as positive_semidefinite_tag,\n\t    symmetric_tag as symmetric_tag,\n\t    transpose_tags as transpose_tags,\n\t    transpose_tags_rules as transpose_tags_rules,\n", "    tridiagonal_tag as tridiagonal_tag,\n\t    unit_diagonal_tag as unit_diagonal_tag,\n\t    upper_triangular_tag as upper_triangular_tag,\n\t)\n\t__version__ = \"0.0.1\"\n"]}
{"filename": "lineax/_misc.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\tfrom collections.abc import Callable\n\timport equinox as eqx\n\timport jax\n\timport jax.core\n\timport jax.flatten_util as jfu\n\timport jax.lax as lax\n", "import jax.numpy as jnp\n\timport jax.tree_util as jtu\n\tfrom jaxtyping import Array, ArrayLike, Bool, PyTree, Scalar  # pyright:ignore\n\tdef two_norm(x: PyTree) -> Scalar:\n\t    x, _ = jfu.ravel_pytree(x)\n\t    if x.size == 0:\n\t        return jnp.array(0.0)\n\t    return _two_norm(x)\n\t@jax.custom_jvp\n\tdef _two_norm(x):\n", "    x_sq = jnp.real(x * jnp.conj(x))\n\t    return jnp.sqrt(jnp.sum(x_sq))\n\t@_two_norm.defjvp\n\tdef _two_norm_jvp(x, tx):\n\t    (x,) = x\n\t    (tx,) = tx\n\t    out = _two_norm(x)\n\t    # Get zero gradient, rather than NaN gradient, in these cases\n\t    pred = (out == 0) | jnp.isinf(out)\n\t    numerator = jnp.where(pred, 0, jnp.dot(x, tx))\n", "    denominator = jnp.where(pred, 1, out)\n\t    t_out = numerator / denominator\n\t    return out, t_out\n\tdef tree_dot(a: PyTree[Array], b: PyTree[Array]) -> Array:\n\t    a = jtu.tree_leaves(a)\n\t    b = jtu.tree_leaves(b)\n\t    assert len(a) == len(b)\n\t    return sum(\n\t        [\n\t            jnp.vdot(ai, bi, precision=lax.Precision.HIGHEST) for ai, bi in zip(a, b)\n", "        ]  # pyright:ignore\n\t    )\n\tdef tree_where(\n\t    pred: Bool[ArrayLike, \"\"], true: PyTree[ArrayLike], false: PyTree[ArrayLike]\n\t) -> PyTree[Array]:\n\t    keep = lambda a, b: jnp.where(pred, a, b)\n\t    return jtu.tree_map(keep, true, false)\n\tdef max_norm(x: PyTree) -> Scalar:\n\t    # a standard python max will fail when jax tracers are introduced.\n\t    return jtu.tree_reduce(\n", "        jnp.maximum,\n\t        [jnp.max(jnp.abs(xi)) for xi in jtu.tree_leaves(x)],\n\t    )\n\tdef resolve_rcond(rcond, n, m, dtype):\n\t    if rcond is None:\n\t        return jnp.finfo(dtype).eps * max(n, m)\n\t    else:\n\t        return jnp.where(rcond < 0, jnp.finfo(dtype).eps, rcond)\n\tclass NoneAux(eqx.Module):\n\t    fn: Callable\n", "    def __call__(self, *args, **kwargs):\n\t        return self.fn(*args, **kwargs), None\n\tdef jacobian(fn, in_size, out_size, has_aux=False):\n\t    # Heuristic for which is better in each case\n\t    # These could probably be tuned a lot more.\n\t    if (in_size < 100) or (in_size <= 1.5 * out_size):\n\t        return jax.jacfwd(fn, has_aux=has_aux)\n\t    else:\n\t        return jax.jacrev(fn, has_aux=has_aux)\n\tdef _to_struct(x):\n", "    if eqx.is_array(x):\n\t        return jax.ShapeDtypeStruct(x.shape, x.dtype)\n\t    else:\n\t        return x\n\t@ft.lru_cache(maxsize=128)\n\tdef _cached_eval_shape(leaves, treedef):\n\t    fn, args, kwargs = jtu.tree_unflatten(treedef, leaves)\n\t    return eqx.filter_eval_shape(fn, *args, **kwargs)\n\tdef cached_eval_shape(fn, *args, **kwargs):\n\t    tree = jtu.tree_map(_to_struct, (fn, args, kwargs))\n", "    leaves, treedef = jtu.tree_flatten(tree)\n\t    leaves = tuple(leaves)\n\t    return _cached_eval_shape(leaves, treedef)\n\tdef default_floating_dtype():\n\t    if jax.config.jax_enable_x64:  # pyright: ignore\n\t        return jnp.float64\n\t    else:\n\t        return jnp.float32\n\tdef _asarray(dtype, x):\n\t    return jnp.asarray(x, dtype=dtype)\n", "# Work around JAX issue #15676\n\t_asarray = jax.custom_jvp(_asarray, nondiff_argnums=(0,))\n\t@_asarray.defjvp\n\tdef _asarray_jvp(dtype, x, tx):\n\t    (x,) = x\n\t    (tx,) = tx\n\t    return _asarray(dtype, x), _asarray(dtype, tx)\n\tdef inexact_asarray(x):\n\t    dtype = jnp.result_type(x)\n\t    if not jnp.issubdtype(jnp.result_type(x), jnp.inexact):\n", "        dtype = default_floating_dtype()\n\t    return _asarray(dtype, x)\n"]}
{"filename": "lineax/_tags.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tclass _HasRepr:\n\t    def __init__(self, string: str):\n\t        self.string = string\n\t    def __repr__(self):\n\t        return self.string\n\tsymmetric_tag = _HasRepr(\"symmetric_tag\")\n\tdiagonal_tag = _HasRepr(\"diagonal_tag\")\n", "tridiagonal_tag = _HasRepr(\"tridiagonal_tag\")\n\tunit_diagonal_tag = _HasRepr(\"unit_diagonal_tag\")\n\tlower_triangular_tag = _HasRepr(\"lower_triangular_tag\")\n\tupper_triangular_tag = _HasRepr(\"upper_triangular_tag\")\n\tpositive_semidefinite_tag = _HasRepr(\"positive_semidefinite_tag\")\n\tnegative_semidefinite_tag = _HasRepr(\"negative_semidefinite_tag\")\n\ttranspose_tags_rules = []\n\tfor tag in (\n\t    symmetric_tag,\n\t    unit_diagonal_tag,\n", "    diagonal_tag,\n\t    positive_semidefinite_tag,\n\t    negative_semidefinite_tag,\n\t    tridiagonal_tag,\n\t):\n\t    @transpose_tags_rules.append\n\t    def _(tags: frozenset[object], tag=tag):\n\t        if tag in tags:\n\t            return tag\n\t@transpose_tags_rules.append\n", "def _(tags: frozenset[object]):\n\t    if lower_triangular_tag in tags:\n\t        return upper_triangular_tag\n\t@transpose_tags_rules.append\n\tdef _(tags: frozenset[object]):\n\t    if upper_triangular_tag in tags:\n\t        return lower_triangular_tag\n\tdef transpose_tags(tags: frozenset[object]):\n\t    \"\"\"Lineax uses \"tags\" to declare that a particular linear operator exhibits some\n\t    property, e.g. symmetry.\n", "    This function takes in a collection of tags representing a linear operator, and\n\t    returns a collection of tags that should be associated with the transpose of that\n\t    linear operator.\n\t    **Arguments:**\n\t    - `tags`: a `frozenset` of tags.\n\t    **Returns:**\n\t    A `frozenset` of tags.\n\t    \"\"\"\n\t    if symmetric_tag in tags:\n\t        return tags\n", "    new_tags = []\n\t    for rule in transpose_tags_rules:\n\t        out = rule(tags)\n\t        if out is not None:\n\t            new_tags.append(out)\n\t    return frozenset(new_tags)\n"]}
{"filename": "lineax/_solution.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any\n\timport equinox as eqx\n\timport equinox.internal as eqxi\n\tfrom jaxtyping import Array, ArrayLike, PyTree\n\t_singular_msg = \"\"\"\n\tThe linear solver returned non-finite (NaN or inf) output. This usually means that the\n\toperator was not well-posed, and that the solver does not support this.\n", "If you are trying solve a linear least-squares problem then you should pass\n\t`solver=AutoLinearSolver(well_posed=False)`. By default `lineax.linear_solve`\n\tassumes that the operator is square and nonsingular.\n\tIf you *were* expecting this solver to work with this operator, then it may be because:\n\t(a) the operator is singular, and your code has a bug; or\n\t(b) the operator was nearly singular (i.e. it had a high condition number:\n\t    `jnp.linalg.cond(operator.as_matrix())` is large), and the solver suffered from\n\t    numerical instability issues; or\n\t(c) the operator is declared to exhibit a certain property (e.g. positive definiteness)\n\t    that is does not actually satisfy.\n", "\"\"\".strip()\n\tclass RESULTS(eqxi.Enumeration):\n\t    successful = \"\"\n\t    max_steps_reached = (\n\t        \"The maximum number of solver steps was reached. Try increasing `max_steps`.\"\n\t    )\n\t    singular = _singular_msg\n\t    breakdown = (\n\t        \"A form of iterative breakdown has occured in the linear solve. \"\n\t        \"Try using a different solver for this problem or increase `restart` \"\n", "        \"if using GMRES.\"\n\t    )\n\t    stagnation = (\n\t        \"A stagnation in an iterative linear solve has occurred. Try increasing \"\n\t        \"`stagnation_iters` or `restart`.\"\n\t    )\n\tclass Solution(eqx.Module):\n\t    \"\"\"The solution to a linear solve.\n\t    **Attributes:**\n\t    - `value`: The solution to the solve.\n", "    - `result`: An integer representing whether the solve was successful or not. This\n\t        can be converted into a human-readable error message via\n\t        `lineax.RESULTS[result]`.\n\t    - `stats`: Statistics about the solver, e.g. the number of steps that were required.\n\t    - `state`: The internal state of the solver. The meaning of this is specific to each\n\t        solver.\n\t    \"\"\"\n\t    value: PyTree[Array]\n\t    result: RESULTS\n\t    stats: dict[str, PyTree[ArrayLike]]\n", "    state: PyTree[Any]\n"]}
{"filename": "lineax/_custom_types.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any\n\timport equinox.internal as eqxi\n\tsentinel: Any = eqxi.doc_repr(object(), \"sentinel\")\n"]}
{"filename": "lineax/_solver/diagonal.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any, Optional\n\tfrom typing_extensions import TypeAlias\n\timport jax.flatten_util as jfu\n\timport jax.numpy as jnp\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._misc import resolve_rcond\n\tfrom .._operator import AbstractLinearOperator, diagonal, has_unit_diagonal, is_diagonal\n", "from .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver\n\t_DiagonalState: TypeAlias = Optional[Array]\n\tclass Diagonal(AbstractLinearSolver[_DiagonalState]):\n\t    \"\"\"Diagonal solver for linear systems.\n\t    Requires that the operator be diagonal. Then $Ax = b$, with $A = diag[a]$, is\n\t    solved simply by doing an elementwise division $x = b / a$.\n\t    This solver can handle singular operators (i.e. diagonal entries with value 0).\n\t    \"\"\"\n\t    well_posed: bool = False\n", "    rcond: Optional[float] = None\n\t    def init(\n\t        self, operator: AbstractLinearOperator, options: dict[str, Any]\n\t    ) -> _DiagonalState:\n\t        del options\n\t        if operator.in_size() != operator.out_size():\n\t            raise ValueError(\n\t                \"`Diagonal` may only be used for linear solves with square matrices\"\n\t            )\n\t        if not is_diagonal(operator):\n", "            raise ValueError(\n\t                \"`Diagonal` may only be used for linear solves with diagonal matrices\"\n\t            )\n\t        if has_unit_diagonal(operator):\n\t            return None\n\t        else:\n\t            return diagonal(operator)\n\t    def compute(\n\t        self, state: _DiagonalState, vector: PyTree[Array], options: dict[str, Any]\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n", "        diag = state\n\t        del state, options\n\t        unit_diagonal = diag is None\n\t        # diagonal => symmetric => (in_structure == out_structure) =>\n\t        # we don't need to use packed structures.\n\t        if unit_diagonal:\n\t            solution = vector\n\t        else:\n\t            vector, unflatten = jfu.ravel_pytree(vector)\n\t            if not self.well_posed:\n", "                (size,) = diag.shape\n\t                rcond = resolve_rcond(self.rcond, size, size, diag.dtype)\n\t                abs_diag = jnp.abs(diag)\n\t                diag = jnp.where(abs_diag > rcond * jnp.max(abs_diag), diag, jnp.inf)\n\t            solution = unflatten(vector / diag)\n\t        return solution, RESULTS.successful, {}\n\t    def transpose(self, state: _DiagonalState, options: dict[str, Any]):\n\t        # Matrix is symmetric\n\t        return state, options\n\t    def allow_dependent_columns(self, operator):\n", "        return not self.well_posed\n\t    def allow_dependent_rows(self, operator):\n\t        return not self.well_posed\n\tDiagonal.__init__.__doc__ = \"\"\"**Arguments**:\n\t- `well_posed`: if `False`, then singular operators are accepted, and the pseudoinverse\n\t    solution is returned. If `True` then passing a singular operator will cause an error\n\t    to be raised instead.\n\t- `rcond`: the cutoff for handling zero entries on the diagonal. Defaults to machine\n\t    precision times `N`, where `N` is the input (or output) size of the operator.\n\t    Only used if `well_posed=False`\n", "\"\"\"\n"]}
{"filename": "lineax/_solver/tridiagonal.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any\n\tfrom typing_extensions import TypeAlias\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._operator import AbstractLinearOperator, is_tridiagonal, tridiagonal\n\tfrom .._solution import RESULTS\n", "from .._solve import AbstractLinearSolver\n\tfrom .misc import (\n\t    pack_structures,\n\t    PackedStructures,\n\t    ravel_vector,\n\t    transpose_packed_structures,\n\t    unravel_solution,\n\t)\n\t_TridiagonalState: TypeAlias = tuple[tuple[Array, Array, Array], PackedStructures]\n\tclass Tridiagonal(AbstractLinearSolver[_TridiagonalState]):\n", "    \"\"\"Tridiagonal solver for linear systems, using the Thomas algorithm.\"\"\"\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n\t        del options\n\t        if operator.in_size() != operator.out_size():\n\t            raise ValueError(\n\t                \"`Tridiagonal` may only be used for linear solves with square matrices\"\n\t            )\n\t        if not is_tridiagonal(operator):\n\t            raise ValueError(\n\t                \"`Tridiagonal` may only be used for linear solves with tridiagonal \"\n", "                \"matrices\"\n\t            )\n\t        return tridiagonal(operator), pack_structures(operator)\n\t    def compute(\n\t        self,\n\t        state: _TridiagonalState,\n\t        vector,\n\t        options,\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        (diagonal, lower_diagonal, upper_diagonal), packed_structures = state\n", "        del state, options\n\t        vector = ravel_vector(vector, packed_structures)\n\t        #\n\t        # notation from: https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm\n\t        # _p indicates prime, ie. `d_p` is the variable name for d' on wikipedia\n\t        #\n\t        size = len(diagonal)\n\t        def thomas_scan(prev_cd_carry, bd):\n\t            c_p, d_p, step = prev_cd_carry\n\t            # the index of `a` doesn't matter at step 0 as\n", "            # we won't use it at all. Same for `c` at final step\n\t            a_index = jnp.where(step > 0, step - 1, 0)\n\t            c_index = jnp.where(step < size, step, 0)\n\t            b, d = bd\n\t            a, c = lower_diagonal[a_index], upper_diagonal[c_index]\n\t            denom = b - a * c_p\n\t            new_d_p = (d - a * d_p) / denom\n\t            new_c_p = c / denom\n\t            return (new_c_p, new_d_p, step + 1), (new_c_p, new_d_p)\n\t        def backsub(prev_x_carry, cd_p):\n", "            x_prev, step = prev_x_carry\n\t            c_p, d_p = cd_p\n\t            x_new = d_p - c_p * x_prev\n\t            return (x_new, step + 1), x_new\n\t        # not a dummy init! 0 is the proper value for all of these\n\t        init_thomas = (0, 0, 0)\n\t        init_backsub = (0, 0)\n\t        diag_vec = (diagonal, vector)\n\t        _, cd_p = lax.scan(thomas_scan, init_thomas, diag_vec, unroll=32)\n\t        _, solution = lax.scan(backsub, init_backsub, cd_p, reverse=True, unroll=32)\n", "        solution = unravel_solution(solution, packed_structures)\n\t        return solution, RESULTS.successful, {}\n\t    def transpose(self, state: _TridiagonalState, options: dict[str, Any]):\n\t        (diagonal, lower_diagonal, upper_diagonal), packed_structures = state\n\t        transposed_packed_structures = transpose_packed_structures(packed_structures)\n\t        transpose_diagonals = (diagonal, upper_diagonal, lower_diagonal)\n\t        transpose_state = (transpose_diagonals, transposed_packed_structures)\n\t        return transpose_state, options\n\t    def allow_dependent_columns(self, operator):\n\t        return False\n", "    def allow_dependent_rows(self, operator):\n\t        return False\n"]}
{"filename": "lineax/_solver/triangular.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any\n\tfrom typing_extensions import TypeAlias\n\timport jax.scipy as jsp\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._operator import (\n\t    AbstractLinearOperator,\n\t    has_unit_diagonal,\n", "    is_lower_triangular,\n\t    is_upper_triangular,\n\t)\n\tfrom .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver\n\tfrom .misc import (\n\t    pack_structures,\n\t    PackedStructures,\n\t    ravel_vector,\n\t    transpose_packed_structures,\n", "    unravel_solution,\n\t)\n\t_TriangularState: TypeAlias = tuple[Array, bool, bool, PackedStructures, bool]\n\tclass Triangular(AbstractLinearSolver[_TriangularState]):\n\t    \"\"\"Triangular solver for linear systems.\n\t    The operator should either be lower triangular or upper triangular.\n\t    \"\"\"\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n\t        del options\n\t        if operator.in_size() != operator.out_size():\n", "            raise ValueError(\n\t                \"`Triangular` may only be used for linear solves with square matrices\"\n\t            )\n\t        if not (is_lower_triangular(operator) or is_upper_triangular(operator)):\n\t            raise ValueError(\n\t                \"`Triangular` may only be used for linear solves with triangular \"\n\t                \"matrices\"\n\t            )\n\t        return (\n\t            operator.as_matrix(),\n", "            is_lower_triangular(operator),\n\t            has_unit_diagonal(operator),\n\t            pack_structures(operator),\n\t            False,  # transposed\n\t        )\n\t    def compute(\n\t        self, state: _TriangularState, vector: PyTree[Array], options: dict[str, Any]\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        matrix, lower, unit_diagonal, packed_structures, transpose = state\n\t        del state, options\n", "        vector = ravel_vector(vector, packed_structures)\n\t        if transpose:\n\t            trans = \"T\"\n\t        else:\n\t            trans = \"N\"\n\t        solution = jsp.linalg.solve_triangular(\n\t            matrix, vector, trans=trans, lower=lower, unit_diagonal=unit_diagonal\n\t        )\n\t        solution = unravel_solution(solution, packed_structures)\n\t        return solution, RESULTS.successful, {}\n", "    def transpose(self, state: _TriangularState, options: dict[str, Any]):\n\t        matrix, lower, unit_diagonal, packed_structures, transpose = state\n\t        transposed_packed_structures = transpose_packed_structures(packed_structures)\n\t        transpose_state = (\n\t            matrix,\n\t            lower,\n\t            unit_diagonal,\n\t            transposed_packed_structures,\n\t            not transpose,\n\t        )\n", "        transpose_options = {}\n\t        return transpose_state, transpose_options\n\t    def allow_dependent_columns(self, operator):\n\t        return False\n\t    def allow_dependent_rows(self, operator):\n\t        return False\n"]}
{"filename": "lineax/_solver/qr.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any\n\tfrom typing_extensions import TypeAlias\n\timport jax.numpy as jnp\n\timport jax.scipy as jsp\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver\n", "from .misc import (\n\t    pack_structures,\n\t    PackedStructures,\n\t    ravel_vector,\n\t    transpose_packed_structures,\n\t    unravel_solution,\n\t)\n\t_QRState: TypeAlias = tuple[tuple[Array, Array], bool, PackedStructures]\n\tclass QR(AbstractLinearSolver):\n\t    \"\"\"QR solver for linear systems.\n", "    This solver can handle non-square operators.\n\t    This is usually the preferred solver when dealing with non-square operators.\n\t    !!! info\n\t        Note that whilst this does handle non-square operators, it still can only\n\t        handle full-rank operators.\n\t        This is because JAX does not currently support a rank-revealing/pivoted QR\n\t        decomposition, see [issue #12897](https://github.com/google/jax/issues/12897).\n\t        For such use cases, switch to [`lineax.SVD`][] instead.\n\t    \"\"\"\n\t    def init(self, operator, options):\n", "        del options\n\t        matrix = operator.as_matrix()\n\t        m, n = matrix.shape\n\t        transpose = n > m\n\t        if transpose:\n\t            matrix = matrix.T\n\t        qr = jnp.linalg.qr(matrix, mode=\"reduced\")\n\t        packed_structures = pack_structures(operator)\n\t        return qr, transpose, packed_structures\n\t    def compute(\n", "        self,\n\t        state: _QRState,\n\t        vector: PyTree[Array],\n\t        options: dict[str, Any],\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        (q, r), transpose, packed_structures = state\n\t        del state, options\n\t        vector = ravel_vector(vector, packed_structures)\n\t        if transpose:\n\t            # Minimal norm solution if underdetermined.\n", "            solution = q @ jsp.linalg.solve_triangular(\n\t                r, vector, trans=\"T\", unit_diagonal=False\n\t            )\n\t        else:\n\t            # Least squares solution if overdetermined.\n\t            solution = jsp.linalg.solve_triangular(\n\t                r, q.T @ vector, trans=\"N\", unit_diagonal=False\n\t            )\n\t        solution = unravel_solution(solution, packed_structures)\n\t        return solution, RESULTS.successful, {}\n", "    def transpose(self, state: _QRState, options: dict[str, Any]):\n\t        (q, r), transpose, structures = state\n\t        transposed_packed_structures = transpose_packed_structures(structures)\n\t        transpose_state = (q, r), not transpose, transposed_packed_structures\n\t        transpose_options = {}\n\t        return transpose_state, transpose_options\n\t    def allow_dependent_columns(self, operator):\n\t        rows = operator.out_size()\n\t        columns = operator.in_size()\n\t        # We're able to pull an efficiency trick here.\n", "        #\n\t        # As we don't use a rank-revealing implementation, then we always require that\n\t        # the operator have full rank.\n\t        #\n\t        # So if we have columns <= rows, then we know that all our columns are linearly\n\t        # independent. We can return `False` and get a computationally cheaper jvp rule.\n\t        return columns > rows\n\t    def allow_dependent_rows(self, operator):\n\t        rows = operator.out_size()\n\t        columns = operator.in_size()\n", "        return rows > columns\n"]}
{"filename": "lineax/_solver/gmres.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\tfrom collections.abc import Callable\n\tfrom typing import Any, cast, Optional\n\tfrom typing_extensions import TypeAlias\n\timport equinox.internal as eqxi\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n", "import jax.tree_util as jtu\n\tfrom equinox.internal import ω\n\tfrom jaxtyping import Array, ArrayLike, Bool, Float, PyTree\n\tfrom .._misc import max_norm, two_norm\n\tfrom .._operator import (\n\t    AbstractLinearOperator,\n\t    MatrixLinearOperator,\n\t)\n\tfrom .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver, linear_solve\n", "from .misc import preconditioner_and_y0\n\tfrom .qr import QR\n\t_GMRESState: TypeAlias = AbstractLinearOperator\n\tclass GMRES(AbstractLinearSolver[_GMRESState]):\n\t    \"\"\"GMRES solver for linear systems.\n\t    The operator should be square.\n\t    Similar to `jax.scipy.sparse.linalg.gmres`.\n\t    This supports the following `options` (as passed to\n\t    `lx.linear_solve(..., options=...)`).\n\t    - `preconditioner`: A positive definite [`lineax.AbstractLinearOperator`][]\n", "        to be used as preconditioner. Defaults to\n\t        [`lineax.IdentityLinearOperator`][].\n\t    - `y0`: The initial estimate of the solution to the linear system. Defaults to all\n\t        zeros.\n\t    \"\"\"\n\t    rtol: float\n\t    atol: float\n\t    norm: Callable = max_norm\n\t    max_steps: Optional[int] = None\n\t    restart: int = 20\n", "    stagnation_iters: int = 20\n\t    def __post_init__(self):\n\t        if isinstance(self.rtol, (int, float)) and self.rtol < 0:\n\t            raise ValueError(\"Tolerances must be non-negative.\")\n\t        if isinstance(self.atol, (int, float)) and self.atol < 0:\n\t            raise ValueError(\"Tolerances must be non-negative.\")\n\t        if isinstance(self.atol, (int, float)) and isinstance(self.rtol, (int, float)):\n\t            if self.atol == 0 and self.rtol == 0 and self.max_steps is None:\n\t                raise ValueError(\n\t                    \"Must specify `rtol`, `atol`, or `max_steps` (or some combination \"\n", "                    \"of all three).\"\n\t                )\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n\t        if operator.in_structure() != operator.out_structure():\n\t            raise ValueError(\n\t                \"`GMRES(..., normal=False)` may only be used for linear solves with \"\n\t                \"square matrices.\"\n\t            )\n\t        return operator\n\t    #\n", "    # This differs from `jax.scipy.sparse.linalg.gmres` in a few ways:\n\t    # 1. We use a more sophisticated termination condition. To begin with we have an\n\t    #    rtol and atol in the conventional way, inducing a vector-valued scale. This is\n\t    #    then checked in both the `y` and `b` domains (for `Ay = b`).\n\t    # 2. We handle in-place updates with buffers to avoid generating unnecessary\n\t    #    copies of arrays during the Gram-Schmidt procedure.\n\t    # 3. We use a QR solve at the end of the batched Gram-Schmidt instead\n\t    #    of a Cholesky solve of the normal equations. This is both faster and more\n\t    #    numerically stable.\n\t    # 4. We use tricks to compile `A y` fewer times throughout the code, including\n", "    #    passing a dummy initial residual.\n\t    # 5. We return the number of steps, and whether or not the solve succeeded, as\n\t    #    additional information.\n\t    # 6. We do not use the unnecessary loop within Gram-Schmidt, and simply compute\n\t    #    this in a single pass.\n\t    # 7. We add better safety checks for breakdown, and a safety check for stagnation\n\t    #    of the iterates even when we don't explicitly get breakdown.\n\t    #\n\t    def compute(\n\t        self,\n", "        state: _GMRESState,\n\t        vector: PyTree[Array],\n\t        options: dict[str, Any],\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        has_scale = not (\n\t            isinstance(self.atol, (int, float))\n\t            and isinstance(self.rtol, (int, float))\n\t            and self.atol == 0\n\t            and self.rtol == 0\n\t        )\n", "        if has_scale:\n\t            b_scale = (self.atol + self.rtol * ω(vector).call(jnp.abs)).ω\n\t        operator = state\n\t        preconditioner, y0 = preconditioner_and_y0(operator, vector, options)\n\t        leaves, _ = jtu.tree_flatten(vector)\n\t        size = sum(leaf.size for leaf in leaves)\n\t        if self.max_steps is None:\n\t            max_steps = 10 * size  # Copied from SciPy!\n\t        else:\n\t            max_steps = self.max_steps\n", "        restart = min(self.restart, size)\n\t        def not_converged(r, diff, y):\n\t            # The primary tolerance check.\n\t            # Given Ay=b, then we have to be doing better than `scale` in both\n\t            # the `y` and the `b` spaces.\n\t            if has_scale:\n\t                y_scale = (self.atol + self.rtol * ω(y).call(jnp.abs)).ω\n\t                norm1 = self.norm((r**ω / b_scale**ω).ω)\n\t                norm2 = self.norm((diff**ω / y_scale**ω).ω)\n\t                return (norm1 > 1) | (norm2 > 1)\n", "            else:\n\t                return True\n\t        def cond_fun(carry):\n\t            y, r, _, deferred_breakdown, diff, _, step, stagnation_counter = carry\n\t            # NOTE: we defer ending due to breakdown by one loop! This is nonstandard,\n\t            # but lets us use a cauchy-like condition in the convergence criteria.\n\t            # If we do not defer breakdown, breakdown may detect convergence when\n\t            # the diff between two iterations is still quite large, and we only\n\t            # consider convergence when the diff is small.\n\t            out = jnp.invert(deferred_breakdown) & (\n", "                stagnation_counter < self.stagnation_iters\n\t            )\n\t            out = out & not_converged(r, diff, y)\n\t            out = out & (step < max_steps)\n\t            # The first pass uses a dummy value for r0 in order to save on compiling\n\t            # an extra matvec. The dummy step may raise a breakdown, and `step == 0`\n\t            # avoids us from returning prematurely.\n\t            return out | (step == 0)\n\t        def body_fun(carry):\n\t            # `breakdown` -> `deferred_breakdown` and `deferred_breakdown` -> `_`\n", "            y, r, deferred_breakdown, _, diff, r_min, step, stagnation_counter = carry\n\t            y_new, r_new, breakdown, diff_new = self._gmres_compute(\n\t                operator, vector, y, r, restart, preconditioner, b_scale, step == 0\n\t            )\n\t            #\n\t            # If the minimum residual does not decrease for many iterations\n\t            # (\"many\" is determined by self.stagnation_iters) then the iterative\n\t            # solve has stagnated and we stop the loop. This bit keeps track of how\n\t            # long it has been since the minimum has decreased, and updates the minimum\n\t            # when a new minimum is encountered. As far as I (raderj) am\n", "            # aware, this is custom to our implementation and not standard practice.\n\t            #\n\t            r_new_norm = self.norm(r_new)\n\t            r_decreased = (r_new_norm - r_min) < 0\n\t            stagnation_counter = jnp.where(r_decreased, 0, stagnation_counter + 1)\n\t            stagnation_counter = cast(Array, stagnation_counter)\n\t            r_min = jnp.minimum(r_new_norm, r_min)\n\t            return (\n\t                y_new,\n\t                r_new,\n", "                breakdown,\n\t                deferred_breakdown,\n\t                diff_new,\n\t                r_min,\n\t                step + 1,\n\t                stagnation_counter,\n\t            )\n\t        # Initialise the residual r0 to the dummy value of all 0s. This means\n\t        # the first iteration of Gram-Schmidt will do nothing, but it saves\n\t        # us from compiling an extra matvec here.\n", "        r0 = ω(vector).call(jnp.zeros_like).ω\n\t        init_carry = (\n\t            y0,  # y\n\t            r0,  # residual\n\t            False,  # breakdown\n\t            False,  # deferred_breakdown\n\t            ω(y0).call(lambda x: jnp.full_like(x, jnp.inf)).ω,  # diff\n\t            jnp.inf,  # r_min\n\t            0,  # steps\n\t            jnp.array(0),  # stagnation counter\n", "        )\n\t        (\n\t            solution,\n\t            residual,\n\t            _,  # breakdown\n\t            breakdown,  # deferred_breakdown\n\t            diff,\n\t            _,\n\t            num_steps,\n\t            stagnation_counter,\n", "        ) = lax.while_loop(cond_fun, body_fun, init_carry)\n\t        if self.max_steps is None:\n\t            result = RESULTS.where(\n\t                (num_steps == max_steps), RESULTS.singular, RESULTS.successful\n\t            )\n\t        else:\n\t            result = RESULTS.where(\n\t                (num_steps == self.max_steps),\n\t                RESULTS.max_steps_reached,\n\t                RESULTS.successful,\n", "            )\n\t        result = RESULTS.where(\n\t            stagnation_counter >= self.stagnation_iters, RESULTS.stagnation, result\n\t        )\n\t        # breakdown is only an issue if we broke down outside the tolerance\n\t        # of the solution. If we get breakdown and are within the tolerance,\n\t        # this is called convergence :)\n\t        breakdown = breakdown & not_converged(residual, diff, solution)\n\t        # breakdown is the most serious potential issue\n\t        result = RESULTS.where(breakdown, RESULTS.breakdown, result)\n", "        stats = {\"num_steps\": num_steps, \"max_steps\": self.max_steps}\n\t        return solution, result, stats\n\t    def _gmres_compute(\n\t        self, operator, vector, y, r, restart, preconditioner, b_scale, first_pass\n\t    ):\n\t        #\n\t        # internal function for computing the bulk of the gmres. We seperate this out\n\t        # for two reasons:\n\t        # 1. avoid nested body and cond functions in the body and cond function of\n\t        # `self.compute`. `self.compute` is primarily responsible for the restart\n", "        # behavior of gmres.\n\t        # 2. Like the jax.scipy implementation we may want to add an incremental\n\t        # version at a later date.\n\t        #\n\t        def main_gmres(y):\n\t            # see the comment at the end of `_arnoldi_gram_schmidt` for a discussion\n\t            # of `initial_breakdown`\n\t            r_normalised, r_norm, initial_breakdown = self._normalise(r, eps=None)\n\t            basis_init = jtu.tree_map(\n\t                lambda x: jnp.pad(x[..., None], ((0, 0),) * x.ndim + ((0, restart),)),\n", "                r_normalised,\n\t            )\n\t            coeff_mat_init = jnp.eye(restart, restart + 1, dtype=r_norm.dtype)\n\t            def cond_fun(carry):\n\t                _, _, breakdown, step = carry\n\t                return (step < restart) & jnp.invert(breakdown)\n\t            def body_fun(carry):\n\t                basis, coeff_mat, breakdown, step = carry\n\t                basis_new, coeff_mat_new, breakdown = self._arnoldi_gram_schmidt(\n\t                    operator,\n", "                    preconditioner,\n\t                    basis,\n\t                    coeff_mat,\n\t                    step,\n\t                    restart,\n\t                    b_scale,\n\t                    vector,\n\t                    breakdown,\n\t                )\n\t                return basis_new, coeff_mat_new, breakdown, step + 1\n", "            def buffers(carry):\n\t                basis, coeff_mat, _, _ = carry\n\t                return basis, coeff_mat\n\t            init_carry = (basis_init, coeff_mat_init, initial_breakdown, 0)\n\t            basis, coeff_mat, breakdown, steps = eqxi.while_loop(\n\t                cond_fun, body_fun, init_carry, kind=\"lax\", buffers=buffers\n\t            )\n\t            beta_vec = jnp.concatenate(\n\t                (r_norm[None], jnp.zeros_like(coeff_mat, shape=(restart,)))\n\t            )\n", "            coeff_op_transpose = MatrixLinearOperator(coeff_mat.T)\n\t            # TODO(raderj): move to a Hessenberg-specific solver\n\t            z = linear_solve(coeff_op_transpose, beta_vec, QR(), throw=False).value\n\t            diff = jtu.tree_map(\n\t                lambda mat: jnp.tensordot(\n\t                    mat[..., :-1], z, axes=1, precision=lax.Precision.HIGHEST\n\t                ),\n\t                basis,\n\t            )\n\t            y_new = (y**ω + diff**ω).ω\n", "            return y_new, diff, breakdown\n\t        def first_gmres(y):\n\t            return y, ω(y).call(lambda x: jnp.full_like(x, jnp.inf)).ω, False\n\t        first_pass = eqxi.unvmap_any(first_pass)\n\t        y_new, diff, breakdown = lax.cond(first_pass, first_gmres, main_gmres, y)\n\t        r_new = preconditioner.mv((vector**ω - operator.mv(y_new) ** ω).ω)\n\t        return y_new, r_new, breakdown, diff\n\t        # NOTE: in the jax implementation:\n\t        # https://github.com/google/jax/blob/\n\t        # c662fd216dec10cdb2cff4138b4318bb98853134/jax/_src/scipy/sparse/linalg.py#L327\n", "        # _classical_iterative_gram_schmidt uses a while loop to call this.\n\t        # However, max_iterations is set to 2 in all calls they make to the function,\n\t        # and the condition function requires steps < (max_iterations - 1).\n\t        # This means that in fact they only apply Gram-Schmidt once, and using a\n\t        # while_loop is unnecessary.\n\t    def _arnoldi_gram_schmidt(\n\t        self,\n\t        operator,\n\t        preconditioner,\n\t        basis,\n", "        coeff_mat,\n\t        step,\n\t        restart,\n\t        b_scale,\n\t        vector,\n\t        initial_breakdown,\n\t    ):\n\t        #\n\t        # compute `basis.T @ basis_step` for each leaf of pytree\n\t        # and then compute the projected vector onto the basis\n", "        #\n\t        # `basis` is a pytree with buffers, meaning it can only be\n\t        # indexed into. Through this section, there are terms like `lambda _, x: ...`\n\t        # because`jtu.tree_map` only uses the first argument to determine the shape\n\t        # of the pytree. Since _Buffer is considered part of the pytree\n\t        # structure, we get leaves which are not buffers if we direclty pass `basis`.\n\t        # Instead, we make sure that the first argument of the tree map is something\n\t        # with the correct pytree structure, such as `vector` in the dummy case and\n\t        # basis_step when not, so that we correctly index into `basis`.\n\t        #\n", "        basis_step = preconditioner.mv(\n\t            operator.mv(jtu.tree_map(lambda _, x: x[..., step], vector, basis))\n\t        )\n\t        step_norm = two_norm(basis_step)\n\t        contract_matrix = lambda x, y: ft.partial(\n\t            jnp.tensordot, axes=x.ndim, precision=lax.Precision.HIGHEST\n\t        )(x, y[...])\n\t        _proj = jtu.tree_map(contract_matrix, basis_step, basis)\n\t        proj = jtu.tree_reduce(lambda x, y: x + y, _proj)\n\t        proj_on_cols = jtu.tree_map(lambda _, x: x[...] @ proj, vector, basis)\n", "        # now remove the component of the vector in that subspace\n\t        basis_step_new = (basis_step**ω - proj_on_cols**ω).ω\n\t        eps = step_norm * jnp.finfo(proj.dtype).eps\n\t        basis_step_normalised, step_norm_new, breakdown = self._normalise(\n\t            basis_step_new, eps=eps\n\t        )\n\t        basis_new = jtu.tree_map(\n\t            lambda y, mat: mat.at[..., step + 1].set(y),\n\t            basis_step_normalised,\n\t            basis,\n", "        )\n\t        proj_new = proj.at[step + 1].set(step_norm_new)\n\t        #\n\t        # NOTE: two somewhat complicated things are going on here:\n\t        #\n\t        # The `coeff_mat` in_place update has a batch tracer, so we need to be\n\t        # careful and wrap it in a buffer, hence the use of eqxi.while_loop\n\t        # instead of lax.while_loop throughout.\n\t        #\n\t        # `initial_breakdown` occurs when the previous loop returns a\n", "        # residual which is small enough to be interpreted as 0 by self._normalise,\n\t        # but which was passed through the solve anyway. This occurs when\n\t        # the residual is small but the diff is not, or if the\n\t        # correct solution was given to GMRES from the start. Both of these tend to\n\t        # happen at the start of `gmres_compute`.\n\t        # The latter may happen when using a sequence of iterative methods.\n\t        # If `initial_breakdown` occurs, then we leave the `coeff_mat` as it was\n\t        # at initialisation. Replacing it with the projection (which will be all 0s)\n\t        # will mean `coeff_mat` is not full-rank, and `QR` can only handle nonsquare\n\t        # matrices of full-rank.\n", "        #\n\t        coeff_mat_new = coeff_mat.at[step, :].set(\n\t            proj_new, pred=jnp.invert(initial_breakdown)\n\t        )\n\t        return basis_new, coeff_mat_new, breakdown\n\t    def _normalise(\n\t        self, x: PyTree[Array], eps: Optional[Float[ArrayLike, \"\"]]\n\t    ) -> tuple[PyTree[Array], Float[Array, \"\"], Bool[ArrayLike, \"\"]]:\n\t        norm = two_norm(x)\n\t        if eps is None:\n", "            eps = jnp.finfo(norm.dtype).eps\n\t        breakdown = norm < eps\n\t        safe_norm = jnp.where(breakdown, jnp.inf, norm)\n\t        x_normalised = (x**ω / safe_norm).ω\n\t        return x_normalised, norm, breakdown\n\t    def transpose(self, state: _GMRESState, options: dict[str, Any]):\n\t        del options\n\t        operator = state\n\t        transpose_options = {}\n\t        return operator.transpose(), transpose_options\n", "    def allow_dependent_columns(self, operator):\n\t        return False\n\t    def allow_dependent_rows(self, operator):\n\t        return False\n\tGMRES.__init__.__doc__ = r\"\"\"**Arguments:**\n\t- `rtol`: Relative tolerance for terminating solve.\n\t- `atol`: Absolute tolerance for terminating solve.\n\t- `norm`: The norm to use when computing whether the error falls within the tolerance.\n\t    Defaults to the max norm.\n\t- `max_steps`: The maximum number of iterations to run the solver for. If more steps\n", "    than this are required, then the solve is halted with a failure.\n\t- `restart`: Size of the Krylov subspace built between restarts. The returned solution\n\t    is the projection of the true solution onto this subpsace, so this direclty\n\t    bounds the accuracy of the algorithm. Default is 20.\n\t- `stagnation_iters`: The maximum number of iterations for which the solver may not\n\t    decrease. If more than `stagnation_iters` restarts are performed without\n\t    sufficient decrease in the residual, the algorithm is halted.\n\t\"\"\"\n"]}
{"filename": "lineax/_solver/bicgstab.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom collections.abc import Callable\n\tfrom typing import Any, Optional\n\tfrom typing_extensions import TypeAlias\n\timport jax\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n\timport jax.tree_util as jtu\n", "from equinox.internal import ω\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._misc import max_norm, tree_dot\n\tfrom .._operator import AbstractLinearOperator\n\tfrom .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver\n\tfrom .misc import preconditioner_and_y0\n\t_BiCGStabState: TypeAlias = AbstractLinearOperator\n\tclass BiCGStab(AbstractLinearSolver[_BiCGStabState]):\n\t    \"\"\"Biconjugate gradient stabilised method for linear systems.\n", "    The operator should be square.\n\t    Equivalent to `jax.scipy.sparse.linalg.bicgstab`.\n\t    This supports the following `options` (as passed to\n\t    `lx.linear_solve(..., options=...)`).\n\t    - `preconditioner`: A positive definite [`lineax.AbstractLinearOperator`][]\n\t        to be used as a preconditioner. Defaults to\n\t        [`lineax.IdentityLinearOperator`][].\n\t    - `y0`: The initial estimate of the solution to the linear system. Defaults to all\n\t        zeros.\n\t    \"\"\"\n", "    rtol: float\n\t    atol: float\n\t    norm: Callable = max_norm\n\t    max_steps: Optional[int] = None\n\t    def __post_init__(self):\n\t        if isinstance(self.rtol, (int, float)) and self.rtol < 0:\n\t            raise ValueError(\"Tolerances must be non-negative.\")\n\t        if isinstance(self.atol, (int, float)) and self.atol < 0:\n\t            raise ValueError(\"Tolerances must be non-negative.\")\n\t        if isinstance(self.atol, (int, float)) and isinstance(self.rtol, (int, float)):\n", "            if self.atol == 0 and self.rtol == 0 and self.max_steps is None:\n\t                raise ValueError(\n\t                    \"Must specify `rtol`, `atol`, or `max_steps` (or some combination \"\n\t                    \"of all three).\"\n\t                )\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n\t        if operator.in_structure() != operator.out_structure():\n\t            raise ValueError(\n\t                \"`BiCGstab(..., normal=False)` may only be used for linear solves with \"\n\t                \"square matrices.\"\n", "            )\n\t        return operator\n\t    def compute(\n\t        self, state: _BiCGStabState, vector: PyTree[Array], options: dict[str, Any]\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        operator = state\n\t        preconditioner, y0 = preconditioner_and_y0(operator, vector, options)\n\t        leaves, _ = jtu.tree_flatten(vector)\n\t        if self.max_steps is None:\n\t            size = sum(leaf.size for leaf in leaves)\n", "            max_steps = 10 * size\n\t        else:\n\t            max_steps = self.max_steps\n\t        has_scale = not (\n\t            isinstance(self.atol, (int, float))\n\t            and isinstance(self.rtol, (int, float))\n\t            and self.atol == 0\n\t            and self.rtol == 0\n\t        )\n\t        if has_scale:\n", "            b_scale = (self.atol + self.rtol * ω(vector).call(jnp.abs)).ω\n\t        # This implementation is the same a jax.scipy.sparse.linalg.bicgstab\n\t        # but with AbstractLinearOperator.\n\t        # We use the notation found on the wikipedia except with y instead of x:\n\t        # https://en.wikipedia.org/wiki/\n\t        # Biconjugate_gradient_stabilized_method#Preconditioned_BiCGSTAB\n\t        r0 = (vector**ω - operator.mv(y0) ** ω).ω\n\t        def breakdown_occurred(omega, alpha, rho):\n\t            # Empirically, the tolerance checks for breakdown are very tight.\n\t            # These specific tolerances are heuristic.\n", "            if jax.config.jax_enable_x64:  # pyright: ignore\n\t                return (omega == 0.0) | (alpha == 0.0) | (rho == 0.0)\n\t            else:\n\t                return (omega < 1e-16) | (alpha < 1e-16) | (rho < 1e-16)\n\t        def not_converged(r, diff, y):\n\t            # The primary tolerance check.\n\t            # Given Ay=b, then we have to be doing better than `scale` in both\n\t            # the `y` and the `b` spaces.\n\t            if has_scale:\n\t                y_scale = (self.atol + self.rtol * ω(y).call(jnp.abs)).ω\n", "                norm1 = self.norm((r**ω / b_scale**ω).ω)\n\t                norm2 = self.norm((diff**ω / y_scale**ω).ω)\n\t                return (norm1 > 1) | (norm2 > 1)\n\t            else:\n\t                return True\n\t        def cond_fun(carry):\n\t            y, r, alpha, omega, rho, _, _, diff, step = carry\n\t            out = jnp.invert(breakdown_occurred(omega, alpha, rho))\n\t            out = out & not_converged(r, diff, y)\n\t            out = out & (step < max_steps)\n", "            return out\n\t        def body_fun(carry):\n\t            y, r, alpha, omega, rho, p, v, diff, step = carry\n\t            rho_new = tree_dot(r0, r)\n\t            beta = (rho_new / rho) * (alpha / omega)\n\t            p_new = (r**ω + beta * (p**ω - omega * v**ω)).ω\n\t            # TODO(raderj): reduce this to a single operator.mv call\n\t            # by using the scan trick.\n\t            x = preconditioner.mv(p_new)\n\t            v_new = operator.mv(x)\n", "            alpha_new = rho_new / tree_dot(r0, v_new)\n\t            s = (r**ω - alpha_new * v_new**ω).ω\n\t            z = preconditioner.mv(s)\n\t            t = operator.mv(z)\n\t            omega_new = tree_dot(t, s) / tree_dot(t, t)\n\t            diff = (alpha_new * x**ω + omega_new * z**ω).ω\n\t            y_new = (y**ω + diff**ω).ω\n\t            r_new = (s**ω - omega_new * t**ω).ω\n\t            return (\n\t                y_new,\n", "                r_new,\n\t                alpha_new,\n\t                omega_new,\n\t                rho_new,\n\t                p_new,\n\t                v_new,\n\t                diff,\n\t                step + 1,\n\t            )\n\t        p0 = v0 = jtu.tree_map(jnp.zeros_like, vector)\n", "        alpha = omega = rho = jnp.array(1.0)\n\t        init_carry = (\n\t            y0,\n\t            r0,\n\t            alpha,\n\t            omega,\n\t            rho,\n\t            p0,\n\t            v0,\n\t            ω(y0).call(lambda x: jnp.full_like(x, jnp.inf)).ω,\n", "            0,\n\t        )\n\t        solution, residual, alpha, omega, rho, _, _, diff, num_steps = lax.while_loop(\n\t            cond_fun, body_fun, init_carry\n\t        )\n\t        if self.max_steps is None:\n\t            result = RESULTS.where(\n\t                (num_steps == max_steps), RESULTS.singular, RESULTS.successful\n\t            )\n\t        else:\n", "            result = RESULTS.where(\n\t                (num_steps == self.max_steps),\n\t                RESULTS.max_steps_reached,\n\t                RESULTS.successful,\n\t            )\n\t        # breakdown is only an issue if we did not converge\n\t        breakdown = breakdown_occurred(omega, alpha, rho) & not_converged(\n\t            residual, diff, solution\n\t        )\n\t        result = RESULTS.where(breakdown, RESULTS.breakdown, result)\n", "        stats = {\"num_steps\": num_steps, \"max_steps\": self.max_steps}\n\t        return solution, result, stats\n\t    def transpose(self, state: _BiCGStabState, options: dict[str, Any]):\n\t        del options\n\t        operator = state\n\t        transpose_options = {}\n\t        return operator.transpose(), transpose_options\n\t    def allow_dependent_columns(self, operator):\n\t        return False\n\t    def allow_dependent_rows(self, operator):\n", "        return False\n\tBiCGStab.__init__.__doc__ = r\"\"\"**Arguments:**\n\t- `rtol`: Relative tolerance for terminating solve.\n\t- `atol`: Absolute tolerance for terminating solve.\n\t- `norm`: The norm to use when computing whether the error falls within the tolerance.\n\t    Defaults to the max norm.\n\t- `max_steps`: The maximum number of iterations to run the solver for. If more steps\n\t    than this are required, then the solve is halted with a failure.\n\t\"\"\"\n"]}
{"filename": "lineax/_solver/svd.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any, Optional\n\tfrom typing_extensions import TypeAlias\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n\timport jax.scipy as jsp\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._misc import resolve_rcond\n", "from .._operator import AbstractLinearOperator\n\tfrom .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver\n\tfrom .misc import (\n\t    pack_structures,\n\t    PackedStructures,\n\t    ravel_vector,\n\t    transpose_packed_structures,\n\t    unravel_solution,\n\t)\n", "_SVDState: TypeAlias = tuple[tuple[Array, Array, Array], PackedStructures]\n\tclass SVD(AbstractLinearSolver[_SVDState]):\n\t    \"\"\"SVD solver for linear systems.\n\t    This solver can handle any operator, even nonsquare or singular ones. In these\n\t    cases it will return the pseudoinverse solution to the linear system.\n\t    Equivalent to `scipy.linalg.lstsq`.\n\t    \"\"\"\n\t    rcond: Optional[float] = None\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n\t        del options\n", "        svd = jsp.linalg.svd(operator.as_matrix(), full_matrices=False)\n\t        packed_structures = pack_structures(operator)\n\t        return svd, packed_structures\n\t    def compute(\n\t        self,\n\t        state: _SVDState,\n\t        vector: PyTree[Array],\n\t        options: dict[str, Any],\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        del options\n", "        (u, s, vt), packed_structures = state\n\t        vector = ravel_vector(vector, packed_structures)\n\t        m, _ = u.shape\n\t        _, n = vt.shape\n\t        rcond = resolve_rcond(self.rcond, n, m, s.dtype)\n\t        rcond = jnp.array(rcond, dtype=s.dtype)\n\t        if s.size > 0:\n\t            rcond = rcond * s[0]\n\t        # Not >=, or this fails with a matrix of all-zeros.\n\t        mask = s > rcond\n", "        rank = mask.sum()\n\t        safe_s = jnp.where(mask, s, 1)\n\t        s_inv = jnp.where(mask, jnp.array(1.0) / safe_s, 0)\n\t        uTb = jnp.matmul(u.conj().T, vector, precision=lax.Precision.HIGHEST)\n\t        solution = jnp.matmul(vt.conj().T, s_inv * uTb, precision=lax.Precision.HIGHEST)\n\t        solution = unravel_solution(solution, packed_structures)\n\t        return solution, RESULTS.successful, {\"rank\": rank}\n\t    def transpose(self, state: _SVDState, options: dict[str, Any]):\n\t        del options\n\t        (u, s, vt), packed_structures = state\n", "        transposed_packed_structures = transpose_packed_structures(packed_structures)\n\t        transpose_state = (vt.T, s, u.T), transposed_packed_structures\n\t        transpose_options = {}\n\t        return transpose_state, transpose_options\n\t    def allow_dependent_columns(self, operator):\n\t        return True\n\t    def allow_dependent_rows(self, operator):\n\t        return True\n\tSVD.__init__.__doc__ = \"\"\"**Arguments**:\n\t- `rcond`: the cutoff for handling zero entries on the diagonal. Defaults to machine\n", "    precision times `max(N, M)`, where `(N, M)` is the shape of the operator. (I.e.\n\t    `N` is the output size and `M` is the input size.)\n\t\"\"\"\n"]}
{"filename": "lineax/_solver/lu.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any\n\tfrom typing_extensions import TypeAlias\n\timport jax.numpy as jnp\n\timport jax.scipy as jsp\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._operator import AbstractLinearOperator, is_diagonal\n\tfrom .._solution import RESULTS\n", "from .._solve import AbstractLinearSolver\n\tfrom .misc import (\n\t    pack_structures,\n\t    PackedStructures,\n\t    ravel_vector,\n\t    transpose_packed_structures,\n\t    unravel_solution,\n\t)\n\t_LUState: TypeAlias = tuple[tuple[Array, Array], PackedStructures, bool]\n\tclass LU(AbstractLinearSolver[_LUState]):\n", "    \"\"\"LU solver for linear systems.\n\t    This solver can only handle square nonsingular operators.\n\t    \"\"\"\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n\t        del options\n\t        if operator.in_size() != operator.out_size():\n\t            raise ValueError(\n\t                \"`LU` may only be used for linear solves with square matrices\"\n\t            )\n\t        packed_structures = pack_structures(operator)\n", "        if is_diagonal(operator):\n\t            lu = operator.as_matrix(), jnp.arange(operator.in_size(), dtype=jnp.int32)\n\t        else:\n\t            lu = jsp.linalg.lu_factor(operator.as_matrix())\n\t        return lu, packed_structures, False\n\t    def compute(\n\t        self, state: _LUState, vector: PyTree[Array], options: dict[str, Any]\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        del options\n\t        lu_and_piv, packed_structures, transpose = state\n", "        trans = 1 if transpose else 0\n\t        vector = ravel_vector(vector, packed_structures)\n\t        solution = jsp.linalg.lu_solve(lu_and_piv, vector, trans=trans)\n\t        solution = unravel_solution(solution, packed_structures)\n\t        return solution, RESULTS.successful, {}\n\t    def transpose(\n\t        self,\n\t        state: _LUState,\n\t        options: dict[str, Any],\n\t    ):\n", "        lu_and_piv, packed_structures, transpose = state\n\t        transposed_packed_structures = transpose_packed_structures(packed_structures)\n\t        transpose_state = lu_and_piv, transposed_packed_structures, not transpose\n\t        transpose_options = {}\n\t        return transpose_state, transpose_options\n\t    def allow_dependent_columns(self, operator):\n\t        return False\n\t    def allow_dependent_rows(self, operator):\n\t        return False\n"]}
{"filename": "lineax/_solver/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom .bicgstab import BiCGStab as BiCGStab\n\tfrom .cg import CG as CG, NormalCG as NormalCG\n\tfrom .cholesky import Cholesky as Cholesky\n\tfrom .diagonal import Diagonal as Diagonal\n\tfrom .gmres import GMRES as GMRES\n\tfrom .lu import LU as LU\n\tfrom .qr import QR as QR\n", "from .svd import SVD as SVD\n\tfrom .triangular import Triangular as Triangular\n\tfrom .tridiagonal import Tridiagonal as Tridiagonal\n"]}
{"filename": "lineax/_solver/misc.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport math\n\tfrom typing import Any, NewType\n\timport equinox as eqx\n\timport equinox.internal as eqxi\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.tree_util as jtu\n", "import numpy as np\n\tfrom jaxtyping import Array, PyTree, Shaped\n\tfrom .._operator import (\n\t    AbstractLinearOperator,\n\t    IdentityLinearOperator,\n\t    is_positive_semidefinite,\n\t)\n\tdef preconditioner_and_y0(\n\t    operator: AbstractLinearOperator, vector: PyTree[Array], options: dict[str, Any]\n\t):\n", "    structure = operator.in_structure()\n\t    try:\n\t        preconditioner = options[\"preconditioner\"]\n\t    except KeyError:\n\t        preconditioner = IdentityLinearOperator(structure)\n\t    else:\n\t        if not isinstance(preconditioner, AbstractLinearOperator):\n\t            raise ValueError(\"The preconditioner must be a linear operator.\")\n\t        if preconditioner.in_structure() != structure:\n\t            raise ValueError(\n", "                \"The preconditioner must have `in_structure` that matches the \"\n\t                \"operator's `in_strucure`.\"\n\t            )\n\t        if preconditioner.out_structure() != structure:\n\t            raise ValueError(\n\t                \"The preconditioner must have `out_structure` that matches the \"\n\t                \"operator's `in_structure`.\"\n\t            )\n\t        if not is_positive_semidefinite(preconditioner):\n\t            raise ValueError(\"The preconditioner must be positive definite.\")\n", "    try:\n\t        y0 = options[\"y0\"]\n\t    except KeyError:\n\t        y0 = jtu.tree_map(jnp.zeros_like, vector)\n\t    else:\n\t        if jax.eval_shape(lambda: y0) != jax.eval_shape(lambda: vector):\n\t            raise ValueError(\n\t                \"`y0` must have the same structure, shape, and dtype as `vector`\"\n\t            )\n\t    return preconditioner, y0\n", "PackedStructures = NewType(\"PackedStructures\", eqxi.Static)\n\tdef pack_structures(operator: AbstractLinearOperator) -> PackedStructures:\n\t    structures = operator.out_structure(), operator.in_structure()\n\t    leaves, treedef = jtu.tree_flatten(structures)  # handle nonhashable pytrees\n\t    return PackedStructures(eqxi.Static((leaves, treedef)))\n\tdef ravel_vector(\n\t    pytree: PyTree[Array], packed_structures: PackedStructures\n\t) -> Shaped[Array, \" size\"]:\n\t    leaves, treedef = packed_structures.value\n\t    out_structure, _ = jtu.tree_unflatten(treedef, leaves)\n", "    # `is` in case `tree_equal` returns a Tracer.\n\t    if eqx.tree_equal(jax.eval_shape(lambda: pytree), out_structure) is not True:\n\t        raise ValueError(\"pytree does not match out_structure\")\n\t    # not using `ravel_pytree` as that doesn't come with guarantees about order\n\t    leaves = jtu.tree_leaves(pytree)\n\t    dtype = jnp.result_type(*leaves)\n\t    return jnp.concatenate([x.astype(dtype).reshape(-1) for x in leaves])\n\tdef unravel_solution(\n\t    solution: Shaped[Array, \" size\"], packed_structures: PackedStructures\n\t) -> PyTree[Array]:\n", "    leaves, treedef = packed_structures.value\n\t    _, in_structure = jtu.tree_unflatten(treedef, leaves)\n\t    leaves, treedef = jtu.tree_flatten(in_structure)\n\t    sizes = np.cumsum([math.prod(x.shape) for x in leaves[:-1]])\n\t    split = jnp.split(solution, sizes)\n\t    assert len(split) == len(leaves)\n\t    shaped = [x.reshape(y.shape).astype(y.dtype) for x, y in zip(split, leaves)]\n\t    return jtu.tree_unflatten(treedef, shaped)\n\tdef transpose_packed_structures(\n\t    packed_structures: PackedStructures,\n", ") -> PackedStructures:\n\t    leaves, treedef = packed_structures.value\n\t    out_structure, in_structure = jtu.tree_unflatten(treedef, leaves)\n\t    leaves, treedef = jtu.tree_flatten((in_structure, out_structure))\n\t    return eqxi.Static((leaves, treedef))\n"]}
{"filename": "lineax/_solver/cholesky.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom typing import Any\n\tfrom typing_extensions import TypeAlias\n\timport jax.flatten_util as jfu\n\timport jax.scipy as jsp\n\tfrom jaxtyping import Array, PyTree\n\tfrom .._operator import (\n\t    AbstractLinearOperator,\n", "    is_negative_semidefinite,\n\t    is_positive_semidefinite,\n\t)\n\tfrom .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver\n\t_CholeskyState: TypeAlias = tuple[Array, bool]\n\tclass Cholesky(AbstractLinearSolver[_CholeskyState]):\n\t    \"\"\"Cholesky solver for linear systems. This is generally the preferred solver for\n\t    positive or negative definite systems.\n\t    Equivalent to `scipy.linalg.solve(..., assume_a=\"pos\")`.\n", "    The operator must be square, nonsingular, and either positive or negative definite.\n\t    \"\"\"\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n\t        del options\n\t        is_nsd = is_negative_semidefinite(operator)\n\t        if not (is_positive_semidefinite(operator) | is_nsd):\n\t            raise ValueError(\n\t                \"`Cholesky(..., normal=False)` may only be used for positive \"\n\t                \"or negative definite linear operators\"\n\t            )\n", "        matrix = operator.as_matrix()\n\t        m, n = matrix.shape\n\t        if m != n:\n\t            raise ValueError(\n\t                \"`Cholesky(..., normal=False)` may only be used for linear solves \"\n\t                \"with square matrices\"\n\t            )\n\t        if is_nsd:\n\t            matrix = -matrix\n\t        factor, lower = jsp.linalg.cho_factor(matrix)\n", "        # Fix lower triangular for simplicity.\n\t        assert lower is False\n\t        return factor, is_nsd\n\t    def compute(\n\t        self, state: _CholeskyState, vector: PyTree[Array], options: dict[str, Any]\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        factor, is_nsd = state\n\t        del options\n\t        # Cholesky => PSD => symmetric => (in_structure == out_structure) =>\n\t        # we don't need to use packed structures.\n", "        vector, unflatten = jfu.ravel_pytree(vector)\n\t        solution = jsp.linalg.cho_solve((factor, False), vector)\n\t        if is_nsd:\n\t            solution = -solution\n\t        solution = unflatten(solution)\n\t        return solution, RESULTS.successful, {}\n\t    def transpose(self, state: _CholeskyState, options: dict[str, Any]):\n\t        # Matrix is symmetric anyway\n\t        return state, options\n\t    def allow_dependent_columns(self, operator):\n", "        return False\n\t    def allow_dependent_rows(self, operator):\n\t        return False\n"]}
{"filename": "lineax/_solver/cg.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom collections.abc import Callable\n\tfrom typing import Any, ClassVar, Optional\n\tfrom typing_extensions import TYPE_CHECKING, TypeAlias\n\timport equinox.internal as eqxi\n\timport jax.lax as lax\n\timport jax.numpy as jnp\n\timport jax.tree_util as jtu\n", "from equinox.internal import ω\n\tfrom jaxtyping import Array, PyTree, Scalar\n\tif TYPE_CHECKING:\n\t    from typing import ClassVar as AbstractClassVar\n\telse:\n\t    from equinox.internal import AbstractClassVar\n\tfrom .._misc import max_norm, resolve_rcond, tree_dot, tree_where\n\tfrom .._operator import (\n\t    AbstractLinearOperator,\n\t    is_negative_semidefinite,\n", "    is_positive_semidefinite,\n\t    linearise,\n\t)\n\tfrom .._solution import RESULTS\n\tfrom .._solve import AbstractLinearSolver\n\tfrom .misc import preconditioner_and_y0\n\t_CGState: TypeAlias = tuple[AbstractLinearOperator, bool]\n\t# TODO(kidger): this is pretty slow to compile.\n\t# - CG evaluates `operator.mv` three times.\n\t# - Normal CG evaluates `operator.mv` seven (!) times.\n", "# Possibly this can be cheapened a bit somehow?\n\tclass _CG(AbstractLinearSolver[_CGState]):\n\t    rtol: float\n\t    atol: float\n\t    norm: Callable[[PyTree], Scalar] = max_norm\n\t    stabilise_every: Optional[int] = 10\n\t    max_steps: Optional[int] = None\n\t    _normal: AbstractClassVar[bool]\n\t    def __post_init__(self):\n\t        if isinstance(self.rtol, (int, float)) and self.rtol < 0:\n", "            raise ValueError(\"Tolerances must be non-negative.\")\n\t        if isinstance(self.atol, (int, float)) and self.atol < 0:\n\t            raise ValueError(\"Tolerances must be non-negative.\")\n\t        if isinstance(self.atol, (int, float)) and isinstance(self.rtol, (int, float)):\n\t            if self.atol == 0 and self.rtol == 0 and self.max_steps is None:\n\t                raise ValueError(\n\t                    \"Must specify `rtol`, `atol`, or `max_steps` (or some combination \"\n\t                    \"of all three).\"\n\t                )\n\t    def init(self, operator: AbstractLinearOperator, options: dict[str, Any]):\n", "        del options\n\t        is_nsd = is_negative_semidefinite(operator)\n\t        if not self._normal:\n\t            if operator.in_structure() != operator.out_structure():\n\t                raise ValueError(\n\t                    \"`CG()` may only be used for linear solves with \" \"square matrices.\"\n\t                )\n\t            if not (is_positive_semidefinite(operator) | is_nsd):\n\t                raise ValueError(\n\t                    \"`CG()` may only be used for positive \"\n", "                    \"or negative definite linear operators\"\n\t                )\n\t            if is_nsd:\n\t                operator = -operator\n\t        return operator, is_nsd\n\t    # This differs from jax.scipy.sparse.linalg.cg in:\n\t    # 1. Every few steps we calculate the residual directly, rather than by cheaply\n\t    #    using the existing quantities. This improves numerical stability.\n\t    # 2. We use a more sophisticated termination condition. To begin with we have an\n\t    #    rtol and atol in the conventional way, inducing a vector-valued scale. This is\n", "    #    then checked in both the `y` and `b` domains (for `Ay = b`).\n\t    # 3. We return the number of steps, and whether or not the solve succeeded, as\n\t    #    additional information.\n\t    # 4. We don't try to support complex numbers. (Yet.)\n\t    def compute(\n\t        self, state: _CGState, vector: PyTree[Array], options: dict[str, Any]\n\t    ) -> tuple[PyTree[Array], RESULTS, dict[str, Any]]:\n\t        operator, is_nsd = state\n\t        if self._normal:\n\t            # Linearise if JacobianLinearOperator, to avoid computing the forward\n", "            # pass separately for mv and transpose_mv.\n\t            # This choice is \"fast by default\", even at the expense of memory.\n\t            # If a downstream user wants to avoid this then they can call\n\t            # ```\n\t            # linear_solve(\n\t            #     operator.T @ operator, operator.mv(b), solver=CG()\n\t            # )\n\t            # ```\n\t            # directly.\n\t            operator = linearise(operator)\n", "            _mv = operator.mv\n\t            _transpose_mv = operator.transpose().mv\n\t            def mv(vector: PyTree) -> PyTree:\n\t                return _transpose_mv(_mv(vector))\n\t            vector = _transpose_mv(vector)\n\t        else:\n\t            mv = operator.mv\n\t        preconditioner, y0 = preconditioner_and_y0(operator, vector, options)\n\t        leaves, _ = jtu.tree_flatten(vector)\n\t        if self.max_steps is None:\n", "            size = sum(leaf.size for leaf in leaves)\n\t            max_steps = 10 * size  # Copied from SciPy!\n\t        else:\n\t            max_steps = self.max_steps\n\t        r0 = (vector**ω - mv(y0) ** ω).ω\n\t        p0 = preconditioner.mv(r0)\n\t        gamma0 = tree_dot(r0, p0)\n\t        rcond = resolve_rcond(None, vector.size, vector.size, vector.dtype)\n\t        initial_value = (\n\t            ω(y0).call(lambda x: jnp.full_like(x, jnp.inf)).ω,\n", "            y0,\n\t            r0,\n\t            p0,\n\t            gamma0,\n\t            0,\n\t        )\n\t        has_scale = not (\n\t            isinstance(self.atol, (int, float))\n\t            and isinstance(self.rtol, (int, float))\n\t            and self.atol == 0\n", "            and self.rtol == 0\n\t        )\n\t        if has_scale:\n\t            b_scale = (self.atol + self.rtol * ω(vector).call(jnp.abs)).ω\n\t        def not_converged(r, diff, y):\n\t            # The primary tolerance check.\n\t            # Given Ay=b, then we have to be doing better than `scale` in both\n\t            # the `y` and the `b` spaces.\n\t            if has_scale:\n\t                y_scale = (self.atol + self.rtol * ω(y).call(jnp.abs)).ω\n", "                norm1 = self.norm((r**ω / b_scale**ω).ω)\n\t                norm2 = self.norm((diff**ω / y_scale**ω).ω)\n\t                return (norm1 > 1) | (norm2 > 1)\n\t            else:\n\t                return True\n\t        def cond_fun(value):\n\t            diff, y, r, _, gamma, step = value\n\t            out = gamma > 0\n\t            out = out & (step < max_steps)\n\t            out = out & not_converged(r, diff, y)\n", "            return out\n\t        def body_fun(value):\n\t            _, y, r, p, gamma, step = value\n\t            mat_p = mv(p)\n\t            inner_prod = tree_dot(p, mat_p)\n\t            alpha = gamma / inner_prod\n\t            alpha = tree_where(\n\t                jnp.abs(inner_prod) > 100 * rcond * gamma, alpha, jnp.nan\n\t            )\n\t            diff = (alpha * p**ω).ω\n", "            y = (y**ω + diff**ω).ω\n\t            step = step + 1\n\t            # E.g. see B.2 of\n\t            # https://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf\n\t            # We compute the residual the \"expensive\" way every now and again, so as to\n\t            # correct numerical rounding errors.\n\t            def stable_r():\n\t                return (vector**ω - mv(y) ** ω).ω\n\t            def cheap_r():\n\t                return (r**ω - alpha * mat_p**ω).ω\n", "            if self.stabilise_every == 1:\n\t                r = stable_r()\n\t            elif self.stabilise_every is None:\n\t                r = cheap_r()\n\t            else:\n\t                stable_step = (eqxi.unvmap_max(step) % self.stabilise_every) == 0\n\t                stable_step = eqxi.nonbatchable(stable_step)\n\t                r = lax.cond(stable_step, stable_r, cheap_r)\n\t            z = preconditioner.mv(r)\n\t            gamma_prev = gamma\n", "            gamma = tree_dot(r, z)\n\t            beta = gamma / gamma_prev\n\t            p = (z**ω + beta * p**ω).ω\n\t            return diff, y, r, p, gamma, step\n\t        _, solution, _, _, _, num_steps = lax.while_loop(\n\t            cond_fun, body_fun, initial_value\n\t        )\n\t        if (self.max_steps is None) or (max_steps < self.max_steps):\n\t            result = RESULTS.where(\n\t                num_steps == max_steps,\n", "                RESULTS.singular,\n\t                RESULTS.successful,\n\t            )\n\t        else:\n\t            result = RESULTS.where(\n\t                num_steps == max_steps,\n\t                RESULTS.max_steps_reached,\n\t                RESULTS.successful,\n\t            )\n\t        if is_nsd and not self._normal:\n", "            solution = -(solution**ω).ω\n\t        stats = {\"num_steps\": num_steps, \"max_steps\": self.max_steps}\n\t        return solution, result, stats\n\t    def transpose(self, state: _CGState, options: dict[str, Any]):\n\t        del options\n\t        psd_op, is_nsd = state\n\t        transpose_state = psd_op.transpose(), is_nsd\n\t        transpose_options = {}\n\t        return transpose_state, transpose_options\n\tclass CG(_CG):\n", "    \"\"\"Conjugate gradient solver for linear systems.\n\t    The operator should be positive or negative definite.\n\t    Equivalent to `scipy.sparse.linalg.cg`.\n\t    This supports the following `options` (as passed to\n\t    `lx.linear_solve(..., options=...)`).\n\t    - `preconditioner`: A positive definite [`lineax.AbstractLinearOperator`][]\n\t        to be used as preconditioner. Defaults to\n\t        [`lineax.IdentityLinearOperator`][].\n\t    - `y0`: The initial estimate of the solution to the linear system. Defaults to all\n\t        zeros.\n", "    !!! info\n\t    \"\"\"\n\t    _normal: ClassVar[bool] = False\n\t    def allow_dependent_columns(self, operator):\n\t        return False\n\t    def allow_dependent_rows(self, operator):\n\t        return False\n\tclass NormalCG(_CG):\n\t    \"\"\"Conjugate gradient applied to the normal equations:\n\t    `A^T A = A^T b`\n", "    of a system of linear equations. Note that this squares the condition\n\t    number, so it is not recommended. This is a fast but potentially inaccurate\n\t    method, especially in 32 bit floating point precision.\n\t    This can handle nonsquare operators provided they are full-rank.\n\t    This supports the following `options` (as passed to\n\t    `lx.linear_solve(..., options=...)`).\n\t    - `preconditioner`: A positive definite [`lineax.AbstractLinearOperator`][]\n\t        to be used as preconditioner. Defaults to\n\t        [`lineax.IdentityLinearOperator`][].\n\t    - `y0`: The initial estimate of the solution to the linear system. Defaults to all\n", "        zeros.\n\t    !!! info\n\t    \"\"\"\n\t    _normal: ClassVar[bool] = True\n\t    def allow_dependent_columns(self, operator):\n\t        rows = operator.out_size()\n\t        columns = operator.in_size()\n\t        return columns > rows\n\t    def allow_dependent_rows(self, operator):\n\t        rows = operator.out_size()\n", "        columns = operator.in_size()\n\t        return rows > columns\n\tCG.__init__.__doc__ = r\"\"\"**Arguments:**\n\t- `rtol`: Relative tolerance for terminating solve.\n\t- `atol`: Absolute tolerance for terminating solve.\n\t- `norm`: The norm to use when computing whether the error falls within the tolerance.\n\t    Defaults to the max norm.\n\t- `stabilise_every`: The conjugate gradient is an iterative method that produces\n\t    candidate solutions $x_1, x_2, \\ldots$, and terminates once $r_i = \\| Ax_i - b \\|$\n\t    is small enough. For computational efficiency, the values $r_i$ are computed using\n", "    other internal quantities, and not by directly evaluating the formula above.\n\t    However, this computation of $r_i$ is susceptible to drift due to limited\n\t    floating-point precision. Every `stabilise_every` steps, then $r_i$ is computed\n\t    directly using the formula above, in order to stabilise the computation.\n\t- `max_steps`: The maximum number of iterations to run the solver for. If more steps\n\t    than this are required, then the solve is halted with a failure.\n\t\"\"\"\n\tNormalCG.__init__.__doc__ = r\"\"\"**Arguments:**\n\t- `rtol`: Relative tolerance for terminating solve.\n\t- `atol`: Absolute tolerance for terminating solve.\n", "- `norm`: The norm to use when computing whether the error falls within the tolerance.\n\t    Defaults to the max norm.\n\t- `stabilise_every`: The conjugate gradient is an iterative method that produces\n\t    candidate solutions $x_1, x_2, \\ldots$, and terminates once $r_i = \\| Ax_i - b \\|$\n\t    is small enough. For computational efficiency, the values $r_i$ are computed using\n\t    other internal quantities, and not by directly evaluating the formula above.\n\t    However, this computation of $r_i$ is susceptible to drift due to limited\n\t    floating-point precision. Every `stabilise_every` steps, then $r_i$ is computed\n\t    directly using the formula above, in order to stabilise the computation.\n\t- `max_steps`: The maximum number of iterations to run the solver for. If more steps\n", "    than this are required, then the solve is halted with a failure.\n\t\"\"\"\n"]}
{"filename": "lineax/internal/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom .._solve import linear_solve_p as linear_solve_p\n\tfrom .._solver.misc import (\n\t    pack_structures as pack_structures,\n\t    PackedStructures as PackedStructures,\n\t    ravel_vector as ravel_vector,\n\t    transpose_packed_structures as transpose_packed_structures,\n\t    unravel_solution as unravel_solution,\n", ")\n"]}
{"filename": "benchmarks/lstsq_gradients.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# Core JAX has some numerical issues with their lstsq gradients.\n\t# See https://github.com/google/jax/issues/14868\n\t# This demonstrates that we don't have the same issue!\n\timport sys\n\timport jax\n\timport jax.numpy as jnp\n\timport lineax as lx\n", "sys.path.append(\"../tests\")\n\tfrom helpers import finite_difference_jvp  # pyright: ignore\n\ta_primal = (jnp.eye(3),)\n\ta_tangent = (jnp.zeros((3, 3)),)\n\tdef jax_solve(a):\n\t    sol, _, _, _ = jnp.linalg.lstsq(a, jnp.arange(3))\n\t    return sol\n\tdef lx_solve(a):\n\t    op = lx.MatrixLinearOperator(a)\n\t    return lx.linear_solve(op, jnp.arange(3)).value\n", "_, true_jvp = finite_difference_jvp(jax_solve, a_primal, a_tangent)\n\t_, jax_jvp = jax.jvp(jax_solve, a_primal, a_tangent)\n\t_, lx_jvp = jax.jvp(lx_solve, a_primal, a_tangent)\n\tassert jnp.isnan(jax_jvp).all()\n\tassert jnp.allclose(true_jvp, lx_jvp)\n"]}
{"filename": "benchmarks/gmres_fails_safely.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\timport sys\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n\timport jax.scipy as jsp\n\timport lineax as lx\n", "sys.path.append(\"../tests\")\n\tfrom helpers import getkey, shaped_allclose  # pyright: ignore\n\tjax.config.update(\"jax_enable_x64\", True)\n\tdef make_problem(mat_size: int, *, key):\n\t    mat = jr.normal(key, (mat_size, mat_size))\n\t    true_x = jr.normal(key, (mat_size,))\n\t    b = mat @ true_x\n\t    op = lx.MatrixLinearOperator(mat)\n\t    return mat, op, b, true_x\n\tdef benchmark_jax(mat_size: int, *, key):\n", "    mat, _, b, true_x = make_problem(mat_size, key=key)\n\t    solve_with_jax = ft.partial(\n\t        jsp.sparse.linalg.gmres, tol=1e-5, solve_method=\"batched\"\n\t    )\n\t    gmres_jit = jax.jit(solve_with_jax)\n\t    jax_soln, info = gmres_jit(mat, b)\n\t    # info == 0.0 implies that the solve has succeeded.\n\t    returned_failed = jnp.all(info != 0.0)\n\t    actually_failed = not shaped_allclose(jax_soln, true_x, atol=1e-4, rtol=1e-4)\n\t    assert actually_failed\n", "    captured_failure = returned_failed & actually_failed\n\t    return captured_failure\n\tdef benchmark_lx(mat_size: int, *, key):\n\t    _, op, b, true_x = make_problem(mat_size, key=key)\n\t    lx_soln = lx.linear_solve(op, b, lx.GMRES(atol=1e-5, rtol=1e-5), throw=False)\n\t    returned_failed = jnp.all(lx_soln.result != lx.RESULTS.successful)\n\t    actually_failed = not shaped_allclose(lx_soln.value, true_x, atol=1e-4, rtol=1e-4)\n\t    assert actually_failed\n\t    captured_failure = returned_failed & actually_failed\n\t    return captured_failure\n", "lx_failed_safely = 0\n\tjax_failed_safely = 0\n\tfor _ in range(100):\n\t    key = getkey()\n\t    jax_captured_failure = benchmark_jax(100, key=key)\n\t    lx_captured_failure = benchmark_lx(100, key=key)\n\t    jax_failed_safely = jax_failed_safely + jax_captured_failure\n\t    lx_failed_safely = lx_failed_safely + lx_captured_failure\n\tprint(f\"JAX failed safely {jax_failed_safely} out of 100 times\")\n\tprint(f\"Lineax failed safely {lx_failed_safely} out of 100 times\")\n"]}
{"filename": "benchmarks/solver_speeds.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport functools as ft\n\timport sys\n\timport timeit\n\timport equinox as eqx\n\timport jax\n\timport jax.numpy as jnp\n\timport jax.random as jr\n", "import jax.scipy as jsp\n\timport lineax as lx\n\tsys.path.append(\"../tests\")\n\tfrom helpers import (  # pyright: ignore\n\t    construct_matrix,\n\t    getkey,\n\t    has_tag,\n\t    shaped_allclose,\n\t)\n\tjax.config.update(\"jax_enable_x64\", True)\n", "if jax.config.jax_enable_x64:  # pyright: ignore\n\t    tol = 1e-12\n\telse:\n\t    tol = 1e-6\n\tdef base_wrapper(a, b, solver):\n\t    op = lx.MatrixLinearOperator(\n\t        a,\n\t        (\n\t            lx.positive_semidefinite_tag,\n\t            lx.symmetric_tag,\n", "            lx.diagonal_tag,\n\t            lx.tridiagonal_tag,\n\t        ),\n\t    )\n\t    out = lx.linear_solve(op, b, solver, throw=False)\n\t    return out.value\n\tdef jax_svd(a, b):\n\t    out, _, _, _ = jnp.linalg.lstsq(a, b)\n\t    return out\n\tdef jax_gmres(a, b):\n", "    out, _ = jsp.sparse.linalg.gmres(a, b, tol=tol)\n\t    return out\n\tdef jax_bicgstab(a, b):\n\t    out, _ = jsp.sparse.linalg.bicgstab(a, b, tol=tol)\n\t    return out\n\tdef jax_cg(a, b):\n\t    out, _ = jsp.sparse.linalg.cg(a, b, tol=tol)\n\t    return out\n\tdef jax_lu(matrix, vector):\n\t    return jsp.linalg.lu_solve(jsp.linalg.lu_factor(matrix), vector)\n", "def jax_cholesky(matrix, vector):\n\t    return jsp.linalg.cho_solve(jsp.linalg.cho_factor(matrix), vector)\n\tnamed_solvers = [\n\t    (\"LU\", \"LU\", lx.LU(), jax_lu, ()),\n\t    (\"QR\", \"SVD\", lx.QR(), jax_svd, ()),\n\t    (\"SVD\", \"SVD\", lx.SVD(), jax_svd, ()),\n\t    (\n\t        \"Cholesky\",\n\t        \"Cholesky\",\n\t        lx.Cholesky(),\n", "        jax_cholesky,\n\t        lx.positive_semidefinite_tag,\n\t    ),\n\t    (\"Diagonal\", \"None\", lx.Diagonal(), None, lx.diagonal_tag),\n\t    (\"Tridiagonal\", \"None\", lx.Tridiagonal(), None, lx.tridiagonal_tag),\n\t    (\n\t        \"CG\",\n\t        \"CG\",\n\t        lx.CG(atol=tol, rtol=tol, stabilise_every=None),\n\t        jax_cg,\n", "        lx.positive_semidefinite_tag,\n\t    ),\n\t    (\n\t        \"GMRES\",\n\t        \"GMRES\",\n\t        lx.GMRES(atol=1, rtol=1),\n\t        jax_gmres,\n\t        (),\n\t    ),\n\t    (\n", "        \"BiCGStab\",\n\t        \"BiCGStab\",\n\t        lx.BiCGStab(atol=tol, rtol=tol),\n\t        jax_bicgstab,\n\t        (),\n\t    ),\n\t]\n\tdef create_problem(solver, tags, size=3):\n\t    (matrix,) = construct_matrix(getkey, solver, tags, size=size)\n\t    true_x = jr.normal(getkey(), (size,))\n", "    b = matrix @ true_x\n\t    return matrix, true_x, b\n\tdef create_easy_iterative_problem(size, tags):\n\t    matrix = jr.normal(getkey(), (size, size)) / size + 2 * jnp.eye(size)\n\t    true_x = jr.normal(getkey(), (size,))\n\t    if has_tag(tags, lx.positive_semidefinite_tag):\n\t        matrix = matrix.T @ matrix\n\t    b = matrix @ true_x\n\t    return matrix, true_x, b\n\tdef test_solvers(vmap_size, mat_size):\n", "    for lx_name, jax_name, _lx_solver, jax_solver, tags in named_solvers:\n\t        lx_solver = ft.partial(base_wrapper, solver=_lx_solver)\n\t        if vmap_size == 1:\n\t            if isinstance(_lx_solver, (lx.CG, lx.GMRES, lx.BiCGStab)):\n\t                matrix, true_x, b = create_easy_iterative_problem(mat_size, tags)\n\t            else:\n\t                matrix, true_x, b = create_problem(lx_solver, tags, size=mat_size)\n\t        else:\n\t            if isinstance(_lx_solver, (lx.CG, lx.GMRES, lx.BiCGStab)):\n\t                matrix, true_x, b = eqx.filter_vmap(\n", "                    create_easy_iterative_problem,\n\t                    axis_size=vmap_size,\n\t                    out_axes=eqx.if_array(0),\n\t                )(mat_size, tags)\n\t            else:\n\t                matrix, true_x, b = create_problem(lx_solver, tags, size=mat_size)\n\t                _create_problem = ft.partial(create_problem, size=mat_size)\n\t                matrix, true_x, b = eqx.filter_vmap(\n\t                    _create_problem, axis_size=vmap_size, out_axes=eqx.if_array(0)\n\t                )(lx_solver, tags)\n", "            lx_solver = jax.vmap(lx_solver)\n\t            if jax_solver is not None:\n\t                jax_solver = jax.vmap(jax_solver)\n\t        lx_solver = jax.jit(lx_solver)\n\t        bench_lx = ft.partial(lx_solver, matrix, b)\n\t        if vmap_size == 1:\n\t            batch_msg = \"problem\"\n\t        else:\n\t            batch_msg = f\"batch of {vmap_size} problems\"\n\t        lx_soln = bench_lx()\n", "        if shaped_allclose(lx_soln, true_x, atol=1e-4, rtol=1e-4):\n\t            lx_solve_time = timeit.timeit(bench_lx, number=1)\n\t            print(\n\t                f\"Lineax's {lx_name} solved {batch_msg} of \"\n\t                f\"size {mat_size} in {lx_solve_time} seconds.\"\n\t            )\n\t        else:\n\t            fail_time = timeit.timeit(bench_lx, number=1)\n\t            err = jnp.abs(lx_soln - true_x).max()\n\t            print(\n", "                f\"Lineax's {lx_name} failed to solve {batch_msg} of \"\n\t                f\"size {mat_size} with error {err} in {fail_time} seconds\"\n\t            )\n\t        if jax_solver is None:\n\t            print(\"JAX has no equivalent solver. \\n\")\n\t        else:\n\t            jax_solver = jax.jit(jax_solver)\n\t            bench_jax = ft.partial(jax_solver, matrix, b)\n\t            jax_soln = bench_jax()\n\t            if shaped_allclose(jax_soln, true_x, atol=1e-4, rtol=1e-4):\n", "                jax_solve_time = timeit.timeit(bench_jax, number=1)\n\t                print(\n\t                    f\"JAX's {jax_name} solved {batch_msg} of \"\n\t                    f\"size {mat_size} in {jax_solve_time} seconds. \\n\"\n\t                )\n\t            else:\n\t                fail_time = timeit.timeit(bench_jax, number=1)\n\t                err = jnp.abs(jax_soln - true_x).max()\n\t                print(\n\t                    f\"JAX's {jax_name} failed to solve {batch_msg} of \"\n", "                    f\"size {mat_size} with error {err} in {fail_time} seconds\"\n\t                )\n\tfor vmap_size, mat_size in [(1, 50), (1000, 50)]:\n\t    test_solvers(vmap_size, mat_size)\n"]}
