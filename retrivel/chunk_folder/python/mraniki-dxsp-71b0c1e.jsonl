{"filename": "tests/test_unit.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Unit Test\n\t\"\"\"\n\tfrom unittest.mock import AsyncMock, patch\n\timport pytest\n\tfrom web3 import EthereumTesterProvider, Web3\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n", "    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\t@pytest.fixture(name=\"dex\")\n\tdef DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture\n\tdef tester_provider():\n\t    return EthereumTesterProvider()\n\t@pytest.fixture(name=\"web3\")\n\tdef w3():\n\t    provider = EthereumTesterProvider()\n", "    return Web3(provider)\n\t@pytest.fixture(name=\"account\")\n\tdef account_fixture(web3) -> str:\n\t    \"\"\"setup account.\"\"\"\n\t    return web3.eth.accounts[0]\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n", "        'instrument': 'WBTC',\n\t        'quantity': 1,\n\t    }\n\t@pytest.fixture(name=\"invalid_order\")\n\tdef invalid_order_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n\t        'instrument': 'NOTATHING',\n\t        'quantity': 1,\n", "    }\n\t@pytest.fixture(name=\"test_contract\")\n\tdef mock_contract(dex):\n\t    contract = AsyncMock()\n\t    contract.get_token_decimals.return_value = 18\n\t    contract.to_wei.return_value = 1000000000000000000\n\t    contract.functions.balanceOf = AsyncMock(return_value=100)\n\t    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n\t    return contract\n\t@pytest.fixture(name=\"mock_dex\")\n", "def mock_dex_transaction():\n\t    dex = DexSwap()\n\t    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n\t    dex.get_gas = AsyncMock(return_value=21000)\n\t    dex.get_gas_price = AsyncMock(return_value=1000000000)\n\t    dex.w3.eth.account.sign_transaction = (\n\t        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n\t    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n\t    return dex\n\tdef test_dynaconf_is_in_testing():\n", "    print(settings.VALUE)\n\t    assert settings.VALUE == \"On Testing\"\n\t@pytest.mark.asyncio\n\tasync def test_dex(dex):\n\t    \"\"\"Init Testing\"\"\"\n\t    assert isinstance(dex, DexSwap)\n\t    assert dex.w3 is not None\n\t    assert dex.w3.net.version == \"1\"\n\t    assert dex.protocol_type is not None\n\t    assert dex.protocol_type == \"uniswap\"\n", "    assert dex.account.wallet_address.startswith(\"0x\")\n\t    assert dex.account.wallet_address == \"0x1a9C8182C09F50C8318d769245beA52c32BE35BC\"\n\t    assert dex.account.private_key.startswith(\"0x\")\n\t    assert \"1 - 32BE35BC\" in dex.account.account_number\n\t@pytest.mark.asyncio\n\tasync def test_execute_order(dex, order):\n\t    # sell_balance = AsyncMock()\n\t    # dex.get_swap = AsyncMock()\n\t    result = await dex.execute_order(order)\n\t    print(f\"swap_order: {result}\")\n", "    assert result is not None\n\t@pytest.mark.asyncio\n\tasync def test_execute_order_invalid(dex, invalid_order):\n\t    result = await dex.execute_order(invalid_order)\n\t    print(result)\n\t    assert result.startswith(\"⚠️ order execution: Invalid Token\")\n\t@pytest.mark.asyncio\n\tasync def test_get_quote(dex):\n\t    \"\"\"getquote Testing\"\"\"\n\t    result = await dex.get_quote(\"UNI\")\n", "    print(result)\n\t    assert result is not None\n\t    assert result.startswith(\"🦄\")\n\t@pytest.mark.asyncio\n\tasync def test_get_quote_BTC(account) -> str:\n\t    \"\"\"test token account.\"\"\"\n\t    with patch(\"dxsp.config.settings\", autospec=True):\n\t        settings.dex_wallet_address = account\n\t        dex = DexSwap()\n\t        result = await dex.get_quote('WBTC')\n", "        print(result)\n\t        assert result is not None\n\t@pytest.mark.asyncio\n\tasync def test_get_quote_invalid(dex):\n\t    result = await dex.get_quote(\"THISISNOTATOKEN\")\n\t    print(result)\n\t    assert result is not None\n\t    assert '⚠️' in result\n"]}
{"filename": "tests/test_utils_explorer.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Unit Test\n\t\"\"\"\n\tfrom unittest.mock import AsyncMock\n\timport pytest\n\tfrom web3 import EthereumTesterProvider, Web3\n\timport dxsp\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\tfrom dxsp.utils.explorer_utils import get_account_transactions, get_explorer_abi\n", "from dxsp.utils.utils import get\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n\t    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\t@pytest.fixture(name=\"dex\")\n\tdef DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture\n\tdef tester_provider():\n\t    return EthereumTesterProvider()\n", "@pytest.fixture(name=\"web3\")\n\tdef w3():\n\t    provider = EthereumTesterProvider()\n\t    return Web3(provider)\n\t@pytest.fixture(name=\"account\")\n\tdef account_fixture(web3) -> str:\n\t    \"\"\"setup account.\"\"\"\n\t    return web3.eth.accounts[0]\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n", "    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n\t        'instrument': 'WBTC',\n\t        'quantity': 1,\n\t    }\n\t@pytest.fixture(name=\"invalid_order\")\n\tdef invalid_order_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n", "        'action': 'BUY',\n\t        'instrument': 'NOTATHING',\n\t        'quantity': 1,\n\t    }\n\t@pytest.fixture(name=\"test_contract\")\n\tdef mock_contract(dex):\n\t    contract = AsyncMock()\n\t    contract.get_token_decimals.return_value = 18\n\t    contract.to_wei.return_value = 1000000000000000000\n\t    contract.functions.balanceOf = AsyncMock(return_value=100)\n", "    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n\t    return contract\n\t@pytest.fixture(name=\"mock_dex\")\n\tdef mock_dex_transaction():\n\t    dex = DexSwap()\n\t    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n\t    dex.get_gas = AsyncMock(return_value=21000)\n\t    dex.get_gas_price = AsyncMock(return_value=1000000000)\n\t    dex.w3.eth.account.sign_transaction = (\n\t        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n", "    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n\t    return dex\n\tdef test_dynaconf_is_in_testing():\n\t    print(settings.VALUE)\n\t    assert settings.VALUE == \"On Testing\"\n\t@pytest.mark.asyncio\n\tasync def test_get():\n\t    result = await get(\n\t        \"http://ip.jsontest.com\",\n\t        params=None,\n", "        headers=None)\n\t    assert result is not None\n\t@pytest.mark.asyncio\n\tasync def test_get_abi(dex, mocker):\n\t    mock_resp = {\"status\": \"1\", \"result\": \"0x0123456789abcdef\"}\n\t    mocker.patch.object(dxsp.utils.explorer_utils, \"get\", return_value=mock_resp)\n\t    result = await get_explorer_abi(\"0x1234567890123456789012345678901234567890\")\n\t    assert result == \"0x0123456789abcdef\"\n\t@pytest.mark.asyncio\n\tasync def test_invalid_get_abi():\n", "    result = await get_explorer_abi(\"0x1234567890123456789012345678901234567890\")\n\t    assert result is None\n\t@pytest.mark.asyncio\n\tasync def test_get_account_transactions(dex):\n\t    # Call the get_account_transactions method\n\t    result = await get_account_transactions(\n\t        '0xdAC17F958D2ee523a2206206994597C13D831ec7',\n\t        dex.account.wallet_address)\n\t    print(f\"history: {result}\")\n\t    assert result is not None\n", "    assert 'pnl' in result\n\t    assert 'tokenList' in result"]}
{"filename": "tests/test_unit_uniswap.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Uniswap  Test\n\t\"\"\"\n\timport pytest\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n\t    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\t@pytest.fixture(name=\"dex\")\n", "def DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n\t        'instrument': 'WBTC',\n\t        'quantity': 1,\n\t    }\n", "def test_dynaconf_is_in_testing():\n\t    print(settings.VALUE)\n\t    assert settings.VALUE == \"On Testing\"\n\t@pytest.mark.asyncio\n\tasync def test_get_quote(dex):\n\t    result = await dex.get_quote(\"WBTC\")\n\t    print(f\"result: {result}\")\n\t    assert result is not None\n\t    assert result.startswith(\"🦄\")\n\t@pytest.mark.asyncio\n", "async def test_get_swap(dex, order):\n\t    result = await dex.execute_order(order)\n\t    print(f\"result: {result}\")\n\t    assert result is not None\n"]}
{"filename": "tests/test_chain_56.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Unit Test\n\t\"\"\"\n\timport pytest\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n\t    settings.configure(FORCE_ENV_FOR_DYNACONF=\"bsc\")\n\t@pytest.fixture(name=\"dex\")\n", "def DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n\t        'instrument': 'WBTC',\n\t        'quantity': 1,\n\t    }\n", "def test_dynaconf_is_in_testing():\n\t    print(settings.VALUE)\n\t    assert settings.VALUE == \"chain_56\"\n\t    assert settings.dex_wallet_address == \"0xf977814e90da44bfa03b6295a0616a897441acec\"\n\t    assert settings.dex_notify_invalid_token is False\n\t@pytest.mark.asyncio\n\tasync def test_get_quote(dex):\n\t    \"\"\"getquote Testing\"\"\"\n\t    print(settings.VALUE)\n\t    quote = await dex.get_quote(\"BTCB\")\n", "    print(quote)\n\t    if quote:\n\t        assert settings.VALUE == \"chain_56\"\n\t        assert dex.w3.net.version == '56'\n\t        assert quote is not None\n\t        assert quote.startswith(\"🦄\")\n\t@pytest.mark.asyncio\n\tasync def test_execute_order(dex, order):\n\t    result = await dex.execute_order(order)\n\t    print(f\"result: {result}\")\n", "    assert result is not None\n"]}
{"filename": "tests/test_utils_contract.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Unit Test\n\t\"\"\"\n\timport decimal\n\timport time\n\tfrom unittest.mock import AsyncMock, patch\n\timport pytest\n\tfrom web3 import EthereumTesterProvider, Web3\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n", "@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n\t    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\t@pytest.fixture(name=\"dex\")\n\tdef DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture\n\tdef tester_provider():\n\t    return EthereumTesterProvider()\n\t@pytest.fixture(name=\"web3\")\n", "def w3():\n\t    provider = EthereumTesterProvider()\n\t    return Web3(provider)\n\t@pytest.fixture(name=\"account\")\n\tdef account_fixture(web3) -> str:\n\t    \"\"\"setup account.\"\"\"\n\t    return web3.eth.accounts[0]\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n", "    return {\n\t        'action': 'BUY',\n\t        'instrument': 'WBTC',\n\t        'quantity': 1,\n\t    }\n\t@pytest.fixture(name=\"invalid_order\")\n\tdef invalid_order_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n", "        'instrument': 'NOTATHING',\n\t        'quantity': 1,\n\t    }\n\t@pytest.fixture(name=\"test_contract\")\n\tdef mock_contract(dex):\n\t    contract = AsyncMock()\n\t    contract.get_token_decimals.return_value = 18\n\t    contract.to_wei.return_value = 1000000000000000000\n\t    contract.functions.balanceOf = AsyncMock(return_value=100)\n\t    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n", "    return contract\n\t@pytest.fixture(name=\"mock_dex\")\n\tdef mock_dex_transaction():\n\t    dex = DexSwap()\n\t    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n\t    dex.get_gas = AsyncMock(return_value=21000)\n\t    dex.get_gas_price = AsyncMock(return_value=1000000000)\n\t    dex.w3.eth.account.sign_transaction = (\n\t        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n\t    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n", "    return dex\n\tdef test_dynaconf_is_in_testing():\n\t    print(settings.VALUE)\n\t    assert settings.VALUE == \"On Testing\"\n\t@pytest.mark.asyncio\n\tasync def test_search_contract_address(dex):\n\t    result = await dex.contract_utils.search_contract_address(\"USDT\")\n\t    assert result is not None\n\t    assert result == \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"\n\t    print(result)\n", "@pytest.mark.asyncio\n\tasync def test_invalid_search_contract_address(dex):\n\t    with pytest.raises(ValueError, match='Invalid Token'):\n\t        await dex.contract_utils.search_contract_address(\"NOTATHING\")\n\t@pytest.mark.asyncio\n\tasync def test_get_token_contract(dex):\n\t    \"\"\"get_token_contract Testing\"\"\"\n\t    result = await dex.contract_utils.get_token_contract(\n\t        \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\")\n\t    print(type(result))\n", "    assert result is not None\n\t    assert type(result) is not None\n\t    assert result.functions is not None\n\t@pytest.mark.asyncio\n\tasync def test_get_decimals(dex):\n\t    \"\"\"get_token_decimals Testing\"\"\"\n\t    result = await dex.contract_utils.get_token_decimals(\n\t        \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\")\n\t    print(result)\n\t    time.sleep(5)\n", "    assert result is not None\n\t    assert result == 18\n\t@pytest.mark.asyncio\n\tasync def test_get_decimals_stable(dex):\n\t    \"\"\"get_token_decimals Testing\"\"\"\n\t    result = await dex.contract_utils.get_token_decimals(\n\t        \"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n\t    print(result)\n\t    time.sleep(5)\n\t    assert result is not None\n", "    assert result == 6\n\t@pytest.mark.asyncio\n\tasync def test_get_token_symbol(dex):\n\t    \"\"\"get_token_symbol Testing\"\"\"\n\t    result = await dex.contract_utils.get_token_symbol(\n\t        \"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n\t    print(result)\n\t    assert result is not None\n\t    assert result == 'USDT'\n\t@pytest.mark.asyncio\n", "async def test_get_token_name(dex):\n\t    \"\"\"get_token_symbol Testing\"\"\"\n\t    result = await dex.contract_utils.get_token_name(\n\t        \"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n\t    print(result)\n\t    assert result is not None\n\t    assert result == 'Tether USD'\n\t@pytest.mark.asyncio\n\tasync def test_get_token_balance(dex):\n\t    # Call the get_token_balance method\n", "    result = await dex.contract_utils.get_token_balance(\n\t        \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\",\n\t        dex.account.wallet_address)\n\t    print(\"balance \", result)\n\t    print(\"balance \", type(result))\n\t    assert result is not None\n\t    assert result >= 0\n\t    assert isinstance(result, decimal.Decimal)\n\t@pytest.mark.asyncio\n\tasync def test_token_balance(account) -> str:\n", "    \"\"\"test token account.\"\"\"\n\t    with patch(\"dxsp.config.settings\", autospec=True):\n\t        settings.dex_wallet_address = account\n\t        # with pytest.raises(ValueError, match='No Balance'):\n\t        dex = DexSwap()\n\t        result = await dex.contract_utils.get_token_balance(\n\t            settings.trading_asset_address,\n\t            account)\n\t        print(result)\n\t        assert result is not None\n", "@pytest.mark.asyncio\n\tasync def calculate_sell_amount(dex):\n\t    pass\n\t@pytest.mark.asyncio\n\tasync def test_get_confirmation(dex):\n\t    result = await dex.contract_utils.get_confirmation(\n\t        \"0xda56e5f1a26241a03d3f96740989e432ca41ae35b5a1b44bcb37aa2cf7772771\")\n\t    print(result)\n\t    assert result is not None\n\t    assert result['timestamp'] is not None\n", "    assert result['fee'] is not None\n\t    assert result['confirmation'] is not None\n\t    assert result['confirmation'].startswith('➕')\n\t    assert '⛽' in result['confirmation']\n\t    assert '🗓️' in result['confirmation']\n\t    assert 'ℹ️' in result['confirmation']\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_chain_5.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Unit Test\n\t\"\"\"\n\timport pytest\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n\t    settings.configure(FORCE_ENV_FOR_DYNACONF=\"testnet\")\n\t@pytest.fixture(name=\"dex\")\n", "def DexSwap_fixture():\n\t    return DexSwap()\n\tdef test_dynaconf_is_in_testing():\n\t    print(settings.VALUE)\n\t    assert settings.VALUE == \"On Testnet\"\n\t    assert settings.dex_wallet_address == \"0x1a9C8182C09F50C8318d769245beA52c32BE35BC\"\n\t# @pytest.mark.asyncio\n\t# async def test_get_quote(dex):\n\t#     \"\"\"getquote Testing\"\"\"\n\t#     print(settings.VALUE)\n", "#     quote = await dex.get_quote(\"wBTC\")\n\t#     print(quote)\n\t#     if quote:\n\t#         assert settings.VALUE\n\t#         assert dex.w3.net.version == '5'\n\t#         assert quote is not None\n\t#         assert quote.startswith(\"🦄\")\n\t# @pytest.mark.asyncio\n\t# async def test_get_swap(dex, account, order): \n\t#     \"\"\"test token account.\"\"\"\n", "#     with patch(\"dxsp.config.settings\", autospec=True):\n\t#         settings.dex_wallet_address = account\n\t#         dex = DexSwap()\n\t#         swap_order = await dex.execute_order(order)\n\t#         print(swap_order)\n\t# @pytest.mark.asyncio\n\t# async def test_get_swap_invalid(dex, order):\n\t#     with pytest.raises(ValueError):\n\t#         await dex.execute_order(order)"]}
{"filename": "tests/test_utils_account.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Unit Test\n\t\"\"\"\n\tfrom unittest.mock import AsyncMock, patch\n\timport pytest\n\tfrom web3 import EthereumTesterProvider, Web3\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n", "    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\t@pytest.fixture(name=\"dex\")\n\tdef DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture\n\tdef tester_provider():\n\t    return EthereumTesterProvider()\n\t@pytest.fixture(name=\"web3\")\n\tdef w3():\n\t    provider = EthereumTesterProvider()\n", "    return Web3(provider)\n\t@pytest.fixture(name=\"account\")\n\tdef account_fixture(web3) -> str:\n\t    \"\"\"setup account.\"\"\"\n\t    return web3.eth.accounts[0]\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n", "        'instrument': 'WBTC',\n\t        'quantity': 1,\n\t    }\n\t@pytest.fixture(name=\"invalid_order\")\n\tdef invalid_order_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n\t        'instrument': 'NOTATHING',\n\t        'quantity': 1,\n", "    }\n\t@pytest.fixture(name=\"test_contract\")\n\tdef mock_contract(dex):\n\t    contract = AsyncMock()\n\t    contract.get_token_decimals.return_value = 18\n\t    contract.to_wei.return_value = 1000000000000000000\n\t    contract.functions.balanceOf = AsyncMock(return_value=100)\n\t    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n\t    return contract\n\t@pytest.fixture(name=\"mock_dex\")\n", "def mock_dex_transaction():\n\t    dex = DexSwap()\n\t    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n\t    dex.get_gas = AsyncMock(return_value=21000)\n\t    dex.get_gas_price = AsyncMock(return_value=1000000000)\n\t    dex.w3.eth.account.sign_transaction = (\n\t        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n\t    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n\t    return dex\n\tdef test_dynaconf_is_in_testing():\n", "    print(settings.VALUE)\n\t    assert settings.VALUE == \"On Testing\"\n\t@pytest.mark.asyncio\n\tasync def test_get_info(dex):\n\t    result = await dex.get_info()\n\t    print(result)\n\t    assert result is not None\n\t@pytest.mark.asyncio\n\tasync def test_get_name(dex):\n\t    result = await dex.get_name()\n", "    assert isinstance(result, str)\n\t    assert len(result) == 8\n\t@pytest.mark.asyncio\n\tasync def test_get_account_balance(dex):\n\t    # Call the get_account_balance method\n\t    result = await dex.get_account_balance()\n\t    assert result is not None\n\t    assert '₿' in result\n\t@pytest.mark.asyncio\n\tasync def test_account_balance(account) -> str:\n", "    \"\"\"test balance account.\"\"\"\n\t    with patch(\"dxsp.config.settings\", autospec=True):\n\t        settings.dex_wallet_address = account\n\t        print(settings.dex_wallet_address)\n\t        dex = DexSwap()\n\t        print(dex.account.wallet_address)\n\t        result = await dex.get_account_balance()\n\t        print(result)\n\t        assert result is not None\n\t        assert '₿' in result\n", "        assert '💵' in result\n\t@pytest.mark.asyncio\n\tasync def test_trading_asset_balance(account) -> str:\n\t    \"\"\"test token account.\"\"\"\n\t    with patch(\"dxsp.config.settings\", autospec=True):\n\t        settings.dex_wallet_address = account\n\t        dex = DexSwap()\n\t        result = await dex.get_trading_asset_balance()\n\t        print(result)\n\t        assert result is not None\n", "@pytest.mark.asyncio\n\tasync def test_get_account_position(account) -> str:\n\t    \"\"\"test token account.\"\"\"\n\t    with patch(\"dxsp.config.settings\", autospec=True):\n\t        settings.dex_wallet_address = account\n\t        # with pytest.raises(ValueError, match='No Balance'):\n\t        dex = DexSwap()\n\t        result = await dex.get_account_position()\n\t        print(result)\n\t        assert result is not None\n", "        assert '📊' in result\n\t@pytest.mark.asyncio\n\tasync def test_get_account_transactions(dex):\n\t    # Call the get_account_transactions method\n\t    result = await dex.get_account_transactions()\n\t    print(f\"history: {result}\")\n\t    assert result is not None\n\t    assert 'pnl' in result\n\t    assert 'tokenList' in result\n\t@pytest.mark.asyncio\n", "async def test_get_account_pnl(dex):\n\t    # Call the get_account_pnl method\n\t    result = await dex.get_account_pnl()\n\t    print(f\"pnl: {result}\")\n\t    assert result is not None\n\t    assert 'Total' in result\n\t    assert '📊' in result\n\t    assert 'Opened' in result\n\t    assert 'Margin' in result\n\t@pytest.mark.asyncio\n", "async def test_get_approve(dex):\n\t    symbol = \"UNI\"\n\t    approve_receipt = None\n\t    try:\n\t        approve_receipt = await dex.get_approve(symbol)\n\t        print(approve_receipt)\n\t    except Exception as e:\n\t        print(f\"Error getting approve receipt: {e}\")\n\t    assert approve_receipt is None\n\t@pytest.mark.asyncio\n", "async def test_failed_get_approve(dex):\n\t    with pytest.raises(ValueError, match='Approval failed'):\n\t        await dex.account.get_approve(\"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n\t@pytest.mark.asyncio\n\tasync def test_get_sign(mock_dex):\n\t    pass\n\t#    transaction = MagicMock()\n\t#    result = await mock_dex.get_sign(transaction)\n\t#    mock_dex.get_gas.assert_called_once_with(transaction)\n\t#    mock_dex.get_gas_price.assert_called_once()\n", "#    mock_dex.w3.eth.get_transaction_count.assert_called_once_with(\n\t# mock_dex.wallet_address)\n\t@pytest.mark.asyncio\n\tasync def test_get_gas(dex):\n\t    \"\"\"get_gas Testing\"\"\"\n\t    mock_tx = {\"to\": \"0x1234567890123456789012345678901234567890\",\n\t                \"value\": \"1000000000000000000\"}\n\t    result = await dex.account.get_gas(mock_tx)\n\t    print(result)\n\t@pytest.mark.asyncio\n", "async def test_get_gas_price(dex):\n\t    # Call the get_gasPrice method\n\t    result = await dex.account.get_gas_price()\n\t    print(f\"gas_price: {result}\")\n\t    assert result is not None"]}
{"filename": "tests/test_unit_zerox.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Unit Test\n\t\"\"\"\n\tfrom unittest.mock import AsyncMock, patch\n\timport pytest\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n\t    settings.configure(FORCE_ENV_FOR_DYNACONF=\"zerox\")\n", "@pytest.fixture(name=\"dex\")\n\tdef DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        \"action\": \"BUY\",\n\t        \"instrument\": \"WBTC\",\n\t        \"quantity\": 1,\n", "    }\n\tdef test_dynaconf_is_in_testing():\n\t    print(settings.VALUE)\n\t    assert settings.VALUE == \"test_zerox\"\n\t@pytest.mark.asyncio\n\tasync def test_dex(dex):\n\t    \"\"\"Init Testing\"\"\"\n\t    assert isinstance(dex, DexSwap)\n\t    assert dex.w3 is not None\n\t    assert dex.protocol_type is not None\n", "    assert dex.protocol_type == \"0x\"\n\t@pytest.mark.asyncio\n\tasync def test_get_quote(dex):\n\t    result = await dex.get_quote(\"UNI\")\n\t    print(\"0x quote: \", result)\n\t    assert dex.w3.net.version == \"1\"\n\t    assert result is not None\n\t    assert result.startswith(\"🦄\")\n\t@pytest.mark.asyncio\n\tasync def test_execute_order(dex, order):\n", "    result = await dex.execute_order(order)\n\t    print(result)\n\t    assert result is not None\n\t    assert result.startswith(\"⚠️\")\n"]}
{"filename": "tests/test_unit_uniswap_v3.py", "chunked_list": ["\"\"\"\n\t DEXSWAP Uniswap  Test\n\t\"\"\"\n\timport pytest\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n\t@pytest.fixture(scope=\"session\", autouse=True)\n\tdef set_test_settings():\n\t    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswapv3\")\n\t@pytest.fixture(name=\"dex\")\n", "def DexSwap_fixture():\n\t    return DexSwap()\n\t@pytest.fixture(name=\"order\")\n\tdef order_params_fixture():\n\t    \"\"\"Return order parameters.\"\"\"\n\t    return {\n\t        'action': 'BUY',\n\t        'instrument': 'WBTC',\n\t        'quantity': 1,\n\t    }\n", "def test_dynaconf_is_in_testing():\n\t    print(settings.VALUE)\n\t    assert settings.VALUE == \"On uniswap3\"\n\t@pytest.mark.asyncio\n\tasync def test_get_quote(dex):\n\t    result = await dex.get_quote(\"WBTC\")\n\t    print(f\"result: {result}\")\n\t    assert result is not None\n\t    assert result.startswith(\"🦄\")\n\t@pytest.mark.asyncio\n", "async def test_execute_order(dex, order):\n\t    result = await dex.execute_order(order)\n\t    print(f\"result: {result}\")\n\t    assert result is not None\n"]}
{"filename": "dxsp/main.py", "chunked_list": ["\"\"\"\n\t DEX SWAP Main\n\t\"\"\"\n\timport decimal\n\tfrom typing import Optional\n\tfrom loguru import logger\n\tfrom web3 import Web3\n\tfrom web3.gas_strategies.time_based import medium_gas_price_strategy\n\tfrom dxsp.config import settings\n\tfrom dxsp.utils import AccountUtils, ContractUtils\n", "class DexSwap:\n\t    \"\"\"\n\t    DEXswap  class to build a DexSwap Object\n\t    use to interact with the dex protocol\n\t    Args:\n\t        w3 (Optional[Web3]): Web3\n\t    Returns:\n\t        DexSwap\n\t    \"\"\"\n\t    def __init__(self, w3: Optional[Web3] = None):\n", "        \"\"\"\n\t        Initialize the DexSwap object to interact with\n\t        w3 contracts.\n\t        \"\"\"\n\t        self.logger = logger\n\t        self.w3 = w3 or Web3(Web3.HTTPProvider(settings.dex_rpc))\n\t        if not self.w3.net.listening:\n\t            raise ValueError(\"w3 not connected\")\n\t        self.w3.eth.set_gas_price_strategy(medium_gas_price_strategy)\n\t        self.account = AccountUtils(w3=self.w3)\n", "        self.protocol_type = settings.dex_protocol_type\n\t        self.protocol_version = settings.dex_protocol_version\n\t        self.dex_swap = None\n\t        self.router = None\n\t        self.quoter = None\n\t        self.contract_utils = ContractUtils(w3=self.w3)\n\t    async def get_protocol(self):\n\t        \"\"\"\n\t        Set the dex_swap object based\n\t        on the protocol type.\n", "        Currently supports:\n\t            1inch: currently blocked\n\t            0x\n\t            Uniswap V2 and V3\n\t        Returns:\n\t            dex_swap\n\t        \"\"\"\n\t        from dxsp.protocols import DexSwapOneInch, DexSwapUniswap, DexSwapZeroX\n\t        if self.protocol_type == \"0x\":\n\t            self.dex_swap = DexSwapZeroX()\n", "        elif self.protocol_type == \"1inch\":\n\t            self.dex_swap = DexSwapOneInch()\n\t        else:\n\t            self.dex_swap = DexSwapUniswap()\n\t    async def execute_order(self, order_params):\n\t        \"\"\"\n\t        Execute an order function.\n\t        Args:\n\t            order_params (dict): The order parameters.\n\t        Returns:\n", "            str: The trade confirmation\n\t        \"\"\"\n\t        try:\n\t            self.logger.debug(\"execute order\")\n\t            action = order_params.get(\"action\")\n\t            instrument = order_params.get(\"instrument\")\n\t            quantity = order_params.get(\"quantity\", 1)\n\t            sell_token, buy_token = (\n\t                (self.account.trading_asset_address, instrument)\n\t                if action == \"BUY\"\n", "                else (instrument, self.account.trading_asset_address)\n\t            )\n\t            order = await self.get_swap(sell_token, buy_token, quantity)\n\t            if order:\n\t                trade_confirmation = (\n\t                    f\"⬇️ {instrument}\" if (action == \"SELL\") else f\"⬆️ {instrument}\\n\"\n\t                )\n\t                trade_confirmation += order\n\t                return trade_confirmation\n\t        except Exception as error:\n", "            return f\"⚠️ order execution: {error}\"\n\t    async def get_swap(self, sell_token: str, buy_token: str, quantity: int) -> None:\n\t        \"\"\"\n\t        Execute a swap\n\t        Args:\n\t            sell_token (str): The sell token.\n\t            buy_token (str): The buy token.\n\t            quantity (int): The quantity of tokens.\n\t        Returns:\n\t            transactionHash\n", "        \"\"\"\n\t        try:\n\t            self.logger.debug(\"get swap\")\n\t            await self.get_protocol()\n\t            sell_token_address = sell_token\n\t            self.logger.debug(\"sell token {}\", sell_token_address)\n\t            if not sell_token.startswith(\"0x\"):\n\t                sell_token_address = await self.contract_utils.search_contract_address(\n\t                    sell_token\n\t                )\n", "            buy_token_address = buy_token\n\t            self.logger.debug(\"buy token {}\", buy_token_address)\n\t            if not buy_token_address.startswith(\"0x\"):\n\t                buy_token_address = await self.contract_utils.search_contract_address(\n\t                    buy_token\n\t                )\n\t            sell_amount = await self.contract_utils.calculate_sell_amount(\n\t                sell_token_address, self.account.wallet_address, quantity\n\t            )\n\t            sell_token_amount_wei = sell_amount * (\n", "                10 ** (await self.contract_utils.get_token_decimals(sell_token_address))\n\t            )\n\t            if self.protocol_type == \"0x\":\n\t                await self.account.get_approve(sell_token_address)\n\t            order_amount = int(\n\t                sell_token_amount_wei\n\t                * decimal.Decimal((settings.dex_trading_slippage / 100))\n\t            )\n\t            self.logger.debug(order_amount)\n\t            order = await self.dex_swap.get_swap(\n", "                sell_token_address, buy_token_address, order_amount\n\t            )\n\t            if not order:\n\t                self.logger.debug(\"swap order error\")\n\t                raise ValueError(\"swap order not executed\")\n\t            signed_order = await self.account.get_sign(order)\n\t            order_hash = str(self.w3.to_hex(signed_order))\n\t            receipt = self.w3.wait_for_transaction_receipt(order_hash)\n\t            if receipt[\"status\"] != 1:\n\t                self.logger.debug(receipt)\n", "                raise ValueError(\"receipt failed\")\n\t            return await self.contract_utils.get_confirmation(\n\t                receipt[\"transactionHash\"]\n\t            )\n\t        except Exception as error:\n\t            self.logger.debug(error)\n\t            raise error\n\t    async def get_quote(self, sell_token):\n\t        \"\"\"\n\t        gets a quote for a token\n", "        Args:\n\t            sell_token (str): The sell token.\n\t        Returns:\n\t            str: The quote with the trading symbol\n\t        \"\"\"\n\t        try:\n\t            await self.get_protocol()\n\t            buy_address = self.account.trading_asset_address\n\t            sell_address = await self.contract_utils.search_contract_address(sell_token)\n\t            quote = await self.dex_swap.get_quote(buy_address, sell_address)\n", "            quote = f\"🦄 {quote}\"\n\t            symbol = await self.contract_utils.get_token_symbol(\n\t                self.account.trading_asset_address\n\t            )\n\t            return f\"{quote} {symbol}\"\n\t        except Exception as error:\n\t            return f\"⚠️: {error}\"\n\t    # 🔒 USER RELATED\n\t    async def get_info(self):\n\t        \"\"\"\n", "        Get information from the account.\n\t        :return: The information retrieved from the account.\n\t        \"\"\"\n\t        return await self.account.get_info()\n\t    async def get_help(self):\n\t        \"\"\"\n\t        Retrieves help information\n\t        using the `account.get_help()` method.\n\t        :return: The help information.\n\t        :rtype: Any\n", "        \"\"\"\n\t        return await self.account.get_help()\n\t    async def get_name(self):\n\t        \"\"\"\n\t        Retrieves the name of the account.\n\t        :return: The name of the account.\n\t        \"\"\"\n\t        return await self.account.get_name()\n\t    async def get_account_balance(self):\n\t        \"\"\"\n", "        Retrieves the account balance.\n\t        :return: The account balance.\n\t        :rtype: float\n\t        \"\"\"\n\t        return await self.account.get_account_balance()\n\t    async def get_trading_asset_balance(self):\n\t        \"\"\"\n\t        Retrieves the trading asset balance for the current account.\n\t        :return: A dictionary containing the trading asset balance.\n\t                 The dictionary has the following keys:\n", "                 - 'asset': The asset symbol.\n\t                 - 'free': The free balance of the asset.\n\t                 - 'locked': The locked balance of the asset.\n\t        \"\"\"\n\t        return await self.account.get_trading_asset_balance()\n\t    async def get_account_position(self):\n\t        \"\"\"\n\t        Retrieves the account position.\n\t        :return: The account position.\n\t        :rtype: AccountPosition\n", "        \"\"\"\n\t        return await self.account.get_account_position()\n\t    async def get_account_margin(self):\n\t        \"\"\"\n\t        Retrieves the account margin.\n\t        :return: The account margin.\n\t        :rtype: float\n\t        \"\"\"\n\t        return await self.account.get_account_margin()\n\t    async def get_account_open_positions(self):\n", "        \"\"\"\n\t        Retrieves the open positions of the account.\n\t        :return: A list of open positions in the account.\n\t        \"\"\"\n\t        return await self.account.get_account_open_positions()\n\t    async def get_account_transactions(self, period=24):\n\t        \"\"\"\n\t        Get the account transactions\n\t        for a specific period.\n\t        Args:\n", "            period (int): The number of hours\n\t            for which to retrieve the transactions. Defaults to 24.\n\t        Returns:\n\t            List[Transaction]: A list of\n\t            transaction objects representing the account transactions.\n\t        \"\"\"\n\t        return await self.account.get_account_transactions(period)\n\t    async def get_account_pnl(self, period=24):\n\t        \"\"\"\n\t        Get the profit and loss (PnL)\n", "        for the account within a specified period.\n\t        Args:\n\t            period (int, optional):\n\t            The period in hours for which to calculate the PnL.\n\t            Defaults to 24.\n\t        Returns:\n\t            float: The profit and loss (PnL)\n\t            for the account within the specified period.\n\t        \"\"\"\n\t        return await self.account.get_account_pnl(period)\n"]}
{"filename": "dxsp/config.py", "chunked_list": ["\"\"\"\n\t DEX SWAP CONFIG\n\t\"\"\"\n\timport os\n\tfrom dynaconf import Dynaconf\n\tROOT = os.path.dirname(__file__)\n\tsettings = Dynaconf(\n\t    envvar_prefix=\"TT\",\n\t    root_path=os.path.dirname(ROOT),\n\t    settings_files=[\n", "        os.path.join(ROOT, \"default_settings.toml\"),\n\t        \"talky_settings.toml\",\n\t        \"settings.toml\",\n\t        \".secrets.toml\",\n\t    ],\n\t    load_dotenv=True,\n\t    environments=True,\n\t    default_env=\"default\",\n\t)\n"]}
{"filename": "dxsp/__init__.py", "chunked_list": ["__version__ = \"4.2.25\"\n\tfrom dxsp.config import settings\n\tfrom dxsp.main import DexSwap\n\tfrom dxsp.protocols import DexSwapOneInch, DexSwapUniswap, DexSwapZeroX\n"]}
{"filename": "dxsp/utils/account_utils.py", "chunked_list": ["\"\"\"\n\t DEX SWAP\n\t🔒 USER RELATED\n\t\"\"\"\n\tfrom typing import Optional\n\tfrom loguru import logger\n\tfrom web3 import Web3\n\tfrom dxsp import __version__\n\tfrom dxsp.config import settings\n\tfrom dxsp.utils.contract_utils import ContractUtils\n", "from dxsp.utils.explorer_utils import get_account_transactions\n\tclass AccountUtils:\n\t    \"\"\"\n\t    Class AccountUtils to interact with private related methods\n\t    such as account balance, signing transactions, etc.\n\t    Args:\n\t        w3 (Optional[Web3]): Web3\n\t    Methods:\n\t        get_info()\n\t        get_name()\n", "        get_help()\n\t        get_account_balance()\n\t        get_trading_asset_balance()\n\t        get_account_position\n\t        get_account_margin\n\t        get_account_open_positions\n\t        get_account_transactions()\n\t        get_account_pnl\n\t        get_approve\n\t        get_sign\n", "        get_gas\n\t        get_gas_price\n\t    \"\"\"\n\t    def __init__(self, w3: Optional[Web3] = None):\n\t        self.logger = logger\n\t        self.w3 = w3 or Web3(Web3.HTTPProvider(settings.dex_rpc))\n\t        self.wallet_address = self.w3.to_checksum_address(settings.dex_wallet_address)\n\t        self.account_number = (\n\t            f\"{str(self.w3.net.version)} - \" f\"{str(self.wallet_address)[-8:]}\"\n\t        )\n", "        self.private_key = settings.dex_private_key\n\t        self.trading_asset_address = self.w3.to_checksum_address(\n\t            settings.trading_asset_address\n\t        )\n\t        self.contract_utils = ContractUtils(w3=self.w3)\n\t        self.commands = settings.dxsp_commands\n\t    async def get_info(self):\n\t        \"\"\"\n\t        Get the information about the DexSwap API.\n\t        Returns:\n", "            str: A string containing the version of DexSwap, the name obtained from\n\t                 `get_name()`, and the account number.\n\t        Raises:\n\t            Exception: If there is an error while retrieving the information.\n\t        \"\"\"\n\t        try:\n\t            return (\n\t                f\"ℹ️ DexSwap v{__version__}\\n\"\n\t                f\"💱 {await self.get_name()}\\n\"\n\t                f\"🪪 {self.account_number}\"\n", "            )\n\t        except Exception as error:\n\t            return error\n\t    async def get_name(self):\n\t        \"\"\"\n\t        Retrieves the name of the object being the\n\t        last 8 characters of the router contract address.\n\t        :return: A string representing\n\t        the name of the object.\n\t        \"\"\"\n", "        if settings.dex_router_contract_addr:\n\t            return str(settings.dex_router_contract_addr)[-8:]\n\t    async def get_help(self):\n\t        \"\"\"\n\t        Asynchronously retrieves the help information.\n\t        Returns:\n\t            str: The help information,\n\t            including the available commands.\n\t        \"\"\"\n\t        return f\"{self.commands}\\n\"\n", "    async def get_account_balance(self):\n\t        \"\"\"\n\t        Retrieves the account balance of the user.\n\t        Returns:\n\t            str: A formatted string containing\n\t            the account balance in Bitcoin (₿) and\n\t            the trading asset balance like USDT (💵).\n\t        \"\"\"\n\t        account_balance = self.w3.eth.get_balance(\n\t            self.w3.to_checksum_address(self.wallet_address)\n", "        )\n\t        account_balance = self.w3.from_wei(account_balance, \"ether\") or 0\n\t        trading_asset_balance = await self.get_trading_asset_balance()\n\t        return f\"₿ {round(account_balance,5)}\\n💵 {trading_asset_balance}\"\n\t    async def get_trading_asset_balance(self):\n\t        \"\"\"\n\t        Retrieves the balance of the trading asset\n\t        for the current wallet address.\n\t        Returns:\n\t            The balance of the trading asset as a float.\n", "            If the balance is not available,\n\t            it returns 0.\n\t        \"\"\"\n\t        trading_asset_balance = await self.contract_utils.get_token_balance(\n\t            self.trading_asset_address, self.wallet_address\n\t        )\n\t        return trading_asset_balance if trading_asset_balance else 0\n\t    async def get_account_position(self):\n\t        \"\"\"\n\t        Retrieves the account position.\n", "        Returns:\n\t            str: A string representing the account position.\n\t        \"\"\"\n\t        position = \"📊 Position\\n\"\n\t        position += f\"Opened: {str(await self.get_account_open_positions())}\\n\"\n\t        position += f\"Margin: {str(await self.get_account_margin())}\"\n\t        return position\n\t    async def get_account_margin(self):\n\t        \"\"\"\n\t        Get the account margin. Not yet implemented\n", "        Returns:\n\t            int: The account margin.\n\t        \"\"\"\n\t        return 0\n\t    async def get_account_open_positions(self):\n\t        \"\"\"\n\t        Get the open positions for the account.\n\t        Not yet implemented\n\t        :return: The number of open positions\n\t        for the account.\n", "        \"\"\"\n\t        return 0\n\t    async def get_account_transactions(self, period=24):\n\t        \"\"\"\n\t        Retrieve the account transactions for a given period.\n\t        Not yet implemented\n\t        Args:\n\t            period (int): The time period in hours\n\t            to retrieve the transactions for.\n\t            Default is 24 hours.\n", "        Returns:\n\t            List[Transaction]: A list of transactions for the account.\n\t        \"\"\"\n\t        return await get_account_transactions(\n\t            period, self.trading_asset_address, self.wallet_address\n\t        )\n\t    async def get_account_pnl(self, period=24):\n\t        \"\"\"\n\t        Create a profit and loss (PnL)\n\t        report for the account.\n", "        Not yet implemented\n\t        Args:\n\t            period (int): The time period in hours\n\t            to retrieve the PnL for. Default is 24 hours.\n\t        Returns:\n\t            str: A string containing the PnL report.\n\t        \"\"\"\n\t        pnl_dict = await self.get_account_transactions(period)\n\t        pnl_report = \"\".join(\n\t            f\"{token} {value}\\n\" for token, value in pnl_dict[\"tokenList\"].items()\n", "        )\n\t        pnl_report += f\"Total {pnl_dict['pnl']}\\n\"\n\t        pnl_report += await self.get_account_position()\n\t        return pnl_report\n\t    async def get_approve(self, token_address):\n\t        \"\"\"\n\t        Given a token address, approve a token\n\t        Args:\n\t            token_address (str): The token address\n\t        Returns:\n", "            approval_tx_hash\n\t        \"\"\"\n\t        try:\n\t            contract = await self.contract_utils.get_token_contract(token_address)\n\t            if contract is None:\n\t                return\n\t            approved_amount = self.w3.to_wei(2**64 - 1, \"ether\")\n\t            owner_address = self.w3.to_checksum_address(self.wallet_address)\n\t            dex_router_address = self.w3.to_checksum_address(\n\t                settings.dex_router_contract_addr\n", "            )\n\t            allowance = contract.functions.allowance(\n\t                owner_address, dex_router_address\n\t            ).call()\n\t            if allowance == 0:\n\t                approval_tx = contract.functions.approve(\n\t                    dex_router_address, approved_amount\n\t                )\n\t                approval_tx_hash = await self.get_sign(approval_tx.transact())\n\t                return self.w3.eth.wait_for_transaction_receipt(approval_tx_hash)\n", "        except Exception as error:\n\t            raise ValueError(f\"Approval failed {error}\")\n\t    async def get_sign(self, transaction):\n\t        \"\"\"\n\t        Given a transaction, sign a transaction\n\t        Args:\n\t            transaction (Transaction): The transaction\n\t        Returns:\n\t            signed_tx_hash\n\t        \"\"\"\n", "        try:\n\t            signed_tx = self.w3.eth.account.sign_transaction(\n\t                transaction, self.private_key\n\t            )\n\t            return self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)\n\t        except Exception as error:\n\t            raise error\n\t    async def get_gas(self, transaction):\n\t        \"\"\"\n\t        Given a transaction, get gas estimate\n", "        Args:\n\t            transaction (Transaction): The transaction\n\t        Returns:\n\t            int: The gas estimate\n\t        \"\"\"\n\t        gas_limit = self.w3.eth.estimate_gas(transaction) * 1.25\n\t        return int(self.w3.to_wei(gas_limit, \"wei\"))\n\t    async def get_gas_price(self):\n\t        \"\"\"\n\t        search get gas price\n", "        Returns:\n\t            int: The gas price\n\t        \"\"\"\n\t        return round(self.w3.from_wei(self.w3.eth.generate_gas_price(), \"gwei\"), 2)\n"]}
{"filename": "dxsp/utils/contract_utils.py", "chunked_list": ["\"\"\"\n\t DEX SWAP\n\t✍️ CONTRACT\n\t\"\"\"\n\timport decimal\n\tfrom datetime import datetime\n\tfrom typing import Optional\n\timport requests\n\tfrom loguru import logger\n\tfrom pycoingecko import CoinGeckoAPI\n", "from web3 import Web3\n\tfrom dxsp.config import settings\n\tfrom dxsp.utils.explorer_utils import get_explorer_abi\n\tfrom dxsp.utils.utils import get\n\tclass ContractUtils:\n\t    \"\"\"\n\t    ContractUtils class to interact with w3 contracts\n\t    and with coingecko API.\n\t    Coingecko data is retrieve via pycoingecko\n\t    More info: https://github.com/man-c/pycoingecko\n", "    Args:\n\t        w3 (Optional[Web3]): Web3\n\t    Methods:\n\t        search_contract_address(self, token)\n\t        search_cg_platform(self)\n\t        search_cg(self, token)\n\t        search_cg_contract(token)\n\t        get_token_address(self, contract_list, token)\n\t        get_token_contract(self, token)\n\t        get_token_decimals(self, token_address)\n", "        get_token_symbol(self, token_address)\n\t        get_token_name(self, token_address)\n\t        get_token_balance(self, token_address)\n\t        calculate_sell_amount(self,\n\t            sell_token_address, wallet_address, quantity)\n\t        get_confirmation(self, tx_hash)\n\t    \"\"\"\n\t    def __init__(self, w3: Optional[Web3] = None):\n\t        self.logger = logger\n\t        self.w3 = w3\n", "        self.cg = CoinGeckoAPI()\n\t    async def search_contract_address(self, token):\n\t        \"\"\"\n\t        Search a contract function on json file\n\t        using tokenlist format https://github.com/Uniswap/token-lists\n\t        or if not in the list verify with coingecko.\n\t        The token list can be modified for your needs.\n\t        The list are defined in settings. Default settings\n\t        are using list under https://github.com/mraniki/tokenlist\n\t        Args:\n", "            token (str): The token address\n\t        Returns:\n\t            str: The token address in w3 checksum format\n\t        Raises:\n\t            ValueError: Invalid Token\n\t        \"\"\"\n\t        try:\n\t            self.logger.debug(\"Searching Token Address\")\n\t            contract_lists = [\n\t                settings.token_personal_list,\n", "                settings.token_testnet_list,\n\t                settings.token_mainnet_list,\n\t            ]\n\t            for contract_list in contract_lists:\n\t                self.logger.debug(\"Searching {} on {}\", token, contract_list)\n\t                token_address = await self.get_token_address(contract_list, token)\n\t                if token_address is not None:\n\t                    self.logger.debug(\n\t                        \"Found {} on {}\", token_address, contract_list\n\t                    )\n", "                    return self.w3.to_checksum_address(token_address)\n\t            self.logger.debug(\"Searching on Coingecko\")\n\t            token_address = await self.search_cg_contract(token)\n\t            if token_address is None:\n\t                self.logger.warning(\"Invalid Token\")\n\t                raise ValueError(\"Invalid Token\")\n\t            self.logger.debug(\"Found on Coingecko {}\", token_address)\n\t            return self.w3.to_checksum_address(token_address)\n\t        except Exception as e:\n\t            self.logger.error(\": {}\", e)\n", "            raise ValueError(\"Invalid Token\")\n\t    async def search_cg_platform(self):\n\t        \"\"\"\n\t        Search coingecko platform\n\t        Returns:\n\t            str: The platform\n\t        \"\"\"\n\t        asset_platforms = self.cg.get_asset_platforms()\n\t        output_dict = next(\n\t            x\n", "            for x in asset_platforms\n\t            if x[\"chain_identifier\"] == int(self.w3.net.version)\n\t        )\n\t        platform = output_dict[\"id\"] or None\n\t        self.logger.debug(\"coingecko platform identified {}\", platform)\n\t        return platform\n\t    async def search_cg(self, token):\n\t        \"\"\"\n\t        Search Coingecko\n\t        Args:\n", "            token (str): The token symbol\n\t        Returns:\n\t            str: The token dictionary for the platform\n\t        \"\"\"\n\t        try:\n\t            search_results = self.cg.search(query=token)\n\t            search_dict = search_results[\"coins\"]\n\t            filtered_dict = [x for x in search_dict if x[\"symbol\"] == token.upper()]\n\t            api_dict = [sub[\"api_symbol\"] for sub in filtered_dict]\n\t            for i in api_dict:\n", "                coin_dict = self.cg.get_coin_by_id(i)\n\t                try:\n\t                    if coin_dict[\"platforms\"][f\"{await self.search_cg_platform()}\"]:\n\t                        return coin_dict\n\t                except (KeyError, requests.exceptions.HTTPError):\n\t                    pass\n\t        except Exception as e:\n\t            self.logger.error(\"search_cg {}\", e)\n\t    async def search_cg_contract(self, token):\n\t        \"\"\"\n", "        search for a token address on coingecko\n\t        Args:\n\t            token (str): The token symbol\n\t        Returns:\n\t            str: The token address\n\t        \"\"\"\n\t        try:\n\t            self.logger.debug(\"Coingecko Address search for {}\", token)\n\t            coin_info = await self.search_cg(token)\n\t            return (\n", "                coin_info[\"platforms\"][f\"{await self.search_cg_platform()}\"]\n\t                if coin_info is not None\n\t                else None\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(\" search_cg_contract: {}\", e)\n\t    async def get_token_address(self, token_list_url, symbol):\n\t        \"\"\"\n\t        Given a token symbol and json tokenlist, get token address\n\t        Args:\n", "            token_list_url (str): The token list url\n\t            symbol (str): The token symbol\n\t        Returns:\n\t            str: The token address\n\t        \"\"\"\n\t        try:\n\t            self.logger.debug(\"Token address search in {}\", token_list_url)\n\t            token_list = await get(token_list_url)\n\t            token_search = token_list[\"tokens\"]\n\t            for keyval in token_search:\n", "                if keyval[\"symbol\"] == symbol and keyval[\"chainId\"] == int(\n\t                    self.w3.net.version\n\t                ):\n\t                    self.logger.debug(\"token identified\")\n\t                    return keyval[\"address\"]\n\t            raise ValueError(\"Token not found\")\n\t        except Exception as e:\n\t            self.logger.error(\"get_token_address: {}\", e)\n\t            return None\n\t    async def get_token_contract(self, token_address):\n", "        \"\"\"\n\t        Given a token address, returns a contract object.\n\t        Args:\n\t            token_address (str): The token address\n\t        Returns:\n\t            Contract: The token contract\n\t        \"\"\"\n\t        token_abi = await get_explorer_abi(token_address)\n\t        if token_abi is None:\n\t            token_abi = await get(settings.dex_erc20_abi_url)\n", "        return self.w3.eth.contract(address=token_address, abi=token_abi)\n\t    async def get_token_decimals(self, token_address: str) -> Optional[int]:\n\t        \"\"\"\n\t        Get token decimals\n\t        Args:\n\t            token_address (str): The token address\n\t        Returns:\n\t            int: The token decimals\n\t        \"\"\"\n\t        contract = await self.get_token_contract(token_address)\n", "        return 18 if not contract else contract.functions.decimals().call()\n\t    async def get_token_symbol(self, token_address: str):\n\t        \"\"\"\n\t        Get token symbol\n\t        Args:\n\t            token_address (str): The token address\n\t        Returns:\n\t            str: The token symbol\n\t        \"\"\"\n\t        contract = await self.get_token_contract(token_address)\n", "        # token_name = contract.functions.name().call()\n\t        return contract.functions.symbol().call()\n\t    async def get_token_name(self, token_address: str):\n\t        \"\"\"\n\t        Get token symbol\n\t        Args:\n\t            token_address (str): The token address\n\t        Returns:\n\t            str: The token name\n\t        \"\"\"\n", "        contract = await self.get_token_contract(token_address)\n\t        return contract.functions.name().call()\n\t    async def get_token_balance(\n\t        self, token_address: str, wallet_address: str\n\t    ) -> Optional[int]:\n\t        \"\"\"\n\t        Get token balance\n\t        Args:\n\t            token_address (str): The token address\n\t            wallet_address (str): The wallet address\n", "        Returns:\n\t            int: The token balance\n\t        \"\"\"\n\t        contract = await self.get_token_contract(token_address)\n\t        if contract is None or contract.functions is None:\n\t            raise ValueError(\"No Balance\")\n\t        balance = contract.functions.balanceOf(wallet_address).call()\n\t        if balance is None:\n\t            raise ValueError(\"No Balance\")\n\t        return round(self.w3.from_wei(balance, \"ether\"), 5) or 0\n", "    async def calculate_sell_amount(self, sell_token_address, wallet_address, quantity):\n\t        \"\"\"\n\t        Returns amount based on risk percentage.\n\t        Args:\n\t            sell_token_address (str): The sell token address\n\t            wallet_address (str): The wallet address\n\t            quantity (int): The quantity\n\t        Returns:\n\t            float: The sell amount\n\t        \"\"\"\n", "        sell_balance = await self.get_token_balance(sell_token_address, wallet_address)\n\t        sell_contract = await self.get_token_contract(sell_token_address)\n\t        sell_decimals = (\n\t            sell_contract.functions.decimals().call()\n\t            if sell_contract is not None\n\t            else 18\n\t        )\n\t        risk_percentage = settings.trading_risk_amount\n\t        return (sell_balance / (risk_percentage * 10**sell_decimals)) * (\n\t            decimal.Decimal(quantity) / 100\n", "        )\n\t    async def get_confirmation(self, transactionHash):\n\t        \"\"\"\n\t        Returns trade confirmation.\n\t        Args:\n\t            transactionHash (str): The transaction hash\n\t        Returns:\n\t            dict: The trade confirmation\n\t        Raises:\n\t            Exception: Error\n", "        \"\"\"\n\t        try:\n\t            transaction = self.w3.eth.get_transaction(transactionHash)\n\t            block_info = self.w3.eth.get_block(transaction[\"blockNumber\"])\n\t            return {\n\t                \"timestamp\": datetime.utcfromtimestamp(block_info[\"timestamp\"]),\n\t                \"id\": transactionHash,\n\t                \"instrument\": transaction[\"to\"],\n\t                \"contract\": transaction[\"to\"],  # TBD To be determined.\n\t                \"amount\": transaction[\"value\"],\n", "                \"price\": transaction[\"value\"],  # TBD To be determined.\n\t                \"fee\": transaction[\"gas\"],\n\t                \"confirmation\": (\n\t                    f\"➕ Size: {round(transaction['value'], 4)}\\n\"\n\t                    f\"⚫️ Entry: {round(transaction['value'], 4)}\\n\"\n\t                    f\"ℹ️ {transactionHash}\\n\"\n\t                    f\"⛽ {transaction['gas']}\\n\"\n\t                    f\"🗓️ {datetime.utcfromtimestamp(block_info['timestamp'])}\"\n\t                ),\n\t            }\n", "        except Exception as error:\n\t            raise error\n"]}
{"filename": "dxsp/utils/__init__.py", "chunked_list": ["from dxsp.utils.account_utils import AccountUtils\n\tfrom dxsp.utils.contract_utils import ContractUtils\n"]}
{"filename": "dxsp/utils/utils.py", "chunked_list": ["\"\"\"\n\t DEX SWAP\n\t🛠️ W3 UTILS\n\t\"\"\"\n\timport requests\n\timport aiohttp\n\tfrom loguru import logger\n\tMAX_RESPONSE_SIZE = 5 * 1024 * 1024  # Maximum response size in bytes (e.g., 5 MB)\n\tasync def get(url, params=None, headers=None):\n\t    \"\"\"\n", "    Asynchronously gets a url payload\n\t    and returns the response\n\t    Args:\n\t        url (str): The url to get\n\t        params (dict, optional): The params to send. Defaults to None.\n\t        headers (dict, optional): The headers to send. Defaults to None.\n\t    Returns:\n\t        dict: The response\n\t    Raises:\n\t        Exception: Error\n", "    \"\"\"\n\t    # try:\n\t    #     response = requests.get(url, params=params, headers=headers, timeout=20)\n\t    #     logger.debug(response)\n\t    #     if response.status_code == 200:\n\t    #         return response.json()\n\t    # except Exception as error:\n\t    #     logger.error(\"get: {}\", error)\n\t    try:\n\t        async with aiohttp.ClientSession() as session:\n", "            async with session.get(\n\t             url,\n\t             params=None,\n\t             headers=None, \n\t             timeout=20) as response:\n\t                logger.debug(response)\n\t                if response.status == 200:\n\t                    if response.content_length > MAX_RESPONSE_SIZE:\n\t                        logger.warning(\"Response content too large, skipping...\")\n\t                        return None  # Return None for large responses\n", "                    return await response.json(content_type=None)\n\t    except Exception as error:\n\t        logger.error(\"get: {}\", error)\n"]}
{"filename": "dxsp/utils/explorer_utils.py", "chunked_list": ["\"\"\"\n\t DEX SWAP\n\tEXPLORER\n\t\"\"\"\n\tfrom datetime import datetime, timedelta\n\tfrom loguru import logger\n\tfrom dxsp.config import settings\n\tfrom dxsp.utils.utils import get\n\tasync def get_explorer_abi(address):\n\t    \"\"\"\n", "    Retrieves the ABI (Application Binary Interface)\n\t    for the contract at the given address.\n\t    :param address: The address of the contract.\n\t    :type address: str\n\t    :return: The ABI of the contract if it exists, else None.\n\t    :rtype: str or None\n\t    \"\"\"\n\t    if not settings.dex_block_explorer_api:\n\t        return None\n\t    params = {\n", "        \"module\": \"contract\",\n\t        \"action\": \"getabi\",\n\t        \"address\": address,\n\t        \"apikey\": settings.dex_block_explorer_api,\n\t    }\n\t    resp = await get(url=settings.dex_block_explorer_url, params=params)\n\t    return resp[\"result\"] if resp[\"status\"] == \"1\" else None\n\tasync def get_account_transactions(contract_address, wallet_address, period=24):\n\t    \"\"\"\n\t    Retrieves the account transactions\n", "    within a specified time period\n\t    for the main asset activity\n\t    Not yet implemented\n\t    :param contract_address: The address of the contract.\n\t    :type contract_address: str\n\t    :param wallet_address: The address of the wallet.\n\t    :type wallet_address: str\n\t    :param period: The time period in hours\n\t    :type period: int\n\t    :return: The transactions for the account.\n", "    \"\"\"\n\t    pnl_dict = {\"pnl\": 0, \"tokenList\": {}}\n\t    if not settings.dex_block_explorer_api:\n\t        return pnl_dict\n\t    params = {\n\t        \"module\": \"account\",\n\t        \"action\": \"tokentx\",\n\t        \"contractaddress\": contract_address,\n\t        \"address\": wallet_address,\n\t        \"page\": \"1\",\n", "        \"offset\": \"100\",\n\t        \"startblock\": \"0\",\n\t        \"endblock\": \"99999999\",\n\t        \"sort\": \"desc\",\n\t        \"apikey\": settings.dex_block_explorer_api,\n\t    }\n\t    response = await get(url=settings.dex_block_explorer_url, params=params)\n\t    if response.get(\"status\") == \"1\" and \"result\" in response:\n\t        current_time = datetime.utcnow()\n\t        time_history_start = current_time - timedelta(hours=period)\n", "        for entry in response[\"result\"]:\n\t            token_symbol = entry.get(\"tokenSymbol\")\n\t            value = int(entry.get(\"value\", 0))\n\t            timestamp = int(entry.get(\"timeStamp\", 0))\n\t            transaction_time = datetime.utcfromtimestamp(timestamp)\n\t            if transaction_time >= time_history_start and token_symbol:\n\t                pnl_dict[\"tokenList\"][token_symbol] = (\n\t                    pnl_dict[\"tokenList\"].get(token_symbol, 0) + value\n\t                )\n\t                pnl_dict[\"pnl\"] += value\n", "    return pnl_dict\n"]}
{"filename": "dxsp/protocols/zerox.py", "chunked_list": ["\"\"\"\n\t0️⃣x\n\t\"\"\"\n\tfrom dxsp.config import settings\n\tfrom dxsp.main import DexSwap\n\tfrom dxsp.utils.utils import get\n\tclass DexSwapZeroX(DexSwap):\n\t    \"\"\"\n\t    A DEXSwap sub class using 0x protocol\n\t    Implementation of 0x swap protocol\n", "    https://0x.org/docs/0x-swap-api/introduction\n\t    \"\"\"\n\t    async def get_quote(self, buy_address, sell_address, amount=1):\n\t        \"\"\"\n\t        Retrieves a quote for a token swap.\n\t        Args:\n\t            buy_address (str): The address of the token to be bought.\n\t            sell_address (str): The address of the token to be sold.\n\t            amount (int, optional): The amount of tokens to be sold. Defaults to 1.\n\t        Returns:\n", "            float: The guaranteed price for the token swap.\n\t        \"\"\"\n\t        token_decimals = await self.contract_utils.get_token_decimals(sell_address)\n\t        out_amount = amount * (10**token_decimals)\n\t        url = (\n\t            f\"{settings.dex_0x_url}/swap/v1/quote\"\n\t            f\"?buyToken={str(buy_address)}&sellToken={str(sell_address)}&sellAmount={str(out_amount)}\"\n\t        )\n\t        headers = {\"0x-api-key\": settings.dex_0x_api_key}\n\t        response = await get(url, params=None, headers=headers)\n", "        if response:\n\t            return float(response[\"guaranteedPrice\"])\n\t    async def get_swap(self, buy_address, sell_address, amount):\n\t        \"\"\"\n\t        Asynchronously gets a swap order by calling the `get_quote`\n\t        method with the specified `buy_address`,\n\t        `sell_address`, and `amount` parameters.\n\t        Then, it calls the `get_sign` method of the\n\t        `account` object, passing the `swap_order`\n\t        as an argument, and returns the result.\n", "        :param buy_address: The buy address for the swap.\n\t        :param sell_address: The sell address for the swap.\n\t        :param amount: The amount for the swap.\n\t        :return: The result of calling the `get_sign` method\n\t        of the `account` object with the `swap_order`\n\t        as an argument.\n\t        \"\"\"\n\t        swap_order = await self.get_quote(buy_address, sell_address, amount)\n\t        return await self.account.get_sign(swap_order)\n"]}
{"filename": "dxsp/protocols/__init__.py", "chunked_list": ["from .oneinch import DexSwapOneInch\n\tfrom .uniswap import DexSwapUniswap\n\tfrom .zerox import DexSwapZeroX\n"]}
{"filename": "dxsp/protocols/uniswap.py", "chunked_list": ["\"\"\"\n\tuniswap  🦄\n\t\"\"\"\n\tfrom uniswap import Uniswap\n\tfrom dxsp.config import settings\n\tfrom dxsp.main import DexSwap\n\tclass DexSwapUniswap(DexSwap):\n\t    \"\"\"\n\t    A DEXSwap sub class using uniswap-python library\n\t    More info on uniswap-python library:\n", "    https://github.com/uniswap-python/uniswap-python\n\t    \"\"\"\n\t    async def get_quote(self, buy_address, sell_address, amount=1):\n\t        \"\"\"\n\t        Retrieves a quote for the given buy and sell addresses.\n\t        Args:\n\t            buy_address (str): The address of the token to buy.\n\t            sell_address (str): The address of the token to sell.\n\t            amount (int, optional): The amount of tokens to sell. Defaults to 1.\n\t        Returns:\n", "            float: The calculated quote for the given buy and sell addresses.\n\t        \"\"\"\n\t        try:\n\t            uniswap = Uniswap(\n\t                address=self.account.wallet_address,\n\t                private_key=self.account.private_key,\n\t                version=self.protocol_version,\n\t                web3=self.w3,\n\t                factory_contract_addr=settings.dex_factory_contract_addr,\n\t                router_contract_addr=settings.dex_router_contract_addr,\n", "            )\n\t            amount_wei = amount * (\n\t                10 ** (await self.contract_utils.get_token_decimals(sell_address))\n\t            )\n\t            quote = uniswap.get_price_input(sell_address, buy_address, amount_wei)\n\t            return round(\n\t                float(\n\t                    (\n\t                        quote\n\t                        / (\n", "                            10\n\t                            ** (\n\t                                await self.contract_utils.get_token_decimals(\n\t                                    buy_address\n\t                                )\n\t                            )\n\t                        )\n\t                    )\n\t                ),\n\t                5,\n", "            )\n\t        except Exception as error:\n\t            raise ValueError(f\"Quote failed {error}\")\n\t    async def get_swap(self, sell_address, buy_address, amount):\n\t        \"\"\"\n\t        Asynchronously gets the swap\n\t        for the specified sell address, buy address, and amount.\n\t        :param sell_address: The address of the token being sold.\n\t        :type sell_address: str\n\t        :param buy_address: The address of the token being bought.\n", "        :type buy_address: str\n\t        :param amount: The amount of tokens to be swapped.\n\t        :type amount: int\n\t        :return: The result of the swap.\n\t        :rtype: Any\n\t        :raises ValueError: If the swap fails.\n\t        \"\"\"\n\t        try:\n\t            uniswap = Uniswap(\n\t                address=self.account.wallet_address,\n", "                private_key=self.account.private_key,\n\t                version=self.protocol_version,\n\t                web3=self.w3,\n\t                factory_contract_addr=settings.dex_factory_contract_addr,\n\t                router_contract_addr=settings.dex_router_contract_addr,\n\t            )\n\t            return uniswap.make_trade(sell_address, buy_address, amount)\n\t        except Exception as error:\n\t            self.logger.debug(error)\n\t            raise ValueError(f\"Swap failed {error}\")\n"]}
{"filename": "dxsp/protocols/oneinch.py", "chunked_list": ["\"\"\"\n\tOneInch 🦄\n\t\"\"\"\n\tfrom dxsp.config import settings\n\tfrom dxsp.main import DexSwap\n\tclass DexSwapOneInch(DexSwap):\n\t    \"\"\"\n\t    A DEXSwap sub class using 1inch protocol\n\t    https://github.com/mraniki/dxsp/issues/189\n\t    \"\"\"\n", "    async def get_quote(self, buy_address, sell_address, amount=1):\n\t        \"\"\"\n\t        Retrieves a quote for the\n\t        given buy and sell addresses and amount.\n\t        Args:\n\t            buy_address (str): The address of the token to buy.\n\t            sell_address (str): The address of the token to sell.\n\t            amount (int, optional): The amount of tokens to buy. Defaults to 1.\n\t        Returns:\n\t            float: The quote amount rounded to 2 decimal places.\n", "        \"\"\"\n\t        # try:\n\t        pass\n\t        #     min_amount = self.w3.to_wei(amount, 'ether')\n\t        #     quote_url = (\n\t        #         settings.dex_1inch_url\n\t        #         + str(self.chain_id)\n\t        #         + \"/quote?fromTokenAddress=\"\n\t        #         + str(buy_address)\n\t        #         + \"&toTokenAddress=\"\n", "        #         + str(sell_address)\n\t        #         + \"&amount=\"\n\t        #         + str(min_amount))\n\t        #     quote_response = await self._get(\n\t        #         url=quote_url,\n\t        #         params=None,\n\t        #         headers=settings.headers)\n\t        #     self.logger.debug(\"quote_response {}\", quote_response)\n\t        #     if quote_response:\n\t        #         quote_amount = quote_response['toTokenAmount']\n", "        #         self.logger.debug(\"quote_amount {}\", quote_amount)\n\t        #         # quote_decimals = quote_response['fromToken']['decimals']\n\t        #         quote = self.w3.from_wei(int(quote_amount), 'ether')\n\t        #         # /(10 ** quote_decimals))\n\t        #         return round(quote, 2)\n\t    #     except Exception as error:\n\t    #         raise ValueError(f\"Approval failed {error}\")\n\t    # async def get_approve(self, token_address):\n\t    #     # pass\n\t    #     try:\n", "    #         pass\n\t    # approval_check_URL = (\n\t    #     settings.dex_1inch_url\n\t    #     + str(self.chain_id)\n\t    #     + \"/approve/allowance?tokenAddress=\"\n\t    #     + str(sell_address)\n\t    #     + \"&walletAddress=\"\n\t    #     + str(self.wallet_address))\n\t    # approval_response = await self._get(\n\t    #     url=approval_check_URL,\n", "    #     params=None,\n\t    #     headers=settings.headers)\n\t    # approval_check = approval_response['allowance']\n\t    # if (approval_check == 0):\n\t    #     approval_URL = (\n\t    #         settings.dex_1inch_url\n\t    #         + str(self.chain_id)\n\t    #         + \"/approve/transaction?tokenAddress=\"\n\t    #         + str(sell_address))\n\t    #     approval_response = await self._get(approval_URL)\n", "    #     return approval_response\n\t    #     except Exception as error:\n\t    #         raise ValueError(f\"Approval failed {error}\")\n\t    # async def get_swap(self, sell_address, buy_address, amount):\n\t    #     try:\n\t    #         pass\n\t    # swap_url = (\n\t    #     settings.dex_1inch_url\n\t    #     + str(self.chain_id)\n\t    #     + \"/swap?fromTokenAddress=\"\n", "    #     + sell_address\n\t    #     + \"&toTokenAddress=\"\n\t    #     + buy_address\n\t    #     + \"&amount=\"\n\t    #     + amount\n\t    #     + \"&fromAddress=\"\n\t    #     + self.wallet_address\n\t    #     + \"&slippage=\"\n\t    #     + settings.dex_trading_slippage\n\t    #     )\n", "    # swap_order = await self._get(\n\t    #     url=swap_url,\n\t    #     params=None,\n\t    #     headers=settings.headers\n\t    #     )\n\t    # swap_order_status = swap_order['statusCode']\n\t    # if swap_order_status != 200:\n\t    #     return\n\t    # return swap_order\n\t    # except Exception as error:\n", "    #     raise ValueError(f\"Swap failed {error}\")\n"]}
{"filename": "examples/example.py", "chunked_list": ["\"\"\"\n\tDXSP Example\n\t\"\"\"\n\timport asyncio\n\timport sys\n\timport uvicorn\n\tfrom fastapi import FastAPI\n\tfrom loguru import logger\n\tfrom dxsp import DexSwap\n\tfrom dxsp.config import settings\n", "logger.remove()\n\tlogger.add(sys.stderr, level=\"INFO\")\n\tasync def main():\n\t    while True:\n\t        # SWAP HELPER\n\t        dex = DexSwap()\n\t        # print(type(dex))\n\t        print(settings.VALUE)\n\t        # settings.setenv()\n\t        print(dex.account)\n", "        symbol = 'WBTC'\n\t        # # Contract Address\n\t        address = await dex.contract_utils.search_contract_address(symbol)\n\t        print(\"address \", address)\n\t        # # token_contract found 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\n\t        # # get contract and underlying ABI\n\t        token_contract = await dex.contract_utils.get_token_contract(address)\n\t        print(\"Contract \", token_contract)\n\t        # Contract  <web3._utils.datatypes.Contract object at 0x10acdb050>\n\t        quote = await dex.get_quote(symbol)\n", "        print(\"quote \", quote)\n\t        # quote  🦄 29761.19589 USDT\n\t        # # BUY 10 USDC to SWAP with BITCOIN\n\t        # demo_tx = await dex.get_swap('USDT','WBTC',10)\n\t        # print(\"demo_tx \", demo_tx)\n\t        await asyncio.sleep(7200)\n\tapp = FastAPI()\n\t@app.on_event('startup')\n\tasync def start():\n\t    asyncio.create_task(main())\n", "@app.get(\"/\")\n\tdef read_root():\n\t    return {\"DXSP is online\"}\n\t@app.get(\"/health\")\n\tdef health_check():\n\t    return {\"DXSP is online\"}\n\tif __name__ == \"__main__\":\n\t    uvicorn.run(app, host='0.0.0.0', port=8080)\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t# -- Path setup --------------------------------------------------------------\n\timport os\n\timport sys\n\tfrom pathlib import Path\n\tfrom typing import Any, Dict\n\timport pydata_sphinx_theme\n\tfrom sphinx.application import Sphinx\n\tsys.path.insert(0, os.path.abspath('../'))\n\t# -- Project information -----------------------------------------------------\n", "project = 'dxsp'\n\tcopyright = '2023, mraniki'\n\tauthor = 'mraniki'\n\tlanguage = \"en\"\n\t# -- General configuration ---------------------------------------------------\n\textensions = [\n\t    'sphinx.ext.autodoc',\n\t    'sphinx.ext.autosummary',\n\t    'sphinx.ext.napoleon',\n\t    'sphinx.ext.viewcode',\n", "    \"sphinx.ext.intersphinx\",\n\t    \"hoverxref.extension\",\n\t    \"sphinx.ext.extlinks\",\n\t    \"sphinx_design\",\n\t    \"myst_parser\",\n\t    \"sphinx_copybutton\",\n\t    \"notfound.extension\",\n\t    # \"autoapi.extension\",\n\t]\n\t# -- Extension configuration ---------------------------------------------------\n", "# -- intersphinx ------------\n\tintersphinx_mapping = {\n\t    \"sphinx\": (\"https://www.sphinx-doc.org/en/master/\", None),\n\t    # - :doc:`sphinx:usage/extensions/intersphinx`\n\t    \"dynaconf\": (\"https://www.dynaconf.com\", None),\n\t    \"python\": (\"https://docs.python.org/3\", None),\n\t    \"talky\": (\"https://talky.readthedocs.io/en/latest\", None),\n\t    \"talky-dev\": (\"https://talky.readthedocs.io/en/dev/\", None),\n\t    \"findmyorder\": (\n\t        \"https://findmyorder.readthedocs.io/en/latest\", None),\n", "    \"dxsp\": (\"https://dxsp.readthedocs.io/en/latest\", None),\n\t    \"iamlistening\": (\n\t        \"https://iamlistening.readthedocs.io/en/latest\", None),\n\t    \"talkytrend\": (\"https://talkytrend.readthedocs.io/en/latest\", None),\n\t    \"myllm\": (\"https://myllm.readthedocs.io/en/latest\", None),\n\t    \"community\": (\"https://tt-plugins.readthedocs.io/en/latest\", None),\n\t}\n\tintersphinx_disabled_reftypes = [\"*\"]\n\t# -- hoverxref ----------------\n\thoverxref_intersphinx = [\n", "    'readthedocs',\n\t    'sphinx',\n\t    'python',\n\t    'talky',\n\t    'findmyorder',\n\t    'dxsp',\n\t    'iamlistening',\n\t    'talkytrend',\n\t    'myllm',\n\t]\n", "# -- autodoc --------------------\n\tautoclass_content = 'both'\n\tautodoc_inherit_docstrings = True \n\tset_type_checking_flag = True \n\tautodoc_member_order = 'bysource'\n\tadd_module_names = True\n\t# -- autoapi -------------------\n\t# autoapi_type = \"python\"\n\t# autoapi_dirs = ['../iamlistening']\n\t# autoapi_keep_files = True\n", "# autoapi_root = \"api\"\n\t# autoapi_member_order = \"groupwise\"\n\t# -- napoleon -------------------\n\tnapoleon_google_docstring = True\n\t# -- MyST options -----------------\n\t# This allows us to use ::: to denote directives, useful for admonitions\n\tmyst_enable_extensions = [\"colon_fence\", \"linkify\", \"substitution\"]\n\tmyst_heading_anchors = 2\n\tmyst_substitutions = {\"rtd\": \"[Read the Docs](https://readthedocs.org/)\"}\n\tmaster_doc = 'index'\n", "source_suffix = ['.rst', '.md']\n\ttemplates_path = [\"_templates\"]\n\texclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\t# -- Sitemap ----------------------\n\t# ReadTheDocs has its own way of generating sitemaps, etc.\n\tif not os.environ.get(\"READTHEDOCS\"):\n\t    extensions += [\"sphinx_sitemap\"]\n\t    html_baseurl = os.environ.get(\"SITEMAP_URL_BASE\", \"http://127.0.0.1:8000/\")\n\t    sitemap_locales = [None]\n\t    sitemap_url_scheme = \"{link}\"\n", "# -- Options for HTML output --------\n\thtml_static_path = [\"_static\"]\n\thtml_css_files = [\"custom.css\"]\n\thtml_logo = '_static/logo.png'\n\thtml_favicon = '_static/favicon.ico'\n\thtml_show_sphinx = False\n\thtml_show_copyright = False\n\thtml_theme = \"pydata_sphinx_theme\"\n\thtml_theme_options = {\n\t    \"secondary_sidebar_items\": [\"page-toc\"],\n", "    \"logo\": {\n\t        \"link\": \"https://talky.readthedocs.io\",\n\t    },\n\t    \"icon_links\": [\n\t        {\n\t            \"name\": \"GitHub\",\n\t            \"url\": \"https://github.com/mraniki/tt/\",\n\t            \"icon\": \"fa-brands fa-github\",\n\t            \"type\": \"fontawesome\",\n\t        },\n", "        {\n\t            \"name\": \"Telegram\",\n\t            \"url\": \"https://t.me/TTTalkyTraderChat/1\",\n\t            \"icon\": \"fa-brands fa-telegram\",\n\t        },\n\t        {\n\t            \"name\": \"Mastodon\",\n\t            \"url\": \"https://mastodon.social/@MrAniki\",\n\t            \"icon\": \"fa-brands fa-mastodon\",\n\t        },\n", "        {\n\t            \"name\": \"Tips\",\n\t            \"url\": \"https://coindrop.to/mraniki\",\n\t            \"icon\": \"fa-solid fa-burger\",\n\t        },\n\t        ],\n\t}\n\thtml_context = {\n\t   \"default_mode\": \"dark\",\n\t}\n"]}
