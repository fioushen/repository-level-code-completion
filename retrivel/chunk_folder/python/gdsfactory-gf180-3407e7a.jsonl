{"filename": "install_tech.py", "chunked_list": ["\"\"\"Symlink tech to klayout.\"\"\"\n\timport os\n\timport pathlib\n\timport shutil\n\timport sys\n\tdef remove_path_or_dir(dest: pathlib.Path):\n\t    if dest.is_dir():\n\t        os.unlink(dest)\n\t    else:\n\t        os.remove(dest)\n", "def make_link(src, dest, overwrite: bool = True) -> None:\n\t    dest = pathlib.Path(dest)\n\t    if dest.exists() and not overwrite:\n\t        print(f\"{dest} already exists\")\n\t        return\n\t    if dest.exists() or dest.is_symlink():\n\t        print(f\"removing {dest} already installed\")\n\t        remove_path_or_dir(dest)\n\t    try:\n\t        os.symlink(src, dest, target_is_directory=True)\n", "    except OSError:\n\t        shutil.copy(src, dest)\n\t    print(\"link made:\")\n\t    print(f\"From: {src}\")\n\t    print(f\"To:   {dest}\")\n\tif __name__ == \"__main__\":\n\t    klayout_folder = \"KLayout\" if sys.platform == \"win32\" else \".klayout\"\n\t    cwd = pathlib.Path(__file__).resolve().parent\n\t    home = pathlib.Path.home()\n\t    src = cwd / \"gf180\" / \"klayout\"\n", "    dest_folder = home / klayout_folder / \"tech\"\n\t    dest_folder.mkdir(exist_ok=True, parents=True)\n\t    dest = dest_folder / \"gf180\"\n\t    make_link(src=src, dest=dest)\n"]}
{"filename": "tests/test_components.py", "chunked_list": ["import pathlib\n\timport pytest\n\tfrom gdsfactory.component import Component\n\tfrom gdsfactory.difftest import difftest\n\tfrom pytest_regressions.data_regression import DataRegressionFixture\n\tfrom gf180 import cells\n\tskip_test = {\"res_dev\"}\n\tcell_names = set(cells.keys()) - set(skip_test)\n\tdirpath = pathlib.Path(__file__).absolute().parent / \"gds_ref\"\n\t@pytest.fixture(params=cell_names, scope=\"function\")\n", "def component(request) -> Component:\n\t    return cells[request.param]()\n\tdef test_pdk_gds(component: Component) -> None:\n\t    \"\"\"Avoid regressions in GDS geometry shapes and layers.\"\"\"\n\t    difftest(component, dirpath=dirpath)\n\tdef test_pdk_settings(\n\t    component: Component, data_regression: DataRegressionFixture\n\t) -> None:\n\t    \"\"\"Avoid regressions when exporting settings.\"\"\"\n\t    data_regression.check(component.to_dict())\n", "def test_assert_ports_on_grid(component: Component):\n\t    component.assert_ports_on_grid()\n"]}
{"filename": "docs/write_cells.py", "chunked_list": ["import inspect\n\timport pathlib\n\tfrom gf180 import cells\n\tfilepath = pathlib.Path(__file__).parent.absolute() / \"cells.rst\"\n\tskip = {\n\t    \"LIBRARY\",\n\t    \"circuit_names\",\n\t    \"component_factory\",\n\t    \"component_names\",\n\t    \"container_names\",\n", "    \"component_names_test_ports\",\n\t    \"component_names_skip_test\",\n\t    \"component_names_skip_test_ports\",\n\t    \"dataclasses\",\n\t    \"library\",\n\t    \"waveguide_template\",\n\t}\n\tskip_plot: tuple[str, ...] = (\"add_fiber_array_siepic\",)\n\tskip_settings: tuple[str, ...] = (\"flatten\", \"safe_cell_names\")\n\twith open(filepath, \"w+\") as f:\n", "    f.write(\n\t        \"\"\"\n\tHere are the parametric cells available in the PDK\n\tCells\n\t=============================\n\t\"\"\"\n\t    )\n\t    for name in sorted(cells.keys()):\n\t        if name in skip or name.startswith(\"_\"):\n\t            continue\n", "        print(name)\n\t        sig = inspect.signature(cells[name])\n\t        kwargs = \", \".join(\n\t            [\n\t                f\"{p}={repr(sig.parameters[p].default)}\"\n\t                for p in sig.parameters\n\t                if isinstance(sig.parameters[p].default, (int, float, str, tuple))\n\t                and p not in skip_settings\n\t            ]\n\t        )\n", "        if name in skip_plot:\n\t            f.write(\n\t                f\"\"\"\n\t{name}\n\t----------------------------------------------------\n\t.. autofunction:: gf180.{name}\n\t\"\"\"\n\t            )\n\t        else:\n\t            f.write(\n", "                f\"\"\"\n\t{name}\n\t----------------------------------------------------\n\t.. autofunction:: gf180.{name}\n\t.. plot::\n\t  :include-source:\n\t  import gf180\n\t  c = gf180.{name}({kwargs})\n\t  c.plot()\n\t\"\"\"\n", "            )\n"]}
{"filename": "docs/notebooks/intro.py", "chunked_list": ["# ---\n\t# jupyter:\n\t#   jupytext:\n\t#     custom_cell_magics: kql\n\t#     text_representation:\n\t#       extension: .py\n\t#       format_name: percent\n\t#       format_version: '1.3'\n\t#       jupytext_version: 1.11.2\n\t#   kernelspec:\n", "#     display_name: Python 3 (ipykernel)\n\t#     language: python\n\t#     name: python3\n\t# ---\n\t# %% [markdown]\n\t# # Layout\n\t#\n\t# ## Layout driven flow\n\t#\n\t# You can import the PDK and layout any of the standard cells\n", "# %%\n\timport gf180\n\t# %%\n\tc = gf180.diode_dw2ps()\n\tc\n"]}
{"filename": "gf180/res.py", "chunked_list": ["import gdsfactory as gf\n\tfrom gdsfactory.typings import Float2, LayerSpec\n\tfrom gf180.guardring import pcmpgr_gen\n\tfrom gf180.layers import layer\n\tfrom gf180.via_generator import via_stack\n\t@gf.cell\n\tdef res(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"rm1\",\n", "    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw 2-terminal Metal resistor by specifying parameters\n\t    Args:\n\t         l      : Float of diff length\n\t         w      : Float of diff width\n", "    \"\"\"\n\t    c = gf.Component(\"res_dev\")\n\t    m_ext = 0.28\n\t    if res_type == \"rm1\":\n\t        m_layer = layer[\"metal1\"]\n\t        res_layer = layer[\"metal1_res\"]\n\t        m_lbl_layer = layer[\"metal1_label\"]\n\t    elif res_type == \"rm2\":\n\t        m_layer = layer[\"metal2\"]\n\t        res_layer = layer[\"metal2_res\"]\n", "        m_lbl_layer = layer[\"metal2_label\"]\n\t    elif res_type == \"rm3\":\n\t        m_layer = layer[\"metal3\"]\n\t        res_layer = layer[\"metal3_res\"]\n\t        m_lbl_layer = layer[\"metal3_label\"]\n\t    else:\n\t        m_layer = layer[\"metaltop\"]\n\t        res_layer = layer[\"metal6_res\"]\n\t        m_lbl_layer = layer[\"metaltop_label\"]\n\t    res_mk = c.add_ref(gf.components.rectangle(size=(l_res, w_res), layer=res_layer))\n", "    m_rect = c.add_ref(\n\t        gf.components.rectangle(size=(l_res + (2 * m_ext), w_res), layer=m_layer)\n\t    )\n\t    m_rect.xmin = res_mk.xmin - m_ext\n\t    m_rect.ymin = res_mk.ymin\n\t    # labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n", "                res_mk.xmin + (res_mk.size[0] / 2),\n\t                res_mk.ymin + (res_mk.size[1] / 2),\n\t            ),\n\t            layer=m_lbl_layer,\n\t        )\n\t        c.add_label(\n\t            r1_lbl,\n\t            position=(\n\t                m_rect.xmin + (res_mk.xmin - m_rect.xmin) / 2,\n\t                m_rect.ymin + (m_rect.size[1] / 2),\n", "            ),\n\t            layer=m_lbl_layer,\n\t        )\n\t    return c\n\t@gf.cell\n\tdef plus_res_inst(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"nplus_s\",\n\t    sub: bool = 0,\n", "    cmp_res_ext: float = 0.1,\n\t    con_enc: float = 0.1,\n\t    cmp_imp_layer: LayerSpec = layer[\"nplus\"],\n\t    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component()\n", "    sub_w: float = 0.36\n\t    np_enc_cmp: float = 0.16\n\t    pp_enc_cmp: float = 0.16\n\t    comp_spacing: float = 0.72\n\t    sab_res_ext = 0.22\n\t    res_mk = c.add_ref(\n\t        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n\t    )\n\t    if \"plus_u\" in res_type:\n\t        sab_rect = c.add_ref(\n", "            gf.components.rectangle(\n\t                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n\t                layer=layer[\"sab\"],\n\t            )\n\t        )\n\t        sab_rect.xmin = res_mk.xmin\n\t        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\t    cmp = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(res_mk.size[0] + (2 * cmp_res_ext), res_mk.size[1]),\n", "            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    cmp.xmin = res_mk.xmin - cmp_res_ext\n\t    cmp.ymin = res_mk.ymin\n\t    cmp_con = via_stack(\n\t        x_range=(cmp.xmin, res_mk.xmin + con_enc),\n\t        y_range=(cmp.ymin, cmp.ymax),\n\t        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n", "    )\n\t    cmp_con_arr = c.add_array(\n\t        component=cmp_con,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmp_res_ext - con_enc + res_mk.size[0], 0),\n\t    )  # comp contact array\n\t    # labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n", "            r0_lbl,\n\t            position=(\n\t                cmp_con_arr.xmin + (cmp_con.size[0] / 2),\n\t                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            r1_lbl,\n\t            position=(\n", "                cmp_con_arr.xmax - (cmp_con.size[0] / 2),\n\t                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    cmp_imp = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(cmp.size[0] + (2 * np_enc_cmp), cmp.size[1] + (2 * np_enc_cmp)),\n\t            layer=cmp_imp_layer,\n\t        )\n", "    )\n\t    cmp_imp.xmin = cmp.xmin - np_enc_cmp\n\t    cmp_imp.ymin = cmp.ymin - np_enc_cmp\n\t    if sub == 1:\n\t        sub_rect = c.add_ref(\n\t            gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n\t        )\n\t        sub_rect.xmax = cmp.xmin - comp_spacing\n\t        sub_rect.ymin = cmp.ymin\n\t        # sub_rect contact\n", "        sub_con = c.add_ref(\n\t            via_stack(\n\t                x_range=(sub_rect.xmin, sub_rect.xmax),\n\t                y_range=(sub_rect.ymin, sub_rect.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n\t            )\n\t        )\n\t        sub_imp = c.add_ref(\n\t            gf.components.rectangle(\n", "                size=(\n\t                    sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                    cmp.size[1] + (2 * pp_enc_cmp),\n\t                ),\n\t                layer=sub_imp_layer,\n\t            )\n\t        )\n\t        sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t        sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\t        # label generation\n", "        if lbl == 1:\n\t            c.add_label(\n\t                sub_lbl,\n\t                position=(\n\t                    sub_con.xmin + (sub_con.size[0] / 2),\n\t                    sub_con.ymin + (sub_con.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t            )\n\t    return c\n", "@gf.cell\n\tdef nplus_res(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"nplus_s\",\n\t    sub: bool = 0,\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n", "    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component()\n\t    lvpwell_enc_cmp = 0.43\n\t    dn_enc_lvpwell = 2.5\n\t    sub_w = 0.36\n\t    if res_type == \"nplus_s\":\n\t        cmp_res_ext = 0.29\n\t        con_enc = 0.07\n", "    else:\n\t        cmp_res_ext = 0.44\n\t        con_enc = 0.0\n\t    # adding res inst\n\t    r_inst = c.add_ref(\n\t        plus_res_inst(\n\t            l_res=l_res,\n\t            w_res=w_res,\n\t            res_type=res_type,\n\t            sub=sub,\n", "            cmp_res_ext=cmp_res_ext,\n\t            con_enc=con_enc,\n\t            cmp_imp_layer=layer[\"nplus\"],\n\t            sub_imp_layer=layer[\"pplus\"],\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n\t            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n\t        )\n\t    )\n", "    if deepnwell == 1:\n\t        lvpwell = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n\t                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n\t                ),\n\t                layer=layer[\"lvpwell\"],\n\t            )\n\t        )\n", "        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n\t        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n\t                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n", "        )\n\t        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    return c\n\t@gf.cell\n\tdef pplus_res(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n", "    res_type: str = \"pplus_s\",\n\t    sub: bool = 0,\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n", "    nw_enc_pcmp = 0.6\n\t    dn_enc_ncmp = 0.66\n\t    dn_enc_pcmp = 1.02\n\t    sub_w = 0.36\n\t    if res_type == \"pplus_s\":\n\t        cmp_res_ext = 0.29\n\t        con_enc = 0.07\n\t    else:\n\t        cmp_res_ext = 0.44\n\t        con_enc = 0.0\n", "    # adding res inst\n\t    r_inst = c.add_ref(\n\t        plus_res_inst(\n\t            l_res=l_res,\n\t            w_res=w_res,\n\t            res_type=res_type,\n\t            sub=1,\n\t            cmp_res_ext=cmp_res_ext,\n\t            con_enc=con_enc,\n\t            cmp_imp_layer=layer[\"pplus\"],\n", "            sub_imp_layer=layer[\"nplus\"],\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n\t            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n\t        )\n\t    )\n\t    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n", "                size=(\n\t                    r_inst.size[0] + (dn_enc_pcmp + dn_enc_ncmp),\n\t                    r_inst.size[1] + (2 * dn_enc_pcmp),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmax = r_inst.xmax + dn_enc_pcmp\n\t        dn_rect.ymin = r_inst.ymin - dn_enc_pcmp\n\t        if pcmpgr == 1:\n", "            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    else:\n\t        nw_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (2 * nw_enc_pcmp),\n\t                    r_inst.size[1] + (2 * nw_enc_pcmp),\n\t                ),\n\t                layer=layer[\"nwell\"],\n\t            )\n", "        )\n\t        nw_rect.xmin = r_inst.xmin - nw_enc_pcmp\n\t        nw_rect.ymin = r_inst.ymin - nw_enc_pcmp\n\t    return c\n\t@gf.cell\n\tdef polyf_res_inst(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"npolyf_s\",\n\t    pl_res_ext: float = 0.1,\n", "    con_enc: float = 0.1,\n\t    pl_imp_layer: LayerSpec = layer[\"nplus\"],\n\t    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component()\n\t    sub_w: float = 0.36\n", "    np_enc_poly2 = 0.3\n\t    pp_enc_cmp: float = 0.16\n\t    comp_spacing: float = 0.72\n\t    sab_res_ext = 0.28\n\t    res_mk = c.add_ref(\n\t        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n\t    )\n\t    if \"polyf_u\" in res_type:\n\t        sab_rect = c.add_ref(\n\t            gf.components.rectangle(\n", "                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n\t                layer=layer[\"sab\"],\n\t            )\n\t        )\n\t        sab_rect.xmin = res_mk.xmin\n\t        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\t    pl = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n\t            layer=layer[\"poly2\"],\n", "        )\n\t    )\n\t    pl.xmin = res_mk.xmin - pl_res_ext\n\t    pl.ymin = res_mk.ymin\n\t    pl_con = via_stack(\n\t        x_range=(pl.xmin, res_mk.xmin + con_enc),\n\t        y_range=(pl.ymin, pl.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t    )\n", "    pl_con_arr = c.add_array(\n\t        component=pl_con,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(pl_res_ext - con_enc + res_mk.size[0], 0),\n\t    )  # comp contact array\n\t    pl_imp = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(pl.size[0] + (2 * np_enc_poly2), pl.size[1] + (2 * np_enc_poly2)),\n\t            layer=pl_imp_layer,\n", "        )\n\t    )\n\t    pl_imp.xmin = pl.xmin - np_enc_poly2\n\t    pl_imp.ymin = pl.ymin - np_enc_poly2\n\t    sub_rect = c.add_ref(\n\t        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n\t    )\n\t    sub_rect.xmax = pl.xmin - comp_spacing\n\t    sub_rect.ymin = pl.ymin\n\t    # sub_rect contact\n", "    sub_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(sub_rect.xmin, sub_rect.xmax),\n\t            y_range=(sub_rect.ymin, sub_rect.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )\n\t    sub_imp = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                pl.size[1] + (2 * pp_enc_cmp),\n\t            ),\n\t            layer=sub_imp_layer,\n\t        )\n\t    )\n\t    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\t    # labels generation\n", "    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n\t                pl_con_arr.xmin + (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n", "            r1_lbl,\n\t            position=(\n\t                pl_con_arr.xmax - (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            sub_lbl,\n\t            position=(\n", "                sub_con.xmin + (sub_con.size[0] / 2),\n\t                sub_con.ymin + (sub_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    return c\n\t@gf.cell\n\tdef npolyf_res(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n", "    res_type: str = \"npolyf_s\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    lvpwell_enc_cmp = 0.43\n", "    dn_enc_lvpwell = 2.5\n\t    sub_w = 0.36\n\t    if res_type == \"npolyf_s\":\n\t        pl_res_ext = 0.29\n\t        con_enc = 0.07\n\t    else:\n\t        pl_res_ext = 0.44\n\t        con_enc = 0.0\n\t    # adding res inst\n\t    r_inst = c.add_ref(\n", "        polyf_res_inst(\n\t            l_res=l_res,\n\t            w_res=w_res,\n\t            res_type=res_type,\n\t            pl_res_ext=pl_res_ext,\n\t            con_enc=con_enc,\n\t            pl_imp_layer=layer[\"nplus\"],\n\t            sub_imp_layer=layer[\"pplus\"],\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n", "            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n\t        )\n\t    )\n\t    if deepnwell == 1:\n\t        lvpwell = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n\t                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n", "                ),\n\t                layer=layer[\"lvpwell\"],\n\t            )\n\t        )\n\t        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n\t        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n", "                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    return c\n", "@gf.cell\n\tdef ppolyf_res(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"ppolyf_s\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n", "    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    sub_w = 0.36\n\t    dn_enc_ncmp = 0.66\n\t    dn_enc_poly2 = 1.34\n\t    if res_type == \"ppolyf_s\":\n\t        pl_res_ext = 0.29\n\t        con_enc = 0.07\n\t    else:\n", "        pl_res_ext = 0.44\n\t        con_enc = 0.0\n\t    if deepnwell == 1:\n\t        sub_layer = layer[\"nplus\"]\n\t    else:\n\t        sub_layer = layer[\"pplus\"]\n\t    # adding res inst\n\t    r_inst = c.add_ref(\n\t        polyf_res_inst(\n\t            l_res=l_res,\n", "            w_res=w_res,\n\t            res_type=res_type,\n\t            pl_res_ext=pl_res_ext,\n\t            con_enc=con_enc,\n\t            pl_imp_layer=layer[\"pplus\"],\n\t            sub_imp_layer=sub_layer,\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n\t            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n", "        )\n\t    )\n\t    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (dn_enc_poly2 + dn_enc_ncmp),\n\t                    r_inst.size[1] + (2 * dn_enc_poly2),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n", "            )\n\t        )\n\t        dn_rect.xmax = r_inst.xmax + dn_enc_poly2\n\t        dn_rect.ymin = r_inst.ymin - dn_enc_poly2\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    return c\n\t@gf.cell\n\tdef ppolyf_u_high_Rs_res(\n\t    l_res: float = 0.42,\n", "    w_res: float = 0.42,\n\t    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n", "    dn_enc_ncmp = 0.62\n\t    dn_enc_poly2 = 1.34\n\t    pl_res_ext = 0.64\n\t    sub_w: float = 0.42\n\t    pp_enc_poly2 = 0.18\n\t    pp_enc_cmp: float = 0.02\n\t    comp_spacing: float = 0.7\n\t    sab_res_ext = (0.1, 0.28)\n\t    con_size = 0.36\n\t    resis_enc = (1.04, 0.4)\n", "    dg_enc_dn = 0.5\n\t    res_mk = c.add_ref(\n\t        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n\t    )\n\t    resis_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                res_mk.size[0] + (2 * resis_enc[0]),\n\t                res_mk.size[1] + (2 * resis_enc[1]),\n\t            ),\n", "            layer=layer[\"resistor\"],\n\t        )\n\t    )\n\t    resis_mk.xmin = res_mk.xmin - resis_enc[0]\n\t    resis_mk.ymin = res_mk.ymin - resis_enc[1]\n\t    sab_rect = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                res_mk.size[0] + (2 * sab_res_ext[0]),\n\t                res_mk.size[1] + (2 * sab_res_ext[1]),\n", "            ),\n\t            layer=layer[\"sab\"],\n\t        )\n\t    )\n\t    sab_rect.xmin = res_mk.xmin - sab_res_ext[0]\n\t    sab_rect.ymin = res_mk.ymin - sab_res_ext[1]\n\t    pl = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n\t            layer=layer[\"poly2\"],\n", "        )\n\t    )\n\t    pl.xmin = res_mk.xmin - pl_res_ext\n\t    pl.ymin = res_mk.ymin\n\t    pl_con = via_stack(\n\t        x_range=(pl.xmin, pl.xmin + con_size),\n\t        y_range=(pl.ymin, pl.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t    )\n", "    pl_con_arr = c.add_array(\n\t        component=pl_con,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(pl.size[0] - con_size, 0),\n\t    )  # comp contact array\n\t    pplus = gf.components.rectangle(\n\t        size=(pl_res_ext + pp_enc_poly2, pl.size[1] + (2 * pp_enc_poly2)),\n\t        layer=layer[\"pplus\"],\n\t    )\n", "    pplus_arr = c.add_array(\n\t        component=pplus, rows=1, columns=2, spacing=(pplus.size[0] + res_mk.size[0], 0)\n\t    )\n\t    pplus_arr.xmin = pl.xmin - pp_enc_poly2\n\t    pplus_arr.ymin = pl.ymin - pp_enc_poly2\n\t    sub_rect = c.add_ref(\n\t        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n\t    )\n\t    sub_rect.xmax = pl.xmin - comp_spacing\n\t    sub_rect.ymin = pl.ymin\n", "    # sub_rect contact\n\t    sub_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(sub_rect.xmin, sub_rect.xmax),\n\t            y_range=(sub_rect.ymin, sub_rect.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )\n\t    # labels generation\n", "    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n\t                pl_con_arr.xmin + (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n", "            r1_lbl,\n\t            position=(\n\t                pl_con_arr.xmax - (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            sub_lbl,\n\t            position=(\n", "                sub_con.xmin + (sub_con.size[0] / 2),\n\t                sub_con.ymin + (sub_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    if deepnwell == 1:\n\t        sub_layer = layer[\"nplus\"]\n\t    else:\n\t        sub_layer = layer[\"pplus\"]\n\t    sub_imp = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                pl.size[1] + (2 * pp_enc_cmp),\n\t            ),\n\t            layer=sub_layer,\n\t        )\n\t    )\n\t    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n", "    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (pl.xmax - sub_rect.xmin) + (dn_enc_poly2 + dn_enc_ncmp),\n\t                    pl.size[1] + (2 * dn_enc_poly2),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n", "        dn_rect.xmax = pl.xmax + dn_enc_poly2\n\t        dn_rect.ymin = pl.ymin - dn_enc_poly2\n\t        if volt == \"5/6V\":\n\t            dg = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        dn_rect.size[0] + (2 * dg_enc_dn),\n\t                        dn_rect.size[1] + (2 * dg_enc_dn),\n\t                    ),\n\t                    layer=layer[\"dualgate\"],\n", "                )\n\t            )\n\t            dg.xmin = dn_rect.xmin - dg_enc_dn\n\t            dg.ymin = dn_rect.ymin - dg_enc_dn\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    else:\n\t        if volt == \"5/6V\":\n\t            dg = c.add_ref(\n\t                gf.components.rectangle(\n", "                    size=(resis_mk.size[0], resis_mk.size[1]), layer=layer[\"dualgate\"]\n\t                )\n\t            )\n\t            dg.xmin = resis_mk.xmin\n\t            dg.ymin = resis_mk.ymin\n\t    return c\n\t@gf.cell\n\tdef well_res(\n\t    l_res: float = 0.42,\n\t    w_res: float = 0.42,\n", "    res_type: str = \"nwell\",\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    nw_res_ext = 0.48\n\t    nw_res_enc = 0.5\n", "    nw_enc_cmp = 0.12\n\t    sub_w: float = 0.36\n\t    pp_enc_cmp: float = 0.16\n\t    nw_comp_spacing: float = 0.72\n\t    dn_enc_lvpwell = 2.5\n\t    if res_type == \"pwell\":\n\t        cmp_imp_layer = layer[\"pplus\"]\n\t        sub_imp_layer = layer[\"nplus\"]\n\t        well_layer = layer[\"lvpwell\"]\n\t    else:\n", "        cmp_imp_layer = layer[\"nplus\"]\n\t        sub_imp_layer = layer[\"pplus\"]\n\t        well_layer = layer[\"nwell\"]\n\t    res_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(l_res, w_res + (2 * nw_res_enc)), layer=layer[\"res_mk\"]\n\t        )\n\t    )\n\t    well_rect = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(res_mk.size[0] + (2 * nw_res_ext), w_res), layer=well_layer\n\t        )\n\t    )\n\t    well_rect.xmin = res_mk.xmin - nw_res_ext\n\t    well_rect.ymin = res_mk.ymin + nw_res_enc\n\t    @gf.cell\n\t    def comp_related_gen(size: Float2 = (0.42, 0.42)) -> gf.Component:\n\t        c = gf.Component()\n\t        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\t        cmp.xmin = well_rect.xmin + nw_enc_cmp\n", "        cmp.ymin = well_rect.ymin + nw_enc_cmp\n\t        c.add_ref(\n\t            via_stack(\n\t                x_range=(cmp.xmin, cmp.xmax),\n\t                y_range=(cmp.ymin, cmp.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n\t            )\n\t        )  # contact\n\t        return c\n", "    con_polys = comp_related_gen(\n\t        size=(\n\t            res_mk.xmin - well_rect.xmin - nw_enc_cmp,\n\t            well_rect.size[1] - (2 * nw_enc_cmp),\n\t        )\n\t    )\n\t    con_polys_arr = c.add_array(\n\t        component=con_polys,\n\t        rows=1,\n\t        columns=2,\n", "        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n\t    )  # comp and its related contact array\n\t    nplus_rect = gf.components.rectangle(\n\t        size=(\n\t            con_polys.size[0] + (2 * pp_enc_cmp),\n\t            con_polys.size[1] + (2 * pp_enc_cmp),\n\t        ),\n\t        layer=cmp_imp_layer,\n\t    )\n\t    nplus_arr = c.add_array(\n", "        component=nplus_rect,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n\t    )\n\t    nplus_arr.xmin = con_polys.xmin - pp_enc_cmp\n\t    nplus_arr.ymin = con_polys.ymin - pp_enc_cmp\n\t    sub_rect = c.add_ref(\n\t        gf.components.rectangle(size=(sub_w, well_rect.size[1]), layer=layer[\"comp\"])\n\t    )\n", "    sub_rect.xmax = well_rect.xmin - nw_comp_spacing\n\t    sub_rect.ymin = well_rect.ymin\n\t    # sub_rect contact\n\t    sub_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(sub_rect.xmin, sub_rect.xmax),\n\t            y_range=(sub_rect.ymin, sub_rect.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n", "    )\n\t    sub_imp = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                well_rect.size[1] + (2 * pp_enc_cmp),\n\t            ),\n\t            layer=sub_imp_layer,\n\t        )\n\t    )\n", "    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\t    if res_type == \"pwell\":\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    well_rect.size[0] + (2 * dn_enc_lvpwell),\n\t                    well_rect.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n", "            )\n\t        )\n\t        dn_rect.xmin = well_rect.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = well_rect.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    # labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n", "            position=(\n\t                con_polys_arr.xmin + (con_polys.size[0] / 2),\n\t                con_polys_arr.ymin + (con_polys.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            r1_lbl,\n\t            position=(\n\t                con_polys_arr.xmax - (con_polys.size[0] / 2),\n", "                con_polys_arr.ymin + (con_polys.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            sub_lbl,\n\t            position=(\n\t                sub_con.xmin + (sub_con.size[0] / 2),\n\t                sub_con.ymin + (sub_con.size[1] / 2),\n\t            ),\n", "            layer=layer[\"metal1_label\"],\n\t        )\n\t    return c\n\tif __name__ == \"__main__\":\n\t    c = res()\n\t    c.show()\n"]}
{"filename": "gf180/layers.py", "chunked_list": ["import gdsfactory as gf\n\tfrom gdsfactory.typings import Layer\n\tfrom pydantic import BaseModel\n\tfrom gf180.config import PATH\n\tclass LayerMap(BaseModel):\n\t    comp: Layer = (22, 0)\n\t    dnwell: Layer = (12, 0)\n\t    nwell: Layer = (21, 0)\n\t    lvpwell: Layer = (204, 0)\n\t    dualgate: Layer = (55, 0)\n", "    poly2: Layer = (30, 0)\n\t    nplus: Layer = (32, 0)\n\t    pplus: Layer = (31, 0)\n\t    sab: Layer = (49, 0)\n\t    esd: Layer = (24, 0)\n\t    contact: Layer = (33, 0)\n\t    metal1: Layer = (34, 0)\n\t    via1: Layer = (35, 0)\n\t    metal2: Layer = (36, 0)\n\t    via2: Layer = (38, 0)\n", "    metal3: Layer = (42, 0)\n\t    via3: Layer = (40, 0)\n\t    metal4: Layer = (46, 0)\n\t    via4: Layer = (41, 0)\n\t    metal5: Layer = (81, 0)\n\t    via5: Layer = (82, 0)\n\t    metaltop: Layer = (53, 0)\n\t    pad: Layer = (37, 0)\n\t    resistor: Layer = (62, 0)\n\t    fhres: Layer = (227, 0)\n", "    fusetop: Layer = (75, 0)\n\t    fusewindow_d: Layer = (96, 1)\n\t    polyfuse: Layer = (220, 0)\n\t    mvsd: Layer = (210, 0)\n\t    mvpsd: Layer = (11, 39)\n\t    nat: Layer = (5, 0)\n\t    comp_dummy: Layer = (22, 4)\n\t    poly2_dummy: Layer = (30, 4)\n\t    metal1_dummy: Layer = (34, 4)\n\t    metal2_dummy: Layer = (36, 4)\n", "    metal3_dummy: Layer = (42, 4)\n\t    metal4_dummy: Layer = (46, 4)\n\t    metal5_dummy: Layer = (81, 4)\n\t    metaltop_dummy: Layer = (53, 4)\n\t    comp_label: Layer = (22, 10)\n\t    poly2_label: Layer = (30, 10)\n\t    metal1_label: Layer = (34, 10)\n\t    metal2_label: Layer = (36, 10)\n\t    metal3_label: Layer = (42, 10)\n\t    metal4_label: Layer = (46, 10)\n", "    metal5_label: Layer = (81, 10)\n\t    metaltop_label: Layer = (53, 10)\n\t    metal1_slot: Layer = (34, 3)\n\t    metal2_slot: Layer = (36, 3)\n\t    metal3_slot: Layer = (42, 3)\n\t    metal4_slot: Layer = (46, 3)\n\t    metal5_slot: Layer = (81, 3)\n\t    metaltop_slot: Layer = (53, 3)\n\t    ubmpperi: Layer = (183, 0)\n\t    ubmparray: Layer = (184, 0)\n", "    ubmeplate: Layer = (185, 0)\n\t    schottky_diode: Layer = (241, 0)\n\t    zener: Layer = (178, 0)\n\t    res_mk: Layer = (110, 5)\n\t    opc_drc: Layer = (124, 5)\n\t    ndmy: Layer = (111, 5)\n\t    pmndmy: Layer = (152, 5)\n\t    v5_xtor: Layer = (112, 1)\n\t    cap_mk: Layer = (117, 5)\n\t    mos_cap_mk: Layer = (166, 5)\n", "    ind_mk: Layer = (151, 5)\n\t    diode_mk: Layer = (115, 5)\n\t    drc_bjt: Layer = (127, 5)\n\t    lvs_bjt: Layer = (118, 5)\n\t    mim_l_mk: Layer = (117, 10)\n\t    latchup_mk: Layer = (137, 5)\n\t    guard_ring_mk: Layer = (167, 5)\n\t    otp_mk: Layer = (173, 5)\n\t    mtpmark: Layer = (122, 5)\n\t    neo_ee_mk: Layer = (88, 17)\n", "    sramcore: Layer = (108, 5)\n\t    lvs_rf: Layer = (100, 5)\n\t    lvs_drain: Layer = (100, 7)\n\t    ind_mk1: Layer = (151, 5)\n\t    hvpolyrs: Layer = (123, 5)\n\t    lvs_io: Layer = (119, 5)\n\t    probe_mk: Layer = (13, 17)\n\t    esd_mk: Layer = (24, 5)\n\t    lvs_source: Layer = (100, 8)\n\t    well_diode_mk: Layer = (153, 51)\n", "    ldmos_xtor: Layer = (226, 0)\n\t    plfuse: Layer = (125, 5)\n\t    efuse_mk: Layer = (80, 5)\n\t    mcell_feol_mk: Layer = (11, 17)\n\t    ymtp_mk: Layer = (86, 17)\n\t    dev_wf_mk: Layer = (128, 17)\n\t    metal1_blk: Layer = (34, 5)\n\t    metal2_blk: Layer = (36, 5)\n\t    metal3_blk: Layer = (42, 5)\n\t    metal4_blk: Layer = (46, 5)\n", "    metal5_blk: Layer = (81, 5)\n\t    metalt_blk: Layer = (53, 5)\n\t    pr_bndry: Layer = (0, 0)\n\t    mdiode: Layer = (116, 5)\n\t    metal1_res: Layer = (110, 11)\n\t    metal2_res: Layer = (110, 12)\n\t    metal3_res: Layer = (110, 13)\n\t    metal4_res: Layer = (110, 14)\n\t    metal5_res: Layer = (110, 15)\n\t    metal6_res: Layer = (110, 16)\n", "    border: Layer = (63, 0)\n\tLAYER = LayerMap()\n\tlayer = dict(LAYER)\n\tLAYER_VIEWS = gf.technology.LayerViews(PATH.lyp_yaml)\n\tif __name__ == \"__main__\":\n\t    LAYER_VIEWS.to_lyp(PATH.lyp)\n"]}
{"filename": "gf180/config.py", "chunked_list": ["\"\"\"Store configuration.\"\"\"\n\t__all__ = [\"PATH\"]\n\timport pathlib\n\thome = pathlib.Path.home()\n\tcwd = pathlib.Path.cwd()\n\tcwd_config = cwd / \"config.yml\"\n\thome_config = home / \".config\" / \"gf180.yml\"\n\tconfig_dir = home / \".config\"\n\tconfig_dir.mkdir(exist_ok=True)\n\tmodule_path = pathlib.Path(__file__).parent.absolute()\n", "repo_path = module_path.parent\n\tclass Path:\n\t    module = module_path\n\t    repo = repo_path\n\t    lyp = module_path / \"klayout\" / \"tech\" / \"gf180mcu.lyp\"\n\t    lyp_yaml = module_path / \"layers.yaml\"\n\tPATH = Path()\n\tif __name__ == \"__main__\":\n\t    print(PATH)\n"]}
{"filename": "gf180/guardring.py", "chunked_list": ["import gdsfactory as gf\n\tfrom gf180.layers import LAYER, layer\n\tfrom gf180.via_generator import via_generator\n\tdn_rect = gf.partial(gf.components.rectangle, layer=LAYER.dnwell)\n\t@gf.cell\n\tdef pcmpgr_gen(dn_rect=dn_rect, grw: float = 0.36) -> gf.Component:\n\t    \"\"\"Return deepnwell guardring\n\t    Args:\n\t        dn_rect : deepnwell polygon.\n\t        grw : guardring width.\n", "    \"\"\"\n\t    c = gf.Component()\n\t    dn_rect = gf.get_component(dn_rect)\n\t    comp_pp_enc: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    pcmpgr_enc_dn = 2.5\n\t    c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t    rect_pcmpgr_in = c_temp_gr.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_pcmpgr_in.move((dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn))\n\t    rect_pcmpgr_out = c_temp_gr.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n\t                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t    c.add_ref(\n", "        gf.geometry.boolean(\n\t            A=rect_pcmpgr_out,\n\t            B=rect_pcmpgr_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )  # guardring bulk\n\t    psdm_in = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n\t                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    psdm_in.move(\n\t        (\n\t            rect_pcmpgr_in.xmin + comp_pp_enc,\n\t            rect_pcmpgr_in.ymin + comp_pp_enc,\n", "        )\n\t    )\n\t    psdm_out = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n\t                (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n", "    )\n\t    psdm_out.move(\n\t        (\n\t            rect_pcmpgr_out.xmin - comp_pp_enc,\n\t            rect_pcmpgr_out.ymin - comp_pp_enc,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n", "        )\n\t    )  # pplus_draw\n\t    # generating contacts\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_pcmpgr_in.xmin + con_size,\n\t                rect_pcmpgr_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n", "            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # bottom contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_pcmpgr_in.xmin + con_size,\n", "                rect_pcmpgr_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # upper contact\n\t    c.add_ref(\n", "        via_generator(\n\t            x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t            y_range=(\n\t                rect_pcmpgr_in.ymin + con_size,\n\t                rect_pcmpgr_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n", "        )\n\t    )  # right contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t            y_range=(\n\t                rect_pcmpgr_in.ymin + con_size,\n\t                rect_pcmpgr_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n", "            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # left contact\n\t    comp_m1_in = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t            layer=layer[\"metal1\"],\n\t        )\n", "    )\n\t    comp_m1_out = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (comp_m1_in.size[0]) + 2 * grw,\n\t                (comp_m1_in.size[1]) + 2 * grw,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n", "    comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=rect_pcmpgr_out,\n\t            B=rect_pcmpgr_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )  # metal1 guardring\n\t    return c\n", "if __name__ == \"__main__\":\n\t    c = pcmpgr_gen()\n\t    c.show()\n"]}
{"filename": "gf180/__init__.py", "chunked_list": ["import sys\n\tfrom gdsfactory.get_factories import get_cells\n\tfrom gdsfactory.pdk import Pdk\n\tfrom gf180 import config, diode, fet, layers\n\tfrom gf180.cap_mim import (\n\t    cap_mim,\n\t)\n\tfrom gf180.cap_mos import (\n\t    cap_mos,\n\t    cap_mos_inst,\n", ")\n\tfrom gf180.config import PATH\n\tfrom gf180.diode import (\n\t    diode_dw2ps,\n\t    diode_nd2ps,\n\t    diode_nw2ps,\n\t    diode_pd2nw,\n\t    diode_pw2dw,\n\t    sc_diode,\n\t)\n", "from gf180.fet import (\n\t    add_gate_labels,\n\t    add_inter_sd_labels,\n\t    alter_interdig,\n\t    bulk_gr_gen,\n\t    get_patt_lbl,\n\t    hv_gen,\n\t    interdigit,\n\t    labels_gen,\n\t    nfet,\n", "    nfet_06v0_nvt,\n\t    nfet_deep_nwell,\n\t    pfet,\n\t    pfet_deep_nwell,\n\t)\n\tfrom gf180.guardring import (\n\t    pcmpgr_gen,\n\t)\n\tfrom gf180.layers import LAYER, LAYER_VIEWS, LayerMap, layer\n\tfrom gf180.res import (\n", "    nplus_res,\n\t    npolyf_res,\n\t    plus_res_inst,\n\t    polyf_res_inst,\n\t    pplus_res,\n\t    ppolyf_res,\n\t    ppolyf_u_high_Rs_res,\n\t    res,\n\t    well_res,\n\t)\n", "from gf180.via_generator import (\n\t    via_generator,\n\t    via_stack,\n\t)\n\t__all__ = [\n\t    \"LAYER\",\n\t    \"LayerMap\",\n\t    \"PATH\",\n\t    \"add_gate_labels\",\n\t    \"add_inter_sd_labels\",\n", "    \"alter_interdig\",\n\t    \"bulk_gr_gen\",\n\t    \"cap_mim\",\n\t    \"cap_mos\",\n\t    \"cap_mos_inst\",\n\t    \"config\",\n\t    \"diode\",\n\t    \"diode_dw2ps\",\n\t    \"diode_nd2ps\",\n\t    \"diode_nw2ps\",\n", "    \"diode_pd2nw\",\n\t    \"diode_pw2dw\",\n\t    \"cap_mos\",\n\t    \"nplus_res\",\n\t    \"npolyf_res\",\n\t    \"pplus_res\",\n\t    \"ppolyf_res\",\n\t    \"ppolyf_u_high_Rs_res\",\n\t    \"well_res\",\n\t    \"fet\",\n", "    \"get_patt_lbl\",\n\t    \"hv_gen\",\n\t    \"interdigit\",\n\t    \"labels_gen\",\n\t    \"layer\",\n\t    \"layers\",\n\t    \"nfet\",\n\t    \"nfet_06v0_nvt\",\n\t    \"nfet_deep_nwell\",\n\t    \"pcmpgr_gen\",\n", "    \"pfet\",\n\t    \"pfet_deep_nwell\",\n\t    \"plus_res_inst\",\n\t    \"polyf_res_inst\",\n\t    \"res\",\n\t    \"sc_diode\",\n\t    \"via_generator\",\n\t    \"via_stack\",\n\t]\n\t__version__ = \"0.0.3\"\n", "cells = get_cells(sys.modules[__name__])\n\tPDK = Pdk(\n\t    name=\"tj\",\n\t    cells=cells,\n\t    layers=LAYER.dict(),\n\t    layer_views=LAYER_VIEWS,\n\t    # layer_stack=LAYER_STACK,\n\t)\n\tPDK.activate()\n"]}
{"filename": "gf180/via_generator.py", "chunked_list": ["from math import ceil, floor\n\timport gdsfactory as gf\n\tfrom gdsfactory.typings import Float2, LayerSpec\n\tfrom gf180.layers import layer\n\t@gf.cell\n\tdef via_generator(\n\t    x_range: Float2 = (0, 1),\n\t    y_range: Float2 = (0, 1),\n\t    via_size: Float2 = (0.17, 0.17),\n\t    via_layer: LayerSpec = (66, 44),\n", "    via_enclosure: Float2 = (0.06, 0.06),\n\t    via_spacing: Float2 = (0.17, 0.17),\n\t) -> gf.Component:\n\t    \"\"\"\n\t    return only vias withen the range xrange and yrange while enclosing by via_enclosure\n\t    and set number of rows and number of coloumns according to ranges and via size and spacing\n\t    \"\"\"\n\t    c = gf.Component()\n\t    width = x_range[1] - x_range[0]\n\t    length = y_range[1] - y_range[0]\n", "    nr = floor(length / (via_size[1] + via_spacing[1]))\n\t    if (length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2 < via_enclosure[1]:\n\t        nr -= 1\n\t    if nr < 1:\n\t        nr = 1\n\t    nc = ceil(width / (via_size[0] + via_spacing[0]))\n\t    if (\n\t        round(width - nc * via_size[0] - (nc - 1) * via_spacing[0], 2)\n\t    ) / 2 < via_enclosure[0]:\n\t        nc -= 1\n", "    if nc < 1:\n\t        nc = 1\n\t    via_sp = (via_size[0] + via_spacing[0], via_size[1] + via_spacing[1])\n\t    rect_via = gf.components.rectangle(size=via_size, layer=via_layer)\n\t    via_arr = c.add_array(rect_via, rows=nr, columns=nc, spacing=via_sp)\n\t    via_arr.move((x_range[0], y_range[0]))\n\t    via_arr.movex((width - nc * via_size[0] - (nc - 1) * via_spacing[0]) / 2)\n\t    via_arr.movey((length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2)\n\t    return c\n\t@gf.cell\n", "def via_stack(\n\t    x_range: Float2 = (0, 1),\n\t    y_range: Float2 = (0, 1),\n\t    base_layer: LayerSpec = layer[\"comp\"],\n\t    slotted_licon: int = 0,\n\t    metal_level: int = 1,\n\t    li_enc_dir=\"V\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    return via stack till the metal level indicated where :\n", "    metal_level 1 : till m1\n\t    metal_level 2 : till m2\n\t    metal_level 3 : till m3\n\t    metal_level 4 : till m4\n\t    metal_level 5 : till m5\n\t    withen the range xrange and yrange and expecting the base_layer to be drawen\n\t    \"\"\"\n\t    c = gf.Component()\n\t    # vias dimensions\n\t    con_size = (0.22, 0.22)\n", "    con_enc = 0.07\n\t    m_enc = 0.06\n\t    con_spacing = (0.28, 0.28)\n\t    via_size = (0.22, 0.22)\n\t    via_spacing = (0.28, 0.28)\n\t    via_enc = (0.06, 0.06)\n\t    if metal_level >= 1:\n\t        con_gen = via_generator(\n\t            x_range=x_range,\n\t            y_range=y_range,\n", "            via_size=con_size,\n\t            via_enclosure=(con_enc, con_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_spacing=con_spacing,\n\t        )\n\t        con = c.add_ref(con_gen)\n\t        m1_x = con.size[0] + 2 * m_enc\n\t        m1_y = con.size[1] + 2 * m_enc\n\t        m1 = c.add_ref(\n\t            gf.components.rectangle(size=(m1_x, m1_y), layer=layer[\"metal1\"])\n", "        )\n\t        m1.xmin = con.xmin - m_enc\n\t        m1.ymin = con.ymin - m_enc\n\t    if metal_level >= 2:\n\t        via1_gen = via_generator(\n\t            x_range=(m1.xmin, m1.xmax),\n\t            y_range=(m1.ymin, m1.ymax),\n\t            via_size=via_size,\n\t            via_enclosure=via_enc,\n\t            via_layer=layer[\"via1\"],\n", "            via_spacing=via_spacing,\n\t        )\n\t        via1 = c.add_ref(via1_gen)\n\t        if (via1.xmax - via1.xmin + 2 * m_enc[0]) < (\n\t            via_size[0] + 2 * via_enc[0]\n\t        ) and metal_level >= 3:\n\t            m2_x = via_size[0] + 2 * via_enc[0]\n\t        else:\n\t            m2_x = via1.xmax - via1.xmin + 2 * m_enc[0]\n\t        if (via1.ymax - via1.ymin + 2 * m_enc[1]) < (\n", "            via_size[1] + 2 * via_enc[1]\n\t        ) and metal_level >= 3:\n\t            m2_y = via_size[1] + 2 * via_enc[1]\n\t        else:\n\t            m2_y = via1.ymax - via1.ymin + 2 * m_enc[1]\n\t        m2_mx = (m2_x - (via1.xmax - via1.xmin)) / 2\n\t        m2_my = (m2_y - (via1.ymax - via1.ymin)) / 2\n\t        m2 = c.add_ref(\n\t            gf.components.rectangle(size=(m2_x, m2_y), layer=layer[\"metal2\"])\n\t        )\n", "        m2.move((via1.xmin - m2_mx, via1.ymin - m2_my))\n\t    return c\n\tif __name__ == \"__main__\":\n\t    c = via_stack()\n\t    c.show()\n\t    # c = vias_gen_draw(start_layer=\"li\",end_layer=\"poly\")\n\t    # c.show()\n"]}
{"filename": "gf180/fet.py", "chunked_list": ["from math import ceil, floor\n\timport gdsfactory as gf\n\tfrom gdsfactory.typings import Float2, LayerSpec, Optional, Strs\n\tfrom gf180.guardring import pcmpgr_gen\n\tfrom gf180.layers import layer\n\tfrom gf180.via_generator import via_generator, via_stack\n\t@gf.cell\n\tdef labels_gen(\n\t    lbl_str: str = \"\",\n\t    position: Float2 = (0.1, 0.1),\n", "    layer: LayerSpec = layer[\"metal1_label\"],\n\t    lbl: bool = 0,\n\t    labels: Optional[Strs] = None,\n\t    lbl_valid_len: int = 1,\n\t    index: int = 0,\n\t) -> gf.Component:\n\t    \"\"\"Returns labels at given position when lbl is enabled\n\t    Args :\n\t        lbl_str : string of the label.\n\t        position : position of the label.\n", "        layer : layer of the label.\n\t        lbl : boolean of having the label.\n\t        labels : list of given labels.\n\t        lbl_valid_len : valid length of labels.\n\t    \"\"\"\n\t    c = gf.Component()\n\t    if lbl == 1:\n\t        if len(labels) == lbl_valid_len:\n\t            if lbl_str == \"None\":\n\t                c.add_label(labels[index], position=position, layer=layer)\n", "            else:\n\t                c.add_label(lbl_str, position=position, layer=layer)\n\t    return c\n\tdef get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o):\n\t    \"\"\"Returns list of odd,even gate label patterns for alternating gate connection\n\t    Args:\n\t        nl_b : number of bottom connected gates transistors.\n\t        nl : number of transistor.\n\t        nt : patterns of tansistor [with out redundency].\n\t        nt_e : number of transistor with even order.\n", "        g_lbl : list of transistors gate label.\n\t        nl_u :  number of upper connected gates transistors.\n\t        nt_o : number of transistor with odd order.\n\t    \"\"\"\n\t    g_lbl_e = []\n\t    g_lbl_o = []\n\t    if nt == len(g_lbl):\n\t        for i in range(nl_b):\n\t            for j in range(nl):\n\t                if nt[j] == nt_e[i]:\n", "                    g_lbl_e.append(g_lbl[j])\n\t        for i in range(nl_u):\n\t            for j in range(nl):\n\t                if nt[j] == nt_o[i]:\n\t                    g_lbl_o.append(g_lbl[j])\n\t    return [g_lbl_e, g_lbl_o]\n\t@gf.cell\n\tdef alter_interdig(\n\t    sd_diff,\n\t    pc1,\n", "    pc2,\n\t    poly_con,\n\t    sd_diff_intr,\n\t    l_gate=0.15,\n\t    inter_sd_l=0.15,\n\t    sd_l=0.36,\n\t    nf=1,\n\t    pat=\"\",\n\t    pc_x=0.1,\n\t    pc_spacing=0.1,\n", "    lbl: bool = 0,\n\t    g_lbl: list = [],\n\t    nl: int = 1,\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"Returns interdigitation polygons of gate with alterating poly contacts\n\t    Args :\n\t        sd_diff : source/drain diffusion rectangle.\n\t        pc1 : first poly contact array.\n\t        pc2 : second poly contact array.\n", "        poly_con : componenet of poly contact.\n\t        sd_diff_inter : inter source/drain diffusion rectangle.\n\t        l_gate : gate length.\n\t        inter_sd_l : inter diffusion length.\n\t        nf : number of fingers.\n\t        pat : string of the required pattern.\n\t    \"\"\"\n\t    c_inst = gf.Component()\n\t    m2_spacing = 0.28\n\t    via_size = (0.26, 0.26)\n", "    via_enc = (0.06, 0.06)\n\t    via_spacing = (0.26, 0.26)\n\t    pat_o = []\n\t    pat_e = []\n\t    for i in range(int(nf)):\n\t        if i % 2 == 0:\n\t            pat_e.append(pat[i])\n\t        else:\n\t            pat_o.append(pat[i])\n\t    nt = []\n", "    [nt.append(x) for x in pat if x not in nt]\n\t    nt_o = []\n\t    [nt_o.append(x) for x in pat_o if x not in nt_o]\n\t    nt_e = []\n\t    [nt_e.append(x) for x in pat_e if x not in nt_e]\n\t    nl = len(nt)\n\t    nl_b = len(nt_e)\n\t    nl_u = len(nt_o)\n\t    g_lbl_e, g_lbl_o = get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o)\n\t    m2_y = via_size[1] + 2 * via_enc[1]\n", "    m2 = gf.components.rectangle(\n\t        size=(sd_diff.xmax - sd_diff.xmin, m2_y),\n\t        layer=layer[\"metal2\"],\n\t    )\n\t    m2_arrb = c_inst.add_array(\n\t        component=m2,\n\t        columns=1,\n\t        rows=nl_b,\n\t        spacing=(0, -m2_y - m2_spacing),\n\t    )\n", "    m2_arrb.movey(pc1.ymin - m2_spacing - m2_y)\n\t    m2_arru = c_inst.add_array(\n\t        component=m2,\n\t        columns=1,\n\t        rows=nl_u,\n\t        spacing=(0, m2_y + m2_spacing),\n\t    )\n\t    m2_arru.movey(pc2.ymax + m2_spacing)\n\t    for i in range(nl_u):\n\t        for j in range(floor(nf / 2)):\n", "            if pat_o[j] == nt_o[i]:\n\t                m1 = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            pc_x,\n\t                            ((pc2.ymax + (i + 1) * (m2_spacing + m2_y)) - pc2.ymin),\n\t                        ),\n\t                        layer=layer[\"metal1\"],\n\t                    )\n\t                )\n", "                m1.xmin = pc2.xmin + j * (pc_spacing)\n\t                m1.ymin = pc2.ymin\n\t                via1_dr = via_generator(\n\t                    x_range=(m1.xmin, m1.xmax),\n\t                    y_range=(\n\t                        m2_arru.ymin + i * (m2_y + m2_spacing),\n\t                        m2_arru.ymin + i * (m2_y + m2_spacing) + m2_y,\n\t                    ),\n\t                    via_enclosure=via_enc,\n\t                    via_layer=layer[\"via1\"],\n", "                    via_size=via_size,\n\t                    via_spacing=via_spacing,\n\t                )\n\t                via1 = c_inst.add_ref(via1_dr)\n\t                c_inst.add_ref(\n\t                    labels_gen(\n\t                        lbl_str=\"None\",\n\t                        position=(\n\t                            (via1.xmax + via1.xmin) / 2,\n\t                            (via1.ymax + via1.ymin) / 2,\n", "                        ),\n\t                        layer=layer[\"metal2_label\"],\n\t                        lbl=patt_lbl,\n\t                        labels=pat_o,\n\t                        lbl_valid_len=len(pat_o),\n\t                        index=j,\n\t                    )\n\t                )\n\t                # adding gate_label\n\t                c_inst.add_ref(\n", "                    labels_gen(\n\t                        lbl_str=\"None\",\n\t                        position=(\n\t                            m1.xmin + (m1.size[0] / 2),\n\t                            pc2.ymin + (pc2.size[1] / 2),\n\t                        ),\n\t                        layer=layer[\"metal1_label\"],\n\t                        lbl=lbl,\n\t                        labels=g_lbl_o,\n\t                        lbl_valid_len=nl_u,\n", "                        index=i,\n\t                    )\n\t                )\n\t    for i in range(nl_b):\n\t        for j in range(ceil(nf / 2)):\n\t            if pat_e[j] == nt_e[i]:\n\t                m1 = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            # poly_con.xmax - poly_con.xmin,\n", "                            pc_x,\n\t                            ((pc1.ymax + (i + 1) * (m2_spacing + m2_y)) - pc1.ymin),\n\t                        ),\n\t                        layer=layer[\"metal1\"],\n\t                    )\n\t                )\n\t                m1.xmin = pc1.xmin + j * (pc_spacing)\n\t                m1.ymin = -(m1.ymax - m1.ymin) + (pc1.ymax)\n\t                via1_dr = via_generator(\n\t                    x_range=(m1.xmin, m1.xmax),\n", "                    y_range=(\n\t                        m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n\t                        m2_arrb.ymax - i * (m2_spacing + m2_y),\n\t                    ),\n\t                    via_enclosure=via_enc,\n\t                    via_layer=layer[\"via1\"],\n\t                    via_size=via_size,\n\t                    via_spacing=via_spacing,\n\t                )\n\t                via1 = c_inst.add_ref(via1_dr)\n", "                c_inst.add_ref(\n\t                    labels_gen(\n\t                        lbl_str=\"None\",\n\t                        position=(\n\t                            (via1.xmax + via1.xmin) / 2,\n\t                            (via1.ymax + via1.ymin) / 2,\n\t                        ),\n\t                        layer=layer[\"metal2_label\"],\n\t                        lbl=patt_lbl,\n\t                        labels=pat_e,\n", "                        lbl_valid_len=len(pat_e),\n\t                        index=j,\n\t                    )\n\t                )\n\t                # adding gate_label\n\t                c_inst.add_ref(\n\t                    labels_gen(\n\t                        lbl_str=\"None\",\n\t                        position=(\n\t                            m1.xmin + (m1.size[0] / 2),\n", "                            pc1.ymin + (pc1.size[1] / 2),\n\t                        ),\n\t                        layer=layer[\"metal1_label\"],\n\t                        lbl=lbl,\n\t                        labels=g_lbl_e,\n\t                        lbl_valid_len=nl_b,\n\t                        index=i,\n\t                    )\n\t                )\n\t    m3_x = via_size[0] + 2 * via_enc[0]\n", "    m3_spacing = m2_spacing\n\t    for i in range(nl_b):\n\t        for j in range(nl_u):\n\t            if nt_e[i] == nt_o[j]:\n\t                m2_join_b = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n\t                            m2_y,\n\t                        ),\n", "                        layer=layer[\"metal2\"],\n\t                    ).move(\n\t                        (\n\t                            m2_arrb.xmin\n\t                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n\t                            m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n\t                        )\n\t                    )\n\t                )\n\t                m2_join_u = c_inst.add_ref(\n", "                    gf.components.rectangle(\n\t                        size=(\n\t                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n\t                            m2_y,\n\t                        ),\n\t                        layer=layer[\"metal2\"],\n\t                    ).move(\n\t                        (\n\t                            m2_arru.xmin\n\t                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n", "                            m2_arru.ymin + j * (m2_spacing + m2_y),\n\t                        )\n\t                    )\n\t                )\n\t                m3 = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            m3_x,\n\t                            m2_join_u.ymax - m2_join_b.ymin,\n\t                        ),\n", "                        layer=layer[\"metal1\"],\n\t                    )\n\t                )\n\t                m3.move((m2_join_b.xmin, m2_join_b.ymin))\n\t                via2_dr = via_generator(\n\t                    x_range=(m3.xmin, m3.xmax),\n\t                    y_range=(m2_join_b.ymin, m2_join_b.ymax),\n\t                    via_enclosure=via_enc,\n\t                    via_size=via_size,\n\t                    via_layer=layer[\"via1\"],\n", "                    via_spacing=via_spacing,\n\t                )\n\t                c_inst.add_array(\n\t                    component=via2_dr,\n\t                    columns=1,\n\t                    rows=2,\n\t                    spacing=(\n\t                        0,\n\t                        m2_join_u.ymin - m2_join_b.ymin,\n\t                    ),\n", "                )  # via2_draw\n\t    return c_inst\n\t@gf.cell\n\tdef interdigit(\n\t    sd_diff,\n\t    pc1,\n\t    pc2,\n\t    poly_con,\n\t    sd_diff_intr,\n\t    l_gate: float = 0.15,\n", "    inter_sd_l: float = 0.23,\n\t    sd_l: float = 0.15,\n\t    nf=1,\n\t    patt=[\"\"],\n\t    gate_con_pos=\"top\",\n\t    pc_x=0.1,\n\t    pc_spacing=0.1,\n\t    lbl: bool = 0,\n\t    g_lbl: Optional[Strs] = [],\n\t    patt_lbl: bool = 0,\n", ") -> gf.Component:\n\t    \"\"\"Returns interdigitation related polygons\n\t    Args :\n\t        sd_diff : source/drain diffusion rectangle.\n\t        pc1 : first poly contact array.\n\t        pc2 : second poly contact array.\n\t        poly_con : componenet of poly contact.\n\t        sd_diff_inter : inter source/drain diffusion rectangle.\n\t        l_gate : gate length.\n\t        inter_sd_l : inter diffusion length.\n", "        nf : number of fingers.\n\t        pat : string of the required pattern.\n\t        gate_con_pos : position of gate contact.\n\t    \"\"\"\n\t    c_inst = gf.Component()\n\t    if nf == len(patt):\n\t        pat = list(patt)\n\t        nt = (\n\t            []\n\t        )  # list to store the symbols of transistors and thier number nt(number of transistors)\n", "        [nt.append(x) for x in pat if x not in nt]\n\t        nl = int(len(nt))\n\t        m2_spacing = 0.28\n\t        via_size = (0.26, 0.26)\n\t        via_enc = (0.06, 0.06)\n\t        via_spacing = (0.26, 0.26)\n\t        m2_y = via_size[1] + 2 * via_enc[1]\n\t        m2 = gf.components.rectangle(\n\t            size=(sd_diff.xmax - sd_diff.xmin, m2_y), layer=layer[\"metal2\"]\n\t        )\n", "        if gate_con_pos == \"alternating\":\n\t            c_inst.add_ref(\n\t                alter_interdig(\n\t                    sd_diff=sd_diff,\n\t                    pc1=pc1,\n\t                    pc2=pc2,\n\t                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n", "                    sd_l=sd_l,\n\t                    nf=nf,\n\t                    pat=pat,\n\t                    pc_x=pc_x,\n\t                    pc_spacing=pc_spacing,\n\t                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    nl=nl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n", "            )\n\t        elif gate_con_pos == \"top\":\n\t            m2_arr = c_inst.add_array(\n\t                component=m2,\n\t                columns=1,\n\t                rows=nl,\n\t                spacing=(0, m2.ymax - m2.ymin + m2_spacing),\n\t            )\n\t            m2_arr.movey(pc2.ymax + m2_spacing)\n\t            for i in range(nl):\n", "                for j in range(int(nf)):\n\t                    if pat[j] == nt[i]:\n\t                        m1 = c_inst.add_ref(\n\t                            gf.components.rectangle(\n\t                                size=(\n\t                                    pc_x,\n\t                                    # poly_con.xmax - poly_con.xmin,\n\t                                    (\n\t                                        (pc2.ymax + (i + 1) * (m2_spacing + m2_y))\n\t                                        - ((1 - j % 2) * pc1.ymin)\n", "                                        - (j % 2) * pc2.ymin\n\t                                    ),\n\t                                ),\n\t                                layer=layer[\"metal1\"],\n\t                            )\n\t                        )\n\t                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n\t                        m1.ymin = pc1.ymin\n\t                        via1_dr = via_generator(\n\t                            x_range=(m1.xmin, m1.xmax),\n", "                            y_range=(\n\t                                m2_arr.ymin + i * (m2_spacing + m2_y),\n\t                                m2_arr.ymin + i * (m2_spacing + m2_y) + m2_y,\n\t                            ),\n\t                            via_enclosure=via_enc,\n\t                            via_layer=layer[\"via1\"],\n\t                            via_size=via_size,\n\t                            via_spacing=via_spacing,\n\t                        )\n\t                        via1 = c_inst.add_ref(via1_dr)\n", "                        c_inst.add_ref(\n\t                            labels_gen(\n\t                                lbl_str=\"None\",\n\t                                position=(\n\t                                    (via1.xmax + via1.xmin) / 2,\n\t                                    (via1.ymax + via1.ymin) / 2,\n\t                                ),\n\t                                layer=layer[\"metal2_label\"],\n\t                                lbl=patt_lbl,\n\t                                labels=pat,\n", "                                lbl_valid_len=nl,\n\t                                index=j,\n\t                            )\n\t                        )\n\t                        # adding gate_label\n\t                        c_inst.add_ref(\n\t                            labels_gen(\n\t                                lbl_str=\"None\",\n\t                                position=(\n\t                                    m1.xmin + (m1.size[0] / 2),\n", "                                    pc1.ymin + (pc1.size[1] / 2),\n\t                                ),\n\t                                layer=layer[\"metal1_label\"],\n\t                                lbl=lbl,\n\t                                labels=g_lbl,\n\t                                lbl_valid_len=nl,\n\t                                index=i,\n\t                            )\n\t                        )\n\t        elif gate_con_pos == \"bottom\":\n", "            m2_arr = c_inst.add_array(\n\t                component=m2,\n\t                columns=1,\n\t                rows=nl,\n\t                spacing=(0, -m2_y - m2_spacing),\n\t            )\n\t            m2_arr.movey(pc2.ymin - m2_spacing - m2_y)\n\t            for i in range(nl):\n\t                for j in range(int(nf)):\n\t                    if pat[j] == nt[i]:\n", "                        m1 = c_inst.add_ref(\n\t                            gf.components.rectangle(\n\t                                size=(\n\t                                    # poly_con.xmax - poly_con.xmin,\n\t                                    pc_x,\n\t                                    (\n\t                                        (pc1.ymax + (i + 1) * (m2_spacing + m2_y))\n\t                                        - (j % 2) * pc1.ymin\n\t                                        - (1 - j % 2) * pc2.ymin\n\t                                    ),\n", "                                ),\n\t                                layer=layer[\"metal1\"],\n\t                            )\n\t                        )\n\t                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n\t                        m1.ymax = pc1.ymax\n\t                        via1_dr = via_generator(\n\t                            x_range=(m1.xmin, m1.xmax),\n\t                            y_range=(\n\t                                m2_arr.ymax - i * (m2_spacing + m2_y) - m2_y,\n", "                                m2_arr.ymax - i * (m2_spacing + m2_y),\n\t                            ),\n\t                            via_enclosure=via_enc,\n\t                            via_layer=layer[\"via1\"],\n\t                            via_size=via_size,\n\t                            via_spacing=via_spacing,\n\t                        )\n\t                        via1 = c_inst.add_ref(via1_dr)\n\t                        c_inst.add_ref(\n\t                            labels_gen(\n", "                                lbl_str=\"None\",\n\t                                position=(\n\t                                    (via1.xmax + via1.xmin) / 2,\n\t                                    (via1.ymax + via1.ymin) / 2,\n\t                                ),\n\t                                layer=layer[\"metal2_label\"],\n\t                                lbl=patt_lbl,\n\t                                labels=pat,\n\t                                lbl_valid_len=nl,\n\t                                index=j,\n", "                            )\n\t                        )\n\t                        # adding gate_label\n\t                        c_inst.add_ref(\n\t                            labels_gen(\n\t                                lbl_str=\"None\",\n\t                                position=(\n\t                                    m1.xmin + (m1.size[0] / 2),\n\t                                    pc1.ymin + (pc1.size[1] / 2),\n\t                                ),\n", "                                layer=layer[\"metal1_label\"],\n\t                                lbl=lbl,\n\t                                labels=g_lbl,\n\t                                lbl_valid_len=nl,\n\t                                index=i,\n\t                            )\n\t                        )\n\t    return c_inst\n\t# @gf.cell\n\tdef hv_gen(c, c_inst, volt, dg_encx: float = 0.1, dg_ency: float = 0.1):\n", "    \"\"\"Returns high volatge related polygons\n\t    Args :\n\t        c_inst : dualgate enclosed componenet\n\t        volt : operating voltage\n\t        dg_encx : dualgate enclosure in x_direction\n\t        dg_ency : dualgate enclosure in y_direction\n\t    \"\"\"\n\t    # c = gf.Component()\n\t    if volt == \"5V\" or volt == \"6V\":\n\t        dg = c.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    c_inst.size[0] + (2 * dg_encx),\n\t                    c_inst.size[1] + (2 * dg_ency),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = c_inst.xmin - dg_encx\n\t        dg.ymin = c_inst.ymin - dg_ency\n", "        if volt == \"5V\":\n\t            v5x = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n\t                )\n\t            )\n\t            v5x.xmin = dg.xmin\n\t            v5x.ymin = dg.ymin\n\t    # return c\n\tdef bulk_gr_gen(\n", "    c,\n\t    c_inst,\n\t    comp_spacing: float = 0.1,\n\t    poly2_comp_spacing: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    grw: float = 0.36,\n\t    l_d: float = 0.1,\n\t    implant_layer: LayerSpec = layer[\"pplus\"],\n\t    lbl: bool = 0,\n\t    sub_lbl: str = \"\",\n", "    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    nw_enc_pcmp: float = 0.1,\n\t):\n\t    \"\"\"Returns guardring\n\t    Args :\n\t        c_inst : componenet enclosed by guardring\n\t        comp_spacing : spacing between comp polygons\n\t        poly2_comp_spacing : spacing between comp and poly2 polygons\n\t        volt : operating voltage\n", "        grw : guardring width\n\t        l_d : total diffusion length\n\t        implant_layer : layer of comp implant (nplus,pplus)\n\t    \"\"\"\n\t    # c = gf.Component()\n\t    comp_pp_enc: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    dg_enc_cmp = 0.24\n", "    c_temp = gf.Component(\"temp_store\")\n\t    rect_bulk_in = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (c_inst.xmax - c_inst.xmin) + 2 * comp_spacing,\n\t                (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n", "    rect_bulk_in.move((c_inst.xmin - comp_spacing, c_inst.ymin - poly2_comp_spacing))\n\t    rect_bulk_out = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n", "    rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n\t    B = c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=rect_bulk_out,\n\t            B=rect_bulk_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    psdm_in = c_temp.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n\t                (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n\t    psdm_out = c_temp.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n\t                (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    psdm_out.move(\n\t        (\n", "            rect_bulk_out.xmin - comp_pp_enc,\n\t            rect_bulk_out.ymin - comp_pp_enc,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        gf.geometry.boolean(A=psdm_out, B=psdm_in, operation=\"A-B\", layer=implant_layer)\n\t    )  # implant_draw(pplus or nplus)\n\t    # generating contacts\n\t    c.add_ref(\n\t        via_generator(\n", "            x_range=(\n\t                rect_bulk_in.xmin + con_size,\n\t                rect_bulk_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n", "    )  # bottom contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_bulk_in.xmin + con_size,\n\t                rect_bulk_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n", "            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # upper contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n\t            y_range=(\n\t                rect_bulk_in.ymin + con_size,\n\t                rect_bulk_in.ymax - con_size,\n", "            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # right contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n", "            y_range=(\n\t                rect_bulk_in.ymin + con_size,\n\t                rect_bulk_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # left contact\n", "    comp_m1_in = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (l_d) + 2 * comp_spacing,\n\t                (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n\t    comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n", "    comp_m1_out = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n\t    comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n", "    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=rect_bulk_out,\n\t            B=rect_bulk_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )  # metal1_gaurdring\n\t    # c.add_ref(hv_gen(c_inst=B, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_cmp))\n\t    hv_gen(c, c_inst=B, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_cmp)\n", "    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=sub_lbl,\n\t            position=(\n\t                B.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n\t                B.ymin + (B.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            labels=[sub_lbl],\n", "            lbl_valid_len=1,\n\t        )\n\t    )\n\t    if implant_layer == layer[\"pplus\"]:\n\t        c.add_ref(\n\t            nfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                inst_size=(B.size[0], B.size[1]),\n\t                inst_xmin=B.xmin,\n", "                inst_ymin=B.ymin,\n\t                grw=grw,\n\t            )\n\t        )\n\t    else:\n\t        c.add_ref(\n\t            pfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                enc_size=(B.size[0], B.size[1]),\n", "                enc_xmin=B.xmin,\n\t                enc_ymin=B.ymin,\n\t                nw_enc_pcmp=nw_enc_pcmp,\n\t                grw=grw,\n\t            )\n\t        )\n\t    # return c\n\t@gf.cell\n\tdef nfet_deep_nwell(\n\t    deepnwell: bool = 0,\n", "    pcmpgr: bool = 0,\n\t    inst_size: Float2 = (0.1, 0.1),\n\t    inst_xmin: float = 0.1,\n\t    inst_ymin: float = 0.1,\n\t    grw: float = 0.36,\n\t) -> gf.Component:\n\t    \"\"\"Return nfet deepnwell\n\t    Args :\n\t        deepnwell : boolean of having deepnwell\n\t        pcmpgr : boolean of having deepnwell guardring\n", "        inst_size : deepnwell enclosed size\n\t        inst_xmin : deepnwell enclosed xmin\n\t        inst_ymin : deepnwell enclosed ymin\n\t        grw : guardring width\n\t    \"\"\"\n\t    c = gf.Component()\n\t    dn_enc_lvpwell = 2.5\n\t    lvpwell_enc_ncmp = 0.43\n\t    if deepnwell == 1:\n\t        lvp_rect = c.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    inst_size[0] + (2 * lvpwell_enc_ncmp),\n\t                    inst_size[1] + (2 * lvpwell_enc_ncmp),\n\t                ),\n\t                layer=layer[\"lvpwell\"],\n\t            )\n\t        )\n\t        lvp_rect.xmin = inst_xmin - lvpwell_enc_ncmp\n\t        lvp_rect.ymin = inst_ymin - lvpwell_enc_ncmp\n", "        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n\t                    lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n", "        dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\t    return c\n\tdef add_inter_sd_labels(\n\t    c, nf, sd_lbl, poly1, l_gate, inter_sd_l, sd_diff_intr, lbl, layer, con_bet_fin\n\t):\n\t    \"\"\"Adds label to intermediate source/drain diffusion\n\t    Args :\n\t        c : instance componenet of the device\n", "        nf : number of fingers\n\t        sd_lbl : required source and drain labels list\n\t        poly1 : componenet of poly array\n\t        l_gate : length of fet gate\n\t        inter_sd_l : length of intermediate source/drain diffusion\n\t        sd_diff_inter : componenet of intermediate source/drain polygon\n\t        lbl: boolean of having labels\n\t        layer : layer of label\n\t        con_bet_fin : boolean of having contact between fingers\n\t    \"\"\"\n", "    if con_bet_fin == 1:\n\t        lbl_layer = layer[\"metal1_label\"]\n\t    else:\n\t        lbl_layer = layer[\"comp_label\"]\n\t    for i in range(int(nf - 1)):\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(\n\t                    poly1.xmin + l_gate + (inter_sd_l / 2) + i * (l_gate + inter_sd_l),\n", "                    sd_diff_intr.ymin + (sd_diff_intr.size[1] / 2),\n\t                ),\n\t                layer=lbl_layer,\n\t                lbl=lbl,\n\t                labels=sd_lbl,\n\t                lbl_valid_len=nf + 1,\n\t                index=i + 1,\n\t            )\n\t        )\n\tdef add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf):\n", "    \"\"\"Adds gate label when lbl is enabled\n\t    Args :\n\t        c : instance componenet of the device\n\t        g_lbl : required gate labels list\n\t        pc1 : componenet of poly array1\n\t        c_pc : componenet of poly array element\n\t        pc_spacing : float of space between labels\n\t        nc1 : number of columns in poly array1\n\t        nc2 : number of columns in poly array2\n\t        pc2 : componenet of poly array2\n", "        lbl : boolean of having labels\n\t        layer : layer of labels\n\t        nf : number of fingers\n\t    \"\"\"\n\t    for i in range(nc1):\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(\n\t                    pc1.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n", "                    pc1.ymin + (c_pc.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                labels=g_lbl,\n\t                lbl_valid_len=nf,\n\t                index=2 * i,\n\t            )\n\t        )\n\t    for i in range(nc2):\n", "        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(\n\t                    pc2.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n\t                    pc2.ymin + (c_pc.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                labels=g_lbl,\n", "                lbl_valid_len=nf,\n\t                index=(2 * i) + 1,\n\t            )\n\t        )\n\t@gf.cell\n\tdef nfet(\n\t    l_gate: float = 0.28,\n\t    w_gate: float = 0.22,\n\t    sd_con_col: int = 1,\n\t    inter_sd_l: float = 0.24,\n", "    nf: int = 1,\n\t    grw: float = 0.22,\n\t    volt: str = \"3.3V\",\n\t    bulk=\"None\",\n\t    con_bet_fin: int = 1,\n\t    gate_con_pos=\"alternating\",\n\t    interdig: int = 0,\n\t    patt=\"\",\n\t    deepnwell: int = 0,\n\t    pcmpgr: int = 0,\n", "    lbl: bool = 0,\n\t    sd_lbl: Optional[Strs] = [],\n\t    g_lbl: str = [],\n\t    sub_lbl: str = \"\",\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Return nfet\n\t    Args:\n\t        l : Float of gate length\n", "        w : Float of gate width\n\t        sd_l : Float of source and drain diffusion length\n\t        inter_sd_l : Float of source and drain diffusion length between fingers\n\t        nf : integer of number of fingers\n\t        M : integer of number of multipliers\n\t        grw : gaurd ring width when enabled\n\t        type : string of the device type\n\t        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n\t        con_bet_fin : boolean of having contacts for diffusion between fingers\n\t        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n", "    \"\"\"\n\t    # used layers and dimensions\n\t    end_cap: float = 0.22\n\t    if volt == \"3.3V\":\n\t        comp_spacing: float = 0.28\n\t    else:\n\t        comp_spacing: float = 0.36\n\t    gate_np_enc: float = 0.23\n\t    comp_np_enc: float = 0.16\n\t    comp_pp_enc: float = 0.16\n", "    poly2_spacing: float = 0.24\n\t    pc_ext: float = 0.04\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    con_pl_enc = 0.07\n\t    dg_enc_cmp = 0.24\n\t    dg_enc_poly = 0.4\n\t    sd_l_con = (\n\t        ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n", "    )\n\t    sd_l = sd_l_con\n\t    # gds components to store a single instance and the generated device\n\t    c = gf.Component(\"sky_nfet_dev\")\n\t    c_inst = gf.Component(\"dev_temp\")\n\t    # generating sd diffusion\n\t    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n\t        nf = len(patt)\n\t    l_d = (\n\t        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc)\n", "    )  # diffution total length\n\t    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n\t    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\t    #     # generatin sd contacts\n\t    if w_gate <= con_size + 2 * con_comp_enc:\n\t        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\t    else:\n\t        cmpc_y = w_gate\n\t    cmpc_size = (sd_l_con, cmpc_y)\n\t    sd_diff = c_inst.add_array(\n", "        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n\t    )\n\t    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n\t    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\t    sd_con = via_stack(\n\t        x_range=(sd_diff.xmin, sd_diff_intr.xmin),\n\t        y_range=(sd_diff.ymin, sd_diff.ymax),\n", "        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n\t    )\n\t    c_inst.add_array(\n\t        component=sd_con,\n\t        columns=2,\n\t        rows=1,\n\t        spacing=(\n\t            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc),\n\t            0,\n", "        ),\n\t    )\n\t    if con_bet_fin == 1 and nf > 1:\n\t        inter_sd_con = via_stack(\n\t            x_range=(\n\t                sd_diff_intr.xmin + con_comp_enc + l_gate,\n\t                sd_diff_intr.xmin + con_comp_enc + l_gate + inter_sd_l,\n\t            ),\n\t            y_range=(0, w_gate),\n\t            base_layer=layer[\"comp\"],\n", "            metal_level=1,\n\t        )\n\t        c_inst.add_array(\n\t            component=inter_sd_con,\n\t            columns=nf - 1,\n\t            rows=1,\n\t            spacing=(l_gate + inter_sd_l, 0),\n\t        )\n\t    ### adding source/drain labels\n\t    c.add_ref(\n", "        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            labels=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=0,\n\t        )\n\t    )\n", "    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            labels=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=nf,\n\t        )\n", "    )\n\t    # generating poly\n\t    if l_gate <= con_size + 2 * con_pl_enc:\n\t        pc_x = con_pl_enc + con_size + con_pl_enc\n\t    else:\n\t        pc_x = l_gate\n\t    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\t    c_pc = gf.Component(\"poly con\")\n\t    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\t    poly_con = via_stack(\n", "        x_range=(rect_pc.xmin, rect_pc.xmax),\n\t        y_range=(rect_pc.ymin, rect_pc.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t        li_enc_dir=\"H\",\n\t    )\n\t    c_pc.add_ref(poly_con)\n\t    if nf == 1:\n\t        poly = c_inst.add_ref(\n\t            gf.components.rectangle(\n", "                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n\t            )\n\t        )\n\t        poly.xmin = sd_diff_intr.xmin + con_comp_enc\n\t        poly.ymin = sd_diff_intr.ymin - end_cap\n\t        if gate_con_pos == \"bottom\":\n\t            mv = 0\n\t            nr = 1\n\t        elif gate_con_pos == \"top\":\n\t            mv = pc_size[1] + w_gate + 2 * end_cap\n", "            nr = 1\n\t        else:\n\t            mv = 0\n\t            nr = 2\n\t        pc = c_inst.add_array(\n\t            component=c_pc,\n\t            rows=nr,\n\t            columns=1,\n\t            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n\t        )\n", "        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\t        # gate_lablel\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                labels=g_lbl,\n\t                lbl_valid_len=nf,\n", "                index=0,\n\t            )\n\t        )\n\t    else:\n\t        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\t        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n\t            if gate_con_pos == \"alternating\":\n\t                w_p1 += 0.2\n\t                w_p2 = w_p1\n\t                e_c = 0.2\n", "            else:\n\t                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n\t                e_c = 0\n\t            if gate_con_pos == \"bottom\":\n\t                p_mv = -end_cap - (w_p2 - w_p1)\n\t            else:\n\t                p_mv = -end_cap\n\t        else:\n\t            w_p2 = w_p1\n\t            p_mv = -end_cap\n", "            e_c = 0\n\t        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n\t        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n\t        poly1 = c_inst.add_array(\n\t            rect_p1,\n\t            rows=1,\n\t            columns=ceil(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly1.xmin = sd_diff_intr.xmin + con_comp_enc\n", "        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\t        poly2 = c_inst.add_array(\n\t            rect_p2,\n\t            rows=1,\n\t            columns=floor(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n\t        poly2.ymin = p_mv\n\t        # generating poly contacts setups\n", "        if gate_con_pos == \"bottom\":\n\t            mv_1 = 0\n\t            mv_2 = -(w_p2 - w_p1)\n\t        elif gate_con_pos == \"top\":\n\t            mv_1 = pc_size[1] + w_p1\n\t            mv_2 = pc_size[1] + w_p2\n\t        else:\n\t            mv_1 = -e_c\n\t            mv_2 = pc_size[1] + w_p2\n\t        nc1 = ceil(nf / 2)\n", "        nc2 = floor(nf / 2)\n\t        pc_spacing = 2 * (inter_sd_l + l_gate)\n\t        # generating poly contacts\n\t        pc1 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n\t        )\n\t        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\t        pc2 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n\t        )\n", "        pc2.move(\n\t            (\n\t                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n\t                -pc_size[1] - end_cap + mv_2,\n\t            )\n\t        )\n\t        add_inter_sd_labels(\n\t            c,\n\t            nf,\n\t            sd_lbl,\n", "            poly1,\n\t            l_gate,\n\t            inter_sd_l,\n\t            sd_diff_intr,\n\t            lbl,\n\t            layer,\n\t            con_bet_fin,\n\t        )\n\t        # add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\t        if interdig == 1:\n", "            c_inst.add_ref(\n\t                interdigit(\n\t                    sd_diff=sd_diff,\n\t                    pc1=pc1,\n\t                    pc2=pc2,\n\t                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n\t                    sd_l=sd_l,\n", "                    nf=nf,\n\t                    patt=patt,\n\t                    gate_con_pos=gate_con_pos,\n\t                    pc_x=pc_x,\n\t                    pc_spacing=pc_spacing,\n\t                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n\t            )\n", "        else:\n\t            add_gate_labels(\n\t                c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf\n\t            )\n\t    # generating bulk\n\t    if bulk == \"None\":\n\t        nplus = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n\t                layer=layer[\"nplus\"],\n", "            )\n\t        )\n\t        nplus.xmin = sd_diff.xmin - comp_np_enc\n\t        nplus.ymin = sd_diff_intr.ymin - gate_np_enc\n\t    elif bulk == \"Bulk Tie\":\n\t        rect_bulk = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n\t            )\n\t        )\n", "        rect_bulk.xmin = sd_diff.xmax\n\t        rect_bulk.ymin = sd_diff.ymin\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n\t                    w_gate + 2 * gate_np_enc,\n\t                ),\n\t                layer=layer[\"nplus\"],\n\t            )\n", "        )\n\t        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n\t                    w_gate + 2 * comp_pp_enc,\n\t                ),\n\t                layer=layer[\"pplus\"],\n", "            )\n\t        )\n\t        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\t        bulk_con = via_stack(\n\t            x_range=(rect_bulk.xmin + 0.1, rect_bulk.xmax - 0.1),\n\t            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t        c_inst.add_ref(bulk_con)\n", "        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=sub_lbl,\n\t                position=(\n\t                    bulk_con.xmin + bulk_con.size[0] / 2,\n\t                    bulk_con.ymin + bulk_con.size[1] / 2,\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                labels=[sub_lbl],\n", "                lbl_valid_len=1,\n\t            )\n\t        )\n\t    if bulk == \"Guard Ring\":\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n\t                layer=layer[\"nplus\"],\n\t            )\n\t        )\n", "        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n\t        c.add_ref(c_inst)\n\t        # b_gr = c.add_ref(\n\t        bulk_gr_gen(\n\t            c,\n\t            c_inst=c_inst,\n\t            comp_spacing=comp_spacing,\n\t            poly2_comp_spacing=comp_spacing,\n\t            volt=volt,\n", "            grw=grw,\n\t            l_d=l_d,\n\t            implant_layer=layer[\"pplus\"],\n\t            lbl=lbl,\n\t            sub_lbl=sub_lbl,\n\t            deepnwell=deepnwell,\n\t            pcmpgr=pcmpgr,\n\t        )\n\t    # if bulk != \"Guard Ring\":\n\t    else:\n", "        c.add_ref(c_inst)\n\t        inst_size = (c_inst.size[0], c_inst.size[1])\n\t        inst_xmin = c_inst.xmin\n\t        inst_ymin = c_inst.ymin\n\t        # c.add_ref(\n\t        #     hv_gen(c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\t        # )\n\t        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\t        c.add_ref(\n\t            nfet_deep_nwell(\n", "                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                inst_size=inst_size,\n\t                inst_xmin=inst_xmin,\n\t                inst_ymin=inst_ymin,\n\t                grw=grw,\n\t            )\n\t        )\n\t    return c\n\t@gf.cell\n", "def pfet_deep_nwell(\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    enc_size: Float2 = (0.1, 0.1),\n\t    enc_xmin: float = 0.1,\n\t    enc_ymin: float = 0.1,\n\t    nw_enc_pcmp: float = 0.1,\n\t    grw: float = 0.36,\n\t) -> gf.Component:\n\t    \"\"\"Returns pfet well related polygons\n", "    Args :\n\t        deepnwell : boolaen of having deepnwell\n\t        pcmpgr : boolean of having deepnwell guardring\n\t        enc_size : enclosed size\n\t        enc_xmin : enclosed xmin\n\t        enc_ymin : enclosed ymin\n\t        nw_enc_pcmp : nwell enclosure of pcomp\n\t        grw : guardring width\n\t    \"\"\"\n\t    c = gf.Component()\n", "    dnwell_enc_pcmp = 1.1\n\t    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    enc_size[0] + (2 * dnwell_enc_pcmp),\n\t                    enc_size[1] + (2 * dnwell_enc_pcmp),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n", "        )\n\t        dn_rect.xmin = enc_xmin - dnwell_enc_pcmp\n\t        dn_rect.ymin = enc_ymin - dnwell_enc_pcmp\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\t    else:\n\t        # nwell generation\n\t        nw = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    enc_size[0] + (2 * nw_enc_pcmp),\n\t                    enc_size[1] + (2 * nw_enc_pcmp),\n\t                ),\n\t                layer=layer[\"nwell\"],\n\t            )\n\t        )\n\t        nw.xmin = enc_xmin - nw_enc_pcmp\n\t        nw.ymin = enc_ymin - nw_enc_pcmp\n\t    return c\n\t# @gf.cell\n", "def pfet(\n\t    l_gate: float = 0.28,\n\t    w_gate: float = 0.22,\n\t    sd_con_col: int = 1,\n\t    inter_sd_l: float = 0.24,\n\t    nf: int = 1,\n\t    grw: float = 0.22,\n\t    volt: str = \"3.3V\",\n\t    bulk=\"None\",\n\t    con_bet_fin: int = 1,\n", "    gate_con_pos=\"alternating\",\n\t    interdig: int = 0,\n\t    patt=\"\",\n\t    deepnwell: int = 0,\n\t    pcmpgr: int = 0,\n\t    lbl: bool = 0,\n\t    sd_lbl: Optional[Strs] = [],\n\t    g_lbl: str = [],\n\t    sub_lbl: str = \"\",\n\t    patt_lbl: bool = 0,\n", ") -> gf.Component:\n\t    \"\"\"\n\t    Return pfet\n\t    Args:\n\t        l : Float of gate length\n\t        w : Float of gate width\n\t        sd_l : Float of source and drain diffusion length\n\t        inter_sd_l : Float of source and drain diffusion length between fingers\n\t        nf : integer of number of fingers\n\t        M : integer of number of multipliers\n", "        grw : gaurd ring width when enabled\n\t        type : string of the device type\n\t        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n\t        con_bet_fin : boolean of having contacts for diffusion between fingers\n\t        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n\t    \"\"\"\n\t    # used layers and dimensions\n\t    end_cap: float = 0.22\n\t    if volt == \"3.3V\":\n\t        comp_spacing: float = 0.28\n", "        nw_enc_pcmp = 0.43\n\t    else:\n\t        comp_spacing: float = 0.36\n\t        nw_enc_pcmp = 0.6\n\t    gate_pp_enc: float = 0.23\n\t    comp_np_enc: float = 0.16\n\t    comp_pp_enc: float = 0.16\n\t    poly2_spacing: float = 0.24\n\t    pc_ext: float = 0.04\n\t    con_size = 0.22\n", "    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    con_pl_enc = 0.07\n\t    dg_enc_cmp = 0.24\n\t    dg_enc_poly = 0.4\n\t    sd_l_con = (\n\t        ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n\t    )\n\t    sd_l = sd_l_con\n\t    # gds components to store a single instance and the generated device\n", "    c = gf.Component(\"sky_pfet_dev\")\n\t    c_inst = gf.Component(\"dev_temp\")\n\t    # generating sd diffusion\n\t    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n\t        nf = len(patt)\n\t    l_d = (\n\t        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc)\n\t    )  # diffution total length\n\t    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n\t    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n", "    # generatin sd contacts\n\t    if w_gate <= con_size + 2 * con_comp_enc:\n\t        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\t    else:\n\t        cmpc_y = w_gate\n\t    cmpc_size = (sd_l_con, cmpc_y)\n\t    sd_diff = c_inst.add_array(\n\t        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n\t        rows=1,\n\t        columns=2,\n", "        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n\t    )\n\t    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n\t    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\t    sd_con = via_stack(\n\t        x_range=(sd_diff.xmin, sd_diff_intr.xmin),\n\t        y_range=(sd_diff.ymin, sd_diff.ymax),\n\t        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n\t    )\n", "    c_inst.add_array(\n\t        component=sd_con,\n\t        columns=2,\n\t        rows=1,\n\t        spacing=(\n\t            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc),\n\t            0,\n\t        ),\n\t    )\n\t    if con_bet_fin == 1 and nf > 1:\n", "        inter_sd_con = via_stack(\n\t            x_range=(\n\t                sd_diff_intr.xmin + con_comp_enc + l_gate,\n\t                sd_diff_intr.xmin + con_comp_enc + l_gate + inter_sd_l,\n\t            ),\n\t            y_range=(0, w_gate),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t        c_inst.add_array(\n", "            component=inter_sd_con,\n\t            columns=nf - 1,\n\t            rows=1,\n\t            spacing=(l_gate + inter_sd_l, 0),\n\t        )\n\t    ### adding source/drain labels\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n", "            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            labels=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=0,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n", "            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            labels=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=nf,\n\t        )\n\t    )\n\t    # generating poly\n\t    if l_gate <= con_size + 2 * con_pl_enc:\n", "        pc_x = con_pl_enc + con_size + con_pl_enc\n\t    else:\n\t        pc_x = l_gate\n\t    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\t    c_pc = gf.Component(\"poly con\")\n\t    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\t    poly_con = via_stack(\n\t        x_range=(rect_pc.xmin, rect_pc.xmax),\n\t        y_range=(rect_pc.ymin, rect_pc.ymax),\n\t        base_layer=layer[\"poly2\"],\n", "        metal_level=1,\n\t        li_enc_dir=\"H\",\n\t    )\n\t    c_pc.add_ref(poly_con)\n\t    if nf == 1:\n\t        poly = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n\t            )\n\t        )\n", "        poly.xmin = sd_diff_intr.xmin + con_comp_enc\n\t        poly.ymin = sd_diff_intr.ymin - end_cap\n\t        if gate_con_pos == \"bottom\":\n\t            mv = 0\n\t            nr = 1\n\t        elif gate_con_pos == \"top\":\n\t            mv = pc_size[1] + w_gate + 2 * end_cap\n\t            nr = 1\n\t        else:\n\t            mv = 0\n", "            nr = 2\n\t        pc = c_inst.add_array(\n\t            component=c_pc,\n\t            rows=nr,\n\t            columns=1,\n\t            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n\t        )\n\t        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\t        # gate_lablel\n\t        c.add_ref(\n", "            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                labels=g_lbl,\n\t                lbl_valid_len=nf,\n\t                index=0,\n\t            )\n\t        )\n", "    else:\n\t        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\t        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n\t            if gate_con_pos == \"alternating\":\n\t                w_p1 += 0.2\n\t                w_p2 = w_p1\n\t                e_c = 0.2\n\t            else:\n\t                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n\t                e_c = 0\n", "            if gate_con_pos == \"bottom\":\n\t                p_mv = -end_cap - (w_p2 - w_p1)\n\t            else:\n\t                p_mv = -end_cap\n\t        else:\n\t            w_p2 = w_p1\n\t            p_mv = -end_cap\n\t            e_c = 0\n\t        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n\t        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n", "        poly1 = c_inst.add_array(\n\t            rect_p1,\n\t            rows=1,\n\t            columns=ceil(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly1.xmin = sd_diff_intr.xmin + con_comp_enc\n\t        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\t        poly2 = c_inst.add_array(\n\t            rect_p2,\n", "            rows=1,\n\t            columns=floor(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n\t        poly2.ymin = p_mv\n\t        # generating poly contacts setups\n\t        if gate_con_pos == \"bottom\":\n\t            mv_1 = 0\n\t            mv_2 = -(w_p2 - w_p1)\n", "        elif gate_con_pos == \"top\":\n\t            mv_1 = pc_size[1] + w_p1\n\t            mv_2 = pc_size[1] + w_p2\n\t        else:\n\t            mv_1 = -e_c\n\t            mv_2 = pc_size[1] + w_p2\n\t        nc1 = ceil(nf / 2)\n\t        nc2 = floor(nf / 2)\n\t        pc_spacing = 2 * (inter_sd_l + l_gate)\n\t        # generating poly contacts\n", "        pc1 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n\t        )\n\t        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\t        pc2 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n\t        )\n\t        pc2.move(\n\t            (\n\t                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n", "                -pc_size[1] - end_cap + mv_2,\n\t            )\n\t        )\n\t        add_inter_sd_labels(\n\t            c,\n\t            nf,\n\t            sd_lbl,\n\t            poly1,\n\t            l_gate,\n\t            inter_sd_l,\n", "            sd_diff_intr,\n\t            lbl,\n\t            layer,\n\t            con_bet_fin,\n\t        )\n\t        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\t        if interdig == 1:\n\t            c_inst.add_ref(\n\t                interdigit(\n\t                    sd_diff=sd_diff,\n", "                    pc1=pc1,\n\t                    pc2=pc2,\n\t                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n\t                    sd_l=sd_l,\n\t                    nf=nf,\n\t                    patt=patt,\n\t                    gate_con_pos=gate_con_pos,\n", "                    pc_x=pc_x,\n\t                    pc_spacing=pc_spacing,\n\t                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n\t            )\n\t    # generating bulk\n\t    if bulk == \"None\":\n\t        pplus = c_inst.add_ref(\n", "            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_pp_enc, w_gate + 2 * gate_pp_enc),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        pplus.xmin = sd_diff.xmin - comp_pp_enc\n\t        pplus.ymin = sd_diff_intr.ymin - gate_pp_enc\n\t        c.add_ref(c_inst)\n\t        # deep nwell and nwell generation\n\t        c.add_ref(\n", "            pfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                enc_size=(sd_diff.size[0], sd_diff.size[1]),\n\t                enc_xmin=sd_diff.xmin,\n\t                enc_ymin=sd_diff.ymin,\n\t                nw_enc_pcmp=nw_enc_pcmp,\n\t                grw=grw,\n\t            )\n\t        )\n", "        # dualgate generation\n\t        # c.add_ref(\n\t        #     hv_gen(c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\t        # )\n\t        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\t    elif bulk == \"Bulk Tie\":\n\t        rect_bulk = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n\t            )\n", "        )\n\t        rect_bulk.xmin = sd_diff.xmax\n\t        rect_bulk.ymin = sd_diff.ymin\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.xmax - sd_diff.xmin + comp_pp_enc,\n\t                    w_gate + 2 * gate_pp_enc,\n\t                ),\n\t                layer=layer[\"pplus\"],\n", "            )\n\t        )\n\t        psdm.xmin = sd_diff.xmin - comp_pp_enc\n\t        psdm.ymin = sd_diff_intr.ymin - gate_pp_enc\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    rect_bulk.xmax - rect_bulk.xmin + comp_np_enc,\n\t                    w_gate + 2 * comp_np_enc,\n\t                ),\n", "                layer=layer[\"nplus\"],\n\t            )\n\t        )\n\t        nsdm.connect(\"e1\", destination=psdm.ports[\"e3\"])\n\t        bulk_con = via_stack(\n\t            x_range=(rect_bulk.xmin + 0.1, rect_bulk.xmax - 0.1),\n\t            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n", "        c_inst.add_ref(bulk_con)\n\t        c.add_ref(c_inst)\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=sub_lbl,\n\t                position=(\n\t                    bulk_con.xmin + bulk_con.size[0] / 2,\n\t                    bulk_con.ymin + bulk_con.size[1] / 2,\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n", "                lbl=lbl,\n\t                labels=[sub_lbl],\n\t                lbl_valid_len=1,\n\t            )\n\t        )\n\t        # deep nwell generation\n\t        c.add_ref(\n\t            pfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n", "                enc_size=(sd_diff.size[0] + rect_bulk.size[0], sd_diff.size[1]),\n\t                enc_xmin=sd_diff.xmin,\n\t                enc_ymin=sd_diff.ymin,\n\t                nw_enc_pcmp=nw_enc_pcmp,\n\t                grw=grw,\n\t            )\n\t        )\n\t        # dualgate generation\n\t        # c.add_ref(\n\t        #     hv_gen(c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n", "        # )\n\t        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\t    elif bulk == \"Guard Ring\":\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_pp_enc),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm.xmin = sd_diff.xmin - comp_pp_enc\n", "        psdm.ymin = sd_diff_intr.ymin - gate_pp_enc\n\t        c.add_ref(c_inst)\n\t        bulk_gr_gen(\n\t            c,\n\t            c_inst=c_inst,\n\t            comp_spacing=comp_spacing,\n\t            poly2_comp_spacing=comp_spacing,\n\t            volt=volt,\n\t            grw=grw,\n\t            l_d=l_d,\n", "            implant_layer=layer[\"nplus\"],\n\t            lbl=lbl,\n\t            sub_lbl=sub_lbl,\n\t            deepnwell=deepnwell,\n\t            pcmpgr=pcmpgr,\n\t            nw_enc_pcmp=nw_enc_pcmp,\n\t        )\n\t        # bulk guardring\n\t    return c\n\t@gf.cell\n", "def nfet_06v0_nvt(\n\t    l_gate: float = 1.8,\n\t    w_gate: float = 0.8,\n\t    sd_con_col: int = 1,\n\t    inter_sd_l: float = 0.24,\n\t    nf: int = 1,\n\t    grw: float = 0.22,\n\t    bulk=\"None\",\n\t    con_bet_fin: int = 1,\n\t    gate_con_pos=\"alternating\",\n", "    interdig: int = 0,\n\t    patt=\"\",\n\t    lbl: bool = 0,\n\t    sd_lbl: Optional[Strs] = [],\n\t    g_lbl: str = [],\n\t    sub_lbl: str = \"\",\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n", "     used to draw Native NFET 6V transistor by specifying parameters\n\t    Arguments:-\n\t     l      : Float of gate length\n\t     w      : Float of gate width\n\t     ld     : Float of diffusion length\n\t     nf     : Integer of number of fingers\n\t     grw    : Float of guard ring width [If enabled]\n\t     bulk   : String of bulk connection type [None, Bulk Tie, Guard Ring]\n\t    \"\"\"\n\t    # used layers and dimensions\n", "    end_cap: float = 0.22\n\t    comp_spacing: float = 0.36\n\t    poly2_comp_spacing: float = 0.3\n\t    gate_np_enc: float = 0.23\n\t    comp_np_enc: float = 0.16\n\t    comp_pp_enc: float = 0.16\n\t    poly2_spacing: float = 0.24\n\t    pc_ext: float = 0.04\n\t    con_size = 0.22\n\t    con_sp = 0.28\n", "    con_comp_enc = 0.07\n\t    con_pl_enc = 0.07\n\t    dg_enc_cmp = 0.24\n\t    dg_enc_poly = 0.4\n\t    sd_l_con = (\n\t        ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n\t    )\n\t    sd_l = sd_l_con\n\t    # gds components to store a single instance and the generated device\n\t    c = gf.Component(\"sky_nfet_nvt_dev\")\n", "    c_inst = gf.Component(\"dev_temp\")\n\t    # generating sd diffusion\n\t    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n\t        nf = len(patt)\n\t    l_d = (\n\t        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc)\n\t    )  # diffution total length\n\t    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n\t    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\t    # generatin sd contacts\n", "    if w_gate <= con_size + 2 * con_comp_enc:\n\t        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\t    else:\n\t        cmpc_y = w_gate\n\t    cmpc_size = (sd_l_con, cmpc_y)\n\t    sd_diff = c_inst.add_array(\n\t        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n", "    )\n\t    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n\t    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\t    sd_con = via_stack(\n\t        x_range=(sd_diff.xmin, sd_diff_intr.xmin),\n\t        y_range=(sd_diff.ymin, sd_diff.ymax),\n\t        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n\t    )\n\t    c_inst.add_array(\n", "        component=sd_con,\n\t        columns=2,\n\t        rows=1,\n\t        spacing=(\n\t            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc),\n\t            0,\n\t        ),\n\t    )\n\t    if con_bet_fin == 1 and nf > 1:\n\t        inter_sd_con = via_stack(\n", "            x_range=(\n\t                sd_diff_intr.xmin + con_comp_enc + l_gate,\n\t                sd_diff_intr.xmin + con_comp_enc + l_gate + inter_sd_l,\n\t            ),\n\t            y_range=(0, w_gate),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t        c_inst.add_array(\n\t            component=inter_sd_con,\n", "            columns=nf - 1,\n\t            rows=1,\n\t            spacing=(l_gate + inter_sd_l, 0),\n\t        )\n\t    ### adding source/drain labels\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n", "            lbl=lbl,\n\t            labels=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=0,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n", "            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            labels=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=nf,\n\t        )\n\t    )\n\t    # generating poly\n\t    if l_gate <= con_size + 2 * con_pl_enc:\n\t        pc_x = con_pl_enc + con_size + con_pl_enc\n", "    else:\n\t        pc_x = l_gate\n\t    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\t    c_pc = gf.Component(\"poly con\")\n\t    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\t    poly_con = via_stack(\n\t        x_range=(rect_pc.xmin, rect_pc.xmax),\n\t        y_range=(rect_pc.ymin, rect_pc.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n", "        li_enc_dir=\"H\",\n\t    )\n\t    c_pc.add_ref(poly_con)\n\t    if nf == 1:\n\t        poly = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n\t            )\n\t        )\n\t        poly.xmin = sd_diff_intr.xmin + con_comp_enc\n", "        poly.ymin = sd_diff_intr.ymin - end_cap\n\t        if gate_con_pos == \"bottom\":\n\t            mv = 0\n\t            nr = 1\n\t        elif gate_con_pos == \"top\":\n\t            mv = pc_size[1] + w_gate + 2 * end_cap\n\t            nr = 1\n\t        else:\n\t            mv = 0\n\t            nr = 2\n", "        pc = c_inst.add_array(\n\t            component=c_pc,\n\t            rows=nr,\n\t            columns=1,\n\t            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n\t        )\n\t        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\t        # gate_lablel\n\t        c.add_ref(\n\t            labels_gen(\n", "                lbl_str=\"None\",\n\t                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                labels=g_lbl,\n\t                lbl_valid_len=nf,\n\t                index=0,\n\t            )\n\t        )\n\t    else:\n", "        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\t        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n\t            if gate_con_pos == \"alternating\":\n\t                w_p1 += 0.2\n\t                w_p2 = w_p1\n\t                e_c = 0.2\n\t            else:\n\t                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n\t                e_c = 0\n\t            if gate_con_pos == \"bottom\":\n", "                p_mv = -end_cap - (w_p2 - w_p1)\n\t            else:\n\t                p_mv = -end_cap\n\t        else:\n\t            w_p2 = w_p1\n\t            p_mv = -end_cap\n\t            e_c = 0\n\t        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n\t        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n\t        poly1 = c_inst.add_array(\n", "            rect_p1,\n\t            rows=1,\n\t            columns=ceil(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly1.xmin = sd_diff_intr.xmin + con_comp_enc\n\t        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\t        poly2 = c_inst.add_array(\n\t            rect_p2,\n\t            rows=1,\n", "            columns=floor(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n\t        poly2.ymin = p_mv\n\t        # generating poly contacts setups\n\t        if gate_con_pos == \"bottom\":\n\t            mv_1 = 0\n\t            mv_2 = -(w_p2 - w_p1)\n\t        elif gate_con_pos == \"top\":\n", "            mv_1 = pc_size[1] + w_p1\n\t            mv_2 = pc_size[1] + w_p2\n\t        else:\n\t            mv_1 = -e_c\n\t            mv_2 = pc_size[1] + w_p2\n\t        nc1 = ceil(nf / 2)\n\t        nc2 = floor(nf / 2)\n\t        pc_spacing = 2 * (inter_sd_l + l_gate)\n\t        # generating poly contacts\n\t        pc1 = c_inst.add_array(\n", "            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n\t        )\n\t        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\t        pc2 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n\t        )\n\t        pc2.move(\n\t            (\n\t                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n\t                -pc_size[1] - end_cap + mv_2,\n", "            )\n\t        )\n\t        add_inter_sd_labels(\n\t            c,\n\t            nf,\n\t            sd_lbl,\n\t            poly1,\n\t            l_gate,\n\t            inter_sd_l,\n\t            sd_diff_intr,\n", "            lbl,\n\t            layer,\n\t            con_bet_fin,\n\t        )\n\t        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\t        if interdig == 1:\n\t            c_inst.add_ref(\n\t                interdigit(\n\t                    sd_diff=sd_diff,\n\t                    pc1=pc1,\n", "                    pc2=pc2,\n\t                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n\t                    sd_l=sd_l,\n\t                    nf=nf,\n\t                    patt=patt,\n\t                    gate_con_pos=gate_con_pos,\n\t                    pc_x=pc_x,\n", "                    pc_spacing=pc_spacing,\n\t                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n\t            )\n\t    # generating bulk\n\t    if bulk == \"None\":\n\t        nplus = c_inst.add_ref(\n\t            gf.components.rectangle(\n", "                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n\t                layer=layer[\"nplus\"],\n\t            )\n\t        )\n\t        nplus.xmin = sd_diff.xmin - comp_np_enc\n\t        nplus.ymin = sd_diff_intr.ymin - gate_np_enc\n\t    elif bulk == \"Bulk Tie\":\n\t        rect_bulk = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n", "            )\n\t        )\n\t        rect_bulk.xmin = sd_diff.xmax\n\t        rect_bulk.ymin = sd_diff.ymin\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n\t                    w_gate + 2 * gate_np_enc,\n\t                ),\n", "                layer=layer[\"nplus\"],\n\t            )\n\t        )\n\t        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n\t                    w_gate + 2 * comp_pp_enc,\n", "                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\t        bulk_con = via_stack(\n\t            x_range=(rect_bulk.xmin + 0.1, rect_bulk.xmax - 0.1),\n\t            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n", "        )\n\t        c_inst.add_ref(bulk_con)\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=sub_lbl,\n\t                position=(\n\t                    bulk_con.xmin + bulk_con.size[0] / 2,\n\t                    bulk_con.ymin + bulk_con.size[1] / 2,\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n", "                lbl=lbl,\n\t                labels=[sub_lbl],\n\t                lbl_valid_len=1,\n\t            )\n\t        )\n\t    elif bulk == \"Guard Ring\":\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n\t                layer=layer[\"nplus\"],\n", "            )\n\t        )\n\t        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n\t        c.add_ref(c_inst)\n\t        c_temp = gf.Component(\"temp_store\")\n\t        rect_bulk_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (c_inst.xmax - c_inst.xmin) + 2 * comp_spacing,\n", "                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_bulk_in.move(\n\t            (c_inst.xmin - comp_spacing, c_inst.ymin - poly2_comp_spacing)\n\t        )\n\t        rect_bulk_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n", "                size=(\n\t                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n\t        B = c.add_ref(\n\t            gf.geometry.boolean(\n", "                A=rect_bulk_out,\n\t                B=rect_bulk_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        psdm_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n", "                    (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n\t        psdm_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n", "                    (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n\t            (\n\t                rect_bulk_out.xmin - comp_pp_enc,\n\t                rect_bulk_out.ymin - comp_pp_enc,\n\t            )\n", "        )\n\t        psdm = c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n", "                    rect_bulk_in.xmin + con_size,\n\t                    rect_bulk_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n", "        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_bulk_in.xmin + con_size,\n\t                    rect_bulk_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n", "                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # upper contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n\t                y_range=(\n\t                    rect_bulk_in.ymin + con_size,\n\t                    rect_bulk_in.ymax - con_size,\n\t                ),\n", "                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n\t                y_range=(\n", "                    rect_bulk_in.ymin + con_size,\n\t                    rect_bulk_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n\t        comp_m1_in = c_temp.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    (l_d) + 2 * comp_spacing,\n\t                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n\t                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n\t        comp_m1_out = c_temp.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n\t        b_gr = c.add_ref(\n", "            gf.geometry.boolean(\n\t                A=rect_bulk_out,\n\t                B=rect_bulk_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )  # guardring metal1\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=sub_lbl,\n", "                position=(\n\t                    b_gr.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n\t                    b_gr.ymin + (b_gr.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                labels=[sub_lbl],\n\t                lbl_valid_len=1,\n\t            )\n\t        )\n", "        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    B.size[0] + (2 * dg_enc_cmp),\n\t                    B.size[1] + (2 * dg_enc_cmp),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = B.xmin - dg_enc_cmp\n", "        dg.ymin = B.ymin - dg_enc_cmp\n\t    if bulk != \"Guard Ring\":\n\t        c.add_ref(c_inst)\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    c_inst.size[0] + (2 * dg_enc_cmp),\n\t                    c_inst.size[1] + (2 * dg_enc_poly),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n", "            )\n\t        )\n\t        dg.xmin = c_inst.xmin - dg_enc_cmp\n\t        dg.ymin = c_inst.ymin - dg_enc_poly\n\t    # generating native layer\n\t    nat = c.add_ref(\n\t        gf.components.rectangle(size=(dg.size[0], dg.size[1]), layer=layer[\"nat\"])\n\t    )\n\t    nat.xmin = dg.xmin\n\t    nat.ymin = dg.ymin\n", "    return c\n\tif __name__ == \"__main__\":\n\t    # c = nfet()\n\t    c = nfet_06v0_nvt()\n\t    c.show()\n"]}
{"filename": "gf180/cap_mim.py", "chunked_list": ["import gdsfactory as gf\n\tfrom gf180.layers import layer\n\tfrom gf180.via_generator import via_generator\n\t@gf.cell\n\tdef cap_mim(\n\t    mim_option: str = \"A\",\n\t    metal_level: str = \"M4\",\n\t    lc: float = 2,\n\t    wc: float = 2,\n\t    lbl: bool = 0,\n", "    top_lbl: str = \"\",\n\t    bot_lbl: str = \"\",\n\t):\n\t    \"\"\"Return mim cap.\n\t    Args:\n\t        lc : float of cap length\n\t        wc : float of cap width\n\t    \"\"\"\n\t    c = gf.Component(\"mim_cap_dev\")\n\t    # used dimensions and layers\n", "    # MIM Option selection\n\t    if mim_option == \"MIM-A\":\n\t        upper_layer = layer[\"metal3\"]\n\t        bottom_layer = layer[\"metal2\"]\n\t        via_layer = layer[\"via2\"]\n\t        up_lbl_layer = layer[\"metal3_label\"]\n\t        bot_lbl_layer = layer[\"metal2_label\"]\n\t    elif mim_option == \"MIM-B\":\n\t        if metal_level == \"M4\":\n\t            upper_layer = layer[\"metal4\"]\n", "            bottom_layer = layer[\"metal3\"]\n\t            via_layer = layer[\"via3\"]\n\t            up_lbl_layer = layer[\"metal4_label\"]\n\t            bot_lbl_layer = layer[\"metal3_label\"]\n\t        elif metal_level == \"M5\":\n\t            upper_layer = layer[\"metal5\"]\n\t            bottom_layer = layer[\"metal4\"]\n\t            via_layer = layer[\"via4\"]\n\t            up_lbl_layer = layer[\"metal5_label\"]\n\t            bot_lbl_layer = layer[\"metal4_label\"]\n", "        elif metal_level == \"M6\":\n\t            upper_layer = layer[\"metaltop\"]\n\t            bottom_layer = layer[\"metal5\"]\n\t            via_layer = layer[\"via5\"]\n\t            up_lbl_layer = layer[\"metaltop_label\"]\n\t            bot_lbl_layer = layer[\"metal5_label\"]\n\t    else:\n\t        upper_layer = layer[\"metal3\"]\n\t        bottom_layer = layer[\"metal2\"]\n\t        via_layer = layer[\"via2\"]\n", "        up_lbl_layer = layer[\"metal3_label\"]\n\t        bot_lbl_layer = layer[\"metal2_label\"]\n\t    via_size = (0.22, 0.22)\n\t    via_spacing = (0.5, 0.5)\n\t    via_enc = (0.4, 0.4)\n\t    bot_enc_top = 0.6\n\t    l_mk_w = 0.1\n\t    # drawing cap identifier and bottom , upper layers\n\t    m_up = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(wc, lc),\n\t            layer=upper_layer,\n\t        )\n\t    )\n\t    fusetop = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(m_up.size[0], m_up.size[1]), layer=layer[\"fusetop\"]\n\t        )\n\t    )\n\t    fusetop.xmin = m_up.xmin\n", "    fusetop.ymin = m_up.ymin\n\t    mim_l_mk = c.add_ref(\n\t        gf.components.rectangle(size=(fusetop.size[0], l_mk_w), layer=layer[\"mim_l_mk\"])\n\t    )\n\t    mim_l_mk.xmin = fusetop.xmin\n\t    mim_l_mk.ymin = fusetop.ymin\n\t    m_dn = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(m_up.size[0] + (2 * bot_enc_top), m_up.size[1] + (2 * bot_enc_top)),\n\t            layer=bottom_layer,\n", "        )\n\t    )\n\t    m_dn.xmin = m_up.xmin - bot_enc_top\n\t    m_dn.ymin = m_up.ymin - bot_enc_top\n\t    cap_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(m_dn.size[0], m_dn.size[1]), layer=layer[\"cap_mk\"]\n\t        )\n\t    )\n\t    cap_mk.xmin = m_dn.xmin\n", "    cap_mk.ymin = m_dn.ymin\n\t    # generating labels\n\t    if lbl == 1:\n\t        c.add_label(\n\t            top_lbl,\n\t            position=(m_up.xmin + (m_up.size[0] / 2), m_dn.xmin + (m_dn.size[1] / 2)),\n\t            layer=up_lbl_layer,\n\t        )\n\t        c.add_label(\n\t            bot_lbl,\n", "            position=(\n\t                m_dn.xmin + (m_dn.size[0] / 2),\n\t                m_dn.ymin + (m_up.ymin - m_dn.ymin) / 2,\n\t            ),\n\t            layer=bot_lbl_layer,\n\t        )\n\t    # generating vias\n\t    via = via_generator(\n\t        x_range=(m_up.xmin, m_up.xmax),\n\t        y_range=(m_up.ymin, m_up.ymax),\n", "        via_enclosure=via_enc,\n\t        via_layer=via_layer,\n\t        via_size=via_size,\n\t        via_spacing=via_spacing,\n\t    )\n\t    c.add_ref(via)\n\t    return c\n\tif __name__ == \"__main__\":\n\t    c = cap_mim()\n\t    c.show()\n"]}
{"filename": "gf180/diode.py", "chunked_list": ["import gdsfactory as gf\n\timport numpy as np\n\tfrom gdsfactory.typings import Float2\n\tfrom gf180.layers import layer\n\tfrom gf180.via_generator import via_generator, via_stack\n\t@gf.cell\n\tdef diode_nd2ps(\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n", "    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n\t    Arguments:\n", "        la         : Float of diff length (anode)\n\t        wa         : Float of diff width (anode)\n\t        cw         : Float of cathode width\n\t        volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t        deepnwell  : Boolean of using Deep NWELL device\n\t        pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n\t    \"\"\"\n\t    c = gf.Component(\"diode_nd2ps_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n", "    pp_enc_comp: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    dg_enc_cmp = 0.24\n\t    dn_enc_lvpwell = 2.5\n\t    lvpwell_enc_ncmp = 0.6\n\t    lvpwell_enc_pcmp = 0.16\n\t    pcmpgr_enc_dn = 2.5\n\t    # n generation\n", "    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    nplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n\t            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n\t    )\n", "    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = ncmp.xmin\n\t    diode_mk.ymin = ncmp.ymin\n\t    ncmp_con = c.add_ref(\n", "        via_stack(\n\t            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp_con\n\t    # p generation\n\t    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    pcmp.xmax = ncmp.xmin - comp_spacing\n", "    pplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n\t                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n", "    pplus.ymin = pcmp.ymin - pp_enc_comp\n\t    pcmp_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(pcmp.xmin, pcmp.xmax),\n\t            y_range=(pcmp.ymin, pcmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # pcomp_con\n\t    # labels generation\n", "    if lbl == 1:\n\t        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n\t                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n", "        # p_label generation\n\t        c.add_label(\n\t            p_lbl,\n\t            position=(\n\t                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n\t                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    if volt == \"5/6V\":\n", "        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n\t                    ncmp.size[1] + (2 * dg_enc_cmp),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = pcmp.xmin - dg_enc_cmp\n", "        dg.ymin = pcmp.ymin - dg_enc_cmp\n\t    if deepnwell == 1:\n\t        lvpwell = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.xmax - pcmp.xmin + (lvpwell_enc_ncmp + lvpwell_enc_pcmp),\n\t                    ncmp.size[1] + (2 * lvpwell_enc_ncmp),\n\t                ),\n\t                layer=layer[\"lvpwell\"],\n\t            )\n", "        )\n\t        lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n\t        lvpwell.ymin = ncmp.ymin - lvpwell_enc_ncmp\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n\t                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n", "            )\n\t        )\n\t        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t            rect_pcmpgr_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n", "                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_in.move(\n\t                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t            )\n\t            rect_pcmpgr_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n", "                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n", "                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )  # guardring Bulk draw\n\t            psdm_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n", "                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_in.move(\n\t                (\n\t                    rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                    rect_pcmpgr_in.ymin + pp_enc_comp,\n\t                )\n", "            )\n\t            psdm_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n\t                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n", "            psdm_out.move(\n\t                (\n\t                    rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                    rect_pcmpgr_out.ymin - pp_enc_comp,\n\t                )\n\t            )\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t                )\n", "            )  # psdm draw\n\t            # generating contacts\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n", "                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # bottom contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n", "                    ),\n\t                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # upper contact\n\t            c.add_ref(\n\t                via_generator(\n", "                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n", "            )  # right contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n", "                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # left contact\n\t            comp_m1_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n", "            comp_m1_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (comp_m1_in.size[0]) + 2 * cw,\n\t                        (comp_m1_in.size[1]) + 2 * cw,\n\t                    ),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n", "            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )  # guardring metal1\n\t    return c\n\t@gf.cell\n", "def diode_pd2nw(\n\t    layout,\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n", "    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw 3.3V P+/Nwell diode (Outside DNWELL) by specifying parameters\n\t    Arguments:-\n\t     la         : Float of diffusion length (anode)\n\t     wa         : Float of diffusion width (anode)\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t     deepnwell  : Boolean of using Deep NWELL device\n", "     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n\t    \"\"\"\n\t    c = gf.Component(\"diode_pd2nw_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    dg_enc_cmp = 0.24\n", "    dn_enc_nwell = 0.5\n\t    nwell_ncmp_enc = 0.12\n\t    nwell_pcmp_enc = 0.43\n\t    pcmpgr_enc_dn = 2.5\n\t    # p generation\n\t    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    pplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n", "                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n\t    pplus.ymin = pcmp.ymin - pp_enc_comp\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n", "        )\n\t    )\n\t    diode_mk.xmin = pcmp.xmin\n\t    diode_mk.ymin = pcmp.ymin\n\t    pcmp_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(pcmp.xmin, pcmp.xmax),\n\t            y_range=(pcmp.ymin, pcmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n", "        )\n\t    )  # pcomp_contact\n\t    # n generation\n\t    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    ncmp.xmax = pcmp.xmin - comp_spacing\n\t    nplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n", "            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n\t    )\n\t    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n\t    ncmp_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n", "            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp contact\n\t    # labels generation\n\t    if lbl == 1:\n\t        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n", "                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n\t                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        # p_label generation\n\t        c.add_label(\n\t            p_lbl,\n\t            position=(\n\t                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n", "                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    pcmp.xmax - ncmp.xmin + (2 * dg_enc_cmp),\n\t                    ncmp.size[1] + (2 * dg_enc_cmp),\n", "                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = ncmp.xmin - dg_enc_cmp\n\t        dg.ymin = ncmp.ymin - dg_enc_cmp\n\t    # nwell generation\n\t    nwell = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                pcmp.xmax - ncmp.xmin + (nwell_ncmp_enc + nwell_pcmp_enc),\n\t                pcmp.size[1] + (2 * nwell_pcmp_enc),\n\t            ),\n\t            layer=layer[\"nwell\"],\n\t        )\n\t    )\n\t    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n\t    nwell.ymin = pcmp.ymin - nwell_pcmp_enc\n\t    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    nwell.size[0] + (2 * dn_enc_nwell),\n\t                    nwell.size[1] + (2 * dn_enc_nwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = nwell.xmin - dn_enc_nwell\n\t        dn_rect.ymin = nwell.ymin - dn_enc_nwell\n", "        if pcmpgr == 1:\n\t            c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t            rect_pcmpgr_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n", "            )\n\t            rect_pcmpgr_in.move(\n\t                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t            )\n\t            rect_pcmpgr_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                    ),\n", "                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"comp\"],\n", "                )\n\t            )  # Bulk guardring\n\t            psdm_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n", "            )\n\t            psdm_in.move(\n\t                (\n\t                    rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                    rect_pcmpgr_in.ymin + pp_enc_comp,\n\t                )\n\t            )\n\t            psdm_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n", "                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n\t                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_out.move(\n\t                (\n\t                    rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                    rect_pcmpgr_out.ymin - pp_enc_comp,\n", "                )\n\t            )\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t                )\n\t            )  # psdm guardring\n\t            # generating contacts\n\t            c.add_ref(\n\t                via_generator(\n", "                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n", "            )  # bottom contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n", "                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # upper contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n", "                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # right contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n", "                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # left contact\n", "            comp_m1_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (comp_m1_in.size[0]) + 2 * cw,\n", "                        (comp_m1_in.size[1]) + 2 * cw,\n\t                    ),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n", "                    operation=\"A-B\",\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )  # guardring metal1\n\t    return c\n\t@gf.cell\n\tdef diode_nw2ps(\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n", "    volt: str = \"3.3V\",\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw 3.3V Nwell/Psub diode by specifying parameters\n\t    Arguments:-\n\t     la         : Float of diff length (anode)\n", "     wa         : Float of diff width (anode)\n\t     cw         : Float of Cathode width\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t    \"\"\"\n\t    c = gf.Component(\"diode_nw2ps_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    dg_enc_cmp = 0.24\n\t    nwell_ncmp_enc = 0.16\n", "    # n generation\n\t    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    nplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n\t            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n", "    )\n\t    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = ncmp.xmin\n\t    diode_mk.ymin = ncmp.ymin\n", "    nwell = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * nwell_ncmp_enc),\n\t                ncmp.size[1] + (2 * nwell_ncmp_enc),\n\t            ),\n\t            layer=layer[\"nwell\"],\n\t        )\n\t    )\n\t    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n", "    nwell.ymin = ncmp.ymin - nwell_ncmp_enc\n\t    n_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp contact\n\t    # p generation\n", "    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    pcmp.xmax = ncmp.xmin - comp_spacing\n\t    pplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n\t                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n", "    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n\t    pplus.ymin = pcmp.ymin - pp_enc_comp\n\t    p_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(pcmp.xmin, pcmp.xmax),\n\t            y_range=(pcmp.ymin, pcmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n", "    )  # pcmop contact\n\t    # labels generation\n\t    if lbl == 1:\n\t        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                n_con.xmin + (n_con.size[0] / 2),\n\t                n_con.ymin + (n_con.size[1] / 2),\n\t            ),\n", "            layer=layer[\"metal1_label\"],\n\t        )\n\t        # p_label generation\n\t        c.add_label(\n\t            p_lbl,\n\t            position=(\n\t                p_con.xmin + (p_con.size[0] / 2),\n\t                p_con.ymin + (p_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n", "        )\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n\t                    ncmp.size[1] + (2 * dg_enc_cmp),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n", "        )\n\t        dg.xmin = pcmp.xmin - dg_enc_cmp\n\t        dg.ymin = pcmp.ymin - dg_enc_cmp\n\t    return c\n\t@gf.cell\n\tdef diode_pw2dw(\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    volt: str = \"3.3V\",\n", "    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw LVPWELL/DNWELL diode by specifying parameters\n\t    Arguments:-\n\t     layout     : Object of layout\n", "     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n\t     cw         : Float of cathode width\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t    \"\"\"\n\t    c = gf.Component(\"diode_pw2dw_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    dg_enc_dn = 0.5\n", "    lvpwell_enc_pcmp = 0.16\n\t    dn_enc_lvpwell = 2.5\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    pcmpgr_enc_dn = 2.5\n\t    # p generation\n\t    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    pplus = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n\t                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n\t    pplus.ymin = pcmp.ymin - pp_enc_comp\n\t    diode_mk = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = pcmp.xmin\n\t    diode_mk.ymin = pcmp.ymin\n\t    lvpwell = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                pcmp.size[0] + (2 * lvpwell_enc_pcmp),\n", "                pcmp.size[1] + (2 * lvpwell_enc_pcmp),\n\t            ),\n\t            layer=layer[\"lvpwell\"],\n\t        )\n\t    )\n\t    lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n\t    lvpwell.ymin = pcmp.ymin - lvpwell_enc_pcmp\n\t    p_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(pcmp.xmin, pcmp.xmax),\n", "            y_range=(pcmp.ymin, pcmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # pcomp_contact\n\t    # n generation\n\t    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    ncmp.xmax = pcmp.xmin - comp_spacing\n\t    nplus = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n\t            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n\t    )\n\t    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n\t    n_con = c.add_ref(\n", "        via_stack(\n\t            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp contact\n\t    # labels generation\n\t    if lbl == 1:\n\t        # n_label generation\n", "        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                n_con.xmin + (n_con.size[0] / 2),\n\t                n_con.ymin + (n_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        # p_label generation\n\t        c.add_label(\n", "            p_lbl,\n\t            position=(\n\t                p_con.xmin + (p_con.size[0] / 2),\n\t                p_con.ymin + (p_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    dn_rect = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                lvpwell.size[0] + (2 * dn_enc_lvpwell),\n\t                lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t            ),\n\t            layer=layer[\"dnwell\"],\n\t        )\n\t    )\n\t    dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t    dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t    if pcmpgr == 1:\n\t        c_temp_gr = gf.Component(\"temp_store guard ring\")\n", "        rect_pcmpgr_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_pcmpgr_in.move(\n", "            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t        )\n\t        rect_pcmpgr_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n", "        )\n\t        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )  # guardring Bulk\n", "        psdm_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_in.move(\n", "            (\n\t                rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                rect_pcmpgr_in.ymin + pp_enc_comp,\n\t            )\n\t        )\n\t        psdm_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n", "                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n\t            (\n\t                rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                rect_pcmpgr_out.ymin - pp_enc_comp,\n\t            )\n\t        )\n", "        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )  # guardring psdm\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n", "                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n\t        c.add_ref(\n", "            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n", "            )\n\t        )  # upper contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n", "                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n", "                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n\t        comp_m1_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n", "                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n\t                    (comp_m1_in.size[1]) + 2 * cw,\n\t                ),\n", "                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n", "            )\n\t        )  # guardring metal1\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    dn_rect.size[0] + (2 * dg_enc_dn),\n\t                    dn_rect.size[1] + (2 * dg_enc_dn),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n", "            )\n\t        )\n\t        dg.xmin = dn_rect.xmin - dg_enc_dn\n\t        dg.ymin = dn_rect.ymin - dg_enc_dn\n\t    return c\n\t@gf.cell\n\tdef diode_dw2ps(\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n", "    volt: str = \"3.3V\",\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw LVPWELL/DNWELL diode by specifying parameters\n\t    Arguments:-\n", "     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t    \"\"\"\n\t    c = gf.Component(\"diode_dw2ps_dev\")\n\t    if volt == \"5/6V\":\n\t        dn_enc_ncmp = 0.66\n\t    else:\n\t        dn_enc_ncmp = 0.62\n\t    comp_spacing = 0.32\n", "    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    dg_enc_dn = 0.5\n\t    pcmpgr_enc_dn = 2.5\n\t    if (wa < ((2 * cw) + comp_spacing)) or (la < ((2 * cw) + comp_spacing)):\n\t        ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t        n_con = c.add_ref(\n", "            via_stack(\n\t                x_range=(ncmp.xmin, ncmp.xmax),\n\t                y_range=(ncmp.ymin, ncmp.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n\t            )\n\t        )  # ncomp_contact\n\t        nplus = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    ncmp.size[0] + (2 * np_enc_comp),\n\t                    ncmp.size[1] + (2 * np_enc_comp),\n\t                ),\n\t                layer=layer[\"nplus\"],\n\t            )\n\t        )\n\t        nplus.xmin = ncmp.xmin - np_enc_comp\n\t        nplus.ymin = ncmp.ymin - np_enc_comp\n\t    else:\n\t        c_temp = gf.Component(\"temp_store guard ring\")\n", "        ncmp_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(wa - (2 * cw), la - (2 * cw)),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        ncmp_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(wa, la),\n\t                layer=layer[\"comp\"],\n", "            )\n\t        )\n\t        ncmp_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n\t        ncmp = c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=ncmp_out,\n\t                B=ncmp_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n", "        )\n\t        pplus_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (ncmp_in.xmax - ncmp_in.xmin) - 2 * pp_enc_comp,\n\t                    (ncmp_in.ymax - ncmp_in.ymin) - 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n", "        pplus_in.move(\n\t            (\n\t                ncmp_in.xmin + pp_enc_comp,\n\t                ncmp_in.ymin + pp_enc_comp,\n\t            )\n\t        )\n\t        pplus_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (ncmp_out.xmax - ncmp_out.xmin) + 2 * pp_enc_comp,\n", "                    (ncmp_out.ymax - ncmp_out.ymin) + 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        pplus_out.move(\n\t            (\n\t                ncmp_out.xmin - pp_enc_comp,\n\t                ncmp_out.ymin - pp_enc_comp,\n\t            )\n", "        )\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=pplus_out, B=pplus_in, operation=\"A-B\", layer=layer[\"nplus\"]\n\t            )\n\t        )  # nplus\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n", "                    ncmp_in.xmin + con_size,\n\t                    ncmp_in.xmax - con_size,\n\t                ),\n\t                y_range=(ncmp_out.ymin, ncmp_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n", "        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    ncmp_in.xmin + con_size,\n\t                    ncmp_in.xmax - con_size,\n\t                ),\n\t                y_range=(ncmp_in.ymax, ncmp_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n", "                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # upper contact\n\t        n_con = c.add_ref(\n\t            via_generator(\n\t                x_range=(ncmp_out.xmin, ncmp_in.xmin),\n\t                y_range=(\n\t                    ncmp_in.ymin + con_size,\n\t                    ncmp_in.ymax - con_size,\n\t                ),\n", "                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(ncmp_in.xmax, ncmp_out.xmax),\n\t                y_range=(\n", "                    ncmp_in.ymin + con_size,\n\t                    ncmp_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        comp_m1_in = c_temp.add_ref(\n", "            gf.components.rectangle(\n\t                size=(ncmp_in.size[0], ncmp_in.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n", "                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=ncmp_out,\n\t                B=ncmp_in,\n\t                operation=\"A-B\",\n", "                layer=layer[\"metal1\"],\n\t            )\n\t        )  # guardring metal1\n\t    # labels generation\n\t    if lbl == 1:\n\t        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                n_con.xmin + (n_con.size[0] / 2),\n", "                n_con.ymin + (n_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    # generate dnwell\n\t    dn_rect = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * dn_enc_ncmp),\n\t                ncmp.size[1] + (2 * dn_enc_ncmp),\n", "            ),\n\t            layer=layer[\"dnwell\"],\n\t        )\n\t    )\n\t    dn_rect.xmin = ncmp.xmin - dn_enc_ncmp\n\t    dn_rect.ymin = ncmp.ymin - dn_enc_ncmp\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(dn_rect.size[0], dn_rect.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n", "    )\n\t    diode_mk.xmin = dn_rect.xmin\n\t    diode_mk.ymin = dn_rect.ymin\n\t    if pcmpgr == 1:\n\t        c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t        rect_pcmpgr_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n", "                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_pcmpgr_in.move(\n\t            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t        )\n\t        rect_pcmpgr_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n", "                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )  # guardring Bulk\n\t        psdm_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n", "                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_in.move(\n\t            (\n\t                rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                rect_pcmpgr_in.ymin + pp_enc_comp,\n\t            )\n\t        )\n", "        psdm_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n", "            (\n\t                rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                rect_pcmpgr_out.ymin - pp_enc_comp,\n\t            )\n\t        )\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )  # psdm\n", "        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n", "                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n", "                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # upper contact\n\t        p_con = c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n", "                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n", "        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n", "                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        # labels generation\n\t        if lbl == 1:\n\t            # n_label generation\n\t            c.add_label(\n\t                p_lbl,\n\t                position=(\n\t                    p_con.xmin + (p_con.size[0] / 2),\n", "                    p_con.ymin + (p_con.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t            )\n\t        comp_m1_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n", "        comp_m1_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n", "        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )  # guardring metal1\n\t    # generate dualgate\n\t    if volt == \"5/6V\":\n", "        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    dn_rect.size[0] + (2 * dg_enc_dn),\n\t                    dn_rect.size[1] + (2 * dg_enc_dn),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = dn_rect.xmin - dg_enc_dn\n", "        dg.ymin = dn_rect.ymin - dg_enc_dn\n\t    return c\n\t@gf.cell\n\tdef sc_diode(\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    m: int = 1,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n", "    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n\t    Arguments:-\n\t     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n\t     m          : Integer of number of fingers\n", "     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n\t    \"\"\"\n\t    c = gf.Component(\"sc_diode_dev\")\n\t    sc_enc_comp = 0.16\n\t    sc_comp_spacing = 0.28\n\t    dn_enc_sc_an = 1.4\n\t    np_enc_comp = 0.03\n\t    m1_w = 0.23\n\t    pcmpgr_enc_dn = 2.5\n\t    pp_enc_comp: float = 0.16\n", "    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    # cathode draw\n\t    @gf.cell\n\t    def sc_cathode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n\t        \"\"\"Returns sc_diode cathode array element\n\t        Args :\n\t            size : size of cathode array element\n\t        \"\"\"\n", "        c = gf.Component()\n\t        ncmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\t        nplus = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.size[0] + (2 * np_enc_comp),\n\t                    ncmp.size[1] + (2 * np_enc_comp),\n\t                ),\n\t                layer=layer[\"nplus\"],\n\t            )\n", "        )\n\t        nplus.xmin = ncmp.xmin - np_enc_comp\n\t        nplus.ymin = ncmp.ymin - np_enc_comp\n\t        c.add_ref(\n\t            via_stack(\n\t                x_range=(ncmp.xmin, ncmp.xmax),\n\t                y_range=(ncmp.ymin, ncmp.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n\t            )\n", "        )  # ncomp contact\n\t        return c\n\t    @gf.cell\n\t    def sc_anode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n\t        \"\"\"Returns sc_diode anode array element\n\t        Args :\n\t            size : size of anode array element\n\t        \"\"\"\n\t        c = gf.Component()\n\t        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n", "        c.add_ref(\n\t            via_stack(\n\t                x_range=(cmp.xmin, cmp.xmax),\n\t                y_range=(cmp.ymin, cmp.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n\t            )\n\t        )  # comp contact\n\t        return c\n\t    sc_an = sc_anode_strap(size=(wa, la))\n", "    sc_cath = sc_cathode_strap(size=(cw, la))\n\t    sc_cathode = c.add_array(\n\t        component=sc_cath,\n\t        rows=1,\n\t        columns=(m + 1),\n\t        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n\t    )\n\t    cath_m1_polys = sc_cath.get_polygons(by_spec=layer[\"metal1\"])\n\t    cath_m1_xmin = np.min(cath_m1_polys[0][:, 0])\n\t    cath_m1_ymin = np.min(cath_m1_polys[0][:, 1])\n", "    cath_m1_xmax = np.max(cath_m1_polys[0][:, 0])\n\t    cath_m1_v = c.add_array(\n\t        component=gf.components.rectangle(\n\t            size=(\n\t                cath_m1_xmax - cath_m1_xmin,\n\t                cath_m1_ymin - sc_cathode.ymin + m1_w,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        ),\n\t        rows=1,\n", "        columns=(m + 1),\n\t        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n\t    )\n\t    cath_m1_v.xmin = cath_m1_xmin\n\t    cath_m1_v.ymax = cath_m1_ymin\n\t    cath_m1_h = c.add_ref(\n\t        gf.components.rectangle(size=(cath_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n\t    )\n\t    cath_m1_h.xmin = cath_m1_v.xmin\n\t    cath_m1_h.ymax = cath_m1_v.ymin\n", "    # cathode label generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                cath_m1_h.xmin + (cath_m1_h.size[0] / 2),\n\t                cath_m1_h.ymin + (cath_m1_h.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n", "    sc_anode = c.add_array(\n\t        component=sc_an,\n\t        rows=1,\n\t        columns=m,\n\t        spacing=(wa + cw + (2 * sc_comp_spacing), 0),\n\t    )\n\t    sc_anode.xmin = sc_cathode.xmin + (cw + sc_comp_spacing)\n\t    an_m1_polys = sc_anode.get_polygons(by_spec=layer[\"metal1\"])\n\t    an_m1_xmin = np.min(an_m1_polys[0][:, 0])\n\t    an_m1_ymin = np.min(an_m1_polys[0][:, 1])\n", "    an_m1_xmax = np.max(an_m1_polys[0][:, 0])\n\t    an_m1_ymax = np.max(an_m1_polys[0][:, 1])\n\t    if m > 1:\n\t        an_m1_v = c.add_array(\n\t            component=gf.components.rectangle(\n\t                size=(\n\t                    an_m1_xmax - an_m1_xmin,\n\t                    cath_m1_ymin - sc_an.ymin + m1_w,\n\t                ),\n\t                layer=layer[\"metal1\"],\n", "            ),\n\t            rows=1,\n\t            columns=m,\n\t            spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n\t        )\n\t        an_m1_v.xmin = an_m1_xmin\n\t        an_m1_v.ymin = an_m1_ymax\n\t        an_m1_h = c.add_ref(\n\t            gf.components.rectangle(size=(an_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n\t        )\n", "        an_m1_h.xmin = an_m1_v.xmin\n\t        an_m1_h.ymin = an_m1_v.ymax\n\t        # anode label generation\n\t        if lbl == 1:\n\t            c.add_label(\n\t                p_lbl,\n\t                position=(\n\t                    an_m1_h.xmin + (an_m1_h.size[0] / 2),\n\t                    an_m1_h.ymin + (an_m1_h.size[1] / 2),\n\t                ),\n", "                layer=layer[\"metal1_label\"],\n\t            )\n\t    else:\n\t        # anode label generation\n\t        if lbl == 1:\n\t            c.add_label(\n\t                p_lbl,\n\t                position=(\n\t                    an_m1_xmin + ((an_m1_xmax - an_m1_xmin) / 2),\n\t                    an_m1_ymin + ((an_m1_ymax - an_m1_ymin) / 2),\n", "                ),\n\t                layer=layer[\"metal1_label\"],\n\t            )\n\t    # diode_mk\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                sc_cathode.size[0] + (2 * sc_enc_comp),\n\t                sc_cathode.size[1] + (2 * sc_enc_comp),\n\t            ),\n", "            layer=layer[\"schottky_diode\"],\n\t        )\n\t    )\n\t    diode_mk.xmin = sc_cathode.xmin - sc_enc_comp\n\t    diode_mk.ymin = sc_cathode.ymin - sc_enc_comp\n\t    # dnwell\n\t    dn_rect = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                sc_anode.size[0] + (2 * dn_enc_sc_an),\n", "                sc_anode.size[1] + (2 * dn_enc_sc_an),\n\t            ),\n\t            layer=layer[\"dnwell\"],\n\t        )\n\t    )\n\t    dn_rect.xmin = sc_anode.xmin - dn_enc_sc_an\n\t    dn_rect.ymin = sc_anode.ymin - dn_enc_sc_an\n\t    if pcmpgr == 1:\n\t        c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t        rect_pcmpgr_in = c_temp_gr.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_pcmpgr_in.move(\n\t            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n", "        )\n\t        rect_pcmpgr_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n", "        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )  # guardring Bulk\n\t        psdm_in = c_temp_gr.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_in.move(\n\t            (\n", "                rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                rect_pcmpgr_in.ymin + pp_enc_comp,\n\t            )\n\t        )\n\t        psdm_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                ),\n", "                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n\t            (\n\t                rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                rect_pcmpgr_out.ymin - pp_enc_comp,\n\t            )\n\t        )\n\t        c.add_ref(\n", "            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )  # psdm\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n", "                ),\n\t                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n\t        c.add_ref(\n\t            via_generator(\n", "                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n", "        )  # upper contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n", "                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n", "                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n\t        comp_m1_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n", "                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n\t                    (comp_m1_in.size[1]) + 2 * cw,\n\t                ),\n\t                layer=layer[\"metal1\"],\n", "            )\n\t        )\n\t        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n\t            )\n", "        )  # guardring metal1\n\t    # creating layout and cell in klayout\n\t    return c\n\tif __name__ == \"__main__\":\n\t    c = sc_diode()\n\t    c.show()\n"]}
{"filename": "gf180/cap_mos.py", "chunked_list": ["import gdsfactory as gf\n\timport numpy as np\n\tfrom gdsfactory.typings import Float2, LayerSpec\n\tfrom gf180.layers import layer\n\tfrom gf180.via_generator import via_generator, via_stack\n\t@gf.cell\n\tdef cap_mos_inst(\n\t    lc: float = 0.1,\n\t    wc: float = 0.1,\n\t    cmp_w: float = 0.1,\n", "    con_w: float = 0.1,\n\t    pl_l: float = 0.1,\n\t    cmp_ext: float = 0.1,\n\t    pl_ext: float = 0.1,\n\t    implant_layer: LayerSpec = layer[\"nplus\"],\n\t    implant_enc: Float2 = (0.1, 0.1),\n\t    lbl: bool = 0,\n\t    g_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"Returns mos cap simple instance\n", "    Args :\n\t        lc : length of mos_cap\n\t        ws : width of mos_cap\n\t        cmp_w : width of layer[\"comp\"]\n\t        con_w : min width of comp contain contact\n\t        pl_l : length od layer[\"poly2\"]\n\t        cmp_ext : comp extension beyond poly2\n\t        pl_ext : poly2 extension beyond comp\n\t        implant_layer : Layer of implant [nplus,pplus]\n\t        implant_enc : enclosure of implant_layer to comp\n", "    \"\"\"\n\t    c_inst = gf.Component()\n\t    cmp = c_inst.add_ref(gf.components.rectangle(size=(cmp_w, wc), layer=layer[\"comp\"]))\n\t    cap_mk = c_inst.add_ref(\n\t        gf.components.rectangle(\n\t            size=(cmp.size[0], cmp.size[1]), layer=layer[\"mos_cap_mk\"]\n\t        )\n\t    )\n\t    cap_mk.xmin = cmp.xmin\n\t    cap_mk.ymin = cmp.ymin\n", "    c_inst.add_array(\n\t        component=via_stack(\n\t            x_range=(cmp.xmin, cmp.xmin + con_w),\n\t            y_range=(cmp.ymin, cmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        ),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmp_w - con_w, 0),\n", "    )  # comp contact\n\t    imp_rect = c_inst.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                cmp.size[0] + (2 * implant_enc[0]),\n\t                cmp.size[1] + (2 * implant_enc[1]),\n\t            ),\n\t            layer=implant_layer,\n\t        )\n\t    )\n", "    imp_rect.xmin = cmp.xmin - implant_enc[0]\n\t    imp_rect.ymin = cmp.ymin - implant_enc[1]\n\t    poly = c_inst.add_ref(\n\t        gf.components.rectangle(size=(lc, pl_l), layer=layer[\"poly2\"])\n\t    )\n\t    poly.xmin = cmp.xmin + cmp_ext\n\t    poly.ymin = cmp.ymin - pl_ext\n\t    pl_con_el = via_stack(\n\t        x_range=(poly.xmin, poly.xmax),\n\t        y_range=(poly.ymin, poly.ymin + con_w),\n", "        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t    )\n\t    pl_con = c_inst.add_array(\n\t        component=pl_con_el,\n\t        rows=2,\n\t        columns=1,\n\t        spacing=(0, pl_l - con_w),\n\t    )\n\t    # Gate labels_generation\n", "    if lbl == 1:\n\t        c_inst.add_label(\n\t            g_lbl,\n\t            position=(\n\t                pl_con.xmin + (pl_con.size[0] / 2),\n\t                pl_con.ymin + (pl_con_el.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    pl_m1 = c_inst.add_ref(\n", "        gf.components.rectangle(\n\t            size=(pl_con.size[0], pl_con.size[1]), layer=layer[\"metal1\"]\n\t        )\n\t    )\n\t    pl_m1.xmin = pl_con.xmin\n\t    pl_m1.ymin = pl_con.ymin\n\t    return c_inst\n\t@gf.cell\n\tdef cap_mos(\n\t    type: str = \"cap_nmos\",\n", "    lc: float = 0.1,\n\t    wc: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    g_lbl: str = \"\",\n\t    sd_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n", "    Usage:-\n\t     used to draw NMOS capacitor (Outside DNWELL) by specifying parameters\n\t    Arguments:-\n\t     l      : Float of diff length\n\t     w      : Float of diff width\n\t    \"\"\"\n\t    c = gf.Component(\"cap_mos_dev\")\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n", "    con_pl_enc = 0.07\n\t    cmp_ext = 0.15 - con_comp_enc\n\t    pl_ext = 0.17 - con_pl_enc\n\t    np_enc_gate: float = 0.23\n\t    np_enc_cmp: float = 0.16\n\t    dg_enc_cmp = 0.24\n\t    dg_enc_poly = 0.4\n\t    lvpwell_enc_ncmp = 0.43\n\t    dn_enc_lvpwell = 2.5\n\t    grw = 0.36\n", "    m1_w = 1\n\t    pcmpgr_enc_dn = 2.5\n\t    m1_ext = 0.82\n\t    comp_pp_enc: float = 0.16\n\t    dnwell_enc_pcmp = 1.1\n\t    # end_cap: float = 0.22\n\t    cmp_ed_w = con_size + (2 * con_comp_enc)\n\t    cmp_w = (2 * (cmp_ed_w + cmp_ext)) + lc\n\t    end_cap = pl_ext + cmp_ed_w\n\t    pl_l = wc + (2 * end_cap)\n", "    if \"cap_nmos\" in type:\n\t        implant_layer = layer[\"nplus\"]\n\t    else:\n\t        implant_layer = layer[\"pplus\"]\n\t    c_inst = c.add_ref(\n\t        cap_mos_inst(\n\t            cmp_w=cmp_w,\n\t            lc=lc,\n\t            wc=wc,\n\t            pl_l=pl_l,\n", "            cmp_ext=cmp_ed_w + cmp_ext,\n\t            con_w=cmp_ed_w,\n\t            pl_ext=end_cap,\n\t            implant_layer=implant_layer,\n\t            implant_enc=(np_enc_cmp, np_enc_gate),\n\t            lbl=lbl,\n\t            g_lbl=g_lbl,\n\t        )\n\t    )\n\t    cmp_m1_polys = c_inst.get_polygons(by_spec=layer[\"metal1\"])\n", "    cmp_m1_xmin = np.min(cmp_m1_polys[0][:, 0])\n\t    cmp_m1_xmax = np.max(cmp_m1_polys[0][:, 0])\n\t    cmp_m1_ymax = np.max(cmp_m1_polys[0][:, 1])\n\t    # cmp_m1 = c.add_ref(gf.components.rectangle(size=(m1_w,w+m1_ext),layer=layer[\"metal1\"]))\n\t    cmp_m1_v = c.add_array(\n\t        component=gf.components.rectangle(\n\t            size=(m1_w, wc + m1_ext), layer=layer[\"metal1\"]\n\t        ),\n\t        rows=1,\n\t        columns=2,\n", "        spacing=(m1_w + cmp_w - 2 * cmp_ed_w, 0),\n\t    )\n\t    cmp_m1_v.xmin = cmp_m1_xmin - (m1_w - (cmp_m1_xmax - cmp_m1_xmin))\n\t    cmp_m1_v.ymax = cmp_m1_ymax\n\t    cmp_m1_h = c.add_ref(\n\t        gf.components.rectangle(size=(cmp_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n\t    )\n\t    cmp_m1_h.xmin = cmp_m1_v.xmin\n\t    cmp_m1_h.ymax = cmp_m1_v.ymin\n\t    # sd labels generation\n", "    if lbl == 1:\n\t        c.add_label(\n\t            sd_lbl,\n\t            position=(\n\t                cmp_m1_h.xmin + (cmp_m1_h.size[0] / 2),\n\t                cmp_m1_h.ymin + (cmp_m1_h.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    # dualgate\n", "    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    c_inst.size[0] + (2 * dg_enc_cmp),\n\t                    c_inst.size[1] + (2 * dg_enc_poly),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n", "        dg.xmin = c_inst.xmin - dg_enc_cmp\n\t        dg.ymin = c_inst.ymin - dg_enc_poly\n\t    cmp_polys = c_inst.get_polygons(by_spec=layer[\"comp\"])\n\t    cmp_xmin = np.min(cmp_polys[0][:, 0])\n\t    cmp_ymin = np.min(cmp_polys[0][:, 1])\n\t    cmp_xmax = np.max(cmp_polys[0][:, 0])\n\t    cmp_ymax = np.max(cmp_polys[0][:, 1])\n\t    if \"_b\" in type:\n\t        if \"cap_nmos\" in type:\n\t            nwell = c.add_ref(\n", "                gf.components.rectangle(\n\t                    size=(\n\t                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n\t                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n\t                    ),\n\t                    layer=layer[\"nwell\"],\n\t                )\n\t            )\n\t            nwell.xmin = cmp_xmin - np_enc_cmp\n\t            nwell.ymin = cmp_ymin - np_enc_gate\n", "        else:\n\t            lvpwell = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n\t                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n\t                    ),\n\t                    layer=layer[\"lvpwell\"],\n\t                )\n\t            )\n", "            lvpwell.xmin = cmp_xmin - np_enc_cmp\n\t            lvpwell.ymin = cmp_ymin - np_enc_gate\n\t    if deepnwell == 1:\n\t        if type == \"cap_nmos\":\n\t            lvp_rect = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        c_inst.size[0] + (2 * lvpwell_enc_ncmp),\n\t                        c_inst.size[1] + (2 * lvpwell_enc_ncmp),\n\t                    ),\n", "                    layer=layer[\"lvpwell\"],\n\t                )\n\t            )\n\t            lvp_rect.xmin = c_inst.xmin - lvpwell_enc_ncmp\n\t            lvp_rect.ymin = c_inst.ymin - lvpwell_enc_ncmp\n\t            dn_rect = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n\t                        lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n", "                    ),\n\t                    layer=layer[\"nwell\"],\n\t                )\n\t            )\n\t            dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n\t            dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\t        else:\n\t            dn_rect = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n", "                        c_inst.size[0] + (2 * dnwell_enc_pcmp),\n\t                        c_inst.size[1] + (2 * dnwell_enc_pcmp),\n\t                    ),\n\t                    layer=layer[\"nwell\"],\n\t                )\n\t            )\n\t            dn_rect.xmin = c_inst.xmin - dnwell_enc_pcmp\n\t            dn_rect.ymin = c_inst.ymin - dnwell_enc_pcmp\n\t        if pcmpgr == 1:\n\t            c_temp_gr = gf.Component(\"temp_store guard ring\")\n", "            rect_pcmpgr_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_in.move(\n", "                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t            )\n\t            rect_pcmpgr_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n", "            )\n\t            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )  # guardring Bullk\n", "            psdm_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_in.move(\n", "                (\n\t                    rect_pcmpgr_in.xmin + comp_pp_enc,\n\t                    rect_pcmpgr_in.ymin + comp_pp_enc,\n\t                )\n\t            )\n\t            psdm_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n\t                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n", "                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_out.move(\n\t                (\n\t                    rect_pcmpgr_out.xmin - comp_pp_enc,\n\t                    rect_pcmpgr_out.ymin - comp_pp_enc,\n\t                )\n\t            )\n", "            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t                )\n\t            )  # psdm\n\t            # generating contacts\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n", "                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # bottom contact\n\t            c.add_ref(\n", "                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n", "                )\n\t            )  # upper contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n", "                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # right contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n", "                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # left contact\n\t            comp_m1_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n", "                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (comp_m1_in.size[0]) + 2 * grw,\n\t                        (comp_m1_in.size[1]) + 2 * grw,\n\t                    ),\n", "                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"metal1\"],\n", "                )\n\t            )  # guardring metal1\n\t    return c\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_diode.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t## Diode Pcells Generators for Klayout of GF180MCU\n\t########################################################################################################################\n\timport gdsfactory as gf\n\timport numpy as np\n\tfrom gdsfactory.typings import Float2\n\tfrom .layers_def import layer\n", "from .via_generator import via_generator, via_stack\n\tdef draw_diode_nd2ps(\n\t    layout,\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n", "    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n\t    Arguments:-\n\t     layout     : Object of layout\n\t     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n", "     cw         : Float of cathode width\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t     deepnwell  : Boolean of using Deep NWELL device\n\t     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n\t    \"\"\"\n\t    c = gf.Component(\"diode_nd2ps_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    # n generation\n", "    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    nplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n\t            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n\t    )\n", "    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = ncmp.xmin\n\t    diode_mk.ymin = ncmp.ymin\n\t    ncmp_con = c.add_ref(\n", "        via_stack(\n\t            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp_con\n\t    # p generation\n\t    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    pcmp.xmax = ncmp.xmin - comp_spacing\n", "    pplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n\t                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n", "    pplus.ymin = pcmp.ymin - pp_enc_comp\n\t    pcmp_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(pcmp.xmin, pcmp.xmax),\n\t            y_range=(pcmp.ymin, pcmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # pcomp_con\n\t    # labels generation\n", "    if lbl == 1:\n\t        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n\t                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n", "        # p_label generation\n\t        c.add_label(\n\t            p_lbl,\n\t            position=(\n\t                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n\t                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    if volt == \"5/6V\":\n", "        dg_enc_cmp = 0.24\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n\t                    ncmp.size[1] + (2 * dg_enc_cmp),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n", "        dg.xmin = pcmp.xmin - dg_enc_cmp\n\t        dg.ymin = pcmp.ymin - dg_enc_cmp\n\t    if deepnwell == 1:\n\t        lvpwell_enc_ncmp = 0.6\n\t        lvpwell_enc_pcmp = 0.16\n\t        lvpwell = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.xmax - pcmp.xmin + (lvpwell_enc_ncmp + lvpwell_enc_pcmp),\n\t                    ncmp.size[1] + (2 * lvpwell_enc_ncmp),\n", "                ),\n\t                layer=layer[\"lvpwell\"],\n\t            )\n\t        )\n\t        lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n\t        lvpwell.ymin = ncmp.ymin - lvpwell_enc_ncmp\n\t        dn_enc_lvpwell = 2.5\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n\t                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c_temp_gr = gf.Component(\"temp_store guard ring\")\n", "            pcmpgr_enc_dn = 2.5\n\t            rect_pcmpgr_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )\n", "            rect_pcmpgr_in.move(\n\t                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t            )\n\t            rect_pcmpgr_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n", "                )\n\t            )\n\t            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"comp\"],\n\t                )\n", "            )  # guardring Bulk draw\n\t            psdm_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n", "            psdm_in.move(\n\t                (\n\t                    rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                    rect_pcmpgr_in.ymin + pp_enc_comp,\n\t                )\n\t            )\n\t            psdm_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n", "                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_out.move(\n\t                (\n\t                    rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                    rect_pcmpgr_out.ymin - pp_enc_comp,\n\t                )\n", "            )\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t                )\n\t            )  # psdm draw\n\t            con_size = 0.22\n\t            con_sp = 0.28\n\t            con_comp_enc = 0.07\n\t            # generating contacts\n", "            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n", "                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # bottom contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n", "                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # upper contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                    y_range=(\n", "                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # right contact\n\t            c.add_ref(\n", "                via_generator(\n\t                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n", "                )\n\t            )  # left contact\n\t            comp_m1_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n", "                    size=(\n\t                        (comp_m1_in.size[0]) + 2 * cw,\n\t                        (comp_m1_in.size[1]) + 2 * cw,\n\t                    ),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n", "                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )  # guardring metal1\n\t    # creating layout and cell in klayout\n\t    c.write_gds(\"diode_nd2ps_temp.gds\")\n\t    layout.read(\"diode_nd2ps_temp.gds\")\n\t    cell_name = \"diode_nd2ps_dev\"\n", "    return layout.cell(cell_name)\n\tdef draw_diode_pd2nw(\n\t    layout,\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n", "    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw 3.3V P+/Nwell diode (Outside DNWELL) by specifying parameters\n\t    Arguments:-\n\t     layout     : Object of layout\n\t     la         : Float of diffusion length (anode)\n\t     wa         : Float of diffusion width (anode)\n", "     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t     deepnwell  : Boolean of using Deep NWELL device\n\t     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n\t    \"\"\"\n\t    c = gf.Component(\"diode_pd2nw_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n", "    con_comp_enc = 0.07\n\t    dg_enc_cmp = 0.24\n\t    dn_enc_nwell = 0.5\n\t    nwell_ncmp_enc = 0.12\n\t    nwell_pcmp_enc = 0.43\n\t    pcmpgr_enc_dn = 2.5\n\t    # p generation\n\t    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    pplus = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n\t                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n\t    pplus.ymin = pcmp.ymin - pp_enc_comp\n\t    diode_mk = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = pcmp.xmin\n\t    diode_mk.ymin = pcmp.ymin\n\t    pcmp_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(pcmp.xmin, pcmp.xmax),\n\t            y_range=(pcmp.ymin, pcmp.ymax),\n", "            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # pcomp_contact\n\t    # n generation\n\t    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    ncmp.xmax = pcmp.xmin - comp_spacing\n\t    nplus = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n\t            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n\t    )\n\t    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n\t    ncmp_con = c.add_ref(\n\t        via_stack(\n", "            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp contact\n\t    # labels generation\n\t    if lbl == 1:\n\t        # n_label generation\n\t        c.add_label(\n", "            n_lbl,\n\t            position=(\n\t                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n\t                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        # p_label generation\n\t        c.add_label(\n\t            p_lbl,\n", "            position=(\n\t                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n\t                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    pcmp.xmax - ncmp.xmin + (2 * dg_enc_cmp),\n\t                    ncmp.size[1] + (2 * dg_enc_cmp),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = ncmp.xmin - dg_enc_cmp\n\t        dg.ymin = ncmp.ymin - dg_enc_cmp\n\t    # nwell generation\n\t    nwell = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                pcmp.xmax - ncmp.xmin + (nwell_ncmp_enc + nwell_pcmp_enc),\n\t                pcmp.size[1] + (2 * nwell_pcmp_enc),\n\t            ),\n\t            layer=layer[\"nwell\"],\n\t        )\n\t    )\n\t    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n\t    nwell.ymin = pcmp.ymin - nwell_pcmp_enc\n", "    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    nwell.size[0] + (2 * dn_enc_nwell),\n\t                    nwell.size[1] + (2 * dn_enc_nwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n", "        dn_rect.xmin = nwell.xmin - dn_enc_nwell\n\t        dn_rect.ymin = nwell.ymin - dn_enc_nwell\n\t        if pcmpgr == 1:\n\t            c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t            rect_pcmpgr_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                    ),\n", "                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_in.move(\n\t                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t            )\n\t            rect_pcmpgr_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n", "                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n", "                    operation=\"A-B\",\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )  # Bulk guardring\n\t            psdm_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                    ),\n", "                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_in.move(\n\t                (\n\t                    rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                    rect_pcmpgr_in.ymin + pp_enc_comp,\n\t                )\n\t            )\n\t            psdm_out = c_temp_gr.add_ref(\n", "                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n\t                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_out.move(\n\t                (\n", "                    rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                    rect_pcmpgr_out.ymin - pp_enc_comp,\n\t                )\n\t            )\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t                )\n\t            )  # psdm guardring\n\t            # generating contacts\n", "            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n", "                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # bottom contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n", "                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # upper contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                    y_range=(\n", "                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # right contact\n\t            c.add_ref(\n", "                via_generator(\n\t                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n", "                )\n\t            )  # left contact\n\t            comp_m1_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n", "                    size=(\n\t                        (comp_m1_in.size[0]) + 2 * cw,\n\t                        (comp_m1_in.size[1]) + 2 * cw,\n\t                    ),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n\t            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n", "                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )  # guardring metal1\n\t    # creating layout and cell in klayout\n\t    c.write_gds(\"diode_pd2nw_temp.gds\")\n\t    layout.read(\"diode_pd2nw_temp.gds\")\n\t    cell_name = \"diode_pd2nw_dev\"\n", "    return layout.cell(cell_name)\n\tdef draw_diode_nw2ps(\n\t    layout,\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n", ") -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw 3.3V Nwell/Psub diode by specifying parameters\n\t    Arguments:-\n\t     layout     : Object of layout\n\t     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n\t     cw         : Float of Cathode width\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n", "    \"\"\"\n\t    c = gf.Component(\"diode_nw2ps_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    dg_enc_cmp = 0.24\n\t    nwell_ncmp_enc = 0.16\n\t    # n generation\n\t    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    nplus = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n\t            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n\t    )\n\t    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n", "    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = ncmp.xmin\n\t    diode_mk.ymin = ncmp.ymin\n\t    nwell = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                ncmp.size[0] + (2 * nwell_ncmp_enc),\n\t                ncmp.size[1] + (2 * nwell_ncmp_enc),\n\t            ),\n\t            layer=layer[\"nwell\"],\n\t        )\n\t    )\n\t    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n\t    nwell.ymin = ncmp.ymin - nwell_ncmp_enc\n\t    n_con = c.add_ref(\n\t        via_stack(\n", "            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp contact\n\t    # p generation\n\t    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    pcmp.xmax = ncmp.xmin - comp_spacing\n\t    pplus = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n\t                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n\t    pplus.ymin = pcmp.ymin - pp_enc_comp\n", "    p_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(pcmp.xmin, pcmp.xmax),\n\t            y_range=(pcmp.ymin, pcmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # pcmop contact\n\t    # labels generation\n\t    if lbl == 1:\n", "        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                n_con.xmin + (n_con.size[0] / 2),\n\t                n_con.ymin + (n_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        # p_label generation\n", "        c.add_label(\n\t            p_lbl,\n\t            position=(\n\t                p_con.xmin + (p_con.size[0] / 2),\n\t                p_con.ymin + (p_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n\t                    ncmp.size[1] + (2 * dg_enc_cmp),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = pcmp.xmin - dg_enc_cmp\n\t        dg.ymin = pcmp.ymin - dg_enc_cmp\n", "    # creating layout and cell in klayout\n\t    c.write_gds(\"diode_nw2ps_temp.gds\")\n\t    layout.read(\"diode_nw2ps_temp.gds\")\n\t    cell_name = \"diode_nw2ps_dev\"\n\t    return layout.cell(cell_name)\n\tdef draw_diode_pw2dw(\n\t    layout,\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n", "    volt: str = \"3.3V\",\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw LVPWELL/DNWELL diode by specifying parameters\n\t    Arguments:-\n", "     layout     : Object of layout\n\t     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n\t     cw         : Float of cathode width\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t    \"\"\"\n\t    c = gf.Component(\"diode_pw2dw_dev\")\n\t    comp_spacing: float = 0.48\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n", "    dg_enc_dn = 0.5\n\t    lvpwell_enc_pcmp = 0.16\n\t    dn_enc_lvpwell = 2.5\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    pcmpgr_enc_dn = 2.5\n\t    # p generation\n\t    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t    pplus = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                pcmp.size[0] + (2 * pp_enc_comp),\n\t                pcmp.size[1] + (2 * pp_enc_comp),\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    pplus.xmin = pcmp.xmin - pp_enc_comp\n\t    pplus.ymin = pcmp.ymin - pp_enc_comp\n", "    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = pcmp.xmin\n\t    diode_mk.ymin = pcmp.ymin\n\t    lvpwell = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                pcmp.size[0] + (2 * lvpwell_enc_pcmp),\n\t                pcmp.size[1] + (2 * lvpwell_enc_pcmp),\n\t            ),\n\t            layer=layer[\"lvpwell\"],\n\t        )\n\t    )\n\t    lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n\t    lvpwell.ymin = pcmp.ymin - lvpwell_enc_pcmp\n\t    p_con = c.add_ref(\n\t        via_stack(\n", "            x_range=(pcmp.xmin, pcmp.xmax),\n\t            y_range=(pcmp.ymin, pcmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # pcomp_contact\n\t    # n generation\n\t    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n\t    ncmp.xmax = pcmp.xmin - comp_spacing\n\t    nplus = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * np_enc_comp),\n\t                ncmp.size[1] + (2 * np_enc_comp),\n\t            ),\n\t            layer=layer[\"nplus\"],\n\t        )\n\t    )\n\t    nplus.xmin = ncmp.xmin - np_enc_comp\n\t    nplus.ymin = ncmp.ymin - np_enc_comp\n", "    n_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(ncmp.xmin, ncmp.xmax),\n\t            y_range=(ncmp.ymin, ncmp.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )  # ncomp contact\n\t    # labels generation\n\t    if lbl == 1:\n", "        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                n_con.xmin + (n_con.size[0] / 2),\n\t                n_con.ymin + (n_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        # p_label generation\n", "        c.add_label(\n\t            p_lbl,\n\t            position=(\n\t                p_con.xmin + (p_con.size[0] / 2),\n\t                p_con.ymin + (p_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    dn_rect = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                lvpwell.size[0] + (2 * dn_enc_lvpwell),\n\t                lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t            ),\n\t            layer=layer[\"dnwell\"],\n\t        )\n\t    )\n\t    dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t    dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t    if pcmpgr == 1:\n", "        c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t        rect_pcmpgr_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n", "        rect_pcmpgr_in.move(\n\t            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t        )\n\t        rect_pcmpgr_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"comp\"],\n", "            )\n\t        )\n\t        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n", "        )  # guardring Bulk\n\t        psdm_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n", "        psdm_in.move(\n\t            (\n\t                rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                rect_pcmpgr_in.ymin + pp_enc_comp,\n\t            )\n\t        )\n\t        psdm_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n", "                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n\t            (\n\t                rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                rect_pcmpgr_out.ymin - pp_enc_comp,\n\t            )\n", "        )\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )  # guardring psdm\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n", "                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n", "        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n", "                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # upper contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n", "                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                y_range=(\n", "                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n\t        comp_m1_in = c_temp_gr.add_ref(\n", "            gf.components.rectangle(\n\t                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n\t                    (comp_m1_in.size[1]) + 2 * cw,\n", "                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n", "                layer=layer[\"metal1\"],\n\t            )\n\t        )  # guardring metal1\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    dn_rect.size[0] + (2 * dg_enc_dn),\n\t                    dn_rect.size[1] + (2 * dg_enc_dn),\n\t                ),\n", "                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = dn_rect.xmin - dg_enc_dn\n\t        dg.ymin = dn_rect.ymin - dg_enc_dn\n\t    # creating layout and cell in klayout\n\t    c.write_gds(\"diode_pw2dw_temp.gds\")\n\t    layout.read(\"diode_pw2dw_temp.gds\")\n\t    cell_name = \"diode_pw2dw_dev\"\n\t    return layout.cell(cell_name)\n", "def draw_diode_dw2ps(\n\t    layout,\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n", ") -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw LVPWELL/DNWELL diode by specifying parameters\n\t    Arguments:-\n\t     layout     : Object of layout\n\t     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n\t     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n\t    \"\"\"\n", "    c = gf.Component(\"diode_dw2ps_dev\")\n\t    if volt == \"5/6V\":\n\t        dn_enc_ncmp = 0.66\n\t    else:\n\t        dn_enc_ncmp = 0.62\n\t    comp_spacing = 0.32\n\t    np_enc_comp: float = 0.16\n\t    pp_enc_comp: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n", "    con_comp_enc = 0.07\n\t    dg_enc_dn = 0.5\n\t    pcmpgr_enc_dn = 2.5\n\t    if (wa < ((2 * cw) + comp_spacing)) or (la < ((2 * cw) + comp_spacing)):\n\t        ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\t        n_con = c.add_ref(\n\t            via_stack(\n\t                x_range=(ncmp.xmin, ncmp.xmax),\n\t                y_range=(ncmp.ymin, ncmp.ymax),\n\t                base_layer=layer[\"comp\"],\n", "                metal_level=1,\n\t            )\n\t        )  # ncomp_contact\n\t        nplus = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.size[0] + (2 * np_enc_comp),\n\t                    ncmp.size[1] + (2 * np_enc_comp),\n\t                ),\n\t                layer=layer[\"nplus\"],\n", "            )\n\t        )\n\t        nplus.xmin = ncmp.xmin - np_enc_comp\n\t        nplus.ymin = ncmp.ymin - np_enc_comp\n\t    else:\n\t        c_temp = gf.Component(\"temp_store guard ring\")\n\t        ncmp_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(wa - (2 * cw), la - (2 * cw)),\n\t                layer=layer[\"comp\"],\n", "            )\n\t        )\n\t        ncmp_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(wa, la),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        ncmp_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n\t        ncmp = c.add_ref(\n", "            gf.geometry.boolean(\n\t                A=ncmp_out,\n\t                B=ncmp_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        pplus_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    (ncmp_in.xmax - ncmp_in.xmin) - 2 * pp_enc_comp,\n\t                    (ncmp_in.ymax - ncmp_in.ymin) - 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        pplus_in.move(\n\t            (\n\t                ncmp_in.xmin + pp_enc_comp,\n\t                ncmp_in.ymin + pp_enc_comp,\n", "            )\n\t        )\n\t        pplus_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (ncmp_out.xmax - ncmp_out.xmin) + 2 * pp_enc_comp,\n\t                    (ncmp_out.ymax - ncmp_out.ymin) + 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n", "        )\n\t        pplus_out.move(\n\t            (\n\t                ncmp_out.xmin - pp_enc_comp,\n\t                ncmp_out.ymin - pp_enc_comp,\n\t            )\n\t        )\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=pplus_out, B=pplus_in, operation=\"A-B\", layer=layer[\"nplus\"]\n", "            )\n\t        )  # nplus\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    ncmp_in.xmin + con_size,\n\t                    ncmp_in.xmax - con_size,\n\t                ),\n\t                y_range=(ncmp_out.ymin, ncmp_in.ymin),\n", "                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    ncmp_in.xmin + con_size,\n", "                    ncmp_in.xmax - con_size,\n\t                ),\n\t                y_range=(ncmp_in.ymax, ncmp_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # upper contact\n\t        n_con = c.add_ref(\n", "            via_generator(\n\t                x_range=(ncmp_out.xmin, ncmp_in.xmin),\n\t                y_range=(\n\t                    ncmp_in.ymin + con_size,\n\t                    ncmp_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n", "            )\n\t        )  # left contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(ncmp_in.xmax, ncmp_out.xmax),\n\t                y_range=(\n\t                    ncmp_in.ymin + con_size,\n\t                    ncmp_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n", "                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        comp_m1_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(ncmp_in.size[0], ncmp_in.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n", "        )\n\t        comp_m1_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n\t                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n", "        comp_m1_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=ncmp_out,\n\t                B=ncmp_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )  # guardring metal1\n\t    # labels generation\n", "    if lbl == 1:\n\t        # n_label generation\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                n_con.xmin + (n_con.size[0] / 2),\n\t                n_con.ymin + (n_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n", "    # generate dnwell\n\t    dn_rect = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                ncmp.size[0] + (2 * dn_enc_ncmp),\n\t                ncmp.size[1] + (2 * dn_enc_ncmp),\n\t            ),\n\t            layer=layer[\"dnwell\"],\n\t        )\n\t    )\n", "    dn_rect.xmin = ncmp.xmin - dn_enc_ncmp\n\t    dn_rect.ymin = ncmp.ymin - dn_enc_ncmp\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(dn_rect.size[0], dn_rect.size[1]), layer=layer[\"diode_mk\"]\n\t        )\n\t    )\n\t    diode_mk.xmin = dn_rect.xmin\n\t    diode_mk.ymin = dn_rect.ymin\n\t    if pcmpgr == 1:\n", "        c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t        rect_pcmpgr_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n", "        rect_pcmpgr_in.move(\n\t            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t        )\n\t        rect_pcmpgr_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"comp\"],\n", "            )\n\t        )\n\t        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n", "        )  # guardring Bulk\n\t        psdm_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n", "        psdm_in.move(\n\t            (\n\t                rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                rect_pcmpgr_in.ymin + pp_enc_comp,\n\t            )\n\t        )\n\t        psdm_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n", "                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n\t            (\n\t                rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                rect_pcmpgr_out.ymin - pp_enc_comp,\n\t            )\n", "        )\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )  # psdm\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n", "                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n", "        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n", "                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # upper contact\n\t        p_con = c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n", "                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                y_range=(\n", "                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        # labels generation\n", "        if lbl == 1:\n\t            # n_label generation\n\t            c.add_label(\n\t                p_lbl,\n\t                position=(\n\t                    p_con.xmin + (p_con.size[0] / 2),\n\t                    p_con.ymin + (p_con.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t            )\n", "        comp_m1_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n", "                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n", "                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )  # guardring metal1\n\t    # generate dualgate\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    dn_rect.size[0] + (2 * dg_enc_dn),\n", "                    dn_rect.size[1] + (2 * dg_enc_dn),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = dn_rect.xmin - dg_enc_dn\n\t        dg.ymin = dn_rect.ymin - dg_enc_dn\n\t    # creating layout and cell in klayout\n\t    c.write_gds(\"diode_dw2ps_temp.gds\")\n\t    layout.read(\"diode_dw2ps_temp.gds\")\n", "    cell_name = \"diode_dw2ps_dev\"\n\t    return layout.cell(cell_name)\n\tdef draw_sc_diode(\n\t    layout,\n\t    la: float = 0.1,\n\t    wa: float = 0.1,\n\t    cw: float = 0.1,\n\t    m: int = 1,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n", "    p_lbl: str = \"\",\n\t    n_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n\t    Arguments:-\n\t     layout     : Object of layout\n\t     la         : Float of diff length (anode)\n\t     wa         : Float of diff width (anode)\n", "     m          : Integer of number of fingers\n\t     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n\t    \"\"\"\n\t    c = gf.Component(\"sc_diode_dev\")\n\t    sc_enc_comp = 0.16\n\t    sc_comp_spacing = 0.28\n\t    dn_enc_sc_an = 1.4\n\t    np_enc_comp = 0.03\n\t    m1_w = 0.23\n\t    pcmpgr_enc_dn = 2.5\n", "    pp_enc_comp: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    # cathode draw\n\t    @gf.cell\n\t    def sc_cathode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n\t        \"\"\"Returns sc_diode cathode array element\n\t        Args :\n\t            size : size of cathode array element\n", "        \"\"\"\n\t        c = gf.Component()\n\t        ncmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\t        nplus = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    ncmp.size[0] + (2 * np_enc_comp),\n\t                    ncmp.size[1] + (2 * np_enc_comp),\n\t                ),\n\t                layer=layer[\"nplus\"],\n", "            )\n\t        )\n\t        nplus.xmin = ncmp.xmin - np_enc_comp\n\t        nplus.ymin = ncmp.ymin - np_enc_comp\n\t        c.add_ref(\n\t            via_stack(\n\t                x_range=(ncmp.xmin, ncmp.xmax),\n\t                y_range=(ncmp.ymin, ncmp.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n", "            )\n\t        )  # ncomp contact\n\t        return c\n\t    @gf.cell\n\t    def sc_anode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n\t        \"\"\"Returns sc_diode anode array element\n\t        Args :\n\t            size : size of anode array element\n\t        \"\"\"\n\t        c = gf.Component()\n", "        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\t        c.add_ref(\n\t            via_stack(\n\t                x_range=(cmp.xmin, cmp.xmax),\n\t                y_range=(cmp.ymin, cmp.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n\t            )\n\t        )  # comp contact\n\t        return c\n", "    sc_an = sc_anode_strap(size=(wa, la))\n\t    sc_cath = sc_cathode_strap(size=(cw, la))\n\t    sc_cathode = c.add_array(\n\t        component=sc_cath,\n\t        rows=1,\n\t        columns=(m + 1),\n\t        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n\t    )\n\t    cath_m1_polys = sc_cath.get_polygons(by_spec=layer[\"metal1\"])\n\t    cath_m1_xmin = np.min(cath_m1_polys[0][:, 0])\n", "    cath_m1_ymin = np.min(cath_m1_polys[0][:, 1])\n\t    cath_m1_xmax = np.max(cath_m1_polys[0][:, 0])\n\t    cath_m1_v = c.add_array(\n\t        component=gf.components.rectangle(\n\t            size=(\n\t                cath_m1_xmax - cath_m1_xmin,\n\t                cath_m1_ymin - sc_cathode.ymin + m1_w,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        ),\n", "        rows=1,\n\t        columns=(m + 1),\n\t        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n\t    )\n\t    cath_m1_v.xmin = cath_m1_xmin\n\t    cath_m1_v.ymax = cath_m1_ymin\n\t    cath_m1_h = c.add_ref(\n\t        gf.components.rectangle(size=(cath_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n\t    )\n\t    cath_m1_h.xmin = cath_m1_v.xmin\n", "    cath_m1_h.ymax = cath_m1_v.ymin\n\t    # cathode label generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            n_lbl,\n\t            position=(\n\t                cath_m1_h.xmin + (cath_m1_h.size[0] / 2),\n\t                cath_m1_h.ymin + (cath_m1_h.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n", "        )\n\t    sc_anode = c.add_array(\n\t        component=sc_an,\n\t        rows=1,\n\t        columns=m,\n\t        spacing=(wa + cw + (2 * sc_comp_spacing), 0),\n\t    )\n\t    sc_anode.xmin = sc_cathode.xmin + (cw + sc_comp_spacing)\n\t    an_m1_polys = sc_anode.get_polygons(by_spec=layer[\"metal1\"])\n\t    an_m1_xmin = np.min(an_m1_polys[0][:, 0])\n", "    an_m1_ymin = np.min(an_m1_polys[0][:, 1])\n\t    an_m1_xmax = np.max(an_m1_polys[0][:, 0])\n\t    an_m1_ymax = np.max(an_m1_polys[0][:, 1])\n\t    if m > 1:\n\t        an_m1_v = c.add_array(\n\t            component=gf.components.rectangle(\n\t                size=(\n\t                    an_m1_xmax - an_m1_xmin,\n\t                    cath_m1_ymin - sc_an.ymin + m1_w,\n\t                ),\n", "                layer=layer[\"metal1\"],\n\t            ),\n\t            rows=1,\n\t            columns=m,\n\t            spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n\t        )\n\t        an_m1_v.xmin = an_m1_xmin\n\t        an_m1_v.ymin = an_m1_ymax\n\t        an_m1_h = c.add_ref(\n\t            gf.components.rectangle(size=(an_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n", "        )\n\t        an_m1_h.xmin = an_m1_v.xmin\n\t        an_m1_h.ymin = an_m1_v.ymax\n\t        # anode label generation\n\t        if lbl == 1:\n\t            c.add_label(\n\t                p_lbl,\n\t                position=(\n\t                    an_m1_h.xmin + (an_m1_h.size[0] / 2),\n\t                    an_m1_h.ymin + (an_m1_h.size[1] / 2),\n", "                ),\n\t                layer=layer[\"metal1_label\"],\n\t            )\n\t    else:\n\t        # anode label generation\n\t        if lbl == 1:\n\t            c.add_label(\n\t                p_lbl,\n\t                position=(\n\t                    an_m1_xmin + ((an_m1_xmax - an_m1_xmin) / 2),\n", "                    an_m1_ymin + ((an_m1_ymax - an_m1_ymin) / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t            )\n\t    # diode_mk\n\t    diode_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                sc_cathode.size[0] + (2 * sc_enc_comp),\n\t                sc_cathode.size[1] + (2 * sc_enc_comp),\n", "            ),\n\t            layer=layer[\"schottky_diode\"],\n\t        )\n\t    )\n\t    diode_mk.xmin = sc_cathode.xmin - sc_enc_comp\n\t    diode_mk.ymin = sc_cathode.ymin - sc_enc_comp\n\t    # dnwell\n\t    dn_rect = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                sc_anode.size[0] + (2 * dn_enc_sc_an),\n\t                sc_anode.size[1] + (2 * dn_enc_sc_an),\n\t            ),\n\t            layer=layer[\"dnwell\"],\n\t        )\n\t    )\n\t    dn_rect.xmin = sc_anode.xmin - dn_enc_sc_an\n\t    dn_rect.ymin = sc_anode.ymin - dn_enc_sc_an\n\t    if pcmpgr == 1:\n\t        c_temp_gr = gf.Component(\"temp_store guard ring\")\n", "        rect_pcmpgr_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_pcmpgr_in.move(\n", "            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t        )\n\t        rect_pcmpgr_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n", "        )\n\t        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )  # guardring Bulk\n", "        psdm_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_in.move(\n", "            (\n\t                rect_pcmpgr_in.xmin + pp_enc_comp,\n\t                rect_pcmpgr_in.ymin + pp_enc_comp,\n\t            )\n\t        )\n\t        psdm_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n\t                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n", "                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n\t            (\n\t                rect_pcmpgr_out.xmin - pp_enc_comp,\n\t                rect_pcmpgr_out.ymin - pp_enc_comp,\n\t            )\n\t        )\n", "        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )  # psdm\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n", "                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # bottom contact\n\t        c.add_ref(\n", "            via_generator(\n\t                x_range=(\n\t                    rect_pcmpgr_in.xmin + con_size,\n\t                    rect_pcmpgr_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n", "            )\n\t        )  # upper contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n\t                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n", "                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                y_range=(\n\t                    rect_pcmpgr_in.ymin + con_size,\n", "                    rect_pcmpgr_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n\t        comp_m1_in = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n", "                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out = c_temp_gr.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (comp_m1_in.size[0]) + 2 * cw,\n\t                    (comp_m1_in.size[1]) + 2 * cw,\n\t                ),\n", "                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n\t        c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_pcmpgr_out,\n\t                B=rect_pcmpgr_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n", "            )\n\t        )  # guardring metal1\n\t    # creating layout and cell in klayout\n\t    c.write_gds(\"sc_diode_temp.gds\")\n\t    layout.read(\"sc_diode_temp.gds\")\n\t    cell_name = \"sc_diode_dev\"\n\t    return layout.cell(cell_name)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/res.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t# Resistor Generator for GF180MCU\n\t########################################################################################################################\n\timport os\n\timport pya\n\tfrom .draw_res import (\n\t    draw_metal_res,\n", "    draw_nplus_res,\n\t    draw_npolyf_res,\n\t    draw_pplus_res,\n\t    draw_ppolyf_res,\n\t    draw_ppolyf_u_high_Rs_res,\n\t    draw_well_res,\n\t)\n\trm1_l = 0.23\n\trm1_w = 0.23\n\trm2_3_l = 0.28\n", "rm2_3_w = 0.28\n\ttm6k_l = 0.36\n\ttm6k_w = 0.36\n\ttm9_11k_l = 0.44\n\ttm9_11k_w = 0.44\n\ttm30k_l = 1.8\n\ttm30k_w = 1.8\n\tnplus_s_l = 0.42\n\tnplus_s_w = 0.42\n\tpplus_s_l = 0.42\n", "pplus_s_w = 0.42\n\tnplus_u_l = 0.42\n\tnplus_u_w = 0.42\n\tpplus_u_l = 0.42\n\tpplus_u_w = 0.42\n\tnwell_l = 0.42\n\tnwell_w = 0.42\n\tpwell_l = 2.0\n\tpwell_w = 2.0\n\tnpolyf_s_l = 0.42\n", "npolyf_s_w = 0.42\n\tppolyf_s_l = 0.42\n\tppolyf_s_w = 0.42\n\tnpolyf_u_l = 0.42\n\tnpolyf_u_w = 0.42\n\tppolyf_u_l = 0.42\n\tppolyf_u_w = 0.42\n\tppolyf_u_h_res_l = 0.42\n\tppolyf_u_h_res_w = 0.42\n\tclass metal_resistor(pya.PCellDeclarationHelper):\n", "    \"\"\"\n\t    2-terminal Metal resistor Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.Type_handle = self.param(\"res_type\", self.TypeList, \"Metal resistor type\")\n\t        self.Type_handle.add_choice(\"rm1\", \"rm1\")\n\t        self.Type_handle.add_choice(\"rm2\", \"rm2\")\n", "        self.Type_handle.add_choice(\"rm3\", \"rm3\")\n\t        self.Type_handle.add_choice(\"tm6k\", \"tm6k\")\n\t        self.Type_handle.add_choice(\"tm9k\", \"tm9k\")\n\t        self.Type_handle.add_choice(\"tm11k\", \"tm11k\")\n\t        self.Type_handle.add_choice(\"tm30k\", \"tm30k\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Width\", default=rm1_l, unit=\"um\")\n\t        self.param(\"w_res\", self.TypeDouble, \"Length\", default=rm1_w, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Width\", default=rm1_l, unit=\"um\")\n\t        self.param(\"w_res\", self.TypeDouble, \"Length\", default=rm1_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n", "        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n", "        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"metal_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n", "        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        if (self.res_type) == \"rm1\":\n", "            self.l_res = max(self.l_res, rm1_l)\n\t            self.w_res = max(self.w_res, rm1_w)\n\t            self.l_res = max(self.l_res, rm1_l)\n\t            self.w_res = max(self.w_res, rm1_w)\n\t        if self.res_type in [\"rm2\", \"rm3\"]:\n\t            self.l_res = max(self.l_res, rm2_3_l)\n\t            self.w_res = max(self.w_res, rm2_3_w)\n\t        if (self.res_type) == \"tm6k\":\n\t            self.l_res = max(self.l_res, tm6k_l)\n\t            self.w_res = max(self.w_res, tm6k_w)\n", "        if self.res_type in [\"tm9k\", \"tm11k\"]:\n\t            self.l_res = max(self.l_res, tm9_11k_l)\n\t            self.w_res = max(self.w_res, tm9_11k_w)\n\t        if (self.res_type) == \"tm30k\":\n\t            self.l_res = max(self.l_res, tm30k_l)\n\t            self.w_res = max(self.w_res, tm30k_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n", "    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n", "        dbu_PERCISION = 1 / self.layout.dbu\n\t        option = os.environ[\"GF_PDK_OPTION\"]\n\t        if option == \"A\":\n\t            if self.res_type in [\"rm3\", \"tm6k\", \"tm9k\", \"tm11k\"]:\n\t                raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n\t        elif option == \"B\":\n\t            if self.res_type in [\"tm6k\", \"tm9k\", \"tm30k\"]:\n\t                raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n\t        elif self.res_type in [\"tm6k\", \"tm11k\", \"tm30k\"]:\n\t            raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n", "        np_instance = draw_metal_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n\t            res_type=self.res_type,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n", "            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass nplus_s_resistor(pya.PCellDeclarationHelper):\n", "    \"\"\"\n\t    3-terminal salicided n+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=nplus_s_l, unit=\"um\")\n", "        self.param(\"l_res\", self.TypeDouble, \"Length\", default=nplus_s_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n", "        )\n\t        self.param(\"sub\", self.TypeBoolean, \"Substrate terminal\", default=1)\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"nplus_s_resistor(L=\"\n", "            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n", "        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, nplus_s_l)\n\t        self.w_res = max(self.w_res, nplus_s_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n", "        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_nplus_res(\n\t            layout=self.layout,\n", "            l_res=self.l_res,\n\t            w_res=self.w_res,\n\t            res_type=\"nplus_s\",\n\t            sub=self.sub,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n", "        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n", "        self.cell.flatten(1)\n\tclass pplus_s_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3-terminal salicided P+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n", "        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=pplus_s_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=pplus_s_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n", "        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n", "            \"pplus_s_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n", "        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, pplus_s_l)\n\t        self.w_res = max(self.w_res, pplus_s_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n", "        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_pplus_res(\n", "            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n\t            res_type=\"pplus_s\",\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n", "        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n", "        self.cell.flatten(1)\n\tclass nplus_u_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3-terminal unsalicided n+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n", "        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=nplus_u_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=nplus_u_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n", "        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\"sub\", self.TypeBoolean, \"Substrate terminal\", default=1)\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n", "        return (\n\t            \"nplus_u_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n", "        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, nplus_u_l)\n\t        self.w_res = max(self.w_res, nplus_u_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n", "        np_instance = draw_nplus_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n\t            res_type=\"nplus_u\",\n\t            sub=self.sub,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n", "            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n", "        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass pplus_u_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3-terminal salicided P+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n", "        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=pplus_u_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=pplus_u_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n", "            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n", "        # Provide a descriptive text for the cell\n\t        return (\n\t            \"pplus_u_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n", "        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, pplus_u_l)\n\t        self.w_res = max(self.w_res, pplus_u_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n", "    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n", "        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_pplus_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n\t            res_type=\"pplus_u\",\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n", "            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n", "        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass nwell_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3-terminal Nwell resistor under STI (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n", "        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=nwell_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=nwell_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n", "        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n", "            \"nwell_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n", "        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, nwell_l)\n\t        self.w_res = max(self.w_res, nwell_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n", "        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_well_res(\n", "            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n\t            res_type=\"nwell\",\n\t            pcmpgr=0,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n", "        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n", "class pwell_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3-terminal Pwell resistor under STI (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=pwell_l, unit=\"um\")\n", "        self.param(\"l_res\", self.TypeDouble, \"Length\", default=pwell_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n", "        )\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"pwell_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n", "            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n", "        self.l_res = max(self.l_res, pwell_l)\n\t        self.w_res = max(self.w_res, pwell_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n", "        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_well_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n", "            w_res=self.w_res,\n\t            res_type=\"pwell\",\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n", "            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass npolyf_s_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n", "    3-terminal salicided n+ poly resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=npolyf_s_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=npolyf_s_w, unit=\"um\")\n", "        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n", "        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"npolyf_s_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n", "            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, npolyf_s_l)\n", "        self.w_res = max(self.w_res, npolyf_s_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n", "    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_npolyf_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n", "            res_type=\"npolyf_s\",\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n", "            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass ppolyf_s_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n", "    3-terminal salicided p+ poly resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=ppolyf_s_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=ppolyf_s_w, unit=\"um\")\n", "        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n", "        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"ppolyf_s_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n", "            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, ppolyf_s_l)\n", "        self.w_res = max(self.w_res, ppolyf_s_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n", "    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_ppolyf_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n", "            res_type=\"ppolyf_s\",\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n", "            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass npolyf_u_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n", "    3-terminal unsalicided n+ poly resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=npolyf_u_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=npolyf_u_w, unit=\"um\")\n", "        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n", "        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"npolyf_u_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n", "            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, npolyf_u_l)\n", "        self.w_res = max(self.w_res, npolyf_u_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n", "    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_npolyf_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n", "            res_type=\"npolyf_u\",\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n", "            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass ppolyf_u_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n", "    3-terminal unsalicided p+ poly resistor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"w_res\", self.TypeDouble, \"Width\", default=ppolyf_u_l, unit=\"um\")\n\t        self.param(\"l_res\", self.TypeDouble, \"Length\", default=ppolyf_u_w, unit=\"um\")\n", "        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n", "        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"ppolyf_u_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n", "            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, ppolyf_u_l)\n", "        self.w_res = max(self.w_res, ppolyf_u_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        #     # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        #     # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n", "    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_ppolyf_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n", "            res_type=\"ppolyf_u\",\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n", "            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass ppolyf_u_high_Rs_resistor(pya.PCellDeclarationHelper):\n\t    \"\"\"\n", "    high-Rs p+ poly resistor (outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n", "        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\n\t            \"w_res\", self.TypeDouble, \"Width\", default=ppolyf_u_h_res_l, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"l_res\", self.TypeDouble, \"Length\", default=ppolyf_u_h_res_w, unit=\"um\"\n\t        )\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n", "        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n\t        )\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\t        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n", "        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return (\n\t            \"ppolyf_u_high_Rs_resistor(L=\"\n\t            + (\"%.3f\" % self.l_res)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_res)\n\t            + \")\"\n\t        )\n", "    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_res * self.l_res\n\t        self.perim = 2 * (self.w_res + self.l_res)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_res = max(self.l_res, ppolyf_u_h_res_l)\n\t        self.w_res = max(self.w_res, ppolyf_u_h_res_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n", "        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.l_res = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n", "        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        dbu_PERCISION = 1 / self.layout.dbu\n\t        np_instance = draw_ppolyf_u_high_Rs_res(\n\t            layout=self.layout,\n\t            l_res=self.l_res,\n\t            w_res=self.w_res,\n\t            volt=self.volt,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n", "            lbl=self.lbl,\n\t            r0_lbl=self.r0_lbl,\n\t            r1_lbl=self.r1_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n\t            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n", "            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/efuse.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t# EFuse Generator for GF180MCU\n\t########################################################################################################################\n\timport pya\n\tfrom .draw_efuse import draw_efuse\n\tclass efuse(pya.PCellDeclarationHelper):\n\t    \"\"\"\n", "    eFuse Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Important: initialize the super class\n\t        super().__init__()\n\t        self.param(\n\t            \"Model\",\n\t            self.TypeString,\n\t            \"Model\",\n\t            default=\"gf180mcu_fd_pr__efuse\",\n", "            readonly=True,\n\t        )\n\t        self.param(\"array_x\", self.TypeInt, \"Elements in x_direction\", default=1)\n\t        self.param(\"array_y\", self.TypeInt, \"Elements in y_direction\", default=1)\n\t        self.param(\n\t            \"x_spacing\", self.TypeDouble, \"Spacing in x_direction\", default=1, unit=\"um\"\n\t        )\n\t        self.param(\n\t            \"y_spacing\", self.TypeDouble, \"Spacing in y_direction\", default=1, unit=\"um\"\n\t        )\n", "    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"efuse\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the\n\t        # numeric parameter has changed (by comparing against the effective\n\t        # radius ru) and set ru to the effective radius. We also update the\n\t        # numerical value or the shape, depending on which on has not changed.\n\t        pass\n\t    def can_create_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        # return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t        pass\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        # self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        # self.l = self.layout.get_info(self.layer)\n\t        pass\n", "    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        # return pya.Trans(self.shape.bbox().center())\n\t        pass\n\t    def produce_impl(self):\n\t        # This is the main part of the implementation: create the layout\n\t        self.percision = 1 / self.layout.dbu\n\t        efuse_instance = draw_efuse(layout=self.layout)\n\t        write_cells = pya.CellInstArray(\n", "            efuse_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(self.x_spacing * self.percision, 0),\n\t            pya.Vector(0, self.y_spacing * self.percision),\n\t            self.array_x,\n\t            self.array_y,\n\t        )\n\t        self.cell.flatten(1)\n\t        self.cell.insert(write_cells)\n\t        self.layout.cleanup()\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_cap_mim.py", "chunked_list": ["import gdsfactory as gf\n\tfrom .layers_def import layer\n\tfrom .via_generator import via_generator\n\tdef draw_cap_mim(\n\t    layout,\n\t    mim_option: str = \"A\",\n\t    metal_level: str = \"M4\",\n\t    lc: float = 2,\n\t    wc: float = 2,\n\t    lbl: bool = 0,\n", "    top_lbl: str = \"\",\n\t    bot_lbl: str = \"\",\n\t):\n\t    \"\"\"\n\t    Retern mim cap\n\t    Args:\n\t        layout : layout object\n\t        lc : float of cap length\n\t        wc : float of cap width\n\t    \"\"\"\n", "    c = gf.Component(\"mim_cap_dev\")\n\t    # used dimensions and layers\n\t    # MIM Option selection\n\t    if mim_option == \"MIM-B\":\n\t        if metal_level == \"M4\":\n\t            upper_layer = layer[\"metal4\"]\n\t            bottom_layer = layer[\"metal3\"]\n\t            via_layer = layer[\"via3\"]\n\t            up_lbl_layer = layer[\"metal4_label\"]\n\t            bot_lbl_layer = layer[\"metal3_label\"]\n", "        elif metal_level == \"M5\":\n\t            upper_layer = layer[\"metal5\"]\n\t            bottom_layer = layer[\"metal4\"]\n\t            via_layer = layer[\"via4\"]\n\t            up_lbl_layer = layer[\"metal5_label\"]\n\t            bot_lbl_layer = layer[\"metal4_label\"]\n\t        elif metal_level == \"M6\":\n\t            upper_layer = layer[\"metaltop\"]\n\t            bottom_layer = layer[\"metal5\"]\n\t            via_layer = layer[\"via5\"]\n", "            up_lbl_layer = layer[\"metaltop_label\"]\n\t            bot_lbl_layer = layer[\"metal5_label\"]\n\t    else:\n\t        upper_layer = layer[\"metal3\"]\n\t        bottom_layer = layer[\"metal2\"]\n\t        via_layer = layer[\"via2\"]\n\t        up_lbl_layer = layer[\"metal3_label\"]\n\t        bot_lbl_layer = layer[\"metal2_label\"]\n\t    via_size = (0.22, 0.22)\n\t    via_spacing = (0.5, 0.5)\n", "    via_enc = (0.4, 0.4)\n\t    bot_enc_top = 0.6\n\t    l_mk_w = 0.1\n\t    # drawing cap identifier and bottom , upper layers\n\t    m_up = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(wc, lc),\n\t            layer=upper_layer,\n\t        )\n\t    )\n", "    fusetop = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(m_up.size[0], m_up.size[1]), layer=layer[\"fusetop\"]\n\t        )\n\t    )\n\t    fusetop.xmin = m_up.xmin\n\t    fusetop.ymin = m_up.ymin\n\t    mim_l_mk = c.add_ref(\n\t        gf.components.rectangle(size=(fusetop.size[0], l_mk_w), layer=layer[\"mim_l_mk\"])\n\t    )\n", "    mim_l_mk.xmin = fusetop.xmin\n\t    mim_l_mk.ymin = fusetop.ymin\n\t    m_dn = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(m_up.size[0] + (2 * bot_enc_top), m_up.size[1] + (2 * bot_enc_top)),\n\t            layer=bottom_layer,\n\t        )\n\t    )\n\t    m_dn.xmin = m_up.xmin - bot_enc_top\n\t    m_dn.ymin = m_up.ymin - bot_enc_top\n", "    cap_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(m_dn.size[0], m_dn.size[1]), layer=layer[\"cap_mk\"]\n\t        )\n\t    )\n\t    cap_mk.xmin = m_dn.xmin\n\t    cap_mk.ymin = m_dn.ymin\n\t    # generating labels\n\t    if lbl == 1:\n\t        c.add_label(\n", "            top_lbl,\n\t            position=(m_up.xmin + (m_up.size[0] / 2), m_dn.xmin + (m_dn.size[1] / 2)),\n\t            layer=up_lbl_layer,\n\t        )\n\t        c.add_label(\n\t            bot_lbl,\n\t            position=(\n\t                m_dn.xmin + (m_dn.size[0] / 2),\n\t                m_dn.ymin + (m_up.ymin - m_dn.ymin) / 2,\n\t            ),\n", "            layer=bot_lbl_layer,\n\t        )\n\t    # generating vias\n\t    via = via_generator(\n\t        x_range=(m_up.xmin, m_up.xmax),\n\t        y_range=(m_up.ymin, m_up.ymax),\n\t        via_enclosure=via_enc,\n\t        via_layer=via_layer,\n\t        via_size=via_size,\n\t        via_spacing=via_spacing,\n", "    )\n\t    c.add_ref(via)\n\t    c.write_gds(\"mim_cap_temp.gds\")\n\t    layout.read(\"mim_cap_temp.gds\")\n\t    cell_name = \"mim_cap_dev\"\n\t    return layout.cell(cell_name)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_fet.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t## FET Pcells Generators for Klayout of GF180MCU\n\t########################################################################################################################\n\tfrom math import ceil, floor\n\timport gdsfactory as gf\n\tfrom gdsfactory.typings import Float2, LayerSpec\n\tfrom .layers_def import layer\n", "from .via_generator import via_generator, via_stack\n\t@gf.cell\n\tdef labels_gen(\n\t    lbl_str: str = \"\",\n\t    position: Float2 = (0.1, 0.1),\n\t    layer: LayerSpec = layer[\"metal1_label\"],\n\t    lbl: bool = 0,\n\t    lbl_lst: list = [],\n\t    lbl_valid_len: int = 1,\n\t    index: int = 0,\n", ") -> gf.Component:\n\t    \"\"\"Returns labels at given position when lbl is enabled\n\t    Args :\n\t        lbl_str : string of the label\n\t        position : position of the label\n\t        layer : layer of the label\n\t        lbl : boolean of having the label\n\t        lbl_lst : list of given labels\n\t        lbl_valid_len : valid length of labels\n\t    \"\"\"\n", "    c = gf.Component()\n\t    if lbl == 1 and len(lbl_lst) == lbl_valid_len:\n\t        if lbl_str == \"None\":\n\t            c.add_label(lbl_lst[index], position=position, layer=layer)\n\t        else:\n\t            c.add_label(lbl_str, position=position, layer=layer)\n\t    return c\n\tdef get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o):\n\t    \"\"\"Returns list of odd,even gate label patterns for alternating gate connection\n\t    Args :\n", "        nl_b : number of bottom connected gates transistors\n\t        nl : number of transistor\n\t        nt : patterns of tansistor [with out redundency]\n\t        nt_e : number of transistor with even order\n\t        g_lbl : list of transistors gate label\n\t        nl_u :  number of upper connected gates transistors\n\t        nt_o : number of transistor with odd order\n\t    \"\"\"\n\t    g_lbl_e = []\n\t    g_lbl_o = []\n", "    if nt == len(g_lbl):\n\t        for i in range(nl_b):\n\t            g_lbl_e.extend(g_lbl[j] for j in range(nl) if nt[j] == nt_e[i])\n\t        for i in range(nl_u):\n\t            g_lbl_o.extend(g_lbl[j] for j in range(nl) if nt[j] == nt_o[i])\n\t    return [g_lbl_e, g_lbl_o]\n\tdef alter_interdig(\n\t    sd_diff,\n\t    pc1,\n\t    pc2,\n", "    poly_con,\n\t    sd_diff_intr,\n\t    l_gate=0.15,\n\t    inter_sd_l=0.15,\n\t    sd_l=0.36,\n\t    nf=1,\n\t    pat=\"\",\n\t    pc_x=0.1,\n\t    pc_spacing=0.1,\n\t    lbl: bool = 0,\n", "    g_lbl: list = [],\n\t    nl: int = 1,\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"Returns interdigitation polygons of gate with alterating poly contacts\n\t    Args :\n\t        sd_diff : source/drain diffusion rectangle\n\t        pc1 : first poly contact array\n\t        pc2 : second poly contact array\n\t        poly_con : componenet of poly contact\n", "        sd_diff_inter : inter source/drain diffusion rectangle\n\t        l_gate : gate length\n\t        inter_sd_l : inter diffusion length\n\t        nf : number of fingers\n\t        pat : string of the required pattern\n\t    \"\"\"\n\t    c_inst = gf.Component()\n\t    m2_spacing = 0.28\n\t    via_size = (0.26, 0.26)\n\t    via_enc = (0.06, 0.06)\n", "    via_spacing = (0.26, 0.26)\n\t    pat_o = []\n\t    pat_e = []\n\t    for i in range(int(nf)):\n\t        if i % 2 == 0:\n\t            pat_e.append(pat[i])\n\t        else:\n\t            pat_o.append(pat[i])\n\t    nt = []\n\t    [nt.append(x) for x in pat if x not in nt]\n", "    nt_o = []\n\t    [nt_o.append(x) for x in pat_o if x not in nt_o]\n\t    nt_e = []\n\t    [nt_e.append(x) for x in pat_e if x not in nt_e]\n\t    nl = len(nt)\n\t    nl_b = len(nt_e)\n\t    nl_u = len(nt_o)\n\t    g_lbl_e, g_lbl_o = get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o)\n\t    m2_y = via_size[1] + 2 * via_enc[1]\n\t    m2 = gf.components.rectangle(\n", "        size=(sd_diff.xmax - sd_diff.xmin, m2_y),\n\t        layer=layer[\"metal2\"],\n\t    )\n\t    m2_arrb = c_inst.add_array(\n\t        component=m2,\n\t        columns=1,\n\t        rows=nl_b,\n\t        spacing=(0, -m2_y - m2_spacing),\n\t    )\n\t    m2_arrb.movey(pc1.ymin - m2_spacing - m2_y)\n", "    m2_arru = c_inst.add_array(\n\t        component=m2,\n\t        columns=1,\n\t        rows=nl_u,\n\t        spacing=(0, m2_y + m2_spacing),\n\t    )\n\t    m2_arru.movey(pc2.ymax + m2_spacing)\n\t    for i in range(nl_u):\n\t        for j in range(floor(nf / 2)):\n\t            if pat_o[j] == nt_o[i]:\n", "                m1 = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            pc_x,\n\t                            ((pc2.ymax + (i + 1) * (m2_spacing + m2_y)) - pc2.ymin),\n\t                        ),\n\t                        layer=layer[\"metal1\"],\n\t                    )\n\t                )\n\t                m1.xmin = pc2.xmin + j * (pc_spacing)\n", "                m1.ymin = pc2.ymin\n\t                via1_dr = via_generator(\n\t                    x_range=(m1.xmin, m1.xmax),\n\t                    y_range=(\n\t                        m2_arru.ymin + i * (m2_y + m2_spacing),\n\t                        m2_arru.ymin + i * (m2_y + m2_spacing) + m2_y,\n\t                    ),\n\t                    via_enclosure=via_enc,\n\t                    via_layer=layer[\"via1\"],\n\t                    via_size=via_size,\n", "                    via_spacing=via_spacing,\n\t                )\n\t                via1 = c_inst.add_ref(via1_dr)\n\t                c_inst.add_ref(\n\t                    labels_gen(\n\t                        lbl_str=\"None\",\n\t                        position=(\n\t                            (via1.xmax + via1.xmin) / 2,\n\t                            (via1.ymax + via1.ymin) / 2,\n\t                        ),\n", "                        layer=layer[\"metal2_label\"],\n\t                        lbl=patt_lbl,\n\t                        lbl_lst=pat_o,\n\t                        lbl_valid_len=len(pat_o),\n\t                        index=j,\n\t                    )\n\t                )\n\t                # adding gate_label\n\t                c_inst.add_ref(\n\t                    labels_gen(\n", "                        lbl_str=\"None\",\n\t                        position=(\n\t                            m1.xmin + (m1.size[0] / 2),\n\t                            pc2.ymin + (pc2.size[1] / 2),\n\t                        ),\n\t                        layer=layer[\"metal1_label\"],\n\t                        lbl=lbl,\n\t                        lbl_lst=g_lbl_o,\n\t                        lbl_valid_len=nl_u,\n\t                        index=i,\n", "                    )\n\t                )\n\t    for i in range(nl_b):\n\t        for j in range(ceil(nf / 2)):\n\t            if pat_e[j] == nt_e[i]:\n\t                m1 = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            pc_x,\n\t                            ((pc1.ymax + (i + 1) * (m2_spacing + m2_y)) - pc1.ymin),\n", "                        ),\n\t                        layer=layer[\"metal1\"],\n\t                    )\n\t                )\n\t                m1.xmin = pc1.xmin + j * (pc_spacing)\n\t                m1.ymin = -(m1.ymax - m1.ymin) + (pc1.ymax)\n\t                via1_dr = via_generator(\n\t                    x_range=(m1.xmin, m1.xmax),\n\t                    y_range=(\n\t                        m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n", "                        m2_arrb.ymax - i * (m2_spacing + m2_y),\n\t                    ),\n\t                    via_enclosure=via_enc,\n\t                    via_layer=layer[\"via1\"],\n\t                    via_size=via_size,\n\t                    via_spacing=via_spacing,\n\t                )\n\t                via1 = c_inst.add_ref(via1_dr)\n\t                c_inst.add_ref(\n\t                    labels_gen(\n", "                        lbl_str=\"None\",\n\t                        position=(\n\t                            (via1.xmax + via1.xmin) / 2,\n\t                            (via1.ymax + via1.ymin) / 2,\n\t                        ),\n\t                        layer=layer[\"metal2_label\"],\n\t                        lbl=patt_lbl,\n\t                        lbl_lst=pat_e,\n\t                        lbl_valid_len=len(pat_e),\n\t                        index=j,\n", "                    )\n\t                )\n\t                # adding gate_label\n\t                c_inst.add_ref(\n\t                    labels_gen(\n\t                        lbl_str=\"None\",\n\t                        position=(\n\t                            m1.xmin + (m1.size[0] / 2),\n\t                            pc1.ymin + (pc1.size[1] / 2),\n\t                        ),\n", "                        layer=layer[\"metal1_label\"],\n\t                        lbl=lbl,\n\t                        lbl_lst=g_lbl_e,\n\t                        lbl_valid_len=nl_b,\n\t                        index=i,\n\t                    )\n\t                )\n\t    m3_x = via_size[0] + 2 * via_enc[0]\n\t    m3_spacing = m2_spacing\n\t    for i in range(nl_b):\n", "        for j in range(nl_u):\n\t            if nt_e[i] == nt_o[j]:\n\t                m2_join_b = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n\t                            m2_y,\n\t                        ),\n\t                        layer=layer[\"metal2\"],\n\t                    ).move(\n", "                        (\n\t                            m2_arrb.xmin\n\t                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n\t                            m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n\t                        )\n\t                    )\n\t                )\n\t                m2_join_u = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n", "                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n\t                            m2_y,\n\t                        ),\n\t                        layer=layer[\"metal2\"],\n\t                    ).move(\n\t                        (\n\t                            m2_arru.xmin\n\t                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n\t                            m2_arru.ymin + j * (m2_spacing + m2_y),\n\t                        )\n", "                    )\n\t                )\n\t                m3 = c_inst.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(\n\t                            m3_x,\n\t                            m2_join_u.ymax - m2_join_b.ymin,\n\t                        ),\n\t                        layer=layer[\"metal1\"],\n\t                    )\n", "                )\n\t                m3.move((m2_join_b.xmin, m2_join_b.ymin))\n\t                via2_dr = via_generator(\n\t                    x_range=(m3.xmin, m3.xmax),\n\t                    y_range=(m2_join_b.ymin, m2_join_b.ymax),\n\t                    via_enclosure=via_enc,\n\t                    via_size=via_size,\n\t                    via_layer=layer[\"via1\"],\n\t                    via_spacing=via_spacing,\n\t                )\n", "                c_inst.add_array(\n\t                    component=via2_dr,\n\t                    columns=1,\n\t                    rows=2,\n\t                    spacing=(\n\t                        0,\n\t                        m2_join_u.ymin - m2_join_b.ymin,\n\t                    ),\n\t                )  # via2_draw\n\t    return c_inst\n", "def interdigit(\n\t    sd_diff,\n\t    pc1,\n\t    pc2,\n\t    poly_con,\n\t    sd_diff_intr,\n\t    l_gate: float = 0.15,\n\t    inter_sd_l: float = 0.23,\n\t    sd_l: float = 0.15,\n\t    nf=1,\n", "    patt=[\"\"],\n\t    gate_con_pos=\"top\",\n\t    pc_x=0.1,\n\t    pc_spacing=0.1,\n\t    lbl: bool = 0,\n\t    g_lbl: list = [],\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"Returns interdigitation related polygons\n\t    Args :\n", "        sd_diff : source/drain diffusion rectangle\n\t        pc1 : first poly contact array\n\t        pc2 : second poly contact array\n\t        poly_con : componenet of poly contact\n\t        sd_diff_inter : inter source/drain diffusion rectangle\n\t        l_gate : gate length\n\t        inter_sd_l : inter diffusion length\n\t        nf : number of fingers\n\t        pat : string of the required pattern\n\t        gate_con_pos : position of gate contact\n", "    \"\"\"\n\t    c_inst = gf.Component()\n\t    if nf == len(patt):\n\t        pat = list(patt)\n\t        nt = (\n\t            []\n\t        )  # list to store the symbols of transistors and thier number nt(number of transistors)\n\t        [nt.append(x) for x in pat if x not in nt]\n\t        nl = len(nt)\n\t        m2_spacing = 0.28\n", "        via_size = (0.26, 0.26)\n\t        via_enc = (0.06, 0.06)\n\t        via_spacing = (0.26, 0.26)\n\t        m2_y = via_size[1] + 2 * via_enc[1]\n\t        m2 = gf.components.rectangle(\n\t            size=(sd_diff.xmax - sd_diff.xmin, m2_y), layer=layer[\"metal2\"]\n\t        )\n\t        if gate_con_pos == \"alternating\":\n\t            c_inst.add_ref(\n\t                alter_interdig(\n", "                    sd_diff=sd_diff,\n\t                    pc1=pc1,\n\t                    pc2=pc2,\n\t                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n\t                    sd_l=sd_l,\n\t                    nf=nf,\n\t                    pat=pat,\n", "                    pc_x=pc_x,\n\t                    pc_spacing=pc_spacing,\n\t                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    nl=nl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n\t            )\n\t        elif gate_con_pos == \"top\":\n\t            m2_arr = c_inst.add_array(\n", "                component=m2,\n\t                columns=1,\n\t                rows=nl,\n\t                spacing=(0, m2.ymax - m2.ymin + m2_spacing),\n\t            )\n\t            m2_arr.movey(pc2.ymax + m2_spacing)\n\t            for i in range(nl):\n\t                for j in range(int(nf)):\n\t                    if pat[j] == nt[i]:\n\t                        m1 = c_inst.add_ref(\n", "                            gf.components.rectangle(\n\t                                size=(\n\t                                    pc_x,\n\t                                    (\n\t                                        (pc2.ymax + (i + 1) * (m2_spacing + m2_y))\n\t                                        - ((1 - j % 2) * pc1.ymin)\n\t                                        - (j % 2) * pc2.ymin\n\t                                    ),\n\t                                ),\n\t                                layer=layer[\"metal1\"],\n", "                            )\n\t                        )\n\t                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n\t                        m1.ymin = pc1.ymin\n\t                        via1_dr = via_generator(\n\t                            x_range=(m1.xmin, m1.xmax),\n\t                            y_range=(\n\t                                m2_arr.ymin + i * (m2_spacing + m2_y),\n\t                                m2_arr.ymin + i * (m2_spacing + m2_y) + m2_y,\n\t                            ),\n", "                            via_enclosure=via_enc,\n\t                            via_layer=layer[\"via1\"],\n\t                            via_size=via_size,\n\t                            via_spacing=via_spacing,\n\t                        )\n\t                        via1 = c_inst.add_ref(via1_dr)\n\t                        c_inst.add_ref(\n\t                            labels_gen(\n\t                                lbl_str=\"None\",\n\t                                position=(\n", "                                    (via1.xmax + via1.xmin) / 2,\n\t                                    (via1.ymax + via1.ymin) / 2,\n\t                                ),\n\t                                layer=layer[\"metal2_label\"],\n\t                                lbl=patt_lbl,\n\t                                lbl_lst=pat,\n\t                                lbl_valid_len=nl,\n\t                                index=j,\n\t                            )\n\t                        )\n", "                        # adding gate_label\n\t                        c_inst.add_ref(\n\t                            labels_gen(\n\t                                lbl_str=\"None\",\n\t                                position=(\n\t                                    m1.xmin + (m1.size[0] / 2),\n\t                                    pc1.ymin + (pc1.size[1] / 2),\n\t                                ),\n\t                                layer=layer[\"metal1_label\"],\n\t                                lbl=lbl,\n", "                                lbl_lst=g_lbl,\n\t                                lbl_valid_len=nl,\n\t                                index=i,\n\t                            )\n\t                        )\n\t        elif gate_con_pos == \"bottom\":\n\t            m2_arr = c_inst.add_array(\n\t                component=m2,\n\t                columns=1,\n\t                rows=nl,\n", "                spacing=(0, -m2_y - m2_spacing),\n\t            )\n\t            m2_arr.movey(pc2.ymin - m2_spacing - m2_y)\n\t            for i in range(nl):\n\t                for j in range(int(nf)):\n\t                    if pat[j] == nt[i]:\n\t                        m1 = c_inst.add_ref(\n\t                            gf.components.rectangle(\n\t                                size=(\n\t                                    pc_x,\n", "                                    (\n\t                                        (pc1.ymax + (i + 1) * (m2_spacing + m2_y))\n\t                                        - (j % 2) * pc1.ymin\n\t                                        - (1 - j % 2) * pc2.ymin\n\t                                    ),\n\t                                ),\n\t                                layer=layer[\"metal1\"],\n\t                            )\n\t                        )\n\t                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n", "                        m1.ymax = pc1.ymax\n\t                        via1_dr = via_generator(\n\t                            x_range=(m1.xmin, m1.xmax),\n\t                            y_range=(\n\t                                m2_arr.ymax - i * (m2_spacing + m2_y) - m2_y,\n\t                                m2_arr.ymax - i * (m2_spacing + m2_y),\n\t                            ),\n\t                            via_enclosure=via_enc,\n\t                            via_layer=layer[\"via1\"],\n\t                            via_size=via_size,\n", "                            via_spacing=via_spacing,\n\t                        )\n\t                        via1 = c_inst.add_ref(via1_dr)\n\t                        c_inst.add_ref(\n\t                            labels_gen(\n\t                                lbl_str=\"None\",\n\t                                position=(\n\t                                    (via1.xmax + via1.xmin) / 2,\n\t                                    (via1.ymax + via1.ymin) / 2,\n\t                                ),\n", "                                layer=layer[\"metal2_label\"],\n\t                                lbl=patt_lbl,\n\t                                lbl_lst=pat,\n\t                                lbl_valid_len=nl,\n\t                                index=j,\n\t                            )\n\t                        )\n\t                        # adding gate_label\n\t                        c_inst.add_ref(\n\t                            labels_gen(\n", "                                lbl_str=\"None\",\n\t                                position=(\n\t                                    m1.xmin + (m1.size[0] / 2),\n\t                                    pc1.ymin + (pc1.size[1] / 2),\n\t                                ),\n\t                                layer=layer[\"metal1_label\"],\n\t                                lbl=lbl,\n\t                                lbl_lst=g_lbl,\n\t                                lbl_valid_len=nl,\n\t                                index=i,\n", "                            )\n\t                        )\n\t    return c_inst\n\t# @gf.cell\n\tdef hv_gen(c, c_inst, volt, dg_encx: float = 0.1, dg_ency: float = 0.1):\n\t    \"\"\"Returns high volatge related polygons\n\t    Args :\n\t        c_inst : dualgate enclosed componenet\n\t        volt : operating voltage\n\t        dg_encx : dualgate enclosure in x_direction\n", "        dg_ency : dualgate enclosure in y_direction\n\t    \"\"\"\n\t    # c = gf.Component()\n\t    if volt in [\"5V\", \"6V\"]:\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    c_inst.size[0] + (2 * dg_encx),\n\t                    c_inst.size[1] + (2 * dg_ency),\n\t                ),\n", "                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = c_inst.xmin - dg_encx\n\t        dg.ymin = c_inst.ymin - dg_ency\n\t    if volt == \"5V\":\n\t        v5x = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n\t            )\n", "        )\n\t        v5x.xmin = dg.xmin\n\t        v5x.ymin = dg.ymin\n\t    # return c\n\t# @gf.cell\n\tdef bulk_gr_gen(\n\t    c,\n\t    c_inst,\n\t    comp_spacing: float = 0.1,\n\t    poly2_comp_spacing: float = 0.1,\n", "    volt: str = \"3.3V\",\n\t    grw: float = 0.36,\n\t    l_d: float = 0.1,\n\t    implant_layer: LayerSpec = layer[\"pplus\"],\n\t    lbl: bool = 0,\n\t    sub_lbl: str = \"\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    nw_enc_pcmp: float = 0.1,\n\t    m1_sp: float = 0.1,\n", "):\n\t    \"\"\"Returns guardring\n\t    Args :\n\t        c_inst : componenet enclosed by guardring\n\t        comp_spacing : spacing between comp polygons\n\t        poly2_comp_spacing : spacing between comp and poly2 polygons\n\t        volt : operating voltage\n\t        grw : guardring width\n\t        l_d : total diffusion length\n\t        implant_layer : layer of comp implant (nplus,pplus)\n", "    \"\"\"\n\t    # c = gf.Component()\n\t    comp_pp_enc: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    dg_enc_cmp = 0.24\n\t    c_temp = gf.Component(\"temp_store\")\n\t    rect_bulk_in = c_temp.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                (c_inst.xmax - c_inst.xmin) + 2 * m1_sp,\n\t                (c_inst.ymax - c_inst.ymin) + 2 * m1_sp,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_bulk_in.move((c_inst.xmin - m1_sp, c_inst.ymin - m1_sp))\n\t    rect_bulk_out = c_temp.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n\t    B = c.add_ref(\n\t        gf.geometry.boolean(\n", "            A=rect_bulk_out,\n\t            B=rect_bulk_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    psdm_in = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n", "                (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n\t    psdm_out = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n", "                (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    psdm_out.move(\n\t        (\n\t            rect_bulk_out.xmin - comp_pp_enc,\n\t            rect_bulk_out.ymin - comp_pp_enc,\n\t        )\n", "    )\n\t    c.add_ref(\n\t        gf.geometry.boolean(A=psdm_out, B=psdm_in, operation=\"A-B\", layer=implant_layer)\n\t    )  # implant_draw(pplus or nplus)\n\t    # generating contacts\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_bulk_in.xmin + con_size,\n\t                rect_bulk_in.xmax - con_size,\n", "            ),\n\t            y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # bottom contact\n\t    c.add_ref(\n\t        via_generator(\n", "            x_range=(\n\t                rect_bulk_in.xmin + con_size,\n\t                rect_bulk_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n", "    )  # upper contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n\t            y_range=(\n\t                rect_bulk_in.ymin + con_size,\n\t                rect_bulk_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n", "            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # right contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n\t            y_range=(\n\t                rect_bulk_in.ymin + con_size,\n\t                rect_bulk_in.ymax - con_size,\n", "            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # left contact\n\t    comp_m1_in = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                (l_d) + 2 * comp_spacing,\n\t                (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n\t    comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n\t    comp_m1_out = c_temp.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n\t    comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n\t    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=rect_bulk_out,\n", "            B=rect_bulk_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )  # metal1_gaurdring\n\t    hv_gen(c, c_inst=B, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_cmp)\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=sub_lbl,\n\t            position=(\n", "                B.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n\t                B.ymin + (B.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            lbl_lst=[sub_lbl],\n\t            lbl_valid_len=1,\n\t        )\n\t    )\n\t    if implant_layer == layer[\"pplus\"]:\n", "        c.add_ref(\n\t            nfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                inst_size=(B.size[0], B.size[1]),\n\t                inst_xmin=B.xmin,\n\t                inst_ymin=B.ymin,\n\t                grw=grw,\n\t                volt=volt,\n\t            )\n", "        )\n\t    else:\n\t        c.add_ref(\n\t            pfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                enc_size=(B.size[0], B.size[1]),\n\t                enc_xmin=B.xmin,\n\t                enc_ymin=B.ymin,\n\t                nw_enc_pcmp=nw_enc_pcmp,\n", "                grw=grw,\n\t                volt=volt,\n\t            )\n\t        )\n\t    # return c\n\t@gf.cell\n\tdef pcmpgr_gen(dn_rect, grw: float = 0.36) -> gf.Component:\n\t    \"\"\"Return deepnwell guardring\n\t    Args :\n\t        dn_rect : deepnwell polygon\n", "        grw : guardring width\n\t    \"\"\"\n\t    c = gf.Component()\n\t    comp_pp_enc: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    pcmpgr_enc_dn = 2.5\n\t    c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t    rect_pcmpgr_in = c_temp_gr.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_pcmpgr_in.move((dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn))\n\t    rect_pcmpgr_out = c_temp_gr.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n\t                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t    c.add_ref(\n", "        gf.geometry.boolean(\n\t            A=rect_pcmpgr_out,\n\t            B=rect_pcmpgr_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )  # guardring bulk\n\t    psdm_in = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n\t                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    psdm_in.move(\n\t        (\n\t            rect_pcmpgr_in.xmin + comp_pp_enc,\n\t            rect_pcmpgr_in.ymin + comp_pp_enc,\n", "        )\n\t    )\n\t    psdm_out = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n\t                (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n", "    )\n\t    psdm_out.move(\n\t        (\n\t            rect_pcmpgr_out.xmin - comp_pp_enc,\n\t            rect_pcmpgr_out.ymin - comp_pp_enc,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n", "        )\n\t    )  # pplus_draw\n\t    # generating contacts\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_pcmpgr_in.xmin + con_size,\n\t                rect_pcmpgr_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n", "            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # bottom contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_pcmpgr_in.xmin + con_size,\n", "                rect_pcmpgr_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # upper contact\n\t    c.add_ref(\n", "        via_generator(\n\t            x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t            y_range=(\n\t                rect_pcmpgr_in.ymin + con_size,\n\t                rect_pcmpgr_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n", "        )\n\t    )  # right contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t            y_range=(\n\t                rect_pcmpgr_in.ymin + con_size,\n\t                rect_pcmpgr_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n", "            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # left contact\n\t    comp_m1_in = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t            layer=layer[\"metal1\"],\n\t        )\n", "    )\n\t    comp_m1_out = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (comp_m1_in.size[0]) + 2 * grw,\n\t                (comp_m1_in.size[1]) + 2 * grw,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n", "    comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=rect_pcmpgr_out,\n\t            B=rect_pcmpgr_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )  # metal1 guardring\n\t    return c\n", "@gf.cell\n\tdef nfet_deep_nwell(\n\t    volt=\"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    inst_size: Float2 = (0.1, 0.1),\n\t    inst_xmin: float = 0.1,\n\t    inst_ymin: float = 0.1,\n\t    grw: float = 0.36,\n\t) -> gf.Component:\n", "    \"\"\"Return nfet deepnwell\n\t    Args :\n\t        deepnwell : boolean of having deepnwell\n\t        pcmpgr : boolean of having deepnwell guardring\n\t        inst_size : deepnwell enclosed size\n\t        inst_xmin : deepnwell enclosed xmin\n\t        inst_ymin : deepnwell enclosed ymin\n\t        grw : guardring width\n\t    \"\"\"\n\t    c = gf.Component()\n", "    if deepnwell == 1:\n\t        lvpwell_enc_ncmp = 0.44\n\t        lvp_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    inst_size[0] + (2 * lvpwell_enc_ncmp),\n\t                    inst_size[1] + (2 * lvpwell_enc_ncmp),\n\t                ),\n\t                layer=layer[\"lvpwell\"],\n\t            )\n", "        )\n\t        lvp_rect.ymin = inst_ymin - lvpwell_enc_ncmp\n\t        dn_enc_lvpwell = 2.5\n\t        lvp_rect.xmin = inst_xmin - lvpwell_enc_ncmp\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n\t                    lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n", "                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\t        if volt in [\"5V\", \"6V\"]:\n\t            dg_enc_dn = 0.5\n\t            dg = c.add_ref(\n", "                gf.components.rectangle(\n\t                    size=(\n\t                        dn_rect.size[0] + (2 * dg_enc_dn),\n\t                        dn_rect.size[1] + (2 * dg_enc_dn),\n\t                    ),\n\t                    layer=layer[\"dualgate\"],\n\t                )\n\t            )\n\t            dg.xmin = dn_rect.xmin - dg_enc_dn\n\t            dg.ymin = dn_rect.ymin - dg_enc_dn\n", "    elif volt in [\"5V\", \"6V\"]:\n\t        dg_enc_cmp = 0.24\n\t        dg_enc_poly = 0.4\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    inst_size[0] + (2 * dg_enc_cmp),\n\t                    inst_size[1] + (2 * dg_enc_poly),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n", "            )\n\t        )\n\t        dg.xmin = inst_xmin - dg_enc_cmp\n\t        dg.ymin = inst_ymin - dg_enc_poly\n\t    if volt == \"5V\":\n\t        v5x = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n\t            )\n\t        )\n", "        v5x.xmin = dg.xmin\n\t        v5x.ymin = dg.ymin\n\t    return c\n\tdef add_inter_sd_labels(\n\t    c, nf, sd_lbl, poly1, l_gate, inter_sd_l, sd_diff_intr, lbl, layer, con_bet_fin\n\t):\n\t    \"\"\"Adds label to intermediate source/drain diffusion\n\t    Args :\n\t        c : instance componenet of the device\n\t        nf : number of fingers\n", "        sd_lbl : required source and drain labels list\n\t        poly1 : componenet of poly array\n\t        l_gate : length of fet gate\n\t        inter_sd_l : length of intermediate source/drain diffusion\n\t        sd_diff_inter : componenet of intermediate source/drain polygon\n\t        lbl: boolean of having labels\n\t        layer : layer of label\n\t        con_bet_fin : boolean of having contact between fingers\n\t    \"\"\"\n\t    lbl_layer = layer[\"metal1_label\"] if con_bet_fin == 1 else layer[\"comp_label\"]\n", "    for i in range(int(nf - 1)):\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(\n\t                    poly1.xmin + l_gate + (inter_sd_l / 2) + i * (l_gate + inter_sd_l),\n\t                    sd_diff_intr.ymin + (sd_diff_intr.size[1] / 2),\n\t                ),\n\t                layer=lbl_layer,\n\t                lbl=lbl,\n", "                lbl_lst=sd_lbl,\n\t                lbl_valid_len=nf + 1,\n\t                index=i + 1,\n\t            )\n\t        )\n\tdef add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf):\n\t    \"\"\"Adds gate label when lbl is enabled\n\t    Args :\n\t        c : instance componenet of the device\n\t        g_lbl : required gate labels list\n", "        pc1 : componenet of poly array1\n\t        c_pc : componenet of poly array element\n\t        pc_spacing : float of space between labels\n\t        nc1 : number of columns in poly array1\n\t        nc2 : number of columns in poly array2\n\t        pc2 : componenet of poly array2\n\t        lbl : boolean of having labels\n\t        layer : layer of labels\n\t        nf : number of fingers\n\t    \"\"\"\n", "    for i in range(nc1):\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(\n\t                    pc1.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n\t                    pc1.ymin + (c_pc.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n", "                lbl_lst=g_lbl,\n\t                lbl_valid_len=nf,\n\t                index=2 * i,\n\t            )\n\t        )\n\t    for i in range(nc2):\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(\n", "                    pc2.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n\t                    pc2.ymin + (c_pc.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                lbl_lst=g_lbl,\n\t                lbl_valid_len=nf,\n\t                index=(2 * i) + 1,\n\t            )\n\t        )\n", "def sd_m1_area_check(\n\t    sd_con_area, m1_area, sd_con, c_inst, sd_l, nf, l_gate, inter_sd_l, pl_cmp_spacing\n\t):\n\t    if sd_con_area < m1_area:\n\t        sd_con_m1 = gf.components.rectangle(\n\t            size=(sd_con.size[0], m1_area / sd_con.size[1]), layer=layer[\"metal1\"]\n\t        )\n\t        sd_m1_arr = c_inst.add_array(\n\t            component=sd_con_m1,\n\t            columns=2,\n", "            rows=1,\n\t            spacing=(\n\t                sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n\t                0,\n\t            ),\n\t        )\n\t        sd_m1_arr.xmin = sd_con.xmin\n\t        sd_m1_arr.ymin = sd_con.ymin - (sd_con_m1.size[1] - sd_con.size[1]) / 2\n\tdef poly_con_m1_check(poly_con_area, m1_area, c_pc, poly_con, c_pl_con):\n\t    if poly_con_area < m1_area:\n", "        m1_poly = c_pc.add_ref(\n\t            gf.components.rectangle(\n\t                size=(m1_area / poly_con.size[0], poly_con.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        m1_poly.xmin = c_pl_con.xmin - (m1_poly.size[0] - poly_con.size[0]) / 2\n\t        m1_poly.ymin = c_pl_con.ymin\n\tdef inter_sd_m1_area_check(\n\t    inter_sd_con_area, m1_area, inter_sd_con, c_inst, l_gate, nf, inter_sd_l, sd_con\n", "):\n\t    if inter_sd_con_area < m1_area:\n\t        inter_sd_con_m1 = gf.components.rectangle(\n\t            size=(inter_sd_con.size[0], m1_area / inter_sd_con.size[1]),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t        inter_sd_m1_arr = c_inst.add_array(\n\t            component=inter_sd_con_m1,\n\t            columns=nf - 1,\n\t            rows=1,\n", "            spacing=(l_gate + inter_sd_l, 0),\n\t        )\n\t        inter_sd_m1_arr.xmin = inter_sd_con.xmin\n\t        inter_sd_m1_arr.ymin = (\n\t            inter_sd_con.ymin - (inter_sd_con_m1.size[1] - sd_con.size[1]) / 2\n\t        )\n\tdef bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con):\n\t    if bulk_con_area < m1_area:\n\t        bulk_m1 = c_inst.add_ref(\n\t            gf.components.rectangle(\n", "                size=(bulk_con.size[0], m1_area / bulk_con.size[1]),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        bulk_m1.xmin = bulk_con.xmin\n\t        bulk_m1.ymin = bulk_con.ymin - (bulk_m1.size[1] - bulk_con.size[1]) / 2\n\t# @gf.cell\n\tdef draw_nfet(\n\t    layout,\n\t    l_gate: float = 0.28,\n", "    w_gate: float = 0.22,\n\t    sd_con_col: int = 1,\n\t    inter_sd_l: float = 0.24,\n\t    nf: int = 1,\n\t    grw: float = 0.22,\n\t    volt: str = \"3.3V\",\n\t    bulk=\"None\",\n\t    con_bet_fin: int = 1,\n\t    gate_con_pos=\"alternating\",\n\t    interdig: int = 0,\n", "    patt=\"\",\n\t    deepnwell: int = 0,\n\t    pcmpgr: int = 0,\n\t    lbl: bool = 0,\n\t    sd_lbl: list = [],\n\t    g_lbl: str = [],\n\t    sub_lbl: str = \"\",\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"\n", "    Retern nfet\n\t    Args:\n\t        layout : layout object\n\t        l : Float of gate length\n\t        w : Float of gate width\n\t        sd_l : Float of source and drain diffusion length\n\t        inter_sd_l : Float of source and drain diffusion length between fingers\n\t        nf : integer of number of fingers\n\t        M : integer of number of multipliers\n\t        grw : gaurd ring width when enabled\n", "        type : string of the device type\n\t        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n\t        con_bet_fin : boolean of having contacts for diffusion between fingers\n\t        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n\t    \"\"\"\n\t    # used layers and dimensions\n\t    end_cap: float = 0.3\n\t    if volt == \"3.3V\":\n\t        comp_spacing: float = 0.28\n\t    else:\n", "        comp_spacing: float = 0.36\n\t    gate_np_enc: float = 0.23\n\t    comp_np_enc: float = 0.16\n\t    comp_pp_enc: float = 0.16\n\t    poly2_spacing: float = 0.24\n\t    pc_ext: float = 0.04\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    con_pp_sp = 0.1 - con_comp_enc\n", "    con_pl_enc = 0.07\n\t    pl_cmp_spacing = 0.18\n\t    m1_area = 0.145\n\t    m1_sp = 0.3\n\t    pl_cmpcon_sp = 0.15\n\t    sd_l_con = (\n\t        ((sd_con_col) * con_size)\n\t        + ((sd_con_col - 1) * con_sp)\n\t        + 2 * con_comp_enc\n\t        + 2 * con_pp_sp\n", "    )\n\t    sd_l = sd_l_con\n\t    # gds components to store a single instance and the generated device\n\t    c = gf.Component(\"sky_nfet_dev\")\n\t    c_inst = gf.Component(\"dev_temp\")\n\t    # generating sd diffusion\n\t    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n\t        nf = len(patt)\n\t    l_d = (\n\t        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing)\n", "    )  # diffution total length\n\t    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n\t    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\t    #     # generatin sd contacts\n\t    if w_gate <= con_size + 2 * con_comp_enc:\n\t        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\t        np_cmp_ency = comp_np_enc\n\t    else:\n\t        cmpc_y = w_gate\n\t        np_cmp_ency = gate_np_enc\n", "    cmpc_size = (sd_l_con, cmpc_y)\n\t    sd_diff = c_inst.add_array(\n\t        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n\t    )\n\t    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n\t    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\t    sd_con = via_stack(\n", "        x_range=(sd_diff.xmin + con_pp_sp, sd_diff_intr.xmin - con_pp_sp),\n\t        y_range=(sd_diff.ymin, sd_diff.ymax),\n\t        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n\t    )\n\t    sd_con_arr = c_inst.add_array(\n\t        component=sd_con,\n\t        columns=2,\n\t        rows=1,\n\t        spacing=(\n", "            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n\t            0,\n\t        ),\n\t    )\n\t    sd_con_area = sd_con.size[0] * sd_con.size[1]\n\t    sd_m1_area_check(\n\t        sd_con_area,\n\t        m1_area,\n\t        sd_con,\n\t        c_inst,\n", "        sd_l,\n\t        nf,\n\t        l_gate,\n\t        inter_sd_l,\n\t        pl_cmp_spacing,\n\t    )\n\t    if con_bet_fin == 1 and nf > 1:\n\t        inter_sd_con = via_stack(\n\t            x_range=(\n\t                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + pl_cmpcon_sp,\n", "                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + inter_sd_l - pl_cmpcon_sp,\n\t            ),\n\t            y_range=(0, w_gate),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t        c_inst.add_array(\n\t            component=inter_sd_con,\n\t            columns=nf - 1,\n\t            rows=1,\n", "            spacing=(l_gate + inter_sd_l, 0),\n\t        )\n\t        inter_sd_con_area = inter_sd_con.size[0] * inter_sd_con.size[1]\n\t        inter_sd_m1_area_check(\n\t            inter_sd_con_area,\n\t            m1_area,\n\t            inter_sd_con,\n\t            c_inst,\n\t            l_gate,\n\t            nf,\n", "            inter_sd_l,\n\t            sd_con,\n\t        )\n\t    ### adding source/drain labels\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n", "            lbl_lst=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=0,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n", "            lbl=lbl,\n\t            lbl_lst=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=nf,\n\t        )\n\t    )\n\t    # generating poly\n\t    if l_gate <= con_size + 2 * con_pl_enc:\n\t        pc_x = con_pl_enc + con_size + con_pl_enc\n\t    else:\n", "        pc_x = l_gate\n\t    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\t    c_pc = gf.Component(\"poly con\")\n\t    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\t    poly_con = via_stack(\n\t        x_range=(rect_pc.xmin, rect_pc.xmax),\n\t        y_range=(rect_pc.ymin, rect_pc.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t        li_enc_dir=\"H\",\n", "    )\n\t    c_pl_con = c_pc.add_ref(poly_con)\n\t    poly_con_area = poly_con.size[0] * poly_con.size[1]\n\t    poly_con_m1_check(poly_con_area, m1_area, c_pc, poly_con, c_pl_con)\n\t    if nf == 1:\n\t        poly = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n\t            )\n\t        )\n", "        poly.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n\t        poly.ymin = sd_diff_intr.ymin - end_cap\n\t        if gate_con_pos == \"bottom\":\n\t            mv = 0\n\t            nr = 1\n\t        elif gate_con_pos == \"top\":\n\t            mv = pc_size[1] + w_gate + 2 * end_cap\n\t            nr = 1\n\t        else:\n\t            mv = 0\n", "            nr = 2\n\t        pc = c_inst.add_array(\n\t            component=c_pc,\n\t            rows=nr,\n\t            columns=1,\n\t            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n\t        )\n\t        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\t        # gate_lablel\n\t        c.add_ref(\n", "            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                lbl_lst=g_lbl,\n\t                lbl_valid_len=nf,\n\t                index=0,\n\t            )\n\t        )\n", "    else:\n\t        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\t        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n\t            if gate_con_pos == \"alternating\":\n\t                w_p1 += 0.2\n\t                w_p2 = w_p1\n\t                e_c = 0.2\n\t            else:\n\t                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n\t                e_c = 0\n", "            if gate_con_pos == \"bottom\":\n\t                p_mv = -end_cap - (w_p2 - w_p1)\n\t            else:\n\t                p_mv = -end_cap\n\t        else:\n\t            w_p2 = w_p1\n\t            p_mv = -end_cap\n\t            e_c = 0\n\t        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n\t        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n", "        poly1 = c_inst.add_array(\n\t            rect_p1,\n\t            rows=1,\n\t            columns=ceil(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly1.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n\t        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\t        poly2 = c_inst.add_array(\n\t            rect_p2,\n", "            rows=1,\n\t            columns=floor(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n\t        poly2.ymin = p_mv\n\t        # generating poly contacts setups\n\t        if gate_con_pos == \"bottom\":\n\t            mv_1 = 0\n\t            mv_2 = -(w_p2 - w_p1)\n", "        elif gate_con_pos == \"top\":\n\t            mv_1 = pc_size[1] + w_p1\n\t            mv_2 = pc_size[1] + w_p2\n\t        else:\n\t            mv_1 = -e_c\n\t            mv_2 = pc_size[1] + w_p2\n\t        nc1 = ceil(nf / 2)\n\t        nc2 = floor(nf / 2)\n\t        pc_spacing = 2 * (inter_sd_l + l_gate)\n\t        # generating poly contacts\n", "        pc1 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n\t        )\n\t        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\t        pc2 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n\t        )\n\t        pc2.move(\n\t            (\n\t                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n", "                -pc_size[1] - end_cap + mv_2,\n\t            )\n\t        )\n\t        add_inter_sd_labels(\n\t            c,\n\t            nf,\n\t            sd_lbl,\n\t            poly1,\n\t            l_gate,\n\t            inter_sd_l,\n", "            sd_diff_intr,\n\t            lbl,\n\t            layer,\n\t            con_bet_fin,\n\t        )\n\t        if interdig == 1:\n\t            c_inst.add_ref(\n\t                interdigit(\n\t                    sd_diff=sd_diff,\n\t                    pc1=pc1,\n", "                    pc2=pc2,\n\t                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n\t                    sd_l=sd_l,\n\t                    nf=nf,\n\t                    patt=patt,\n\t                    gate_con_pos=gate_con_pos,\n\t                    pc_x=pc_x,\n", "                    pc_spacing=pc_spacing,\n\t                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n\t            )\n\t        else:\n\t            add_gate_labels(\n\t                c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf\n\t            )\n", "    # generating bulk\n\t    if bulk == \"None\":\n\t        nplus = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.size[0] + 2 * comp_np_enc,\n\t                    sd_diff.size[1] + 2 * np_cmp_ency,\n\t                ),\n\t                layer=layer[\"nplus\"],\n\t            )\n", "        )\n\t        nplus.xmin = sd_diff.xmin - comp_np_enc\n\t        nplus.ymin = sd_diff.ymin - np_cmp_ency\n\t    elif bulk == \"Bulk Tie\":\n\t        rect_bulk = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n\t            )\n\t        )\n\t        rect_bulk.xmin = sd_diff.xmax\n", "        rect_bulk.ymin = sd_diff.ymin\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n\t                    sd_diff.size[1] + (2 * np_cmp_ency),\n\t                ),\n\t                layer=layer[\"nplus\"],\n\t            )\n\t        )\n", "        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff.ymin - np_cmp_ency\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n\t                    w_gate + 2 * comp_pp_enc,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n", "        )\n\t        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\t        bulk_con = via_stack(\n\t            x_range=(sd_con_arr.xmax + m1_sp, rect_bulk.xmax),\n\t            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t        c_inst.add_ref(bulk_con)\n\t        bulk_con_area = bulk_con.size[0] * bulk_con.size[1]\n", "        bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con)\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=sub_lbl,\n\t                position=(\n\t                    bulk_con.xmin + bulk_con.size[0] / 2,\n\t                    bulk_con.ymin + bulk_con.size[1] / 2,\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n", "                lbl_lst=[sub_lbl],\n\t                lbl_valid_len=1,\n\t            )\n\t        )\n\t    if bulk == \"Guard Ring\":\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n\t                layer=layer[\"nplus\"],\n\t            )\n", "        )\n\t        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n\t        c.add_ref(c_inst)\n\t        bulk_gr_gen(\n\t            c,\n\t            c_inst=c_inst,\n\t            comp_spacing=comp_spacing,\n\t            poly2_comp_spacing=comp_spacing,\n\t            volt=volt,\n", "            grw=grw,\n\t            l_d=l_d,\n\t            implant_layer=layer[\"pplus\"],\n\t            lbl=lbl,\n\t            sub_lbl=sub_lbl,\n\t            deepnwell=deepnwell,\n\t            pcmpgr=pcmpgr,\n\t            m1_sp=m1_sp,\n\t        )\n\t    else:\n", "        c.add_ref(c_inst)\n\t        inst_size = (c_inst.size[0], c_inst.size[1])\n\t        inst_xmin = c_inst.xmin\n\t        inst_ymin = c_inst.ymin\n\t        c.add_ref(\n\t            nfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                inst_size=inst_size,\n\t                inst_xmin=inst_xmin,\n", "                inst_ymin=inst_ymin,\n\t                grw=grw,\n\t                volt=volt,\n\t            )\n\t        )\n\t    # creating layout and cell in klayout\n\t    c.write_gds(\"nfet_temp.gds\")\n\t    layout.read(\"nfet_temp.gds\")\n\t    cell_name = \"sky_nfet_dev\"\n\t    return layout.cell(cell_name)\n", "    # return c\n\t@gf.cell\n\tdef pfet_deep_nwell(\n\t    volt=\"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    enc_size: Float2 = (0.1, 0.1),\n\t    enc_xmin: float = 0.1,\n\t    enc_ymin: float = 0.1,\n\t    nw_enc_pcmp: float = 0.1,\n", "    grw: float = 0.36,\n\t) -> gf.Component:\n\t    \"\"\"Returns pfet well related polygons\n\t    Args :\n\t        deepnwell : boolaen of having deepnwell\n\t        pcmpgr : boolean of having deepnwell guardring\n\t        enc_size : enclosed size\n\t        enc_xmin : enclosed xmin\n\t        enc_ymin : enclosed ymin\n\t        nw_enc_pcmp : nwell enclosure of pcomp\n", "        grw : guardring width\n\t    \"\"\"\n\t    c = gf.Component()\n\t    dnwell_enc_pcmp = 1.1\n\t    dg_enc_dn = 0.5\n\t    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    enc_size[0] + (2 * dnwell_enc_pcmp),\n", "                    enc_size[1] + (2 * dnwell_enc_pcmp),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = enc_xmin - dnwell_enc_pcmp\n\t        dn_rect.ymin = enc_ymin - dnwell_enc_pcmp\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\t        if volt == \"5V\" or volt == \"6V\":\n", "            dg = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        dn_rect.size[0] + (2 * dg_enc_dn),\n\t                        dn_rect.size[1] + (2 * dg_enc_dn),\n\t                    ),\n\t                    layer=layer[\"dualgate\"],\n\t                )\n\t            )\n\t            dg.xmin = dn_rect.xmin - dg_enc_dn\n", "            dg.ymin = dn_rect.ymin - dg_enc_dn\n\t            if volt == \"5V\":\n\t                v5x = c.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n\t                    )\n\t                )\n\t                v5x.xmin = dg.xmin\n\t                v5x.ymin = dg.ymin\n\t    else:\n", "        # nwell generation\n\t        nw = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    enc_size[0] + (2 * nw_enc_pcmp),\n\t                    enc_size[1] + (2 * nw_enc_pcmp),\n\t                ),\n\t                layer=layer[\"nwell\"],\n\t            )\n\t        )\n", "        nw.xmin = enc_xmin - nw_enc_pcmp\n\t        nw.ymin = enc_ymin - nw_enc_pcmp\n\t        if volt == \"5V\" or volt == \"6V\":\n\t            dg = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        nw.size[0] + (2 * dg_enc_dn),\n\t                        nw.size[1] + (2 * dg_enc_dn),\n\t                    ),\n\t                    layer=layer[\"dualgate\"],\n", "                )\n\t            )\n\t            dg.xmin = nw.xmin - dg_enc_dn\n\t            dg.ymin = nw.ymin - dg_enc_dn\n\t            if volt == \"5V\":\n\t                v5x = c.add_ref(\n\t                    gf.components.rectangle(\n\t                        size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n\t                    )\n\t                )\n", "                v5x.xmin = dg.xmin\n\t                v5x.ymin = dg.ymin\n\t    return c\n\t# @gf.cell\n\tdef draw_pfet(\n\t    layout,\n\t    l_gate: float = 0.28,\n\t    w_gate: float = 0.22,\n\t    sd_con_col: int = 1,\n\t    inter_sd_l: float = 0.24,\n", "    nf: int = 1,\n\t    grw: float = 0.22,\n\t    volt: str = \"3.3V\",\n\t    bulk=\"None\",\n\t    con_bet_fin: int = 1,\n\t    gate_con_pos=\"alternating\",\n\t    interdig: int = 0,\n\t    patt=\"\",\n\t    deepnwell: int = 0,\n\t    pcmpgr: int = 0,\n", "    lbl: bool = 0,\n\t    sd_lbl: list = [],\n\t    g_lbl: str = [],\n\t    sub_lbl: str = \"\",\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Retern pfet\n\t    Args:\n\t        layout : layout object\n", "        l : Float of gate length\n\t        w : Float of gate width\n\t        sd_l : Float of source and drain diffusion length\n\t        inter_sd_l : Float of source and drain diffusion length between fingers\n\t        nf : integer of number of fingers\n\t        M : integer of number of multipliers\n\t        grw : gaurd ring width when enabled\n\t        type : string of the device type\n\t        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n\t        con_bet_fin : boolean of having contacts for diffusion between fingers\n", "        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n\t    \"\"\"\n\t    # used layers and dimensions\n\t    end_cap: float = 0.22\n\t    if volt == \"3.3V\":\n\t        comp_spacing: float = 0.28\n\t        nw_enc_pcmp = 0.43\n\t    else:\n\t        comp_spacing: float = 0.36\n\t        nw_enc_pcmp = 0.6\n", "    gate_pp_enc: float = 0.23\n\t    comp_np_enc: float = 0.16\n\t    comp_pp_enc: float = 0.16\n\t    poly2_spacing: float = 0.24\n\t    pc_ext: float = 0.04\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    con_pp_sp = 0.1 - con_comp_enc\n\t    pl_cmp_spacing = 0.1\n", "    con_pl_enc = 0.07\n\t    dg_enc_cmp = 0.24\n\t    dg_enc_poly = 0.4\n\t    m1_sp = 0.3\n\t    m1_area = 0.145\n\t    pl_cmpcon_sp = 0.15\n\t    # sd_l_con = (\n\t    #     ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n\t    # )\n\t    sd_l_con = (\n", "        ((sd_con_col) * con_size)\n\t        + ((sd_con_col - 1) * con_sp)\n\t        + 2 * con_comp_enc\n\t        + 2 * con_pp_sp\n\t    )\n\t    sd_l = sd_l_con\n\t    # gds components to store a single instance and the generated device\n\t    c = gf.Component(\"sky_pfet_dev\")\n\t    c_inst = gf.Component(\"dev_temp\")\n\t    # generating sd diffusion\n", "    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n\t        nf = len(patt)\n\t    l_d = (\n\t        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing)\n\t    )  # diffution total length\n\t    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n\t    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\t    # generatin sd contacts\n\t    if w_gate <= con_size + 2 * con_comp_enc:\n\t        cmpc_y = con_comp_enc + con_size + con_comp_enc\n", "        pp_cmp_ency = comp_pp_enc\n\t    else:\n\t        cmpc_y = w_gate\n\t        pp_cmp_ency = gate_pp_enc\n\t    cmpc_size = (sd_l_con, cmpc_y)\n\t    sd_diff = c_inst.add_array(\n\t        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n", "    )\n\t    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n\t    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\t    sd_con = via_stack(\n\t        x_range=(sd_diff.xmin + con_pp_sp, sd_diff_intr.xmin - con_pp_sp),\n\t        y_range=(sd_diff.ymin, sd_diff.ymax),\n\t        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n\t    )\n\t    sd_con_arr = c_inst.add_array(\n", "        component=sd_con,\n\t        columns=2,\n\t        rows=1,\n\t        spacing=(\n\t            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n\t            0,\n\t        ),\n\t    )\n\t    sd_con_area = sd_con.size[0] * sd_con.size[1]\n\t    sd_m1_area_check(\n", "        sd_con_area,\n\t        m1_area,\n\t        sd_con,\n\t        c_inst,\n\t        sd_l,\n\t        nf,\n\t        l_gate,\n\t        inter_sd_l,\n\t        pl_cmp_spacing,\n\t    )\n", "    if con_bet_fin == 1 and nf > 1:\n\t        inter_sd_con = via_stack(\n\t            x_range=(\n\t                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + pl_cmpcon_sp,\n\t                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + inter_sd_l - pl_cmpcon_sp,\n\t            ),\n\t            y_range=(0, w_gate),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n", "        c_inst.add_array(\n\t            component=inter_sd_con,\n\t            columns=nf - 1,\n\t            rows=1,\n\t            spacing=(l_gate + inter_sd_l, 0),\n\t        )\n\t        inter_sd_con_area = inter_sd_con.size[0] * inter_sd_con.size[1]\n\t        inter_sd_m1_area_check(\n\t            inter_sd_con_area,\n\t            m1_area,\n", "            inter_sd_con,\n\t            c_inst,\n\t            l_gate,\n\t            nf,\n\t            inter_sd_l,\n\t            sd_con,\n\t        )\n\t    ### adding source/drain labels\n\t    c.add_ref(\n\t        labels_gen(\n", "            lbl_str=\"None\",\n\t            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            lbl_lst=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=0,\n\t        )\n\t    )\n\t    c.add_ref(\n", "        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n\t            lbl_lst=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=nf,\n\t        )\n\t    )\n", "    # generating poly\n\t    if l_gate <= con_size + 2 * con_pl_enc:\n\t        pc_x = con_pl_enc + con_size + con_pl_enc\n\t    else:\n\t        pc_x = l_gate\n\t    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\t    c_pc = gf.Component(\"poly con\")\n\t    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\t    poly_con = via_stack(\n\t        x_range=(rect_pc.xmin, rect_pc.xmax),\n", "        y_range=(rect_pc.ymin, rect_pc.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t        li_enc_dir=\"H\",\n\t    )\n\t    c_pl_con = c_pc.add_ref(poly_con)\n\t    poly_con_area = poly_con.size[0] * poly_con.size[1]\n\t    poly_con_m1_check(poly_con_area, m1_area, c_pc, poly_con, c_pl_con)\n\t    if nf == 1:\n\t        poly = c_inst.add_ref(\n", "            gf.components.rectangle(\n\t                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n\t            )\n\t        )\n\t        poly.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n\t        poly.ymin = sd_diff_intr.ymin - end_cap\n\t        if gate_con_pos == \"bottom\":\n\t            mv = 0\n\t            nr = 1\n\t        elif gate_con_pos == \"top\":\n", "            mv = pc_size[1] + w_gate + 2 * end_cap\n\t            nr = 1\n\t        else:\n\t            mv = 0\n\t            nr = 2\n\t        pc = c_inst.add_array(\n\t            component=c_pc,\n\t            rows=nr,\n\t            columns=1,\n\t            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n", "        )\n\t        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\t        # gate_lablel\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n\t                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                lbl_lst=g_lbl,\n", "                lbl_valid_len=nf,\n\t                index=0,\n\t            )\n\t        )\n\t    else:\n\t        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\t        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n\t            if gate_con_pos == \"alternating\":\n\t                w_p1 += 0.2\n\t                w_p2 = w_p1\n", "                e_c = 0.2\n\t            else:\n\t                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n\t                e_c = 0\n\t            if gate_con_pos == \"bottom\":\n\t                p_mv = -end_cap - (w_p2 - w_p1)\n\t            else:\n\t                p_mv = -end_cap\n\t        else:\n\t            w_p2 = w_p1\n", "            p_mv = -end_cap\n\t            e_c = 0\n\t        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n\t        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n\t        poly1 = c_inst.add_array(\n\t            rect_p1,\n\t            rows=1,\n\t            columns=ceil(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n", "        poly1.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n\t        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\t        poly2 = c_inst.add_array(\n\t            rect_p2,\n\t            rows=1,\n\t            columns=floor(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n\t        poly2.ymin = p_mv\n", "        # generating poly contacts setups\n\t        if gate_con_pos == \"bottom\":\n\t            mv_1 = 0\n\t            mv_2 = -(w_p2 - w_p1)\n\t        elif gate_con_pos == \"top\":\n\t            mv_1 = pc_size[1] + w_p1\n\t            mv_2 = pc_size[1] + w_p2\n\t        else:\n\t            mv_1 = -e_c\n\t            mv_2 = pc_size[1] + w_p2\n", "        nc1 = ceil(nf / 2)\n\t        nc2 = floor(nf / 2)\n\t        pc_spacing = 2 * (inter_sd_l + l_gate)\n\t        # generating poly contacts\n\t        pc1 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n\t        )\n\t        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\t        pc2 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n", "        )\n\t        pc2.move(\n\t            (\n\t                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n\t                -pc_size[1] - end_cap + mv_2,\n\t            )\n\t        )\n\t        add_inter_sd_labels(\n\t            c,\n\t            nf,\n", "            sd_lbl,\n\t            poly1,\n\t            l_gate,\n\t            inter_sd_l,\n\t            sd_diff_intr,\n\t            lbl,\n\t            layer,\n\t            con_bet_fin,\n\t        )\n\t        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n", "        if interdig == 1:\n\t            c_inst.add_ref(\n\t                interdigit(\n\t                    sd_diff=sd_diff,\n\t                    pc1=pc1,\n\t                    pc2=pc2,\n\t                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n", "                    sd_l=sd_l,\n\t                    nf=nf,\n\t                    patt=patt,\n\t                    gate_con_pos=gate_con_pos,\n\t                    pc_x=pc_x,\n\t                    pc_spacing=pc_spacing,\n\t                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n", "            )\n\t    # generating bulk\n\t    if bulk == \"None\":\n\t        pplus = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_pp_enc, w_gate + 2 * gate_pp_enc),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        pplus.xmin = sd_diff.xmin - comp_pp_enc\n", "        pplus.ymin = sd_diff_intr.ymin - gate_pp_enc\n\t        c.add_ref(c_inst)\n\t        # deep nwell and nwell generation\n\t        c.add_ref(\n\t            pfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                enc_size=(sd_diff.size[0], sd_diff.size[1]),\n\t                enc_xmin=sd_diff.xmin,\n\t                enc_ymin=sd_diff.ymin,\n", "                nw_enc_pcmp=nw_enc_pcmp,\n\t                grw=grw,\n\t                volt=volt,\n\t            )\n\t        )\n\t        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\t    elif bulk == \"Bulk Tie\":\n\t        rect_bulk = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n", "            )\n\t        )\n\t        rect_bulk.xmin = sd_diff.xmax\n\t        rect_bulk.ymin = sd_diff.ymin\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.xmax - sd_diff.xmin + comp_pp_enc,\n\t                    sd_diff.size[1] + (2 * pp_cmp_ency),\n\t                    # w_gate + 2 * gate_pp_enc,\n", "                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm.xmin = sd_diff.xmin - comp_pp_enc\n\t        psdm.ymin = sd_diff.ymin - gate_pp_enc\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    rect_bulk.xmax - rect_bulk.xmin + comp_np_enc,\n", "                    w_gate + 2 * comp_np_enc,\n\t                ),\n\t                layer=layer[\"nplus\"],\n\t            )\n\t        )\n\t        nsdm.connect(\"e1\", destination=psdm.ports[\"e3\"])\n\t        bulk_con = via_stack(\n\t            x_range=(sd_con_arr.xmax + m1_sp, rect_bulk.xmax),\n\t            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n\t            base_layer=layer[\"comp\"],\n", "            metal_level=1,\n\t        )\n\t        c_inst.add_ref(bulk_con)\n\t        bulk_con_area = bulk_con.size[0] * bulk_con.size[1]\n\t        bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con)\n\t        c.add_ref(c_inst)\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=sub_lbl,\n\t                position=(\n", "                    bulk_con.xmin + bulk_con.size[0] / 2,\n\t                    bulk_con.ymin + bulk_con.size[1] / 2,\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                lbl_lst=[sub_lbl],\n\t                lbl_valid_len=1,\n\t            )\n\t        )\n\t        # deep nwell generation\n", "        nw_enc_pcmp = 0.45 + comp_np_enc + psdm.ymax - nsdm.ymax\n\t        c.add_ref(\n\t            pfet_deep_nwell(\n\t                deepnwell=deepnwell,\n\t                pcmpgr=pcmpgr,\n\t                enc_size=(sd_diff.size[0] + rect_bulk.size[0], sd_diff.size[1]),\n\t                enc_xmin=sd_diff.xmin,\n\t                enc_ymin=sd_diff.ymin,\n\t                nw_enc_pcmp=nw_enc_pcmp,\n\t                grw=grw,\n", "                volt=volt,\n\t            )\n\t        )\n\t    elif bulk == \"Guard Ring\":\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_pp_enc),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n", "        psdm.xmin = sd_diff.xmin - comp_pp_enc\n\t        psdm.ymin = sd_diff_intr.ymin - gate_pp_enc\n\t        c.add_ref(c_inst)\n\t        bulk_gr_gen(\n\t            c,\n\t            c_inst=c_inst,\n\t            comp_spacing=comp_spacing,\n\t            poly2_comp_spacing=comp_spacing,\n\t            volt=volt,\n\t            grw=grw,\n", "            l_d=l_d,\n\t            implant_layer=layer[\"nplus\"],\n\t            lbl=lbl,\n\t            sub_lbl=sub_lbl,\n\t            deepnwell=deepnwell,\n\t            pcmpgr=pcmpgr,\n\t            nw_enc_pcmp=nw_enc_pcmp,\n\t            m1_sp=m1_sp,\n\t        )\n\t        # bulk guardring\n", "    # creating layout and cell in klayout\n\t    c.write_gds(\"pfet_temp.gds\")\n\t    layout.read(\"pfet_temp.gds\")\n\t    cell_name = \"sky_pfet_dev\"\n\t    return layout.cell(cell_name)\n\tdef draw_nfet_06v0_nvt(\n\t    layout,\n\t    l_gate: float = 1.8,\n\t    w_gate: float = 0.8,\n\t    sd_con_col: int = 1,\n", "    inter_sd_l: float = 0.24,\n\t    nf: int = 1,\n\t    grw: float = 0.22,\n\t    bulk=\"None\",\n\t    con_bet_fin: int = 1,\n\t    gate_con_pos=\"alternating\",\n\t    interdig: int = 0,\n\t    patt=\"\",\n\t    lbl: bool = 0,\n\t    sd_lbl: list = [],\n", "    g_lbl: str = [],\n\t    sub_lbl: str = \"\",\n\t    patt_lbl: bool = 0,\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw Native NFET 6V transistor by specifying parameters\n\t    Arguments:-\n\t     layout : Object of layout\n\t     l      : Float of gate length\n", "     w      : Float of gate width\n\t     ld     : Float of diffusion length\n\t     nf     : Integer of number of fingers\n\t     grw    : Float of guard ring width [If enabled]\n\t     bulk   : String of bulk connection type [None, Bulk Tie, Guard Ring]\n\t    \"\"\"\n\t    # used layers and dimensions\n\t    end_cap: float = 0.22\n\t    comp_spacing: float = 0.36\n\t    poly2_comp_spacing: float = 0.3\n", "    gate_np_enc: float = 0.23\n\t    comp_np_enc: float = 0.16\n\t    comp_pp_enc: float = 0.16\n\t    poly2_spacing: float = 0.24\n\t    pc_ext: float = 0.04\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    con_pp_sp = 0.1 - con_comp_enc\n\t    pl_cmp_spacing = 0.1\n", "    con_pl_enc = 0.07\n\t    pl_cmpcon_sp = 0.15\n\t    nvt_enc_cmp = 2\n\t    m1_sp = 0.3\n\t    m1_area = 0.145\n\t    sd_l_con = (\n\t        ((sd_con_col) * con_size)\n\t        + ((sd_con_col - 1) * con_sp)\n\t        + 2 * con_comp_enc\n\t        + 2 * con_pp_sp\n", "    )\n\t    sd_l = sd_l_con\n\t    # gds components to store a single instance and the generated device\n\t    c = gf.Component(\"sky_nfet_nvt_dev\")\n\t    c_inst = gf.Component(\"dev_temp\")\n\t    # generating sd diffusion\n\t    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n\t        nf = len(patt)\n\t    l_d = (\n\t        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing)\n", "    )  # diffution total length\n\t    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n\t    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\t    # generatin sd contacts\n\t    if w_gate <= con_size + 2 * con_comp_enc:\n\t        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\t        np_cmp_ency = comp_np_enc\n\t    else:\n\t        cmpc_y = w_gate\n\t        np_cmp_ency = gate_np_enc\n", "    cmpc_size = (sd_l_con, cmpc_y)\n\t    sd_diff = c_inst.add_array(\n\t        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n\t    )\n\t    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n\t    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\t    sd_con = via_stack(\n", "        x_range=(sd_diff.xmin + con_pp_sp, sd_diff_intr.xmin - con_pp_sp),\n\t        y_range=(sd_diff.ymin, sd_diff.ymax),\n\t        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n\t    )\n\t    sd_con_arr = c_inst.add_array(\n\t        component=sd_con,\n\t        columns=2,\n\t        rows=1,\n\t        spacing=(\n", "            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n\t            0,\n\t        ),\n\t    )\n\t    sd_con_area = sd_con.size[0] * sd_con.size[1]\n\t    sd_m1_area_check(\n\t        sd_con_area,\n\t        m1_area,\n\t        sd_con,\n\t        c_inst,\n", "        sd_l,\n\t        nf,\n\t        l_gate,\n\t        inter_sd_l,\n\t        pl_cmp_spacing,\n\t    )\n\t    if con_bet_fin == 1 and nf > 1:\n\t        inter_sd_con = via_stack(\n\t            x_range=(\n\t                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + pl_cmpcon_sp,\n", "                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + inter_sd_l - pl_cmpcon_sp,\n\t            ),\n\t            y_range=(0, w_gate),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t        c_inst.add_array(\n\t            component=inter_sd_con,\n\t            columns=nf - 1,\n\t            rows=1,\n", "            spacing=(l_gate + inter_sd_l, 0),\n\t        )\n\t        inter_sd_con_area = inter_sd_con.size[0] * inter_sd_con.size[1]\n\t        inter_sd_m1_area_check(\n\t            inter_sd_con_area,\n\t            m1_area,\n\t            inter_sd_con,\n\t            c_inst,\n\t            l_gate,\n\t            nf,\n", "            inter_sd_l,\n\t            sd_con,\n\t        )\n\t    ### adding source/drain labels\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n\t            lbl=lbl,\n", "            lbl_lst=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=0,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        labels_gen(\n\t            lbl_str=\"None\",\n\t            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n\t            layer=layer[\"metal1_label\"],\n", "            lbl=lbl,\n\t            lbl_lst=sd_lbl,\n\t            lbl_valid_len=nf + 1,\n\t            index=nf,\n\t        )\n\t    )\n\t    # generating poly\n\t    if l_gate <= con_size + 2 * con_pl_enc:\n\t        pc_x = con_pl_enc + con_size + con_pl_enc\n\t    else:\n", "        pc_x = l_gate\n\t    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\t    c_pc = gf.Component(\"poly con\")\n\t    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\t    poly_con = via_stack(\n\t        x_range=(rect_pc.xmin, rect_pc.xmax),\n\t        y_range=(rect_pc.ymin, rect_pc.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t        li_enc_dir=\"H\",\n", "    )\n\t    c_pc.add_ref(poly_con)\n\t    if nf == 1:\n\t        poly = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n\t            )\n\t        )\n\t        poly.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n\t        poly.ymin = sd_diff_intr.ymin - end_cap\n", "        if gate_con_pos == \"bottom\":\n\t            mv = 0\n\t            nr = 1\n\t        elif gate_con_pos == \"top\":\n\t            mv = pc_size[1] + w_gate + 2 * end_cap\n\t            nr = 1\n\t        else:\n\t            mv = 0\n\t            nr = 2\n\t        pc = c_inst.add_array(\n", "            component=c_pc,\n\t            rows=nr,\n\t            columns=1,\n\t            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n\t        )\n\t        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\t        # gate_lablel\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=\"None\",\n", "                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                lbl_lst=g_lbl,\n\t                lbl_valid_len=nf,\n\t                index=0,\n\t            )\n\t        )\n\t    else:\n\t        w_p1 = end_cap + w_gate + end_cap  # poly total width\n", "        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n\t            if gate_con_pos == \"alternating\":\n\t                w_p1 += 0.2\n\t                w_p2 = w_p1\n\t                e_c = 0.2\n\t            else:\n\t                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n\t                e_c = 0\n\t            if gate_con_pos == \"bottom\":\n\t                p_mv = -end_cap - (w_p2 - w_p1)\n", "            else:\n\t                p_mv = -end_cap\n\t        else:\n\t            w_p2 = w_p1\n\t            p_mv = -end_cap\n\t            e_c = 0\n\t        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n\t        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n\t        poly1 = c_inst.add_array(\n\t            rect_p1,\n", "            rows=1,\n\t            columns=ceil(nf / 2),\n\t            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly1.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n\t        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\t        poly2 = c_inst.add_array(\n\t            rect_p2,\n\t            rows=1,\n\t            columns=floor(nf / 2),\n", "            spacing=[2 * (inter_sd_l + l_gate), 0],\n\t        )\n\t        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n\t        poly2.ymin = p_mv\n\t        # generating poly contacts setups\n\t        if gate_con_pos == \"bottom\":\n\t            mv_1 = 0\n\t            mv_2 = -(w_p2 - w_p1)\n\t        elif gate_con_pos == \"top\":\n\t            mv_1 = pc_size[1] + w_p1\n", "            mv_2 = pc_size[1] + w_p2\n\t        else:\n\t            mv_1 = -e_c\n\t            mv_2 = pc_size[1] + w_p2\n\t        nc1 = ceil(nf / 2)\n\t        nc2 = floor(nf / 2)\n\t        pc_spacing = 2 * (inter_sd_l + l_gate)\n\t        # generating poly contacts\n\t        pc1 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n", "        )\n\t        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\t        pc2 = c_inst.add_array(\n\t            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n\t        )\n\t        pc2.move(\n\t            (\n\t                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n\t                -pc_size[1] - end_cap + mv_2,\n\t            )\n", "        )\n\t        add_inter_sd_labels(\n\t            c,\n\t            nf,\n\t            sd_lbl,\n\t            poly1,\n\t            l_gate,\n\t            inter_sd_l,\n\t            sd_diff_intr,\n\t            lbl,\n", "            layer,\n\t            con_bet_fin,\n\t        )\n\t        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\t        if interdig == 1:\n\t            c_inst.add_ref(\n\t                interdigit(\n\t                    sd_diff=sd_diff,\n\t                    pc1=pc1,\n\t                    pc2=pc2,\n", "                    poly_con=poly_con,\n\t                    sd_diff_intr=sd_diff_intr,\n\t                    l_gate=l_gate,\n\t                    inter_sd_l=inter_sd_l,\n\t                    sd_l=sd_l,\n\t                    nf=nf,\n\t                    patt=patt,\n\t                    gate_con_pos=gate_con_pos,\n\t                    pc_x=pc_x,\n\t                    pc_spacing=pc_spacing,\n", "                    lbl=lbl,\n\t                    g_lbl=g_lbl,\n\t                    patt_lbl=patt_lbl,\n\t                )\n\t            )\n\t    # generating bulk\n\t    if bulk == \"None\":\n\t        nplus = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n", "                layer=layer[\"nplus\"],\n\t            )\n\t        )\n\t        nplus.xmin = sd_diff.xmin - comp_np_enc\n\t        nplus.ymin = sd_diff_intr.ymin - gate_np_enc\n\t    elif bulk == \"Bulk Tie\":\n\t        rect_bulk = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n\t            )\n", "        )\n\t        rect_bulk.xmin = sd_diff.xmax\n\t        rect_bulk.ymin = sd_diff.ymin\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n\t                    sd_diff.size[1] + (2 * np_cmp_ency),\n\t                ),\n\t                layer=layer[\"nplus\"],\n", "            )\n\t        )\n\t        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff.ymin - np_cmp_ency\n\t        psdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n\t                    w_gate + 2 * comp_pp_enc,\n\t                ),\n", "                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\t        bulk_con = via_stack(\n\t            x_range=(sd_con_arr.xmax + m1_sp, rect_bulk.xmax),\n\t            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n", "        c_inst.add_ref(bulk_con)\n\t        bulk_con_area = bulk_con.size[0] * bulk_con.size[1]\n\t        bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con)\n\t        c.add_ref(\n\t            labels_gen(\n\t                lbl_str=sub_lbl,\n\t                position=(\n\t                    bulk_con.xmin + bulk_con.size[0] / 2,\n\t                    bulk_con.ymin + bulk_con.size[1] / 2,\n\t                ),\n", "                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                lbl_lst=[sub_lbl],\n\t                lbl_valid_len=1,\n\t            )\n\t        )\n\t    elif bulk == \"Guard Ring\":\n\t        nsdm = c_inst.add_ref(\n\t            gf.components.rectangle(\n\t                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n", "                layer=layer[\"nplus\"],\n\t            )\n\t        )\n\t        nsdm.xmin = sd_diff.xmin - comp_np_enc\n\t        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n\t        c.add_ref(c_inst)\n\t        c_temp = gf.Component(\"temp_store\")\n\t        rect_bulk_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    (c_inst.xmax - c_inst.xmin) + 2 * comp_spacing,\n\t                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_bulk_in.move(\n\t            (c_inst.xmin - comp_spacing, c_inst.ymin - poly2_comp_spacing)\n\t        )\n\t        rect_bulk_out = c_temp.add_ref(\n", "            gf.components.rectangle(\n\t                size=(\n\t                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t                ),\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n\t        c.add_ref(\n", "            gf.geometry.boolean(\n\t                A=rect_bulk_out,\n\t                B=rect_bulk_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"comp\"],\n\t            )\n\t        )\n\t        psdm_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n\t                    (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n\t        psdm_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n", "                    (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n\t                    (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n\t                ),\n\t                layer=layer[\"pplus\"],\n\t            )\n\t        )\n\t        psdm_out.move(\n\t            (\n\t                rect_bulk_out.xmin - comp_pp_enc,\n\t                rect_bulk_out.ymin - comp_pp_enc,\n", "            )\n\t        )\n\t        psdm = c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t            )\n\t        )\n\t        # generating contacts\n\t        c.add_ref(\n\t            via_generator(\n", "                x_range=(\n\t                    rect_bulk_in.xmin + con_size,\n\t                    rect_bulk_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n", "        )  # bottom contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(\n\t                    rect_bulk_in.xmin + con_size,\n\t                    rect_bulk_in.xmax - con_size,\n\t                ),\n\t                y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n", "                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # upper contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n\t                y_range=(\n\t                    rect_bulk_in.ymin + con_size,\n\t                    rect_bulk_in.ymax - con_size,\n", "                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # right contact\n\t        c.add_ref(\n\t            via_generator(\n\t                x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n", "                y_range=(\n\t                    rect_bulk_in.ymin + con_size,\n\t                    rect_bulk_in.ymax - con_size,\n\t                ),\n\t                via_enclosure=(con_comp_enc, con_comp_enc),\n\t                via_layer=layer[\"contact\"],\n\t                via_size=(con_size, con_size),\n\t                via_spacing=(con_sp, con_sp),\n\t            )\n\t        )  # left contact\n", "        comp_m1_in = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (l_d) + 2 * comp_spacing,\n\t                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n\t                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n", "        comp_m1_out = c_temp.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n\t                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n\t                ),\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )\n\t        comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n", "        b_gr = c.add_ref(\n\t            gf.geometry.boolean(\n\t                A=rect_bulk_out,\n\t                B=rect_bulk_in,\n\t                operation=\"A-B\",\n\t                layer=layer[\"metal1\"],\n\t            )\n\t        )  # guardring metal1\n\t        c.add_ref(\n\t            labels_gen(\n", "                lbl_str=sub_lbl,\n\t                position=(\n\t                    b_gr.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n\t                    b_gr.ymin + (b_gr.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t                lbl=lbl,\n\t                lbl_lst=[sub_lbl],\n\t                lbl_valid_len=1,\n\t            )\n", "        )\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sd_diff.size[0] + (2 * nvt_enc_cmp),\n\t                    sd_diff.size[1] + (2 * nvt_enc_cmp),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n", "        dg.xmin = sd_diff.xmin - nvt_enc_cmp\n\t        dg.ymin = sd_diff.ymin - nvt_enc_cmp\n\t    if bulk != \"Guard Ring\":\n\t        c.add_ref(c_inst)\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    c_inst.size[0] + (2 * nvt_enc_cmp),\n\t                    c_inst.size[1] + (2 * nvt_enc_cmp),\n\t                ),\n", "                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = c_inst.xmin - nvt_enc_cmp\n\t        dg.ymin = c_inst.ymin - nvt_enc_cmp\n\t    # generating native layer\n\t    nat = c.add_ref(\n\t        gf.components.rectangle(size=(dg.size[0], dg.size[1]), layer=layer[\"nat\"])\n\t    )\n\t    nat.xmin = dg.xmin\n", "    nat.ymin = dg.ymin\n\t    # creating layout and cell in klayout\n\t    c.write_gds(\"nfet_nvt_temp.gds\")\n\t    layout.read(\"nfet_nvt_temp.gds\")\n\t    cell_name = \"sky_nfet_nvt_dev\"\n\t    return layout.cell(cell_name)\n\tif __name__ == \"__main__\":\n\t    pass\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/bjt.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t# BJT Generator for GF180MCU\n\t########################################################################################################################\n\timport pya\n\tfrom .draw_bjt import draw_bjt\n\tclass npn_bjt(pya.PCellDeclarationHelper):\n\t    \"\"\"\n", "    NPN BJT Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Important: initialize the super class\n\t        super().__init__()\n\t        self.Type_handle = self.param(\n\t            \"Type\", self.TypeList, \"Type\", default=\"npn_10p00x10p00\"\n\t        )\n\t        self.Type_handle.add_choice(\"npn_10p00x10p00\", \"npn_10p00x10p00\")\n\t        self.Type_handle.add_choice(\"npn_05p00x05p00\", \"npn_05p00x05p00\")\n", "        self.Type_handle.add_choice(\"npn_00p54x16p00\", \"npn_00p54x16p00\")\n\t        self.Type_handle.add_choice(\"npn_00p54x08p00\", \"npn_00p54x08p00\")\n\t        self.Type_handle.add_choice(\"npn_00p54x04p00\", \"npn_00p54x04p00\")\n\t        self.Type_handle.add_choice(\"npn_00p54x02p00\", \"npn_00p54x02p00\")\n\t        self.param(\n\t            \"Model\",\n\t            self.TypeString,\n\t            \"Model\",\n\t            default=\"gf180mcu_fd_pr__npn\",\n\t            readonly=True,\n", "        )\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return str(self.Type)\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the\n\t        # numeric parameter has changed. We also update the numerical value\n\t        # or the shape, depending on which on has not changed.\n\t        pass\n\t    def can_create_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        pass\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        pass\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n", "        pass\n\t    def produce_impl(self):\n\t        # This is the main part of the implementation: create the layout\n\t        self.percision = 1 / self.layout.dbu\n\t        npn_instance = draw_bjt(layout=self.layout, device_name=self.Type)\n\t        write_cells = pya.CellInstArray(\n\t            npn_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n", "            1,\n\t            1,\n\t        )\n\t        self.cell.flatten(1)\n\t        self.cell.insert(write_cells)\n\t        self.layout.cleanup()\n\tclass pnp_bjt(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    PNP BJT Generator for GF180MCU\n\t    \"\"\"\n", "    def __init__(self):\n\t        # Important: initialize the super class\n\t        super().__init__()\n\t        self.Type_handle = self.param(\n\t            \"Type\", self.TypeList, \"Type\", default=\"pnp_10p00x10p00\"\n\t        )\n\t        self.Type_handle.add_choice(\"pnp_10p00x10p00\", \"pnp_10p00x10p00\")\n\t        self.Type_handle.add_choice(\"pnp_05p00x05p00\", \"pnp_05p00x05p00\")\n\t        self.Type_handle.add_choice(\"pnp_10p00x00p42\", \"pnp_10p00x00p42\")\n\t        self.Type_handle.add_choice(\"pnp_05p00x00p42\", \"pnp_05p00x00p42\")\n", "        self.param(\n\t            \"Model\",\n\t            self.TypeString,\n\t            \"Model\",\n\t            default=\"gf180mcu_fd_pr__pnp\",\n\t            readonly=True,\n\t        )\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return str(self.Type)\n", "    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the\n\t        # numeric parameter has changed. We also update the numerical value\n\t        # or the shape, depending on which on has not changed.\n\t        pass\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        pass\n\t    def parameters_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        pass\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        pass\n\t    def produce_impl(self):\n\t        # This is the main part of the implementation: create the layout\n\t        self.percision = 1 / self.layout.dbu\n", "        pnp_instance = draw_bjt(layout=self.layout, device_name=self.Type)\n\t        write_cells = pya.CellInstArray(\n\t            pnp_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.flatten(1)\n", "        self.cell.insert(write_cells)\n\t        self.layout.cleanup()\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/layers_def.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t## layers definition for Klayout of GF180MCU\n\t########################################################################################################################\n\tlayer = {\n\t    \"comp\": (22, 0),\n\t    \"dnwell\": (12, 0),\n\t    \"nwell\": (21, 0),\n", "    \"lvpwell\": (204, 0),\n\t    \"dualgate\": (55, 0),\n\t    \"poly2\": (30, 0),\n\t    \"nplus\": (32, 0),\n\t    \"pplus\": (31, 0),\n\t    \"sab\": (49, 0),\n\t    \"esd\": (24, 0),\n\t    \"contact\": (33, 0),\n\t    \"metal1\": (34, 0),\n\t    \"via1\": (35, 0),\n", "    \"metal2\": (36, 0),\n\t    \"via2\": (38, 0),\n\t    \"metal3\": (42, 0),\n\t    \"via3\": (40, 0),\n\t    \"metal4\": (46, 0),\n\t    \"via4\": (41, 0),\n\t    \"metal5\": (81, 0),\n\t    \"via5\": (82, 0),\n\t    \"metaltop\": (53, 0),\n\t    \"pad\": (37, 0),\n", "    \"resistor\": (62, 0),\n\t    \"fhres\": (227, 0),\n\t    \"fusetop\": (75, 0),\n\t    \"fusewindow_d\": (96, 1),\n\t    \"polyfuse\": (220, 0),\n\t    \"mvsd\": (210, 0),\n\t    \"mvpsd\": (11, 39),\n\t    \"nat\": (5, 0),\n\t    \"comp_dummy\": (22, 4),\n\t    \"poly2_dummy\": (30, 4),\n", "    \"metal1_dummy\": (34, 4),\n\t    \"metal2_dummy\": (36, 4),\n\t    \"metal3_dummy\": (42, 4),\n\t    \"metal4_dummy\": (46, 4),\n\t    \"metal5_dummy\": (81, 4),\n\t    \"metaltop_dummy\": (53, 4),\n\t    \"comp_label\": (22, 10),\n\t    \"poly2_label\": (30, 10),\n\t    \"metal1_label\": (34, 10),\n\t    \"metal2_label\": (36, 10),\n", "    \"metal3_label\": (42, 10),\n\t    \"metal4_label\": (46, 10),\n\t    \"metal5_label\": (81, 10),\n\t    \"metaltop_label\": (53, 10),\n\t    \"metal1_slot\": (34, 3),\n\t    \"metal2_slot\": (36, 3),\n\t    \"metal3_slot\": (42, 3),\n\t    \"metal4_slot\": (46, 3),\n\t    \"metal5_slot\": (81, 3),\n\t    \"metaltop_slot\": (53, 3),\n", "    \"ubmpperi\": (183, 0),\n\t    \"ubmparray\": (184, 0),\n\t    \"ubmeplate\": (185, 0),\n\t    \"schottky_diode\": (241, 0),\n\t    \"zener\": (178, 0),\n\t    \"res_mk\": (110, 5),\n\t    \"opc_drc\": (124, 5),\n\t    \"ndmy\": (111, 5),\n\t    \"pmndmy\": (152, 5),\n\t    \"v5_xtor\": (112, 1),\n", "    \"cap_mk\": (117, 5),\n\t    \"mos_cap_mk\": (166, 5),\n\t    \"ind_mk\": (151, 5),\n\t    \"diode_mk\": (115, 5),\n\t    \"drc_bjt\": (127, 5),\n\t    \"lvs_bjt\": (118, 5),\n\t    \"mim_l_mk\": (117, 10),\n\t    \"latchup_mk\": (137, 5),\n\t    \"guard_ring_mk\": (167, 5),\n\t    \"otp_mk\": (173, 5),\n", "    \"mtpmark\": (122, 5),\n\t    \"neo_ee_mk\": (88, 17),\n\t    \"sramcore\": (108, 5),\n\t    \"lvs_rf\": (100, 5),\n\t    \"lvs_drain\": (100, 7),\n\t    \"ind_mk1\": (151, 5),\n\t    \"hvpolyrs\": (123, 5),\n\t    \"lvs_io\": (119, 5),\n\t    \"probe_mk\": (13, 17),\n\t    \"esd_mk\": (24, 5),\n", "    \"lvs_source\": (100, 8),\n\t    \"well_diode_mk\": (153, 51),\n\t    \"ldmos_xtor\": (226, 0),\n\t    \"plfuse\": (125, 5),\n\t    \"efuse_mk\": (80, 5),\n\t    \"mcell_feol_mk\": (11, 17),\n\t    \"ymtp_mk\": (86, 17),\n\t    \"dev_wf_mk\": (128, 17),\n\t    \"metal1_blk\": (34, 5),\n\t    \"metal2_blk\": (36, 5),\n", "    \"metal3_blk\": (42, 5),\n\t    \"metal4_blk\": (46, 5),\n\t    \"metal5_blk\": (81, 5),\n\t    \"metalt_blk\": (53, 5),\n\t    \"pr_bndry\": (0, 0),\n\t    \"mdiode\": (116, 5),\n\t    \"metal1_res\": (110, 11),\n\t    \"metal2_res\": (110, 12),\n\t    \"metal3_res\": (110, 13),\n\t    \"metal4_res\": (110, 14),\n", "    \"metal5_res\": (110, 15),\n\t    \"metal6_res\": (110, 16),\n\t    \"border\": (63, 0),\n\t}\n\tprint(layer[\"comp\"])\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_efuse.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport os\n\tUSER = os.environ[\"USER\"]\n\tgds_path = f\"/home/{USER}/.klayout/pymacros/cells/efuse\"\n\tdef draw_efuse(layout, device_name):\n\t    layout.read(f\"{gds_path}/efuse.gds\")\n\t    cell_name = \"efuse_cell\"\n\t    return layout.cell(cell_name)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_cap_mos.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t## MOS capacitor Pcells Generators for Klayout of GF180MCU\n\t########################################################################################################################\n\timport gdsfactory as gf\n\timport numpy as np\n\tfrom gdsfactory.typings import Float2, LayerSpec\n\tfrom .layers_def import layer\n", "from .via_generator import via_generator, via_stack\n\t@gf.cell\n\tdef cap_mos_inst(\n\t    lc: float = 0.1,\n\t    wc: float = 0.1,\n\t    cmp_w: float = 0.1,\n\t    con_w: float = 0.1,\n\t    pl_l: float = 0.1,\n\t    cmp_ext: float = 0.1,\n\t    pl_ext: float = 0.1,\n", "    implant_layer: LayerSpec = layer[\"nplus\"],\n\t    implant_enc: Float2 = (0.1, 0.1),\n\t    lbl: bool = 0,\n\t    g_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"Returns mos cap simple instance\n\t    Args :\n\t        lc : length of mos_cap\n\t        ws : width of mos_cap\n\t        cmp_w : width of layer[\"comp\"]\n", "        con_w : min width of comp contain contact\n\t        pl_l : length od layer[\"poly2\"]\n\t        cmp_ext : comp extension beyond poly2\n\t        pl_ext : poly2 extension beyond comp\n\t        implant_layer : Layer of implant [nplus,pplus]\n\t        implant_enc : enclosure of implant_layer to comp\n\t    \"\"\"\n\t    c_inst = gf.Component()\n\t    cmp = c_inst.add_ref(gf.components.rectangle(size=(cmp_w, wc), layer=layer[\"comp\"]))\n\t    cap_mk = c_inst.add_ref(\n", "        gf.components.rectangle(\n\t            size=(cmp.size[0], cmp.size[1]), layer=layer[\"mos_cap_mk\"]\n\t        )\n\t    )\n\t    cap_mk.xmin = cmp.xmin\n\t    cap_mk.ymin = cmp.ymin\n\t    c_inst.add_array(\n\t        component=via_stack(\n\t            x_range=(cmp.xmin, cmp.xmin + con_w),\n\t            y_range=(cmp.ymin, cmp.ymax),\n", "            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        ),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmp_w - con_w, 0),\n\t    )  # comp contact\n\t    imp_rect = c_inst.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n", "                cmp.size[0] + (2 * implant_enc[0]),\n\t                cmp.size[1] + (2 * implant_enc[1]),\n\t            ),\n\t            layer=implant_layer,\n\t        )\n\t    )\n\t    imp_rect.xmin = cmp.xmin - implant_enc[0]\n\t    imp_rect.ymin = cmp.ymin - implant_enc[1]\n\t    poly = c_inst.add_ref(\n\t        gf.components.rectangle(size=(lc, pl_l), layer=layer[\"poly2\"])\n", "    )\n\t    poly.xmin = cmp.xmin + cmp_ext\n\t    poly.ymin = cmp.ymin - pl_ext\n\t    pl_con_el = via_stack(\n\t        x_range=(poly.xmin, poly.xmax),\n\t        y_range=(poly.ymin, poly.ymin + con_w),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t    )\n\t    pl_con = c_inst.add_array(\n", "        component=pl_con_el,\n\t        rows=2,\n\t        columns=1,\n\t        spacing=(0, pl_l - con_w),\n\t    )\n\t    # Gate labels_generation\n\t    if lbl == 1:\n\t        c_inst.add_label(\n\t            g_lbl,\n\t            position=(\n", "                pl_con.xmin + (pl_con.size[0] / 2),\n\t                pl_con.ymin + (pl_con_el.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    pl_m1 = c_inst.add_ref(\n\t        gf.components.rectangle(\n\t            size=(pl_con.size[0], pl_con.size[1]), layer=layer[\"metal1\"]\n\t        )\n\t    )\n", "    pl_m1.xmin = pl_con.xmin\n\t    pl_m1.ymin = pl_con.ymin\n\t    return c_inst\n\tdef draw_cap_mos(\n\t    layout,\n\t    type: str = \"cap_nmos\",\n\t    lc: float = 0.1,\n\t    wc: float = 0.1,\n\t    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n", "    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    g_lbl: str = \"\",\n\t    sd_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    Usage:-\n\t     used to draw NMOS capacitor (Outside DNWELL) by specifying parameters\n\t    Arguments:-\n\t     layout : Object of layout\n", "     l      : Float of diff length\n\t     w      : Float of diff width\n\t    \"\"\"\n\t    c = gf.Component(\"cap_mos_dev\")\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    con_pl_enc = 0.07\n\t    cmp_ext = 0.15 - con_comp_enc\n\t    pl_ext = 0.17 - con_pl_enc\n", "    np_enc_gate: float = 0.23\n\t    np_enc_cmp: float = 0.16\n\t    dg_enc_cmp = 0.24\n\t    dg_enc_poly = 0.4\n\t    lvpwell_enc_ncmp = 0.43\n\t    dn_enc_lvpwell = 2.5\n\t    grw = 0.36\n\t    m1_w = 1\n\t    pcmpgr_enc_dn = 2.5\n\t    m1_ext = 0.82\n", "    comp_pp_enc: float = 0.16\n\t    dnwell_enc_pcmp = 1.1\n\t    # end_cap: float = 0.22\n\t    cmp_ed_w = con_size + (2 * con_comp_enc)\n\t    cmp_w = (2 * (cmp_ed_w + cmp_ext)) + lc\n\t    end_cap = pl_ext + cmp_ed_w\n\t    pl_l = wc + (2 * end_cap)\n\t    if \"cap_nmos\" in type:\n\t        implant_layer = layer[\"nplus\"]\n\t    else:\n", "        implant_layer = layer[\"pplus\"]\n\t    c_inst = c.add_ref(\n\t        cap_mos_inst(\n\t            cmp_w=cmp_w,\n\t            lc=lc,\n\t            wc=wc,\n\t            pl_l=pl_l,\n\t            cmp_ext=cmp_ed_w + cmp_ext,\n\t            con_w=cmp_ed_w,\n\t            pl_ext=end_cap,\n", "            implant_layer=implant_layer,\n\t            implant_enc=(np_enc_cmp, np_enc_gate),\n\t            lbl=lbl,\n\t            g_lbl=g_lbl,\n\t        )\n\t    )\n\t    cmp_m1_polys = c_inst.get_polygons(by_spec=layer[\"metal1\"])\n\t    cmp_m1_xmin = np.min(cmp_m1_polys[0][:, 0])\n\t    cmp_m1_xmax = np.max(cmp_m1_polys[0][:, 0])\n\t    cmp_m1_ymax = np.max(cmp_m1_polys[0][:, 1])\n", "    # cmp_m1 = c.add_ref(gf.components.rectangle(size=(m1_w,w+m1_ext),layer=layer[\"metal1\"]))\n\t    cmp_m1_v = c.add_array(\n\t        component=gf.components.rectangle(\n\t            size=(m1_w, wc + m1_ext), layer=layer[\"metal1\"]\n\t        ),\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(m1_w + cmp_w - 2 * cmp_ed_w, 0),\n\t    )\n\t    cmp_m1_v.xmin = cmp_m1_xmin - (m1_w - (cmp_m1_xmax - cmp_m1_xmin))\n", "    cmp_m1_v.ymax = cmp_m1_ymax\n\t    cmp_m1_h = c.add_ref(\n\t        gf.components.rectangle(size=(cmp_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n\t    )\n\t    cmp_m1_h.xmin = cmp_m1_v.xmin\n\t    cmp_m1_h.ymax = cmp_m1_v.ymin\n\t    # sd labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            sd_lbl,\n", "            position=(\n\t                cmp_m1_h.xmin + (cmp_m1_h.size[0] / 2),\n\t                cmp_m1_h.ymin + (cmp_m1_h.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    # dualgate\n\t    if volt == \"5/6V\":\n\t        dg = c.add_ref(\n\t            gf.components.rectangle(\n", "                size=(\n\t                    c_inst.size[0] + (2 * dg_enc_cmp),\n\t                    c_inst.size[1] + (2 * dg_enc_poly),\n\t                ),\n\t                layer=layer[\"dualgate\"],\n\t            )\n\t        )\n\t        dg.xmin = c_inst.xmin - dg_enc_cmp\n\t        dg.ymin = c_inst.ymin - dg_enc_poly\n\t    cmp_polys = c_inst.get_polygons(by_spec=layer[\"comp\"])\n", "    cmp_xmin = np.min(cmp_polys[0][:, 0])\n\t    cmp_ymin = np.min(cmp_polys[0][:, 1])\n\t    cmp_xmax = np.max(cmp_polys[0][:, 0])\n\t    cmp_ymax = np.max(cmp_polys[0][:, 1])\n\t    if \"_b\" in type:\n\t        if \"cap_nmos\" in type:\n\t            nwell = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n", "                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n\t                    ),\n\t                    layer=layer[\"nwell\"],\n\t                )\n\t            )\n\t            nwell.xmin = cmp_xmin - np_enc_cmp\n\t            nwell.ymin = cmp_ymin - np_enc_gate\n\t        else:\n\t            lvpwell = c.add_ref(\n\t                gf.components.rectangle(\n", "                    size=(\n\t                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n\t                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n\t                    ),\n\t                    layer=layer[\"lvpwell\"],\n\t                )\n\t            )\n\t            lvpwell.xmin = cmp_xmin - np_enc_cmp\n\t            lvpwell.ymin = cmp_ymin - np_enc_gate\n\t    if deepnwell == 1:\n", "        if type == \"cap_nmos\":\n\t            lvp_rect = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        c_inst.size[0] + (2 * lvpwell_enc_ncmp),\n\t                        c_inst.size[1] + (2 * lvpwell_enc_ncmp),\n\t                    ),\n\t                    layer=layer[\"lvpwell\"],\n\t                )\n\t            )\n", "            lvp_rect.xmin = c_inst.xmin - lvpwell_enc_ncmp\n\t            lvp_rect.ymin = c_inst.ymin - lvpwell_enc_ncmp\n\t            dn_rect = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n\t                        lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n\t                    ),\n\t                    layer=layer[\"nwell\"],\n\t                )\n", "            )\n\t            dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n\t            dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\t        else:\n\t            dn_rect = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        c_inst.size[0] + (2 * dnwell_enc_pcmp),\n\t                        c_inst.size[1] + (2 * dnwell_enc_pcmp),\n\t                    ),\n", "                    layer=layer[\"nwell\"],\n\t                )\n\t            )\n\t            dn_rect.xmin = c_inst.xmin - dnwell_enc_pcmp\n\t            dn_rect.ymin = c_inst.ymin - dnwell_enc_pcmp\n\t        if pcmpgr == 1:\n\t            c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t            rect_pcmpgr_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n", "                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_in.move(\n\t                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n\t            )\n\t            rect_pcmpgr_out = c_temp_gr.add_ref(\n", "                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n\t                    ),\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )\n\t            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t            c.add_ref(\n", "                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"comp\"],\n\t                )\n\t            )  # guardring Bullk\n\t            psdm_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n", "                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n\t                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n\t            )\n\t            psdm_in.move(\n\t                (\n\t                    rect_pcmpgr_in.xmin + comp_pp_enc,\n\t                    rect_pcmpgr_in.ymin + comp_pp_enc,\n", "                )\n\t            )\n\t            psdm_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n\t                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n\t                    ),\n\t                    layer=layer[\"pplus\"],\n\t                )\n", "            )\n\t            psdm_out.move(\n\t                (\n\t                    rect_pcmpgr_out.xmin - comp_pp_enc,\n\t                    rect_pcmpgr_out.ymin - comp_pp_enc,\n\t                )\n\t            )\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n", "                )\n\t            )  # psdm\n\t            # generating contacts\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n\t                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n", "                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # bottom contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(\n\t                        rect_pcmpgr_in.xmin + con_size,\n", "                        rect_pcmpgr_in.xmax - con_size,\n\t                    ),\n\t                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # upper contact\n\t            c.add_ref(\n", "                via_generator(\n\t                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n\t                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n", "                )\n\t            )  # right contact\n\t            c.add_ref(\n\t                via_generator(\n\t                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t                    y_range=(\n\t                        rect_pcmpgr_in.ymin + con_size,\n\t                        rect_pcmpgr_in.ymax - con_size,\n\t                    ),\n\t                    via_enclosure=(con_comp_enc, con_comp_enc),\n", "                    via_layer=layer[\"contact\"],\n\t                    via_size=(con_size, con_size),\n\t                    via_spacing=(con_sp, con_sp),\n\t                )\n\t            )  # left contact\n\t            comp_m1_in = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t                    layer=layer[\"metal1\"],\n\t                )\n", "            )\n\t            comp_m1_out = c_temp_gr.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n\t                        (comp_m1_in.size[0]) + 2 * grw,\n\t                        (comp_m1_in.size[1]) + 2 * grw,\n\t                    ),\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )\n", "            comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t            c.add_ref(\n\t                gf.geometry.boolean(\n\t                    A=rect_pcmpgr_out,\n\t                    B=rect_pcmpgr_in,\n\t                    operation=\"A-B\",\n\t                    layer=layer[\"metal1\"],\n\t                )\n\t            )  # guardring metal1\n\t    c.write_gds(\"cap_mos_temp.gds\")\n", "    layout.read(\"cap_mos_temp.gds\")\n\t    cell_name = \"cap_mos_dev\"\n\t    return layout.cell(cell_name)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/__init__.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# ============================================================================\n\t# ---------------- Pcells Generators for Klayout of GF180MCU ----------------\n\t# ============================================================================\n\timport pya\n\tfrom .bjt import npn_bjt, pnp_bjt\n\tfrom .cap_mim import cap_mim\n\tfrom .cap_mos import cap_nmos, cap_nmos_b, cap_pmos, cap_pmos_b\n", "from .diode import (\n\t    diode_dw2ps,\n\t    diode_nd2ps,\n\t    diode_nw2ps,\n\t    diode_pd2nw,\n\t    diode_pw2dw,\n\t    sc_diode,\n\t)\n\tfrom .fet import nfet, nfet_06v0_nvt, pfet\n\tfrom .res import (\n", "    metal_resistor,\n\t    nplus_s_resistor,\n\t    nplus_u_resistor,\n\t    npolyf_s_resistor,\n\t    npolyf_u_resistor,\n\t    nwell_resistor,\n\t    pplus_s_resistor,\n\t    pplus_u_resistor,\n\t    ppolyf_s_resistor,\n\t    ppolyf_u_high_Rs_resistor,\n", "    ppolyf_u_resistor,\n\t    pwell_resistor,\n\t)\n\t# It's a Python class that inherits from the pya.Library class\n\tclass gf180mcu(pya.Library):\n\t    \"\"\"\n\t    The library where we will put the PCell into\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Set the description\n", "        self.description = \"GF180MCU Pcells\"\n\t        # Create the PCell declarations\n\t        # MOS DEVICES\n\t        self.layout().register_pcell(\n\t            \"nfet\", nfet()\n\t        )  # nfet_03v3 , nfet_05v0 , nfet_06v0\n\t        self.layout().register_pcell(\n\t            \"pfet\", pfet()\n\t        )  # pfet_03v3 , pfet_05v0 , pfet_06v0\n\t        self.layout().register_pcell(\"nfet_06v0_nvt\", nfet_06v0_nvt())\n", "        # self.layout().register_pcell(\"nfet_10v0_asym\", nfet_10v0_asym())\n\t        # self.layout().register_pcell(\"pfet_10v0_asym\", pfet_10v0_asym())\n\t        # BJT\n\t        self.layout().register_pcell(\n\t            \"npn_bjt\", npn_bjt()\n\t        )  # npn_10p00x10p00 , npn_05p00x05p00 , npn_00p54x16p00 ,\n\t        # npn_00p54x08p00 , npn_00p54x04p00 , npn_00p54x02p00\n\t        self.layout().register_pcell(\n\t            \"pnp_bjt\", pnp_bjt()\n\t        )  # pnp_10p00x10p00 , pnp_05p00x05p00 , pnp_10p00x00p42 , pnp_05p00x00p42\n", "        # DIODE DEVICES\n\t        self.layout().register_pcell(\n\t            \"diode_nd2ps\", diode_nd2ps()\n\t        )  # diode_nd2ps_03v3    , diode_nd2ps_06v0\n\t        self.layout().register_pcell(\n\t            \"diode_pd2nw\", diode_pd2nw()\n\t        )  # diode_pd2nw_03v3    , diode_pd2nw_06v0\n\t        self.layout().register_pcell(\n\t            \"diode_nw2ps\", diode_nw2ps()\n\t        )  # diode_nw2ps_03v3   , diode_nw2ps_06v0\n", "        self.layout().register_pcell(\n\t            \"diode_pw2dw\", diode_pw2dw()\n\t        )  # diode_pw2dw_03v3 , diode_pw2dw_06v0\n\t        self.layout().register_pcell(\n\t            \"diode_dw2ps\", diode_dw2ps()\n\t        )  # diode_dw2ps_03v3 , diode_dw2ps_06v0\n\t        self.layout().register_pcell(\"sc_diode\", sc_diode())\n\t        # MIM_CAP DEVICES\n\t        self.layout().register_pcell(\"cap_mim\", cap_mim())\n\t        # cap_mos\n", "        self.layout().register_pcell(\n\t            \"cap_nmos\", cap_nmos()\n\t        )  # cap_nmos_03v3   , cap_nmos_06v0\n\t        self.layout().register_pcell(\n\t            \"cap_pmos\", cap_pmos()\n\t        )  # cap_pmos_03v3   , cap_pmos_06v0\n\t        self.layout().register_pcell(\n\t            \"cap_nmos_b\", cap_nmos_b()\n\t        )  # cap_nmos_03v3_b , cap_nmos_06v0_b\n\t        self.layout().register_pcell(\n", "            \"cap_pmos_b\", cap_pmos_b()\n\t        )  # cap_pmos_03v3_b , cap_pmos_06v0_b\n\t        # RES\n\t        self.layout().register_pcell(\"metal_resistor\", metal_resistor())\n\t        self.layout().register_pcell(\"nplus_s_resistor\", nplus_s_resistor())\n\t        self.layout().register_pcell(\"pplus_s_resistor\", pplus_s_resistor())\n\t        self.layout().register_pcell(\"nplus_u_resistor\", nplus_u_resistor())\n\t        self.layout().register_pcell(\"pplus_u_resistor\", pplus_u_resistor())\n\t        self.layout().register_pcell(\"nwell_resistor\", nwell_resistor())\n\t        self.layout().register_pcell(\"pwell_resistor\", pwell_resistor())\n", "        self.layout().register_pcell(\"npolyf_s_resistor\", npolyf_s_resistor())\n\t        self.layout().register_pcell(\"ppolyf_s_resistor\", ppolyf_s_resistor())\n\t        self.layout().register_pcell(\"npolyf_u_resistor\", npolyf_u_resistor())\n\t        self.layout().register_pcell(\"ppolyf_u_resistor\", ppolyf_u_resistor())\n\t        self.layout().register_pcell(\n\t            \"ppolyf_u_high_Rs_resistor\", ppolyf_u_high_Rs_resistor()\n\t        )\n\t        # Register us with the name \"gf180mcu\".\n\t        self.register(\"gf180mcu\")\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/via_generator.py", "chunked_list": ["# Copyright 2022 Skywater 130nm pdk development\n\t#\n\t# This program is free software: you can redistribute it and/or modify\n\t# it under the terms of the GNU Affero General Public License as published\n\t# by the Free Software Foundation, either version 3 of the License, or\n\t# (at your option) any later version.\n\t#\n\t# This program is distributed in the hope that it will be useful,\n\t# but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "# GNU Affero General Public License for more details.\n\t#\n\t# You should have received a copy of the GNU Affero General Public License\n\t# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\t########################################################################################################################\n\t# via Generator for skywater130\n\t########################################################################################################################\n\tfrom math import ceil, floor\n\timport gdsfactory as gf\n\tfrom gdsfactory.typings import Float2, LayerSpec\n", "from .layers_def import layer\n\t@gf.cell\n\tdef via_generator(\n\t    x_range: Float2 = (0, 1),\n\t    y_range: Float2 = (0, 1),\n\t    via_size: Float2 = (0.17, 0.17),\n\t    via_layer: LayerSpec = (66, 44),\n\t    via_enclosure: Float2 = (0.06, 0.06),\n\t    via_spacing: Float2 = (0.17, 0.17),\n\t) -> gf.Component:\n", "    \"\"\"\n\t    return only vias withen the range xrange and yrange while enclosing by via_enclosure\n\t    and set number of rows and number of coloumns according to ranges and via size and spacing\n\t    \"\"\"\n\t    c = gf.Component()\n\t    width = x_range[1] - x_range[0]\n\t    length = y_range[1] - y_range[0]\n\t    nr = floor(length / (via_size[1] + via_spacing[1]))\n\t    if (length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2 < via_enclosure[1]:\n\t        nr -= 1\n", "    nr = max(nr, 1)\n\t    nc = ceil(width / (via_size[0] + via_spacing[0]))\n\t    if (\n\t        round(width - nc * via_size[0] - (nc - 1) * via_spacing[0], 2)\n\t    ) / 2 < via_enclosure[0]:\n\t        nc -= 1\n\t    nc = max(nc, 1)\n\t    via_sp = (via_size[0] + via_spacing[0], via_size[1] + via_spacing[1])\n\t    rect_via = gf.components.rectangle(size=via_size, layer=via_layer)\n\t    via_arr = c.add_array(rect_via, rows=nr, columns=nc, spacing=via_sp)\n", "    via_arr.move((x_range[0], y_range[0]))\n\t    via_arr.movex((width - nc * via_size[0] - (nc - 1) * via_spacing[0]) / 2)\n\t    via_arr.movey((length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2)\n\t    return c\n\t@gf.cell\n\tdef via_stack(\n\t    x_range: Float2 = (0, 1),\n\t    y_range: Float2 = (0, 1),\n\t    base_layer: LayerSpec = layer[\"comp\"],\n\t    slotted_licon: int = 0,\n", "    metal_level: int = 1,\n\t    li_enc_dir=\"V\",\n\t) -> gf.Component:\n\t    \"\"\"\n\t    return via stack till the metal level indicated where :\n\t    metal_level 1 : till m1\n\t    metal_level 2 : till m2\n\t    metal_level 3 : till m3\n\t    metal_level 4 : till m4\n\t    metal_level 5 : till m5\n", "    withen the range xrange and yrange and expecting the base_layer to be drawen\n\t    \"\"\"\n\t    c = gf.Component()\n\t    # vias dimensions\n\t    con_size = (0.22, 0.22)\n\t    m_enc = 0.06\n\t    con_spacing = (0.28, 0.28)\n\t    via_size = (0.22, 0.22)\n\t    via_spacing = (0.28, 0.28)\n\t    via_enc = (0.06, 0.06)\n", "    if metal_level >= 1:\n\t        con_enc = 0.07\n\t        con_gen = via_generator(\n\t            x_range=x_range,\n\t            y_range=y_range,\n\t            via_size=con_size,\n\t            via_enclosure=(con_enc, con_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_spacing=con_spacing,\n\t        )\n", "        con = c.add_ref(con_gen)\n\t        m1_x = con.size[0] + 2 * m_enc\n\t        m1_y = con.size[1] + 2 * m_enc\n\t        m1 = c.add_ref(\n\t            gf.components.rectangle(size=(m1_x, m1_y), layer=layer[\"metal1\"])\n\t        )\n\t        m1.xmin = con.xmin - m_enc\n\t        m1.ymin = con.ymin - m_enc\n\t    if metal_level >= 2:\n\t        via1_gen = via_generator(\n", "            x_range=(m1.xmin, m1.xmax),\n\t            y_range=(m1.ymin, m1.ymax),\n\t            via_size=via_size,\n\t            via_enclosure=via_enc,\n\t            via_layer=layer[\"via1\"],\n\t            via_spacing=via_spacing,\n\t        )\n\t        via1 = c.add_ref(via1_gen)\n\t        if (via1.xmax - via1.xmin + 2 * m_enc[0]) < (\n\t            via_size[0] + 2 * via_enc[0]\n", "        ) and metal_level >= 3:\n\t            m2_x = via_size[0] + 2 * via_enc[0]\n\t        else:\n\t            m2_x = via1.xmax - via1.xmin + 2 * m_enc[0]\n\t        if (via1.ymax - via1.ymin + 2 * m_enc[1]) < (\n\t            via_size[1] + 2 * via_enc[1]\n\t        ) and metal_level >= 3:\n\t            m2_y = via_size[1] + 2 * via_enc[1]\n\t        else:\n\t            m2_y = via1.ymax - via1.ymin + 2 * m_enc[1]\n", "        m2_mx = (m2_x - (via1.xmax - via1.xmin)) / 2\n\t        m2_my = (m2_y - (via1.ymax - via1.ymin)) / 2\n\t        m2 = c.add_ref(\n\t            gf.components.rectangle(size=(m2_x, m2_y), layer=layer[\"metal2\"])\n\t        )\n\t        m2.move((via1.xmin - m2_mx, via1.ymin - m2_my))\n\t    return c\n\t# testing the generated methods\n\tif __name__ == \"__main__\":\n\t    c = via_stack()\n", "    c.show()\n\t    # c = vias_gen_draw(start_layer=\"li\",end_layer=\"poly\")\n\t    # c.show()\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/fet.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t# FET Generator for GF180MCU\n\t########################################################################################################################\n\timport pya\n\tfrom .draw_fet import draw_nfet, draw_nfet_06v0_nvt, draw_pfet\n\tfet_3p3_l = 0.28\n\tfet_3p3_w = 0.22\n", "fet_3p3_w_con = 0.36\n\tfet_3p3_w_con_bulk = 0.42\n\tfet_5_6_w = 0.3\n\tnfet_05v0_l = 0.6\n\tnfet_06v0_l = 0.7\n\tpfet_05v0_l = 0.5\n\tpfet_06v0_l = 0.55\n\tnfet_nat_l = 1.8\n\tnfet_nat_w = 0.8\n\tfet_grw = 0.36\n", "fet_ld = 0.52\n\tldfet_l_min = 0.6\n\tldfet_l_max = 20\n\tldfet_w_min = 4\n\tldfet_w_max = 50\n\tclass nfet(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    NFET Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n", "        # Initialize super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Deep NWELL Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Operating Voltage\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5V\", \"5V\")\n\t        self.Type_handle.add_choice(\"6V\", \"6V\")\n\t        self.Type_handle = self.param(\"bulk\", self.TypeList, \"Bulk Type\")\n", "        self.Type_handle.add_choice(\"None\", \"None\")\n\t        self.Type_handle.add_choice(\"Bulk Tie\", \"Bulk Tie\")\n\t        self.Type_handle.add_choice(\"Guard Ring\", \"Guard Ring\")\n\t        self.param(\"w_gate\", self.TypeDouble, \"Width\", default=fet_3p3_w, unit=\"um\")\n\t        self.param(\"l_gate\", self.TypeDouble, \"Length\", default=fet_3p3_l, unit=\"um\")\n\t        self.param(\"ld\", self.TypeDouble, \"Diffusion Length\", default=fet_ld, unit=\"um\")\n\t        self.param(\"nf\", self.TypeInt, \"Number of Fingers\", default=1)\n\t        self.param(\n\t            \"grw\", self.TypeDouble, \"Guard Ring Width\", default=fet_grw, unit=\"um\"\n\t        )\n", "        self.Type_handle = self.param(\n\t            \"gate_con_pos\", self.TypeList, \"Gate Contact Position\"\n\t        )\n\t        self.Type_handle.add_choice(\"top\", \"top\")\n\t        self.Type_handle.add_choice(\"bottom\", \"bottom\")\n\t        self.Type_handle.add_choice(\"alternating\", \"alternating\")\n\t        self.param(\n\t            \"con_bet_fin\", self.TypeBoolean, \"Contact Between Fingers\", default=1\n\t        )\n\t        self.param(\"sd_con_col\", self.TypeInt, \"Diffusion Contacts Columns\", default=1)\n", "        self.param(\"interdig\", self.TypeBoolean, \"Interdigitation\", default=0)\n\t        self.param(\n\t            \"patt\", self.TypeString, \"Pattern in case of Interdigitation\", default=\"\"\n\t        )\n\t        self.param(\n\t            \"patt_lbl\", self.TypeBoolean, \"Interdigitation pattern label\", default=0\n\t        )\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n", "        self.param(\n\t            \"sd_lbl\", self.TypeList, \"Pattern of Source/Drain Labels\", default=[]\n\t        )\n\t        self.param(\"g_lbl\", self.TypeList, \"Pattern of Gate Labels\", default=[])\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate Label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"nfet(L=\" + (\"%.3f\" % self.l_gate) + \",W=\" + (\"%.3f\" % self.w_gate) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the\n", "        # numeric parameter has changed (by comparing against the effective\n\t        # radius ru) and set ru to the effective radius. We also update the\n\t        # numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_gate * self.l_gate\n\t        self.perim = 2 * (self.w_gate + self.l_gate)\n\t        # w,l must be larger or equal than min. values.\n\t        if self.volt == \"3.3V\":\n\t            self.l_gate = max(self.l_gate, fet_3p3_l)\n\t            self.w_gate = max(self.w_gate, fet_3p3_w)\n\t            if self.con_bet_fin == 1 and (self.w_gate) < fet_3p3_w_con:\n", "                self.w_gate = fet_3p3_w_con\n\t        elif self.volt == \"5V\":\n\t            self.l_gate = max(self.l_gate, nfet_05v0_l)\n\t            self.w_gate = max(self.w_gate, fet_5_6_w)\n\t        elif self.volt == \"6V\":\n\t            self.l_gate = max(self.l_gate, nfet_06v0_l)\n\t            self.w_gate = max(self.w_gate, fet_5_6_w)\n\t        self.ld = max(self.ld, fet_ld)\n\t        self.grw = max(self.grw, fet_grw)\n\t    def can_create_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.l_gateayout.dbu / 2\n\t        self.l_gate = self.l_gateayout.get_info(self.l_gateayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n", "        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        instance = draw_nfet(\n\t            layout=self.layout,\n\t            l_gate=self.l_gate,\n\t            w_gate=self.w_gate,\n\t            sd_con_col=self.sd_con_col,\n\t            inter_sd_l=self.ld,\n\t            nf=self.nf,\n", "            grw=self.grw,\n\t            bulk=self.bulk,\n\t            volt=self.volt,\n\t            con_bet_fin=self.con_bet_fin,\n\t            gate_con_pos=self.gate_con_pos,\n\t            interdig=self.interdig,\n\t            patt=self.patt,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n", "            sd_lbl=self.sd_lbl,\n\t            g_lbl=self.g_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t            patt_lbl=self.patt_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n", "            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass pfet(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    PFET Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n", "        # Initialize super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Deep NWELL Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Operating Voltage\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5V\", \"5V\")\n\t        self.Type_handle.add_choice(\"6V\", \"6V\")\n\t        self.Type_handle = self.param(\"bulk\", self.TypeList, \"Bulk Type\")\n", "        self.Type_handle.add_choice(\"None\", \"None\")\n\t        self.Type_handle.add_choice(\"Bulk Tie\", \"Bulk Tie\")\n\t        self.Type_handle.add_choice(\"Guard Ring\", \"Guard Ring\")\n\t        self.param(\"w_gate\", self.TypeDouble, \"Width\", default=fet_3p3_w, unit=\"um\")\n\t        self.param(\"l_gate\", self.TypeDouble, \"Length\", default=fet_3p3_l, unit=\"um\")\n\t        self.param(\"ld\", self.TypeDouble, \"Diffusion Length\", default=fet_ld, unit=\"um\")\n\t        self.param(\"nf\", self.TypeInt, \"Number of Fingers\", default=1)\n\t        self.param(\n\t            \"grw\", self.TypeDouble, \"Guard Ring Width\", default=fet_grw, unit=\"um\"\n\t        )\n", "        self.Type_handle = self.param(\n\t            \"gate_con_pos\", self.TypeList, \"Gate Contact Position\"\n\t        )\n\t        self.Type_handle.add_choice(\"top\", \"top\")\n\t        self.Type_handle.add_choice(\"bottom\", \"bottom\")\n\t        self.Type_handle.add_choice(\"alternating\", \"alternating\")\n\t        self.param(\n\t            \"con_bet_fin\", self.TypeBoolean, \"Contact Between Fingers\", default=1\n\t        )\n\t        self.param(\"sd_con_col\", self.TypeInt, \"Diffusion Contacts Columns\", default=1)\n", "        self.param(\"interdig\", self.TypeBoolean, \"Interdigitation\", default=0)\n\t        self.param(\n\t            \"patt\", self.TypeString, \"Pattern in case of Interdigitation\", default=\"\"\n\t        )\n\t        self.param(\n\t            \"patt_lbl\", self.TypeBoolean, \"Interdigitation pattern label\", default=0\n\t        )\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n", "        self.param(\n\t            \"sd_lbl\", self.TypeList, \"Pattern of Source/Drain Labels\", default=[]\n\t        )\n\t        self.param(\"g_lbl\", self.TypeList, \"Pattern of Gate Labels\", default=[])\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate Label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"pfet(L=\" + (\"%.3f\" % self.l_gate) + \",W=\" + (\"%.3f\" % self.w_gate) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the\n", "        # numeric parameter has changed (by comparing against the effective\n\t        # radius ru) and set ru to the effective radius. We also update the\n\t        # numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_gate * self.l_gate\n\t        self.perim = 2 * (self.w_gate + self.l_gate)\n\t        # w,l must be larger or equal than min. values.\n\t        if self.volt == \"3.3V\":\n\t            self.l_gate = max(self.l_gate, fet_3p3_l)\n\t            self.w_gate = max(self.w_gate, fet_3p3_w)\n\t            if self.con_bet_fin == 1 and (self.w_gate) < fet_3p3_w_con:\n", "                self.w_gate = fet_3p3_w_con\n\t        elif self.volt == \"5V\":\n\t            self.l_gate = max(self.l_gate, pfet_05v0_l)\n\t            self.w_gate = max(self.w_gate, fet_5_6_w)\n\t        elif self.volt == \"6V\":\n\t            self.l_gate = max(self.l_gate, pfet_06v0_l)\n\t            self.w_gate = max(self.w_gate, fet_5_6_w)\n\t        self.ld = max(self.ld, fet_ld)\n\t        self.grw = max(self.grw, fet_grw)\n\t    def can_create_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.l_gateayout.dbu / 2\n\t        self.l_gate = self.l_gateayout.get_info(self.l_gateayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n", "        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        instance = draw_pfet(\n\t            self.layout,\n\t            l_gate=self.l_gate,\n\t            w_gate=self.w_gate,\n\t            sd_con_col=self.sd_con_col,\n\t            inter_sd_l=self.ld,\n\t            nf=self.nf,\n", "            grw=self.grw,\n\t            bulk=self.bulk,\n\t            volt=self.volt,\n\t            con_bet_fin=self.con_bet_fin,\n\t            gate_con_pos=self.gate_con_pos,\n\t            interdig=self.interdig,\n\t            patt=self.patt,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n", "            sd_lbl=self.sd_lbl,\n\t            g_lbl=self.g_lbl,\n\t            sub_lbl=self.sub_lbl,\n\t            patt_lbl=self.patt_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n", "            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass nfet_06v0_nvt(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    6V Native NFET Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n", "        # Initialize super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.Type_handle = self.param(\"bulk\", self.TypeList, \"Bulk Type\")\n\t        self.Type_handle.add_choice(\"None\", \"None\")\n\t        self.Type_handle.add_choice(\"Bulk Tie\", \"Bulk Tie\")\n\t        self.Type_handle.add_choice(\"Guard Ring\", \"Guard Ring\")\n\t        self.param(\"w_gate\", self.TypeDouble, \"Width\", default=nfet_nat_w, unit=\"um\")\n\t        self.param(\"l_gate\", self.TypeDouble, \"Length\", default=nfet_nat_l, unit=\"um\")\n\t        self.param(\"ld\", self.TypeDouble, \"Diffusion Length\", default=fet_ld, unit=\"um\")\n", "        self.param(\"nf\", self.TypeInt, \"Number of Fingers\", default=1)\n\t        self.param(\n\t            \"grw\", self.TypeDouble, \"Guard Ring Width\", default=fet_grw, unit=\"um\"\n\t        )\n\t        self.Type_handle = self.param(\n\t            \"gate_con_pos\", self.TypeList, \"Gate Contact Position\"\n\t        )\n\t        self.Type_handle.add_choice(\"top\", \"top\")\n\t        self.Type_handle.add_choice(\"bottom\", \"bottom\")\n\t        self.Type_handle.add_choice(\"alternating\", \"alternating\")\n", "        self.param(\n\t            \"con_bet_fin\", self.TypeBoolean, \"Contact Between Fingers\", default=1\n\t        )\n\t        self.param(\"sd_con_col\", self.TypeInt, \"Diffusion Contacts Columns\", default=1)\n\t        self.param(\"interdig\", self.TypeBoolean, \"Interdigitation\", default=0)\n\t        self.param(\n\t            \"patt\", self.TypeString, \"Pattern in case of Interdigitation\", default=\"\"\n\t        )\n\t        self.param(\n\t            \"patt_lbl\", self.TypeBoolean, \"Interdigitation pattern label\", default=0\n", "        )\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\n\t            \"sd_lbl\", self.TypeList, \"Pattern of Source/Drain Labels\", default=[]\n\t        )\n\t        self.param(\"g_lbl\", self.TypeList, \"Pattern of Gate Labels\", default=[])\n\t        self.param(\"sub_lbl\", self.TypeString, \"Substrate Label\", default=\"\")\n\t    def display_text_impl(self):\n", "        # Provide a descriptive text for the cell\n\t        return (\n\t            \"nfet_06v0_nvt(L=\"\n\t            + (\"%.3f\" % self.l_gate)\n\t            + \",W=\"\n\t            + (\"%.3f\" % self.w_gate)\n\t            + \")\"\n\t        )\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the\n", "        # numeric parameter has changed (by comparing against the effective\n\t        # radius ru) and set ru to the effective radius. We also update the\n\t        # numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.w_gate * self.l_gate\n\t        self.perim = 2 * (self.w_gate + self.l_gate)\n\t        # w,l must be larger or equal than min. values.\n\t        self.l_gate = max(self.l_gate, nfet_nat_l)\n\t        self.w_gate = max(self.w_gate, nfet_nat_w)\n\t        self.grw = max(self.grw, fet_grw)\n\t        self.ld = max(self.ld, fet_ld)\n", "    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.l_gateayout.dbu / 2\n\t        self.l_gate = self.l_gateayout.get_info(self.l_gateayer)\n\t    def transformation_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        instance = draw_nfet_06v0_nvt(\n\t            self.layout,\n\t            l_gate=self.l_gate,\n\t            w_gate=self.w_gate,\n\t            sd_con_col=self.sd_con_col,\n\t            inter_sd_l=self.ld,\n", "            nf=self.nf,\n\t            grw=self.grw,\n\t            bulk=self.bulk,\n\t            con_bet_fin=self.con_bet_fin,\n\t            gate_con_pos=self.gate_con_pos,\n\t            interdig=self.interdig,\n\t            patt=self.patt,\n\t            lbl=self.lbl,\n\t            sd_lbl=self.sd_lbl,\n\t            g_lbl=self.g_lbl,\n", "            sub_lbl=self.sub_lbl,\n\t            patt_lbl=self.patt_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n", "        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_bjt.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t## BJT Pcells Generators for Klayout of GF180MCU\n\t########################################################################################################################\n\timport os\n\tgds_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"bjt\")\n\tdef draw_bjt(layout, device_name):\n\t    gds_file = f\"{gds_path}/{device_name}.gds\"\n", "    if os.path.exists(gds_file) and os.path.isfile(gds_file):\n\t        layout.read(gds_file)\n\t    else:\n\t        print(f\"{gds_file} is not exist, please recheck\")\n\t    return layout.cell(device_name)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_res.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t## Resistor Pcells Generators for Klayout of GF180MCU\n\t########################################################################################################################\n\timport gdsfactory as gf\n\tfrom gdsfactory.typings import Float2, LayerSpec\n\tfrom .layers_def import layer\n\tfrom .via_generator import via_generator, via_stack\n", "def draw_metal_res(\n\t    layout,\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"rm1\",\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t) -> gf.Component:\n\t    \"\"\"\n", "    Usage:-\n\t     used to draw 2-terminal Metal resistor by specifying parameters\n\t    Arguments:-\n\t     layout : Object of layout\n\t     l      : Float of diff length\n\t     w      : Float of diff width\n\t    \"\"\"\n\t    c = gf.Component(\"res_dev\")\n\t    m_ext = 0.28\n\t    if res_type == \"rm1\":\n", "        m_layer = layer[\"metal1\"]\n\t        res_layer = layer[\"metal1_res\"]\n\t        m_lbl_layer = layer[\"metal1_label\"]\n\t    elif res_type == \"rm2\":\n\t        m_layer = layer[\"metal2\"]\n\t        res_layer = layer[\"metal2_res\"]\n\t        m_lbl_layer = layer[\"metal2_label\"]\n\t    elif res_type == \"rm3\":\n\t        m_layer = layer[\"metal3\"]\n\t        res_layer = layer[\"metal3_res\"]\n", "        m_lbl_layer = layer[\"metal3_label\"]\n\t    else:\n\t        m_layer = layer[\"metaltop\"]\n\t        res_layer = layer[\"metal6_res\"]\n\t        m_lbl_layer = layer[\"metaltop_label\"]\n\t    res_mk = c.add_ref(gf.components.rectangle(size=(l_res, w_res), layer=res_layer))\n\t    m_rect = c.add_ref(\n\t        gf.components.rectangle(size=(l_res + (2 * m_ext), w_res), layer=m_layer)\n\t    )\n\t    m_rect.xmin = res_mk.xmin - m_ext\n", "    m_rect.ymin = res_mk.ymin\n\t    # labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n\t                res_mk.xmin + (res_mk.size[0] / 2),\n\t                res_mk.ymin + (res_mk.size[1] / 2),\n\t            ),\n\t            layer=m_lbl_layer,\n", "        )\n\t        c.add_label(\n\t            r1_lbl,\n\t            position=(\n\t                m_rect.xmin + (res_mk.xmin - m_rect.xmin) / 2,\n\t                m_rect.ymin + (m_rect.size[1] / 2),\n\t            ),\n\t            layer=m_lbl_layer,\n\t        )\n\t    # creating layout and cell in klayout\n", "    c.write_gds(\"res_temp.gds\")\n\t    layout.read(\"res_temp.gds\")\n\t    cell_name = \"res_dev\"\n\t    return layout.cell(cell_name)\n\t@gf.cell\n\tdef pcmpgr_gen(dn_rect, grw: float = 0.36) -> gf.Component:\n\t    \"\"\"Return deepnwell guardring\n\t    Args :\n\t        dn_rect : deepnwell polygon\n\t        grw : guardring width\n", "    \"\"\"\n\t    c = gf.Component()\n\t    comp_pp_enc: float = 0.16\n\t    con_size = 0.22\n\t    con_sp = 0.28\n\t    con_comp_enc = 0.07\n\t    pcmpgr_enc_dn = 2.5\n\t    c_temp_gr = gf.Component(\"temp_store guard ring\")\n\t    rect_pcmpgr_in = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n\t                (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_pcmpgr_in.move((dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn))\n\t    rect_pcmpgr_out = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n\t                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n\t            ),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n\t    c.add_ref(\n\t        gf.geometry.boolean(\n", "            A=rect_pcmpgr_out,\n\t            B=rect_pcmpgr_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )  # guardring bulk\n\t    psdm_in = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n", "                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n\t    psdm_in.move(\n\t        (\n\t            rect_pcmpgr_in.xmin + comp_pp_enc,\n\t            rect_pcmpgr_in.ymin + comp_pp_enc,\n\t        )\n", "    )\n\t    psdm_out = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n\t                (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n\t            ),\n\t            layer=layer[\"pplus\"],\n\t        )\n\t    )\n", "    psdm_out.move(\n\t        (\n\t            rect_pcmpgr_out.xmin - comp_pp_enc,\n\t            rect_pcmpgr_out.ymin - comp_pp_enc,\n\t        )\n\t    )\n\t    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n\t        )\n", "    )  # pplus_draw\n\t    # generating contacts\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_pcmpgr_in.xmin + con_size,\n\t                rect_pcmpgr_in.xmax - con_size,\n\t            ),\n\t            y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n", "            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # bottom contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(\n\t                rect_pcmpgr_in.xmin + con_size,\n\t                rect_pcmpgr_in.xmax - con_size,\n", "            ),\n\t            y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # upper contact\n\t    c.add_ref(\n\t        via_generator(\n", "            x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n\t            y_range=(\n\t                rect_pcmpgr_in.ymin + con_size,\n\t                rect_pcmpgr_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n\t            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n", "    )  # right contact\n\t    c.add_ref(\n\t        via_generator(\n\t            x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n\t            y_range=(\n\t                rect_pcmpgr_in.ymin + con_size,\n\t                rect_pcmpgr_in.ymax - con_size,\n\t            ),\n\t            via_enclosure=(con_comp_enc, con_comp_enc),\n\t            via_layer=layer[\"contact\"],\n", "            via_size=(con_size, con_size),\n\t            via_spacing=(con_sp, con_sp),\n\t        )\n\t    )  # left contact\n\t    comp_m1_in = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n", "    comp_m1_out = c_temp_gr.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                (comp_m1_in.size[0]) + 2 * grw,\n\t                (comp_m1_in.size[1]) + 2 * grw,\n\t            ),\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )\n\t    comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n", "    c.add_ref(\n\t        gf.geometry.boolean(\n\t            A=rect_pcmpgr_out,\n\t            B=rect_pcmpgr_in,\n\t            operation=\"A-B\",\n\t            layer=layer[\"metal1\"],\n\t        )\n\t    )  # metal1 guardring\n\t    return c\n\t@gf.cell\n", "def plus_res_inst(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"nplus_s\",\n\t    sub: bool = 0,\n\t    cmp_res_ext: float = 0.1,\n\t    con_enc: float = 0.1,\n\t    cmp_imp_layer: LayerSpec = layer[\"nplus\"],\n\t    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n\t    lbl: bool = 0,\n", "    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component()\n\t    np_enc_cmp: float = 0.16\n\t    res_mk = c.add_ref(\n\t        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n\t    )\n\t    if \"plus_u\" in res_type:\n", "        sab_res_ext = 0.22\n\t        sab_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n\t                layer=layer[\"sab\"],\n\t            )\n\t        )\n\t        sab_rect.xmin = res_mk.xmin\n\t        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\t    cmp = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(res_mk.size[0] + (2 * cmp_res_ext), res_mk.size[1]),\n\t            layer=layer[\"comp\"],\n\t        )\n\t    )\n\t    cmp.xmin = res_mk.xmin - cmp_res_ext\n\t    cmp.ymin = res_mk.ymin\n\t    cmp_con = via_stack(\n\t        x_range=(cmp.xmin, res_mk.xmin + con_enc),\n\t        y_range=(cmp.ymin, cmp.ymax),\n", "        base_layer=layer[\"comp\"],\n\t        metal_level=1,\n\t    )\n\t    cmp_con_arr = c.add_array(\n\t        component=cmp_con,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(cmp_res_ext - con_enc + res_mk.size[0], 0),\n\t    )  # comp contact array\n\t    # labels generation\n", "    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n\t                cmp_con_arr.xmin + (cmp_con.size[0] / 2),\n\t                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n", "            r1_lbl,\n\t            position=(\n\t                cmp_con_arr.xmax - (cmp_con.size[0] / 2),\n\t                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    cmp_imp = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(cmp.size[0] + (2 * np_enc_cmp), cmp.size[1] + (2 * np_enc_cmp)),\n", "            layer=cmp_imp_layer,\n\t        )\n\t    )\n\t    cmp_imp.xmin = cmp.xmin - np_enc_cmp\n\t    cmp_imp.ymin = cmp.ymin - np_enc_cmp\n\t    if sub == 1:\n\t        sub_w: float = 0.36\n\t        sub_rect = c.add_ref(\n\t            gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n\t        )\n", "        comp_spacing: float = 0.72\n\t        sub_rect.xmax = cmp.xmin - comp_spacing\n\t        sub_rect.ymin = cmp.ymin\n\t        # sub_rect contact\n\t        sub_con = c.add_ref(\n\t            via_stack(\n\t                x_range=(sub_rect.xmin, sub_rect.xmax),\n\t                y_range=(sub_rect.ymin, sub_rect.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n", "            )\n\t        )\n\t        pp_enc_cmp: float = 0.16\n\t        sub_imp = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                    cmp.size[1] + (2 * pp_enc_cmp),\n\t                ),\n\t                layer=sub_imp_layer,\n", "            )\n\t        )\n\t        sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t        sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\t        # label generation\n\t        if lbl == 1:\n\t            c.add_label(\n\t                sub_lbl,\n\t                position=(\n\t                    sub_con.xmin + (sub_con.size[0] / 2),\n", "                    sub_con.ymin + (sub_con.size[1] / 2),\n\t                ),\n\t                layer=layer[\"metal1_label\"],\n\t            )\n\t    return c\n\tdef draw_nplus_res(\n\t    layout,\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"nplus_s\",\n", "    sub: bool = 0,\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    if res_type == \"nplus_s\":\n", "        cmp_res_ext = 0.29\n\t        con_enc = 0.07\n\t    else:\n\t        cmp_res_ext = 0.44\n\t        con_enc = 0.0\n\t    # adding res inst\n\t    r_inst = c.add_ref(\n\t        plus_res_inst(\n\t            l_res=l_res,\n\t            w_res=w_res,\n", "            res_type=res_type,\n\t            sub=sub,\n\t            cmp_res_ext=cmp_res_ext,\n\t            con_enc=con_enc,\n\t            cmp_imp_layer=layer[\"nplus\"],\n\t            sub_imp_layer=layer[\"pplus\"],\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n\t            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n", "        )\n\t    )\n\t    if deepnwell == 1:\n\t        lvpwell_enc_cmp = 0.43\n\t        lvpwell = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n\t                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n\t                ),\n", "                layer=layer[\"lvpwell\"],\n\t            )\n\t        )\n\t        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n\t        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\t        dn_enc_lvpwell = 2.5\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n", "                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            sub_w = 0.36\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n", "    c.write_gds(\"res_temp.gds\")\n\t    layout.read(\"res_temp.gds\")\n\t    cell_name = \"res_dev\"\n\t    return layout.cell(cell_name)\n\tdef draw_pplus_res(\n\t    layout,\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"pplus_s\",\n\t    sub: bool = 0,\n", "    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    if res_type == \"pplus_s\":\n\t        cmp_res_ext = 0.29\n", "        con_enc = 0.07\n\t    else:\n\t        cmp_res_ext = 0.44\n\t        con_enc = 0.0\n\t    # adding res inst\n\t    r_inst = c.add_ref(\n\t        plus_res_inst(\n\t            l_res=l_res,\n\t            w_res=w_res,\n\t            res_type=res_type,\n", "            sub=1,\n\t            cmp_res_ext=cmp_res_ext,\n\t            con_enc=con_enc,\n\t            cmp_imp_layer=layer[\"pplus\"],\n\t            sub_imp_layer=layer[\"nplus\"],\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n\t            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n\t        )\n", "    )\n\t    if deepnwell == 1:\n\t        dn_enc_ncmp = 0.66\n\t        dn_enc_pcmp = 1.02\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (dn_enc_pcmp + dn_enc_ncmp),\n\t                    r_inst.size[1] + (2 * dn_enc_pcmp),\n\t                ),\n", "                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmax = r_inst.xmax + dn_enc_pcmp\n\t        dn_rect.ymin = r_inst.ymin - dn_enc_pcmp\n\t        if pcmpgr == 1:\n\t            sub_w = 0.36\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    else:\n\t        nw_enc_pcmp = 0.6\n", "        nw_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (2 * nw_enc_pcmp),\n\t                    r_inst.size[1] + (2 * nw_enc_pcmp),\n\t                ),\n\t                layer=layer[\"nwell\"],\n\t            )\n\t        )\n\t        nw_rect.xmin = r_inst.xmin - nw_enc_pcmp\n", "        nw_rect.ymin = r_inst.ymin - nw_enc_pcmp\n\t    c.write_gds(\"res_temp.gds\")\n\t    layout.read(\"res_temp.gds\")\n\t    cell_name = \"res_dev\"\n\t    return layout.cell(cell_name)\n\t@gf.cell\n\tdef polyf_res_inst(\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"npolyf_s\",\n", "    pl_res_ext: float = 0.1,\n\t    con_enc: float = 0.1,\n\t    pl_imp_layer: LayerSpec = layer[\"nplus\"],\n\t    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component()\n", "    sub_w: float = 0.36\n\t    np_enc_poly2 = 0.3\n\t    pp_enc_cmp: float = 0.16\n\t    comp_spacing: float = 0.72\n\t    res_mk = c.add_ref(\n\t        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n\t    )\n\t    if \"polyf_u\" in res_type:\n\t        sab_res_ext = 0.28\n\t        sab_rect = c.add_ref(\n", "            gf.components.rectangle(\n\t                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n\t                layer=layer[\"sab\"],\n\t            )\n\t        )\n\t        sab_rect.xmin = res_mk.xmin\n\t        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\t    pl = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n", "            layer=layer[\"poly2\"],\n\t        )\n\t    )\n\t    pl.xmin = res_mk.xmin - pl_res_ext\n\t    pl.ymin = res_mk.ymin\n\t    pl_con = via_stack(\n\t        x_range=(pl.xmin, res_mk.xmin + con_enc),\n\t        y_range=(pl.ymin, pl.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n", "    )\n\t    pl_con_arr = c.add_array(\n\t        component=pl_con,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(pl_res_ext - con_enc + res_mk.size[0], 0),\n\t    )  # comp contact array\n\t    pl_imp = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(pl.size[0] + (2 * np_enc_poly2), pl.size[1] + (2 * np_enc_poly2)),\n", "            layer=pl_imp_layer,\n\t        )\n\t    )\n\t    pl_imp.xmin = pl.xmin - np_enc_poly2\n\t    pl_imp.ymin = pl.ymin - np_enc_poly2\n\t    sub_rect = c.add_ref(\n\t        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n\t    )\n\t    sub_rect.xmax = pl.xmin - comp_spacing\n\t    sub_rect.ymin = pl.ymin\n", "    # sub_rect contact\n\t    sub_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(sub_rect.xmin, sub_rect.xmax),\n\t            y_range=(sub_rect.ymin, sub_rect.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )\n\t    sub_imp = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                pl.size[1] + (2 * pp_enc_cmp),\n\t            ),\n\t            layer=sub_imp_layer,\n\t        )\n\t    )\n\t    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n", "    # labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n\t                pl_con_arr.xmin + (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n", "        c.add_label(\n\t            r1_lbl,\n\t            position=(\n\t                pl_con_arr.xmax - (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            sub_lbl,\n", "            position=(\n\t                sub_con.xmin + (sub_con.size[0] / 2),\n\t                sub_con.ymin + (sub_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    return c\n\tdef draw_npolyf_res(\n\t    layout,\n\t    l_res: float = 0.1,\n", "    w_res: float = 0.1,\n\t    res_type: str = \"npolyf_s\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n", "    if res_type == \"npolyf_s\":\n\t        pl_res_ext = 0.29\n\t        con_enc = 0.07\n\t    else:\n\t        pl_res_ext = 0.44\n\t        con_enc = 0.0\n\t    # adding res inst\n\t    r_inst = c.add_ref(\n\t        polyf_res_inst(\n\t            l_res=l_res,\n", "            w_res=w_res,\n\t            res_type=res_type,\n\t            pl_res_ext=pl_res_ext,\n\t            con_enc=con_enc,\n\t            pl_imp_layer=layer[\"nplus\"],\n\t            sub_imp_layer=layer[\"pplus\"],\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n\t            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n", "        )\n\t    )\n\t    if deepnwell == 1:\n\t        lvpwell_enc_cmp = 0.43\n\t        lvpwell = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n\t                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n\t                ),\n", "                layer=layer[\"lvpwell\"],\n\t            )\n\t        )\n\t        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n\t        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\t        dn_enc_lvpwell = 2.5\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n", "                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n\t        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            sub_w = 0.36\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n", "    c.write_gds(\"res_temp.gds\")\n\t    layout.read(\"res_temp.gds\")\n\t    cell_name = \"res_dev\"\n\t    return layout.cell(cell_name)\n\tdef draw_ppolyf_res(\n\t    layout,\n\t    l_res: float = 0.1,\n\t    w_res: float = 0.1,\n\t    res_type: str = \"ppolyf_s\",\n\t    deepnwell: bool = 0,\n", "    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    if res_type == \"ppolyf_s\":\n\t        pl_res_ext = 0.29\n\t        con_enc = 0.07\n", "    else:\n\t        pl_res_ext = 0.44\n\t        con_enc = 0.0\n\t    sub_layer = layer[\"nplus\"] if deepnwell == 1 else layer[\"pplus\"]\n\t    # adding res inst\n\t    r_inst = c.add_ref(\n\t        polyf_res_inst(\n\t            l_res=l_res,\n\t            w_res=w_res,\n\t            res_type=res_type,\n", "            pl_res_ext=pl_res_ext,\n\t            con_enc=con_enc,\n\t            pl_imp_layer=layer[\"pplus\"],\n\t            sub_imp_layer=sub_layer,\n\t            lbl=lbl,\n\t            r0_lbl=r0_lbl,\n\t            r1_lbl=r1_lbl,\n\t            sub_lbl=sub_lbl,\n\t        )\n\t    )\n", "    if deepnwell == 1:\n\t        dn_enc_ncmp = 0.66\n\t        dn_enc_poly2 = 1.34\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    r_inst.size[0] + (dn_enc_poly2 + dn_enc_ncmp),\n\t                    r_inst.size[1] + (2 * dn_enc_poly2),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n", "            )\n\t        )\n\t        dn_rect.xmax = r_inst.xmax + dn_enc_poly2\n\t        dn_rect.ymin = r_inst.ymin - dn_enc_poly2\n\t        if pcmpgr == 1:\n\t            sub_w = 0.36\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    c.write_gds(\"res_temp.gds\")\n\t    layout.read(\"res_temp.gds\")\n\t    cell_name = \"res_dev\"\n", "    return layout.cell(cell_name)\n\tdef draw_ppolyf_u_high_Rs_res(\n\t    layout,\n\t    l_res: float = 0.42,\n\t    w_res: float = 0.42,\n\t    volt: str = \"3.3V\",\n\t    deepnwell: bool = 0,\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n\t    r0_lbl: str = \"\",\n", "    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    dn_enc_ncmp = 0.62\n\t    dn_enc_poly2 = 1.34\n\t    pl_res_ext = 0.64\n\t    sub_w: float = 0.42\n\t    pp_enc_poly2 = 0.18\n\t    pp_enc_cmp: float = 0.02\n", "    comp_spacing: float = 0.7\n\t    sab_res_ext = (0.1, 0.28)\n\t    con_size = 0.36\n\t    resis_enc = (1.04, 0.4)\n\t    dg_enc_dn = 0.5\n\t    res_mk = c.add_ref(\n\t        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n\t    )\n\t    resis_mk = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                res_mk.size[0] + (2 * resis_enc[0]),\n\t                res_mk.size[1] + (2 * resis_enc[1]),\n\t            ),\n\t            layer=layer[\"resistor\"],\n\t        )\n\t    )\n\t    resis_mk.xmin = res_mk.xmin - resis_enc[0]\n\t    resis_mk.ymin = res_mk.ymin - resis_enc[1]\n\t    sab_rect = c.add_ref(\n", "        gf.components.rectangle(\n\t            size=(\n\t                res_mk.size[0] + (2 * sab_res_ext[0]),\n\t                res_mk.size[1] + (2 * sab_res_ext[1]),\n\t            ),\n\t            layer=layer[\"sab\"],\n\t        )\n\t    )\n\t    sab_rect.xmin = res_mk.xmin - sab_res_ext[0]\n\t    sab_rect.ymin = res_mk.ymin - sab_res_ext[1]\n", "    pl = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n\t            layer=layer[\"poly2\"],\n\t        )\n\t    )\n\t    pl.xmin = res_mk.xmin - pl_res_ext\n\t    pl.ymin = res_mk.ymin\n\t    pl_con = via_stack(\n\t        x_range=(pl.xmin, pl.xmin + con_size),\n", "        y_range=(pl.ymin, pl.ymax),\n\t        base_layer=layer[\"poly2\"],\n\t        metal_level=1,\n\t    )\n\t    pl_con_arr = c.add_array(\n\t        component=pl_con,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(pl.size[0] - con_size, 0),\n\t    )  # comp contact array\n", "    pplus = gf.components.rectangle(\n\t        size=(pl_res_ext + pp_enc_poly2, pl.size[1] + (2 * pp_enc_poly2)),\n\t        layer=layer[\"pplus\"],\n\t    )\n\t    pplus_arr = c.add_array(\n\t        component=pplus, rows=1, columns=2, spacing=(pplus.size[0] + res_mk.size[0], 0)\n\t    )\n\t    pplus_arr.xmin = pl.xmin - pp_enc_poly2\n\t    pplus_arr.ymin = pl.ymin - pp_enc_poly2\n\t    sub_rect = c.add_ref(\n", "        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n\t    )\n\t    sub_rect.xmax = pl.xmin - comp_spacing\n\t    sub_rect.ymin = pl.ymin\n\t    # sub_rect contact\n\t    sub_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(sub_rect.xmin, sub_rect.xmax),\n\t            y_range=(sub_rect.ymin, sub_rect.ymax),\n\t            base_layer=layer[\"comp\"],\n", "            metal_level=1,\n\t        )\n\t    )\n\t    # labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n\t                pl_con_arr.xmin + (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n", "            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            r1_lbl,\n\t            position=(\n\t                pl_con_arr.xmax - (pl_con.size[0] / 2),\n\t                pl_con_arr.ymin + (pl_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n", "        )\n\t        c.add_label(\n\t            sub_lbl,\n\t            position=(\n\t                sub_con.xmin + (sub_con.size[0] / 2),\n\t                sub_con.ymin + (sub_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    if deepnwell == 1:\n", "        sub_layer = layer[\"nplus\"]\n\t    else:\n\t        sub_layer = layer[\"pplus\"]\n\t    sub_imp = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(\n\t                sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                pl.size[1] + (2 * pp_enc_cmp),\n\t            ),\n\t            layer=sub_layer,\n", "        )\n\t    )\n\t    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\t    if deepnwell == 1:\n\t        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    (pl.xmax - sub_rect.xmin) + (dn_enc_poly2 + dn_enc_ncmp),\n\t                    pl.size[1] + (2 * dn_enc_poly2),\n", "                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmax = pl.xmax + dn_enc_poly2\n\t        dn_rect.ymin = pl.ymin - dn_enc_poly2\n\t        if volt == \"5/6V\":\n\t            dg = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(\n", "                        dn_rect.size[0] + (2 * dg_enc_dn),\n\t                        dn_rect.size[1] + (2 * dg_enc_dn),\n\t                    ),\n\t                    layer=layer[\"dualgate\"],\n\t                )\n\t            )\n\t            dg.xmin = dn_rect.xmin - dg_enc_dn\n\t            dg.ymin = dn_rect.ymin - dg_enc_dn\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n", "    else:\n\t        if volt == \"5/6V\":\n\t            dg = c.add_ref(\n\t                gf.components.rectangle(\n\t                    size=(resis_mk.size[0], resis_mk.size[1]), layer=layer[\"dualgate\"]\n\t                )\n\t            )\n\t            dg.xmin = resis_mk.xmin\n\t            dg.ymin = resis_mk.ymin\n\t    c.write_gds(\"res_temp.gds\")\n", "    layout.read(\"res_temp.gds\")\n\t    cell_name = \"res_dev\"\n\t    return layout.cell(cell_name)\n\tdef draw_well_res(\n\t    layout,\n\t    l_res: float = 0.42,\n\t    w_res: float = 0.42,\n\t    res_type: str = \"nwell\",\n\t    pcmpgr: bool = 0,\n\t    lbl: bool = 0,\n", "    r0_lbl: str = \"\",\n\t    r1_lbl: str = \"\",\n\t    sub_lbl: str = \"\",\n\t) -> gf.Component:\n\t    c = gf.Component(\"res_dev\")\n\t    nw_res_ext = 0.48\n\t    nw_res_enc = 0.5\n\t    nw_enc_cmp = 0.12\n\t    sub_w: float = 0.36\n\t    pp_enc_cmp: float = 0.16\n", "    nw_comp_spacing: float = 0.72\n\t    dn_enc_lvpwell = 2.5\n\t    if res_type == \"pwell\":\n\t        cmp_imp_layer = layer[\"pplus\"]\n\t        sub_imp_layer = layer[\"nplus\"]\n\t        well_layer = layer[\"lvpwell\"]\n\t    else:\n\t        cmp_imp_layer = layer[\"nplus\"]\n\t        sub_imp_layer = layer[\"pplus\"]\n\t        well_layer = layer[\"nwell\"]\n", "    res_mk = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(l_res, w_res + (2 * nw_res_enc)), layer=layer[\"res_mk\"]\n\t        )\n\t    )\n\t    well_rect = c.add_ref(\n\t        gf.components.rectangle(\n\t            size=(res_mk.size[0] + (2 * nw_res_ext), w_res), layer=well_layer\n\t        )\n\t    )\n", "    well_rect.xmin = res_mk.xmin - nw_res_ext\n\t    well_rect.ymin = res_mk.ymin + nw_res_enc\n\t    @gf.cell\n\t    def comp_related_gen(size: Float2 = (0.42, 0.42)) -> gf.Component:\n\t        c = gf.Component()\n\t        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\t        cmp.xmin = well_rect.xmin + nw_enc_cmp\n\t        cmp.ymin = well_rect.ymin + nw_enc_cmp\n\t        c.add_ref(\n\t            via_stack(\n", "                x_range=(cmp.xmin, cmp.xmax),\n\t                y_range=(cmp.ymin, cmp.ymax),\n\t                base_layer=layer[\"comp\"],\n\t                metal_level=1,\n\t            )\n\t        )  # contact\n\t        return c\n\t    con_polys = comp_related_gen(\n\t        size=(\n\t            res_mk.xmin - well_rect.xmin - nw_enc_cmp,\n", "            well_rect.size[1] - (2 * nw_enc_cmp),\n\t        )\n\t    )\n\t    con_polys_arr = c.add_array(\n\t        component=con_polys,\n\t        rows=1,\n\t        columns=2,\n\t        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n\t    )  # comp and its related contact array\n\t    nplus_rect = gf.components.rectangle(\n", "        size=(\n\t            con_polys.size[0] + (2 * pp_enc_cmp),\n\t            con_polys.size[1] + (2 * pp_enc_cmp),\n\t        ),\n\t        layer=cmp_imp_layer,\n\t    )\n\t    nplus_arr = c.add_array(\n\t        component=nplus_rect,\n\t        rows=1,\n\t        columns=2,\n", "        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n\t    )\n\t    nplus_arr.xmin = con_polys.xmin - pp_enc_cmp\n\t    nplus_arr.ymin = con_polys.ymin - pp_enc_cmp\n\t    sub_rect = c.add_ref(\n\t        gf.components.rectangle(size=(sub_w, well_rect.size[1]), layer=layer[\"comp\"])\n\t    )\n\t    sub_rect.xmax = well_rect.xmin - nw_comp_spacing\n\t    sub_rect.ymin = well_rect.ymin\n\t    # sub_rect contact\n", "    sub_con = c.add_ref(\n\t        via_stack(\n\t            x_range=(sub_rect.xmin, sub_rect.xmax),\n\t            y_range=(sub_rect.ymin, sub_rect.ymax),\n\t            base_layer=layer[\"comp\"],\n\t            metal_level=1,\n\t        )\n\t    )\n\t    sub_imp = c.add_ref(\n\t        gf.components.rectangle(\n", "            size=(\n\t                sub_rect.size[0] + (2 * pp_enc_cmp),\n\t                well_rect.size[1] + (2 * pp_enc_cmp),\n\t            ),\n\t            layer=sub_imp_layer,\n\t        )\n\t    )\n\t    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n\t    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\t    if res_type == \"pwell\":\n", "        dn_rect = c.add_ref(\n\t            gf.components.rectangle(\n\t                size=(\n\t                    well_rect.size[0] + (2 * dn_enc_lvpwell),\n\t                    well_rect.size[1] + (2 * dn_enc_lvpwell),\n\t                ),\n\t                layer=layer[\"dnwell\"],\n\t            )\n\t        )\n\t        dn_rect.xmin = well_rect.xmin - dn_enc_lvpwell\n", "        dn_rect.ymin = well_rect.ymin - dn_enc_lvpwell\n\t        if pcmpgr == 1:\n\t            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\t    # labels generation\n\t    if lbl == 1:\n\t        c.add_label(\n\t            r0_lbl,\n\t            position=(\n\t                con_polys_arr.xmin + (con_polys.size[0] / 2),\n\t                con_polys_arr.ymin + (con_polys.size[1] / 2),\n", "            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t        c.add_label(\n\t            r1_lbl,\n\t            position=(\n\t                con_polys_arr.xmax - (con_polys.size[0] / 2),\n\t                con_polys_arr.ymin + (con_polys.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n", "        )\n\t        c.add_label(\n\t            sub_lbl,\n\t            position=(\n\t                sub_con.xmin + (sub_con.size[0] / 2),\n\t                sub_con.ymin + (sub_con.size[1] / 2),\n\t            ),\n\t            layer=layer[\"metal1_label\"],\n\t        )\n\t    c.write_gds(\"res_temp.gds\")\n", "    layout.read(\"res_temp.gds\")\n\t    cell_name = \"res_dev\"\n\t    return layout.cell(cell_name)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/cap_mim.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t# MIM Capacitor Generator for GF180MCU\n\t########################################################################################################################\n\timport os\n\timport pya\n\tfrom .draw_cap_mim import draw_cap_mim\n\tmim_l = 1.02\n", "mim_w = 1.02\n\tclass cap_mim(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    MIM capacitor Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.Type_handle = self.param(\"mim_option\", self.TypeList, \"MIM-Option\")\n", "        self.Type_handle.add_choice(\"MIM-A\", \"MIM-A\")\n\t        self.Type_handle.add_choice(\"MIM-B\", \"MIM-B\")\n\t        self.Type_handle2 = self.param(\n\t            \"metal_level\", self.TypeList, \"Metal level (MIM-B)\"\n\t        )\n\t        self.Type_handle2.add_choice(\"M4\", \"M4\")\n\t        self.Type_handle2.add_choice(\"M5\", \"M5\")\n\t        self.Type_handle2.add_choice(\"M6\", \"M6\")\n\t        self.param(\"lc\", self.TypeDouble, \"Length\", default=mim_l, unit=\"um\")\n\t        self.param(\"wc\", self.TypeDouble, \"Width\", default=mim_w, unit=\"um\")\n", "        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"top_lbl\", self.TypeString, \"Top plate label\", default=\"\")\n\t        self.param(\"bot_lbl\", self.TypeString, \"Bottom plate label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"cap_mim(L=\" + (\"%.3f\" % self.lc) + \",W=\" + (\"%.3f\" % self.wc) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n", "        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wc * self.lc\n\t        self.perim = 2 * (self.wc + self.lc)\n\t        # w,l must be larger or equal than min. values.\n\t        self.lc = max(self.lc, mim_l)\n\t        self.wc = max(self.wc, mim_w)\n\t        if (self.mim_option) == \"MIM-A\":\n\t            self.metal_level = \"M3\"\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n", "        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.lc = self.layout.get_info(self.layer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n", "        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        option = os.environ[\"GF_PDK_OPTION\"]\n\t        if (\n\t            option == \"A\"\n\t            and (self.mim_option) == \"MIM-B\"\n\t            or option != \"A\"\n\t            and (self.mim_option) == \"MIM-A\"\n\t        ):\n\t            raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n", "        np_instance = draw_cap_mim(\n\t            self.layout,\n\t            lc=self.lc,\n\t            wc=self.wc,\n\t            mim_option=self.mim_option,\n\t            metal_level=self.metal_level,\n\t            lbl=self.lbl,\n\t            top_lbl=self.top_lbl,\n\t            bot_lbl=self.bot_lbl,\n\t        )\n", "        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/diode.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t# Diode Generator for GF180MCU\n\t########################################################################################################################\n\timport pya\n\tfrom .draw_diode import (\n\t    draw_diode_dw2ps,\n\t    draw_diode_nd2ps,\n", "    draw_diode_nw2ps,\n\t    draw_diode_pd2nw,\n\t    draw_diode_pw2dw,\n\t    draw_sc_diode,\n\t)\n\tnp_l = 0.36\n\tnp_w = 0.36\n\tpn_l = 0.36\n\tpn_w = 0.36\n\tnwp_l = 0.36\n", "nwp_w = 0.36\n\tdiode_pw2dw_l = 0.36\n\tdiode_pw2dw_w = 0.36\n\tdiode_dw2ps_l = 0.36\n\tdiode_dw2ps_w = 0.36\n\tsc_l = 1\n\tsc_w = 0.62\n\tclass diode_nd2ps(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    N+/LVPWELL diode (Outside DNWELL) Generator for GF180MCU\n", "    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n", "        self.param(\"la\", self.TypeDouble, \"Length\", default=np_l, unit=\"um\")\n\t        self.param(\"wa\", self.TypeDouble, \"Width\", default=np_w, unit=\"um\")\n\t        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\t        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n", "        return \"diode_nd2ps(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wa * self.la\n\t        self.perim = 2 * (self.wa + self.la)\n\t        # w,l must be larger or equal than min. values.\n\t        self.la = max(self.la, np_l)\n\t        self.wa = max(self.wa, np_w)\n\t        self.cw = max(self.cw, np_w)\n", "    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.la = self.layout.get_info(self.laayer)\n\t    def transformation_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        np_instance = draw_diode_nd2ps(\n\t            self.layout,\n\t            la=self.la,\n\t            wa=self.wa,\n\t            cw=self.cw,\n\t            volt=self.volt,\n", "            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            p_lbl=self.p_lbl,\n\t            n_lbl=self.n_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n", "            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass diode_pd2nw(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    P+/Nwell diode (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n", "    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\"la\", self.TypeDouble, \"Length\", default=pn_l, unit=\"um\")\n", "        self.param(\"wa\", self.TypeDouble, \"Width\", default=pn_w, unit=\"um\")\n\t        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\t        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"diode_pd2nw(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n", "    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wa * self.la\n\t        self.perim = 2 * (self.wa + self.la)\n\t        # w,l must be larger or equal than min. values.\n\t        self.la = max(self.la, pn_l)\n\t        self.wa = max(self.wa, pn_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n", "        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.la = self.layout.get_info(self.laayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n", "        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        np_instance = draw_diode_pd2nw(\n\t            self.layout,\n\t            la=self.la,\n\t            wa=self.wa,\n\t            cw=self.cw,\n\t            volt=self.volt,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n", "            lbl=self.lbl,\n\t            p_lbl=self.p_lbl,\n\t            n_lbl=self.n_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n", "            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass diode_nw2ps(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    Nwell/Psub diode Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n", "        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\"la\", self.TypeDouble, \"Length\", default=nwp_l, unit=\"um\")\n\t        self.param(\"wa\", self.TypeDouble, \"Width\", default=nwp_w, unit=\"um\")\n\t        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n", "        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\t        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"diode_nw2ps(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wa * self.la\n", "        self.perim = 2 * (self.wa + self.la)\n\t        # w,l must be larger or equal than min. values.\n\t        self.la = max(self.la, nwp_l)\n\t        self.wa = max(self.wa, nwp_w)\n\t        self.cw = max(self.cw, nwp_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.la = self.layout.get_info(self.laayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        nwp_instance = draw_diode_nw2ps(\n", "            self.layout,\n\t            la=self.la,\n\t            wa=self.wa,\n\t            cw=self.cw,\n\t            volt=self.volt,\n\t            lbl=self.lbl,\n\t            p_lbl=self.p_lbl,\n\t            n_lbl=self.n_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n", "            nwp_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass diode_pw2dw(pya.PCellDeclarationHelper):\n", "    \"\"\"\n\t    LVPWELL/DNWELL diode Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n", "        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\"la\", self.TypeDouble, \"Length\", default=diode_pw2dw_l, unit=\"um\")\n\t        self.param(\"wa\", self.TypeDouble, \"Width\", default=diode_pw2dw_w, unit=\"um\")\n\t        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\t        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\t    def display_text_impl(self):\n", "        # Provide a descriptive text for the cell\n\t        return \"diode_pw2dw(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wa * self.la\n\t        self.perim = 2 * (self.wa + self.la)\n\t        # w,l must be larger or equal than min. values.\n\t        self.la = max(self.la, diode_pw2dw_l)\n\t        self.wa = max(self.wa, diode_pw2dw_w)\n", "        self.cw = max(self.cw, diode_pw2dw_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.la = self.layout.get_info(self.laayer)\n", "    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        diode_pw2dw_instance = draw_diode_pw2dw(\n\t            self.layout,\n\t            la=self.la,\n\t            wa=self.wa,\n\t            cw=self.cw,\n", "            volt=self.volt,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            p_lbl=self.p_lbl,\n\t            n_lbl=self.n_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            diode_pw2dw_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n", "            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass diode_dw2ps(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    LVPWELL/DNWELL diode Generator for GF180MCU\n\t    \"\"\"\n", "    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\"la\", self.TypeDouble, \"Length\", default=diode_dw2ps_l, unit=\"um\")\n\t        self.param(\"wa\", self.TypeDouble, \"Width\", default=diode_dw2ps_w, unit=\"um\")\n", "        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\t        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"diode_dw2ps(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\t    def coerce_parameters_impl(self):\n", "        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wa * self.la\n\t        self.perim = 2 * (self.wa + self.la)\n\t        # w,l must be larger or equal than min. values.\n\t        self.la = max(self.la, diode_dw2ps_l)\n\t        self.wa = max(self.wa, diode_dw2ps_w)\n\t        self.cw = max(self.cw, diode_dw2ps_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n", "        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.la = self.layout.get_info(self.laayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n", "        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        diode_dw2ps_instance = draw_diode_dw2ps(\n\t            self.layout,\n\t            la=self.la,\n\t            wa=self.wa,\n\t            cw=self.cw,\n\t            volt=self.volt,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n", "            p_lbl=self.p_lbl,\n\t            n_lbl=self.n_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            diode_dw2ps_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n", "        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass sc_diode(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    N+/LVPWELL diode (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n", "        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.param(\"la\", self.TypeDouble, \"Length\", default=sc_l, unit=\"um\")\n\t        self.param(\n\t            \"wa\", self.TypeDouble, \"Width\", default=sc_w, unit=\"um\", readonly=True\n\t        )\n\t        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n\t        self.param(\"m\", self.TypeDouble, \"no. of fingers\", default=4)\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n", "        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\t        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"sc_diode(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wa * self.la\n", "        self.perim = 2 * (self.wa + self.la)\n\t        # w,l must be larger or equal than min. values.\n\t        self.la = max(self.la, sc_l)\n\t        if (self.wa) != sc_w:\n\t            self.wa = sc_w\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.la = self.layout.get_info(self.laayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        sc_instance = draw_sc_diode(\n", "            self.layout,\n\t            la=self.la,\n\t            wa=self.wa,\n\t            cw=self.cw,\n\t            m=self.m,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            p_lbl=self.p_lbl,\n\t            n_lbl=self.n_lbl,\n\t        )\n", "        write_cells = pya.CellInstArray(\n\t            sc_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/cap_mos.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#      http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t########################################################################################################################\n\t# MOS Capacitor Generator for GF180MCU\n\t########################################################################################################################\n\timport pya\n\tfrom .draw_cap_mos import draw_cap_mos\n\tcap_nmos_w = 1.88\n\tcap_nmos_l = 1\n", "cap_pmos_w = 1.88\n\tcap_pmos_l = 1\n\tcap_nmos_b_w = 1.88\n\tcap_nmos_b_l = 1\n\tcap_pmos_b_w = 1.88\n\tcap_pmos_b_l = 1\n\tpoly_spacing = 0.24\n\tclass cap_nmos(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    NMOS capacitor (Outside DNWELL) Generator for GF180MCU\n", "    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n", "        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_nmos_l, unit=\"um\")\n\t        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_nmos_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\t        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"cap_nmos(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n", "    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wc * self.lc\n\t        self.perim = 2 * (self.wc + self.lc)\n\t        # w,l must be larger or equal than min. values.\n\t        self.lc = max(self.lc, cap_nmos_l)\n\t        self.wc = max(self.wc, cap_nmos_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n", "        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.lc = self.layout.get_info(self.lcayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n", "        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        np_instance = draw_cap_mos(\n\t            self.layout,\n\t            type=\"cap_nmos\",\n\t            lc=self.lc,\n\t            wc=self.wc,\n\t            volt=self.volt,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n", "            lbl=self.lbl,\n\t            g_lbl=self.g_lbl,\n\t            sd_lbl=self.sd_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n", "            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass cap_pmos(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3.3V PMOS capacitor (Outside DNWELL) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n", "        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n\t        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_pmos_l, unit=\"um\")\n\t        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_pmos_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n", "        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\t        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"cap_pmos(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n", "        self.area = self.wc * self.lc\n\t        self.perim = 2 * (self.wc + self.lc)\n\t        # w,l must be larger or equal than min. values.\n\t        self.lc = max(self.lc, cap_pmos_l)\n\t        self.wc = max(self.wc, cap_pmos_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.lc = self.layout.get_info(self.lcayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        np_instance = draw_cap_mos(\n", "            self.layout,\n\t            type=\"cap_pmos\",\n\t            lc=self.lc,\n\t            wc=self.wc,\n\t            volt=self.volt,\n\t            deepnwell=self.deepnwell,\n\t            pcmpgr=self.pcmpgr,\n\t            lbl=self.lbl,\n\t            g_lbl=self.g_lbl,\n\t            sd_lbl=self.sd_lbl,\n", "        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n", "        self.cell.flatten(1)\n\tclass cap_nmos_b(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3.3V NMOS capacitor (inside NWell) Generator for GF180MCU\n\t    \"\"\"\n\t    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n", "        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_nmos_b_l, unit=\"um\")\n\t        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_nmos_b_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n\t        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\t        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\t    def display_text_impl(self):\n", "        # Provide a descriptive text for the cell\n\t        return \"cap_nmos_b(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n\t        self.area = self.wc * self.lc\n\t        self.perim = 2 * (self.wc + self.lc)\n\t        # w,l must be larger or equal than min. values.\n\t        self.lc = max(self.lc, cap_nmos_b_l)\n\t        self.wc = max(self.wc, cap_nmos_b_w)\n", "    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.lc = self.layout.get_info(self.lcayer)\n\t    def transformation_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        np_instance = draw_cap_mos(\n\t            self.layout,\n\t            type=\"cap_nmos_b\",\n\t            lc=self.lc,\n\t            wc=self.wc,\n\t            volt=self.volt,\n", "            deepnwell=0,  # self.deepnwell,\n\t            pcmpgr=0,  # self.pcmpgr,\n\t            lbl=self.lbl,\n\t            g_lbl=self.g_lbl,\n\t            sd_lbl=self.sd_lbl,\n\t        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n", "            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n\t        self.cell.flatten(1)\n\tclass cap_pmos_b(pya.PCellDeclarationHelper):\n\t    \"\"\"\n\t    3.3V PMOS capacitor (inside Psub) Generator for GF180MCU\n\t    \"\"\"\n", "    def __init__(self):\n\t        # Initializing super class.\n\t        super().__init__()\n\t        # ===================== PARAMETERS DECLARATIONS =====================\n\t        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n\t        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n\t        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\t        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_pmos_b_l, unit=\"um\")\n\t        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_pmos_b_w, unit=\"um\")\n\t        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n", "        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\t        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\t        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\t        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\t    def display_text_impl(self):\n\t        # Provide a descriptive text for the cell\n\t        return \"cap_pmos_b(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n\t    def coerce_parameters_impl(self):\n\t        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n\t        #  We also update the numerical value or the shape, depending on which on has not changed.\n", "        self.area = self.wc * self.lc\n\t        self.perim = 2 * (self.wc + self.lc)\n\t        # w,l must be larger or equal than min. values.\n\t        self.lc = max(self.lc, cap_pmos_b_l)\n\t        self.wc = max(self.wc, cap_pmos_b_w)\n\t    def can_create_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n\t        # has a finite bounding box\n\t        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\t    def parameters_from_shape_impl(self):\n", "        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n\t        # bounding box width and layer\n\t        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n\t        self.lc = self.layout.get_info(self.lcayer)\n\t    def transformation_from_shape_impl(self):\n\t        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n\t        # bounding box to determine the transformation\n\t        return pya.Trans(self.shape.bbox().center())\n\t    def produce_impl(self):\n\t        np_instance = draw_cap_mos(\n", "            self.layout,\n\t            type=\"cap_pmos_b\",\n\t            lc=self.lc,\n\t            wc=self.wc,\n\t            volt=self.volt,\n\t            deepnwell=0,  # self.deepnwell,\n\t            pcmpgr=0,  # self.pcmpgr,\n\t            lbl=self.lbl,\n\t            g_lbl=self.g_lbl,\n\t            sd_lbl=self.sd_lbl,\n", "        )\n\t        write_cells = pya.CellInstArray(\n\t            np_instance.cell_index(),\n\t            pya.Trans(pya.Point(0, 0)),\n\t            pya.Vector(0, 0),\n\t            pya.Vector(0, 0),\n\t            1,\n\t            1,\n\t        )\n\t        self.cell.insert(write_cells)\n", "        self.cell.flatten(1)\n"]}
