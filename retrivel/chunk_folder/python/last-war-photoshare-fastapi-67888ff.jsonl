{"filename": "main.py", "chunked_list": ["import uvicorn\n\tfrom fastapi import FastAPI, Depends, HTTPException\n\tfrom fastapi.responses import HTMLResponse\n\tfrom sqlalchemy.orm import Session\n\tfrom sqlalchemy import text\n\tfrom src.database.db import get_db\n\tfrom src.routes import users, auth, comments, tags, images, ratings\n\tapp = FastAPI()\n\t@app.get(\"/\", description='Main page')\n\tdef root():\n", "    \"\"\"\n\t    Main page definition\n\t    :return: dict: health status\n\t    \"\"\"\n\t    return {\"message\": \"Welcome to the FAST API from team 6\"}\n\t@app.get(\"/api/healthchecker\")\n\tdef healthchecker(db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    Health Checker\n\t    :param db: database session\n", "    :return: dict: health status\n\t    \"\"\"\n\t    try:\n\t        result = db.execute(text(\"SELECT 1\")).fetchone()\n\t        if result is None:\n\t            raise HTTPException(status_code=500, detail=\"Database is not configured correctly\")\n\t        return {\"message\": \"Welcome to FastAPI!\"}\n\t    except Exception:\n\t        raise HTTPException(status_code=500, detail=\"Error connecting to the database\")\n\tapp.include_router(users.router, prefix='/api')\n", "app.include_router(auth.router, prefix='/api')\n\tapp.include_router(comments.router, prefix='/api')\n\tapp.include_router(images.router, prefix='/api')\n\tapp.include_router(tags.router, prefix='/api')\n\tapp.include_router(ratings.router, prefix='/api')\n"]}
{"filename": "tests/test_unit_repository_ratings.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import MagicMock\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Rating, User, Image\n\tfrom src.repository.ratings import (\n\t    create_rate,\n\t    delete_rate,\n\t    calculate_rating,\n\t    show_images_by_rating\n\t)\n", "class TestRatings(unittest.IsolatedAsyncioTestCase):\n\t    def setUp(self):\n\t        self.session = MagicMock(spec=Session)\n\t        self.test_user = User(\n\t            id=1,\n\t            login='SuperUser',\n\t            email='user@super.com',\n\t            password_checksum='superpwd',\n\t            is_active=True,\n\t        )\n", "    def tearDown(self):\n\t        self.session = None\n\t        self.test_user = None\n\t    # test create_rate function from src/repository/ratings.py with different inputs\n\t    async def test_create_rate_own_image(self):\n\t        # test if it is not possible to rate own image\n\t        self.session.query().filter().order_by().first.return_value = Image(\n\t            id=1,\n\t            image_url='test_image',\n\t            description='test_path',\n", "            user_id=1,\n\t        )\n\t        with self.assertRaises(Exception):\n\t            await create_rate(image_id=1, rate=5, db=self.session, user=self.test_user)\n\t    async def test_create_rate_twice(self):\n\t        # test if it is not possible to rate twice\n\t        self.session.query().filter().order_by().first.return_value = Rating(\n\t            id=1,\n\t            image_id=1,\n\t            rate=5,\n", "            user_id=1,\n\t        )\n\t        with self.assertRaises(Exception):\n\t            await create_rate(image_id=1, rate=5, db=self.session, user=self.test_user)\n\t    async def test_create_rate_image_not_exists(self):\n\t        # test if it is not possible to rate an image that does not exist\n\t        self.session.query().filter().order_by().first.return_value = None\n\t        with self.assertRaises(Exception):\n\t            await create_rate(image_id=1, rate=5, db=self.session, user=self.test_user)\n\t    async def test_create_rate(self):\n", "        # test if it is possible to rate an image\n\t        self.session.query().filter().order_by().first.return_value = None\n\t        self.session.query().filter().order_by().first.return_value = Image(\n\t            id=2,\n\t            image_url='test_image',\n\t            description='test_path',\n\t            user_id=2,\n\t        )\n\t        result = await create_rate(image_id=2, rate=5, db=self.session, user=self.test_user)\n\t        self.assertIsInstance(result, Rating)\n", "    async def test_delete_rate(self):\n\t        # test if it is possible to delete a rate\n\t        self.session.query().filter().order_by().first.return_value = Rating(\n\t            id=1,\n\t            image_id=1,\n\t            rate=5,\n\t            user_id=1,\n\t        )\n\t        result = await delete_rate(rate_id=1, db=self.session, user=self.test_user)\n\t        self.assertIsNone(result)\n", "    async def test_calculate_rating(self):\n\t        # test if it is possible to calculate rate\n\t        self.session.query().filter().order_by().first.return_value = Rating(\n\t            id=1,\n\t            image_id=1,\n\t            rate=5,\n\t            user_id=1,\n\t        )\n\t        result = await calculate_rating(image_id=1, db=self.session, user=self.test_user)\n\t        self.assertEqual(result, 5)\n", "    async def test_show_images_by_rating(self):\n\t        # test if it is possible to show images by rating\n\t        self.session.query().filter().order_by().first.return_value = Rating(\n\t            id=1,\n\t            image_id=1,\n\t            rate=5,\n\t            user_id=1,\n\t        )\n\t        result = await show_images_by_rating(True, db=self.session, user=self.test_user)\n\t        self.assertIsInstance(result, list)\n", "if __name__ == '__main__':\n\t    unittest.main()"]}
{"filename": "tests/test_unit_route_images.py", "chunked_list": ["from unittest.mock import MagicMock\n\timport io\n\timport qrcode\n\tfrom PIL import Image as PILImage\n\tfrom pytest import fixture\n\tfrom src.database.models import User, UserRole, Image\n\tfrom fastapi import status, UploadFile\n\timport datetime\n\t@fixture(scope='module')\n\tdef token(client, user, session):\n", "    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.role = UserRole.Admin\n\t    session.commit()\n\t    response = client.post(\"/api/auth/login\", data={\n\t                            \"username\": \"deadpool@example.com\",\n\t                            \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n\t    return data[\"access_token\"]\n", "@fixture(scope='module')\n\tdef token_moder(client, user_moder, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead2pool\", \"email\": \"dead2pool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user_moder.get('email')).first()\n\t    current_user.role = UserRole.Moderator\n\t    session.commit()\n\t    response = client.post(\"/api/auth/login\", data={\n\t                            \"username\": \"dead2pool@example.com\",\n\t                            \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n", "    data = response.json()\n\t    return data[\"access_token\"]\n\t@fixture(scope='module')\n\tdef token_user(client, user_user, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead1pool\", \"email\": \"dead1pool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    response = client.post(\"/api/auth/login\", data={\n\t                            \"username\": \"dead1pool@example.com\",\n\t                            \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n", "    return data[\"access_token\"]\n\t@fixture(scope='module')\n\tdef image(client, user, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    image = session.query(Image).filter(Image.id == 1).first()\n\t    if image is None:\n\t        image = Image(\n\t                    id=1,\n", "                    image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n\t                                \"/v1/photoshare/473db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n\t                    user_id=current_user.id,\n\t                    created_at=datetime.datetime.now(),\n\t                    description=\"est_image_test_image_test_image_test_image\"\n\t        )\n\t        session.add(image)\n\t        session.commit()\n\t        session.refresh(image)\n\t    return image\n", "@fixture(scope='module')\n\tdef image_moder(client, user_moder, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead2pool\", \"email\": \"dead2pool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user_moder.get('email')).first()\n\t    image = session.query(Image).filter(Image.id == 2).first()\n\t    if image is None:\n\t        image = Image(\n\t                    id=2,\n\t                    image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n", "                                \"/v1/photoshare/223db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n\t                    user_id=current_user.id,\n\t                    created_at=datetime.datetime.now(),\n\t                    description=\"est_image_test_image_test_image_test_image\"\n\t        )\n\t        session.add(image)\n\t        session.commit()\n\t        session.refresh(image)\n\t    return image\n\t@fixture(scope='module')\n", "def image_user(client, user_user, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead1pool\", \"email\": \"dead1pool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user_user.get('email')).first()\n\t    image = session.query(Image).filter(Image.id == 3).first()\n\t    if image is None:\n\t        image = Image(\n\t                    id=3,\n\t                    image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n\t                                \"/v1/photoshare/333db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n", "                    user_id=current_user.id,\n\t                    created_at=datetime.datetime.now(),\n\t                    description=\"est_image_test_image_test_image_test_image\"\n\t        )\n\t        session.add(image)\n\t        session.commit()\n\t        session.refresh(image)\n\t    return image\n\tdef test_create_transformation_image_by_admin(client, token, image):\n\t    response = client.post(\"/api/images/transformation\", json={\"id\": 1, \"transformation\": \"standard\"},\n", "                           headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_201_CREATED\n\t    response = client.post(\"/api/images/transformation\", json={\"id\": 1, \"transformation\": \"standard\"},\n\t                           headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_409_CONFLICT\n\t    response = client.post(\"/api/images/transformation\", json={\"id\": 100, \"transformation\": \"standard\"},\n\t                           headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.post(\"/api/images/transformation\", json={\"id\": 100, \"transformation\": \"test\"},\n\t                           headers={\"Authorization\": f\"Bearer {token}\"})\n", "    assert response.status_code == status.HTTP_404_NOT_FOUND\n\tdef test_create_transformation_image_by_moder(client, token_moder, image_moder):\n\t    response = client.post(\"/api/images/transformation\", json={\"id\": 2, \"transformation\": \"standard\"},\n\t                           headers={\"Authorization\": f\"Bearer {token_moder}\"})\n\t    assert response.status_code == status.HTTP_201_CREATED\n\tdef test_create_transformation_image_by_user(client, token_user, image_user):\n\t    response = client.post(\"/api/images/transformation\", json={\"id\": 3, \"transformation\": \"standard\"},\n\t                           headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_201_CREATED\n\t    response = client.post(\"/api/images/transformation\", json={\"id\": 100, \"transformation\": \"standard\"},\n", "                           headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\tdef test_get_images_by_admin(client, token):\n\t    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\tdef test_get_images_by_moder(client, token_moder):\n\t    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n", "def test_get_images_by_user(client, token_user):\n\t    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\tdef test_get_image_by_admin(client, token, image):\n\t    response = client.get(\"/api/images/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.get(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.get(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n", "def test_get_image_moder(client, token_moder, image_moder):\n\t    response = client.get(\"/api/images/2\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\tdef test_get_image_by_user(client, token_user, image_user):\n\t    response = client.get(\"/api/images/3\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.get(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.get(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n", "def test_update_description_image_by_admin(client, token, image):\n\t    response = client.patch(\"/api/images/description/1\", json={\n\t                            \"description\": \"description_description_description\",\n\t                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK, response.text\n\t    data = response.json()\n\t    assert data[\"description\"] == \"description_description_description\"\n\t    response = client.patch(\"/api/images/description/100\", json={\n\t                            \"description\": \"description_description_description\",\n\t                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token}\"})\n", "    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.patch(\"/api/images/description/{image_id}\", json={\"descri\": \"n\"},\n\t                            headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\tdef test_update_description_image_by_user(client, token_user, image_user):\n\t    response = client.patch(\"/api/images/description/3\", json={\n\t                            \"description\": \"description_description_description\",\n\t                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_200_OK, response.text\n\t    data = response.json()\n", "    assert data[\"description\"] == \"description_description_description\"\n\t    response = client.patch(\"/api/images/description/100\", json={\n\t                            \"description\": \"description_description_description\",\n\t                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.patch(\"/api/images/description/{image_id}\", json={\"descri\": \"n\"},\n\t                            headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\tdef test_remove_image_by_admin(client, token, image):\n\t    response = client.delete(\"/api/images/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n", "    assert response.status_code == status.HTTP_204_NO_CONTENT\n\t    response = client.delete(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.delete(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\tdef test_remove_image_by_moder(client, token_moder, image_moder):\n\t    response = client.delete(\"/api/images/2\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n\t    assert response.status_code == status.HTTP_403_FORBIDDEN\n\t    response = client.delete(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n\t    assert response.status_code == status.HTTP_403_FORBIDDEN\n", "    response = client.delete(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n\t    assert response.status_code == status.HTTP_403_FORBIDDEN\n\tdef test_remove_image_by_user(client, token_user, image_user):\n\t    response = client.delete(\"/api/images/3\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_403_FORBIDDEN\n\t    response = client.delete(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_403_FORBIDDEN\n\t    response = client.delete(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n\t    assert response.status_code == status.HTTP_403_FORBIDDEN\n\tdef test_create_image(client, token):\n", "    image_file = io.BytesIO()\n\t    image = PILImage.new('RGB', size=(100, 100), color=(255, 0, 0))\n\t    image.save(image_file, 'jpeg')\n\t    image_file.seek(0)\n\t    response = client.post(\n\t        \"/api/images\",\n\t        data={\"description\": \"test_image_test_image_test_image_test_image\",\n\t              \"tags_text\": \"#python\",\n\t              },\n\t        files={\"image_file\": (\"test.jpg\", image_file, \"image/jpeg\")}\n", "        ,\n\t        headers={\"Authorization\": f\"Bearer {token}\"},\n\t    )\n\t    assert response.status_code == status.HTTP_201_CREATED, response.text\n\t    data = response.json()\n\t    assert data[\"description\"] == \"test_image_test_image_test_image_test_image\"\n\t    assert \"id\" in data\n\t    image_file = io.BytesIO()\n\t    image = PILImage.new('RGB', size=(100, 100), color=(255, 110, 0))\n\t    image.save(image_file, 'jpeg')\n", "    image_file.seek(0)\n\t    response = client.post(\n\t        \"/api/images\",\n\t        data={\"description\": \"sma\",\n\t              \"tags_text\": \"#python\",\n\t              },\n\t        files={\"image_file\": (\"test.jpg\", image_file, \"image/jpeg\")}\n\t        ,\n\t        headers={\"Authorization\": f\"Bearer {token}\"},\n\t    )\n", "    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\tdef test_generate_qrcode(client, token):\n\t    response = client.post(\"/generate_qrcode/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    qr = qrcode.QRCode(\n\t                        version=1,\n\t                        error_correction=qrcode.constants.ERROR_CORRECT_L,\n\t                        box_size=3,\n\t                        border=4,\n\t                        )\n", "    qr.add_data(\"test\")\n\t    qr.make(fit=True)\n\t    img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n\t    output = io.BytesIO()\n\t    img.save(output)\n\t    output.seek(0)\n\t    response = client.post(\"/generate_qrcode/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_201_CREATED\n"]}
{"filename": "tests/test_unit_route_comments.py", "chunked_list": ["from pytest import fixture\n\tfrom src.database.models import User, UserRole\n\tfrom fastapi import status\n\t@fixture(scope='function')\n\tdef token(client, user, session):\n\t    response = client.post(\"/api/auth/signup\",\n\t                           json={\"login\": \"deadpool\",\n\t                                                     \"email\": \"deadpool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n", "    current_user.role = UserRole.Admin\n\t    session.commit()\n\t    response = client.post(\"/api/auth/login\",\n\t                           data={\"username\": \"deadpool@example.com\",\n\t                                 \"password\": \"123456789\"},\n\t                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n\t    return data[\"access_token\"]\n\tdef test_post_comment(client, token):\n\t    response = client.post(\"/api/comments/1\", json={\"comment_text\": \"Test text for new comment\"}, \n", "                           headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == 200, response.text\n\t    body_data = response.json()\n\t    assert body_data == {\n\t        \"id\": 1,\n\t        \"user_id\": 1,\n\t        \"image_id\": 1,\n\t        \"comment_text\": \"Test text for new comment\",\n\t        \"created_at\": f\"{body_data['created_at']}\",\n\t        \"updated_at\": None,\n", "    }\n\tdef test_show_user_comments(client, token):\n\t    response = client.get(\"/api/comments/user/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == 200, response.text\n\t    data = response.json()\n\t    assert data[0][\"id\"] == 1\n\tdef test_show_comments(client, token):\n\t    response = client.get(\"api/comments/image/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == 200, response.text\n\t    data = response.json()\n", "    assert data[0][\"id\"] == 1\n\tdef test_update_comment(client, token):\n\t    response = client.put(\n\t        \"api/comments/1\", json={\"comment_text\": \"NEW Test text for comment\"},\n\t        headers={\"Authorization\": f\"Bearer {token}\"}\n\t    )\n\t    assert response.status_code == 200, response.text\n\t    body_data = response.json()\n\t    assert body_data == {\n\t        \"id\": 1,\n", "        \"user_id\": 1,\n\t        \"image_id\": 1,\n\t        \"comment_text\": \"NEW Test text for comment\",\n\t        \"created_at\": f\"{body_data['created_at']}\",\n\t        \"updated_at\": f\"{body_data['updated_at']}\",\n\t    }\n\tdef test_remove_comment(client, token):\n\t    response = client.delete(\"/api/comments/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.delete(\"/api/comments/{image_id}\", headers={\"Authorization\": f\"Bearer {token}\"})\n", "    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n"]}
{"filename": "tests/test_unit_route_tags.py", "chunked_list": ["import datetime\n\tfrom pytest import fixture\n\tfrom src.database.models import Tag, User, UserRole, Image\n\tfrom fastapi import status\n\t@fixture(scope='module')\n\tdef token(client, user, session):\n\t    \"\"\"\n\t    The token function is used to create a user with admin privileges, and then log in as that user.\n\t    This allows us to test the endpoints that require an admin token.\n\t    Args:\n", "        client: Make requests to the api\n\t        user: Create a user in the database\n\t        session: Make queries to the database\n\t    Returns:\n\t        A valid access token\n\t    \"\"\"\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.role = UserRole.Admin\n", "    session.commit()\n\t    response = client.post(\"/api/auth/login\", data={\n\t        \"username\": \"deadpool@example.com\",\n\t        \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n\t    return data[\"access_token\"]\n\tdef test_create_tags(client, session, token):\n\t    \"\"\"\n\t    The test_create_tags function tests the POST /api/tag/{tags} endpoint.\n\t    It does this by creating a new tag with the name &quot;test&quot; and then checking that it was created correctly.\n", "    Args:\n\t        client: Make requests to the api\n\t        session: Query the database for tags\n\t        token: Authenticate the user\n\t    Returns:\n\t        A 201 status code and a list of dictionaries containing the tag name\n\t    \"\"\"\n\t    tags_string = \"test\"\n\t    response = client.post(\"/api/tag/%23test\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_201_CREATED, response.text\n", "    expected_response = [{\"id\": 1, \"tag_name\": tags_string}]\n\t    assert response.json() == expected_response\n\t    tag = session.query(Tag).first()\n\t    assert tag is not None\n\t    assert tag.tag_name == tags_string\n\tdef test_create_tags_not_authorization(client, session):\n\t    \"\"\"\n\t    The test_create_tags_not_authorization function tests that a user cannot create a tag without authorization.\n\t    Args:\n\t        client: Make requests to the api\n", "        session: Create a new database session for the test\n\t    Returns:\n\t        A 401 unauthorized status code\n\t    \"\"\"\n\t    token = \"not_valid\"\n\t    response = client.post(\"/api/tag/%23test\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED, response.text\n\tdef test_create_tags_not_valid_tags(client, session, token):\n\t    \"\"\"\n\t    The test_create_tags_not_valid_tags function tests the POST /api/tag/ endpoint.\n", "    It does this by sending a request to the endpoint with no data, and then checking that it returns a 404 status code.\n\t    Args:\n\t        client: Make requests to the api\n\t        session: Rollback the database after each test\n\t        token: Authenticate the user\n\t    Returns:\n\t        404\n\t    \"\"\"\n\t    response = client.post(\"/api/tag/\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text\n", "def test_get_images_by_tag(client, session, token):\n\t    \"\"\"\n\t    The test_get_images_by_tag function tests the get_images_by_tag function in the tag.py file.\n\t    The test is successful if it returns a 200 status code and a list of images with tags that match the tag name.\n\t    Args:\n\t        client: Make requests to the api\n\t        session: Create a new database session for the test\n\t        token: Authenticate the user\n\t    Returns:\n\t        The images that have the tag\n", "    \"\"\"\n\t    tag_name = \"test\"\n\t    limit = 10\n\t    offset = 0\n\t    tag = session.query(Tag).filter(Tag.id == 1).first()\n\t    image = session.query(Image).filter(Image.id == 1).first()\n\t    date = datetime.datetime.now()\n\t    if image is None:\n\t        image = Image(\n\t            id=1,\n", "            image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n\t                      \"/v1/photoshare/333db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n\t            user_id=1,\n\t            created_at=date,\n\t            description=\"est_image_test_image_test_image_test_image\",\n\t            tags=[tag]\n\t        )\n\t        session.add(image)\n\t        session.commit()\n\t        session.refresh(image)\n", "    response = client.get(\"/api/tag/image/test\", headers={\"Authorization\": f\"Bearer {token}\"},\n\t                          params={\"limit\": limit, \"offset\": offset})\n\t    assert response.status_code == status.HTTP_200_OK, response.text\n\t    expected_response = [\n\t        {\n\t            \"id\": 1,\n\t            \"image_url\": \"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n\t                         \"/v1/photoshare/333db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n\t            \"user_id\": 1,\n\t            \"created_at\": date,\n", "            \"updated_at\": date,\n\t            \"description\": \"est_image_test_image_test_image_test_image\",\n\t            \"tags\": [\n\t                {\n\t                    \"id\": 1,\n\t                    \"tag_name\": \"test\"\n\t                }\n\t            ]\n\t        }\n\t    ]\n", "    assert response.json()[0][\"id\"] == expected_response[0][\"id\"]\n\t    assert response.json()[0][\"image_url\"] == expected_response[0][\"image_url\"]\n\t    assert response.json()[0][\"user_id\"] == expected_response[0][\"user_id\"]\n\t    assert response.json()[0][\"description\"] == expected_response[0][\"description\"]\n\t    assert response.json()[0][\"tags\"][0][\"id\"] == expected_response[0][\"tags\"][0][\"id\"]\n\t    assert response.json()[0][\"tags\"][0][\"tag_name\"] == expected_response[0][\"tags\"][0][\"tag_name\"]\n\tdef test_get_images_by_tag_not_found_images(client, session, token):\n\t    \"\"\"\n\t    The test_get_images_by_tag_not_found_images function tests the get_images_by_tag function in the image.py file\n\t    to ensure that it returns an empty list when no images are found with a given tag.\n", "    Args:\n\t        client: Make requests to the api\n\t        session: Pass the database session to the test function\n\t        token: Test the get_images_by_tag function with a valid token\n\t    Returns:\n\t        An empty list\n\t    \"\"\"\n\t    limit = 10\n\t    offset = 0\n\t    response = client.get(\"/api/tag/image/testnotfound\", headers={\"Authorization\": f\"Bearer {token}\"},\n", "                          params={\"limit\": limit, \"offset\": offset})\n\t    assert response.json() == []\n\tdef test_get_one_tag_found(client, session, token):\n\t    \"\"\"\n\t    The test_get_one_tag_found function tests the GET /api/tag/{tag_name} endpoint.\n\t    It ensures that a tag can be retrieved by its name.\n\t    Args:\n\t        client: Make requests to the api\n\t        session: Create a new session for the test\n\t        token: Authenticate the user\n", "    Returns:\n\t        A 200 response with the tag data\n\t    \"\"\"\n\t    tag = {\n\t        \"id\": 1,\n\t        \"tag_name\": \"test\"\n\t    }\n\t    response = client.get(\"/api/tag/test\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK, response.text\n\t    assert response.json() == tag\n", "def test_get_one_tag_not_found(client, session, token):\n\t    \"\"\"\n\t    The test_get_one_tag_not_found function tests the GET /api/tag/{id} endpoint.\n\t        It ensures that a 404 status code is returned when an invalid tag id is passed in.\n\t    Args:\n\t        client: Send requests to the api\n\t        session: Create a new session for the test\n\t        token: Authenticate the user\n\t    Returns:\n\t        A 404 status code\n", "    \"\"\"\n\t    tag = None\n\t    response = client.get(\"/api/tag/testnotfound\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text\n\tdef test_update_tag_found(client, session, token):\n\t    \"\"\"\n\t    The test_update_tag_found function tests the update_tag function in the tag.py file.\n\t    It does this by first creating a new tag name, then it uses that to create a response from the client using PUT method\n\t    to update an existing tag with id 1 and header of token authorization. It then asserts that status code is 200 OK, which means\n\t    the request was successful and returns what we expected (in this case, it should return updated information for id 1).\n", "    Finally, it creates an expected response variable to compare against our actual response.\n\t    Args:\n\t        client: Make requests to the api\n\t        session: Create a new session for the test\n\t        token: Authenticate the user\n\t    Returns:\n\t        A 200 status code and the updated tag\n\t    \"\"\"\n\t    new_tag_name = \"test_1\"\n\t    response = client.put(\"/api/tag/1\", headers={\"Authorization\": f\"Bearer {token}\"}, json={\"tag_name\": new_tag_name})\n", "    assert response.status_code == status.HTTP_200_OK, response.text\n\t    expected_response = {\"id\": 1, \"tag_name\": new_tag_name}\n\t    assert response.json() == expected_response\n\tdef test_update_tag_not_found(client, session, token):\n\t    \"\"\"\n\t    The test_update_tag_not_found function tests the update tag endpoint.\n\t        It does this by first creating a new tag, then attempting to update it with an invalid id.\n\t        The expected result is that the response status code should be 404 NOT FOUND.\n\t    Args:\n\t        client: Make requests to the api\n", "        session: Create a new session for the test\n\t        token: Authenticate the user\n\t    Returns:\n\t        A 404 status code\n\t    \"\"\"\n\t    new_tag_name = \"test_1\"\n\t    response = client.put(\"/api/tag/999\", headers={\"Authorization\": f\"Bearer {token}\"}, json={\"tag_name\": new_tag_name})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text\n\tdef test_delete_tag_found(client, session, token):\n\t    \"\"\"\n", "    The test_delete_tag_found function tests the DELETE /api/tag/{tag_name} endpoint.\n\t    It does so by first creating a tag with the name &quot;test&quot; and then deleting it.\n\t    The test passes if the response status code is 204 No Content and if there are no tags in the database with that name.\n\t    Args:\n\t        client: Send a request to the server\n\t        session: Access the database\n\t        token: Pass in the token to the function\n\t    Returns:\n\t        A 204 status code\n\t    \"\"\"\n", "    response = client.delete(\"/api/tag/test_1\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_204_NO_CONTENT, response.text\n\t    tag = session.query(Tag).filter(Tag.tag_name == \"test\").first()\n\t    assert tag is None\n\tdef test_delete_tag_not_found(client, session, token):\n\t    \"\"\"\n\t    The test_delete_tag_not_found function tests the DELETE /api/tag/{name} endpoint.\n\t    It does so by first creating a tag, then deleting it, and finally attempting to delete it again.\n\t    The final attempt should fail with a 404 Not Found error.\n\t    Args:\n", "        client: Make requests to the api\n\t        session: Create a database session\n\t        token: Authenticate the user\n\t    Returns:\n\t        A 404 status code\n\t    \"\"\"\n\t    response = client.delete(\"/api/tag/test\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text\n"]}
{"filename": "tests/test_unit_repository_images.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import MagicMock\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import User, Image\n\tfrom src.schemas.images import ImageModel\n\tfrom src.repository.images import (\n\t    get_images,\n\t    get_image,\n\t    create,\n\t    get_image_from_id,\n", "    get_image_from_url,\n\t    remove,\n\t    change_description,\n\t)\n\tclass TestContacts(unittest.IsolatedAsyncioTestCase):\n\t    def setUp(self):\n\t        self.session = MagicMock(spec=Session)\n\t        self.user = User(id=1)\n\t    async def test_get_images_found(self):\n\t        expect_res = [Image(), ]\n", "        self.session.query().filter().order_by().limit().offset().all.return_value = expect_res\n\t        result = await get_images(limit=10, offset=0, user=self.user, db=self.session)\n\t        self.assertEqual(result, expect_res)\n\t        self.assertListEqual(result, expect_res)\n\t    async def test_get_image_found(self):\n\t        expect_res = Image()\n\t        self.session.query().filter().order_by().first.return_value = expect_res\n\t        result = await get_image(image_id=1, user=self.user, db=self.session)\n\t        self.assertEqual(result, expect_res)\n\t    async def test_get_image_not_found(self):\n", "        self.session.query().filter().order_by().first.return_value = None\n\t        result = await get_image(image_id=100, user=self.user, db=self.session)\n\t        self.assertIsNone(result)\n\t    async def test_create_found(self):\n\t        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n\t        result = await create(body=body, image_url=\"image_url\", user=self.user, db=self.session)\n\t        self.assertEqual(result.description, body.description)\n\t        self.assertListEqual(result.tags, [])\n\t        self.assertTrue(hasattr(result, \"id\"))\n\t    async def test_get_image_from_id_found(self):\n", "        expect_res = Image()\n\t        self.session.query().filter().first.return_value = expect_res\n\t        result = await get_image_from_id(image_id=1, user=self.user, db=self.session)\n\t        self.assertEqual(result, expect_res)\n\t    async def test_get_image_from_id_not_found(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await get_image_from_id(image_id=100, user=self.user, db=self.session)\n\t        self.assertIsNone(result)\n\t    async def test_get_image_from_url_found(self):\n\t        expect_res = Image()\n", "        self.session.query().filter().first.return_value = expect_res\n\t        result = await get_image_from_url(image_url=\"photo/349856\", user=self.user, db=self.session)\n\t        self.assertEqual(result, expect_res)\n\t    async def test_get_image_from_url_not_found(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await get_image_from_url(image_url=\"\", user=self.user, db=self.session)\n\t        self.assertIsNone(result)\n\t    async def test_remove_found(self):\n\t        expect_res = Image()\n\t        self.session.query().filter().first.return_value = expect_res\n", "        result = await remove(image_id=1, user=self.user, db=self.session)\n\t        self.assertEqual(result, expect_res)\n\t    async def test_remove_not_found(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await remove(image_id=100, user=self.user, db=self.session)\n\t        self.assertIsNone(result)\n\t    async def test_change_description_found(self):\n\t        expect_res = Image()\n\t        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n\t        self.session.query().filter().first.return_value = expect_res\n", "        self.session.commit.return_value = None\n\t        result = await change_description(body=body, image_id=1, user=self.user, db=self.session)\n\t        self.assertEqual(result, expect_res)\n\t        self.assertListEqual(result.tags, [])\n\t    async def test_change_description_not_found(self):\n\t        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n\t        self.session.query().filter().first.return_value = None\n\t        self.session.commit.return_value = None\n\t        result = await change_description(body=body, image_id=1, user=self.user, db=self.session)\n\t        self.assertIsNone(result)\n", "if __name__ == '__main__':\n\t    unittest.main()"]}
{"filename": "tests/test_unit_route_ratings.py", "chunked_list": ["from pytest import fixture\n\tfrom src.database.models import User, UserRole, Image, Rating\n\tfrom fastapi import status\n\timport datetime\n\t@fixture(scope='module')\n\tdef token(client, user, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.role = UserRole.Admin\n", "    session.commit()\n\t    response = client.post(\"/api/auth/login\", data={\n\t        \"username\": \"deadpool@example.com\",\n\t        \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n\t    return data[\"access_token\"]\n\t@fixture(scope='module')\n\tdef image(client, user, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n", "    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    image = session.query(Image).filter(Image.id == 1).first()\n\t    if image is None:\n\t        image = Image(\n\t            id=1,\n\t            image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n\t                      \"/v1/photoshare/473db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n\t            user_id=5,\n\t            created_at=datetime.datetime.now(),\n\t            description=\"est_image_test_image_test_image_test_image\",\n", "        )\n\t        session.add(image)\n\t        session.commit()\n\t        session.refresh(image)\n\t    return image\n\t@fixture(scope='module')\n\tdef rating(client, user, session):\n\t    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n\t                                                     \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n", "    rating = session.query(Image).filter(Rating.id == 1).first()\n\t    if rating is None:\n\t        rating = Rating(\n\t            id=1,\n\t            rate=5,\n\t            user_id=current_user.id,\n\t            image_id=1,\n\t        )\n\t        session.add(rating)\n\t        session.commit()\n", "        session.refresh(rating)\n\t    return rating\n\tdef test_show_images_by_rating(client, token, image, session):\n\t    response = client.get(\"/api/rating/show_images_by_rating?to_decrease=true\",\n\t                          headers={'Authorization': f'Bearer {token}'}\n\t                          )\n\t    assert response.status_code == status.HTTP_200_OK\n\tdef test_create_rate(client, token, image, session):\n\t    response = client.post(\"/api/rating/1/5\",\n\t                           headers={'Authorization': f'Bearer {token}'}\n", "                           )\n\t    assert response.status_code == status.HTTP_200_OK\n\tdef test_delete_rate(client, token, session, rating):\n\t    response = client.delete(\"/api/rating/delete/1\",\n\t                             headers={'Authorization': f'Bearer {token}'}\n\t                             )\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\tdef test_show_image_rating(client, token, image, session):\n\t    response = client.get(\"/api/rating/show_image_rating/1\",\n\t                          headers={'Authorization': f'Bearer {token}'}\n", "                          )\n\t    assert response.status_code == status.HTTP_200_OK\n"]}
{"filename": "tests/test_route_main.py", "chunked_list": ["from fastapi import status\n\tdef test_root(client):\n\t    response = client.get(\"/\")\n\t    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n\t    assert data[\"message\"] == \"Welcome to the FAST API from team 6\"\n\tdef test_healthchecker(client):\n\t    response = client.get(\"/api/healthchecker\")\n\t    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n", "    assert data[\"message\"] == \"Welcome to FastAPI!\"\n"]}
{"filename": "tests/test_unit_repository_tags.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import MagicMock, patch\n\tfrom sqlalchemy.orm import Session\n\tfrom src.schemas.tags import TagModel\n\tfrom src.database.models import Tag, tag_to_image, Image\n\tfrom src.repository.tags import (\n\t    parse_tags,\n\t    create_tags,\n\t    edit_tag,\n\t    find_tag,\n", "    delete_tag,\n\t    get_images_by_tag\n\t)\n\t\"\"\"\n\tUnit test repository tags.\n\t\"\"\"\n\tclass TestTags(unittest.IsolatedAsyncioTestCase):\n\t    \"\"\"\n\t    Unit Test Tags repository.\n\t    \"\"\"\n", "    def setUp(self):\n\t        \"\"\"\n\t        The setUp function is run before each test.\n\t        It creates a mock session object, and a tag object with an id of 1, and the name &quot;test_tags&quot;.\n\t        It also creates an image object with an id of 1, url &quot;url image&quot;, user_id of 1, and description\n\t        &quot;test string description________________________________&quot;. The incoming data is set to &quot;#test_tags&quot;.\n\t        Args:\n\t            self: Represent the instance of the class\n\t        Returns:\n\t            A list of objects that will be used in the tests\n", "        \"\"\"\n\t        self.session = MagicMock(spec=Session)\n\t        self.tag = Tag(id=1, tag_name=\"test_tags\")\n\t        self.incoming_data = \"#test_tags\"\n\t        self.image = Image(\n\t            id=1,\n\t            image_url=\"url image\",\n\t            user_id=1,\n\t            description=\"test string description________________________________\",\n\t        )\n", "    def test_parse_tags_found(self):\n\t        \"\"\"\n\t        The test_parse_tags_found function tests the parse_tags function.\n\t        It checks to see if the tags are found in the incoming data and returns a list of those tags.\n\t        Args:\n\t            self: Represent the instance of the object that is passed to the method when it is called\n\t        Returns:\n\t            A list of tags\n\t        \"\"\"\n\t        expect_result = [\"test_tags\"]\n", "        tags = parse_tags(self.incoming_data)\n\t        self.assertEqual(tags, expect_result)\n\t        self.assertListEqual(tags, expect_result)\n\t    def test_parse_tags_not_found(self):\n\t        \"\"\"\n\t        The test_parse_tags_not_found function tests the parse_tags function when there are no tags in the incoming data.\n\t        The expected result is an empty list, and that is what we get.\n\t        Args:\n\t            self: Represent the instance of the class\n\t        Returns:\n", "            An empty list\n\t        \"\"\"\n\t        expect_result = list()\n\t        incoming_data = \"\"\n\t        tags = parse_tags(incoming_data)\n\t        self.assertEqual(tags, expect_result)\n\t        self.assertListEqual(tags, expect_result)\n\t    async def test_create_new_tags_existing_tag(self):\n\t        \"\"\"\n\t        The test_create_new_tags_existing_tag function tests the create_tags function when a tag already exists in the database.\n", "        The test creates an incoming data list with one tag, and then sets up a mock session object that returns that same tag when queried.\n\t        The test then calls the create_tags function with this incoming data and mock session object, and asserts that it returns a list containing only one element:\n\t        the original inputted Tag object.\n\t        Args:\n\t            self: Represent the instance of the object that is passed to the method when it is called\n\t        Returns:\n\t            The tag\n\t        \"\"\"\n\t        expect_result = [self.tag]\n\t        self.session.query().filter().first.return_value = self.tag\n", "        result = await create_tags(self.incoming_data, db=self.session)\n\t        self.assertEqual(result, expect_result)\n\t        self.assertEqual(result[0], expect_result[0])\n\t    async def test_create_new_tags_new_tag(self):\n\t        \"\"\"\n\t        The test_create_new_tags_new_tag function tests the create_tags function when a new tag is created.\n\t        The test_create_new_tags_new_tag function uses patch to mock the Tag class and return a MagicMock object.\n\t        The test then calls the create tags function with incoming data that does not exist in the database,\n\t        and asserts that it returns an array containing one element, which is equal to self.tag.\n\t        Args:\n", "            self: Access the class attributes and methods\n\t        Returns:\n\t            The tag that it created\n\t        \"\"\"\n\t        expect_result = [self.tag]\n\t        self.session.query().filter().first.return_value = None\n\t        self.session.add.return_value = MagicMock(return_value=self.tag)\n\t        with patch('src.repository.tags.Tag', return_value=self.tag):\n\t            result = await create_tags(self.incoming_data, db=self.session)\n\t        self.assertEqual(result, expect_result)\n", "        self.assertEqual(result[0], expect_result[0])\n\t    async def test_edit_tag_found(self):\n\t        \"\"\"\n\t        The test_edit_tag_found function tests the edit_tag function.\n\t            The test_edit_tag_found function is a coroutine that takes in self as an argument.\n\t            The expect result variable is set to the tag variable, which was created earlier in this class.\n\t            The edit tag name variable is set to &quot;edit name tag&quot;.  This will be used later on when we are editing our tags.\n\t                We want to make sure that our tags can be edited properly and accurately, so we need a way of testing this out!\n\t                That's what this test does for us!  It makes sure that our tags\n\t        Args:\n", "            self: Represent the instance of the class\n\t        Returns:\n\t            A result\n\t        \"\"\"\n\t        expect_result = self.tag\n\t        edit_tag_name = \"edit_name_tag\"\n\t        tag_model = TagModel(tag_name=edit_tag_name)\n\t        result = await edit_tag(expect_result, tag_model, db=self.session)\n\t        self.assertEqual(result.tag_name, edit_tag_name)\n\t        self.assertEqual(result.tag_name, expect_result.tag_name)\n", "        self.assertEqual(result.id, expect_result.id)\n\t    async def test_find_tag_by_id_found(self):\n\t        \"\"\"\n\t        The test_find_tag_by_id_found function tests the find_tag function when a tag is found.\n\t            The test_find_tag_by_id function sets up the following:\n\t                - A mock session object with a query method that returns an object with a filter method that returns an object\n\t                    with first and all methods. The first and all methods return None by default, but can be set to return\n\t                    objects of any type. In this case, we set it to return our self.tag instance variable which is of type TagModel (see above).\n\t        Args:\n\t            self: Access the attributes and methods of the class in python\n", "        Returns:\n\t            The tag object and the name of that tag\n\t        \"\"\"\n\t        expect_result = self.tag\n\t        id_tag = self.tag.id\n\t        self.session.query().filter().first.return_value = self.tag\n\t        result = await find_tag(id_tag, db=self.session)\n\t        self.assertEqual(result, expect_result)\n\t        self.assertEqual(result.tag_name, expect_result.tag_name)\n\t    async def test_find_tag_by_id_not_found(self):\n", "        \"\"\"\n\t        The test_find_tag_by_id_not_found function tests the find_tag function when a tag is not found.\n\t            The test_find_tag_by_id function creates a mock session and assigns it to self.session, then\n\t            creates an expect result of None and assigns it to expect result, then sets the id of self.tag\n\t            equal to id tag, then sets the return value for first() on filter() on query() on self.session\n\t            equal to None (which simulates that no tags were found), finally calls find tag with id tag as its argument.\n\t        Args:\n\t            self: Represent the instance of the object that is passed to the method when it is called\n\t        Returns:\n\t            None\n", "        \"\"\"\n\t        expect_result = None\n\t        id_tag = self.tag.id\n\t        self.session.query().filter().first.return_value = None\n\t        result = await find_tag(id_tag, db=self.session)\n\t        self.assertEqual(result, expect_result)\n\t        self.assertIsNone(result)\n\t    async def test_find_tag_found(self):\n\t        \"\"\"\n\t        The test_find_tag_found function tests the find_tag function when a tag is found.\n", "        It does this by creating a mock session and setting up the query to return an object.\n\t        The test then calls find_tag with that tag name, and checks if it returns the expected result.\n\t        Args:\n\t            self: Represent the instance of the object that is passed to the method\n\t        Returns:\n\t            The tag that is passed into it\n\t        \"\"\"\n\t        expect_result = self.tag\n\t        tex_tag = self.tag.tag_name\n\t        self.session.query().filter().first.return_value = self.tag\n", "        result = await find_tag(tex_tag, db=self.session)\n\t        self.assertEqual(result, expect_result)\n\t        self.assertEqual(result.tag_name, expect_result.tag_name)\n\t    async def test_find_tag_not_found(self):\n\t        \"\"\"\n\t        The test_find_tag_not_found function tests the find_tag function when a tag is not found.\n\t            The test_find_tag_not_found function uses the mock library to create a mock session object, and then sets up\n\t            that object's query method to return another mocked object. This second mocked object has its filter method set\n\t            up to return yet another mocked object, which in turn has its first method set up so that it returns None. This\n\t            simulates what happens when no tag with the given name exists in the database: The query() call returns an empty list,\n", "            and calling first on an\n\t        Args:\n\t            self: Represent the instance of the object that is passed to the method\n\t        Returns:\n\t            None\n\t        \"\"\"\n\t        expect_result = None\n\t        tex_tag = self.tag.tag_name\n\t        self.session.query().filter().first.return_value = None\n\t        result = await find_tag(tex_tag, db=self.session)\n", "        self.assertEqual(result, expect_result)\n\t        self.assertIsNone(result)\n\t    async def test_delete_tag_found(self):\n\t        \"\"\"\n\t        The test_delete_tag_found function tests the delete_tag function in the tags.py file.\n\t        The test_delete_tag_found function is a coroutine, so it must be called with 'await' and runs asynchronously.\n\t        The test_delete_tag found function takes no arguments, but uses self to access class variables that are set up in\n\t        the setUpClass method at the top of this TestCase class definition.\n\t        Args:\n\t            self: Represent the instance of the class\n", "        Returns:\n\t            The tag that was deleted\n\t        \"\"\"\n\t        expect_result = self.tag\n\t        tex_tag = self.tag.tag_name\n\t        self.session.query().filter().first.return_value = self.tag\n\t        result = await delete_tag(tex_tag, db=self.session)\n\t        self.assertEqual(result, expect_result)\n\t        self.assertEqual(result.tag_name, expect_result.tag_name)\n\t    async def test_delete_tag_not_found(self):\n", "        \"\"\"\n\t        The test_delete_tag_not_found function tests the delete_tag function in the tags.py file.\n\t        The test_delete_tag_not_found function is a coroutine that takes no arguments and returns nothing.\n\t        The test case for this function is when a tag does not exist in the database, so it should return None.\n\t        Args:\n\t            self: Access the attributes and methods of the class in python\n\t        Returns:\n\t            None\n\t        \"\"\"\n\t        expect_result = None\n", "        tex_tag = self.tag.tag_name\n\t        self.session.query().filter().first.return_value = None\n\t        result = await delete_tag(tex_tag, db=self.session)\n\t        self.assertEqual(result, expect_result)\n\t        self.assertIsNone(result)\n\t    async def test_get_images_by_tag_found(self):\n\t        \"\"\"\n\t        The test_get_images_by_tag_found function tests the get_images_by_tag function in the image.py file.\n\t        The test is successful if it returns a list of images that have been tagged with a specific tag.\n\t        Args:\n", "            self: Represent the instance of the class\n\t        Returns:\n\t            The list of images that match the tag\n\t        \"\"\"\n\t        expect_result = [self.image]\n\t        tex_tag = self.tag.tag_name\n\t        tag_limit = 10\n\t        tag_offset = 0\n\t        self.session.query().join().join().filter().order_by().limit().offset().all.return_value = [self.image]\n\t        result = await get_images_by_tag(tag=tex_tag, limit=tag_limit, offset=tag_offset, db=self.session)\n", "        self.assertEqual(result, expect_result)\n\t        self.assertEqual(result[0].id, expect_result[0].id)\n\t        self.assertEqual(result[0].image_url, expect_result[0].image_url)\n\t        self.assertEqual(result[0].description, expect_result[0].description)\n\t        self.assertEqual(result[0].user_id, expect_result[0].user_id)\n\t    async def test_get_images_by_tag_not_found(self):\n\t        \"\"\"\n\t        The test_get_images_by_tag_not_found function tests the get_images_by_tag function in the image.py file\n\t        to ensure that it returns None when no images are found with a given tag.\n\t        Args:\n", "            self: Access the attributes and methods of the class in python\n\t        Returns:\n\t            None\n\t        \"\"\"\n\t        expect_result = None\n\t        tex_tag = self.tag.tag_name\n\t        tag_limit = 10\n\t        tag_offset = 0\n\t        self.session.query().join().join().filter().order_by().limit().offset().all.return_value = None\n\t        result = await get_images_by_tag(tag=tex_tag, limit=tag_limit, offset=tag_offset, db=self.session)\n", "        self.assertEqual(result, expect_result)\n\t        self.assertIsNone(result)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "tests/test_unit_repository_users.py", "chunked_list": ["import unittest\n\tfrom datetime import datetime\n\tfrom unittest.mock import MagicMock\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import User\n\tfrom src.repository.users import create_user, update_token, update_avatar, update_user, change_role, ban_user, \\\n\t    get_user_profile, update_user_by_admin\n\tfrom src.schemas.users import UserModel, UserUpdate, UserChangeRole, UserShow, UserUpdateAdmin\n\tclass TestUsersRepository(unittest.IsolatedAsyncioTestCase):\n\t    def setUp(self):\n", "        self.session = MagicMock(spec=Session)\n\t        self.test_user = User(id=1,\n\t                              login='SomeLogin',\n\t                              email='someemail@gmail.com',\n\t                              role=1,\n\t                              user_pic_url='https://www.gravatar.com/avatar/94d093eda664addd6e450d7e9881bcad?s=32&d'\n\t                                           '=identicon&r=PG',\n\t                              name='Somename',\n\t                              is_active=True,\n\t                              password_checksum='secret')\n", "    async def test_create_user(self):\n\t        body = UserModel(login=self.test_user.login,\n\t                         email=self.test_user.email,\n\t                         password_checksum=self.test_user.password_checksum)\n\t        res = await create_user(body=body, db=self.session)\n\t        self.assertTrue(hasattr(res, \"id\"))\n\t        self.assertEqual(res.login, body.login)\n\t        self.assertEqual(res.email, body.email)\n\t        self.assertEqual(res.password_checksum, body.password_checksum)\n\t    async def test_update_token(self):\n", "        user = self.test_user\n\t        token = None\n\t        result = await update_token(user=user, refresh_token=token, db=self.session)\n\t        self.assertIsNone(result)\n\t    async def test_update_avatar(self):\n\t        url = 'https://res.cloudinary.com/'\n\t        result = await update_avatar(email=self.test_user.email, url=url, db=self.session)\n\t        self.assertEqual(result.avatar, url)\n\t    async def test_change_role(self):\n\t        body = UserChangeRole(id=self.test_user.id,\n", "                              role=2,\n\t                              updated_at=datetime.now())\n\t        res = await change_role(body=body, user=self.test_user, db=self.session)\n\t        self.assertEqual(res.role, body.role)\n\t    async def test_change_role_not_found(self):\n\t        body = UserChangeRole(id=100, role=2, updated_at=datetime.now())\n\t        self.session.query().filter().first.return_value = None\n\t        self.session.commit.return_value = None\n\t        result = await change_role(body=body, user=self.test_user, db=self.session)\n\t        self.assertIsNone(result)\n", "    async def test_get_user_profile(self):\n\t        user_profile = UserShow(\n\t            id=self.test_user.id,\n\t            login=self.test_user.login,\n\t            email=self.test_user.email,\n\t            role=self.test_user.role,\n\t            user_pic_url=self.test_user.user_pic_url,\n\t            name=self.test_user.name,\n\t            is_active=self.test_user.is_active,\n\t        )\n", "        self.session.query().filter().first.return_value = self.test_user\n\t        res = await get_user_profile(login=self.test_user.login, db=self.session)\n\t        self.assertEqual(res, user_profile)\n\t    async def test_ban_user(self):\n\t        res = await ban_user(user_id=1, db=self.session)\n\t        self.assertEqual(res.is_active, False)\n\t    async def test_ban_user_not_found(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await ban_user(user_id=100, db=self.session)\n\t        self.assertIsNone(result)\n", "    async def test_update_user(self):\n\t        body = UserUpdate(id=self.test_user.id,\n\t                          login=self.test_user.login,\n\t                          email=self.test_user.email,\n\t                          role=self.test_user.role,\n\t                          user_pic_url=self.test_user.user_pic_url,\n\t                          name=\"test_update\",\n\t                          password_checksum=self.test_user.password_checksum,\n\t                          is_active=self.test_user.is_active,\n\t                          )\n", "        self.session.query().filter().first.return_value = self.test_user\n\t        res = await update_user(body=body, user=self.test_user, db=self.session)\n\t        self.assertEqual(res.name, \"test_update\")\n\t    async def test_update_user_not_found(self):\n\t        body = UserUpdate(id=100, email=self.test_user.email, password_checksum=self.test_user.password_checksum)\n\t        self.session.query().filter().first.return_value = None\n\t        res = await update_user(body=body, user=self.test_user, db=self.session)\n\t        self.assertIsNone(res)\n\t    async def test_update_user_by_admin(self):\n\t        body = UserUpdateAdmin(id=self.test_user.id,\n", "                               login=self.test_user.login,\n\t                               email=self.test_user.email,\n\t                               role=self.test_user.role,\n\t                               user_pic_url=self.test_user.user_pic_url,\n\t                               name=\"test_update_admin\",\n\t                               password_checksum=self.test_user.password_checksum,\n\t                               is_active=self.test_user.is_active,\n\t                               )\n\t        self.session.query().filter().first.return_value = self.test_user\n\t        res = await update_user_by_admin(body=body, user=self.test_user, db=self.session)\n", "        self.assertEqual(res.name, \"test_update_admin\")\n\t    async def test_update_user_by_admin_not_found(self):\n\t        body = UserUpdateAdmin(id=self.test_user.id,\n\t                               login=self.test_user.login,\n\t                               email=self.test_user.email,\n\t                               role=self.test_user.role,\n\t                               user_pic_url=self.test_user.user_pic_url,\n\t                               name=\"test_update_admin\",\n\t                               password_checksum=self.test_user.password_checksum,\n\t                               is_active=self.test_user.is_active,\n", "                               )\n\t        self.session.query().filter().first.return_value = None\n\t        res = await update_user_by_admin(body=body, user=self.test_user, db=self.session)\n\t        self.assertIsNone(res)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "tests/test_unit_route_auth.py", "chunked_list": ["from _pytest.fixtures import fixture\n\tfrom fastapi import status\n\tfrom src.database.models import User, UserRole\n\t@fixture(scope='function')\n\tdef token(client, user, session):\n\t    response = client.post(\"/api/auth/signup\",\n\t                           json={\"login\": \"deadpool\",\n\t                                 \"email\": \"deadpool@example.com\",\n\t                                 \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n", "    current_user.role = UserRole.Admin\n\t    session.commit()\n\t    response = client.post(\"/api/auth/login\",\n\t                           data={\"username\": \"deadpool@example.com\",\n\t                                 \"password\": \"123456789\"},\n\t                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n\t    return data[\"access_token\"]\n\tdef test_signup(client, user, session):\n\t    response = client.post(\"api/auth/signup\", json=user)\n", "    assert response.status_code == status.HTTP_201_CREATED\n\t    response = client.post(\"api/auth/signup\", json=user)\n\t    assert response.status_code == status.HTTP_409_CONFLICT\n\tdef test_login(client):\n\t    response = client.post(\"/api/auth/login\",\n\t                           data={\"username\": \"deadpool@example.com\",\n\t                                 \"password\": \"123456789\"},\n\t                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.post(\"/api/auth/login\",\n", "                           data={\"username\": \"deadpool@example.com\",\n\t                                 \"password\": \"444\"},\n\t                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\tdef test_login_wrong_user_data(client):\n\t    response = client.post(\"/api/auth/login\",\n\t                           data={\"username\": \"not_found@example.com\",\n\t                                 \"password\": \"123456789\"},\n\t                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n", "def test_logout(client, token):\n\t    response = client.post(\"api/auth/logout\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\tdef test_refresh_token(client, token):\n\t    response = client.get(\"api/auth/refresh_token\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.get(\"api/auth/refresh_token\")\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n"]}
{"filename": "tests/test_unit_services_tags.py", "chunked_list": ["import unittest\n\tfrom src.database.models import Tag\n\tfrom src.services.tags import (\n\t    create_transformation_tags\n\t)\n\t\"\"\"\n\tUnit test services tags.\n\t\"\"\"\n\tclass TestTags(unittest.IsolatedAsyncioTestCase):\n\t    \"\"\"\n", "    Unit test services tags.\n\t    \"\"\"\n\t    def setUp(self):\n\t        \"\"\"\n\t        The setUp function is run before each test.\n\t        It creates a Tag object and stores it in the self.tag_2 variable, which can be accessed by any of the tests in this class.\n\t        Args:\n\t            self: Represent the instance of the class\n\t        Returns:\n\t            The self\n", "        \"\"\"\n\t        self.tag_1 = Tag(id=1, tag_name=\"tag_1#Test#Test2\")\n\t        self.tags = [self.tag_1]\n\t    def test_create_transformation_tags(self):\n\t        \"\"\"\n\t        The test_create_transformation_tags function tests the create_transformation_tags function.\n\t        It does this by creating a list of tags, and then passing that list to the create_transformation_tags function.\n\t        The expected result is a string with all of the tags in it, separated by #tag#'s. The actual result is compared to\n\t        the expected result using an assert statement.\n\t        Args:\n", "            self: Represent the instance of the class\n\t        Returns:\n\t            A string of tags with the\n\t        \"\"\"\n\t        expected_result = \"#tag_1#Test#Test2\"\n\t        result = create_transformation_tags(self.tags)\n\t        self.assertEqual(result, expected_result)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "tests/test_unit_repository_comments.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import MagicMock\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Comment, User\n\tfrom src.schemas.comments import CommentBase, CommentResponse\n\tfrom src.repository.comments import (\n\t    get_all_user_comments,\n\t    get_comments_by_image_id,\n\t    create_comment,\n\t    delete_comment,\n", "    edit_comment,\n\t)\n\tclass TestComments(unittest.IsolatedAsyncioTestCase):\n\t    def setUp(self):\n\t        self.session = MagicMock(spec=Session)\n\t        self.test_user = User(id=1,\n\t                              login='SomeLogin',\n\t                              email='someemail@gmail.com',\n\t                              role=1,\n\t                              user_pic_url='https://www.gravatar.com/avatar/94d093eda664addd6e450d7e9881bcad?s=32&d'\n", "                                           '=identicon&r=PG',\n\t                              name='Somename',\n\t                              is_active=True,\n\t                              password_checksum='secret')\n\t    async def test_get_all_user_comments(self):\n\t        comments = [Comment(), Comment(), Comment()]\n\t        self.session.query().filter().offset().limit().all.return_value = comments\n\t        result = await get_all_user_comments(skip=0, limit=10, user_id=self.test_user.id, db=self.session)\n\t        self.assertEqual(result, comments)\n\t    async def test_get_comments_by_image_id(self):\n", "        comments = [Comment(), Comment(), Comment()]\n\t        self.session.query().filter().offset().limit().all.return_value = comments\n\t        result = await get_comments_by_image_id(skip=0, limit=10, image_id=1, db=self.session)\n\t        self.assertEqual(result, comments)\n\t    async def test_create_comment(self):\n\t        image_id = 1\n\t        body = CommentBase(comment_text='test_comment')\n\t        result = await create_comment(image_id=image_id, body=body, db=self.session, user=self.test_user)\n\t        self.assertEqual(result.comment_text, body.comment_text)\n\t        self.assertEqual(result.image_id, image_id)\n", "        self.assertTrue(hasattr(result, \"id\"))\n\t    async def test_delete_comment_found(self):\n\t        comment = Comment()\n\t        self.session.query().filter().first.return_value = comment\n\t        result = await delete_comment(comment_id=1, db=self.session, user=self.test_user)\n\t        self.assertEqual(result, comment)\n\t    async def test_delete_comment_not_found(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await delete_comment(comment_id=1, db=self.session, user=self.test_user)\n\t        self.assertIsNone(result)\n", "    async def test_edit_comment_found(self):\n\t        body = CommentBase(comment_text='test_comment')\n\t        comment = Comment()\n\t        self.session.query().filter().first.return_value = comment\n\t        self.session.commit.return_value = None\n\t        result = await edit_comment(comment_id=1, body=body, db=self.session, user=self.test_user)\n\t        self.assertEqual(result, comment)\n\t    async def test_edit_comment_not_found(self):\n\t        body = CommentBase(comment_text='test_comment')\n\t        self.session.query().filter().first.return_value = None\n", "        self.session.commit.return_value = None\n\t        result = await edit_comment(comment_id=1, body=body, db=self.session, user=self.test_user)\n\t        self.assertIsNone(result)\n\tif __name__ == '__main__':\n\t    unittest.main()"]}
{"filename": "tests/conftest.py", "chunked_list": ["import pytest\n\tfrom fastapi.testclient import TestClient\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom main import app\n\tfrom src.database.models import Base\n\tfrom src.database.db import get_db\n\tSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n\tengine = create_engine(\n\t    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n", ")\n\tTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\t@pytest.fixture(scope=\"module\")\n\tdef session():\n\t    # Create the database\n\t    Base.metadata.drop_all(bind=engine)\n\t    Base.metadata.create_all(bind=engine)\n\t    db = TestingSessionLocal()\n\t    try:\n\t        yield db\n", "    finally:\n\t        db.close()\n\t@pytest.fixture(scope=\"module\")\n\tdef client(session):\n\t    # Dependency override\n\t    def override_get_db():\n\t        try:\n\t            yield session\n\t        finally:\n\t            session.close()\n", "    app.dependency_overrides[get_db] = override_get_db\n\t    yield TestClient(app)\n\t@pytest.fixture(scope=\"module\")\n\tdef user():\n\t    return {\"login\": \"deadpool\", \"email\": \"deadpool@example.com\", \"password_checksum\": \"123456789\"}\n\t@pytest.fixture(scope=\"module\")\n\tdef user_moder():\n\t    return {\"login\": \"dead2pool\", \"email\": \"dead2pool@example.com\", \"password_checksum\": \"123456789\"}\n\t@pytest.fixture(scope=\"module\")\n\tdef user_user():\n", "    return {\"login\": \"dead1pool\", \"email\": \"dead1pool@example.com\", \"password_checksum\": \"123456789\"}\n"]}
{"filename": "tests/test_unit_route_users.py", "chunked_list": ["from pytest import fixture\n\tfrom src.database.models import User, UserRole\n\tfrom fastapi import status\n\t@fixture(scope='function')\n\tdef token(client, user, session):\n\t    response = client.post(\"/api/auth/signup\",\n\t                           json={\"login\": \"deadpool\",\n\t                                 \"email\": \"deadpool@example.com\",\n\t                                 \"password_checksum\": \"123456789\"})\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n", "    current_user.role = UserRole.Admin\n\t    session.commit()\n\t    response = client.post(\"/api/auth/login\",\n\t                           data={\"username\": \"deadpool@example.com\",\n\t                                 \"password\": \"123456789\"},\n\t                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n\t    return data[\"access_token\"]\n\t@fixture(scope='function')\n\tdef token_second(client, user, session):\n", "    response = client.post(\"/api/auth/signup\",\n\t                           json={\"login\": \"TEST\",\n\t                                 \"email\": \"testpool@example.com\",\n\t                                 \"password_checksum\": \"testpassword\"})\n\t    current_user: User = session.query(User).filter(User.email == 'testpool@example.com').first()\n\t    current_user.role = UserRole.Admin\n\t    session.commit()\n\t    response = client.post(\"/api/auth/login\",\n\t                           data={\"username\": \"testpool@example.com\",\n\t                                 \"password\": \"testpassword\"},\n", "                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\t    data = response.json()\n\t    return data[\"access_token\"]\n\tdef test_read_users_me(client, token):\n\t    response = client.get(\"api/users/me/\",\n\t                          headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.get(\"api/users/me/\")\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\tdef test_read_user_profile_by_username(client, token, user):\n", "    login = user['login']\n\t    response = client.get(f\"api/users/user/{login}/\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    login = 'test_wrong_login'\n\t    response = client.get(f\"api/users/user/{login}/\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\tdef test_change_role(client, user, token):\n\t    response = client.put(\"api/users/change_role\",\n\t                          json={\n\t                              \"id\": 1000,\n", "                              \"role\": 2,\n\t                              },\n\t                          headers={\"Authorization\": f\"Bearer {token}\"},)\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.put(\"api/users/change_role\",\n\t                          json={\n\t                              \"id\": 1,\n\t                              \"role\": 2,\n\t                              },\n\t                          headers={\"Authorization\": f\"Bearer {token}\"},)\n", "    assert response.status_code == status.HTTP_200_OK\n\t    response = client.put(\"api/users/change_role\")\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\tdef test_update_user(client, token):\n\t    response = client.put(\"api/users/update_user\",\n\t                          json={\n\t                              \"id\": 12121,\n\t                              \"email\": \"deadpool@example.com\",\n\t                              \"updated_at\": \"2023-05-21T16:35:59.380Z\",\n\t                              \"user_pic_url\": \"string\",\n", "                              \"name\": \"string\",\n\t                              \"password_checksum\": \"123456789\"},\n\t                          headers={\"Authorization\": f\"Bearer {token}\"},)\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.put(\"api/users/update_user\",\n\t                          headers={\"Authorization\": f\"Bearer {token}\"},\n\t                          json={\n\t                              \"id\": 1,\n\t                              \"email\": \"deadpool@example.com\",\n\t                              \"updated_at\": \"2023-05-21T16:35:59.380Z\",\n", "                              \"user_pic_url\": \"str495y2074y5804ying\",\n\t                              \"name\": \"string\",\n\t                              \"password_checksum\": \"123456789\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.put(\"api/users/update_user\")\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\tdef test_update_user_by_admin(client, token_second):\n\t    response = client.put(\"api/users/update_user_by_admin\",\n\t                          json={\"id\": 100,\n\t                                \"login\": \"deadpool_2\",\n", "                                \"name\": \"deadpool_2\",\n\t                                \"email\": \"testpool@example.com\",\n\t                                \"is_active\": True,\n\t                                \"role\": 1,\n\t                                \"user_pic_url\": \"\",\n\t                                \"password_checksum\": \"testpasswod\",\n\t                                \"updated_at\": \"2023-05-21T16:35:59.380Z\",},\n\t                          headers={\"Authorization\": f\"Bearer {token_second}\"},)\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    response = client.put(\"api/users/update_user_by_admin\",\n", "                          json={\"id\": 1,\n\t                                \"login\": \"TEST_USER\",\n\t                                \"name\": \"test3\",\n\t                                \"email\": \"test______test@example.com\",\n\t                                \"is_active\": True,\n\t                                \"role\": 1,\n\t                                \"user_pic_url\": \"\",\n\t                                \"password_checksum\": \"testpasswod\",\n\t                                \"updated_at\": \"2023-05-21T16:35:59.380Z\",},\n\t                          headers={\"Authorization\": f\"Bearer {token_second}\"},)\n", "    assert response.status_code == status.HTTP_200_OK\n\t    print(response.json())\n\t    response = client.put(\"api/users/update_user_by_admin\")\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\tdef test_ban_user(client, user, token):\n\t    response = client.put(f\"api/users/ban_user/?user_id=1\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    response = client.put(f\"api/users/ban_user/?user_id=100\", headers={\"Authorization\": f\"Bearer {token}\"})\n\t    assert response.status_code == status.HTTP_404_NOT_FOUND\n"]}
{"filename": "docs/conf.py", "chunked_list": ["import sys\n\timport os\n\tsys.path.append(os.path.abspath('..'))\n\tproject = 'PhotoShare Rest API'\n\tcopyright = '2023, command 6 Web9 GoIT'\n\tauthor = 'command 6 Web9 GoIT'\n\trelease = '0.1.0'\n\textensions = ['sphinx.ext.autodoc']\n\ttemplates_path = ['_templates']\n\texclude_patterns = ['build', 'Thumbs.db', '.DS_Store']\n", "html_theme = 'nature'\n\thtml_static_path = ['_static']\n"]}
{"filename": "migrations/env.py", "chunked_list": ["from logging.config import fileConfig\n\tfrom sqlalchemy import engine_from_config\n\tfrom sqlalchemy import pool\n\tfrom alembic import context\n\tfrom src.database.models import Base\n\tfrom src.conf.config import settings\n\t# this is the Alembic Config object, which provides\n\t# access to the values within the .ini file in use.\n\tconfig = context.config\n\t# Interpret the config file for Python logging.\n", "# This line sets up loggers basically.\n\tif config.config_file_name is not None:\n\t    fileConfig(config.config_file_name)\n\t# add your model's MetaData object here\n\t# for 'autogenerate' support\n\t# from myapp import mymodel\n\t# target_metadata = mymodel.Base.metadata\n\ttarget_metadata = Base.metadata\n\tconfig.set_main_option(\"sqlalchemy.url\", settings.database_url)\n\t# other values from the config, defined by the needs of env.py,\n", "# can be acquired:\n\t# my_important_option = config.get_main_option(\"my_important_option\")\n\t# ... etc.\n\tdef run_migrations_offline() -> None:\n\t    \"\"\"Run migrations in 'offline' mode.\n\t    This configures the context with just a URL\n\t    and not an Engine, though an Engine is acceptable\n\t    here as well.  By skipping the Engine creation\n\t    we don't even need a DBAPI to be available.\n\t    Calls to context.execute() here emit the given string to the\n", "    script output.\n\t    \"\"\"\n\t    url = config.get_main_option(\"sqlalchemy.url\")\n\t    context.configure(\n\t        url=url,\n\t        target_metadata=target_metadata,\n\t        literal_binds=True,\n\t        dialect_opts={\"paramstyle\": \"named\"},\n\t    )\n\t    with context.begin_transaction():\n", "        context.run_migrations()\n\tdef run_migrations_online() -> None:\n\t    \"\"\"Run migrations in 'online' mode.\n\t    In this scenario we need to create an Engine\n\t    and associate a connection with the context.\n\t    \"\"\"\n\t    connectable = engine_from_config(\n\t        config.get_section(config.config_ini_section, {}),\n\t        prefix=\"sqlalchemy.\",\n\t        poolclass=pool.NullPool,\n", "    )\n\t    with connectable.connect() as connection:\n\t        context.configure(\n\t            connection=connection, target_metadata=target_metadata\n\t        )\n\t        with context.begin_transaction():\n\t            context.run_migrations()\n\tif context.is_offline_mode():\n\t    run_migrations_offline()\n\telse:\n", "    run_migrations_online()\n"]}
{"filename": "migrations/versions/386af5fb453b_t_m2.py", "chunked_list": ["\"\"\"t_m2\n\tRevision ID: 386af5fb453b\n\tRevises: 14057e32129f\n\tCreate Date: 2023-05-17 22:19:03.206484\n\t\"\"\"\n\tfrom alembic import op\n\timport sqlalchemy as sa\n\t# revision identifiers, used by Alembic.\n\trevision = '386af5fb453b'\n\tdown_revision = '14057e32129f'\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_constraint('tag_to_image_image_id_fkey', 'tag_to_image', type_='foreignkey')\n\t    op.drop_constraint('tag_to_image_tag_id_fkey', 'tag_to_image', type_='foreignkey')\n\t    op.create_foreign_key(None, 'tag_to_image', 'images', ['image_id'], ['id'], ondelete='CASCADE')\n\t    op.create_foreign_key(None, 'tag_to_image', 'tags', ['tag_id'], ['id'], ondelete='CASCADE')\n\t    # ### end Alembic commands ###\n\tdef downgrade() -> None:\n", "    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n\t    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n\t    op.create_foreign_key('tag_to_image_tag_id_fkey', 'tag_to_image', 'tags', ['tag_id'], ['id'])\n\t    op.create_foreign_key('tag_to_image_image_id_fkey', 'tag_to_image', 'images', ['image_id'], ['id'])\n\t    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/38aaf09c56da_upd.py", "chunked_list": ["\"\"\"upd\n\tRevision ID: 38aaf09c56da\n\tRevises: eabd5cef78d7\n\tCreate Date: 2023-05-16 12:52:25.829980\n\t\"\"\"\n\tfrom alembic import op\n\timport sqlalchemy as sa\n\t# revision identifiers, used by Alembic.\n\trevision = '38aaf09c56da'\n\tdown_revision = 'eabd5cef78d7'\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_table('tag_to_image')\n\t    op.create_table('tag_to_image',\n\t                sa.Column('tag_id', sa.Integer(), nullable=False),\n\t                sa.Column('image_id', sa.Integer(), nullable=False),\n\t                sa.ForeignKeyConstraint(['image_id'], ['images.id'], ),\n\t                sa.ForeignKeyConstraint(['tag_id'], ['tags.id'], ),\n", "                sa.PrimaryKeyConstraint('tag_id', 'image_id')\n\t                    )\n\t#    op.add_column('tag_to_image', sa.Column('id', sa.Integer(), nullable=False))\n\t#    op.alter_column('tag_to_image', 'tag_id',\n\t#               existing_type=sa.INTEGER(),\n\t#               nullable=True)\n\t#    op.alter_column('tag_to_image', 'image_id',\n\t#               existing_type=sa.INTEGER(),\n\t#               nullable=True)\n\t#    op.drop_constraint('tag_to_image_image_id_fkey', 'tag_to_image', type_='foreignkey')\n", "#    op.drop_constraint('tag_to_image_tag_id_fkey', 'tag_to_image', type_='foreignkey')\n\t#    op.create_foreign_key(None, 'tag_to_image', 'images', ['image_id'], ['id'], ondelete='CASCADE')\n\t#    op.create_foreign_key(None, 'tag_to_image', 'tags', ['tag_id'], ['id'], ondelete='CASCADE')\n\t    # ### end Alembic commands ###\n\tdef downgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n\t    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n\t    op.create_foreign_key('tag_to_image_tag_id_fkey', 'tag_to_image', 'tags', ['tag_id'], ['id'])\n\t    op.create_foreign_key('tag_to_image_image_id_fkey', 'tag_to_image', 'images', ['image_id'], ['id'])\n", "    op.alter_column('tag_to_image', 'image_id',\n\t               existing_type=sa.INTEGER(),\n\t               nullable=False)\n\t    op.alter_column('tag_to_image', 'tag_id',\n\t               existing_type=sa.INTEGER(),\n\t               nullable=False)\n\t    op.drop_column('tag_to_image', 'id')\n\t    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/14057e32129f_new_tabl.py", "chunked_list": ["\"\"\"new_tabl\n\tRevision ID: 14057e32129f\n\tRevises: 38aaf09c56da\n\tCreate Date: 2023-05-17 22:13:42.220180\n\t\"\"\"\n\tfrom alembic import op\n\timport sqlalchemy as sa\n\t# revision identifiers, used by Alembic.\n\trevision = '14057e32129f'\n\tdown_revision = '38aaf09c56da'\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.create_table('blacklisted_tokens',\n\t    sa.Column('id', sa.Integer(), nullable=False),\n\t    sa.Column('token', sa.String(length=255), nullable=False),\n\t    sa.Column('added_on', sa.DateTime(), nullable=True),\n\t    sa.PrimaryKeyConstraint('id'),\n\t    sa.UniqueConstraint('token')\n", "    )\n\t    op.alter_column('tag_to_image', 'tag_id',\n\t               existing_type=sa.INTEGER(),\n\t               nullable=False)\n\t    op.alter_column('tag_to_image', 'image_id',\n\t               existing_type=sa.INTEGER(),\n\t               nullable=False)\n\t    # ### end Alembic commands ###\n\tdef downgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n", "    op.alter_column('tag_to_image', 'image_id',\n\t               existing_type=sa.INTEGER(),\n\t               nullable=False)\n\t    op.alter_column('tag_to_image', 'tag_id',\n\t               existing_type=sa.INTEGER(),\n\t               nullable=False)\n\t    op.drop_table('blacklisted_tokens')\n\t    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/ba6bf3572799_init.py", "chunked_list": ["\"\"\"Init\n\tRevision ID: ba6bf3572799\n\tRevises: \n\tCreate Date: 2023-05-11 23:10:14.699542\n\t\"\"\"\n\tfrom alembic import op\n\timport sqlalchemy as sa\n\t# revision identifiers, used by Alembic.\n\trevision = 'ba6bf3572799'\n\tdown_revision = None\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.create_table('tags',\n\t    sa.Column('id', sa.Integer(), nullable=False),\n\t    sa.Column('tag_name', sa.String(length=25), nullable=True),\n\t    sa.PrimaryKeyConstraint('id'),\n\t    sa.UniqueConstraint('tag_name')\n\t    )\n", "    op.create_table('users',\n\t    sa.Column('id', sa.Integer(), nullable=False),\n\t    sa.Column('login', sa.String(length=50), nullable=True),\n\t    sa.Column('email', sa.String(length=150), nullable=True),\n\t    sa.Column('role', sa.Integer(), nullable=True),\n\t    sa.Column('created_at', sa.DateTime(), nullable=True),\n\t    sa.Column('updated_at', sa.DateTime(), nullable=True),\n\t    sa.Column('user_pic_url', sa.String(length=255), nullable=True),\n\t    sa.Column('name', sa.String(length=150), nullable=True),\n\t    sa.Column('confirmed', sa.Boolean(), nullable=True),\n", "    sa.Column('is_active', sa.Boolean(), nullable=True),\n\t    sa.Column('password_checksum', sa.String(length=255), nullable=False),\n\t    sa.Column('refresh_token', sa.String(length=255), nullable=True),\n\t    sa.PrimaryKeyConstraint('id'),\n\t    sa.UniqueConstraint('email'),\n\t    sa.UniqueConstraint('login'),\n\t    sa.UniqueConstraint('name')\n\t    )\n\t    op.create_table('images',\n\t    sa.Column('id', sa.Integer(), nullable=False),\n", "    sa.Column('image_url', sa.String(length=255), nullable=False),\n\t    sa.Column('user_id', sa.Integer(), nullable=True),\n\t    sa.Column('created_at', sa.DateTime(), nullable=True),\n\t    sa.Column('updated_at', sa.DateTime(), nullable=True),\n\t    sa.Column('description', sa.String(length=255), nullable=True),\n\t    sa.Column('is_deleted', sa.Boolean(), nullable=True),\n\t    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n\t    sa.PrimaryKeyConstraint('id'),\n\t    sa.UniqueConstraint('image_url')\n\t    )\n", "    op.create_table('comments',\n\t    sa.Column('id', sa.Integer(), nullable=False),\n\t    sa.Column('user_id', sa.Integer(), nullable=True),\n\t    sa.Column('image_id', sa.Integer(), nullable=True),\n\t    sa.Column('created_at', sa.DateTime(), nullable=True),\n\t    sa.Column('updated_at', sa.DateTime(), nullable=True),\n\t    sa.Column('comment_text', sa.Text(), nullable=True),\n\t    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ondelete='CASCADE'),\n\t    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n\t    sa.PrimaryKeyConstraint('id')\n", "    )\n\t    op.create_table('ratings',\n\t    sa.Column('id', sa.Integer(), nullable=False),\n\t    sa.Column('rate', sa.Integer(), nullable=True),\n\t    sa.Column('user_id', sa.Integer(), nullable=True),\n\t    sa.Column('image_id', sa.Integer(), nullable=True),\n\t    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ondelete='CASCADE'),\n\t    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n\t    sa.PrimaryKeyConstraint('id')\n\t    )\n", "    op.create_table('tag_to_image',\n\t    sa.Column('tag_id', sa.Integer(), nullable=False),\n\t    sa.Column('image_id', sa.Integer(), nullable=False),\n\t    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ),\n\t    sa.ForeignKeyConstraint(['tag_id'], ['tags.id'], ),\n\t    sa.PrimaryKeyConstraint('tag_id', 'image_id')\n\t    )\n\t    # ### end Alembic commands ###\n\tdef downgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n", "    op.drop_table('tag_to_image')\n\t    op.drop_table('ratings')\n\t    op.drop_table('comments')\n\t    op.drop_table('images')\n\t    op.drop_table('users')\n\t    op.drop_table('tags')\n\t    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/eabd5cef78d7_users_upgrade.py", "chunked_list": ["\"\"\"users upgrade\n\tRevision ID: eabd5cef78d7\n\tRevises: ba6bf3572799\n\tCreate Date: 2023-05-13 15:27:53.669412\n\t\"\"\"\n\tfrom alembic import op\n\timport sqlalchemy as sa\n\t# revision identifiers, used by Alembic.\n\trevision = 'eabd5cef78d7'\n\tdown_revision = 'ba6bf3572799'\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_constraint('users_name_key', 'users', type_='unique')\n\t    op.drop_column('users', 'confirmed')\n\t    # ### end Alembic commands ###\n\tdef downgrade() -> None:\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.add_column('users', sa.Column('confirmed', sa.BOOLEAN(), autoincrement=False, nullable=True))\n", "    op.create_unique_constraint('users_name_key', 'users', ['name'])\n\t    # ### end Alembic commands ###\n"]}
{"filename": "src/repository/images.py", "chunked_list": ["from typing import List\n\tfrom sqlalchemy.orm import Session\n\tfrom sqlalchemy import and_, desc\n\tfrom src.database.models import User, Image\n\tfrom src.repository.tags import create_tags\n\tfrom src.schemas.images import ImageModel\n\tasync def get_images(limit: int, offset: int, user: User, db: Session) -> List[Image] | None:\n\t    \"\"\"\n\t    The get_images function returns a list of images for the specified user.\n\t        The limit and offset parameters are used to paginate the results.\n", "    Arguments:\n\t        limit (int): maximum number to retrieve\n\t        offset (int): number of object to skip in the search\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Image] | None: A list of image objects or None if no matching images were found\n\t    \"\"\"\n\t    images = db.query(Image).filter(and_(Image.user_id == user.id, Image.is_deleted == False)).\\\n\t        order_by(desc(Image.created_at)).limit(limit).offset(offset).all()\n", "    return images\n\tasync def get_image(image_id: int, user: User, db: Session) -> Image | None:\n\t    \"\"\"\n\t    The get_image function takes in an image_id, a user object and a database session.\n\t    It then queries the database for an image with the given id that belongs to the given user.\n\t    If such an image exists, it is returned.\n\t    Arguments:\n\t        image_id (int): Specify the image id of the image that we want to get\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        Image | None: Image objects or None if no matching image were found\n\t    \"\"\"\n\t    image = db.query(Image).filter(and_(Image.user_id == user.id, Image.id == image_id, Image.is_deleted == False)).\\\n\t        order_by(desc(Image.created_at)).first()\n\t    return image\n\tasync def create(body: ImageModel, image_url: str, user: User, db: Session) -> Image:\n\t    \"\"\"\n\t    The create function creates a new image in the database.\n\t    Args:\n", "        body (ImageModel): The ImageModel object to be created.\n\t        image_url(str): Pass the image url to the database\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image: The image object\n\t    \"\"\"\n\t    image = Image(description=body.description, user=user, image_url=image_url, tags=await create_tags(body.tags_text, db))\n\t    db.add(image)\n\t    db.commit()\n", "    db.refresh(image)\n\t    return image\n\tasync def get_image_from_id(image_id: int, user: User, db: Session) -> Image | None:\n\t    \"\"\"\n\t    The get_image_from_id function takes in an image_id and a user, and returns the image with that id.\n\t    Args:\n\t        image_id (int): The id of the desired Image object.\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n", "        Image | None: An image from the database based on an id and a user or None if no matching image were found\n\t    \"\"\"\n\t    image = db.query(Image).filter(and_(Image.id == image_id, Image.user_id == user.id, Image.is_deleted == False)).first()\n\t    return image\n\tasync def get_image_from_url(image_url: str, user: User, db: Session) -> Image | None:\n\t    \"\"\"\n\t    The get_image_from_url function takes in an image_url and a user object, and returns the Image object\n\t        associated with that url. If no such image exists, it returns None.\n\t    Args:\n\t        image_url(str): Pass the image url to the database\n", "        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image | None: The image with the given url and user or None if no matching image were found\n\t    \"\"\"\n\t    image = db.query(Image).filter(and_(Image.image_url == image_url,\n\t                                        Image.user_id == user.id,\n\t                                        Image.is_deleted == False)).first()\n\t    return image\n\tasync def remove(image_id: int, user: User, db: Session) -> Image | None:\n", "    \"\"\"\n\t    The remove function is used to delete an image from the database.\n\t        It takes in a user and an image_id, and returns the deleted image if it exists.\n\t    Args:\n\t        image_id (int): The id of the desired Image object.\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image | None: the Image object representing the deleted image,\n\t        or None if the user have no permission to delete the image or if no matching image exists in the database\n", "    \"\"\"\n\t    image = await get_image_from_id(image_id, user, db)\n\t    if image:\n\t        image.is_deleted = True\n\t        db.commit()\n\t    return image\n\tasync def change_description(body: ImageModel, image_id: int, user: User, db: Session) -> Image | None:\n\t    \"\"\"\n\t    The change_description function takes in a body, image_id, user and db.\n\t        The function then gets the image from the id provided by the user.\n", "        If there is an image it changes its description to what was provided in the body.\n\t    Args:\n\t        body (ImageModel): The ImageModel object to be created.\n\t        image_id(int): The id of the desired Image object.\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image: The image object with the updated description\n\t    \"\"\"\n\t    image = await get_image_from_id(image_id, user, db)\n", "    if image:\n\t        image.description = body.description\n\t        db.commit()\n\t    return image\n"]}
{"filename": "src/repository/ratings.py", "chunked_list": ["from typing import List\n\tfrom fastapi import HTTPException\n\tfrom sqlalchemy.orm import Session\n\tfrom sqlalchemy import and_, func, desc\n\tfrom starlette import status\n\tfrom src.database.models import Rating, User, Image\n\tasync def create_rate(image_id: int, rate: int, db: Session, user: User) -> Rating:\n\t    \"\"\"\n\t    The create_rate function creates a new rate for the image with the given id.\n\t    Args:\n", "        image_id (int): The id of the image to be rated.\n\t        rate (int): The rating value.\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        user (User): The User object that is creating the rate.\n\t    Returns:\n\t        Comment: the Rating object representing the new rating.\n\t    \"\"\"\n\t    is_self_image = db.query(Image).filter(Image.id == image_id).first().user_id == user.id\n\t    already_rated = db.query(Rating).filter(and_(Rating.image_id == image_id, Rating.user_id == user.id)).first()\n\t    image_exists = db.query(Image).filter(Image.id == image_id).first()\n", "    if is_self_image:\n\t        raise HTTPException(status_code=status.HTTP_423_LOCKED, detail=\"It`s not possible to rate own image.\")\n\t    if already_rated:\n\t        raise HTTPException(status_code=status.HTTP_423_LOCKED, detail=\"It`s not possible to rate twice.\")\n\t    if image_exists:\n\t        new_rate = Rating(image_id=image_id, rate=rate, user_id=user.id)\n\t        db.add(new_rate)\n\t        db.commit()\n\t        db.refresh(new_rate)\n\t        return new_rate\n", "async def delete_rate(rate_id: int, db: Session, user: User) -> None:\n\t    \"\"\"\n\t    The delete_rate function deletes a rating from the database.\n\t    Args:\n\t        rate_id (int): The id of the rating to be deleted.\n\t        db (Session): A connection to the database.\n\t        user (User): The User object that is removes the rate.\n\t    Returns:\n\t        None\n\t    \"\"\"\n", "    rate = db.query(Rating).filter(Rating.id == rate_id).first()\n\t    if rate:\n\t        db.delete(rate)\n\t        db.commit()\n\t    return None\n\tasync def calculate_rating(image_id: int, db: Session, user: User) -> float | None:\n\t    \"\"\"\n\t    The calculate_rating function calculate an average rating of the image.\n\t    Args:\n\t        image_id (int): The id of the image for calculating rating.\n", "        db (Session): A connection to the database.\n\t        user (User): The User object which calculates the rating.\n\t    Returns:\n\t        float: The average rating of the image\n\t    \"\"\"\n\t    rating = db.query(func.avg(Rating.rate)).filter(Rating.image_id == image_id).scalar()\n\t    return rating\n\tasync def show_images_by_rating(to_decrease: bool, db: Session, user: User) -> List[Image] | list:\n\t    \"\"\"\n\t    The show_images_by_rating function show all images in db, sorted by rating.\n", "    Args:\n\t        to_decrease (bool): The boolean value, that indicates the direction of sorting.\n\t        db (Session): A connection to the database.\n\t        user (User): The User object which asks for a list of sorted images\n\t    Returns:\n\t        List[Image] | None: a list of Image objects sorted by rating\n\t        or list if no matching rate\n\t    \"\"\"\n\t    if to_decrease:\n\t        images = db.query(Image, func.avg(Rating.rate).label('rate')).join(Rating).order_by(desc('rate')).group_by(Image).all()\n", "    else:\n\t        images = db.query(Image, func.avg(Rating.rate).label('rate')).join(Rating).order_by('rate').group_by(Image).all()\n\t    rez = []\n\t    for image in images:\n\t        rez.append(image.Image)\n\t    return rez\n"]}
{"filename": "src/repository/users.py", "chunked_list": ["from datetime import datetime\n\tfrom libgravatar import Gravatar\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import User, BlacklistToken\n\tfrom src.schemas.users import UserModel, UserChangeRole, UserUpdate, UserUpdateAdmin, UserShow\n\tfrom src.services.auth import auth_service\n\tasync def get_user_by_email(email: str, db: Session) -> User | None:\n\t    \"\"\"\n\t    Function takes in an email and a database session,\n\t    and returns the user with that email if it exists. If no such user exists,\n", "    it returns None.\n\t    Arguments:\n\t        email (str): Pass in the email of the user we want to find\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User | None: A user object or None if the user is not found\n\t    \"\"\"\n\t    return db.query(User).filter_by(email=email).first()\n\tasync def create_user(body: UserModel, db: Session) -> User:\n\t    \"\"\"\n", "    The create_user function creates a new user in the database.\n\t    Arguments:\n\t        body (UserModel): Pass in the UserModel object that is created from the request body\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User: A user object, which is the same as what we return from our get_user function\n\t    \"\"\"\n\t    g = Gravatar(body.email)\n\t    new_user = User(**body.dict(), user_pic_url=g.get_image())\n\t    db.add(new_user)\n", "    db.commit()\n\t    db.refresh(new_user)\n\t    return new_user\n\tasync def update_token(user: User, refresh_token: str | None, db: Session) -> None:\n\t    \"\"\"\n\t    The update_token function updates the refresh token for a user.\n\t    Arguments:\n\t        user (User): Pass the user object to the function\n\t        refresh_token (str | None): Pass the refresh token to the update_token function\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        None\n\t    \"\"\"\n\t    user.refresh_token = refresh_token\n\t    db.commit()\n\tasync def update_avatar(email: str, url: str, db: Session) -> User:\n\t    \"\"\"\n\t    The update_avatar function updates the avatar of a user.\n\t    Arguments:\n\t        email (str): Find the user in the database by this email\n", "        url (str): Pass in the url of the avatar that we want to update\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User: A user object\n\t    \"\"\"\n\t    user = await get_user_by_email(email, db)\n\t    user.avatar = url\n\t    db.commit()\n\t    return user\n\tasync def update_user(body: UserUpdate, user: User, db: Session) -> User | None:\n", "    \"\"\"\n\t    Updates user profile.\n\t    Logged-in user can update his information.\n\t    Arguments:\n\t        body (UserUpdate): A set of user attributes to update\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User | None: A user object or None\n\t    \"\"\"\n", "    user = db.query(User).filter(User.id == body.id).first()\n\t    if user:\n\t        user.name = body.name\n\t        user.email = body.email\n\t        user.user_pic_url = body.user_pic_url\n\t        user.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n\t        user.updated_at = datetime.now()\n\t        db.commit()\n\t    return user\n\tasync def update_user_by_admin(body: UserUpdateAdmin, user: User, db: Session) -> User | None:\n", "    \"\"\"\n\t    Updates user profile.\n\t    Logged-in admin can update any profile.\n\t    Arguments:\n\t        body (UserUpdateAdmin): A set of user attributes to update\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User | None: A user object or None\n\t    \"\"\"\n", "    user_to_update = db.query(User).filter(User.id == body.id).first()\n\t    if user_to_update:\n\t        user_to_update.login = body.login\n\t        user_to_update.name = body.name\n\t        user_to_update.email = body.email\n\t        user_to_update.is_active = body.is_active\n\t        user_to_update.role = body.role\n\t        user_to_update.user_pic_url = body.user_pic_url\n\t        user_to_update.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n\t        user_to_update.updated_at = datetime.now()\n", "        db.commit()\n\t        return user_to_update\n\t    return None\n\tasync def change_role(body: UserChangeRole, user: User, db: Session) -> User | None:\n\t    \"\"\"\n\t    Logged-in admin can change role of any profile by ID.\n\t    Arguments:\n\t        body (UserChangeRole): A set of user new role\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        User | None: A user object or None\n\t    \"\"\"\n\t    user_to_update = db.query(User).filter(User.id == body.id).first()\n\t    if user_to_update:\n\t        user_to_update.role = body.role\n\t        user_to_update.updated_at = datetime.now()\n\t        db.commit()\n\t        return user_to_update\n\t    return None\n", "async def ban_user(user_id: int, db: Session) -> User | None:\n\t    \"\"\"\n\t    Sets user status to inactive.\n\t    Arguments:\n\t        user_id (int): A set of user new role\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User | None: A user object or None\n\t    \"\"\"\n\t    user_to_ban = db.query(User).filter(User.id == user_id).first()\n", "    if user_to_ban:\n\t        user_to_ban.is_active = False\n\t        db.commit()\n\t        return user_to_ban\n\t    return None\n\tasync def get_user_profile(login: str, db: Session) -> UserShow | None:\n\t    \"\"\"\n\t    function returns a UserShow object containing the user's information.\n\t    Arguments:\n\t        login (str): Get the user profile of a specific user\n", "        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User | None: A UserShow object or None\n\t    \"\"\"\n\t    user = db.query(User).filter(User.login == login).first()\n\t    if user:\n\t        user_profile = UserShow(\n\t            id=user.id,\n\t            login=user.login,\n\t            email=user.email,\n", "            role=user.role,\n\t            user_pic_url=user.user_pic_url,\n\t            name=user.name,\n\t            is_active=user.is_active,\n\t        )\n\t        return user_profile\n\t    return None\n\tasync def add_to_blacklist(token: str, db: Session) -> None:\n\t    \"\"\"\n\t    Function adds a token to the blacklist.\n", "    Arguments:\n\t        token (str): The JWT that is being blacklisted.\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        None\n\t    \"\"\"\n\t    blacklist_token = BlacklistToken(token=token, added_on=datetime.now())\n\t    db.add(blacklist_token)\n\t    db.commit()\n\t    db.refresh(blacklist_token)\n", "    return None\n\tasync def is_blacklisted_token(token: str, db: Session) -> bool:\n\t    \"\"\"\n\t    Function takes checks if a token is blacklisted.\n\t    Arguments:\n\t        token (str): token to be checked\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        bool\n\t    \"\"\"\n", "    blacklist_token = db.query(BlacklistToken).filter(BlacklistToken.token == token).first()\n\t    if blacklist_token:\n\t        return True\n\t    return False\n"]}
{"filename": "src/repository/tags.py", "chunked_list": ["from typing import List\n\tfrom sqlalchemy import and_, desc\n\tfrom src.schemas.tags import TagModel\n\tfrom src.database.models import Tag, tag_to_image, Image\n\tfrom sqlalchemy.orm import Session\n\tdef parse_tags(tags_string: str) -> list[str]:\n\t    \"\"\"\n\t    parse a list of tags, find # and separated by spaces\n\t    Arguments:\n\t        tags_string (str): string to parse\n", "    Returns:\n\t        list[str]: list of tags\n\t    \"\"\"\n\t    result = []\n\t    if not tags_string:\n\t        return result\n\t    raw_tag = tags_string.split(' ')\n\t    for cur_tag in raw_tag:\n\t        if cur_tag[:1] == '#':\n\t            result.append(cur_tag[1:])\n", "            if len(result) == 5:\n\t                return result\n\t    return result\n\tasync def create_tags(tags_string: str, db: Session) -> List[Tag]:\n\t    \"\"\"\n\t    Create a new tags in database just if not exist\n\t    limit 5 tags\n\t    Arguments:\n\t        tags_string (str): string to create tags after parsing\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        List[Tag]: list with tags objects\n\t    \"\"\"\n\t    result = []\n\t    rw_tags = parse_tags(tags_string)\n\t    for tag_name in rw_tags:\n\t        tag = await find_tag(tag_name, db)\n\t        if tag:\n\t            result.append(tag)\n\t        else:\n", "            tag = Tag(tag_name=tag_name)\n\t            db.add(tag)\n\t            db.commit()\n\t            db.refresh(tag)\n\t            result.append(tag)\n\t    return result\n\tasync def edit_tag(tag: Tag, body: TagModel, db: Session) -> Tag | None:\n\t    \"\"\"\n\t    The edit_tag function takes in a tag object, the body of the request (which is a TagModel), and\n\t    the database session. It then sets the tag_name attribute of that tag to be equal to whatever was\n", "    passed in as part of the body. The function then commits those changes to our database and refreshes\n\t    the object so that it reflects any changes made by other users.\n\t    Arguments:\n\t        tag (Tag): Pass the tag object to the function\n\t        body (TagModel): request body containing information about tag for editing\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Tag | None: tag object after editing\n\t        or None if the user have no permission to edite the tag or if no matching tag exists in the database\n\t    \"\"\"\n", "    tag.tag_name = body.tag_name\n\t    db.commit()\n\t    db.refresh(tag)\n\t    return tag\n\tasync def find_tag(tag_name: str, db: Session) -> Tag | None:\n\t    \"\"\"\n\t    get tag from database by name\n\t    Arguments:\n\t        tag_name (str): name of tag to find\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        Tag | None: tag object\n\t        or None if no matching tag exists in the database\n\t    \"\"\"\n\t    tag = db.query(Tag).filter(Tag.tag_name == tag_name).first()\n\t    return tag\n\tasync def find_tag_by_id(tag_id: int, db: Session) -> Tag | None:\n\t    \"\"\"\n\t    The find_tag_by_id function takes in a tag_id and db Session object,\n\t    and returns the Tag object with that id. If no such tag exists, it returns None.\n", "    Args:\n\t        tag_id: int: Find the tag in the database\n\t        db: Session: Pass the database session to the function\n\t    Returns:\n\t        A tag object or none\n\t    \"\"\"\n\t    tag = db.query(Tag).filter(Tag.id == tag_id).first()\n\t    return tag\n\tasync def delete_tag(tag_name: str, db: Session) -> Tag | None:\n\t    \"\"\"\n", "    Delete tag from database just for Administrator role\n\t    Arguments:\n\t        tag_name (str): name of tag to find\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Tag | None: tag object\n\t        or None if the user have no permission to delete the tag or if no matching tag exists in the database\n\t    \"\"\"\n\t    tag = await find_tag(tag_name, db)\n\t    if tag:\n", "        db.delete(tag)\n\t        db.commit()\n\t    return tag\n\tasync def get_images_by_tag(tag: str, limit: int, offset: int, db: Session) -> List[Image] | None:\n\t    \"\"\"\n\t    The get_images function returns a list of images for the specified user.\n\t        The limit and offset parameters are used to paginate the results.\n\t    Arguments:\n\t        tag (str): name of tag to find images\n\t        offset (int): number of comments to skip in the search\n", "        limit (int): maximum number of comments to retrieve\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Image] | None: a list of Image objects with tags,\n\t        or None if no matching tags were found\n\t    \"\"\"\n\t    images = db.query(Image).join(tag_to_image).join(Tag).filter(and_(Tag.tag_name == tag, Image.is_deleted == False))\\\n\t        .order_by(desc(Image.created_at)).limit(limit).offset(offset).all()\n\t    return images\n"]}
{"filename": "src/repository/comments.py", "chunked_list": ["from typing import List\n\tfrom sqlalchemy import func, and_\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import User, Comment\n\tfrom src.schemas.comments import CommentBase\n\tasync def create_comment(image_id: int, body: CommentBase, db: Session, user: User) -> Comment:\n\t    \"\"\"\n\t    Creates a new comment in the database.\n\t    Arguments:\n\t        image_id (int): ID of the image that the comment is being made on\n", "        body (CommentBase): Pass the comment_text from the request body to the function\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        user (User): the current user attempting to delete the comment\n\t    Returns:\n\t        Comment: the Comment object representing the new comment\n\t    \"\"\"\n\t    comment = Comment(user_id=user.id,\n\t                      image_id=image_id,\n\t                      created_at=func.now(),\n\t                      comment_text=body.comment_text)\n", "    db.add(comment)\n\t    db.commit()\n\t    db.refresh(comment)\n\t    return comment\n\tasync def edit_comment(comment_id: int, body: CommentBase, db: Session, user: User) -> Comment | None:\n\t    \"\"\"\n\t    Modifies the specified comment in the database, if the current user has permission to do so.\n\t    Arguments:\n\t        comment_id (int): ID of the comment to be deleted\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "        body (CommentBase): Pass the comment_text from the request body to the function\n\t        user (User): the current user attempting to edite the comment\n\t    Returns:\n\t        Comment | None: the Comment object representing the modified comment,\n\t        or None if the user have no permission to edite the comment or if no matching comment exists in the database\n\t    \"\"\"\n\t    comment = db.query(Comment).filter(and_(Comment.id == comment_id, Comment.user_id == user.id)).first()\n\t    if comment:\n\t        comment.comment_text = body.comment_text\n\t        comment.updated_at = func.now()\n", "        db.commit()\n\t    return comment\n\tasync def delete_comment(comment_id: int, db: Session, user: User) -> Comment | None:\n\t    \"\"\"\n\t    Deletes the specified comment from the database, if the current user has permission to do so.\n\t    Arguments:\n\t        comment_id (int): ID of the comment to be deleted\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        user (User): the current user attempting to delete the comment\n\t    Returns:\n", "        Comment | None: the Comment object representing the deleted comment,\n\t        or None if the user have no permission to delete the comment or if no matching comment exists in the database\n\t    \"\"\"\n\t    comment = db.query(Comment).filter(Comment.id == comment_id).first()\n\t    if comment:\n\t        db.delete(comment)\n\t        db.commit()\n\t    return comment\n\tasync def get_all_user_comments(skip: int, limit: int, user_id: int, db: Session) -> List[Comment] | None:\n\t    \"\"\"\n", "    Gets all comments from the specified user from the database.\n\t    Arguments:\n\t        skip (int): number of comments to skip in the search\n\t        limit (int): maximum number of comments to retrieve\n\t        user_id (int): ID of the user to retrieve comments for\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Comment] | None: a list of Comment objects representing the user's comments,\n\t        or None if no matching comments were found\n\t    \"\"\"\n", "    return db.query(Comment).filter(Comment.user_id == user_id).offset(skip).limit(limit).all()\n\tasync def get_comments_by_image_id(skip: int, limit: int, image_id: int, db: Session) -> List[Comment] | None:\n\t    \"\"\"\n\t    Gets all comments of the specified image from the database.\n\t    Arguments:\n\t        skip (int): number of comments to skip in the search\n\t        limit (int): maximum number of comments to retrieve\n\t        image_id (int): ID of the image to retrieve comments for\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n", "        List[Comment] | None: a list of Comment objects representing all comments,\n\t        or None if no matching comments were found\n\t    \"\"\"\n\t    return db.query(Comment).filter(Comment.image_id == image_id).offset(skip).limit(limit).all()\n"]}
{"filename": "src/schemas/images.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Optional, List\n\tfrom pydantic import BaseModel, Field\n\tfrom src.schemas.tags import TagResponse\n\tclass ImageModel(BaseModel):\n\t    description: str = Field('description min_length 20 simbols', min_length=20, max_length=255)\n\t    tags_text: Optional[str] = Field(None, max_length=25)\n\tclass ImageResponse(BaseModel):\n\t    id: int\n\t    image_url: str\n", "    user_id: int\n\t    created_at: datetime\n\t    updated_at: Optional[datetime]\n\t    description: str\n\t    tags: List[TagResponse]\n\t    class Config:\n\t        orm_mode = True\n\tclass ImageTransformationModel(BaseModel):\n\t    id: int\n\t    transformation: str = \"standard\"\n"]}
{"filename": "src/schemas/ratings.py", "chunked_list": ["from pydantic import BaseModel\n\tclass AverageRatingResponse(BaseModel):\n\t    average_rating: float\n\tclass RatingModel(BaseModel):\n\t    rate: int\n\tclass RatingResponse(BaseModel):\n\t    id: int\n\t    rate: int\n\t    user_id: int\n\t    image_id: int\n", "    class Config:\n\t        orm_mode = True\n"]}
{"filename": "src/schemas/users.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Optional\n\tfrom pydantic import BaseModel, Field\n\tclass UserModel(BaseModel):\n\t    login: str = Field(min_length=4, max_length=12)\n\t    email: str = Field(min_length=4, max_length=120)\n\t    password_checksum: str = Field(min_length=6)\n\tclass UserResponse(BaseModel):\n\t    id: int\n\t    login: str\n", "    email: str\n\t    role: int\n\t    created_at: datetime\n\t    updated_at: Optional[datetime]\n\t    user_pic_url: Optional[str]\n\t    name: Optional[str]\n\t    is_active: bool\n\t    password_checksum: str\n\t    refresh_token: Optional[str]\n\t    class Config:\n", "        orm_mode = True\n\tclass UserChangeRole(BaseModel):\n\t    id: int\n\t    role: int\n\t    updated_at: Optional[datetime]\n\t    class Config:\n\t        orm_mode = True\n\tclass UserUpdate(BaseModel):\n\t    id: int\n\t    email: str\n", "    updated_at: Optional[datetime]\n\t    user_pic_url: Optional[str]\n\t    name: Optional[str]\n\t    password_checksum: str\n\t    class Config:\n\t        orm_mode = True\n\tclass UserUpdateAdmin(BaseModel):\n\t    id: int\n\t    login: str\n\t    email: str\n", "    role: int\n\t    updated_at: Optional[datetime]\n\t    user_pic_url: Optional[str]\n\t    name: Optional[str]\n\t    is_active: bool\n\t    password_checksum: str\n\t    class Config:\n\t        orm_mode = True\n\tclass UserShow(BaseModel):\n\t    id: int\n", "    login: str\n\t    email: str\n\t    role: int\n\t    user_pic_url: Optional[str]\n\t    name: Optional[str]\n\t    is_active: bool\n\t    class Config:\n\t        orm_mode = True\n\tclass UserDb(BaseModel):\n\t    id: int\n", "    email: str\n\t    created_at: datetime\n\t    class Config:\n\t        orm_mode = True\n\tclass TokenModel(BaseModel):\n\t    access_token: str\n\t    refresh_token: str\n\t    token_type: str = \"bearer\"\n"]}
{"filename": "src/schemas/tags.py", "chunked_list": ["from pydantic import BaseModel, Field\n\tclass TagModel(BaseModel):\n\t    tag_name: str = Field(max_length=30)\n\tclass TagResponse(BaseModel):\n\t    id: int\n\t    tag_name: str\n\t    class Config:\n\t        orm_mode = True\n"]}
{"filename": "src/schemas/comments.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Optional\n\tfrom pydantic import BaseModel, Field\n\tclass CommentBase(BaseModel):\n\t    comment_text: str = Field(max_length=1500)\n\tclass CommentResponse(BaseModel):\n\t    id: int\n\t    user_id: int\n\t    image_id: int\n\t    comment_text: str\n", "    created_at: datetime\n\t    updated_at: Optional[datetime]\n\t    class Config:\n\t        orm_mode = True\n"]}
{"filename": "src/database/models.py", "chunked_list": ["import enum\n\tfrom sqlalchemy import Column, ForeignKey, String, Integer, DateTime, func, Boolean, Text, Table\n\tfrom sqlalchemy.orm import relationship, declarative_base\n\tBase = declarative_base()\n\ttag_to_image = Table('tag_to_image', Base.metadata,\n\t                     #Column('id', Integer, primary_key=True),\n\t                     Column('tag_id', Integer, ForeignKey('tags.id', ondelete=\"CASCADE\"), nullable=False),\n\t                     Column('image_id', Integer, ForeignKey('images.id', ondelete=\"CASCADE\"), nullable=False),\n\t                     )\n\tclass UserRole(int, enum.Enum):\n", "    Admin = 1\n\t    Moderator = 2\n\t    User = 3\n\tclass User(Base):\n\t    __tablename__ = \"users\"\n\t    id = Column(Integer, primary_key=True)\n\t    login = Column(String(50), unique=True)\n\t    email = Column(String(150), unique=True)\n\t    role = Column(Integer, default=UserRole.User.value)\n\t    created_at = Column('created_at', DateTime, default=func.now())\n", "    updated_at = Column('updated_at', DateTime, default=func.now())\n\t    user_pic_url = Column(String(255))\n\t    name = Column(String(150), unique=False)\n\t    is_active = Column(Boolean, default=True)\n\t    password_checksum = Column(String(255), nullable=False)\n\t    refresh_token = Column(String(255), nullable=True)\n\tclass Image(Base):\n\t    __tablename__ = \"images\"\n\t    id = Column(Integer, primary_key=True)\n\t    image_url = Column(String(255), unique=True, nullable=False)\n", "    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"))\n\t    created_at = Column('created_at', DateTime, default=func.now())\n\t    updated_at = Column('updated_at', DateTime, default=func.now())\n\t    description = Column(String(255))\n\t    is_deleted = Column(Boolean, default=False)\n\t    user = relationship('User', backref=\"images\")\n\t    tags = relationship(\"Tag\", secondary=tag_to_image, backref=\"images\", passive_deletes=True)\n\tclass Comment(Base):\n\t    __tablename__ = \"comments\"\n\t    id = Column(Integer, primary_key=True)\n", "    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"))\n\t    image_id = Column(Integer, ForeignKey(Image.id, ondelete=\"CASCADE\"))\n\t    created_at = Column('created_at', DateTime, default=func.now())\n\t    updated_at = Column('updated_at', DateTime)\n\t    comment_text = Column(Text)\n\t    user = relationship('User', backref=\"comments\")\n\t    image = relationship('Image', backref=\"comments\")\n\tclass Tag(Base):\n\t    __tablename__ = \"tags\"\n\t    id = Column(Integer, primary_key=True)\n", "    tag_name = Column(String(25), unique=True)\n\tclass Rating(Base):\n\t    __tablename__ = 'ratings'\n\t    id = Column(Integer, primary_key=True)\n\t    rate = Column(\"rate\", Integer, default=0)\n\t    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"))\n\t    image_id = Column(Integer, ForeignKey(Image.id, ondelete=\"CASCADE\"))\n\t    user = relationship('User', backref=\"ratings\")\n\t    image = relationship('Image', backref=\"ratings\")\n\tclass BlacklistToken(Base):\n", "    __tablename__ = 'blacklisted_tokens'\n\t    id = Column(Integer, primary_key=True)\n\t    token = Column(String(255), unique=True, nullable=False)\n\t    added_on = Column(DateTime, default=func.now())\n"]}
{"filename": "src/database/db.py", "chunked_list": ["from src.conf.config import settings\n\tfrom fastapi import HTTPException, status\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom sqlalchemy.exc import SQLAlchemyError\n\tSQLALCHEMY_DATABASE_URL = settings.sqlalchemy_database_url\n\tengine = create_engine(SQLALCHEMY_DATABASE_URL)\n\tDBSession = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\t# Dependency\n\tdef get_db():\n", "    db = DBSession()\n\t    try:\n\t        yield db\n\t    except SQLAlchemyError as err_sql:\n\t        db.rollback()\n\t        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(err_sql))\n\t    finally:\n\t        db.close()\n"]}
{"filename": "src/services/cloud_image.py", "chunked_list": ["import hashlib\n\timport re\n\tfrom io import BytesIO\n\tfrom uuid import uuid4\n\timport qrcode\n\timport cloudinary\n\timport cloudinary.uploader\n\tfrom fastapi import HTTPException\n\tfrom starlette import status\n\tfrom src.conf.config import settings\n", "class CloudImage:\n\t    cloudinary.config(\n\t        cloud_name=settings.cloudinary_name,\n\t        api_key=settings.cloudinary_api_key,\n\t        api_secret=settings.cloudinary_api_secret,\n\t        secure=True\n\t    )\n\t    @staticmethod\n\t    def generate_name_image():\n\t        \"\"\"\n", "        The generate_name_image function generates a unique name for the image file.\n\t        It uses the uuid4 function to generate a random UUID, and then hashes it using SHA256.\n\t        The resulting hash is converted to hexadecimal format, and returned as a string.\n\t        Arguments:\n\t        Returns:\n\t            A string of the form &quot;photoshare/&lt;sha256 hash&gt;&quot;\n\t        \"\"\"\n\t        name = hashlib.sha256(str(uuid4()).encode('utf-8')).hexdigest()\n\t        return f\"photoshare/{name}\"\n\t    @staticmethod\n", "    def generate_name_avatar(email: str):\n\t        \"\"\"\n\t        The generate_name_avatar function takes an email address as input and returns a unique avatar name.\n\t        The function uses the first 12 characters of the SHA256 hash of the email address to generate a unique string.\n\t        This string is then appended with &quot;web9/&quot; to create a valid S3 bucket key.\n\t        Arguments:\n\t            email (str): Specify the type of parameter that is expected to be passed into the function\n\t        Returns:\n\t            A string that is a combination of the prefix &quot;web9/&quot; and a 12-character hash of the email address\n\t        \"\"\"\n", "        name = hashlib.sha256(email.encode('utf-8')).hexdigest()[:12]\n\t        return f\"web9/{name}\"\n\t    @staticmethod\n\t    def upload(file, public_id: str, overwrite=True):\n\t        \"\"\"\n\t        The upload function takes a file and uploads it to the cloudinary server.\n\t            The public_id is the name of the file on cloudinary, and overwrite=True means that if there is already\n\t            a file with that name, it will be overwritten.\n\t        Arguments:\n\t            file (bite): Specify the file to be uploaded\n", "            public_id (str): Specify the public id of the image\n\t            overwrite (bool): Determine whether the image should be overwritten if it already exists\n\t        Returns:\n\t            A dictionary with the following keys\n\t        \"\"\"\n\t        r = cloudinary.uploader.upload(file, public_id=public_id, overwrite=overwrite)\n\t        return r\n\t    @staticmethod\n\t    def get_url_for_avatar(public_id, r):\n\t        \"\"\"\n", "        The get_url_for_avatar function takes in a public_id and an r\n\t        (which is the result of a cloudinary.api.resource call)\n\t        and returns the URL for that avatar image, which will be used to display it on the page.\n\t        Arguments:\n\t            public_id (str): Identify the image in cloudinary\n\t            r: Get the version of the image\n\t        Returns:\n\t            A url of avatar\n\t        \"\"\"\n\t        src_url = cloudinary.CloudinaryImage(public_id) \\\n", "            .build_url(width=250, height=250, crop='fill', version=r.get('version'))\n\t        return src_url\n\t    @staticmethod\n\t    def get_url_for_image(file_name):\n\t        \"\"\"\n\t        The get_url_for_image function takes a file name as an argument and returns the url for that image.\n\t        The function uses the cloudinary library to generate a url from the file name.\n\t        Arguments:\n\t            file_name (str): Specify the name of the file that is to be uploaded\n\t        Returns:\n", "            The url for the image\n\t        \"\"\"\n\t        src_url = cloudinary.utils.cloudinary_url(file_name)\n\t        return src_url[0]\n\t    @staticmethod\n\t    def get_transformation_image(public_id: str, transformation: str):\n\t        \"\"\"\n\t        The get_transformation_image function takes in a public_id and transformation string,\n\t            then returns the url of the transformed image. If no transformation is found, it returns None.\n\t        Arguments:\n", "            public_id (str): Get the public id of the image\n\t            transformation (str): Get the transformation name from the transformation class\n\t        Returns:\n\t            The url of the transformed image\n\t        \"\"\"\n\t        public_id = re.search(r'(?<=/v\\d/).+', public_id).group(0)\n\t        if transformation in Transformation.name.keys():\n\t            transformation_image_url = cloudinary.utils.cloudinary_url(public_id,\n\t                                                                       transformation=[Transformation.name.get(transformation)])[0]\n\t            return transformation_image_url\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    @staticmethod\n\t    async def create_qr_code_image(url: str):\n\t        \"\"\"\n\t        The create_qr_code_image function takes a URL and returns an image of the QR code for that URL.\n\t        Arguments:\n\t            url (str): Pass the url to be encoded into a qr code\n\t        Returns:\n\t            A bytesio object\n\t        \"\"\"\n", "        qr = qrcode.QRCode(\n\t            version=1,\n\t            error_correction=qrcode.constants.ERROR_CORRECT_L,\n\t            box_size=3,\n\t            border=4,\n\t        )\n\t        qr.add_data(url)\n\t        qr.make(fit=True)\n\t        img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n\t        output = BytesIO()\n", "        img.save(output)\n\t        output.seek(0)\n\t        return output\n\tclass Standard:\n\t    name = \"standard\"\n\t    transformation = {\"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\tclass Radius:\n\t    name = \"radius\"\n\t    transformation = {\"radius\": \"max\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\tclass Grayscale:\n", "    name = \"grayscale\"\n\t    transformation = {\"effect\": \"grayscale\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\tclass Cartoonify:\n\t    name = \"cartoonify\"\n\t    transformation = {\"effect\": \"cartoonify\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\tclass Vectorize:\n\t    name = \"vectorize\"\n\t    transformation = {\"effect\": \"vectorize:colors:2:detail:0.05\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\tclass Transformation:\n\t    \"\"\"\n", "    Transformation images cloudinary.\n\t    grayscale\n\t    cartoonify\n\t    radius\n\t    standard\n\t    vectorize\n\t    \"\"\"\n\t    name = {\n\t        \"grayscale\": Grayscale.transformation,\n\t        \"cartoonify\": Cartoonify.transformation,\n", "        \"radius\": Radius.transformation,\n\t        \"standard\": Standard.transformation,\n\t        \"vectorize\": Vectorize.transformation\n\t    }\n"]}
{"filename": "src/services/auth.py", "chunked_list": ["from datetime import datetime, timedelta\n\tfrom typing import Optional\n\tfrom fastapi import Depends, HTTPException, status\n\tfrom passlib.context import CryptContext\n\tfrom fastapi.security import OAuth2PasswordBearer  # Bearer token\n\tfrom sqlalchemy.orm import Session\n\tfrom jose import JWTError, jwt\n\tfrom src.database.db import get_db\n\tfrom src.repository import users as repository_users\n\tfrom src.conf.config import settings\n", "class Auth:\n\t    pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\t    SECRET_KEY = settings.secret_key\n\t    ALGORITHM = settings.algorithm\n\t    oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/auth/login\")\n\t    credentials_exception = HTTPException(\n\t        status_code=status.HTTP_401_UNAUTHORIZED,\n\t        detail=\"Could not validate credentials\",\n\t        headers={\"WWW-Authenticate\": \"Bearer\"},\n\t    )\n", "    @classmethod\n\t    def token_decode(cls, token: str) -> dict:\n\t        \"\"\"\n\t            Try to decode the token\n\t        Arguments:\n\t            token (str): token to take decoded\n\t        Returns:\n\t            dict with results of decoded token\n\t        \"\"\"\n\t        try:\n", "            return jwt.decode(token, cls.SECRET_KEY, algorithms=[cls.ALGORITHM])\n\t        except JWTError:\n\t            raise cls.credentials_exception\n\t    @classmethod\n\t    async def create_access_token(cls, data: dict, expires_delta: Optional[float] = None) -> dict:\n\t        \"\"\"\n\t        The create_access_token function creates a new access token for the user.\n\t            The function takes in two arguments: data and expires_delta.\n\t            Data is a dictionary that contains all of the information about the user,\n\t            such as their username, email address, etc.\n", "            Expires_delta is an optional argument that specifies how long you want your access token to be valid\n\t            for (in seconds). If no value is specified then it defaults to 48 hours.\n\t        Arguments:\n\t            data (dict): A dictionary containing the user's id and username.\n\t            expires_delta (Optional[float]): The number of seconds until the token expires, defaults to None.\n\t        Returns:\n\t            A token that is encoded with the data, current time, expiry time and scope\n\t        \"\"\"\n\t        to_encode = data.copy()\n\t        if expires_delta:\n", "            expire = datetime.utcnow() + timedelta(seconds=expires_delta)\n\t        else:\n\t            expire = datetime.utcnow() + timedelta(hours=48)\n\t        to_encode.update({\"iat\": datetime.utcnow(), \"exp\": expire, \"scope\": \"access_token\"})\n\t        encoded_access_token = jwt.encode(to_encode, cls.SECRET_KEY, algorithm=cls.ALGORITHM)\n\t        return encoded_access_token\n\t    @classmethod\n\t    async def create_refresh_token(cls, data: dict, expires_delta: Optional[float] = None):\n\t        \"\"\"\n\t        The create_refresh_token function creates a refresh token for the user.\n", "        Arguments:\n\t            data (dict): A dictionary containing the user's id and username.\n\t            expires_delta (Optional[float]): Set the expiration time of the refresh token\n\t        Returns:\n\t            An encoded refresh token\n\t        \"\"\"\n\t        to_encode = data.copy()\n\t        if expires_delta:\n\t            expire = datetime.utcnow() + timedelta(seconds=expires_delta)\n\t        else:\n", "            expire = datetime.utcnow() + timedelta(days=7)\n\t        to_encode.update({\"iat\": datetime.utcnow(), \"exp\": expire, \"scope\": \"refresh_token\"})\n\t        encoded_refresh_token = jwt.encode(to_encode, cls.SECRET_KEY, algorithm=cls.ALGORITHM)\n\t        return encoded_refresh_token\n\t    @classmethod\n\t    async def get_current_user(cls, token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):\n\t        \"\"\"\n\t        The get_current_user function is a dependency that will be used in the\n\t            protected endpoints. It takes a token as an argument and returns the user\n\t            if it's valid, or raises an exception otherwise.\n", "        Arguments:\n\t            token (str): Get the token from the request header\n\t            db (Session): SQLAlchemy session object for accessing the database\n\t        Returns:\n\t            A user object if the token is valid\n\t        \"\"\"\n\t        payload = cls.token_decode(token)\n\t        if payload.get(\"scope\") == \"access_token\":\n\t            email = payload.get(\"sub\")\n\t            if email is None:\n", "                raise cls.credentials_exception\n\t        else:\n\t            raise cls.credentials_exception\n\t        token_blacklisted = await repository_users.is_blacklisted_token(token, db)\n\t        if token_blacklisted:\n\t            raise cls.credentials_exception\n\t        user = await repository_users.get_user_by_email(email, db)\n\t        if user is None:\n\t            raise cls.credentials_exception\n\t        return user\n", "    @classmethod\n\t    async def decode_refresh_token(cls, refresh_token: str):\n\t        \"\"\"\n\t        The decode_refresh_token function is used to decode the refresh token.\n\t        It takes a refresh_token as an argument and returns the email of the user if it's valid.\n\t        If not, it raises an HTTPException with status code 401 (UNAUTHORIZED)\n\t        and detail 'Could not validate credentials'.\n\t        Arguments:\n\t            refresh_token (str): Pass the refresh token to the function\n\t        Returns:\n", "            The email of the user that is associated with the refresh token\n\t        \"\"\"\n\t        payload = cls.token_decode(refresh_token)\n\t        if payload['scope'] == 'refresh_token':\n\t            email = payload['sub']\n\t            return email\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='Invalid scope for token')\n\t    @classmethod\n\t    def create_email_token(cls, data: dict):\n\t        \"\"\"\n", "        The create_email_token function takes a dictionary of data and returns a token.\n\t        The token is encoded with the SECRET_KEY, which is stored in the .env file.\n\t        The algorithm used to encode the token is also stored in the .env file.\n\t        Arguments:\n\t            data (dict): Pass in the data that will be encoded into the token\n\t        Returns:\n\t            A token that is encoded with the user's email and a secret key\n\t        \"\"\"\n\t        to_encode = data.copy()\n\t        expire = datetime.utcnow() + timedelta(hours=1)\n", "        to_encode.update({\"iat\": datetime.utcnow(), \"exp\": expire, \"scope\": \"email_token\"})\n\t        token = jwt.encode(to_encode, cls.SECRET_KEY, algorithm=cls.ALGORITHM)\n\t        return token\n\t    @classmethod\n\t    def get_email_from_token(cls, token: str):\n\t        \"\"\"\n\t        The get_email_from_token function takes a token as an argument and\n\t        returns the email associated with that token.\n\t        It does this by decoding the JWT using our SECRET_KEY and ALGORITHM,\n\t        then checking to make sure that it has a scope of 'email_token'.\n", "        If so, it returns the email address from the payload's sub field.\n\t        If not, it raises an HTTPException with status code 401 (Unauthorized)\n\t        and detail message &quot;Invalid scope for token&quot;.\n\t        If there is any other error in decoding or validating the JWT, we raise another\n\t        HTTPException with status code 422\n\t        Arguments:\n\t            token (str): Pass in the token that is sent to the user's email\n\t        Returns:\n\t            The email address associated with the token\n\t        \"\"\"\n", "        payload = cls.token_decode(token)\n\t        if payload['scope'] == 'email_token':\n\t            email = payload['sub']\n\t            return email\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='Invalid scope for token')\n\tauth_service = Auth()\n"]}
{"filename": "src/services/roles.py", "chunked_list": ["from typing import List\n\tfrom fastapi import Depends, HTTPException, status, Request\n\tfrom src.database.models import User, UserRole\n\tfrom src.services.auth import auth_service\n\tclass RoleAccess:\n\t    def __init__(self, allowed_roles: List[UserRole]):\n\t        \"\"\"\n\t        The __init__ function is called when the class is instantiated.\n\t        It sets up the instance of the class, and takes in any arguments that are required to do so.\n\t        In this case, we're taking in a list of allowed roles.\n", "        Arguments:\n\t            allowed_roles (List[UserRole]): Create a list of roles that are allowed to use the command\n\t        Returns:\n\t            None\n\t        \"\"\"\n\t        self.allowed_roles = allowed_roles\n\t    async def __call__(self, request: Request, current_user: User = Depends(auth_service.get_current_user)):\n\t        \"\"\"\n\t        The __call__ function is the function that will be called when a user tries to access an endpoint.\n\t        It takes in two arguments: request and current_user. The request argument is the Request object, which contains\n", "        information about the HTTP request made by a client (e.g., headers, body).\n\t        The current_user argument is provided by Depends(auth_service.get_current_user), which means it will call\n\t        auth_service's getCurrentUser() function and pass its return value as an argument to __call__.\n\t        Arguments:\n\t            current_user (User): Get the current user from the auth_service\n\t            request (Request): Get the request object\n\t        Returns:\n\t            The decorated function\n\t        \"\"\"\n\t        if current_user.role not in self.allowed_roles:\n", "            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail='Operation forbidden')"]}
{"filename": "src/services/tags.py", "chunked_list": ["from typing import List\n\tfrom src.database.models import Tag\n\tdef create_transformation_tags(tags: List[Tag]) -> str:\n\t    \"\"\"\n\t    create tag for transformation operations\n\t    Arguments:\n\t        tags (List[Tag]): list tag objects for write tag strings\n\t    Returns:\n\t        List[Tag]: tag strings for new image\n\t    \"\"\"\n", "    tags_in_text = f\"#\"\n\t    for tag in tags:\n\t        tags_in_text += tag.tag_name\n\t    return tags_in_text\n"]}
{"filename": "src/conf/config.py", "chunked_list": ["from pydantic import BaseSettings\n\tclass Settings(BaseSettings):\n\t    sqlalchemy_database_url: str = 'postgresql+psycopg2://user:password@server:5432/database'\n\t    secret_key: str = 'secret'\n\t    algorithm: str = 'HS256'\n\t    cloudinary_name: str = 'name'\n\t    cloudinary_api_key: str = 'key'\n\t    cloudinary_api_secret: str = 'secret'\n\t    class Config:\n\t        env_file = \".env\"\n", "        env_file_encoding = \"utf-8\"\n\tsettings = Settings()\n"]}
{"filename": "src/routes/images.py", "chunked_list": ["from typing import List\n\tfrom fastapi import Depends, HTTPException, status, Path, APIRouter, Query, UploadFile, File, Form\n\tfrom sqlalchemy.orm import Session\n\tfrom starlette.responses import StreamingResponse\n\tfrom pydantic import ValidationError\n\tfrom src.database.db import get_db\n\tfrom src.database.models import User, UserRole\n\tfrom src.schemas.images import ImageModel, ImageResponse, ImageTransformationModel\n\tfrom src.repository import images as repository_images\n\tfrom src.services.cloud_image import CloudImage\n", "from src.services.auth import auth_service\n\tfrom src.services.roles import RoleAccess\n\tfrom src.services.tags import create_transformation_tags\n\trouter = APIRouter(prefix=\"/images\", tags=['images'])\n\tallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_patch = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\n\tallowed_operation_delete = RoleAccess([UserRole.Admin])\n\t@router.post(\"/\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_post)],\n", "             status_code=status.HTTP_201_CREATED)\n\tasync def create_image(description: str = Form(),\n\t                       tags_text: str = Form(None),\n\t                       image_file: UploadFile = File(),\n\t                       current_user: User = Depends(auth_service.get_current_user),\n\t                       db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The create_image function creates a new image in the database.\n\t    Arguments:\n\t        description (str): Get the description from the request body\n", "        tags_text (str): Get the tags from the request body\n\t        image_file (UploadFile): Get the file from the request\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image: the Image object\n\t    \"\"\"\n\t    try:\n\t        body = ImageModel(description=description, tags_text=tags_text)\n\t    except ValidationError:\n", "        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=\"UNPROCESSABLE_ENTITY\")\n\t    file_name = CloudImage.generate_name_image()\n\t    CloudImage.upload(image_file.file, file_name, overwrite=False)\n\t    image_url = CloudImage.get_url_for_image(file_name)\n\t    image = await repository_images.create(body, image_url, current_user, db)\n\t    return image\n\t@router.post(\"/transformation\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_post)],\n\t             status_code=status.HTTP_201_CREATED)\n\tasync def create_transformation_image(body: ImageTransformationModel,\n\t                                      current_user: User = Depends(auth_service.get_current_user),\n", "                                      db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The create_transformation_image function creates a new image in the database.\n\t        The function takes an ImageTransformationModel object as input, which contains the id of the original image and\n\t        transformation to be applied on it. It then uses CloudImage class to get a url for transformed image\n\t        from cloudinary, checks if there is already an entry with that url in database and if not creates one.\n\t        Input examples ->\"standard\" or \"radius\" or \"grayscale\" or \"cartoonify\" or \"vectorize\".\n\t    Arguments:\n\t        body (ImageTransformationModel): Get the id of the image that is to be transformed\n\t        current_user (User): the current user\n", "        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image: new image with the transformation applied\n\t    \"\"\"\n\t    image = await repository_images.get_image_from_id(body.id, current_user, db)\n\t    if not image:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    transformation_image_url = CloudImage.get_transformation_image(image.image_url, body.transformation)\n\t    tags_in_text = None\n\t    if len(image.tags) > 0:\n", "        tags_in_text = create_transformation_tags(image.tags)\n\t    body = ImageModel(description=image.description, tags_text=tags_in_text)\n\t    image_in_db = await repository_images.get_image_from_url(transformation_image_url, current_user, db)\n\t    if image_in_db:\n\t        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"Resource already exists\")\n\t    new_image = await repository_images.create(body, transformation_image_url, current_user, db)\n\t    return new_image\n\t@router.get(\"/\", response_model=List[ImageResponse], dependencies=[Depends(allowed_operation_get)])\n\tasync def get_images(limit: int = Query(10, le=50), offset: int = 0,\n\t                     current_user: User = Depends(auth_service.get_current_user),\n", "                     db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The get_images function returns a list of images.\n\t    Arguments:\n\t        limit (int): Limit the number of images returned\n\t        offset (int): Specify the number of records to skip before returning results\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Image]: A list of images\n", "    \"\"\"\n\t    images = await repository_images.get_images(limit, offset, current_user, db)\n\t    if images is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    return images\n\t@router.get(\"/{image_id}\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_get)])\n\tasync def get_image(image_id: int = Path(ge=1),\n\t                    current_user: User = Depends(auth_service.get_current_user),\n\t                    db: Session = Depends(get_db)):\n\t    \"\"\"\n", "    The get_images function is a GET request that returns the image with the given ID.\n\t    The function takes an optional image_id parameter, which defaults to 1 if not provided.\n\t    It also takes a current_user parameter, which is obtained from auth_service and db parameters,\n\t    which are obtained from get_db.\n\t    Arguments:\n\t        image_id (int): Specify the id of the image that is being requested\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image: image\n", "    \"\"\"\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    return image\n\t@router.delete(\"/{image_id}\", status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(allowed_operation_delete)])\n\tasync def remove_image(image_id: int = Path(ge=1),\n\t                       current_user: User = Depends(auth_service.get_current_user),\n\t                       db: Session = Depends(get_db)):\n\t    \"\"\"\n", "    The remove_image function removes an image from the database.\n\t    Arguments:\n\t        image_id (int): Specify the id of the image to be removed\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        None: The image that was removed\n\t    \"\"\"\n\t    image = await repository_images.remove(image_id, current_user, db)\n\t    if image is None:\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    return None\n\t@router.patch(\"/description/{image_id}\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_patch)])\n\tasync def update_description_image(body: ImageModel,\n\t                                   image_id: int = Path(ge=1),\n\t                                   current_user: User = Depends(auth_service.get_current_user),\n\t                                   db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The update_description_image function updates the description of an image.\n\t        The function takes in a body, which is an ImageModel object, and an image_id.\n", "        It also takes in a current_user and db objects as dependencies.\n\t    Arguments:\n\t        body (ImageModel): Get the new description for the image\n\t        image_id (int): Get the image id from the path\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Image: The updated image\n\t    \"\"\"\n\t    image = await repository_images.change_description(body, image_id, current_user, db)\n", "    if image is None or image.is_deleted is True:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    return image\n\t@router.post(\"/generate_qrcode/{image_id}\", dependencies=[Depends(allowed_operation_post)])\n\tasync def generate_qrcode(image_id: int = Path(ge=1),\n\t                          current_user: User = Depends(auth_service.get_current_user),\n\t                          db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The generate_qrcode function generates a QR code for the image with the given ID.\n\t    Arguments:\n", "        image_id (int): Get the image id from the path\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        image/png: streamingresponse\n\t    \"\"\"\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    qr_code = await CloudImage.create_qr_code_image(image.image_url)\n", "    if qr_code is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\t    return StreamingResponse(qr_code, media_type=\"image/png\", status_code=status.HTTP_201_CREATED)\n"]}
{"filename": "src/routes/ratings.py", "chunked_list": ["from typing import List\n\tfrom fastapi import APIRouter, Depends, Path, status, HTTPException\n\tfrom src.database.models import User, UserRole\n\tfrom src.repository import ratings as repository_ratings\n\tfrom src.schemas.ratings import RatingResponse, AverageRatingResponse\n\tfrom src.schemas.images import ImageResponse\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.db import get_db\n\tfrom src.services.auth import auth_service\n\tfrom src.services.roles import RoleAccess\n", "router = APIRouter(prefix='/rating', tags=['ratings'])\n\tallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\n\tallowed_operation_delete = RoleAccess([UserRole.Admin, UserRole.Moderator])\n\t@router.post(\"/{image_id}/{rate}\", response_model=RatingResponse, dependencies=[Depends(allowed_operation_post)])\n\tasync def create_rate(image_id: int, rate: int = Path(description=\"From one to five stars of rating.\", ge=1, le=5),\n\t                      db: Session = Depends(get_db), current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    The create_rate function creates a new rate for the image with the given ID. The function takes in an integer\n", "    value from 1 to 5, and returns a JSON object containing information about the newly created rate.\n\t    Arguments:\n\t        image_id (int): rate id to be rated.\n\t        rate (int): value from 1 to 5\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Rate: The new rate object\n\t    \"\"\"\n\t    new_rate = await repository_ratings.create_rate(image_id, rate, db, current_user)\n", "    if new_rate is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not found\")\n\t    return new_rate\n\t@router.delete(\"/delete/{rate_id}\", status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(allowed_operation_delete)])\n\tasync def delete_rate(rate_id: int, db: Session = Depends(get_db),\n\t                      current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    The delete_rate function deletes a rate from the database.\n\t        The function takes in an integer, which is the id of the rate to be deleted.\n\t        It also takes in a Session object and a User object as parameters,\n", "        which are used to access and delete data from the database.\n\t    Arguments:\n\t        rate_id (int): rate id to be removed\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        None\n\t    \"\"\"\n\t    deleted_rate = await repository_ratings.delete_rate(rate_id, db, current_user)\n\t    if deleted_rate is None:\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Rate not found or not available.\")\n\t    return deleted_rate\n\t@router.get(\"/show_image_rating/{image_id}\", response_model=AverageRatingResponse)\n\tasync def calculate_rating(image_id: int, db: Session = Depends(get_db),\n\t                           current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    The calculate_rating function calculate an average rating of the image.\n\t        The function takes in an integer, which is the id of the image.\n\t        It also takes in a Session object and a User object as parameters,\n\t        which are used to access data from the database.\n", "    Arguments:\n\t        image_id (int): Get the image_id from the url\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        dict: An average rating object\n\t    \"\"\"\n\t    average_rate = await repository_ratings.calculate_rating(image_id, db, current_user)\n\t    if average_rate is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Rating not found or not available.\")\n", "    return {\"average_rating\": average_rate}\n\t@router.get(\"/show_images_by_rating\", response_model=List[ImageResponse])\n\tasync def show_images_by_rating(to_decrease: bool, db: Session = Depends(get_db),\n\t                            current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    The show_images_by_rating function show all images, sorted by rating.\n\t        The function takes a boolean value that indicates the direction of sorting, \n\t        to increase the rating or to decrease it.\n\t        It also takes in a Session object and a User object as parameters,\n\t        which are used to access data from the database.\n", "    Arguments:\n\t        to_decrease (bool): Indicates the direction of sorting.\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Image]: A list of Images objects, sorted by rating\n\t    \"\"\"\n\t    images_by_rating = await repository_ratings.show_images_by_rating(to_decrease, db, current_user)\n\t    if images_by_rating is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Images not found or not available.\")\n", "    return images_by_rating\n"]}
{"filename": "src/routes/auth.py", "chunked_list": ["from fastapi import Depends, HTTPException, status, APIRouter, Security, Request\n\tfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer, OAuth2PasswordRequestForm\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.db import get_db\n\tfrom src.schemas.users import UserModel, UserResponse, TokenModel\n\tfrom src.repository import users as repository_users\n\tfrom src.services.auth import auth_service\n\trouter = APIRouter(prefix=\"/auth\", tags=['auth'])\n\tsecurity = HTTPBearer()\n\t@router.post(\"/signup\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\n", "async def signup(body: UserModel, request: Request, db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The signup function creates a new user in the database.\n\t        It takes a UserModel object as input, which is validated by pydantic.\n\t        The password is hashed using bcrypt and stored in the database.\n\t        A background task sends an email to the user with their username.\n\t    Arguments:\n\t        body (UserModel): Pass the data from the request body to the function\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        request (Request): Get the base_url of the application\n", "    Returns:\n\t        User: The created user\n\t    \"\"\"\n\t    exist_user = await repository_users.get_user_by_email(body.email, db)\n\t    if exist_user:\n\t        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"Account already exists\")\n\t    body.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n\t    new_user = await repository_users.create_user(body, db)\n\t    return new_user\n\t@router.post(\"/login\", response_model=TokenModel)\n", "async def login(body: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The login function is used to authenticate a user.\n\t        It takes the username and password from the request body,\n\t        verifies them against the database, and returns an access token if successful.\n\t    Arguments:\n\t        body (OAuth2PasswordRequestForm): Get the token from the request header\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        dict: JSON access_token / refresh_token / token_type\n", "    \"\"\"\n\t    user = await repository_users.get_user_by_email(body.username, db)\n\t    if user is None:\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid email\")\n\t    if not user.is_active:\n\t        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User is inactive\")\n\t    if not auth_service.pwd_context.verify(body.password, user.password_checksum):\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid password\")\n\t    # Generate JWT\n\t    access_token = await auth_service.create_access_token(data={\"sub\": user.email})\n", "    refresh_token = await auth_service.create_refresh_token(data={\"sub\": user.email})\n\t    await repository_users.update_token(user, refresh_token, db)\n\t    return {\"access_token\": access_token, \"refresh_token\": refresh_token, \"token_type\": \"bearer\"}\n\t@router.post(\"/logout\")\n\tasync def logout(credentials: HTTPAuthorizationCredentials = Security(security),\n\t                 db: Session = Depends(get_db),\n\t                 current_user: UserModel = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    The logout function is used to logout a user.\n\t    It takes the credentials,\n", "    add access token to blacklist, and returns massage.\n\t    Arguments:\n\t        credentials (HTTPAuthorizationCredentials): Get the token from the request header\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        current_user (UserModel): the current user\n\t    Returns:\n\t        dict: JSON message\n\t    \"\"\"\n\t    token = credentials.credentials\n\t    await repository_users.add_to_blacklist(token, db)\n", "    return {\"message\": \"USER_IS_LOGOUT\"}\n\t@router.get('/refresh_token', response_model=TokenModel)\n\tasync def refresh_token(credentials: HTTPAuthorizationCredentials = Security(security), db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The refresh_token function is used to refresh the access token.\n\t        The function takes in a refresh token and returns an access_token, a new refresh_token, and the type of token.\n\t        If the user's current refresh_token does not match what was\n\t            passed into this function then it will return an error.\n\t    Arguments:\n\t        credentials (HTTPAuthorizationCredentials): Get the token from the request header\n", "        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        dict: JSON access_token - refresh_token - token_type\n\t    \"\"\"\n\t    token = credentials.credentials\n\t    email = await auth_service.decode_refresh_token(token)\n\t    user = await repository_users.get_user_by_email(email, db)\n\t    if user.refresh_token != token:\n\t        await repository_users.update_token(user, None, db)\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid refresh token\")\n", "    access_token = await auth_service.create_access_token(data={\"sub\": email})\n\t    refresh_token = await auth_service.create_refresh_token(data={\"sub\": email})\n\t    await repository_users.update_token(user, refresh_token, db)\n\t    return {\"access_token\": access_token, \"refresh_token\": refresh_token, \"token_type\": \"bearer\"}\n"]}
{"filename": "src/routes/users.py", "chunked_list": ["from fastapi import APIRouter, Depends, status, UploadFile, File, HTTPException\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.db import get_db\n\tfrom src.database.models import User, UserRole, BlacklistToken\n\tfrom src.repository import users as repository_users\n\tfrom src.services.auth import auth_service\n\tfrom src.schemas.users import UserResponse, UserChangeRole, UserUpdate, UserUpdateAdmin, UserShow\n\tfrom src.services.cloud_image import CloudImage\n\tfrom src.services.roles import RoleAccess\n\trouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n", "allowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\n\tallowed_operation_delete = RoleAccess([UserRole.Admin])\n\t@router.get(\"/me/\", response_model=UserResponse)\n\tasync def read_users_me(current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    The read_users_me function is a GET request that returns the current user's information.\n\t        It requires authentication, and it uses the auth_service to get the current user.\n\t    Arguments:\n", "        current_user (User): the current user attempting to delete the comment\n\t    Returns:\n\t        User: The current user object\n\t    \"\"\"\n\t    return current_user\n\t@router.patch('/avatar', response_model=UserResponse)\n\tasync def update_avatar_user(file: UploadFile = File(), current_user: User = Depends(auth_service.get_current_user),\n\t                             db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    The update_avatar_user function updates the avatar of a user.\n", "    Arguments:\n\t        file (UploadFile): object with new role\n\t        current_user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User: object after the change operation\n\t    \"\"\"\n\t    public_id = CloudImage.generate_name_avatar(current_user.email)\n\t    r = CloudImage.upload(file.file, public_id)\n\t    src_url = CloudImage.get_url_for_avatar(public_id, r)\n", "    user = await repository_users.update_avatar(current_user.email, src_url, db)\n\t    return user\n\t@router.put(\"/update_user\", response_model=UserUpdate)\n\tasync def update_user(\n\t        body: UserUpdate,\n\t        user: User = Depends(auth_service.get_current_user),\n\t        db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    Update user\n\t    Arguments:\n", "        body (UserUpdate): object with new role\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User: object after the change operation\n\t    \"\"\"\n\t    user = await repository_users.update_user(body, user, db)\n\t    if user is None:\n\t        raise HTTPException(\n\t            status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n", "    return user\n\t@router.put(\"/update_user_by_admin\", response_model=UserUpdateAdmin, dependencies=[Depends(allowed_operation_put)])\n\tasync def update_user_by_admin(\n\t        body: UserUpdateAdmin,\n\t        user: User = Depends(auth_service.get_current_user),\n\t        db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    Update user just for admin access\n\t    Arguments:\n\t        body (UserUpdateAdmin): object with new role\n", "        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User: object after the change operation\n\t    \"\"\"\n\t    user = await repository_users.update_user_by_admin(body, user, db)\n\t    if user is None:\n\t        raise HTTPException(\n\t            status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n\t    return user\n", "@router.put(\"/change_role\", response_model=UserChangeRole, dependencies=[Depends(allowed_operation_put)])\n\tasync def change_role(body: UserChangeRole,\n\t                      user: User = Depends(auth_service.get_current_user),\n\t                      db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    Change the role of a user\n\t    Arguments:\n\t        body (UserChangeRole): object with new role\n\t        user (User): the current user\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        User: object after the change operation\n\t    \"\"\"\n\t    user = await repository_users.change_role(body, user, db)\n\t    if user is None:\n\t        raise HTTPException(\n\t            status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n\t    return user\n\t@router.put(\"/ban_user\", response_model=UserResponse, dependencies=[Depends(allowed_operation_put)])\n\tasync def ban_user(user_id: int, db: Session = Depends(get_db)):\n", "    \"\"\"\n\t    Take user to ban list\n\t    Arguments:\n\t        user_id (int): Get the username from the url path\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        User: banned user\n\t    \"\"\"\n\t    ban = await repository_users.ban_user(user_id, db)\n\t    if ban is None:\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n\t    return ban\n\t@router.get(\"/user/{login}\", response_model=UserShow)\n\tasync def read_user_profile_by_username(login: str, db: Session = Depends(get_db),\n\t                                        current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    The function takes in the login as an argument and returns the user profile if it exists.\n\t    Arguments:\n\t        login (str): Get the username from the url path\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "        current_user (User): the current user\n\t    Returns:\n\t        User: A userprofile object\n\t    \"\"\"\n\t    user_profile = await repository_users.get_user_profile(login, db)\n\t    if user_profile is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n\t    return user_profile\n"]}
{"filename": "src/routes/tags.py", "chunked_list": ["from typing import List\n\tfrom fastapi import APIRouter, Depends, status, HTTPException, Path\n\tfrom src.database.models import UserRole\n\tfrom src.repository import tags as repository_tag\n\tfrom src.schemas.tags import TagResponse, TagModel\n\tfrom src.schemas.images import ImageResponse\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.db import get_db\n\tfrom src.services.roles import RoleAccess\n\trouter = APIRouter(prefix='/tag', tags=['tags'])\n", "allowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\n\tallowed_operation_delete = RoleAccess([UserRole.Admin])\n\t@router.post(\"/{tags_string}\", response_model=List[TagResponse], dependencies=[Depends(allowed_operation_post)],\n\t             status_code=status.HTTP_201_CREATED)\n\tasync def create_tags(tags_string: str, db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    create new tag from string find # and separated by spaces\n\t    Arguments:\n", "        tags_string (str): string to parse\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Tag]: new tags list\n\t    \"\"\"\n\t    tag = await repository_tag.create_tags(tags_string, db)\n\t    return tag\n\t@router.get(\"/image/{tag_name}\", response_model=List[ImageResponse], dependencies=[Depends(allowed_operation_get)])\n\tasync def get_images_by_tag(tag_name: str, limit: int = 10, offset: int = 0, db: Session = Depends(get_db)):\n\t    \"\"\"\n", "    route to get images by tag name\n\t    Arguments:\n\t        offset (int): number of tags to skip in the search\n\t        limit (int): maximum number of tags to retrieve\n\t        tag_name (str): tag name to found\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Image] | None: a list of Image or None if no matching tag were found\n\t    \"\"\"\n\t    tag = await repository_tag.get_images_by_tag(tag_name, limit, offset, db)\n", "    if tag is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n\t    return tag\n\t@router.get(\"/{tag_name}\", response_model=TagResponse, dependencies=[Depends(allowed_operation_get)])\n\tasync def get_one(tag_name: str, db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    route to get tag object by tag name\n\t    Arguments:\n\t        tag_name (str): tag name to found\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        Tag | None: Tag or None if no matching tag were found\n\t    \"\"\"\n\t    tag = await repository_tag.find_tag(tag_name, db)\n\t    if tag is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n\t    return tag\n\t@router.put(\"/{tag_id}\", response_model=TagResponse, dependencies=[Depends(allowed_operation_put)])\n\tasync def update_tag(body: TagModel, tag_id: int = Path(ge=1), db: Session = Depends(get_db)):\n\t    \"\"\"\n", "    The update_tag function updates a tag in the database.\n\t        The function takes an id and a body as input, and returns the updated tag.\n\t        If no tag is found with that id, it raises an HTTP 404 error.\n\t    Arguments:\n\t        body (TagModel): all need field to update\n\t        tag_id (int): Find the tag to be deleted\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        Tag | None: Tag or None if no matching tag were found\n\t    \"\"\"\n", "    tag = await repository_tag.find_tag_by_id(tag_id, db)\n\t    if tag is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n\t    edit_tag = await repository_tag.edit_tag(tag, body, db)\n\t    return edit_tag\n\t@router.delete(\"/{tag_name}\", dependencies=[Depends(allowed_operation_delete)], status_code=status.HTTP_204_NO_CONTENT)\n\tasync def delete(tag_name: str, db: Session = Depends(get_db)):\n\t    \"\"\"\n\t    route to delete tag finded by name\n\t    Arguments:\n", "        tag_name (str): tag name to found\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        None\n\t    \"\"\"\n\t    tag = await repository_tag.delete_tag(tag_name, db)\n\t    if tag is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n\t    return None\n"]}
{"filename": "src/routes/comments.py", "chunked_list": ["from typing import List\n\tfrom fastapi import APIRouter, Depends, HTTPException, status\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.db import get_db\n\tfrom src.database.models import User, UserRole\n\tfrom src.repository.comments import create_comment, edit_comment, delete_comment, get_all_user_comments, \\\n\t    get_comments_by_image_id\n\tfrom src.schemas.comments import CommentBase, CommentResponse\n\tfrom src.services.auth import auth_service\n\tfrom src.services.roles import RoleAccess\n", "router = APIRouter(prefix='/comments', tags=[\"comments\"])\n\tallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\n\tallowed_operation_delete = RoleAccess([UserRole.Admin])\n\t@router.post('/{image_id}', response_model=CommentResponse, dependencies=[Depends(allowed_operation_post)])\n\tasync def post_comment(image_id: int,\n\t                       body: CommentBase,\n\t                       db: Session = Depends(get_db),\n\t                       current_user: User = Depends(auth_service.get_current_user)):\n", "    \"\"\"\n\t    Creates a new comment for an image.\n\t    Arguments:\n\t        image_id (int): ID of the image that the comment is being made on\n\t        body (CommentBase): Pass the comment_text from the request body to the function\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        current_user (User): the current user attempting to delete the comment\n\t    Returns:\n\t        Comment: the Comment object\n\t    \"\"\"\n", "    comment = await create_comment(image_id, body, db, current_user)\n\t    return comment\n\t@router.put('/{comment_id}', response_model=CommentResponse, dependencies=[Depends(allowed_operation_put)])\n\tasync def update_comment(comment_id: int,\n\t                         body: CommentBase,\n\t                         db: Session = Depends(get_db),\n\t                         current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    Modifies the specified comment in the database, if the current user has permission to do so.\n\t    If comment with requested id does not exist raise HTTPException with status HTTP_404_NOT_FOUND\n", "    Arguments:\n\t        comment_id (int): ID of the comment to be deleted\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        body (CommentBase): Pass the comment_text from the request body to the function\n\t        current_user (User): the current user attempting to edite the comment\n\t    Returns:\n\t        Comment: the Comment object representing the modified comment,\n\t    \"\"\"\n\t    updated_comment = await edit_comment(comment_id, body, db, current_user)\n\t    if not updated_comment:\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n\t    return updated_comment\n\t@router.delete('/{comment_id}', status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(allowed_operation_delete)])\n\tasync def remove_comment(comment_id: int,\n\t                         db: Session = Depends(get_db),\n\t                         current_user: User = Depends(auth_service.get_current_user)):\n\t    \"\"\"\n\t    Deletes the specified comment from the database, if the current user has permission to do so.\n\t    If comment with requested id does not exist raise HTTPException with status HTTP_404_NOT_FOUND\n\t    Arguments:\n", "        comment_id (int): ID of the comment to be deleted\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t        current_user (User): the current user attempting to delete the comment\n\t    Returns:\n\t        None: If comment was success delete\n\t        \"\"\"\n\t    deleted_comment = await delete_comment(comment_id, db, current_user)\n\t    if not deleted_comment:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n\t    return None\n", "@router.get('/user/{user_id}', response_model=List[CommentResponse], dependencies=[Depends(allowed_operation_get)])\n\tasync def show_user_comments(user_id: int,\n\t                             db: Session = Depends(get_db),\n\t                             skip: int = 0,\n\t                             limit: int = 10):\n\t    \"\"\"\n\t    Gets a list of comments made by the specified user.\n\t    Arguments:\n\t        skip (int): number of comments to skip in the search\n\t        limit (int): maximum number of comments to retrieve\n", "        user_id (int): ID of the user to retrieve comments for\n\t        db (Session): SQLAlchemy session object for accessing the database\n\t    Returns:\n\t        List[Comment] | None: a list of Comment objects representing the user's comments,\n\t        or None if no matching comments were found\n\t    \"\"\"\n\t    comments = await get_all_user_comments(skip, limit, user_id, db)\n\t    return comments\n\t@router.get('/image/{image_id}', response_model=List[CommentResponse], dependencies=[Depends(allowed_operation_get)])\n\tasync def show_comments(image_id: int,\n", "                        db: Session = Depends(get_db),\n\t                        skip: int = 0,\n\t                        limit: int = 10):\n\t    \"\"\"\n\t    Gets all comments of the specified image from the database.\n\t    Arguments:\n\t        skip (int): number of comments to skip in the search\n\t        limit (int): maximum number of comments to retrieve\n\t        image_id (int): ID of the image to retrieve comments for\n\t        db (Session): SQLAlchemy session object for accessing the database\n", "    Returns:\n\t        List[Comment] | None: a list of Comment objects representing all comments,\n\t        or None if no matching comments were found\n\t    \"\"\"\n\t    comments = await get_comments_by_image_id(skip, limit, image_id, db)\n\t    return comments\n"]}
