{"filename": "laser_tag/__main__.py", "chunked_list": ["import pygame\n\tfrom pygame.locals import *\n\tfrom laser_tag.configuration import VARIABLES, WINDOW_WINDOWED_SIZE_RATIO\n\tfrom laser_tag.events.Event import Event\n\tfrom laser_tag.events.get_events import *\n\tfrom laser_tag.game.Game import Game\n\tfrom laser_tag.graphics import display\n\tfrom laser_tag.graphics.Renderer import Renderer\n\tfrom laser_tag.graphics.resize import resize\n\tfrom laser_tag.network.Client import Client\n", "from laser_tag.network.Server import Server\n\tif __name__ == \"__main__\":\n\t    pygame.init()\n\t    game = Game()\n\t    clock = pygame.time.Clock()\n\t    renderer = Renderer(clock)\n\t    # Local server\n\t    server = Server(0, debug=True)\n\t    server.start()\n\t    client = Client(\"localhost\", server.get_port())\n", "    running = True\n\t    while running:\n\t        clock.tick(VARIABLES.fps)\n\t        # Events\n\t        events = get_events()\n\t        # Enhance events\n\t        game.enhance_events(events)\n\t        # Process events\n\t        for event in events:\n\t            match event.id:\n", "                case Event.WINDOW_QUIT:\n\t                    running = False\n\t                    break\n\t                case Event.KEY_ESCAPE_PRESS:\n\t                    running = False\n\t                case Event.WINDOW_FULLSCREEN:\n\t                    VARIABLES.fullscreen = not VARIABLES.fullscreen\n\t                    if VARIABLES.fullscreen:\n\t                        VARIABLES.set_screen_size(\n\t                            VARIABLES.full_screen_width, VARIABLES.full_screen_height\n", "                        )\n\t                    else:\n\t                        VARIABLES.set_screen_size(\n\t                            int(VARIABLES.screen_width * WINDOW_WINDOWED_SIZE_RATIO),\n\t                            int(VARIABLES.screen_height * WINDOW_WINDOWED_SIZE_RATIO),\n\t                        )\n\t                    display.refresh_display()\n\t                    renderer.resize()\n\t                case Event.WINDOW_RESIZE:\n\t                    if not VARIABLES.fullscreen:\n", "                        VARIABLES.set_screen_size(event.data[0], event.data[1])\n\t                        display.refresh_display()\n\t                        renderer.resize()\n\t                case Event.SCREENSHOT:\n\t                    display.screenshot()\n\t                case Event.GAME_ROTATE:\n\t                    # Center mouse cursor\n\t                    pygame.mouse.set_pos(resize(960, \"x\"), resize(540, \"y\"))\n\t        # Predict\n\t        game.update(events)\n", "        # Send\n\t        client.add_events_to_send([event for event in events if not event.local])\n\t        # Receive\n\t        if client.is_connected():\n\t            received_data = client.get_received_data()\n\t            for state in received_data:\n\t                game.set_state(state)\n\t        # Display\n\t        network_stats = client.get_network_stats()\n\t        renderer.set_network_stats(\n", "            network_stats[0], network_stats[1], network_stats[2], network_stats[3]\n\t        )\n\t        renderer.render(game)\n\t        pygame.display.flip()\n\t    pygame.quit()\n\t    client.disconnect()\n\t    server.stop()\n"]}
{"filename": "laser_tag/__init__.py", "chunked_list": []}
{"filename": "laser_tag/graphics/resize.py", "chunked_list": ["from ..configuration import VARIABLES\n\tdef resize(size_1080p: float, x_y=\"y\") -> float:\n\t    if x_y == \"x\":\n\t        return size_1080p * VARIABLES.screen_width / 1920\n\t    return size_1080p * VARIABLES.screen_height / 1080\n"]}
{"filename": "laser_tag/graphics/Renderer.py", "chunked_list": ["import pygame\n\tfrom ..configuration import VARIABLES\n\tfrom ..game.Game import Game\n\tfrom . import display\n\tfrom .components.Fps import Fps\n\tfrom .components.GameTimer import GameTimer\n\tfrom .components.Leaderboard import Leaderboard\n\tfrom .components.Minimap import Minimap\n\tfrom .components.NetworkStats import NetworkStats\n\tfrom .components.Scoreboard import Scoreboard\n", "from .components.World import World\n\tfrom .resize import resize\n\tclass Renderer:\n\t    def __init__(self, clock: pygame.time.Clock):\n\t        self.clock = clock\n\t        # Load resources\n\t        self.fps = Fps()\n\t        self.minimap = Minimap()\n\t        self.network_stats = NetworkStats()\n\t        self.leaderboard = Leaderboard()\n", "        self.scoreboard = Scoreboard()\n\t        self.game_timer = GameTimer()\n\t        self.world = World()\n\t        self.components = [\n\t            self.fps,\n\t            self.minimap,\n\t            self.network_stats,\n\t            self.leaderboard,\n\t            self.scoreboard,\n\t            self.game_timer,\n", "            self.world,\n\t        ]\n\t    def set_network_stats(\n\t        self,\n\t        pings: list[float],\n\t        connected: bool,\n\t        bytes_sent: list[int],\n\t        bytes_received: list[int],\n\t    ):\n\t        if VARIABLES.show_network_stats:\n", "            self.network_stats.update(pings, connected, bytes_sent, bytes_received)\n\t    def resize(self):\n\t        for component in self.components:\n\t            component.resize()\n\t    def render(self, game: Game):\n\t        # Update display\n\t        rays = game.world.cast_rays()\n\t        self.world.update(\n\t            rays,\n\t            game.world.entities.values(),\n", "            game.world.get_entity(game.world.controlled_entity),\n\t        )\n\t        display.screen.blit(self.world.get(), (0, 0))\n\t        self.minimap.update(game.world.map.map, game.world.entities.values(), rays)\n\t        display.screen.blit(self.minimap.get(), (resize(10, \"x\"), resize(10, \"y\")))\n\t        self.leaderboard.update(game.game_mode.leaderboard)\n\t        display.screen.blit(\n\t            self.leaderboard.get(),\n\t            (\n\t                resize(420, \"x\"),\n", "                resize(10, \"y\"),\n\t            ),\n\t        )\n\t        network_stats_width = 0\n\t        if VARIABLES.show_network_stats:\n\t            network_stats_surface = self.network_stats.get()\n\t            network_stats_width = network_stats_surface.get_width()\n\t            display.screen.blit(\n\t                network_stats_surface,\n\t                (\n", "                    resize(1910, \"x\") - network_stats_surface.get_width(),\n\t                    resize(10, \"y\"),\n\t                ),\n\t            )\n\t        if game.show_scoreboard:\n\t            self.scoreboard.update(list(game.world.entities.values()))\n\t            scoreboard = self.scoreboard.get()\n\t            display.screen.blit(\n\t                scoreboard,\n\t                (\n", "                    resize(960, \"x\") - scoreboard.get_width() / 2,\n\t                    resize(540, \"y\") - scoreboard.get_height() / 2,\n\t                ),\n\t            )\n\t        self.game_timer.update(\n\t            game.game_mode.grace_period_seconds,\n\t            game.game_mode.grace_period_end,\n\t            game.game_mode.game_time_seconds,\n\t            game.game_mode.game_time_end,\n\t        )\n", "        game_timer = self.game_timer.get()\n\t        display.screen.blit(\n\t            game_timer,\n\t            (\n\t                resize(1910, \"x\")\n\t                - game_timer.get_width()\n\t                - (\n\t                    network_stats_width + resize(10, \"x\")\n\t                    if network_stats_width > 0\n\t                    else 0\n", "                ),\n\t                resize(10, \"y\"),\n\t            ),\n\t        )\n\t        if VARIABLES.show_fps:\n\t            self.fps.update(self.clock.get_fps())\n\t            display.screen.blit(self.fps.get(), (resize(10, \"x\"), resize(10, \"y\")))\n"]}
{"filename": "laser_tag/graphics/Display.py", "chunked_list": ["from os import makedirs\n\tfrom time import strftime, time\n\timport pygame\n\tfrom pygame.locals import *\n\tfrom ..configuration import SCREENSHOTS_PATH, VARIABLES\n\tclass Display:\n\t    def __init__(self):\n\t        self.screen: pygame.Surface = None\n\t        self.refresh_display()\n\t    def refresh_display(self):\n", "        self.screen = pygame.display.set_mode(\n\t            (VARIABLES.screen_width, VARIABLES.screen_height),\n\t            FULLSCREEN if VARIABLES.fullscreen else RESIZABLE,\n\t        )\n\t    def screenshot(self):\n\t        makedirs(SCREENSHOTS_PATH, exist_ok=True)\n\t        time_string = strftime(f\"%Y-%m-%d_%H.%M.%S.{int(round(time() * 1000) % 1000)}\")\n\t        screenshot_file_name = f\"{SCREENSHOTS_PATH}/screenshot_{time_string}.png\"\n\t        pygame.image.save(self.screen, screenshot_file_name)\n\t        if VARIABLES.debug:\n", "            print(f\"Screenshot saved: {screenshot_file_name}\")\n"]}
{"filename": "laser_tag/graphics/__init__.py", "chunked_list": ["import pygame\n\tfrom pygame.locals import *\n\tfrom ..configuration import GAME_NAME, VARIABLES, WINDOW_WINDOWED_SIZE_RATIO\n\tfrom .Display import Display\n\tpygame.init()\n\tpygame.display.set_caption(GAME_NAME)\n\t# Set screen size\n\tVARIABLES.set_full_screen_size(\n\t    pygame.display.Info().current_w, pygame.display.Info().current_h\n\t)\n", "if VARIABLES.fullscreen:\n\t    VARIABLES.set_screen_size(VARIABLES.full_screen_width, VARIABLES.full_screen_height)\n\telse:\n\t    # Default window size\n\t    VARIABLES.set_screen_size(\n\t        int(VARIABLES.full_screen_width * WINDOW_WINDOWED_SIZE_RATIO),\n\t        int(VARIABLES.full_screen_height * WINDOW_WINDOWED_SIZE_RATIO),\n\t    )\n\tdisplay = Display()\n"]}
{"filename": "laser_tag/graphics/Text.py", "chunked_list": ["import pygame\n\tfrom ..configuration import VARIABLES\n\tfrom . import display\n\tfrom .resize import resize\n\tclass Text:\n\t    \"\"\"A class for generating text\"\"\"\n\t    __instances = {}\n\t    def __new__(cls, font: str, font_is_file: bool = False, size_multiplier: float = 1):\n\t        id = (font, font_is_file, size_multiplier)\n\t        if not id in cls.__instances:\n", "            cls.__instances[id] = super().__new__(cls)\n\t            cls.__instances[id].reset(font, font_is_file, size_multiplier)\n\t        return cls.__instances[id]\n\t    def reset(self, font: str, font_is_file: bool, size_multiplier: float):\n\t        self.font = font\n\t        self.font_is_file = font_is_file\n\t        self.size_multiplier = size_multiplier\n\t        self.cache = {}\n\t    def create_cache(self, size: float) -> int:\n\t        resized_size = int(resize(size * self.size_multiplier))\n", "        if resized_size not in self.cache:\n\t            if self.font_is_file:\n\t                self.cache[resized_size] = pygame.font.Font(self.font, resized_size)\n\t            else:\n\t                self.cache[resized_size] = pygame.font.SysFont(self.font, resized_size)\n\t        return resized_size\n\t    def clear_cache(self):\n\t        self.cache.clear()\n\t    def generate_text(\n\t        self, text: str, size: int, color=(255, 255, 255)\n", "    ) -> pygame.Surface:\n\t        return self.cache[size].render(str(text), VARIABLES.anti_aliased_text, color)\n\t    def get_size(self, generated_text: pygame.Surface) -> tuple[int, int]:\n\t        return generated_text.get_width(), generated_text.get_height()\n\t    def blit(\n\t        self, generated_text: pygame.Surface, x, y, align_x, align_y\n\t    ) -> tuple[int, int]:\n\t        text_width, text_height = self.get_size(generated_text)\n\t        blit_x, blit_y = resize(x, \"x\"), resize(y, \"y\")\n\t        if align_x == \"center\":\n", "            blit_x -= text_width / 2\n\t        elif align_x == \"right\":\n\t            blit_x -= text_width\n\t        if align_y == \"center\":\n\t            blit_y -= text_height / 2\n\t        elif align_y == \"bottom\":\n\t            blit_y -= text_height\n\t        display.screen.blit(generated_text, (blit_x, blit_y))\n\t        return text_width, text_height\n\t    def text(\n", "        self, text, x, y, size, color=(255, 255, 255), align_x=\"left\", align_y=\"top\"\n\t    ) -> tuple[int, int]:\n\t        return self.blit(self.get_surface(text, size, color), x, y, align_x, align_y)\n\t    def get_surface(self, text, size, color=(255, 255, 255)) -> pygame.Surface:\n\t        resized_size = self.create_cache(size)\n\t        return self.generate_text(text, resized_size, color)\n"]}
{"filename": "laser_tag/graphics/components/Leaderboard.py", "chunked_list": ["import pygame\n\tfrom ...configuration import DEFAULT_FONT\n\tfrom ...game.Team import get_color\n\tfrom ..resize import resize\n\tfrom ..Text import Text\n\tfrom .Component import Component\n\tclass Leaderboard(Component):\n\t    \"\"\"Leaderboard component\"\"\"\n\t    def __init__(\n\t        self,\n", "        data=[],\n\t    ):\n\t        super().__init__()\n\t        self.text = Text(\n\t            DEFAULT_FONT[\"font\"],\n\t            DEFAULT_FONT[\"font_is_file\"],\n\t            DEFAULT_FONT[\"size_multiplier\"],\n\t        )\n\t        self.max_length = 5\n\t        self.set_original_size(250, 50 * self.max_length)\n", "        self.update(data)\n\t    def update(self, leaderboard):\n\t        \"\"\"\n\t        Update the component.\n\t        Parameters:\n\t            leaderboard (list): Leaderboard (value, team, title)\n\t        \"\"\"\n\t        self.data = leaderboard\n\t        super().update()\n\t    def render(self):\n", "        self.surface.fill((255, 255, 255, 64))\n\t        for i in range(min(len(self.data), self.max_length)):\n\t            data = self.data[i]\n\t            # Team color\n\t            pygame.draw.circle(\n\t                self.surface,\n\t                get_color(data[1]),\n\t                (resize(20, \"x\"), resize(i * 50 + 25, \"y\")),\n\t                resize(10),\n\t            )\n", "            # Rank and team name\n\t            self.surface.blit(\n\t                self.text.get_surface(\n\t                    f\"#{i + 1} {data[2]}\",\n\t                    30,\n\t                    (255, 255, 255),\n\t                ),\n\t                (resize(40, \"x\"), resize(i * 50 + 10, \"y\")),\n\t            )\n\t            # Score\n", "            value_text = self.text.get_surface(\n\t                data[0],\n\t                30,\n\t                (255, 255, 255),\n\t            )\n\t            self.surface.blit(\n\t                value_text,\n\t                (\n\t                    self.width - resize(10, \"x\") - value_text.get_width(),\n\t                    resize(i * 50 + 10, \"y\"),\n", "                ),\n\t            )\n\t        super().render()\n"]}
{"filename": "laser_tag/graphics/components/__init__.py", "chunked_list": []}
{"filename": "laser_tag/graphics/components/Minimap.py", "chunked_list": ["from math import ceil\n\timport pygame\n\tfrom ...configuration import VARIABLES\n\tfrom ...entities.GameEntity import GameEntity\n\tfrom ...game.Ray import Ray\n\tfrom ...math.rotations import rotate\n\tfrom ..resize import resize\n\tfrom .Component import Component\n\tclass Minimap(Component):\n\t    \"\"\"Minimap component\"\"\"\n", "    def __init__(self, data={\"world\": [], \"entities\": [], \"rays\": []}):\n\t        super().__init__()\n\t        self.set_original_size(400, 400)\n\t        self.update(data[\"world\"], data[\"entities\"], data[\"rays\"])\n\t    def update(\n\t        self, world: list[list[int]], entities: list[GameEntity], rays: list[Ray] = []\n\t    ):\n\t        \"\"\"\n\t        Update the component.\n\t        Parameters:\n", "            world (grid): Map of the level as a grid\n\t            entities (list): List of entities in the world\n\t            rays (list): List of rays to render (optional)\n\t        \"\"\"\n\t        self.data = {\"world\": world, \"entities\": entities, \"rays\": rays}\n\t        super().update()\n\t    def render(self):\n\t        self.surface.fill((0, 0, 0, 0))\n\t        map_width = 1\n\t        map_height = len(self.data[\"world\"])\n", "        for y in range(map_height):\n\t            map_width = len(self.data[\"world\"][y])\n\t            for x in range(map_width):\n\t                if self.data[\"world\"][y][x] == 1:\n\t                    pygame.draw.rect(\n\t                        self.surface,\n\t                        (0, 0, 0),\n\t                        (\n\t                            x * self.width / map_width,\n\t                            y * self.height / map_height,\n", "                            ceil(self.width / map_width),\n\t                            ceil(self.height / map_height),\n\t                        ),\n\t                    )\n\t        if VARIABLES.show_rays_minimap:\n\t            for ray in self.data[\"rays\"]:\n\t                if ray.hit_point is not None:\n\t                    pygame.draw.line(\n\t                        self.surface,\n\t                        (255, 255, 0),\n", "                        (\n\t                            ray.origin.x * self.width / map_width,\n\t                            ray.origin.y * self.height / map_height,\n\t                        ),\n\t                        (\n\t                            ray.hit_point.x * self.width / map_width,\n\t                            ray.hit_point.y * self.height / map_height,\n\t                        ),\n\t                        max(1, int(resize(3))),\n\t                    )\n", "        for entity in self.data[\"entities\"]:\n\t            pygame.draw.rect(\n\t                self.surface,\n\t                (0, 128, 192),\n\t                (\n\t                    entity.position.x * self.width / map_width\n\t                    - entity.collider.length / 2 * self.width / map_width,\n\t                    entity.position.y * self.height / map_height\n\t                    - entity.collider.width / 2 * self.height / map_height,\n\t                    ceil(entity.collider.length * self.width / map_width),\n", "                    ceil(entity.collider.width * self.height / map_height),\n\t                ),\n\t            )\n\t            facing_direction_position = rotate(0.5, entity.rotation, entity.position)\n\t            pygame.draw.line(\n\t                self.surface,\n\t                (255, 255, 255),\n\t                (\n\t                    entity.position.x * self.width / map_width,\n\t                    entity.position.y * self.height / map_height,\n", "                ),\n\t                (\n\t                    facing_direction_position.x * self.width / map_width,\n\t                    facing_direction_position.y * self.height / map_height,\n\t                ),\n\t                max(1, int(resize(3))),\n\t            )\n\t        super().render()\n"]}
{"filename": "laser_tag/graphics/components/Fps.py", "chunked_list": ["from ...configuration import DEFAULT_FONT\n\tfrom ..Text import Text\n\tfrom .Component import Component\n\tclass Fps(Component):\n\t    \"\"\"FPS component\"\"\"\n\t    def __init__(self, data=0):\n\t        super().__init__()\n\t        self.text = Text(\n\t            DEFAULT_FONT[\"font\"],\n\t            DEFAULT_FONT[\"font_is_file\"],\n", "            DEFAULT_FONT[\"size_multiplier\"],\n\t        )\n\t        self.update(data)\n\t    def update(self, fps: float):\n\t        \"\"\"\n\t        Update the component.\n\t        Parameters:\n\t            fps (float): FPS\n\t        \"\"\"\n\t        self.data = fps\n", "        super().update()\n\t    def render(self):\n\t        self.surface = self.text.get_surface(\n\t            \"FPS: \" + str(round(self.data, 2)), 40, (255, 255, 255)\n\t        )\n\t        super().render()\n"]}
{"filename": "laser_tag/graphics/components/World.py", "chunked_list": ["from math import cos\n\timport pygame\n\tfrom ...configuration import VARIABLES\n\tfrom ...entities.GameEntity import GameEntity\n\tfrom ...game.Ray import Ray\n\tfrom ...math.degrees_radians import degrees_to_radians\n\tfrom ..resize import resize\n\tfrom .Component import Component\n\tclass World(Component):\n\t    \"\"\"World component\"\"\"\n", "    def __init__(\n\t        self,\n\t        data={\"rays\": [], \"entities\": [], \"current_entity\": None},\n\t    ):\n\t        super().__init__()\n\t        self.set_original_size(1920, 1080)\n\t        self.update(data[\"rays\"], data[\"entities\"], data[\"current_entity\"])\n\t    def update(\n\t        self,\n\t        rays: list[Ray],\n", "        entities: list[GameEntity],\n\t        current_entity: GameEntity = None,\n\t    ):\n\t        \"\"\"\n\t        Update the component.\n\t        Parameters:\n\t            rays (list): List of rays to render\n\t            entities (list): List of entities in the world\n\t            current_entity (GameEntity): The current entity\n\t        \"\"\"\n", "        self.data = {\n\t            \"rays\": rays,\n\t            \"entities\": entities,\n\t            \"current_entity\": current_entity,\n\t        }\n\t        super().update()\n\t    def render(self):\n\t        self.surface.fill((42, 42, 42))\n\t        if len(self.data[\"rays\"]) > 0:\n\t            step = 1920 / len(self.data[\"rays\"])\n", "            for i in range(len(self.data[\"rays\"])):\n\t                ray = self.data[\"rays\"][i]\n\t                ray_world_size = 0\n\t                if ray.distance != 0:\n\t                    if self.data[\"current_entity\"] is not None:\n\t                        # Fix fisheye effect\n\t                        ray_world_size = VARIABLES.world_scale / (\n\t                            ray.distance\n\t                            * cos(\n\t                                degrees_to_radians(\n", "                                    (\n\t                                        self.data[\"current_entity\"].rotation\n\t                                        - ray.direction\n\t                                    )\n\t                                )\n\t                            )\n\t                        )\n\t                    else:\n\t                        ray_world_size = VARIABLES.world_scale / ray.distance\n\t                ray_world_size = min(ray_world_size, 1080)\n", "                color_intensity = 128 / max(1, ray.distance / 3)\n\t                if ray.hit_point is not None:\n\t                    pygame.draw.rect(\n\t                        self.surface,\n\t                        (color_intensity, color_intensity, color_intensity + 64),\n\t                        (\n\t                            resize(i * step - 1, \"x\"),\n\t                            resize(540 - ray_world_size / 2, \"y\"),\n\t                            resize(step + 2, \"x\"),\n\t                            resize(ray_world_size, \"y\"),\n", "                        ),\n\t                        0,\n\t                    )\n\t        super().render()\n"]}
{"filename": "laser_tag/graphics/components/Scoreboard.py", "chunked_list": ["import pygame\n\tfrom ...configuration import DEFAULT_FONT\n\tfrom ...entities.GameEntity import GameEntity\n\tfrom ...entities.Player import Player\n\tfrom ...game.Team import get_color\n\tfrom ..resize import resize\n\tfrom ..Text import Text\n\tfrom .Component import Component\n\tclass Scoreboard(Component):\n\t    \"\"\"Scoreboard component\"\"\"\n", "    def __init__(\n\t        self,\n\t        data=[],\n\t    ):\n\t        super().__init__()\n\t        self.text = Text(\n\t            DEFAULT_FONT[\"font\"],\n\t            DEFAULT_FONT[\"font_is_file\"],\n\t            DEFAULT_FONT[\"size_multiplier\"],\n\t        )\n", "        self.set_original_size(1280, 720)\n\t        self.update(data)\n\t    def update(\n\t        self,\n\t        entities: list[GameEntity],\n\t    ):\n\t        \"\"\"\n\t        Update the component.\n\t        Parameters:\n\t            entities (list): List of entities in the world\n", "        \"\"\"\n\t        self.data = entities\n\t        super().update()\n\t    def render(self):\n\t        self.surface.fill((0, 0, 0, 192))\n\t        # Title\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                \"Scoreboard\",\n\t                75,\n", "                (255, 255, 255),\n\t            ),\n\t            (resize(10, \"x\"), resize(10, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                \"Team\",\n\t                50,\n\t                (255, 255, 255),\n\t            ),\n", "            (resize(1280 / 5 * 0 + 20, \"x\"), resize(85, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                \"Name\",\n\t                50,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(1280 / 5 * 1 + 20, \"x\"), resize(85, \"y\")),\n\t        )\n", "        self.surface.blit(\n\t            self.text.get_surface(\n\t                \"Score\",\n\t                50,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(1280 / 5 * 2 + 20, \"x\"), resize(85, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n", "                \"Eliminations\",\n\t                50,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(1280 / 5 * 3 + 20, \"x\"), resize(85, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                \"Deaths\",\n\t                50,\n", "                (255, 255, 255),\n\t            ),\n\t            (resize(1280 / 5 * 4 + 20, \"x\"), resize(85, \"y\")),\n\t        )\n\t        step_height = 40\n\t        gap = 10\n\t        i = 0\n\t        for entity in self.data:\n\t            if isinstance(entity, Player):\n\t                y = resize(i * (step_height + gap) + 150, \"y\")\n", "                # Team color\n\t                pygame.draw.circle(\n\t                    self.surface,\n\t                    get_color(entity.team),\n\t                    (resize(20 + 50, \"x\"), y + resize(step_height / 2, \"y\")),\n\t                    resize(10),\n\t                )\n\t                # Name\n\t                self.surface.blit(\n\t                    self.text.get_surface(\n", "                        \"Name\",\n\t                        40,\n\t                        (255, 255, 255),\n\t                    ),\n\t                    (resize(1280 / 5 * 1 + 20, \"x\"), y),\n\t                )\n\t                # Score\n\t                self.surface.blit(\n\t                    self.text.get_surface(\n\t                        int(entity.score),\n", "                        40,\n\t                        (255, 255, 255),\n\t                    ),\n\t                    (resize(1280 / 5 * 2 + 20, \"x\"), y),\n\t                )\n\t                # Eliminations\n\t                self.surface.blit(\n\t                    self.text.get_surface(\n\t                        entity.eliminations,\n\t                        40,\n", "                        (255, 255, 255),\n\t                    ),\n\t                    (resize(1280 / 5 * 3 + 20, \"x\"), y),\n\t                )\n\t                # Deaths\n\t                self.surface.blit(\n\t                    self.text.get_surface(\n\t                        entity.deaths,\n\t                        40,\n\t                        (255, 255, 255),\n", "                    ),\n\t                    (resize(1280 / 5 * 4 + 20, \"x\"), y),\n\t                )\n\t                i += 1\n\t        super().render()\n"]}
{"filename": "laser_tag/graphics/components/NetworkStats.py", "chunked_list": ["from time import time\n\tfrom ...configuration import DEFAULT_FONT\n\tfrom ..resize import resize\n\tfrom ..Text import Text\n\tfrom .Component import Component\n\tclass NetworkStats(Component):\n\t    \"\"\"Network stats component\"\"\"\n\t    def __init__(\n\t        self,\n\t        data={\"pings\": [], \"connected\": False, \"bytes_sent\": [], \"bytes_received\": []},\n", "    ):\n\t        super().__init__()\n\t        self.text = Text(\n\t            DEFAULT_FONT[\"font\"],\n\t            DEFAULT_FONT[\"font_is_file\"],\n\t            DEFAULT_FONT[\"size_multiplier\"],\n\t        )\n\t        self.set_original_size(250, 400)\n\t        self.precision = 100\n\t        self.pings = []\n", "        self.bytes_sent = []\n\t        self.bytes_received = []\n\t        self.average_send_per_tick = []\n\t        self.total_sent = 0\n\t        self.send_per_second = 0\n\t        self.next_second = time() + 1\n\t        self.update(\n\t            data[\"pings\"], data[\"connected\"], data[\"bytes_sent\"], data[\"bytes_received\"]\n\t        )\n\t    def update(\n", "        self,\n\t        pings: list[float],\n\t        connected: bool,\n\t        bytes_sent: list[int],\n\t        bytes_received: list[int],\n\t    ):\n\t        \"\"\"\n\t        Update the component.\n\t        Parameters:\n\t            pings (list): Pings in seconds the last game tick\n", "            connected (bool): The client is connected to the server\n\t            bytes_sent (list): Bytes sent the last game tick\n\t            bytes_received (list): Bytes received the last game tick\n\t        \"\"\"\n\t        self.pings += pings\n\t        self.bytes_sent += bytes_sent\n\t        self.bytes_received += bytes_received\n\t        self.average_send_per_tick.append(len(bytes_sent))\n\t        self.total_sent += len(bytes_sent)\n\t        if time() > self.next_second:\n", "            self.send_per_second = self.total_sent\n\t            self.total_sent = 0\n\t            self.next_second = time() + 1\n\t        self.pings = self.pings[-self.precision :]\n\t        self.bytes_sent = self.bytes_sent[-self.precision :]\n\t        self.bytes_received = self.bytes_received[-self.precision :]\n\t        self.average_send_per_tick = self.average_send_per_tick[-self.precision :]\n\t        self.data = {\n\t            \"pings\": self.pings,\n\t            \"connected\": connected,\n", "            \"bytes_sent\": self.bytes_sent,\n\t            \"bytes_received\": self.bytes_received,\n\t            \"average_send_per_tick\": self.average_send_per_tick,\n\t            \"send_per_second\": self.send_per_second,\n\t        }\n\t        super().update()\n\t    def render(self):\n\t        self.surface.fill((0, 0, 0, 0))\n\t        connection_text = (\n\t            \"Connected\"\n", "            if self.data[\"connected\"]\n\t            else \"Disconnected\"\n\t            if self.data[\"connected\"] is not None\n\t            else \"Connecting...\"\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                connection_text,\n\t                30,\n\t                (255, 255, 255),\n", "            ),\n\t            (resize(0, \"x\"), resize(0, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                f\"Ping: {round((sum(self.data['pings']) / max(1, len(self.data['pings'])) * 1000), 2)}ms\",\n\t                30,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(0, \"x\"), resize(50, \"y\")),\n", "        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                f\"Avg send/tick: {round((sum(self.data['average_send_per_tick']) / max(1, len(self.data['average_send_per_tick']))), 2)}\",\n\t                30,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(0, \"x\"), resize(100, \"y\")),\n\t        )\n\t        self.surface.blit(\n", "            self.text.get_surface(\n\t                f\"Send/s: {self.data['send_per_second']}\",\n\t                30,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(0, \"x\"), resize(150, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                f\"Avg send: {round(sum(self.data['bytes_sent']) / max(1, len(self.data['bytes_sent']))/1000, 2)}kbits\",\n", "                30,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(0, \"x\"), resize(200, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                f\"Max send: {round(0 if len(self.data['bytes_sent']) == 0 else max(self.data['bytes_sent']) / 1000, 2)}kbits\",\n\t                30,\n\t                (255, 255, 255),\n", "            ),\n\t            (resize(0, \"x\"), resize(250, \"y\")),\n\t        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                f\"Avg recv: {round(sum(self.data['bytes_received']) / max(1, len(self.data['bytes_received']))/1000, 2)}kbits\",\n\t                30,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(0, \"x\"), resize(300, \"y\")),\n", "        )\n\t        self.surface.blit(\n\t            self.text.get_surface(\n\t                f\"Max recv: {round(0 if len(self.data['bytes_received']) == 0 else max(self.data['bytes_received']) / 1000, 2)}kbits\",\n\t                30,\n\t                (255, 255, 255),\n\t            ),\n\t            (resize(0, \"x\"), resize(350, \"y\")),\n\t        )\n\t        super().render()\n"]}
{"filename": "laser_tag/graphics/components/GameTimer.py", "chunked_list": ["from time import time\n\tfrom ...configuration import DEFAULT_FONT\n\tfrom ..resize import resize\n\tfrom ..Text import Text\n\tfrom .Component import Component\n\tclass GameTimer(Component):\n\t    \"\"\"Game timer component\"\"\"\n\t    def __init__(\n\t        self,\n\t        data={\n", "            \"grace_period_seconds\": 0,\n\t            \"grace_period_end\": 0,\n\t            \"game_time_seconds\": 0,\n\t            \"game_time_end\": 0,\n\t        },\n\t    ):\n\t        super().__init__()\n\t        self.text = Text(\n\t            DEFAULT_FONT[\"font\"],\n\t            DEFAULT_FONT[\"font_is_file\"],\n", "            DEFAULT_FONT[\"size_multiplier\"],\n\t        )\n\t        self.set_original_size(250, 50)\n\t        self.update(\n\t            data[\"grace_period_seconds\"],\n\t            data[\"grace_period_end\"],\n\t            data[\"game_time_seconds\"],\n\t            data[\"game_time_end\"],\n\t        )\n\t    def update(\n", "        self,\n\t        grace_period_seconds: float,\n\t        grace_period_end: float,\n\t        game_time_seconds: float,\n\t        game_time_end: float,\n\t    ):\n\t        \"\"\"\n\t        Update the component.\n\t        Parameters:\n\t            grace_period_seconds (float): Grace period in seconds\n", "            grace_period_end (float): Grace period end time\n\t            game_time_seconds (float): Game time in seconds\n\t            game_time_end (float): Game end time\n\t        \"\"\"\n\t        self.data = {\n\t            \"grace_period_seconds\": grace_period_seconds,\n\t            \"grace_period_end\": grace_period_end,\n\t            \"game_time_seconds\": game_time_seconds,\n\t            \"game_time_end\": game_time_end,\n\t        }\n", "        super().update()\n\t    def render(self):\n\t        self.surface.fill((0, 0, 0, 0))\n\t        timer_value = 0\n\t        if self.data[\"game_time_end\"] > 0:\n\t            timer_value = self.data[\"game_time_end\"] - min(\n\t                self.data[\"game_time_end\"], time()\n\t            )\n\t        elif self.data[\"grace_period_end\"] > 0:\n\t            timer_value = -(\n", "                self.data[\"grace_period_end\"]\n\t                - min(self.data[\"grace_period_end\"], time())\n\t            )\n\t        if timer_value != 0:\n\t            # Minutes\n\t            text = f\"{'-' * (timer_value < 0)}{int(abs(timer_value) / 60) if abs(timer_value) >= 60 else 0:02d}\"\n\t            # Seconds\n\t            text += f\":{int(abs(timer_value) % 60):02d}\"\n\t            if abs(timer_value) < 10:\n\t                # Milliseconds\n", "                text += f\":{int((timer_value % 1) * 1000):03d}\"\n\t            timer_text = self.text.get_surface(\n\t                text,\n\t                50,\n\t                (255, 255, 255),\n\t            )\n\t            self.surface.blit(\n\t                timer_text,\n\t                (self.width - timer_text.get_width(), resize(0, \"y\")),\n\t            )\n", "        super().render()\n"]}
{"filename": "laser_tag/graphics/components/Component.py", "chunked_list": ["import pygame\n\tfrom ...configuration import VARIABLES\n\tfrom ..resize import resize\n\tclass Component:\n\t    \"\"\"Graphical component\"\"\"\n\t    def __init__(self, data=None):\n\t        self.data = data\n\t        self.surface: pygame.Surface\n\t        self.set_original_size(0, 0)\n\t    def set_original_size(self, width, height):\n", "        self.original_width = width\n\t        self.original_height = height\n\t        self.resize()\n\t    def set_surface_size(self, width, height):\n\t        self.width = int(width)\n\t        self.height = int(height)\n\t        self.surface = pygame.Surface((self.width, self.height), pygame.SRCALPHA)\n\t    def resize(self):\n\t        self.set_surface_size(\n\t            resize(self.original_width, \"x\"), resize(self.original_height, \"y\")\n", "        )\n\t    def get(self) -> pygame.Surface:\n\t        return self.surface\n\t    def update(self, data=None):\n\t        if data is not None:\n\t            self.data = data\n\t        self.render()\n\t    def render(self):\n\t        if VARIABLES.show_components_outline:\n\t            pygame.draw.rect(\n", "                self.surface, (0, 255, 0), (0, 0, self.width, self.height), 1\n\t            )\n"]}
{"filename": "laser_tag/math/Point.py", "chunked_list": ["from __future__ import annotations\n\tclass Point:\n\t    \"\"\"A point is represented by three positions: x, y and z. If z is not defined, the point is 2D\"\"\"\n\t    def __init__(self, x, y, z=None):\n\t        self.x = x\n\t        self.y = y\n\t        self.z = z\n\t    def __repr__(self):\n\t        return f\"[{self.x},{self.y},{self.z}]\"\n\t    @staticmethod\n", "    def create(parsed_object) -> Point:\n\t        try:\n\t            return Point(\n\t                float(parsed_object[0]),\n\t                float(parsed_object[1]),\n\t                None\n\t                if len(parsed_object) < 3 or parsed_object[2] is None\n\t                else float(parsed_object[2]),\n\t            )\n\t        except:\n", "            return None\n"]}
{"filename": "laser_tag/math/rotations.py", "chunked_list": ["from math import atan2, cos, sin\n\tfrom .degrees_radians import *\n\tfrom .Point import Point\n\tdef get_angle(point: Point, center=Point(0, 0)) -> float:\n\t    \"\"\"Returns the angle between the line from the center to the point in degrees (2D space)\"\"\"\n\t    x, y = point.x, point.y\n\t    cx, cy = center.x, center.y\n\t    return radians_to_degrees(atan2(y - cy, x - cx)) % 360\n\tdef rotate(distance, angle, center=Point(0, 0)) -> Point:\n\t    \"\"\"Returns a point rotated around a center point by a given angle (degrees) and distance\"\"\"\n", "    a = degrees_to_radians(angle)\n\t    return Point(center.x + distance * cos(a), center.y + distance * sin(a))\n"]}
{"filename": "laser_tag/math/Line.py", "chunked_list": ["from __future__ import annotations\n\tfrom .Point import Point\n\tclass Line:\n\t    \"\"\"A line is represented by two points in space\"\"\"\n\t    def __init__(self, point1: Point, point2: Point):\n\t        self.point1 = point1\n\t        self.point2 = point2\n\t    def __repr__(self):\n\t        return f\"[{self.point1},{self.point2}]\"\n\t    @staticmethod\n", "    def create(parsed_object) -> Line:\n\t        try:\n\t            point1 = Point.create(parsed_object[0])\n\t            point2 = Point.create(parsed_object[1])\n\t            if point1 is None or point2 is None:\n\t                return None\n\t            return Line(point1, point2)\n\t        except:\n\t            return None\n"]}
{"filename": "laser_tag/math/__init__.py", "chunked_list": []}
{"filename": "laser_tag/math/Box.py", "chunked_list": ["from __future__ import annotations\n\tfrom .Point import Point\n\tclass Box:\n\t    \"\"\"A box is represented by an origin point, a length, a width and a height. If height is not defined, the box is 2D\"\"\"\n\t    def __init__(self, origin: Point, length, width, height=None):\n\t        self.origin = origin\n\t        self.length = length\n\t        self.width = width\n\t        self.height = height\n\t    def __repr__(self):\n", "        return f\"[{self.origin},{self.length},{self.width},{self.height}]\"\n\t    @staticmethod\n\t    def create(parsed_object) -> Box:\n\t        try:\n\t            point = Point.create(parsed_object[0])\n\t            if point is None:\n\t                return None\n\t            return Box(\n\t                point,\n\t                float(parsed_object[1]),\n", "                float(parsed_object[2]),\n\t                None\n\t                if len(parsed_object) < 4 or parsed_object[3] is None\n\t                else float(parsed_object[3]),\n\t            )\n\t        except:\n\t            return None\n\t    def collides_with(self, other) -> bool:\n\t        if isinstance(other, Box):\n\t            return self.collides_with_box(other)\n", "        elif isinstance(other, Point):\n\t            return self.collides_with_point(other)\n\t        else:\n\t            raise TypeError(f\"Cannot check collision with {type(other)}\")\n\t    def collides_with_box(self, other: Box) -> bool:\n\t        return (\n\t            self.origin.x <= other.origin.x + other.length\n\t            and self.origin.x + self.length >= other.origin.x\n\t            and self.origin.y <= other.origin.y + other.width\n\t            and self.origin.y + self.width >= other.origin.y\n", "            and (\n\t                self.origin.z is None\n\t                or self.height is None\n\t                or other.origin.z is None\n\t                or other.height is None\n\t                or self.origin.z <= other.origin.z + other.height\n\t                and self.origin.z + self.height >= other.origin.z\n\t            )\n\t        )\n\t    def collides_with_point(self, other: Point) -> bool:\n", "        return (\n\t            self.origin.x <= other.x <= self.origin.x + self.length\n\t            and self.origin.y <= other.y <= self.origin.y + self.width\n\t            and (\n\t                self.origin.z is None\n\t                or self.height is None\n\t                or other.z is None\n\t                or self.origin.z <= other.z <= self.origin.z + self.height\n\t            )\n\t        )\n"]}
{"filename": "laser_tag/math/random.py", "chunked_list": ["from random import randint, random, seed\n\tdef set_seed(seed_value):\n\t    \"\"\"Set the seed for the random number generation\"\"\"\n\t    seed(seed_value)\n\tdef random_int(min_value: int, max_value: int) -> int:\n\t    \"\"\"Random integer between min_value and max_value (inclusive)\"\"\"\n\t    if min_value > max_value:\n\t        min_value, max_value = max_value, min_value\n\t    return randint(min_value, max_value)\n\tdef random_float(min_value: float, max_value: float) -> float:\n", "    \"\"\"Random number between min_value and max_value\"\"\"\n\t    return random() * (max_value - min_value) + min_value\n"]}
{"filename": "laser_tag/math/distance.py", "chunked_list": ["from math import sqrt\n\tfrom .Point import Point\n\tdef distance(x1, y1, x2, y2) -> float:\n\t    \"\"\"Returns the distance between two points in 2D space\"\"\"\n\t    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\tdef distance_3d(x1, y1, z1, x2, y2, z2) -> float:\n\t    \"\"\"Returns the distance between two points in 3D space\"\"\"\n\t    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n\tdef distance_points(point1: Point, point2: Point) -> float:\n\t    \"\"\"Returns the distance between two points in 2D or 3D space\"\"\"\n", "    if point1.z is not None and point2.z is not None:\n\t        return distance_3d(point1.x, point1.y, point1.z, point2.x, point2.y, point2.z)\n\t    return distance(point1.x, point1.y, point2.x, point2.y)\n"]}
{"filename": "laser_tag/math/degrees_radians.py", "chunked_list": ["from math import pi\n\tdef degrees_to_radians(degrees: float):\n\t    \"\"\"Converts degrees to radians\"\"\"\n\t    return degrees * pi / 180\n\tdef radians_to_degrees(radians: float):\n\t    \"\"\"Converts radians to degrees\"\"\"\n\t    return radians * 180 / pi\n"]}
{"filename": "laser_tag/utils/DeltaTime.py", "chunked_list": ["from time import time\n\tfrom ..configuration import TARGET_FPS\n\tclass DeltaTime:\n\t    \"\"\"Keep track of elapsed time between updates\"\"\"\n\t    __instances = {}\n\t    def __new__(cls, id=None):\n\t        if not id in cls.__instances:\n\t            cls.__instances[id] = super().__new__(cls)\n\t            cls.__instances[id].id = id\n\t            cls.__instances[id].reset()\n", "        return cls.__instances[id]\n\t    def reset(self, current_time: float = None):\n\t        if current_time is None:\n\t            self.previous_time = time()\n\t        else:\n\t            self.previous_time = current_time\n\t        self.current_time = self.previous_time\n\t        self.set_dt(0)\n\t    def update(self, current_time: float = None):\n\t        if current_time is None:\n", "            self.current_time = time()\n\t        else:\n\t            self.current_time = current_time\n\t        self.set_dt(self.current_time - self.previous_time)\n\t        self.previous_time = self.current_time\n\t    def set_dt(self, dt: float):\n\t        self.dt = dt\n\t        self.dt_target = dt * TARGET_FPS\n\t    def get_dt(self) -> float:\n\t        return self.dt\n", "    def get_dt_target(self) -> float:\n\t        return self.dt_target\n"]}
{"filename": "laser_tag/utils/Timer.py", "chunked_list": ["from time import time\n\tclass Timer:\n\t    \"\"\"A simple timer class to measure time\"\"\"\n\t    def __init__(self):\n\t        self.timer_start = None\n\t        self.timer_end = None\n\t    def start(self):\n\t        self.timer_start = time()\n\t    def stop(self):\n\t        self.timer_end = time()\n", "    def get_time(self) -> float:\n\t        return self.timer_end - self.timer_start\n"]}
{"filename": "laser_tag/utils/__init__.py", "chunked_list": []}
{"filename": "laser_tag/events/get_events.py", "chunked_list": ["import pygame\n\tfrom pygame.locals import *\n\tfrom ..configuration import VARIABLES\n\tfrom .Event import Event\n\tfrom .EventInstance import EventInstance\n\tnumber_events = [K_0, K_1, K_2, K_3, K_4, K_5, K_6, K_7, K_8, K_9]\n\tkeypad_events = [K_KP0, K_KP1, K_KP2, K_KP3, K_KP4, K_KP5, K_KP6, K_KP7, K_KP8, K_KP9]\n\tdef get_events() -> list[EventInstance]:\n\t    \"\"\"Returns a list of EventInstance objects\"\"\"\n\t    events = []\n", "    # Unique events\n\t    events.append(EventInstance(Event.TICK))\n\t    for event in pygame.event.get():\n\t        if event.type == QUIT:\n\t            events.append(EventInstance(Event.WINDOW_QUIT))\n\t        elif event.type == KEYDOWN:\n\t            if event.key == K_ESCAPE:\n\t                events.append(EventInstance(Event.KEY_ESCAPE_PRESS))\n\t            elif event.key == K_RETURN:\n\t                events.append(EventInstance(Event.KEY_RETURN_PRESS))\n", "                events.append(EventInstance(Event.START_GAME))\n\t            elif event.key == K_F11:\n\t                events.append(EventInstance(Event.WINDOW_FULLSCREEN))\n\t            elif event.key == K_F12:\n\t                events.append(EventInstance(Event.SCREENSHOT))\n\t            elif event.key in number_events:\n\t                events.append(\n\t                    EventInstance(\n\t                        Event.GAME_SELECT_TEAM, number_events.index(event.key) - 1\n\t                    )\n", "                )\n\t            elif event.key in keypad_events:\n\t                events.append(\n\t                    EventInstance(\n\t                        Event.GAME_SELECT_TEAM, keypad_events.index(event.key) - 1\n\t                    )\n\t                )\n\t        elif event.type == pygame.VIDEORESIZE:\n\t            events.append(EventInstance(Event.WINDOW_RESIZE, [event.w, event.h]))\n\t        elif event.type == pygame.MOUSEBUTTONDOWN:\n", "            if event.button == 1:\n\t                events.append(EventInstance(Event.MOUSE_LEFT_CLICK_PRESS))\n\t            elif event.button == 2:\n\t                events.append(EventInstance(Event.MOUSE_MIDDLE_CLICK_PRESS))\n\t            elif event.button == 3:\n\t                events.append(EventInstance(Event.MOUSE_RIGHT_CLICK_PRESS))\n\t            elif event.button == 4:\n\t                events.append(EventInstance(Event.MOUSE_SCROLL_UP))\n\t            elif event.button == 5:\n\t                events.append(EventInstance(Event.MOUSE_SCROLL_DOWN))\n", "        elif event.type == pygame.MOUSEBUTTONUP:\n\t            if event.button == 1:\n\t                events.append(EventInstance(Event.MOUSE_LEFT_CLICK_RELEASE))\n\t            elif event.button == 2:\n\t                events.append(EventInstance(Event.MOUSE_MIDDLE_CLICK_RELEASE))\n\t            elif event.button == 3:\n\t                events.append(EventInstance(Event.MOUSE_RIGHT_CLICK_RELEASE))\n\t        elif event.type == pygame.MOUSEMOTION:\n\t            events.append(EventInstance(Event.MOUSE_MOVE, [event.pos[0], event.pos[1]]))\n\t    key_pressed = pygame.key.get_pressed()\n", "    mouse_buttons = pygame.mouse.get_pressed()\n\t    # Game events\n\t    if key_pressed[K_w]:\n\t        events.append(EventInstance(Event.GAME_MOVE_FORWARD))\n\t    if key_pressed[K_s]:\n\t        events.append(EventInstance(Event.GAME_MOVE_BACKWARD))\n\t    if key_pressed[K_a]:\n\t        events.append(EventInstance(Event.GAME_MOVE_LEFT))\n\t    if key_pressed[K_d]:\n\t        events.append(EventInstance(Event.GAME_MOVE_RIGHT))\n", "    if key_pressed[K_LSHIFT]:\n\t        events.append(EventInstance(Event.GAME_RUN))\n\t    if key_pressed[K_SPACE]:\n\t        events.append(EventInstance(Event.GAME_JUMP))\n\t    if key_pressed[K_LCTRL]:\n\t        events.append(EventInstance(Event.GAME_CROUCH))\n\t    if key_pressed[K_r]:\n\t        events.append(EventInstance(Event.GAME_RELOAD))\n\t    # Key events\n\t    if key_pressed[K_ESCAPE]:\n", "        events.append(EventInstance(Event.KEY_ESCAPE))\n\t    if key_pressed[K_RETURN]:\n\t        events.append(EventInstance(Event.KEY_RETURN))\n\t    if key_pressed[K_TAB]:\n\t        events.append(EventInstance(Event.KEY_TAB))\n\t        events.append(EventInstance(Event.GAME_SCOREBOARD))\n\t    if key_pressed[K_UP]:\n\t        events.append(EventInstance(Event.KEY_UP))\n\t    if key_pressed[K_DOWN]:\n\t        events.append(EventInstance(Event.KEY_DOWN))\n", "    if key_pressed[K_LEFT]:\n\t        events.append(EventInstance(Event.KEY_LEFT))\n\t    if key_pressed[K_RIGHT]:\n\t        events.append(EventInstance(Event.KEY_RIGHT))\n\t    # Mouse events\n\t    if mouse_buttons[0]:\n\t        events.append(EventInstance(Event.MOUSE_LEFT_CLICK))\n\t        events.append(EventInstance(Event.GAME_SHOOT))\n\t    if mouse_buttons[1]:\n\t        events.append(EventInstance(Event.MOUSE_MIDDLE_CLICK))\n", "    if mouse_buttons[2]:\n\t        events.append(EventInstance(Event.MOUSE_RIGHT_CLICK))\n\t    return events\n"]}
{"filename": "laser_tag/events/__init__.py", "chunked_list": []}
{"filename": "laser_tag/events/Event.py", "chunked_list": ["from enum import Enum, auto\n\tclass Event(Enum):\n\t    \"\"\"Events that can be created during the game\"\"\"\n\t    def _generate_next_value_(name, start, count, last_values):\n\t        return start + count\n\t    def __str__(self):\n\t        return str(self.value)\n\t    NONE = auto()\n\t    TICK = auto()\n\t    START_GAME = auto()\n", "    MESSAGE = auto()\n\t    TYPE_CHAR = auto()\n\t    GAME_MOVE = auto()\n\t    GAME_MOVE_FORWARD = auto()\n\t    GAME_MOVE_BACKWARD = auto()\n\t    GAME_MOVE_LEFT = auto()\n\t    GAME_MOVE_RIGHT = auto()\n\t    GAME_RUN = auto()\n\t    GAME_JUMP = auto()\n\t    GAME_CROUCH = auto()\n", "    GAME_RELOAD = auto()\n\t    GAME_SHOOT = auto()\n\t    GAME_ROTATE = auto()\n\t    GAME_SELECT_TEAM = auto()\n\t    GAME_SCOREBOARD = auto()\n\t    KEY_ESCAPE = auto()\n\t    KEY_ESCAPE_PRESS = auto()\n\t    KEY_RETURN = auto()\n\t    KEY_RETURN_PRESS = auto()\n\t    KEY_TAB = auto()\n", "    KEY_UP = auto()\n\t    KEY_DOWN = auto()\n\t    KEY_LEFT = auto()\n\t    KEY_RIGHT = auto()\n\t    MOUSE_MOVE = auto()\n\t    MOUSE_LEFT_CLICK = auto()\n\t    MOUSE_LEFT_CLICK_PRESS = auto()\n\t    MOUSE_LEFT_CLICK_RELEASE = auto()\n\t    MOUSE_RIGHT_CLICK = auto()\n\t    MOUSE_RIGHT_CLICK_PRESS = auto()\n", "    MOUSE_RIGHT_CLICK_RELEASE = auto()\n\t    MOUSE_MIDDLE_CLICK = auto()\n\t    MOUSE_MIDDLE_CLICK_PRESS = auto()\n\t    MOUSE_MIDDLE_CLICK_RELEASE = auto()\n\t    MOUSE_SCROLL_UP = auto()\n\t    MOUSE_SCROLL_DOWN = auto()\n\t    WINDOW_RESIZE = auto()\n\t    WINDOW_FULLSCREEN = auto()\n\t    WINDOW_QUIT = auto()\n\t    SCREENSHOT = auto()\n", "# Events that are not sent to the server\n\tlocal_events = [\n\t    Event.MESSAGE,\n\t    Event.TYPE_CHAR,\n\t    Event.GAME_MOVE_FORWARD,\n\t    Event.GAME_MOVE_BACKWARD,\n\t    Event.GAME_MOVE_LEFT,\n\t    Event.GAME_MOVE_RIGHT,\n\t    Event.GAME_SCOREBOARD,\n\t    Event.KEY_ESCAPE,\n", "    Event.KEY_ESCAPE_PRESS,\n\t    Event.KEY_RETURN,\n\t    Event.KEY_RETURN_PRESS,\n\t    Event.KEY_TAB,\n\t    Event.KEY_UP,\n\t    Event.KEY_DOWN,\n\t    Event.KEY_LEFT,\n\t    Event.KEY_RIGHT,\n\t    Event.MOUSE_MOVE,\n\t    Event.MOUSE_LEFT_CLICK,\n", "    Event.MOUSE_LEFT_CLICK_PRESS,\n\t    Event.MOUSE_LEFT_CLICK_RELEASE,\n\t    Event.MOUSE_RIGHT_CLICK,\n\t    Event.MOUSE_RIGHT_CLICK_PRESS,\n\t    Event.MOUSE_RIGHT_CLICK_RELEASE,\n\t    Event.MOUSE_MIDDLE_CLICK,\n\t    Event.MOUSE_MIDDLE_CLICK_PRESS,\n\t    Event.MOUSE_MIDDLE_CLICK_RELEASE,\n\t    Event.MOUSE_SCROLL_UP,\n\t    Event.MOUSE_SCROLL_DOWN,\n", "    Event.WINDOW_RESIZE,\n\t    Event.WINDOW_FULLSCREEN,\n\t    Event.WINDOW_QUIT,\n\t    Event.SCREENSHOT,\n\t]\n"]}
{"filename": "laser_tag/events/EventInstance.py", "chunked_list": ["from __future__ import annotations\n\tfrom time import time\n\tfrom ..network.safe_eval import safe_eval\n\tfrom .Event import Event, local_events\n\tclass EventInstance:\n\t    \"\"\"An instance of an event\"\"\"\n\t    def __init__(self, id: Event, data=None):\n\t        self.timestamp = time()\n\t        self.id = id\n\t        self.data = data\n", "        self.local = id in local_events\n\t    def __repr__(self):\n\t        return f\"[{self.id},{self.data},{self.timestamp}]\"\n\t    @staticmethod\n\t    def create(parsed_object) -> EventInstance:\n\t        try:\n\t            event = EventInstance(Event(parsed_object[0]), parsed_object[1])\n\t            event.timestamp = float(parsed_object[2])\n\t            return event\n\t        except:\n", "            return None\n"]}
{"filename": "laser_tag/network/safe_eval.py", "chunked_list": ["eval_banned_elements = [\n\t    \"import \",\n\t    \"(\",\n\t    \";\",\n\t    \"=\",\n\t]\n\tdef safe_eval(data, debug=False):\n\t    normalized_data = str(data).strip().lower()\n\t    for element in eval_banned_elements:\n\t        if element in normalized_data:\n", "            if debug:\n\t                print(f'EVAL banned element \"{element}\" found in {data}')\n\t            return None\n\t    try:\n\t        return eval(data, {}, {})\n\t    except Exception as e:\n\t        if debug:\n\t            print(f\"EVAL {e}. Evaluating: {data} (length: {len(data)})\")\n\t        return None\n"]}
{"filename": "laser_tag/network/Client.py", "chunked_list": ["import socket\n\tfrom threading import Lock, Thread\n\tfrom time import sleep\n\tfrom ..configuration import (\n\t    CLIENT_MINIMUM_TICK,\n\t    CLIENT_TIMEOUT,\n\t    NETWORK_BUFFER_SIZE,\n\t    VARIABLES,\n\t    VERSION,\n\t)\n", "from ..events.EventInstance import EventInstance\n\tfrom ..utils.Timer import Timer\n\tfrom .safe_eval import safe_eval\n\tclass Client:\n\t    def __init__(self, ip: str, port: int, debug=False):\n\t        self.ip = ip\n\t        self.port = port\n\t        self.debug = VARIABLES.debug or debug\n\t        self.connected = None\n\t        self.thread = None\n", "        self.events_to_send: list[EventInstance] = []\n\t        self.data_received = []\n\t        self.mutex = Lock()\n\t        self.bytes_sent = []\n\t        self.bytes_received = []\n\t        self.pings = []\n\t        self.network_stats_mutex = Lock()\n\t        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t        self.socket.settimeout(CLIENT_TIMEOUT)\n\t        try:\n", "            self.socket.connect((self.ip, self.port))\n\t            self.connected = True\n\t            if self.debug:\n\t                print(f\"CLIENT connected to {(ip, port)}\")\n\t        except ConnectionRefusedError:\n\t            if self.debug:\n\t                print(f\"CLIENT connection refused by {ip}\")\n\t        except socket.gaierror:\n\t            if self.debug:\n\t                print(f\"CLIENT cannot resolve host {ip}\")\n", "        except TimeoutError:\n\t            if self.debug:\n\t                print(f\"CLIENT connection timed out\")\n\t        if self.connected:\n\t            self.thread = Thread(target=self.client)\n\t            self.thread.start()\n\t        else:\n\t            self.disconnect()\n\t    def client(self):\n\t        # Version check\n", "        self.send(f'\"{VERSION}\"')\n\t        server_version = str(self.recv()[0])\n\t        if VERSION != server_version:\n\t            if self.debug:\n\t                print(\n\t                    f\"CLIENT bad version (Client: {VERSION} Server: {server_version})\"\n\t                )\n\t            self.disconnect()\n\t        ping_timer = Timer()\n\t        while self.connected:\n", "            ping_timer.start()\n\t            bytes_sent = self.send(self.get_events_to_send())\n\t            if VARIABLES.fps > 0:\n\t                sleep(1 / max(CLIENT_MINIMUM_TICK, VARIABLES.fps))\n\t            data, bytes_received = self.recv()\n\t            ping_timer.stop()\n\t            if data is None:\n\t                self.disconnect()\n\t                continue\n\t            else:\n", "                self.add_received_data(data)\n\t            self.set_network_stats(ping_timer.get_time(), bytes_sent, bytes_received)\n\t        self.disconnect()\n\t    def send(self, data):\n\t        encoded_data = str(data).encode(\"utf-8\")\n\t        bytes_sent = len(encoded_data)\n\t        try:\n\t            self.socket.send(encoded_data)\n\t        except Exception as e:\n\t            if self.debug:\n", "                print(f\"CLIENT send {e}\")\n\t        return bytes_sent\n\t    def recv(self):\n\t        try:\n\t            data = self.socket.recv(NETWORK_BUFFER_SIZE)\n\t            bytes_received = len(data)\n\t            data = safe_eval(data.decode(\"utf-8\"), self.debug)\n\t            return data, bytes_received\n\t        except Exception as e:\n\t            if self.debug:\n", "                print(f\"CLIENT recv {e}\")\n\t        return None, 0\n\t    def add_events_to_send(self, events: list[EventInstance]):\n\t        self.mutex.acquire()\n\t        self.events_to_send += events\n\t        self.mutex.release()\n\t    def get_events_to_send(self) -> list[EventInstance]:\n\t        self.mutex.acquire()\n\t        events = self.events_to_send.copy()\n\t        self.events_to_send.clear()\n", "        self.mutex.release()\n\t        return events\n\t    def add_received_data(self, data):\n\t        self.mutex.acquire()\n\t        self.data_received.append(data)\n\t        self.mutex.release()\n\t    def get_received_data(self):\n\t        self.mutex.acquire()\n\t        data = self.data_received.copy()\n\t        self.data_received.clear()\n", "        self.mutex.release()\n\t        return data\n\t    def set_network_stats(self, ping, bytes_sent, bytes_received):\n\t        self.network_stats_mutex.acquire()\n\t        self.pings.append(ping)\n\t        self.bytes_sent.append(bytes_sent)\n\t        self.bytes_received.append(bytes_received)\n\t        self.network_stats_mutex.release()\n\t    def get_network_stats(self):\n\t        self.network_stats_mutex.acquire()\n", "        pings = self.pings.copy()\n\t        bytes_sent = self.bytes_sent.copy()\n\t        bytes_received = self.bytes_received.copy()\n\t        self.pings.clear()\n\t        self.bytes_sent.clear()\n\t        self.bytes_received.clear()\n\t        self.network_stats_mutex.release()\n\t        return pings, self.connected, bytes_sent, bytes_received\n\t    def is_connected(self):\n\t        return self.connected\n", "    def disconnect(self):\n\t        if self.connected or self.connected is None:\n\t            self.socket.close()\n\t            self.connected = False\n\t            if self.debug:\n\t                print(\"CLIENT disconnected\")\n"]}
{"filename": "laser_tag/network/__init__.py", "chunked_list": []}
{"filename": "laser_tag/network/Server.py", "chunked_list": ["import socket\n\tfrom sys import argv\n\tfrom sys import exit as sys_exit\n\tfrom threading import Thread\n\tfrom laser_tag.configuration import (\n\t    NETWORK_BUFFER_SIZE,\n\t    SERVER_DEFAULT_MAX_CLIENTS,\n\t    SERVER_DELTA_TIME_NAME,\n\t    SERVER_SOCKET_TIMEOUT,\n\t    SERVER_TIMEOUT,\n", "    VARIABLES,\n\t    VERSION,\n\t)\n\tfrom laser_tag.entities.Player import Player\n\tfrom laser_tag.events.EventInstance import EventInstance\n\tfrom laser_tag.game.Game import Game\n\tfrom laser_tag.network.safe_eval import safe_eval\n\tfrom laser_tag.utils.DeltaTime import DeltaTime\n\tclass ClientInstance:\n\t    def __init__(self, info, conn):\n", "        self.info = info\n\t        self.conn = conn\n\t        self.thread = None\n\t        self.data = None\n\t        self.controlled_entity_id = None\n\tclass Server:\n\t    def __init__(self, port: int, debug=False):\n\t        self.port = port\n\t        self.debug = VARIABLES.debug or debug\n\t        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n", "        self.socket.settimeout(SERVER_SOCKET_TIMEOUT)\n\t        try:\n\t            self.socket.bind((\"\", self.port))\n\t            self.port = self.socket.getsockname()[1]\n\t        except OSError:\n\t            if self.debug:\n\t                print(f\"SERVER port {self.port} is already in use\")\n\t            self.socket.close()\n\t            sys_exit(1)\n\t        self.socket.listen()\n", "        if self.debug:\n\t            print(f\"SERVER bound to {self.socket.getsockname()}\")\n\t            print(f\"SERVER IP: {socket.gethostbyname(socket.gethostname())}\")\n\t        self.max_clients = SERVER_DEFAULT_MAX_CLIENTS\n\t        self.clients = {}\n\t        self.game = Game()\n\t        self.server_delta_time = DeltaTime(SERVER_DELTA_TIME_NAME)\n\t        self.running = None\n\t        self.running_thread = Thread(target=self.run)\n\t    def start(self):\n", "        if self.running is None:\n\t            self.running = True\n\t            self.running_thread.start()\n\t        else:\n\t            if self.debug:\n\t                print(\"SERVER has already been started\")\n\t    def run(self):\n\t        if self.debug and self.running:\n\t            print(\"SERVER started\")\n\t        while self.running:\n", "            try:\n\t                conn, info = self.socket.accept()\n\t                if (\n\t                    self.max_clients is not None\n\t                    and len(self.clients) >= self.max_clients\n\t                ):\n\t                    conn.close()\n\t                    if self.debug:\n\t                        print(\n\t                            f\"SERVER {info} tried to connect but server is full ({len(self.clients)} client{'s' * (len(self.clients) > 1)})\"\n", "                        )\n\t                    continue\n\t                self.clients[info] = ClientInstance(info, conn)\n\t                self.clients[info].thread = Thread(\n\t                    target=self.client, args=[self.clients[info]]\n\t                )\n\t                self.clients[info].thread.start()\n\t            except TimeoutError:\n\t                continue\n\t            except Exception as e:\n", "                if self.debug:\n\t                    print(f\"SERVER {e}\")\n\t                self.stop()\n\t        self.stop()\n\t    def client(self, client: ClientInstance):\n\t        if self.debug:\n\t            print(\n\t                f\"SERVER {client.info} connected ({len(self.clients)} client{'s' * (len(self.clients) > 1)})\"\n\t            )\n\t        client.conn.settimeout(SERVER_TIMEOUT)\n", "        # Version check\n\t        client_version = str(self.recv(client))\n\t        self.send(client, f'\"{VERSION}\"')\n\t        if VERSION != client_version:\n\t            if self.debug:\n\t                print(\n\t                    f\"SERVER {client.info} bad version (Server: {VERSION} Client: {client_version})\"\n\t                )\n\t        else:\n\t            client.data = True\n", "        # Create player\n\t        spawn_point = self.game.world.map.get_spawn_point()\n\t        client.controlled_entity_id = self.game.world.spawn_entity(Player(spawn_point))\n\t        client_delta_time = DeltaTime(client.info)\n\t        while client.data is not None and self.running:\n\t            client.data = self.parse_events(self.recv(client))\n\t            if client.data is not None:\n\t                # Process data\n\t                self.game.update(\n\t                    client.data,\n", "                    controlled_entity_id=client.controlled_entity_id,\n\t                    delta_time=self.server_delta_time,\n\t                    player_delta_time=client_delta_time,\n\t                )\n\t            # Send data\n\t            self.send(client, self.get_state(client))\n\t        # Disconnect client\n\t        client.conn.close()\n\t        del self.clients[client.info]\n\t        self.game.world.remove_entity(client.controlled_entity_id)\n", "        if self.debug:\n\t            print(\n\t                f\"SERVER {client.info} disconnected ({len(self.clients)} client{'s' * (len(self.clients) > 1)})\"\n\t            )\n\t    def send(self, client: ClientInstance, data):\n\t        try:\n\t            client.conn.send(str(data).encode(\"utf-8\"))\n\t        except Exception as e:\n\t            if self.debug:\n\t                print(f\"SERVER send {client.info} {e}\")\n", "    def recv(self, client: ClientInstance):\n\t        try:\n\t            data = client.conn.recv(NETWORK_BUFFER_SIZE).decode(\"utf-8\")\n\t            data = safe_eval(data, self.debug)\n\t            return data\n\t        except Exception as e:\n\t            if self.debug:\n\t                print(f\"SERVER recv {client.info} {e}\")\n\t        return None\n\t    def set_max_clients(self, max_clients: int):\n", "        self.max_clients = max_clients\n\t    def get_state(self, client: ClientInstance) -> list:\n\t        state = {}\n\t        state[\"game\"] = self.game\n\t        state[\"controlled_entity_id\"] = client.controlled_entity_id\n\t        return state\n\t    def parse_events(self, data):\n\t        if not isinstance(data, list):\n\t            return None\n\t        events = []\n", "        for event in data:\n\t            created_event = EventInstance.create(event)\n\t            if created_event is not None and not created_event.local:\n\t                events.append(created_event)\n\t        return events\n\t    def stop(self):\n\t        if self.running:\n\t            if self.debug:\n\t                print(\"SERVER stopping...\")\n\t            self.running = False\n", "            self.socket.close()\n\t            for client in self.clients.copy().values():\n\t                client.conn.close()\n\t    def get_port(self):\n\t        return self.port\n\tif __name__ == \"__main__\":\n\t    port = None\n\t    debug = None\n\t    if len(argv) < 2:\n\t        # Manual input of port\n", "        while port is None:\n\t            try:\n\t                port = int(input(\"Port: \"))\n\t                if port < 0 or port > 65535:\n\t                    port = None\n\t                    raise ValueError\n\t            except ValueError:\n\t                print(\"Invalid port\")\n\t        debug = \"n\" not in input(\"Debug (Y/n): \").lower()\n\t    else:\n", "        try:\n\t            port = int(argv[1])\n\t            if port < 0 or port > 65535:\n\t                raise ValueError\n\t            debug = len(argv) > 2\n\t        except:\n\t            print(\"Usage: python -m laser_tag.network.Server [port] [debug]\")\n\t            sys_exit(1)\n\t    server = Server(port, debug)\n\t    server.start()\n", "    try:\n\t        while (\n\t            \"exit\"\n\t            not in input('Enter \"exit\" or press Ctrl+C to stop the server\\n').lower()\n\t        ):\n\t            continue\n\t    except KeyboardInterrupt:\n\t        if debug:\n\t            print()\n\t    server.stop()\n"]}
{"filename": "laser_tag/game/Game.py", "chunked_list": ["from ..configuration import VARIABLES\n\tfrom ..events.Event import Event\n\tfrom ..events.EventInstance import EventInstance\n\tfrom ..utils.DeltaTime import DeltaTime\n\tfrom .GameMode import GameMode\n\tfrom .World import World\n\tclass Game:\n\t    \"\"\"Game manager\"\"\"\n\t    def __init__(self):\n\t        self.game_mode = GameMode()\n", "        self.world = World()\n\t        self.mouse_x = None\n\t        self.mouse_y = None\n\t        self.show_scoreboard = False\n\t    def __repr__(self):\n\t        return f\"[{self.game_mode}, {self.world}]\"\n\t    def set_state(self, parsed_object):\n\t        try:\n\t            self.game_mode.set_state(parsed_object[\"game\"][0])\n\t            self.world.set_state(parsed_object[\"game\"][1])\n", "            self.world.set_controlled_entity(int(parsed_object[\"controlled_entity_id\"]))\n\t        except Exception as e:\n\t            if VARIABLES.debug:\n\t                print(\"Error setting game state\", e)\n\t    def reset(self):\n\t        for entity in self.world.entities.values():\n\t            entity.reset()\n\t    def update_state(self, state):\n\t        self.state = state\n\t    def enhance_events(self, events: list[EventInstance]):\n", "        i = 0\n\t        while i < len(events):\n\t            event = events[i]\n\t            if event.id == Event.MOUSE_MOVE:\n\t                self.mouse_x = event.data[0] / VARIABLES.screen_width * 1920\n\t                self.mouse_y = event.data[1] / VARIABLES.screen_height * 1080\n\t                if self.mouse_x != 960 or self.mouse_y != 540:\n\t                    events.append(\n\t                        EventInstance(\n\t                            Event.GAME_ROTATE,\n", "                            [\n\t                                -(960 - self.mouse_x)\n\t                                * VARIABLES.rotate_sensitivity\n\t                                * VARIABLES.screen_width\n\t                                / 1920,\n\t                                -(540 - self.mouse_y)\n\t                                * VARIABLES.rotate_sensitivity\n\t                                * VARIABLES.screen_height\n\t                                / 1080,\n\t                            ],\n", "                        )\n\t                    )\n\t            i += 1\n\t        self.world.enhance_events(events)\n\t    def update(\n\t        self,\n\t        events: list[EventInstance],\n\t        controlled_entity_id=None,\n\t        delta_time=DeltaTime(),\n\t        player_delta_time: DeltaTime = None,\n", "    ):\n\t        delta_time.update()\n\t        self.show_scoreboard = False\n\t        for event in events:\n\t            match event.id:\n\t                case Event.START_GAME:\n\t                    if self.game_mode.start():\n\t                        # Reset\n\t                        self.reset()\n\t                case Event.GAME_SELECT_TEAM:\n", "                    # Can only select team if game has not started\n\t                    if self.game_mode.game_started:\n\t                        event.id = Event.NONE\n\t                case Event.GAME_SCOREBOARD:\n\t                    self.show_scoreboard = True\n\t        self.world.update(events, controlled_entity_id, delta_time, player_delta_time)\n\t        self.game_mode.update(self.world.entities)\n"]}
{"filename": "laser_tag/game/Map.py", "chunked_list": ["from math import ceil, sqrt\n\tfrom ..configuration import MAX_RAY_DISTANCE\n\tfrom ..math.Box import Box\n\tfrom ..math.Point import Point\n\tfrom ..math.rotations import rotate\n\tfrom .Ray import Ray\n\tclass Map:\n\t    \"\"\"Represents a map in the game and checks collisions\"\"\"\n\t    def __init__(self):\n\t        self.map = [\n", "            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n\t            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t            [1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1],\n\t            [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1],\n\t            [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\n\t            [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],\n\t            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],\n\t            [1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\n\t            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n\t            [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1],\n", "            [1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1],\n\t            [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1],\n\t            [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1],\n\t            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n\t        ]\n\t    def get_spawn_point(self):\n\t        return Point(4, 4)\n\t    def collides_with(self, collider: Box):\n\t        if collider.origin.x < 0 or collider.origin.y < 0:\n", "            return True\n\t        for y in range(\n\t            int(collider.origin.y), ceil(collider.origin.y + collider.width)\n\t        ):\n\t            for x in range(\n\t                int(collider.origin.x), ceil(collider.origin.x + collider.length)\n\t            ):\n\t                if y > len(self.map) - 1 or x > len(self.map[y]) - 1:\n\t                    return True\n\t                if self.map[y][x] == 1:\n", "                    return True\n\t    def cast_ray(self, origin: Point, direction: float) -> Ray:\n\t        # DDA: Digital Differential Analyzer\n\t        ray = Ray(origin, direction)\n\t        cell = Point(int(origin.x), int(origin.y))\n\t        end_point = rotate(1, direction, center=origin)\n\t        dx = end_point.x - origin.x\n\t        dy = end_point.y - origin.y\n\t        one_unit_x = sqrt(1 + (dy / dx) ** 2) if dx != 0 else MAX_RAY_DISTANCE\n\t        one_unit_y = sqrt(1 + (dx / dy) ** 2) if dy != 0 else MAX_RAY_DISTANCE\n", "        x_distance = 0\n\t        y_distance = 0\n\t        casting_direction = [0, 0]\n\t        if direction > 180:\n\t            # Up\n\t            casting_direction[1] = -1\n\t            y_distance = (origin.y - cell.y) * one_unit_y\n\t        else:\n\t            # Down\n\t            casting_direction[1] = 1\n", "            y_distance = (cell.y + 1 - origin.y) * one_unit_y\n\t        if direction > 90 and direction < 270:\n\t            # Left\n\t            casting_direction[0] = -1\n\t            x_distance = (origin.x - cell.x) * one_unit_x\n\t        else:\n\t            # Right\n\t            casting_direction[0] = 1\n\t            x_distance = (cell.x + 1 - origin.x) * one_unit_x\n\t        casting = True\n", "        total_distance = 0\n\t        while casting and total_distance < MAX_RAY_DISTANCE:\n\t            if x_distance < y_distance:\n\t                cell.x += casting_direction[0]\n\t                total_distance = x_distance\n\t                x_distance += one_unit_x\n\t            else:\n\t                cell.y += casting_direction[1]\n\t                total_distance = y_distance\n\t                y_distance += one_unit_y\n", "            # Collision\n\t            if (\n\t                cell.x >= 0\n\t                and cell.x < len(self.map[0])\n\t                and cell.y >= 0\n\t                and cell.y < len(self.map)\n\t            ):\n\t                if self.map[cell.y][cell.x] == 1:\n\t                    casting = False\n\t                    ray.set_hit(\n", "                        rotate(\n\t                            min(total_distance, MAX_RAY_DISTANCE),\n\t                            direction,\n\t                            center=origin,\n\t                        ),\n\t                        hit_infos=None,\n\t                        distance=min(total_distance, MAX_RAY_DISTANCE),\n\t                    )\n\t            else:\n\t                # Out of the map\n", "                casting = False\n\t        return ray\n"]}
{"filename": "laser_tag/game/Ray.py", "chunked_list": ["from ..math.distance import distance_points\n\tfrom ..math.Point import Point\n\tclass Ray:\n\t    \"\"\"Represents a raycasting ray\"\"\"\n\t    def __init__(self, origin: Point, direction: float):\n\t        self.origin = origin\n\t        self.direction = direction\n\t        self.set_hit(origin, hit_infos=None, distance=0)\n\t    def __repr__(self):\n\t        return f\"[{self.origin},{self.direction},{self.hit_point},{self.hit_infos},{self.distance}]\"\n", "    def set_hit(self, hit_point: Point, hit_infos=None, distance=None):\n\t        self.hit_point = hit_point\n\t        self.hit_infos = hit_infos\n\t        if distance is None:\n\t            self.distance = distance_points(self.origin, self.hit_point)\n\t        else:\n\t            self.distance = distance\n"]}
{"filename": "laser_tag/game/__init__.py", "chunked_list": []}
{"filename": "laser_tag/game/World.py", "chunked_list": ["from threading import Lock\n\tfrom ..configuration import VARIABLES\n\tfrom ..entities.create_entity import create_entity\n\tfrom ..entities.GameEntity import GameEntity\n\tfrom ..entities.Projectile import Projectile\n\tfrom ..events.Event import Event\n\tfrom ..events.EventInstance import EventInstance\n\tfrom ..math.Box import Box\n\tfrom ..math.Point import Point\n\tfrom ..math.rotations import get_angle, rotate\n", "from ..utils.DeltaTime import DeltaTime\n\tfrom .Map import Map\n\tfrom .Team import Team\n\tclass World:\n\t    \"\"\"World class, contains all entities and map\"\"\"\n\t    def __init__(self):\n\t        self.map = Map()\n\t        self.entities: dict[int, GameEntity] = {}\n\t        self.controlled_entity = None\n\t        self.current_uid = 0\n", "        self.uid_mutex = Lock()\n\t    def __repr__(self):\n\t        return f\"{self.entities}\"\n\t    def set_state(self, parsed_object):\n\t        self.entities.clear()\n\t        try:\n\t            for key in parsed_object:\n\t                new_entity = create_entity(parsed_object[key])\n\t                if new_entity is not None:\n\t                    self.entities[key] = new_entity\n", "        except Exception as e:\n\t            if VARIABLES.debug:\n\t                print(\"Error setting world state\", e)\n\t    def get_uid(self):\n\t        self.uid_mutex.acquire()\n\t        self.current_uid += 1\n\t        uid = self.current_uid\n\t        self.uid_mutex.release()\n\t        return uid\n\t    def spawn_entity(self, entity: GameEntity):\n", "        self.entities[self.get_uid()] = entity\n\t        return self.current_uid\n\t    def get_entity(self, uid):\n\t        try:\n\t            return self.entities[uid]\n\t        except KeyError:\n\t            return None\n\t    def remove_entity(self, uid):\n\t        try:\n\t            del self.entities[uid]\n", "        except KeyError:\n\t            pass\n\t    def set_controlled_entity(self, uid):\n\t        self.controlled_entity = uid\n\t    def enhance_events(self, events: list[EventInstance]):\n\t        movement_vector = [0, 0]\n\t        i = 0\n\t        while i < len(events):\n\t            event = events[i]\n\t            if event.id == Event.GAME_MOVE_FORWARD:\n", "                movement_vector[0] += 1\n\t            if event.id == Event.GAME_MOVE_BACKWARD:\n\t                movement_vector[0] -= 1\n\t            if event.id == Event.GAME_MOVE_LEFT:\n\t                movement_vector[1] -= 1\n\t            if event.id == Event.GAME_MOVE_RIGHT:\n\t                movement_vector[1] += 1\n\t            i += 1\n\t        # Movement direction\n\t        if movement_vector[0] != 0 or movement_vector[1] != 0:\n", "            events.append(\n\t                EventInstance(\n\t                    Event.GAME_MOVE,\n\t                    get_angle(\n\t                        Point(\n\t                            movement_vector[0],\n\t                            movement_vector[1],\n\t                        )\n\t                    ),\n\t                )\n", "            )\n\t    def update(\n\t        self,\n\t        events: list[EventInstance],\n\t        controlled_entity_id=None,\n\t        delta_time=DeltaTime(),\n\t        player_delta_time: DeltaTime = None,\n\t    ):\n\t        if self.controlled_entity is not None or controlled_entity_id is not None:\n\t            current_entity = (\n", "                self.get_entity(self.controlled_entity)\n\t                if self.controlled_entity is not None\n\t                else self.get_entity(controlled_entity_id)\n\t            )\n\t            if current_entity is None:\n\t                if VARIABLES.debug:\n\t                    print(\"Invalid controlled entity\")\n\t                return\n\t            # Asynchronous mode (used by the server to process events in the past)\n\t            async_mode = player_delta_time is not None\n", "            player_delta_time = delta_time if not async_mode else player_delta_time\n\t            current_entity.is_running = False\n\t            current_entity.is_crouching = False\n\t            for event in events:\n\t                match event.id:\n\t                    case Event.TICK:\n\t                        # Synchonize delta time for each tick\n\t                        if async_mode:\n\t                            player_delta_time.update(event.timestamp)\n\t                    case Event.GAME_CROUCH:\n", "                        current_entity.is_crouching = True\n\t                    case Event.GAME_RUN:\n\t                        if not current_entity.is_crouching:\n\t                            current_entity.is_running = True\n\t                    case Event.GAME_ROTATE:\n\t                        if (\n\t                            isinstance(event.data, list)\n\t                            and len(event.data) == 2\n\t                            and isinstance(event.data[0], (int, float))\n\t                        ):\n", "                            current_entity.rotation += event.data[0]\n\t                        current_entity.rotation %= 360\n\t                    case Event.GAME_MOVE:\n\t                        if isinstance(event.data, (int, float)):\n\t                            self.move_entity(\n\t                                current_entity,\n\t                                rotate(\n\t                                    current_entity.move_speed\n\t                                    * (\n\t                                        current_entity.run_speed_multiplier\n", "                                        if current_entity.is_running\n\t                                        else 1\n\t                                    )\n\t                                    * (\n\t                                        current_entity.crouch_speed_multiplier\n\t                                        if current_entity.is_crouching\n\t                                        else 1\n\t                                    )\n\t                                    * player_delta_time.get_dt_target(),\n\t                                    current_entity.rotation + event.data,\n", "                                ),\n\t                            )\n\t                    case Event.GAME_SHOOT:\n\t                        if current_entity.attack():\n\t                            projectile = Projectile(\n\t                                Point(\n\t                                    current_entity.position.x,\n\t                                    current_entity.position.y,\n\t                                    current_entity.position.z,\n\t                                ),\n", "                                self.controlled_entity\n\t                                if self.controlled_entity is not None\n\t                                else controlled_entity_id,\n\t                            )\n\t                            projectile.rotation = current_entity.rotation\n\t                            projectile.team = current_entity.team\n\t                            projectile.damages = current_entity.damages\n\t                            projectile.get_entity_fct = self.get_entity\n\t                            self.spawn_entity(projectile)\n\t                    case Event.GAME_SELECT_TEAM:\n", "                        if event.data in [t.value for t in Team]:\n\t                            current_entity.team = event.data\n\t            # Update other entities\n\t            for key in list(self.entities.keys()):\n\t                entity = self.get_entity(key)\n\t                if entity is None:\n\t                    continue\n\t                # Remove dead entities\n\t                if not entity.alive:\n\t                    self.remove_entity(key)\n", "                    continue\n\t                # Projectile\n\t                if isinstance(entity, Projectile):\n\t                    # Collision with entities\n\t                    if entity.can_attack:\n\t                        for key_target in list(self.entities.keys()):\n\t                            entity_target = self.get_entity(key_target)\n\t                            # Target is not the projectile nor its parent\n\t                            if (\n\t                                entity_target is None\n", "                                or key == key_target\n\t                                or entity.parent_id == key_target\n\t                            ):\n\t                                continue\n\t                            # Target is in a different team (or not in a team)\n\t                            if (\n\t                                entity.team != entity_target.team\n\t                                or entity_target.team == -1\n\t                            ):\n\t                                # Collision with the target\n", "                                if (\n\t                                    entity.collides_with(entity_target)\n\t                                    and entity.attack()\n\t                                ):\n\t                                    # Damage the target\n\t                                    killed = entity_target.damage(entity.damages)\n\t                                    # The target was hit\n\t                                    if killed is not None:\n\t                                        entity.on_hit(entity_target)\n\t                                        if killed:\n", "                                            entity.on_kill(entity_target)\n\t                    # Collision with map\n\t                    if entity.can_move:\n\t                        collision = self.move_entity(\n\t                            entity,\n\t                            rotate(\n\t                                entity.move_speed * delta_time.get_dt_target(),\n\t                                entity.rotation,\n\t                            ),\n\t                        )\n", "                        if collision:\n\t                            entity.can_move = False\n\t                            entity.death()\n\t    def move_entity(self, entity: GameEntity, movement_vector: Point):\n\t        collision = False\n\t        moved_collider_x = Box(\n\t            Point(\n\t                entity.collider.origin.x + movement_vector.x,\n\t                entity.collider.origin.y,\n\t                entity.collider.origin.z,\n", "            ),\n\t            entity.collider.length,\n\t            entity.collider.width,\n\t            entity.collider.height,\n\t        )\n\t        if not self.map.collides_with(moved_collider_x):\n\t            entity.move(\n\t                entity.position.x + movement_vector.x,\n\t                entity.position.y,\n\t                entity.position.z,\n", "            )\n\t        else:\n\t            collision = True\n\t        moved_collider_y = Box(\n\t            Point(\n\t                entity.collider.origin.x,\n\t                entity.collider.origin.y + movement_vector.y,\n\t                entity.collider.origin.z,\n\t            ),\n\t            entity.collider.length,\n", "            entity.collider.width,\n\t            entity.collider.height,\n\t        )\n\t        if not self.map.collides_with(moved_collider_y):\n\t            entity.move(\n\t                entity.position.x,\n\t                entity.position.y + movement_vector.y,\n\t                entity.position.z,\n\t            )\n\t        else:\n", "            collision = True\n\t        if entity.collider.origin.z is not None and movement_vector.z is not None:\n\t            moved_collider_z = Box(\n\t                Point(\n\t                    entity.collider.origin.x,\n\t                    entity.collider.origin.y,\n\t                    entity.collider.origin.z + movement_vector.z,\n\t                ),\n\t                entity.collider.length,\n\t                entity.collider.width,\n", "                entity.collider.height,\n\t            )\n\t            if not self.map.collides_with(moved_collider_z):\n\t                entity.move(\n\t                    entity.position.x,\n\t                    entity.position.y,\n\t                    entity.position.z + movement_vector.z,\n\t                )\n\t            else:\n\t                collision = True\n", "        return collision\n\t    def cast_rays(self):\n\t        rays = []\n\t        entity = self.get_entity(self.controlled_entity)\n\t        if entity is not None:\n\t            start = -VARIABLES.fov / 2\n\t            step = VARIABLES.fov / VARIABLES.rays_quantity\n\t            for i in range(VARIABLES.rays_quantity):\n\t                rays.append(\n\t                    self.map.cast_ray(\n", "                        entity.position,\n\t                        (entity.rotation + start + i * step) % 360,\n\t                    )\n\t                )\n\t        return rays\n"]}
{"filename": "laser_tag/game/GameMode.py", "chunked_list": ["from enum import Enum, auto\n\tfrom time import time\n\tfrom ..configuration import VARIABLES\n\tfrom ..entities.GameEntity import GameEntity\n\tfrom ..entities.Player import Player\n\tclass Mode(Enum):\n\t    \"\"\"Game modes\"\"\"\n\t    def __str__(self):\n\t        return str(self.value)\n\t    SOLO = auto()\n", "    TEAM = auto()\n\t    SOLO_ELIMINATION = auto()\n\t    TEAM_ELIMINATION = auto()\n\tclass GameMode:\n\t    \"\"\"Game mode manager\"\"\"\n\t    def __init__(self, game_mode=Mode.SOLO):\n\t        self.reset(game_mode)\n\t    def __repr__(self):\n\t        return f\"[{self.game_mode}, {self.game_started}, {self.grace_period_end}, {self.game_time_end}, {self.game_time_seconds}]\"\n\t    def set_state(self, parsed_object):\n", "        try:\n\t            self.game_mode = Mode(parsed_object[0])\n\t            self.game_started = bool(parsed_object[1])\n\t            self.grace_period_end = float(parsed_object[2])\n\t            self.game_time_end = float(parsed_object[3])\n\t            self.game_time_seconds = float(parsed_object[4])\n\t        except Exception as e:\n\t            if VARIABLES.debug:\n\t                print(\"Error setting game mode state\", e)\n\t    def reset(self, game_mode):\n", "        self.game_started = False\n\t        self.game_mode = game_mode\n\t        self.grace_period_seconds = 20\n\t        self.grace_period_end = 0\n\t        self.game_time_end = 0\n\t        self.game_time_seconds = 0\n\t        self.leaderboard = []\n\t        match game_mode:\n\t            case Mode.SOLO:\n\t                self.grace_period_seconds = 3\n", "                self.game_time_seconds = 10 * 60\n\t            case Mode.SOLO_ELIMINATION:\n\t                self.grace_period_seconds = 3\n\t                self.game_time_seconds = 10 * 60\n\t            case Mode.TEAM:\n\t                self.grace_period_seconds = 3\n\t                self.game_time_seconds = 10 * 60\n\t            case Mode.TEAM_ELIMINATION:\n\t                self.grace_period_seconds = 3\n\t                self.game_time_seconds = 10 * 60\n", "    def start(self) -> bool:\n\t        if not self.game_started:\n\t            self.game_started = True\n\t            self.grace_period_end = time() + self.grace_period_seconds\n\t            self.game_time_end = 0\n\t        return self.game_started\n\t    def update_leaderboard(self, entities: list[GameEntity]):\n\t        self.leaderboard.clear()\n\t        if self.game_mode in [Mode.SOLO, Mode.SOLO_ELIMINATION]:\n\t            for entity in entities.values():\n", "                if isinstance(entity, Player):\n\t                    if self.game_mode == Mode.SOLO:\n\t                        self.leaderboard.append(\n\t                            [int(entity.score), entity.team, \"Name\"]\n\t                        )\n\t                    else:\n\t                        self.leaderboard.append(\n\t                            [entity.eliminations, entity.team, \"Name\"]\n\t                        )\n\t        elif self.game_mode in [Mode.TEAM, Mode.TEAM_ELIMINATION]:\n", "            teams = {}\n\t            for entity in entities.values():\n\t                if isinstance(entity, Player):\n\t                    if self.game_mode == Mode.TEAM:\n\t                        teams[entity.team] = teams.get(entity.team, 0) + entity.score\n\t                    else:\n\t                        teams[entity.team] = (\n\t                            teams.get(entity.team, 0) + entity.eliminations\n\t                        )\n\t            for team, score in teams.items():\n", "                self.leaderboard.append([int(score), team, team])\n\t        # Sort\n\t        self.leaderboard.sort(key=lambda element: element[0], reverse=True)\n\t    def update(self, entities: list[GameEntity]):\n\t        if not self.game_started:\n\t            for entity in entities.values():\n\t                entity.can_attack = False\n\t            return\n\t        # Time\n\t        if self.grace_period_end > 0 and time() > self.grace_period_end:\n", "            if self.game_time_end == 0:\n\t                self.game_time_end = time() + self.game_time_seconds\n\t                self.grace_period_end = 0\n\t                # End grace period (game started)\n\t                for entity in entities.values():\n\t                    entity.can_attack = True\n\t        elif self.game_time_end > 0 and time() > self.game_time_end:\n\t            self.game_started = False\n\t            self.game_time_end = 0\n\t            # End of game\n", "        # Leaderboard\n\t        self.update_leaderboard(entities)\n"]}
{"filename": "laser_tag/game/Team.py", "chunked_list": ["from enum import Enum\n\tclass Team(Enum):\n\t    \"\"\"Teams\"\"\"\n\t    def __str__(self):\n\t        return str(self.value)\n\t    NONE = -1\n\t    RED = 0\n\t    BLUE = 1\n\t    GREEN = 2\n\t    YELLOW = 3\n", "    ORANGE = 4\n\t    PINK = 5\n\t    BLACK = 6\n\t    WHITE = 7\n\tdef get_color(team):\n\t    try:\n\t        team = Team(team)\n\t    except ValueError:\n\t        team = Team.BLACK\n\t    match team:\n", "        case Team.NONE:\n\t            return (255, 0, 0)\n\t        case Team.RED:\n\t            return (255, 0, 0)\n\t        case Team.BLUE:\n\t            return (0, 0, 255)\n\t        case Team.GREEN:\n\t            return (0, 255, 0)\n\t        case Team.YELLOW:\n\t            return (255, 255, 0)\n", "        case Team.ORANGE:\n\t            return (255, 128, 0)\n\t        case Team.PINK:\n\t            return (255, 0, 255)\n\t        case Team.BLACK:\n\t            return (0, 0, 0)\n\t        case Team.WHITE:\n\t            return (255, 255, 255)\n"]}
{"filename": "laser_tag/configuration/__init__.py", "chunked_list": ["from .variables import *\n\tVARIABLES = Variables()\n\tVERSION = \"v0.0.7\"\n\tGAME_NAME = \"Laser Tag\"\n\tWINDOW_WINDOWED_SIZE_RATIO = 0.5\n\tTARGET_FPS = 60\n\tNETWORK_BUFFER_SIZE = 32768\n\tSERVER_DEFAULT_MAX_CLIENTS = None\n\tSERVER_DELTA_TIME_NAME = \"SERVER\"\n\tSERVER_TIMEOUT = 10\n", "SERVER_SOCKET_TIMEOUT = 2\n\tCLIENT_TIMEOUT = 5\n\tCLIENT_MINIMUM_TICK = 30\n\tMAX_RAY_DISTANCE = 50\n\tDEFAULT_FONT = {\"font\": \"calibri\", \"font_is_file\": False, \"size_multiplier\": 1}\n\tSCREENSHOTS_PATH = \"./screenshots\"\n"]}
{"filename": "laser_tag/configuration/variables.py", "chunked_list": ["class Variables:\n\t    def __init__(self):\n\t        # Default values\n\t        self.full_screen_width = 0\n\t        self.full_screen_height = 0\n\t        self.screen_width = self.full_screen_width\n\t        self.screen_height = self.full_screen_height\n\t        self.fullscreen = False\n\t        self.server_port = 16168\n\t        self.fps = 60\n", "        self.show_fps = True\n\t        self.show_network_stats = True\n\t        self.show_components_outline = False\n\t        self.show_rays_minimap = False\n\t        self.anti_aliased_text = True\n\t        self.debug = True\n\t        self.rotate_sensitivity = 0.05\n\t        self.pseudo = \"Player\"\n\t        self.fov = 80\n\t        self.rays_quantity = 1920 // 15\n", "        self.world_scale = 750\n\t        # Load from file\n\t        self.load()\n\t    def load(self):\n\t        pass\n\t    def set_full_screen_size(self, width, height):\n\t        self.full_screen_width = width\n\t        self.full_screen_height = height\n\t    def set_screen_size(self, width, height):\n\t        self.screen_width = width\n", "        self.screen_height = height\n"]}
{"filename": "laser_tag/entities/GameEntity.py", "chunked_list": ["from __future__ import annotations\n\tfrom time import time\n\tfrom ..math.Box import Box\n\tfrom ..math.Point import Point\n\tfrom .Entity import Entity\n\tclass GameEntity(Entity):\n\t    \"\"\"Entity with game specific properties\"\"\"\n\t    def __init__(self, position, length=1, width=1, height=1):\n\t        super().__init__(position, length, width, height)\n\t        self.move_speed = 0.05\n", "        self.run_speed_multiplier = 1.4\n\t        self.crouch_speed_multiplier = 0.8\n\t        # Attack cooldown (seconds)\n\t        self.attack_speed = 1\n\t        self.next_attack_timestamps = time()\n\t        self.damages = 1\n\t        self.can_move = True\n\t        self.can_attack = True\n\t        self.can_be_attacked = True\n\t        self.is_running = False\n", "        self.is_crouching = False\n\t        self.score = 0\n\t        self.score_reward = 0\n\t        self.eliminations = 0\n\t        self.deaths = 0\n\t        self.team = -1\n\t        self.hp = 0\n\t        self.set_max_hp(1)\n\t    def __repr__(self):\n\t        return f\"['{self.__class__.__name__}',{self.position},{self.collider},{self.rotation},{self.team},{self.score},{self.eliminations},{self.deaths},{self.hp},{self.next_attack_timestamps},{self.can_move},{self.can_attack}]\"\n", "    @staticmethod\n\t    def create(parsed_object) -> GameEntity:\n\t        try:\n\t            position = Point.create(parsed_object[0])\n\t            collider = Box.create(parsed_object[1])\n\t            if position is None or collider is None:\n\t                return None\n\t            entity = GameEntity(\n\t                position,\n\t                collider.length,\n", "                collider.width,\n\t                collider.height,\n\t            )\n\t            entity.rotation = float(parsed_object[2])\n\t            entity.team = int(parsed_object[3])\n\t            entity.score = float(parsed_object[4])\n\t            entity.eliminations = int(parsed_object[5])\n\t            entity.deaths = int(parsed_object[6])\n\t            entity.hp = float(parsed_object[7])\n\t            entity.next_attack_timestamps = float(parsed_object[8])\n", "            entity.can_move = bool(parsed_object[9])\n\t            entity.can_attack = bool(parsed_object[10])\n\t            return entity\n\t        except:\n\t            return None\n\t    def reset(self):\n\t        self.hp = self.max_hp\n\t        self.next_attack_timestamps = time()\n\t        self.score = 0\n\t        self.eliminations = 0\n", "        self.deaths = 0\n\t    def move(self, x, y, z):\n\t        if self.can_move:\n\t            super().move(x, y, z)\n\t    def set_max_hp(self, max_hp):\n\t        self.max_hp = max_hp\n\t        self.hp = self.max_hp\n\t    def death(self, no_deletion=False):\n\t        if not no_deletion:\n\t            self.alive = False\n", "        self.deaths += 1\n\t    def attack(self):\n\t        if (\n\t            self.can_attack\n\t            and time() >= self.next_attack_timestamps\n\t            and not self.is_running\n\t        ):\n\t            self.next_attack_timestamps = time() + self.attack_speed * (\n\t                self.crouch_speed_multiplier if self.is_crouching else 1\n\t            )\n", "            return True\n\t        return False\n\t    def damage(self, damage):\n\t        if self.can_be_attacked:\n\t            self.hp -= damage\n\t            self.hp = max(0, self.hp)\n\t            if self.hp == 0:\n\t                self.death()\n\t                # Killed\n\t                return True\n", "            # Damaged\n\t            return False\n\t        # Can't be attacked\n\t        return None\n\t    def heal(self, heal):\n\t        self.hp += heal\n\t        self.hp = min(self.max_hp, self.hp)\n\t    def on_hit(self, entity: GameEntity):\n\t        pass\n\t    def on_kill(self, entity: GameEntity):\n", "        self.eliminations += 1\n\t        self.score += entity.score_reward\n"]}
{"filename": "laser_tag/entities/Player.py", "chunked_list": ["from __future__ import annotations\n\tfrom ..math.Point import Point\n\tfrom .GameEntity import GameEntity\n\tclass Player(GameEntity):\n\t    \"\"\"Player entity\"\"\"\n\t    def __init__(self, position):\n\t        super().__init__(position, 0.4, 0.4, 1)\n\t        self.move_speed = 0.05\n\t        self.attack_speed = 0.25\n\t        self.damages = 1\n", "        self.score_reward = 100\n\t        self.set_max_hp(1)\n\t    def __repr__(self):\n\t        return f\"['{self.__class__.__name__}',{self.position},{self.rotation},{self.team},{self.score},{self.eliminations},{self.deaths},{self.hp},{self.next_attack_timestamps},{self.can_move},{self.can_attack}]\"\n\t    @staticmethod\n\t    def create(parsed_object) -> Player:\n\t        try:\n\t            position = Point.create(parsed_object[0])\n\t            if position is None:\n\t                return None\n", "            entity = Player(position)\n\t            entity.rotation = float(parsed_object[1])\n\t            entity.team = int(parsed_object[2])\n\t            entity.score = float(parsed_object[3])\n\t            entity.eliminations = int(parsed_object[4])\n\t            entity.deaths = int(parsed_object[5])\n\t            entity.hp = float(parsed_object[6])\n\t            entity.next_attack_timestamps = float(parsed_object[7])\n\t            entity.can_move = bool(parsed_object[8])\n\t            entity.can_attack = bool(parsed_object[9])\n", "            return entity\n\t        except:\n\t            return None\n\t    def death(self):\n\t        super().death(no_deletion=True)\n"]}
{"filename": "laser_tag/entities/__init__.py", "chunked_list": []}
{"filename": "laser_tag/entities/create_entity.py", "chunked_list": ["from .Entity import Entity\n\tfrom .GameEntity import GameEntity\n\tfrom .Player import Player\n\tfrom .Projectile import Projectile\n\tdef create_entity(parsed_object: list):\n\t    try:\n\t        entity_object = parsed_object[1:]\n\t        match parsed_object[0]:\n\t            case \"Entity\":\n\t                return Entity.create(entity_object)\n", "            case \"GameEntity\":\n\t                return GameEntity.create(entity_object)\n\t            case \"Player\":\n\t                return Player.create(entity_object)\n\t            case \"Projectile\":\n\t                return Projectile.create(entity_object)\n\t    except:\n\t        pass\n\t    return None\n"]}
{"filename": "laser_tag/entities/Projectile.py", "chunked_list": ["from __future__ import annotations\n\tfrom threading import Lock\n\tfrom ..math.Point import Point\n\tfrom .GameEntity import GameEntity\n\tclass Projectile(GameEntity):\n\t    \"\"\"Projectile entity\"\"\"\n\t    def __init__(self, position, parent_id=None):\n\t        super().__init__(position, 0.2, 0.2, 0.2)\n\t        self.move_speed = 0.2\n\t        self.attack_speed = 0\n", "        self.can_be_attacked = False\n\t        self.parent_id = parent_id\n\t        self.get_entity_fct = None\n\t        self.give_stats_to_parent_mutex = Lock()\n\t    def __repr__(self):\n\t        return f\"['{self.__class__.__name__}',{self.position},{self.rotation},{self.team},{self.damages},{self.score},{self.eliminations},{self.parent_id}]\"\n\t    @staticmethod\n\t    def create(parsed_object) -> Projectile:\n\t        try:\n\t            position = Point.create(parsed_object[0])\n", "            if position is None:\n\t                return None\n\t            entity = Projectile(position, parsed_object[6])\n\t            entity.rotation = float(parsed_object[1])\n\t            entity.team = int(parsed_object[2])\n\t            entity.damages = int(parsed_object[3])\n\t            entity.score = float(parsed_object[4])\n\t            entity.eliminations = int(parsed_object[5])\n\t            return entity\n\t        except:\n", "            return None\n\t    def on_hit(self, entity: GameEntity):\n\t        super().on_hit(entity)\n\t        self.death()\n\t    def on_kill(self, entity: GameEntity):\n\t        super().on_kill(entity)\n\t        self.give_stats_to_parent()\n\t    def death(self):\n\t        super().death()\n\t        self.give_stats_to_parent()\n", "    def give_stats_to_parent(self):\n\t        self.give_stats_to_parent_mutex.acquire()\n\t        if self.get_entity_fct is not None and (\n\t            self.eliminations > 0 or self.score > 0\n\t        ):\n\t            parent = self.get_entity_fct(self.parent_id)\n\t            if parent is not None:\n\t                # Add eliminations to parent\n\t                parent.eliminations += self.eliminations\n\t                self.eliminations = 0\n", "                # Add score to parent\n\t                parent.score += self.score\n\t                self.score = 0\n\t        self.give_stats_to_parent_mutex.release()\n"]}
{"filename": "laser_tag/entities/Entity.py", "chunked_list": ["from __future__ import annotations\n\tfrom ..math.Box import Box\n\tfrom ..math.Point import Point\n\tfrom ..network.safe_eval import safe_eval\n\tclass Entity:\n\t    \"\"\"Default entity\"\"\"\n\t    def __init__(self, position, length, width, height):\n\t        self.position = position\n\t        self.collider = Box(\n\t            Point(position.x - length / 2, position.y - width / 2, position.z),\n", "            length,\n\t            width,\n\t            height,\n\t        )\n\t        self.rotation = 0\n\t        self.alive = True\n\t    def __repr__(self):\n\t        return f\"['{self.__class__.__name__}',{self.position},{self.collider},{self.rotation}]\"\n\t    @staticmethod\n\t    def create(parsed_object) -> Entity:\n", "        try:\n\t            position = Point.create(parsed_object[0])\n\t            collider = Box.create(parsed_object[1])\n\t            if position is None or collider is None:\n\t                return None\n\t            entity = Entity(\n\t                position,\n\t                collider.length,\n\t                collider.width,\n\t                collider.height,\n", "            )\n\t            entity.rotation = float(parsed_object[2])\n\t            return entity\n\t        except:\n\t            return None\n\t    def move(self, x, y, z):\n\t        self.position.x = x\n\t        self.position.y = y\n\t        self.position.z = z\n\t        self.collider.origin.x = x - self.collider.length / 2\n", "        self.collider.origin.y = y - self.collider.width / 2\n\t        self.collider.origin.z = z\n\t    def collides_with(self, other):\n\t        return self.collider.collides_with(other.collider)\n"]}
