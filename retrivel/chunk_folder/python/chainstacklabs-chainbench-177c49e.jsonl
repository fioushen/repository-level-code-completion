{"filename": "chainbench/main.py", "chunked_list": ["import logging\n\timport os\n\timport shlex\n\timport subprocess\n\timport sys\n\tfrom multiprocessing import Process\n\tfrom pathlib import Path\n\timport click\n\tfrom locust import runners\n\tfrom chainbench.util.cli import (\n", "    ContextData,\n\t    ensure_results_dir,\n\t    get_base_path,\n\t    get_master_command,\n\t    get_profile_path,\n\t    get_worker_command,\n\t)\n\tfrom chainbench.util.monitor import monitors\n\tfrom chainbench.util.notify import NoopNotifier, Notifier\n\t# Default values for arguments\n", "MASTER_HOST = \"127.0.0.1\"\n\tMASTER_PORT = \"5557\"\n\tWORKER_COUNT = 16\n\tTEST_TIME = \"1h\"\n\tUSERS = 1000\n\tSPAWN_RATE = 10\n\tLOG_LEVEL = \"DEBUG\"\n\tDEFAULT_PROFILE = \"ethereum.general\"\n\tNOTIFY_URL_TEMPLATE = \"https://ntfy.sh/{topic}\"\n\trunners.HEARTBEAT_INTERVAL = 60\n", "logger = logging.getLogger(__name__)\n\t@click.group(\n\t    help=\"Tool for flexible blockchain infrastructure benchmarking.\",\n\t)\n\t@click.version_option(message=\"%(prog)s-%(version)s\")\n\t@click.pass_context\n\tdef cli(ctx: click.Context):\n\t    ctx.obj = ContextData()\n\t@cli.command(\n\t    help=\"Start the test using the configured profile. \"\n", "    \"By default, the results are saved in the \"\n\t    \"./results/{profile}/{YYYY-mm-dd_HH-MM-SS} directory.\",\n\t)\n\t@click.option(\n\t    \"-p\",\n\t    \"--profile\",\n\t    default=DEFAULT_PROFILE,\n\t    help=\"Profile to run\",\n\t    show_default=True,\n\t)\n", "@click.option(\"-d\", \"--profile-dir\", default=None, type=click.Path(), help=\"Profile directory\")\n\t@click.option(\"-H\", \"--host\", default=MASTER_HOST, help=\"Host to run on\", show_default=True)\n\t@click.option(\"-P\", \"--port\", default=MASTER_PORT, help=\"Port to run on\", show_default=True)\n\t@click.option(\n\t    \"-w\",\n\t    \"--workers\",\n\t    default=WORKER_COUNT,\n\t    help=\"Number of workers to run\",\n\t    show_default=True,\n\t)\n", "@click.option(\"-t\", \"--test-time\", default=TEST_TIME, help=\"Test time\", show_default=True)\n\t@click.option(\"-u\", \"--users\", default=USERS, help=\"Target number of users\", show_default=True)\n\t@click.option(\n\t    \"-r\",\n\t    \"--spawn-rate\",\n\t    default=SPAWN_RATE,\n\t    help=\"Number of users spawned per second\",\n\t    show_default=True,\n\t)\n\t@click.option(\"--log-level\", default=LOG_LEVEL, help=\"Log level\", show_default=True)\n", "@click.option(\n\t    \"--results-dir\",\n\t    default=Path(\"results\"),\n\t    help=\"Results directory\",\n\t    type=click.Path(),\n\t    show_default=True,\n\t)\n\t@click.option(\"--headless\", is_flag=True, help=\"Run in headless mode\")\n\t@click.option(\"--autoquit\", is_flag=True, help=\"Auto quit after test\")\n\t@click.option(\"--target\", default=None, help=\"Endpoint to test\")\n", "@click.option(\"--run-id\", default=None, help=\"ID of the test\")\n\t@click.option(\"--notify\", default=None, help=\"Notify when test is finished\")\n\t@click.option(\n\t    \"-m\",\n\t    \"--monitor\",\n\t    default=[],\n\t    help=\"Add a monitor to collect additional data or metrics. \"\n\t    \"You may specify this option multiple times for different monitors\",\n\t    type=click.Choice([\"head-lag-monitor\"], case_sensitive=False),\n\t    multiple=True,\n", ")\n\t@click.option(\n\t    \"--debug-trace-methods\",\n\t    is_flag=True,\n\t    help=\"Enable tasks tagged with debug or trace to be executed\",\n\t)\n\t@click.option(\n\t    \"-E\",\n\t    \"--exclude-tags\",\n\t    default=[],\n", "    help=\"Exclude tasks tagged with custom tags from the test. \" \"You may specify this option multiple times\",\n\t    multiple=True,\n\t)\n\t@click.option(\"--timescale\", is_flag=True, help=\"Export data to PG with timescale extension\")\n\t@click.option(\"--pg-host\", default=None, help=\"Hostname of PG instance with timescale extension\")\n\t@click.option(\n\t    \"--pg-port\",\n\t    default=5432,\n\t    help=\"Port of PG instance with timescale extension\",\n\t    show_default=True,\n", ")\n\t@click.option(\"--pg-username\", default=\"postgres\", help=\"PG username\", show_default=True)\n\t@click.option(\"--pg-password\", default=None, help=\"PG password\")\n\t@click.option(\"--use-recent-blocks\", is_flag=True, help=\"Uses recent blocks for test data\")\n\t@click.pass_context\n\tdef start(\n\t    ctx: click.Context,\n\t    profile: str,\n\t    profile_dir: Path | None,\n\t    host: str,\n", "    port: int,\n\t    workers: int,\n\t    test_time: str,\n\t    users: int,\n\t    spawn_rate: int,\n\t    log_level: str,\n\t    results_dir: Path,\n\t    headless: bool,\n\t    autoquit: bool,\n\t    target: str | None,\n", "    run_id: str | None,\n\t    notify: str | None,\n\t    monitor: list[str],\n\t    debug_trace_methods: bool,\n\t    exclude_tags: list[str],\n\t    timescale: bool,\n\t    pg_host: str | None,\n\t    pg_port: int,\n\t    pg_username: str,\n\t    pg_password: str | None,\n", "    use_recent_blocks: bool,\n\t):\n\t    if notify:\n\t        click.echo(f\"Notify when test is finished using topic: {notify}\")\n\t        notifier = Notifier(topic=notify)\n\t    else:\n\t        notifier = NoopNotifier()\n\t    ctx.obj.notifier = notifier\n\t    if headless and target is None:\n\t        click.echo(\"Target is required when running in headless mode\")\n", "        sys.exit(1)\n\t    if timescale and any(pg_arg is None for pg_arg in (pg_host, pg_port, pg_username, pg_password)):\n\t        click.echo(\n\t            \"PG connection parameters are required \"\n\t            \"when --timescale flag is used: pg_host, pg_port, pg_username, pg_password\"\n\t        )\n\t        sys.exit(1)\n\t    if not profile_dir:\n\t        profile_dir = get_base_path(__file__)\n\t    profile_path = get_profile_path(profile_dir, profile)\n", "    if not profile_path.exists():\n\t        click.echo(f\"Profile file {profile_path} does not exist\")\n\t        sys.exit(1)\n\t    results_dir = Path(results_dir).resolve()\n\t    click.echo(f\"Results directory: {results_dir}\")\n\t    results_path = ensure_results_dir(profile=profile, parent_dir=results_dir, run_id=run_id)\n\t    click.echo(f\"Results will be saved to {results_path}\")\n\t    custom_exclude_tags: list[str] = []\n\t    if exclude_tags:\n\t        for tag in exclude_tags:\n", "            custom_exclude_tags.append(tag)\n\t    if not debug_trace_methods:\n\t        custom_exclude_tags = custom_exclude_tags + [\"trace\", \"debug\"]\n\t    # Start the Locust master\n\t    master_command = get_master_command(\n\t        profile_path=profile_path,\n\t        host=host,\n\t        port=port,\n\t        test_time=test_time,\n\t        users=users,\n", "        spawn_rate=spawn_rate,\n\t        log_level=log_level,\n\t        results_path=results_path,\n\t        workers=workers,\n\t        headless=headless,\n\t        target=target,\n\t        exclude_tags=custom_exclude_tags,\n\t        timescale=timescale,\n\t        pg_host=pg_host,\n\t        pg_port=pg_port,\n", "        pg_username=pg_username,\n\t        pg_password=pg_password,\n\t        use_recent_blocks=use_recent_blocks,\n\t    )\n\t    if headless:\n\t        click.echo(f\"Starting master in headless mode for {profile}\")\n\t    else:\n\t        click.echo(f\"Starting master for {profile}\")\n\t    is_posix = os.name == \"posix\"\n\t    master_args = shlex.split(master_command, posix=is_posix)\n", "    master_process = subprocess.Popen(master_args)\n\t    ctx.obj.master = master_process\n\t    # Start the Locust workers\n\t    for worker_id in range(workers):\n\t        worker_command = get_worker_command(\n\t            profile_path=profile_path,\n\t            host=host,\n\t            port=port,\n\t            results_path=results_path,\n\t            headless=headless,\n", "            target=target,\n\t            worker_id=worker_id,\n\t            log_level=log_level,\n\t            exclude_tags=custom_exclude_tags,\n\t            timescale=timescale,\n\t            pg_host=pg_host,\n\t            pg_port=pg_port,\n\t            pg_username=pg_username,\n\t            pg_password=pg_password,\n\t            use_recent_blocks=use_recent_blocks,\n", "        )\n\t        worker_args = shlex.split(worker_command, posix=is_posix)\n\t        worker_process = subprocess.Popen(worker_args)\n\t        ctx.obj.workers.append(worker_process)\n\t        click.echo(f\"Starting worker {worker_id + 1} for {profile}\")\n\t    if headless:\n\t        click.echo(f\"Running test in headless mode for {profile}\")\n\t        ctx.obj.notifier.notify(\n\t            title=\"Test started\",\n\t            message=f\"Running test in headless mode for {profile}\",\n", "            tags=[\"loudspeaker\"],\n\t        )\n\t    else:\n\t        # Print out the URL to access the test\n\t        click.echo(f\"Run test: http://{host}:8089 {profile}\")\n\t    unique_monitors: set[str] = set(monitor)\n\t    for m in unique_monitors:\n\t        p = Process(target=monitors[m], args=(target, results_path, test_time))\n\t        click.echo(f\"Starting monitor {m}\")\n\t        p.start()\n", "        ctx.obj.monitors.append(p)\n\t    for process in ctx.obj.workers:\n\t        process.wait()\n\t    for process in ctx.obj.monitors:\n\t        process.join()\n\t    if autoquit:\n\t        ctx.obj.master.wait()\n\t        click.echo(\"Quitting...\")\n\t        ctx.obj.master.terminate()\n\t    ctx.obj.notifier.notify(title=\"Test finished\", message=f\"Test finished for {profile}\", tags=[\"tada\"])\n", "if __name__ == \"__main__\":\n\t    cli()\n"]}
{"filename": "chainbench/__main__.py", "chunked_list": ["from chainbench.main import cli\n\tcli()\n"]}
{"filename": "chainbench/__init__.py", "chunked_list": []}
{"filename": "chainbench/profile/__init__.py", "chunked_list": []}
{"filename": "chainbench/profile/evm/get_logs.py", "chunked_list": ["\"\"\"\n\t\"\"\"\n\tfrom locust import constant_pacing, task\n\tfrom chainbench.user.evm import EVMBenchUser\n\tfrom chainbench.util.rng import get_rng\n\tclass GetLogsProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(10)\n\t    @task\n\t    def get_logs_task(self):\n\t        self.make_call(\n", "            name=\"get_logs\",\n\t            method=\"eth_getLogs\",\n\t            params=self._get_logs_params_factory(get_rng()),\n\t        ),\n"]}
{"filename": "chainbench/profile/evm/light.py", "chunked_list": ["\"\"\"\n\tEthereum profile (light mode).\n\t\"\"\"\n\tfrom locust import constant_pacing, task\n\tfrom chainbench.user.evm import EVMBenchUser\n\tfrom chainbench.util.rng import get_rng\n\tclass EthereumLightProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(2)\n\t    @task\n\t    def get_transaction_receipt_task(self):\n", "        self.make_call(\n\t            name=\"get_transaction_receipt\",\n\t            method=\"eth_getTransactionReceipt\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @task\n\t    def block_number_task(self):\n\t        self.make_call(\n\t            name=\"block_number\",\n\t            method=\"eth_blockNumber\",\n", "            params=[],\n\t        ),\n\t    @task\n\t    def get_balance_task(self):\n\t        self.make_call(\n\t            name=\"get_balance\",\n\t            method=\"eth_getBalance\",\n\t            params=self._get_balance_params_factory_latest(get_rng()),\n\t        ),\n\t    @task\n", "    def chain_id_task(self):\n\t        self.make_call(\n\t            name=\"chain_id\",\n\t            method=\"eth_chainId\",\n\t            params=[],\n\t        ),\n\t    @task\n\t    def get_block_by_number_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_number\",\n", "            method=\"eth_getBlockByNumber\",\n\t            params=self._block_params_factory(get_rng()),\n\t        ),\n\t    @task\n\t    def get_transaction_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_by_hash\",\n\t            method=\"eth_getTransactionByHash\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n", "    @task\n\t    def client_version_task(self):\n\t        self.make_call(\n\t            name=\"client_version\",\n\t            method=\"web3_clientVersion\",\n\t            params=[],\n\t        ),\n"]}
{"filename": "chainbench/profile/evm/heavy.py", "chunked_list": ["\"\"\"\n\tEthereum profile (heavy mode).\n\t\"\"\"\n\tfrom random import randint\n\tfrom locust import constant_pacing, tag, task\n\tfrom chainbench.user.evm import EVMBenchUser\n\tfrom chainbench.util.rng import get_rng\n\tclass EthereumHeavyProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(10)\n\t    @task\n", "    def debug_trace_transaction_task(self):\n\t        self.make_call(\n\t            name=\"debug_trace_transaction\",\n\t            method=\"debug_traceTransaction\",\n\t            params=self._trace_transaction_params_factory(get_rng()),\n\t        ),\n\t    @task\n\t    def trace_block_task(self):\n\t        self.make_call(\n\t            name=\"trace_block\",\n", "            method=\"trace_block\",\n\t            params=self._block_params_factory(get_rng()),\n\t        ),\n\t    @tag(\"get-logs\")\n\t    @task\n\t    def eth_get_logs_task(self):\n\t        self.make_call(\n\t            name=\"eth_get_logs\",\n\t            method=\"eth_getLogs\",\n\t            params=self._get_logs_params_factory(get_rng()),\n", "        ),\n\t    @task\n\t    def eth_get_blocks_receipts_task(self):\n\t        self.make_call(\n\t            name=\"eth_get_block_receipts\",\n\t            method=\"eth_getBlockReceipts\",\n\t            params=[hex(self.test_data.get_random_block_number(get_rng()))],\n\t        )\n\t    @task\n\t    def trace_replay_transaction_task(self):\n", "        self.make_call(\n\t            name=\"trace_replay_transaction\",\n\t            method=\"trace_replayTransaction\",\n\t            params=self._trace_replay_transaction_params_factory(get_rng()),\n\t        )\n\t    @task\n\t    def trace_replay_block_transactions_task(self):\n\t        self.make_call(\n\t            name=\"trace_replay_block_transactions\",\n\t            method=\"trace_replayBlockTransactions\",\n", "            params=self._trace_replay_block_transaction_params_factory(get_rng()),\n\t        )\n\t    @task\n\t    def trace_call_task(self):\n\t        self.make_call(\n\t            name=\"trace_call\",\n\t            method=\"trace_call\",\n\t            params=[\n\t                {\n\t                    \"to\": \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n", "                    \"data\": \"0x70a082310000000000000000000000006E0d01A76C3Cf4288372a29124A26D4353EE51BE\",  # noqa E501\n\t                },\n\t                [\"trace\"],\n\t                \"latest\",\n\t            ],\n\t        )\n\t    @task\n\t    def trace_filter_task(self):\n\t        self.make_call(\n\t            name=\"trace_filter\",\n", "            method=\"trace_filter\",\n\t            params=self._trace_filter_params_factory(get_rng()),\n\t        )\n\t    @task\n\t    def debug_trace_call_task(self):\n\t        self.make_call(\n\t            name=\"debug_trace_call\",\n\t            method=\"debug_traceCall\",\n\t            params=[\n\t                {\n", "                    \"data\": \"0xd0e30db0\",\n\t                    \"from\": \"0x035C9c507149Fa30b17F9735BF97B4642C73464f\",\n\t                    \"gas\": \"0x1E9EF\",\n\t                    \"gasPrice\": \"0xBD32B2ABC\",\n\t                    \"to\": \"0x0000000000a39bb272e79075ade125fd351887ac\",\n\t                },\n\t                \"latest\",\n\t                {\"tracer\": \"callTracer\"},\n\t            ],\n\t        )\n", "    @task\n\t    def debug_storage_range_at_task(self):\n\t        self.make_call(\n\t            name=\"debug_storage_range_at\",\n\t            method=\"debug_storageRangeAt\",\n\t            params=[\n\t                \"0x99136e1fd072ff630537cf7231c355a6839d848f7673026a7b100a92b26c9f4b\",\n\t                0,\n\t                \"0x27C70Cd1946795B66be9d954418546998b546634\",\n\t                \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n", "                randint(1000, 10000),\n\t            ],\n\t        )\n\t    @task\n\t    def debug_trace_block_by_number_task(self):\n\t        self.make_call(\n\t            name=\"debug_trace_block_by_number\",\n\t            method=\"debug_traceBlockByNumber\",\n\t            params=self._trace_block_by_number_params_factory(get_rng()),\n\t        )\n", "    @task\n\t    def debug_trace_block_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"debug_trace_block_by_hash\",\n\t            method=\"debug_traceBlockByHash\",\n\t            params=self._trace_block_by_hash_params_factory(get_rng()),\n\t        )\n\t    @task\n\t    def eth_estimate_gas_task(self):\n\t        self.make_call(\n", "            name=\"eth_estimate_gas\",\n\t            method=\"eth_estimateGas\",\n\t            params=self._eth_estimate_gas_params_factory(get_rng()),\n\t        )\n"]}
{"filename": "chainbench/profile/oasis/general.py", "chunked_list": ["from locust import constant_pacing, task\n\tfrom chainbench.user.evm import EVMBenchUser\n\tfrom chainbench.util.rng import get_rng\n\tclass OasisProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(2)\n\t    @task\n\t    def get_block_by_number_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_number\",\n\t            method=\"eth_getBlockByNumber\",\n", "            params=self._block_params_factory(get_rng()),\n\t        ),\n\t    @task\n\t    def get_balance_task(self):\n\t        self.make_call(\n\t            name=\"get_balance\",\n\t            method=\"eth_getBalance\",\n\t            params=self._get_balance_params_factory(get_rng()),\n\t        ),\n\t    @task\n", "    def get_transaction_count_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_count\",\n\t            method=\"eth_getTransactionCount\",\n\t            params=self._get_balance_params_factory(get_rng()),\n\t        ),\n\t    @task\n\t    def get_code_task(self):\n\t        self.make_call(\n\t            name=\"get_code\",\n", "            method=\"eth_getCode\",\n\t            params=self._get_balance_params_factory(get_rng()),\n\t        ),\n\t    @task\n\t    def get_transaction_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_by_hash\",\n\t            method=\"eth_getTransactionByHash\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n", "    @task\n\t    def get_block_number_task(self):\n\t        self.make_call(\n\t            name=\"block_number\",\n\t            method=\"eth_blockNumber\",\n\t        ),\n\t    @task\n\t    def get_syncing_task(self):\n\t        self.make_call(\n\t            name=\"get_syncing\",\n", "            method=\"eth_syncing\",\n\t        ),\n\t    @task\n\t    def get_block_transaction_count_by_number_task(self):\n\t        self.make_call(\n\t            name=\"get_block_transaction_count_by_number\",\n\t            method=\"eth_getBlockTransactionCountByNumber\",\n\t            params=self._random_block_number_params_factory(get_rng()),\n\t        ),\n"]}
{"filename": "chainbench/profile/bsc/general.py", "chunked_list": ["\"\"\"\n\tBsc profile.\n\tChart:\n\t```mermaid\n\t%%{init: {'theme':'forest'}}%%\n\tpie title Methods Distribution\n\t    \"eth_call\" : 100\n\t    \"eth_getTransactionReceipt\" : 93\n\t    \"eth_getLogs\" : 36\n\t    \"eth_blockNumber\" : 28\n", "    \"eth_chainId\" : 18\n\t    \"eth_getBlockByNumber\" : 13\n\t    \"Others\" : 20\n\t```\n\t\"\"\"\n\tfrom locust import constant_pacing, tag, task\n\tfrom chainbench.user.evm import EVMBenchUser\n\tfrom chainbench.util.rng import get_rng\n\tclass BscProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(2)\n", "    weight = 89\n\t    @task(100)\n\t    def call_task(self):\n\t        self.make_call(\n\t            name=\"call\",\n\t            method=\"eth_call\",\n\t            params=[\n\t                {\n\t                    \"to\": \"0x55d398326f99059fF775485246999027B3197955\",\n\t                    \"data\": \"0x70a08231000000000000000000000000f977814e90da44bfa03b6295a0616a897441acec\",  # noqa: E501\n", "                },\n\t                \"latest\",\n\t            ],\n\t        ),\n\t    @task(93)\n\t    def get_transaction_receipt_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_receipt\",\n\t            method=\"eth_getTransactionReceipt\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n", "        ),\n\t    @task(28)\n\t    def block_number_task(self):\n\t        self.make_call(\n\t            name=\"block_number\",\n\t            method=\"eth_blockNumber\",\n\t            params=[],\n\t        ),\n\t    @task(18)\n\t    def chain_id_task(self):\n", "        self.make_call(\n\t            name=\"chain_id\",\n\t            method=\"eth_chainId\",\n\t            params=[],\n\t        ),\n\t    @task(13)\n\t    def get_block_by_number_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_number\",\n\t            method=\"eth_getBlockByNumber\",\n", "            params=self._block_params_factory(get_rng()),\n\t        ),\n\t    @task(9)\n\t    def get_transaction_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_by_hash\",\n\t            method=\"eth_getTransactionByHash\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @task(5)\n", "    def get_balance_task(self):\n\t        self.make_call(\n\t            name=\"get_balance\",\n\t            method=\"eth_getBalance\",\n\t            params=self._get_balance_params_factory_latest(get_rng()),\n\t        ),\n\t    @task(3)\n\t    def get_block_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_hash\",\n", "            method=\"eth_getBlockByHash\",\n\t            params=self._block_by_hash_params_factory(get_rng()),\n\t        ),\n\tclass GetLogsProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(10)\n\t    weight = 12\n\t    @tag(\"get-logs\")\n\t    @task\n\t    def get_logs_task(self):\n\t        self.make_call(\n", "            name=\"get_logs\",\n\t            method=\"eth_getLogs\",\n\t            params=self._get_logs_params_factory(get_rng()),\n\t        ),\n"]}
{"filename": "chainbench/profile/polygon/general.py", "chunked_list": ["\"\"\"\n\tPolygon profile.\n\tNote, that eth_sendRawTransaction is excluded from the test because it requires\n\tbuilding a transaction and signing it.\n\tChart:\n\t```mermaid\n\t%%{init: {'theme':'forest'}}%%\n\tpie title Methods Distribution\n\t    \"eth_call\" : 100\n\t    \"eth_getTransactionReceipt\" : 64\n", "    \"eth_chainId\" : 20\n\t    \"eth_getBlockByNumber\" : 17\n\t    \"eth_blockNumber\" : 16\n\t    \"eth_getTransactionByHash\" : 11\n\t    \"eth_getLogs\" : 11\n\t    \"Others\" : 9\n\t```\n\t\"\"\"\n\tfrom locust import constant_pacing, tag, task\n\tfrom chainbench.user.evm import EVMBenchUser\n", "from chainbench.util.rng import get_rng\n\tclass PolygonGeneral(EVMBenchUser):\n\t    wait_time = constant_pacing(2)\n\t    weight = 19\n\t    @task(100)\n\t    def call_task(self):\n\t        self.make_call(\n\t            name=\"call\",\n\t            method=\"eth_call\",\n\t            params=[\n", "                {\n\t                    \"to\": \"0xc2132D05D31c914a87C6611C10748AEb04B58e8F\",\n\t                    \"data\": \"0x70a08231000000000000000000000000F977814e90dA44bFA03b6295A0616a897441aceC\",  # noqa: E501\n\t                },\n\t                \"latest\",\n\t            ],\n\t        ),\n\t    @task(64)\n\t    def get_transaction_receipt_task(self):\n\t        self.make_call(\n", "            name=\"get_transaction_receipt\",\n\t            method=\"eth_getTransactionReceipt\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @task(20)\n\t    def chain_id_task(self):\n\t        self.make_call(\n\t            name=\"chain_id\",\n\t            method=\"eth_chainId\",\n\t            params=[],\n", "        ),\n\t    @task(17)\n\t    def get_block_by_number_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_number\",\n\t            method=\"eth_getBlockByNumber\",\n\t            params=self._block_params_factory(get_rng()),\n\t        ),\n\t    @task(16)\n\t    def block_number_task(self):\n", "        self.make_call(\n\t            name=\"block_number\",\n\t            method=\"eth_blockNumber\",\n\t            params=[],\n\t        ),\n\t    @task(11)\n\t    def get_transaction_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_by_hash\",\n\t            method=\"eth_getTransactionByHash\",\n", "            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @task(4)\n\t    def get_balance_task(self):\n\t        self.make_call(\n\t            name=\"get_balance\",\n\t            method=\"eth_getBalance\",\n\t            params=self._get_balance_params_factory_latest(get_rng()),\n\t        ),\n\t    @tag(\"trace\")\n", "    @task(2)\n\t    def block_task(self):\n\t        self.make_call(\n\t            name=\"block\",\n\t            method=\"trace_block\",\n\t            params=self._block_params_factory(get_rng()),\n\t        ),\n\tclass GetLogsProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(10)\n\t    weight = 1\n", "    @tag(\"get-logs\")\n\t    @task\n\t    def get_logs_task(self):\n\t        self.make_call(\n\t            name=\"get_logs\",\n\t            method=\"eth_getLogs\",\n\t            params=self._get_logs_params_factory(get_rng()),\n\t        ),\n"]}
{"filename": "chainbench/profile/solana/general.py", "chunked_list": ["\"\"\"\n\tSolana profile.\n\tChart:\n\t```mermaid\n\t%%{init: {'theme':'forest'}}%%\n\tpie title Methods Distribution\n\t    \"getAccountInfo\" : 53\n\t    \"getBlock\" : 9\n\t    \"getTokenAccountsByOwner\" : 8\n\t    \"getMultipleAccounts\" : 8\n", "    \"getTransaction\" : 7\n\t    \"getSignaturesForAddress\" : 4\n\t    \"getLatestBlockhash\" : 4\n\t    \"getBalance\" : 4\n\t    \"Others\" : 3\n\t```\n\t\"\"\"\n\tfrom locust import constant_pacing, tag, task\n\tfrom chainbench.user.solana import SolanaBenchUser\n\tfrom chainbench.util.rng import get_rng\n", "class SolanaProfile(SolanaBenchUser):\n\t    wait_time = constant_pacing(2)\n\t    @task(1000)\n\t    def get_account_info_task(self):\n\t        self.make_call(\n\t            method=\"getAccountInfo\",\n\t            params=self._get_account_info_params_factory(get_rng()),\n\t        ),\n\t    @task(175)\n\t    def get_block_task(self):\n", "        self.make_call(\n\t            method=\"getBlock\",\n\t            params=self._get_block_params_factory(get_rng()),\n\t        ),\n\t    @task(150)\n\t    def get_token_accounts_by_owner(self):\n\t        self.make_call(\n\t            method=\"getTokenAccountsByOwner\",\n\t            params=self._get_token_accounts_by_owner_params_factory(get_rng()),\n\t        ),\n", "    @task(150)\n\t    def get_multiple_accounts(self):\n\t        self.make_call(\n\t            method=\"getMultipleAccounts\",\n\t            params=self._get_multiple_accounts_params_factory(get_rng()),\n\t        ),\n\t    @task(130)\n\t    def get_transaction(self):\n\t        self.make_call(\n\t            method=\"getTransaction\",\n", "            params=self._get_transaction_params_factory(get_rng()),\n\t        ),\n\t    @task(75)\n\t    def get_signatures_for_address(self):\n\t        self.make_call(\n\t            method=\"getSignaturesForAddress\",\n\t            params=self._get_signatures_for_address_params_factory(get_rng()),\n\t        ),\n\t    @task(75)\n\t    def get_latest_blockhash(self):\n", "        self.make_call(\n\t            method=\"getLatestBlockhash\",\n\t            params=[],\n\t        ),\n\t    @task(75)\n\t    def get_balance(self):\n\t        self.make_call(\n\t            method=\"getBalance\",\n\t            params=self._get_balance_params_factory(get_rng()),\n\t        ),\n", "    @task(20)\n\t    def get_slot(self):\n\t        self.make_call(\n\t            method=\"getSlot\",\n\t            params=[],\n\t        ),\n\t    @task(15)\n\t    def get_block_height(self):\n\t        self.make_call(\n\t            method=\"getBlockHeight\",\n", "            params=[],\n\t        ),\n\t    @task(5)\n\t    @tag(\"get-program-accounts\")\n\t    def get_program_accounts(self):\n\t        self.make_call(\n\t            method=\"getProgramAccounts\",\n\t            params=[\n\t                \"SharkXwkS3h24fJ2LZvgG5tPbsH3BKQYuAtKdqskf1f\",\n\t                {\"encoding\": \"base64\", \"commitment\": \"confirmed\"},\n", "            ],\n\t        ),\n\t    @task(4)\n\t    def get_signature_statuses(self):\n\t        self.make_call(\n\t            method=\"getSignatureStatuses\",\n\t            params=self._get_signature_statuses_params_factory(get_rng()),\n\t        ),\n\t    @task(3)\n\t    def get_recent_blockhash(self):\n", "        self.make_call(\n\t            method=\"getRecentBlockhash\",\n\t            params=[],\n\t        ),\n\t    @task(2)\n\t    def get_blocks(self):\n\t        self.make_call(\n\t            method=\"getBlocks\",\n\t            params=self._get_blocks_params_factory(get_rng()),\n\t        ),\n", "    @task(2)\n\t    def get_epoch_info(self):\n\t        self.make_call(\n\t            method=\"getEpochInfo\",\n\t            params=[],\n\t        ),\n\t    @task(2)\n\t    def get_confirmed_signatures_for_address2(self):\n\t        self.make_call(\n\t            method=\"getConfirmedSignaturesForAddress2\",\n", "            params=self._get_confirmed_signatures_for_address2_params_factory(get_rng()),\n\t        ),\n"]}
{"filename": "chainbench/profile/ethereum/general.py", "chunked_list": ["\"\"\"\n\tEthereum profile.\n\tChart:\n\t```mermaid\n\t%%{init: {'theme':'forest'}}%%\n\tpie title Methods Distribution\n\t    \"eth_call\" : 100\n\t    \"eth_getTransactionReceipt\" : 24\n\t    \"eth_blockNumber\" : 19\n\t    \"eth_getBalance\" : 12\n", "    \"eth_chainId\" : 11\n\t    \"eth_getBlockByNumber\" : 9\n\t    \"eth_getTransactionByHash\" : 8\n\t    \"Others\" : 12\n\t```\n\t\"\"\"\n\tfrom locust import constant_pacing, tag, task\n\tfrom chainbench.user.evm import EVMBenchUser\n\tfrom chainbench.util.rng import get_rng\n\tclass EthereumProfile(EVMBenchUser):\n", "    wait_time = constant_pacing(2)\n\t    weight = 487\n\t    @task(100)\n\t    def call_task(self):\n\t        self.make_call(\n\t            name=\"call\",\n\t            method=\"eth_call\",\n\t            params=[\n\t                {\n\t                    \"to\": \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n", "                    \"data\": \"0x70a082310000000000000000000000009696f59E4d72E237BE84fFD425DCaD154Bf96976\",  # noqa: E501\n\t                },\n\t                \"latest\",\n\t            ],\n\t        ),\n\t    @task(24)\n\t    def get_transaction_receipt_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_receipt\",\n\t            method=\"eth_getTransactionReceipt\",\n", "            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @task(19)\n\t    def block_number_task(self):\n\t        self.make_call(\n\t            name=\"block_number\",\n\t            method=\"eth_blockNumber\",\n\t            params=[],\n\t        ),\n\t    @task(12)\n", "    def get_balance_task(self):\n\t        self.make_call(\n\t            name=\"get_balance\",\n\t            method=\"eth_getBalance\",\n\t            params=self._get_balance_params_factory_latest(get_rng()),\n\t        ),\n\t    @task(11)\n\t    def chain_id_task(self):\n\t        self.make_call(\n\t            name=\"chain_id\",\n", "            method=\"eth_chainId\",\n\t            params=[],\n\t        ),\n\t    @task(9)\n\t    def get_block_by_number_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_number\",\n\t            method=\"eth_getBlockByNumber\",\n\t            params=self._block_params_factory(get_rng()),\n\t        ),\n", "    @task(8)\n\t    def get_transaction_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_by_hash\",\n\t            method=\"eth_getTransactionByHash\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @tag(\"debug\")\n\t    @task(3)\n\t    def trace_transaction_task(self):\n", "        self.make_call(\n\t            name=\"trace_transaction\",\n\t            method=\"debug_traceTransaction\",\n\t            params=[],\n\t        ),\n\t    @task(2)\n\t    def client_version_task(self):\n\t        self.make_call(\n\t            name=\"client_version\",\n\t            method=\"web3_clientVersion\",\n", "            params=[],\n\t        ),\n\tclass GetLogsProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(10)\n\t    weight = 13\n\t    @tag(\"get-logs\")\n\t    @task\n\t    def get_logs_task(self):\n\t        self.make_call(\n\t            name=\"get_logs\",\n", "            method=\"eth_getLogs\",\n\t            params=self._get_logs_params_factory(get_rng()),\n\t        ),\n"]}
{"filename": "chainbench/profile/avalanche/general.py", "chunked_list": ["\"\"\"\n\tAvalanche profile.\n\tChart:\n\t```mermaid\n\t%%{init: {'theme':'forest'}}%%\n\tpie title Methods Distribution\n\t    \"eth_call\" : 100\n\t    \"eth_getBlockByNumber\" : 50\n\t    \"eth_getLogs\" : 24\n\t    \"eth_getTransactionReceipt\" : 17\n", "    \"eth_chainId\" : 15\n\t    \"eth_blockNumber\" : 15\n\t    \"eth_getBalance\" : 11\n\t    \"Others\" : 28\n\t```\n\t\"\"\"\n\tfrom locust import constant_pacing, tag, task\n\tfrom chainbench.user.evm import EVMBenchUser\n\tfrom chainbench.util.rng import get_rng\n\tclass AvalancheProfile(EVMBenchUser):\n", "    wait_time = constant_pacing(2)\n\t    weight = 91\n\t    @task(100)\n\t    def call_task(self):\n\t        self.make_call(\n\t            name=\"call\",\n\t            method=\"eth_call\",\n\t            params=[\n\t                {\n\t                    \"to\": \"0x7325e3564B89968D102B3261189EA44c0f5f1a8e\",\n", "                    \"data\": \"0x18160ddd0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n\t                },\n\t                \"latest\",\n\t            ],\n\t        ),\n\t    @task(50)\n\t    def get_block_by_number_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_number\",\n\t            method=\"eth_getBlockByNumber\",\n", "            params=self._block_params_factory(get_rng()),\n\t        ),\n\t    @task(17)\n\t    def get_transaction_receipt_task(self):\n\t        self.make_call(\n\t            name=\"get_transaction_receipt\",\n\t            method=\"eth_getTransactionReceipt\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @task(15)\n", "    def chain_id_task(self):\n\t        self.make_call(\n\t            name=\"chain_id\",\n\t            method=\"eth_chainId\",\n\t        ),\n\t    @task(15)\n\t    def block_number_task(self):\n\t        self.make_call(\n\t            name=\"block_number\",\n\t            method=\"eth_blockNumber\",\n", "        ),\n\t    @task(11)\n\t    def get_balance_task(self):\n\t        self.make_call(\n\t            name=\"get_balance\",\n\t            method=\"eth_getBalance\",\n\t            params=self._get_balance_params_factory_latest(get_rng()),\n\t        ),\n\t    @task(10)\n\t    def get_transaction_by_hash_task(self):\n", "        self.make_call(\n\t            name=\"get_transaction_by_hash\",\n\t            method=\"eth_getTransactionByHash\",\n\t            params=self._transaction_by_hash_params_factory(get_rng()),\n\t        ),\n\t    @task(5)\n\t    def estimate_gas_task(self):\n\t        self.make_call(\n\t            name=\"estimate_gas\",\n\t            method=\"eth_estimateGas\",\n", "            params=[\n\t                {\n\t                    \"from\": \"0x9f8c163cBA728e99993ABe7495F06c0A3c8Ac8b9\",\n\t                    \"to\": \"0xC2DE4f542C2e2349ee050541F5AD25aa4BE1a00f\",\n\t                    \"value\": \"0xde0b6b3a7640000\",\n\t                }\n\t            ],\n\t        ),\n\t    @task(4)\n\t    def client_version_task(self):\n", "        self.make_call(\n\t            name=\"client_version\",\n\t            method=\"web3_clientVersion\",\n\t        ),\n\t    @task(3)\n\t    def get_block_by_hash_task(self):\n\t        self.make_call(\n\t            name=\"get_block_by_hash\",\n\t            method=\"eth_getBlockByHash\",\n\t            params=self._block_by_hash_params_factory(get_rng()),\n", "        ),\n\t    @task(3)\n\t    def gas_price_task(self):\n\t        self.make_call(\n\t            name=\"gas_price\",\n\t            method=\"eth_gasPrice\",\n\t        ),\n\t    @task(3)\n\t    def max_priority_fee_per_gas_task(self):\n\t        self.make_call(\n", "            name=\"max_priority_fee_per_gas\",\n\t            method=\"eth_maxPriorityFeePerGas\",\n\t        ),\n\tclass GetLogsProfile(EVMBenchUser):\n\t    wait_time = constant_pacing(10)\n\t    weight = 9\n\t    @tag(\"get-logs\")\n\t    @task\n\t    def get_logs_task(self):\n\t        self.make_call(\n", "            name=\"get_logs\",\n\t            method=\"eth_getLogs\",\n\t            params=self._get_logs_params_factory(get_rng()),\n\t        ),\n"]}
{"filename": "chainbench/user/base.py", "chunked_list": ["import logging\n\timport typing as t\n\tfrom locust import FastHttpUser\n\tfrom locust.contrib.fasthttp import RestResponseContextManager\n\tfrom locust.exception import RescheduleTask\n\tfrom chainbench.test_data import BaseTestData, DummyTestData\n\tfrom chainbench.util.event import setup_event_listeners\n\tfrom chainbench.util.rng import RNGManager\n\tfrom chainbench.util.rpc import generate_request\n\t# importing plugins here as all profiles depend on it\n", "import locust_plugins  # isort: skip  # noqa\n\tsetup_event_listeners()\n\tclass BaseBenchUser(FastHttpUser):\n\t    \"\"\"Base class for all benchmark users.\"\"\"\n\t    abstract = True\n\t    rpc_path: str = \"\"\n\t    connection_timeout = 120\n\t    network_timeout = 360\n\t    test_data: BaseTestData = DummyTestData()\n\t    def __init__(self, *args, **kwargs):\n", "        super().__init__(*args, **kwargs)\n\t        self.logger = logging.getLogger(__name__)\n\t        self.rng = RNGManager()\n\t    def on_start(self):\n\t        self.test_data.wait()\n\t    def on_stop(self):\n\t        self.test_data.close()\n\t    def check_fatal(self, response: RestResponseContextManager):\n\t        if response.status_code == 401:\n\t            self.logger.critical(f\"Unauthorized request to {response.url}\")\n", "        elif response.status_code == 404:\n\t            self.logger.critical(f\"Not found: {response.url}\")\n\t        elif 500 <= response.status_code <= 599:\n\t            self.logger.critical(f\"Got internal server error when requesting {response.url}\")\n\t        elif 300 <= response.status_code <= 399:\n\t            self.logger.critical(f\"Redirect error: {response.url}\")\n\t    def check_response(self, response: RestResponseContextManager, name: str):\n\t        \"\"\"Check the response for errors.\"\"\"\n\t        if response.status_code != 200:\n\t            self.logger.info(f\"Request failed with {response.status_code} code\")\n", "            self.logger.debug(\n\t                f\"Request to {response.url} failed with {response.status_code} code: {response.text}\"  # noqa: E501\n\t            )\n\t            self.check_fatal(response)\n\t            response.failure(f\"Request failed with {response.status_code} code\")\n\t            response.raise_for_status()\n\t        if response.request:\n\t            self.logger.debug(f\"Request: {response.request.body}\")\n\t        if response.js is None:\n\t            self.logger.error(f\"Response for {name}  is not a JSON: {response.text}\")\n", "            response.failure(f\"Response for {name}  is not a JSON\")\n\t            raise RescheduleTask()\n\t        if \"jsonrpc\" not in response.js:\n\t            self.logger.error(f\"Response for {name} is not a JSON-RPC: {response.text}\")\n\t            response.failure(f\"Response for {name} is not a JSON-RPC\")\n\t            raise RescheduleTask()\n\t        if \"error\" in response.js:\n\t            self.logger.error(f\"Response for {name} has a JSON-RPC error: {response.text}\")\n\t            if \"code\" in response.js[\"error\"]:\n\t                response.failure(\n", "                    f\"Response for {name} has a JSON-RPC error {response.js['error']['code']}\"  # noqa: E501\n\t                )\n\t                raise RescheduleTask()\n\t            response.failure(\"Unspecified JSON-RPC error\")\n\t            raise RescheduleTask()\n\t        if not response.js.get(\"result\"):\n\t            self.logger.error(f\"Response for {name} call has no result: {response.text}\")\n\t    def make_call(self, method: str, params: list[t.Any] | None = None, name: str | None = None):\n\t        name = name if name else method\n\t        return self._post(name, data=generate_request(method, params))\n", "    def _post(self, name: str, data: t.Optional[dict] = None):\n\t        \"\"\"Make a JSON-RPC call.\"\"\"\n\t        with self.rest(\"POST\", self.rpc_path, json=data, name=name) as response:\n\t            self.check_response(response, name=name)\n"]}
{"filename": "chainbench/user/__init__.py", "chunked_list": []}
{"filename": "chainbench/user/evm.py", "chunked_list": ["import random\n\tfrom chainbench.test_data import EVMTestData\n\tfrom chainbench.user.base import BaseBenchUser\n\tfrom chainbench.util.rng import RNG\n\tclass EVMBenchUser(BaseBenchUser):\n\t    abstract = True\n\t    test_data = EVMTestData()\n\t    def _get_logs_params_factory(self, rng: RNG):\n\t        return [\n\t            {\n", "                \"fromBlock\": hex(self.test_data.get_random_recent_block_number(20, rng)),\n\t                \"toBlock\": hex(self.test_data.end_block_number),\n\t            }\n\t        ]\n\t    def _transaction_by_hash_params_factory(self, rng: RNG):\n\t        return [self.test_data.get_random_tx_hash(rng)]\n\t    def _random_block_number_params_factory(self, rng: RNG):\n\t        return [hex(self.test_data.get_random_block_number(rng))]\n\t    def _block_params_factory(self, rng: RNG):\n\t        return [hex(self.test_data.get_random_block_number(rng)), True]\n", "    def _block_by_hash_params_factory(self, rng: RNG):\n\t        return [self.test_data.get_random_block_hash(rng), True]\n\t    def _get_balance_params_factory_latest(self, rng: RNG):\n\t        return [self.test_data.get_random_account(rng), \"latest\"]\n\t    def _get_balance_params_factory(self, rng: RNG):\n\t        return [\n\t            self.test_data.get_random_account(rng),\n\t            hex(self.test_data.get_random_block_number(rng)),\n\t        ]\n\t    def _trace_block_by_number_params_factory(self, rng: RNG):\n", "        return [\n\t            hex(self.test_data.get_random_block_number(rng)),\n\t            {\"tracer\": \"callTracer\"},\n\t        ]\n\t    def _trace_block_by_hash_params_factory(self, rng: RNG):\n\t        return [\n\t            self.test_data.get_random_block_hash(rng),\n\t            {\"tracer\": \"callTracer\"},\n\t        ]\n\t    def _trace_replay_block_transaction_params_factory(self, rng: RNG):\n", "        return [\n\t            hex(self.test_data.get_random_block_number(rng)),\n\t            [\"vmTrace\", \"trace\", \"stateDiff\"],\n\t        ]\n\t    def _trace_replay_transaction_params_factory(self, rng: RNG):\n\t        return [\n\t            self.test_data.get_random_tx_hash(rng),\n\t            [\"vmTrace\", \"trace\", \"stateDiff\"],\n\t        ]\n\t    def _trace_transaction_params_factory(self, rng: RNG):\n", "        return [self.test_data.get_random_tx_hash(rng), {\"tracer\": \"prestateTracer\"}]\n\t    def _trace_filter_params_factory(self, rng: RNG):\n\t        block_number = self.test_data.get_random_block_number(rng)\n\t        return [\n\t            {\n\t                \"fromAddress\": [self.test_data.get_random_account(rng)],\n\t                \"fromBlock\": hex(block_number),\n\t                \"toBlock\": hex(block_number + random.randint(0, 20)),\n\t            }\n\t        ]\n", "    def _eth_estimate_gas_params_factory(self, rng: RNG):\n\t        return [\n\t            {\n\t                \"from\": self.test_data.get_random_account(rng),\n\t                \"to\": \"0x18318221d811Da0fe45412394eAf2C42A10BC678\",\n\t            }\n\t        ]\n"]}
{"filename": "chainbench/user/solana.py", "chunked_list": ["from locust.contrib.fasthttp import RestResponseContextManager\n\tfrom locust.exception import RescheduleTask\n\tfrom chainbench.test_data import SolanaTestData\n\tfrom chainbench.user.base import BaseBenchUser\n\tfrom chainbench.util.rng import RNG\n\tclass SolanaBenchUser(BaseBenchUser):\n\t    abstract = True\n\t    test_data = SolanaTestData()\n\t    def check_response(self, response: RestResponseContextManager, name: str):\n\t        \"\"\"Check the response for errors.\"\"\"\n", "        if response.status_code != 200:\n\t            self.logger.info(f\"Request failed with {response.status_code} code\")\n\t            self.logger.debug(\n\t                f\"Request to {response.url} failed with {response.status_code} code: {response.text}\"  # noqa: E501\n\t            )\n\t            self.check_fatal(response)\n\t            response.failure(f\"Request failed with {response.status_code} code\")\n\t            response.raise_for_status()\n\t        if response.request:\n\t            self.logger.debug(f\"Request: {response.request.body}\")\n", "        if response.js is None:\n\t            self.logger.error(f\"Response for {name}  is not a JSON: {response.text}\")\n\t            response.failure(f\"Response for {name}  is not a JSON\")\n\t            raise RescheduleTask()\n\t        if \"jsonrpc\" not in response.js:\n\t            self.logger.error(f\"Response for {name} is not a JSON-RPC: {response.text}\")\n\t            response.failure(f\"Response for {name} is not a JSON-RPC\")\n\t            raise RescheduleTask()\n\t        if \"error\" in response.js:\n\t            self.logger.error(f\"Response for {name} has a JSON-RPC error: {response.text}\")\n", "            if \"code\" in response.js[\"error\"]:\n\t                if response.js[\"error\"][\"code\"] == -32007:\n\t                    self.logger.warn(\n\t                        f\"Response for {name} has a JSON-RPC error: {response.js['error']['message']}\"  # noqa: E501\n\t                    )\n\t                    return\n\t                else:\n\t                    self.logger.error(\n\t                        f\"Response for {name} has a JSON-RPC error {response.js['error']['code']}\"  # noqa: E501\n\t                    )\n", "                    response.failure(\n\t                        f\"Response for {name} has a JSON-RPC error {response.js['error']['code']}\"  # noqa: E501\n\t                    )\n\t                    raise RescheduleTask()\n\t            response.failure(\"Unspecified JSON-RPC error\")\n\t            raise RescheduleTask()\n\t        if not response.js.get(\"result\"):\n\t            self.logger.error(f\"Response for {name} call has no result: {response.text}\")\n\t    def _get_account_info_params_factory(self, rng: RNG):\n\t        return [self.test_data.get_random_account(rng), {\"encoding\": \"jsonParsed\"}]\n", "    def _get_block_params_factory(self, rng: RNG):\n\t        return [\n\t            self.test_data.get_random_block_number(rng),\n\t            {\n\t                \"encoding\": \"jsonParsed\",\n\t                \"transactionDetails\": \"full\",\n\t                \"maxSupportedTransactionVersion\": 0,\n\t            },\n\t        ]\n\t    def _get_token_accounts_by_owner_params_factory(self, rng: RNG):\n", "        return [\n\t            self.test_data.get_random_account(rng),\n\t            {\"programId\": \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"},\n\t            {\"encoding\": \"jsonParsed\"},\n\t        ]\n\t    def _get_multiple_accounts_params_factory(self, rng: RNG):\n\t        return [\n\t            [self.test_data.get_random_account(rng) for _ in range(2, 2 + rng.random.randint(0, 3))],\n\t            {\"encoding\": \"jsonParsed\"},\n\t        ]\n", "    def _get_transaction_params_factory(self, rng: RNG):\n\t        return [\n\t            self.test_data.get_random_tx_hash(rng),\n\t            {\"encoding\": \"jsonParsed\", \"maxSupportedTransactionVersion\": 0},\n\t        ]\n\t    def _get_signatures_for_address_params_factory(self, rng: RNG):\n\t        return [\n\t            self.test_data.get_random_account(rng),\n\t            {\"limit\": rng.random.randint(1, 10)},\n\t        ]\n", "    def _get_balance_params_factory(self, rng: RNG):\n\t        return [\n\t            self.test_data.get_random_account(rng),\n\t            {\"commitment\": \"processed\"},\n\t        ]\n\t    def _get_signature_statuses_params_factory(self, rng: RNG):\n\t        return [\n\t            [self.test_data.get_random_tx_hash(rng) for _ in range(2, 2 + rng.random.randint(0, 3))],\n\t            {\"searchTransactionHistory\": True},\n\t        ]\n", "    def _get_blocks_params_factory(self, rng: RNG):\n\t        start_number = self.test_data.get_random_block_number(rng)\n\t        end_number = start_number + rng.random.randint(1, 4)\n\t        return [\n\t            start_number,\n\t            end_number,\n\t            {\"commitment\": \"confirmed\"},\n\t        ]\n\t    def _get_confirmed_signatures_for_address2_params_factory(self, rng: RNG):\n\t        return [\n", "            self.test_data.get_random_account(rng),\n\t            {\n\t                \"limit\": rng.random.randint(1, 10),\n\t                \"commitment\": \"confirmed\",\n\t            },\n\t        ]\n"]}
{"filename": "chainbench/util/notify.py", "chunked_list": ["import typing as t\n\tfrom dataclasses import InitVar, dataclass, field\n\tfrom enum import IntEnum\n\tfrom pathlib import Path\n\timport httpx\n\tDEFAULT_NTFY_SERVER = \"https://ntfy.sh\"\n\tclass Priority(IntEnum):\n\t    \"\"\"Priority levels for notifications.\"\"\"\n\t    MIN = 0\n\t    LOW = 1\n", "    DEFAULT = 2\n\t    HIGH = 3\n\t    MAX = 4\n\tclass _NotificationData(t.TypedDict):\n\t    \"\"\"Notification request data.\"\"\"\n\t    content: bytes\n\t    headers: dict[str, str]\n\t@dataclass\n\tclass Notification:\n\t    \"\"\"A notification to be sent to a notification service.\"\"\"\n", "    message: str = \"\"\n\t    title: str = \"\"\n\t    priority: int = field(default=2)\n\t    tags: list[str] = field(default_factory=list)\n\t    email: str | None = field(default=None, repr=False, compare=False)\n\t    file: InitVar[str | Path | None] = field(default=None, repr=False, compare=False)\n\t    _file: Path | None = field(init=False, default=None, repr=False, compare=False)\n\t    def __post_init__(self, file: str | Path | None = None) -> None:\n\t        self.title = self.title.strip()\n\t        self.message = self.message.strip()\n", "        if file:\n\t            self._file = Path(file)\n\t    def _headers(self) -> dict[str, str]:\n\t        \"\"\"Return the headers to send to the notification service.\"\"\"\n\t        headers = {\"X-Priority\": str(self.priority)}\n\t        if self.title:\n\t            headers[\"X-Title\"] = self.title\n\t        if self.tags:\n\t            headers[\"X-Tags\"] = \",\".join(self.tags)\n\t        if self._file and self._file.exists():\n", "            headers[\"X-Filename\"] = self._file.name\n\t        if self.email:\n\t            headers[\"X-Email\"] = self.email\n\t        return headers\n\t    def _content(self) -> bytes:\n\t        \"\"\"Return the binary content to send to the notification service.\"\"\"\n\t        if self._file and self._file.exists():\n\t            return self._file.read_bytes()\n\t        return self.message.encode(\"utf-8\")\n\t    def data(self) -> _NotificationData:\n", "        \"\"\"Return the data to send to the notification service.\"\"\"\n\t        return {\n\t            \"content\": self._content(),\n\t            \"headers\": self._headers(),\n\t        }\n\tclass Notifier:\n\t    \"\"\"A notification service.\"\"\"\n\t    def __init__(self, topic: str, url: str = DEFAULT_NTFY_SERVER, timeout: int = 30) -> None:\n\t        self.topic: str = topic\n\t        self.url: str = url\n", "        self.timeout: int = timeout\n\t        self.client = httpx.Client(base_url=url, timeout=timeout)\n\t    def notify(\n\t        self,\n\t        *,\n\t        message: str = \"\",\n\t        title: str = \"\",\n\t        priority: int = Priority.DEFAULT,\n\t        tags: list[str] | None = None,\n\t        email: str | None = None,\n", "        file: str | Path | None = None,\n\t    ) -> None:\n\t        \"\"\"Send a notification.\"\"\"\n\t        response = self.client.post(\n\t            self.topic,\n\t            **Notification(\n\t                message=message,\n\t                title=title,\n\t                priority=priority,\n\t                tags=tags or [],\n", "                email=email,\n\t                file=file,\n\t            ).data(),\n\t        )\n\t        response.raise_for_status()\n\t    def __call__(self, *args, **kwargs):\n\t        self.notify(*args, **kwargs)\n\t    def __del__(self) -> None:\n\t        self.client.close()\n\tclass NoopNotifier(Notifier):\n", "    \"\"\"A notification service that does nothing.\"\"\"\n\t    def __init__(self, *args, **kwargs) -> None:  # noqa\n\t        pass\n\t    def notify(self, **kwargs) -> None:\n\t        \"\"\"Do nothing.\"\"\"\n\t        pass\n\t    def __del__(self) -> None:\n\t        pass\n"]}
{"filename": "chainbench/util/monitor.py", "chunked_list": ["import csv\n\timport logging\n\tfrom datetime import datetime, timedelta\n\tfrom json import JSONDecodeError\n\tfrom time import sleep\n\timport httpx\n\tfrom locust.util.timespan import parse_timespan\n\tlogger = logging.getLogger()\n\tdef calculate_lag(current_timestamp, block_timestamp):\n\t    \"\"\"\n", "    Calculate the difference between the time the node under test received the block,\n\t    and the time when the block producer node produced the block, in seconds.\n\t    Sometimes this value is negative due to difference in precision - block timestamp\n\t    is precise to the second, while current_timestamp is precise to microseconds.\n\t    Therefore, we use max function to ensure the lag calculated is minimum 0 and never\n\t    negative.\n\t    \"\"\"\n\t    return max(int((current_timestamp - block_timestamp).total_seconds()), 0)\n\tdef head_lag_monitor(endpoint, result_path, duration):\n\t    data = {\n", "        \"id\": 1,\n\t        \"jsonrpc\": \"2.0\",\n\t        \"method\": \"eth_getBlockByNumber\",\n\t        \"params\": [\"latest\", False],\n\t    }\n\t    csv_writer_kwargs = {\n\t        \"file\": f\"{result_path}/head_lag.csv\",\n\t        \"mode\": \"a\",\n\t        \"encoding\": \"utf-8-sig\",\n\t        \"newline\": \"\",\n", "    }\n\t    end_time = datetime.now() + timedelta(seconds=parse_timespan(duration))\n\t    http = httpx.Client()\n\t    with open(**csv_writer_kwargs) as csv_file:\n\t        logger.info(\"Start monitoring head lag\")\n\t        csv_writer = csv.writer(csv_file)\n\t        csv_writer.writerow([\"timestamp\", \"lag (s)\", \"block number\"])\n\t        while datetime.now() < end_time:\n\t            current_timestamp = datetime.now()\n\t            response = http.post(endpoint, json=data)\n", "            try:\n\t                block_timestamp = datetime.fromtimestamp(int(response.json()[\"result\"][\"timestamp\"], 0))\n\t                block_number = int(response.json()[\"result\"][\"number\"], 0)\n\t                csv_writer.writerow(\n\t                    [\n\t                        current_timestamp,\n\t                        f\"{calculate_lag(current_timestamp, block_timestamp)}\",\n\t                        block_number,\n\t                    ]\n\t                )\n", "                logger.info(\"Written 1 row to head_lag.csv\")\n\t                sleep(10)\n\t            except (KeyError, JSONDecodeError):\n\t                logger.error(\"Error decoding JSON or key not found\")\n\t                sleep(1)\n\t    logger.info(\"Finished monitoring head lag\")\n\tmonitors = {\"head-lag-monitor\": head_lag_monitor}\n"]}
{"filename": "chainbench/util/__init__.py", "chunked_list": []}
{"filename": "chainbench/util/timer.py", "chunked_list": ["import time\n\tclass Timer:\n\t    \"\"\"Simple timer class to measure time between events.\"\"\"\n\t    _timer: dict = {}\n\t    @classmethod\n\t    def set_timer(cls, timer_id):\n\t        \"\"\"Set a timer with a given id.\"\"\"\n\t        cls._timer[timer_id] = time.time()\n\t    @classmethod\n\t    def get_time_diff(cls, timer_id):\n", "        \"\"\"Get the time difference between now and the timer with the given id.\"\"\"\n\t        return time.time() - cls._timer[timer_id]\n"]}
{"filename": "chainbench/util/rng.py", "chunked_list": ["from inspect import stack\n\tfrom random import Random\n\tclass RNG:\n\t    def __init__(self, name: str, seed: int):\n\t        self.seed = seed\n\t        self.name = name\n\t        self.random = Random(seed)\n\tclass RNGManager:\n\t    def __init__(self, seed: int = 42):\n\t        self._seed = seed\n", "        self._rngs: dict[str, RNG] = {}\n\t    def get_rng(self, name: str | None = None, seed: int | None = None):\n\t        seed = seed if seed is not None else self._seed\n\t        if name is not None:\n\t            if name not in self._rngs.keys():\n\t                self._rngs[name] = RNG(name, seed)\n\t            return self._rngs[name]\n\t        else:\n\t            caller = stack()[1][3]\n\t            if caller not in self._rngs.keys():\n", "                self._rngs[caller] = RNG(caller, seed)\n\t            return self._rngs[caller]\n\trng_manager = RNGManager()\n\tget_rng = rng_manager.get_rng\n"]}
{"filename": "chainbench/util/rpc.py", "chunked_list": ["def generate_request(method, params: list | None = None, version: str = \"2.0\"):\n\t    \"\"\"Generate a JSON-RPC request.\"\"\"\n\t    if params is None:\n\t        params = []\n\t    return {\n\t        \"jsonrpc\": version,\n\t        \"method\": method,\n\t        \"params\": params,\n\t        \"id\": 1,\n\t    }\n"]}
{"filename": "chainbench/util/event.py", "chunked_list": ["import logging\n\tfrom locust import events\n\tfrom locust.runners import MasterRunner, WorkerRunner\n\tfrom chainbench.util.timer import Timer\n\tlogger = logging.getLogger(__name__)\n\tdef cli_custom_arguments(parser):\n\t    parser.add_argument(\n\t        \"--use-recent-blocks\",\n\t        type=bool,\n\t        default=False,\n", "        help=\"Use recent blocks as test data\",\n\t    )\n\tdef setup_test_data(environment, msg, **kwargs):\n\t    # Fired when the worker receives a message of type 'test_data'\n\t    test_data = msg.data[0]\n\t    worker_index = msg.data[1]\n\t    for user in environment.runner.user_classes:\n\t        if not hasattr(user, \"test_data\"):\n\t            continue\n\t        user.test_data.init_data_from_json(test_data[user.__class__.__name__])\n", "    environment.runner.send_message(\"acknowledge_data\", f\"Test data received by worker {worker_index}\")\n\t    logger.info(\"Test Data received from master\")\n\tdef on_acknowledge(msg, **kwargs):\n\t    # Fired when the master receives a message of type 'acknowledge_data'\n\t    print(msg.data)\n\t# Listener for the init event\n\tdef on_init(environment, **_kwargs):\n\t    # It will be called for any runner (master, worker, local)\n\t    logger.debug(\"init.add_listener: Init is started\")\n\t    logger.debug(\"init.add_listener: Environment: %s\", environment.runner)\n", "    logger.debug(\"init.add_listener: Host: %s\", environment.host)\n\t    host_under_test = environment.host or \"Default host\"\n\t    if not isinstance(environment.runner, MasterRunner):\n\t        # Print worker details to the log\n\t        logger.info(\"I'm a worker. Running tests for %s\", host_under_test)\n\t        environment.runner.register_message(\"test_data\", setup_test_data)\n\t    if not isinstance(environment.runner, WorkerRunner):\n\t        # Print master details to the log\n\t        logger.info(\"I'm a master. Running tests for %s\", host_under_test)\n\t        environment.runner.register_message(\"acknowledge_data\", on_acknowledge)\n", "def on_test_start(environment, **_kwargs):\n\t    test_data = {}\n\t    # It will be called for any runner (master, worker, local)\n\t    if not isinstance(environment.runner, WorkerRunner):\n\t        logger.info(\"Initializing test data...\")\n\t        print(\"Initializing test data...\\n\")\n\t        for user in environment.runner.user_classes:\n\t            if not hasattr(user, \"test_data\"):\n\t                continue\n\t            if user.__class__.__name__ not in test_data:\n", "                user.test_data.update(environment.host, environment.parsed_options)\n\t                test_data[user.__class__.__name__] = user.test_data.data.to_json()\n\t        logger.info(\"Test data is ready\")\n\t        for i, worker in enumerate(environment.runner.clients):\n\t            environment.runner.send_message(\"test_data\", (test_data, i), worker)\n\t            logger.info(f\"Test data is sent to worker {i}\")\n\t        # Print master details to the log\n\t        logger.info(\n\t            f\"Master: test_start.add_listener: The test is started, \" f\"Environment: {environment.runner}\",\n\t        )\n", "    if not isinstance(environment.runner, MasterRunner):\n\t        # Print worker details to the log\n\t        logger.info(\n\t            f\"Worker[{environment.runner.worker_index:02d}]: \"\n\t            f\"The test is started, Environment: {environment.runner}\",\n\t        )\n\t        Timer.set_timer(environment.runner.worker_index)\n\t# Listener for the test stop event\n\tdef on_test_stop(environment, **_kwargs):\n\t    # It will be called for any runner (master, worker, local)\n", "    runner = environment.runner\n\t    if not isinstance(runner, MasterRunner):\n\t        # Print worker details to the log\n\t        logger.info(\n\t            f\"Worker[{runner.worker_index:02d}]: Tests completed in \"\n\t            f\"{Timer.get_time_diff(runner.worker_index):>.3f} seconds\"\n\t        )\n\t    else:\n\t        # Print master details to the log\n\t        logger.info(\"Master: The test is stopped\")\n", "def setup_event_listeners():\n\t    events.init_command_line_parser.add_listener(cli_custom_arguments)\n\t    events.test_start.add_listener(on_test_start)\n\t    events.test_stop.add_listener(on_test_stop)\n\t    events.init.add_listener(on_init)\n"]}
{"filename": "chainbench/util/cli.py", "chunked_list": ["import subprocess\n\tfrom dataclasses import dataclass, field\n\tfrom datetime import datetime\n\tfrom pathlib import Path\n\tfrom chainbench.util.notify import NoopNotifier, Notifier\n\tdef get_base_path(src_path: str | Path) -> Path:\n\t    \"\"\"Get base path.\"\"\"\n\t    curr_path = Path(src_path).resolve()\n\t    base_path = curr_path.parent / \"profile\"\n\t    return base_path\n", "def get_profile_path(base_path: Path, profile: str) -> Path:\n\t    \"\"\"Get profile path.\"\"\"\n\t    subdir, _, profile = profile.rpartition(\".\")\n\t    if subdir:\n\t        profile_path = base_path / subdir / f\"{profile}.py\"\n\t    else:\n\t        profile_path = base_path / f\"{profile}.py\"\n\t    return profile_path\n\tdef generate_unique_dir_name() -> str:\n\t    return datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n", "def ensure_results_dir(profile: str, parent_dir: Path, run_id: str | None = None) -> Path:\n\t    if run_id is not None:\n\t        results_dir = (parent_dir / run_id).resolve()\n\t    else:\n\t        results_dir = (parent_dir / profile / generate_unique_dir_name()).resolve()\n\t    if not results_dir.exists():\n\t        results_dir.mkdir(parents=True, exist_ok=True)\n\t    return results_dir\n\tdef get_timescale_args(\n\t    pg_host: str | None,\n", "    pg_port: int | None,\n\t    pg_username: str | None,\n\t    pg_password: str | None,\n\t) -> str:\n\t    return f\" --timescale --pghost={pg_host} --pgport={pg_port}\" f\" --pgpassword={pg_password} --pguser={pg_username}\"\n\tdef get_master_command(\n\t    profile_path: Path,\n\t    host: str,\n\t    port: int,\n\t    users: int,\n", "    workers: int,\n\t    spawn_rate: int,\n\t    test_time: str,\n\t    log_level: str,\n\t    results_path: Path,\n\t    exclude_tags: list[str],\n\t    target: str | None = None,\n\t    headless: bool = False,\n\t    timescale: bool = False,\n\t    pg_host: str | None = None,\n", "    pg_port: int | None = None,\n\t    pg_username: str | None = None,\n\t    pg_password: str | None = None,\n\t    use_recent_blocks: bool = False,\n\t) -> str:\n\t    \"\"\"Generate master command.\"\"\"\n\t    command = (\n\t        f\"locust -f {profile_path} --master \"\n\t        f\"--master-bind-host {host} --master-bind-port {port} \"\n\t        f\"--web-host {host} \"\n", "        f\"-u {users} -r {spawn_rate} --run-time {test_time} \"\n\t        f\"--html {results_path}/report.html --csv {results_path}/report.csv \"\n\t        f\"--logfile {results_path}/report.log \"\n\t        f\"--loglevel {log_level} --expect-workers {workers}\"\n\t    )\n\t    if timescale:\n\t        command += get_timescale_args(pg_host, pg_port, pg_username, pg_password)\n\t    if target is not None:\n\t        command += f\" --host {target}\"\n\t    if headless:\n", "        command += \" --headless\"\n\t    if len(exclude_tags) > 0:\n\t        command += f\" --exclude-tags {' '.join(exclude_tags)}\"\n\t    if use_recent_blocks:\n\t        command += \" --use-recent-blocks True\"\n\t    return command\n\tdef get_worker_command(\n\t    profile_path: Path,\n\t    host: str,\n\t    port: int,\n", "    results_path: Path,\n\t    log_level: str,\n\t    exclude_tags: list[str],\n\t    target: str | None = None,\n\t    headless: bool = False,\n\t    worker_id: int = 0,\n\t    timescale: bool = False,\n\t    pg_host: str | None = None,\n\t    pg_port: int | None = None,\n\t    pg_username: str | None = None,\n", "    pg_password: str | None = None,\n\t    use_recent_blocks: bool = False,\n\t) -> str:\n\t    \"\"\"Generate worker command.\"\"\"\n\t    command = (\n\t        f\"locust -f {profile_path} --worker --master-host {host} --master-port {port} \"\n\t        f\"--logfile {results_path}/worker_{worker_id}.log --loglevel {log_level}\"\n\t    )\n\t    if timescale:\n\t        command += get_timescale_args(pg_host, pg_port, pg_username, pg_password)\n", "    if target is not None:\n\t        command += f\" --host {target}\"\n\t    if headless:\n\t        command += \" --headless\"\n\t    if len(exclude_tags) > 0:\n\t        command += f\" --exclude-tags {' '.join(exclude_tags)}\"\n\t    if use_recent_blocks:\n\t        command += \" --use-recent-blocks True\"\n\t    return command\n\t@dataclass\n", "class ContextData:\n\t    workers: list[subprocess.Popen] = field(default_factory=list)\n\t    master: subprocess.Popen | None = None\n\t    monitors: list[subprocess.Popen] = field(default_factory=list)\n\t    notifier: Notifier = field(default_factory=NoopNotifier)\n"]}
{"filename": "chainbench/test_data/base.py", "chunked_list": ["import json\n\timport logging\n\timport typing as t\n\tfrom argparse import Namespace\n\tfrom dataclasses import dataclass, field\n\tfrom secrets import token_hex\n\timport httpx\n\tfrom gevent.lock import Semaphore as GeventSemaphore\n\tfrom chainbench.util.rng import RNG, get_rng\n\tAccount = str\n", "Accounts = list[Account]\n\tTxHash = str\n\tTxHashes = list[TxHash]\n\tTx = dict[str, t.Any]\n\tTxs = list[Tx]\n\tBlock = dict[str, t.Any]\n\tBlockNumber = int\n\tBlockHash = str\n\tBlocks = list[tuple[BlockNumber, BlockHash]]\n\t@dataclass\n", "class BlockchainData:\n\t    start_block_number: BlockNumber = 0\n\t    end_block_number: BlockNumber = 0\n\t    blocks: Blocks = field(default_factory=list)\n\t    txs: Txs = field(default_factory=list)\n\t    tx_hashes: TxHashes = field(default_factory=list)\n\t    accounts: Accounts = field(default_factory=list)\n\t    def to_json(self):\n\t        return json.dumps(self, default=lambda o: o.__dict__, sort_keys=True, indent=4)\n\t    def from_json(self, json_data):\n", "        data = json.loads(json_data)\n\t        self.start_block_number = data[\"start_block_number\"]\n\t        self.end_block_number = data[\"end_block_number\"]\n\t        self.blocks = data[\"blocks\"]\n\t        self.txs = data[\"txs\"]\n\t        self.tx_hashes = data[\"tx_hashes\"]\n\t        self.accounts = data[\"accounts\"]\n\tclass ChainInfo(t.TypedDict):\n\t    name: str\n\t    start_block: int\n", "    end_block: int\n\tclass BaseTestData:\n\t    def __init__(self, rpc_version: str = \"2.0\"):\n\t        self._logger = logging.getLogger(__name__)\n\t        self._host: str | None = None\n\t        self._client: httpx.Client = httpx.Client()\n\t        self._rpc_version = rpc_version\n\t        self._lock = GeventSemaphore()\n\t        self._logger.debug(\"Locking\")\n\t        self._lock.acquire()\n", "        self._logger.debug(\"Locked\")\n\t        self._data: BlockchainData | None = None\n\t    def update(self, host_url: str, parsed_options: Namespace) -> BlockchainData:\n\t        self._logger.info(\"Updating data\")\n\t        self._host = host_url\n\t        self._logger.debug(\"Host: %s\", self._host)\n\t        data = self._get_init_data(parsed_options)\n\t        self._logger.info(\"Data fetched\")\n\t        self._logger.debug(\"Data: %s\", data)\n\t        self._data = data\n", "        self._logger.info(\"Data updated. Releasing lock\")\n\t        self._lock.release()\n\t        self._logger.info(\"Lock released\")\n\t        return data\n\t    def _get_init_data(self, parsed_options) -> BlockchainData:\n\t        raise NotImplementedError\n\t    def init_data_from_json(self, json_data: str):\n\t        self._data = BlockchainData()\n\t        self._data.from_json(json_data)\n\t        self._logger.info(\"Data updated. Releasing lock\")\n", "        self._lock.release()\n\t        self._logger.info(\"Lock released\")\n\t    @property\n\t    def initialized(self) -> bool:\n\t        return self._data is not None\n\t    @property\n\t    def host(self) -> str:\n\t        if self._host is None:\n\t            raise ValueError(\"Host is not initialized\")\n\t        return self._host\n", "    @property\n\t    def data(self) -> BlockchainData:\n\t        if self._data is None:\n\t            raise ValueError(\"Data is not initialized\")\n\t        return self._data\n\t    @staticmethod\n\t    def _parse_hex_to_int(value: str) -> int:\n\t        return int(value, 16)\n\t    @staticmethod\n\t    def _append_if_not_none(data, val):\n", "        if val is not None:\n\t            if isinstance(data, list):\n\t                data.append(val)\n\t            elif isinstance(data, set):\n\t                data.add(val)\n\t    def _make_body(self, method: str, params: list[t.Any] | None = None):\n\t        if params is None:\n\t            params = []\n\t        return {\n\t            \"jsonrpc\": self._rpc_version,\n", "            \"method\": method,\n\t            \"params\": params,\n\t            \"id\": token_hex(8),\n\t        }\n\t    def _make_call(self, method: str, params: list[t.Any] | None = None):\n\t        if params is None:\n\t            params = []\n\t        response = self._client.post(\n\t            self.host,\n\t            json=self._make_body(method, params),\n", "        )\n\t        self._logger.debug(f\"Making call to {self.host} with method {method} and params {params}\")\n\t        self._logger.debug(f\"Response: {response.text}\")\n\t        response.raise_for_status()\n\t        # check if response is json\n\t        try:\n\t            data = response.json()\n\t        except ValueError:\n\t            self._logger.error(\"Response is not json: %s\", response.text)\n\t            raise\n", "        # check if response is error\n\t        if \"error\" in data:\n\t            self._logger.error(\"Response is error: %s\", response.text)\n\t            raise ValueError(response.text)\n\t        # check if response is valid\n\t        if \"result\" not in data:\n\t            self._logger.error(\"Response is not valid: %s\", response.text)\n\t            raise ValueError(response.text)\n\t        return data[\"result\"]\n\t    def close(self):\n", "        self._client.close()\n\t    def wait(self):\n\t        self._lock.wait()\n\t    @staticmethod\n\t    def get_random_bool(rng: RNG | None = None) -> bool:\n\t        if rng is None:\n\t            rng = get_rng()\n\t        return rng.random.choice([True, False])\n\t    def get_random_block_number(self, rng: RNG | None = None) -> BlockNumber:\n\t        if rng is None:\n", "            rng = get_rng()\n\t        return rng.random.randint(self.start_block_number, self.end_block_number)\n\t    def get_random_block_hash(self, rng: RNG | None = None) -> BlockHash:\n\t        if rng is None:\n\t            rng = get_rng()\n\t        _, block_hash = rng.random.choice(self.blocks)\n\t        return block_hash\n\t    def get_random_tx_hash(self, rng: RNG | None = None) -> TxHash:\n\t        if rng is None:\n\t            rng = get_rng()\n", "        return rng.random.choice(self.tx_hashes)\n\t    def get_random_recent_block_number(self, n: int, rng: RNG | None = None) -> BlockNumber:\n\t        if rng is None:\n\t            rng = get_rng()\n\t        return rng.random.randint(\n\t            self.end_block_number - n,\n\t            self.end_block_number,\n\t        )\n\t    def get_random_account(self, rng: RNG | None = None) -> Account:\n\t        if rng is None:\n", "            rng = get_rng()\n\t        return rng.random.choice(self.accounts)\n\t    @property\n\t    def start_block_number(self) -> BlockNumber:\n\t        return self.data.start_block_number\n\t    @property\n\t    def end_block_number(self) -> BlockNumber:\n\t        return self.data.end_block_number\n\t    @property\n\t    def txs(self) -> Txs:\n", "        return self.data.txs\n\t    @property\n\t    def tx_hashes(self) -> TxHashes:\n\t        return self.data.tx_hashes\n\t    @property\n\t    def accounts(self) -> Accounts:\n\t        return self.data.accounts\n\t    @property\n\t    def blocks(self) -> Blocks:\n\t        return self.data.blocks\n"]}
{"filename": "chainbench/test_data/__init__.py", "chunked_list": ["from .base import BaseTestData\n\tfrom .dummy import DummyTestData\n\tfrom .evm import EVMTestData\n\tfrom .solana import SolanaTestData\n\t__all__ = [\n\t    \"BaseTestData\",\n\t    \"DummyTestData\",\n\t    \"EVMTestData\",\n\t    \"SolanaTestData\",\n\t]\n"]}
{"filename": "chainbench/test_data/evm.py", "chunked_list": ["from typing import Mapping\n\tfrom chainbench.test_data.base import BaseTestData, BlockchainData, Blocks, ChainInfo\n\tfrom chainbench.util.rng import get_rng\n\tclass EVMTestData(BaseTestData):\n\t    TXS_REQUIRED = 100\n\t    ACCOUNTS_REQUIRED = 200\n\t    SAVE_BLOCKS = 20\n\t    CHAIN_INFO: Mapping[int, ChainInfo] = {\n\t        1: {\n\t            \"name\": \"ethereum-mainnet\",\n", "            \"start_block\": 10000000,\n\t            \"end_block\": 17000000,\n\t        },\n\t        56: {\n\t            \"name\": \"binance-smart-chain\",\n\t            \"start_block\": 20000000,\n\t            \"end_block\": 29000000,\n\t        },\n\t        137: {\n\t            \"name\": \"polygon-mainnet\",\n", "            \"start_block\": 35000000,\n\t            \"end_block\": 45000000,\n\t        },\n\t        26863: {\n\t            \"name\": \"oasis-mainnet\",\n\t            \"start_block\": 8000000,\n\t            \"end_block\": 14000000,\n\t        },\n\t        43114: {\n\t            \"name\": \"avalanche-mainnet\",\n", "            \"start_block\": 20000000,\n\t            \"end_block\": 32000000,\n\t        },\n\t    }\n\t    def _fetch_chain_id(self) -> int:\n\t        return self._parse_hex_to_int(self._make_call(\"eth_chainId\"))\n\t    def _fetch_block(self, block_number: int | str, return_txs: bool = True) -> tuple[int, dict]:\n\t        if isinstance(block_number, int):\n\t            block_number = hex(block_number)\n\t        elif (block_number := block_number.lower()) not in (\n", "            \"latest\",\n\t            \"earliest\",\n\t            \"pending\",\n\t        ):\n\t            raise ValueError(\"Invalid block number\")\n\t        result = self._make_call(\"eth_getBlockByNumber\", [block_number, return_txs])\n\t        return self._parse_hex_to_int(result[\"number\"]), result\n\t    def _fetch_random_block(self, start, end, return_txs=True) -> tuple[int, dict]:\n\t        rng = get_rng()\n\t        block_number = rng.random.randint(start, end)\n", "        return self._fetch_block(block_number, return_txs=return_txs)\n\t    # get initial data from blockchain\n\t    def _get_init_data(self, parsed_options) -> BlockchainData:\n\t        txs: list[dict] = []\n\t        tx_hashes: list[str] = []\n\t        accounts: set[str] = set()\n\t        blocks: Blocks = []\n\t        chain_id: int = self._fetch_chain_id()\n\t        start_block_number: int\n\t        end_block_number: int\n", "        return_txs: bool\n\t        if parsed_options.use_recent_blocks:\n\t            end_block_number = int(self._make_call(\"eth_blockNumber\"), 0)\n\t            start_block_number = end_block_number - 20\n\t        else:\n\t            start_block_number = self.CHAIN_INFO[chain_id][\"start_block\"]\n\t            end_block_number = self.CHAIN_INFO[chain_id][\"end_block\"]\n\t        while self.TXS_REQUIRED > len(txs) or self.ACCOUNTS_REQUIRED > len(accounts) or self.SAVE_BLOCKS > len(blocks):\n\t            if self.ACCOUNTS_REQUIRED > len(accounts) or self.TXS_REQUIRED > len(txs):\n\t                return_txs = True\n", "            else:\n\t                return_txs = False\n\t            block_number, block = self._fetch_random_block(start_block_number, end_block_number, return_txs)\n\t            if self.SAVE_BLOCKS > len(blocks):\n\t                blocks.append((block_number, block[\"hash\"]))\n\t            for tx in block[\"transactions\"]:\n\t                if self.TXS_REQUIRED > len(txs):\n\t                    self._append_if_not_none(txs, tx)\n\t                    self._append_if_not_none(tx_hashes, tx[\"hash\"])\n\t                if self.ACCOUNTS_REQUIRED > len(accounts):\n", "                    self._append_if_not_none(accounts, tx[\"from\"])\n\t                if self.ACCOUNTS_REQUIRED > len(accounts):\n\t                    self._append_if_not_none(accounts, tx[\"to\"])\n\t        return BlockchainData(\n\t            end_block_number=end_block_number,\n\t            start_block_number=start_block_number,\n\t            blocks=blocks,\n\t            txs=txs,\n\t            tx_hashes=tx_hashes,\n\t            accounts=sorted(list(accounts)),\n", "        )\n"]}
{"filename": "chainbench/test_data/solana.py", "chunked_list": ["from tenacity import retry, stop_after_attempt\n\tfrom chainbench.test_data.base import BaseTestData, Block, BlockchainData\n\tfrom chainbench.util.rng import get_rng\n\tclass SolanaTestData(BaseTestData):\n\t    TXS_REQUIRED = 100\n\t    ACCOUNTS_REQUIRED = 200\n\t    BLOCK_TIME = 0.4\n\t    def _fetch_block(self, block_number: int, return_txs: bool = True) -> dict:\n\t        if return_txs:\n\t            transaction_details = \"accounts\"\n", "        else:\n\t            transaction_details = \"none\"\n\t        config_object = {\n\t            \"encoding\": \"json\",\n\t            \"transactionDetails\": transaction_details,\n\t            \"rewards\": False,\n\t            \"maxSupportedTransactionVersion\": 0,\n\t        }\n\t        try:\n\t            result = self._make_call(\"getBlock\", [block_number, config_object])\n", "        except Exception as e:\n\t            self._logger.error(f\"Failed to fetch block {block_number}: {e}\")\n\t            raise e\n\t        return result\n\t    @retry(reraise=True, stop=stop_after_attempt(5))\n\t    def _fetch_random_block(self, start, end, return_txs=True) -> dict:\n\t        rng = get_rng()\n\t        block_number = rng.random.randint(start, end)\n\t        block = self._fetch_block(block_number, return_txs=return_txs)\n\t        return block\n", "    def _fetch_latest_slot_number(self):\n\t        slot = self._make_call(\"getLatestBlockhash\")[\"context\"][\"slot\"]\n\t        return slot\n\t    @retry(reraise=True, stop=stop_after_attempt(5))\n\t    def _fetch_latest_block(self):\n\t        slot_number = self._fetch_latest_slot_number()\n\t        latest_block = self._fetch_block(slot_number, return_txs=True)\n\t        return slot_number, latest_block\n\t    def _fetch_first_available_block(self):\n\t        block = self._make_call(\"getFirstAvailableBlock\")\n", "        return block\n\t    # get initial data from blockchain\n\t    def _get_init_data(self, parsed_options) -> BlockchainData:\n\t        txs: list[dict] = []\n\t        tx_hashes: list[str] = []\n\t        accounts: set[str] = set()\n\t        blocks: list[Block] = []\n\t        end_block_number, _latest_block = self._fetch_latest_block()\n\t        start_block_number = self._fetch_first_available_block()\n\t        # factor in run_time and add 10% buffer to ensure blocks used in test data are\n", "        # not removed from the ledger\n\t        start_block_number += int((parsed_options.run_time / self.BLOCK_TIME) * 1.1)\n\t        while self.TXS_REQUIRED > len(txs) or self.ACCOUNTS_REQUIRED > len(accounts):\n\t            if self.ACCOUNTS_REQUIRED > len(accounts) or self.TXS_REQUIRED > len(blocks):\n\t                return_txs = True\n\t            else:\n\t                return_txs = False\n\t            block = self._fetch_random_block(start_block_number, end_block_number, return_txs)\n\t            for tx in block[\"transactions\"]:\n\t                if self.TXS_REQUIRED > len(txs):\n", "                    self._append_if_not_none(txs, tx)\n\t                    self._append_if_not_none(tx_hashes, tx[\"transaction\"][\"signatures\"][0])\n\t                    for account in tx[\"transaction\"][\"accountKeys\"]:\n\t                        if (\n\t                            self.ACCOUNTS_REQUIRED > len(accounts)\n\t                            and account[\"pubkey\"] != \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n\t                        ):\n\t                            self._append_if_not_none(accounts, account[\"pubkey\"])\n\t                        else:\n\t                            break\n", "        return BlockchainData(\n\t            end_block_number=end_block_number,\n\t            start_block_number=start_block_number,\n\t            blocks=[],\n\t            txs=txs,\n\t            tx_hashes=tx_hashes,\n\t            accounts=sorted(list(accounts)),\n\t        )\n"]}
{"filename": "chainbench/test_data/dummy.py", "chunked_list": ["from chainbench.test_data.base import BaseTestData, BlockchainData\n\tclass DummyTestData(BaseTestData):\n\t    def _get_init_data(self):\n\t        return BlockchainData()\n"]}
