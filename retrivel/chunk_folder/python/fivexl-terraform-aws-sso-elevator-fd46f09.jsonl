{"filename": "src/check_python_version.py", "chunked_list": ["import json\n\timport sys\n\t# Read the JSON data passed from Terraform\n\traw_data = sys.stdin.read()\n\tdata = json.loads(raw_data)\n\trequired_version = data[\"required_version\"]\n\t# Get the current Python version\n\tcurrent_version = f\"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\"\n\tif current_version != required_version:\n\t    # Write the error message to stderr\n", "    sys.stderr.write(\n\t        f\"Local python version is incorrect: {current_version}. Required version is {required_version}. Please clean 'builds', and then use docker for deployment, or destroy and re-create sso_elevator with the correct python version.\"  # noqa: E501\n\t    )\n\t    # Exit with a status code of 1, indicating failure\n\t    sys.exit(1)\n\tprint(json.dumps({\"current_version\": current_version}))\n"]}
{"filename": "src/main.py", "chunked_list": ["import functools\n\tfrom datetime import timedelta\n\timport boto3\n\tfrom aws_lambda_powertools import Logger\n\tfrom slack_bolt import Ack, App, BoltContext\n\tfrom slack_bolt.adapter.aws_lambda import SlackRequestHandler\n\tfrom slack_sdk import WebClient\n\tfrom slack_sdk.web.slack_response import SlackResponse\n\timport access_control\n\timport config\n", "import entities\n\timport errors\n\timport organizations\n\timport schedule\n\timport slack_helpers\n\timport sso\n\tlogger = config.get_logger(service=\"main\")\n\tsession = boto3.Session()\n\tschedule_client = session.client(\"scheduler\")\n\torg_client = session.client(\"organizations\")\n", "sso_client = session.client(\"sso-admin\")\n\tcfg = config.get_config()\n\tapp = App(\n\t    process_before_response=True,\n\t    logger=config.get_logger(service=\"slack\", level=cfg.slack_app_log_level),\n\t)\n\tdef lambda_handler(event: str, context):  # noqa: ANN001, ANN201\n\t    slack_handler = SlackRequestHandler(app=app)\n\t    return slack_handler.handle(event, context)\n\tdef error_handler(client: WebClient, e: Exception, logger: Logger, context: BoltContext) -> None:\n", "    logger.exception(e)\n\t    if isinstance(e, errors.ConfigurationError):\n\t        text = f\"<@{context['user_id']}> Your request for AWS permissions failed with error: {e}. Check logs for more details.\"\n\t        client.chat_postMessage(text=text, channel=cfg.slack_channel_id)\n\t    else:\n\t        text = f\"<@{context['user_id']}> Your request for AWS permissions failed with error. Check access-requester logs for more details.\"\n\t        client.chat_postMessage(text=text, channel=cfg.slack_channel_id)\n\tdef handle_errors(fn):  # noqa: ANN001, ANN201\n\t    # Default slack error handler (app.error) does not handle all exceptions. Or at least I did not find how to do it.\n\t    # So I created this error handler.\n", "    @functools.wraps(fn)\n\t    def wrapper(*args, **kwargs):  # noqa: ANN002, ANN003, ANN202\n\t        try:\n\t            return fn(*args, **kwargs)\n\t        except Exception as e:\n\t            client: WebClient = kwargs[\"client\"]\n\t            context: BoltContext = kwargs[\"context\"]\n\t            error_handler(client=client, e=e, logger=logger, context=context)\n\t    return wrapper\n\ttrigger_view_map = {}\n", "# To update the view, it is necessary to know the view_id. It is returned when the view is opened.\n\t# But shortcut 'request_for_access' handled by two functions. The first one opens the view and the second one updates it.\n\t# So we need to store the view_id somewhere. Since the trigger_id is unique for each request,\n\t# and available in both functions, we can use it as a key. The value is the view_id.\n\tdef show_initial_form(client: WebClient, body: dict, ack: Ack) -> SlackResponse:\n\t    ack()\n\t    logger.info(\"Showing initial form\")\n\t    logger.debug(\"Request body\", extra={\"body\": body})\n\t    trigger_id = body[\"trigger_id\"]\n\t    response = client.views_open(trigger_id=trigger_id, view=slack_helpers.RequestForAccessView.build())\n", "    trigger_view_map[trigger_id] = response.data[\"view\"][\"id\"]  # type: ignore # noqa: PGH003\n\t    return response\n\tdef load_select_options(client: WebClient, body: dict) -> SlackResponse:\n\t    logger.info(\"Loading select options for view (accounts and permission sets)\")\n\t    logger.debug(\"Request body\", extra={\"body\": body})\n\t    accounts = organizations.get_accounts_from_config(client=org_client, cfg=cfg)\n\t    permission_sets = sso.get_permission_sets_from_config(client=sso_client, cfg=cfg)\n\t    trigger_id = body[\"trigger_id\"]\n\t    view = slack_helpers.RequestForAccessView.update_with_accounts_and_permission_sets(accounts=accounts, permission_sets=permission_sets)\n\t    return client.views_update(view_id=trigger_view_map[trigger_id], view=view)\n", "app.shortcut(\"request_for_access\")(\n\t    show_initial_form,\n\t    load_select_options,\n\t)\n\tcache_for_dublicate_requests = {}\n\t@handle_errors\n\tdef handle_button_click(body: dict, client: WebClient, context: BoltContext) -> SlackResponse:  # noqa: ARG001\n\t    logger.info(\"Handling button click\")\n\t    payload = slack_helpers.ButtonClickedPayload.parse_obj(body)\n\t    logger.info(\"Button click payload\", extra={\"payload\": payload})\n", "    approver = slack_helpers.get_user(client, id=payload.approver_slack_id)\n\t    requester = slack_helpers.get_user(client, id=payload.request.requester_slack_id)\n\t    if (cache_for_dublicate_requests.get(\"requester_slack_id\") == payload.request.requester_slack_id\n\t    and cache_for_dublicate_requests.get(\"account_id\") == payload.request.account_id\n\t    and cache_for_dublicate_requests.get(\"permission_set_name\") == payload.request.permission_set_name):\n\t        return client.chat_postMessage(\n\t            channel=payload.channel_id,\n\t            text=f\"<@{approver.id}> request is already in progress, please wait for the result.\",\n\t            thread_ts=payload.thread_ts,\n\t        )\n", "    cache_for_dublicate_requests[\"requester_slack_id\"] = payload.request.requester_slack_id\n\t    cache_for_dublicate_requests[\"account_id\"] = payload.request.account_id\n\t    cache_for_dublicate_requests[\"permission_set_name\"] = payload.request.permission_set_name\n\t    if payload.action == entities.ApproverAction.Discard:\n\t        slack_helpers.remove_buttons(payload, client, approver)\n\t        cache_for_dublicate_requests.clear()\n\t        return client.chat_postMessage(\n\t            channel=payload.channel_id,\n\t            text=f\"Request was discarded by<@{approver.id}> \",\n\t            thread_ts=payload.thread_ts,\n", "        )\n\t    decision = access_control.make_decision_on_approve_request(\n\t        action=payload.action,\n\t        statements=cfg.statements,\n\t        account_id=payload.request.account_id,\n\t        permission_set_name=payload.request.permission_set_name,\n\t        approver_email=approver.email,\n\t        requester_email=requester.email,\n\t    )\n\t    logger.info(\"Decision on request was made\", extra={\"decision\": decision})\n", "    if not decision.permit:\n\t        cache_for_dublicate_requests.clear()\n\t        return client.chat_postMessage(\n\t            channel=payload.channel_id,\n\t            text=f\"<@{approver.id}> you can not approve this request\",\n\t            thread_ts=payload.thread_ts,\n\t        )\n\t    slack_helpers.remove_buttons(payload, client, approver)\n\t    access_control.execute_decision(\n\t        decision=decision,\n", "        permission_set_name=payload.request.permission_set_name,\n\t        account_id=payload.request.account_id,\n\t        permission_duration=payload.request.permission_duration,\n\t        approver=approver,\n\t        requester=requester,\n\t        reason=payload.request.reason,\n\t    )\n\t    cache_for_dublicate_requests.clear()\n\t    return client.chat_postMessage(\n\t        channel=payload.channel_id,\n", "        text=f\"Permissions granted to <@{requester.id}> by <@{approver.id}>.\",\n\t        thread_ts=payload.thread_ts,\n\t    )\n\tdef acknowledge_request(ack: Ack):  # noqa: ANN201\n\t    ack()\n\tapp.action(entities.ApproverAction.Approve.value)(\n\t    ack=acknowledge_request,\n\t    lazy=[handle_button_click],\n\t)\n\tapp.action(entities.ApproverAction.Discard.value)(\n", "    ack=acknowledge_request,\n\t    lazy=[handle_button_click],\n\t)\n\t@handle_errors\n\tdef handle_request_for_access_submittion(\n\t    body: dict,\n\t    ack: Ack,  # noqa: ARG001\n\t    client: WebClient,\n\t    context: BoltContext,  # noqa: ARG001\n\t) -> SlackResponse | None:\n", "    logger.info(\"Handling request for access submittion\")\n\t    request = slack_helpers.RequestForAccessView.parse(body)\n\t    logger.info(\"View submitted\", extra={\"view\": request})\n\t    requester = slack_helpers.get_user(client, id=request.requester_slack_id)\n\t    decision = access_control.make_decision_on_access_request(\n\t        cfg.statements,\n\t        account_id=request.account_id,\n\t        permission_set_name=request.permission_set_name,\n\t        requester_email=requester.email,\n\t    )\n", "    logger.info(\"Decision on request was made\", extra={\"decision\": decision})\n\t    account = organizations.describe_account(org_client, request.account_id)\n\t    show_buttons = bool(decision.approvers)\n\t    slack_response = client.chat_postMessage(\n\t        blocks=slack_helpers.build_approval_request_message_blocks(\n\t            requester_slack_id=request.requester_slack_id,\n\t            account=account,\n\t            role_name=request.permission_set_name,\n\t            reason=request.reason,\n\t            permission_duration=request.permission_duration,\n", "            show_buttons=show_buttons,\n\t        ),\n\t        channel=cfg.slack_channel_id,\n\t        text=f\"Request for access to {account.name} account from {requester.real_name}\",\n\t    )\n\t    if show_buttons:\n\t        ts = slack_response[\"ts\"]\n\t        if ts is not None:\n\t            schedule.schedule_discard_buttons_event(\n\t                schedule_client=schedule_client,\n", "                time_stamp=ts,\n\t                channel_id=cfg.slack_channel_id,\n\t            )\n\t            schedule.schedule_approver_notification_event(\n\t                schedule_client=schedule_client,\n\t                message_ts=ts,\n\t                channel_id=cfg.slack_channel_id,\n\t                time_to_wait=timedelta(minutes=cfg.approver_renotification_initial_wait_time,)\n\t            )\n\t    match decision.reason:\n", "        case access_control.DecisionReason.ApprovalNotRequired:\n\t            text = \"Approval for this Permission Set & Account is not required. Request will be approved automatically.\"\n\t        case access_control.DecisionReason.SelfApproval:\n\t            text = \"Self approval is allowed and requester is an approver. Request will be approved automatically.\"\n\t        case access_control.DecisionReason.RequiresApproval:\n\t            approvers = [slack_helpers.get_user_by_email(client, email) for email in decision.approvers]\n\t            mention_approvers = \" \".join(f\"<@{approver.id}>\" for approver in approvers)\n\t            text = f\"{mention_approvers} there is a request waiting for the approval.\"\n\t        case access_control.DecisionReason.NoApprovers:\n\t            text = \"Nobody can approve this request.\"\n", "        case access_control.DecisionReason.NoStatements:\n\t            text = \"There are no statements for this Permission Set & Account.\"\n\t    client.chat_postMessage(text=text, thread_ts=slack_response[\"ts\"], channel=cfg.slack_channel_id)\n\t    access_control.execute_decision(\n\t        decision=decision,\n\t        permission_set_name=request.permission_set_name,\n\t        account_id=request.account_id,\n\t        permission_duration=request.permission_duration,\n\t        approver=requester,\n\t        requester=requester,\n", "        reason=request.reason,\n\t    )\n\t    if decision.grant:\n\t        return client.chat_postMessage(\n\t            channel=cfg.slack_channel_id,\n\t            text=f\"Permissions granted to <@{requester.id}>\",\n\t            thread_ts=slack_response[\"ts\"],\n\t        )\n\tapp.view(slack_helpers.RequestForAccessView.CALLBACK_ID)(\n\t    ack=acknowledge_request,\n", "    lazy=[handle_request_for_access_submittion],\n\t)\n\t@app.action(\"duration_picker_action\")\n\tdef handle_duration_picker_action(ack):  # noqa: ANN201, ANN001\n\t    ack()\n"]}
{"filename": "src/events.py", "chunked_list": ["from datetime import timedelta\n\tfrom typing import Literal\n\tfrom pydantic import Field, root_validator\n\timport entities\n\timport sso\n\tfrom entities.model import BaseModel\n\tclass RevokeEvent(BaseModel):\n\t    schedule_name: str\n\t    approver: entities.slack.User\n\t    requester: entities.slack.User\n", "    user_account_assignment: sso.UserAccountAssignment\n\t    permission_duration: timedelta\n\tclass ScheduledRevokeEvent(BaseModel):\n\t    action: Literal[\"event_bridge_revoke\"]\n\t    revoke_event: RevokeEvent\n\t    @root_validator(pre=True)\n\t    def validate_payload(cls, values: dict) -> dict:  # noqa: ANN101\n\t        values[\"revoke_event\"] = RevokeEvent.parse_raw(values[\"revoke_event\"])\n\t        return values\n\tclass DiscardButtonsEvent(BaseModel):\n", "    action: Literal[\"discard_buttons_event\"]\n\t    schedule_name: str\n\t    time_stamp: str\n\t    channel_id: str\n\tclass CheckOnInconsistency(BaseModel):\n\t    action: Literal[\"check_on_inconsistency\"]\n\tclass SSOElevatorScheduledRevocation(BaseModel):\n\t    action: Literal[\"sso_elevator_scheduled_revocation\"]\n\tclass ApproverNotificationEvent(BaseModel):\n\t    action: Literal[\"approvers_renotification\"]\n", "    schedule_name: str\n\t    time_stamp: str\n\t    channel_id: str\n\t    time_to_wait_in_seconds: float\n\tclass Event(BaseModel):\n\t    __root__: (\n\t        ScheduledRevokeEvent |\n\t        DiscardButtonsEvent |\n\t        CheckOnInconsistency |\n\t        SSOElevatorScheduledRevocation |\n", "        ApproverNotificationEvent\n\t    ) = Field(\n\t        ..., discriminator=\"action\"\n\t    )\n"]}
{"filename": "src/revoker.py", "chunked_list": ["from datetime import datetime, timedelta\n\timport boto3\n\timport slack_sdk\n\tfrom mypy_boto3_events import EventBridgeClient\n\tfrom mypy_boto3_identitystore import IdentityStoreClient\n\tfrom mypy_boto3_organizations import OrganizationsClient\n\tfrom mypy_boto3_scheduler import EventBridgeSchedulerClient\n\tfrom mypy_boto3_sso_admin import SSOAdminClient\n\tfrom pydantic import ValidationError\n\tfrom slack_sdk.web.slack_response import SlackResponse\n", "import config\n\timport entities\n\timport organizations\n\timport s3\n\timport schedule\n\timport slack_helpers\n\timport sso\n\tfrom events import (\n\t    ApproverNotificationEvent,\n\t    CheckOnInconsistency,\n", "    DiscardButtonsEvent,\n\t    Event,\n\t    RevokeEvent,\n\t    ScheduledRevokeEvent,\n\t    SSOElevatorScheduledRevocation,\n\t)\n\tlogger = config.get_logger(service=\"revoker\")\n\tcfg = config.get_config()\n\torg_client = boto3.client(\"organizations\")\n\tsso_client = boto3.client(\"sso-admin\")\n", "identitystore_client = boto3.client(\"identitystore\")\n\tscheduler_client = boto3.client(\"scheduler\")\n\tevents_client = boto3.client(\"events\")\n\tslack_client = slack_sdk.WebClient(token=cfg.slack_bot_token)\n\tdef lambda_handler(event: dict, __) -> SlackResponse | None:  # type: ignore # noqa: ANN001, PGH003\n\t    try:\n\t        parsed_event = Event.parse_obj(event).__root__\n\t    except ValidationError as e:\n\t        logger.warning(\"Got unexpected event:\", extra={\"event\": event, \"exception\": e})\n\t        raise e\n", "    match parsed_event:\n\t        case ScheduledRevokeEvent():\n\t            logger.info(\"Handling ScheduledRevokeEvent\", extra={\"event\": parsed_event})\n\t            return handle_scheduled_account_assignment_deletion(\n\t                revoke_event=parsed_event.revoke_event,\n\t                sso_client=sso_client,\n\t                cfg=cfg,\n\t                scheduler_client=scheduler_client,\n\t                org_client=org_client,\n\t                slack_client=slack_client,\n", "                identitystore_client=identitystore_client,\n\t            )\n\t        case DiscardButtonsEvent():\n\t            logger.info(\"Handling DiscardButtonsEvent\", extra={\"event\": parsed_event})\n\t            handle_discard_buttons_event(event=parsed_event, slack_client=slack_client, scheduler_client=scheduler_client)\n\t            return\n\t        case CheckOnInconsistency():\n\t            logger.info(\"Handling CheckOnInconsistency event\", extra={\"event\": parsed_event})\n\t            return handle_check_on_inconsistency(\n\t                sso_client=sso_client,\n", "                cfg=cfg,\n\t                scheduler_client=scheduler_client,\n\t                org_client=org_client,\n\t                slack_client=slack_client,\n\t                identitystore_client=identitystore_client,\n\t                events_client=events_client,\n\t            )\n\t        case SSOElevatorScheduledRevocation():\n\t            logger.info(\"Handling SSOElevatorScheduledRevocation event\", extra={\"event\": parsed_event})\n\t            return handle_sso_elevator_scheduled_revocation(\n", "                sso_client=sso_client,\n\t                cfg=cfg,\n\t                scheduler_client=scheduler_client,\n\t                org_client=org_client,\n\t                slack_client=slack_client,\n\t                identitystore_client=identitystore_client,\n\t            )\n\t        case ApproverNotificationEvent():\n\t            logger.info(\"Handling ApproverNotificationEvent event\", extra={\"event\": parsed_event})\n\t            return handle_approvers_renotification_event(\n", "                event = parsed_event,\n\t                slack_client=slack_client,\n\t                scheduler_client=scheduler_client,\n\t            )\n\tdef handle_account_assignment_deletion(  # noqa: PLR0913\n\t    account_assignment: sso.UserAccountAssignment,\n\t    cfg: config.Config,\n\t    sso_client: SSOAdminClient,\n\t    org_client: OrganizationsClient,\n\t    slack_client: slack_sdk.WebClient,\n", "    identitystore_client: IdentityStoreClient,\n\t) -> SlackResponse | None:\n\t    logger.info(\"Handling account assignment deletion\", extra={\"account_assignment\": account_assignment})\n\t    assignment_status = sso.delete_account_assignment_and_wait_for_result(\n\t        sso_client,\n\t        account_assignment,\n\t    )\n\t    permission_set = sso.describe_permission_set(\n\t        sso_client,\n\t        account_assignment.instance_arn,\n", "        account_assignment.permission_set_arn,\n\t    )\n\t    s3.log_operation(\n\t        s3.AuditEntry(\n\t            role_name=permission_set.name,\n\t            account_id=account_assignment.account_id,\n\t            reason=\"automated revocation\",\n\t            requester_slack_id=\"NA\",\n\t            requester_email=\"NA\",\n\t            request_id=assignment_status.request_id,\n", "            approver_slack_id=\"NA\",\n\t            approver_email=\"NA\",\n\t            operation_type=\"revoke\",\n\t            permission_duration=\"NA\",\n\t        ),\n\t    )\n\t    if cfg.post_update_to_slack:\n\t        account = organizations.describe_account(org_client, account_assignment.account_id)\n\t        return slack_notify_user_on_revoke(\n\t            cfg=cfg,\n", "            account_assignment=account_assignment,\n\t            permission_set=permission_set,\n\t            account=account,\n\t            sso_client=sso_client,\n\t            identitystore_client=identitystore_client,\n\t            slack_client=slack_client,\n\t        )\n\tdef slack_notify_user_on_revoke(  # noqa: PLR0913\n\t    cfg: config.Config,\n\t    account_assignment: sso.AccountAssignment | sso.UserAccountAssignment,\n", "    permission_set: entities.aws.PermissionSet,\n\t    account: entities.aws.Account,\n\t    sso_client: SSOAdminClient,\n\t    identitystore_client: IdentityStoreClient,\n\t    slack_client: slack_sdk.WebClient,\n\t) -> SlackResponse:\n\t    mention = slack_helpers.create_slack_mention_by_principal_id(\n\t        account_assignment=account_assignment,\n\t        sso_client=sso_client,\n\t        cfg=cfg,\n", "        identitystore_client=identitystore_client,\n\t        slack_client=slack_client,\n\t    )\n\t    return slack_client.chat_postMessage(\n\t        channel=cfg.slack_channel_id,\n\t        text=f\"Revoked role {permission_set.name} for user {mention} in account {account.name}\",\n\t    )\n\tdef handle_scheduled_account_assignment_deletion(  # noqa: PLR0913\n\t    revoke_event: RevokeEvent,\n\t    sso_client: SSOAdminClient,\n", "    cfg: config.Config,\n\t    scheduler_client: EventBridgeSchedulerClient,\n\t    org_client: OrganizationsClient,\n\t    slack_client: slack_sdk.WebClient,\n\t    identitystore_client: IdentityStoreClient,\n\t) -> SlackResponse | None:\n\t    logger.info(\"Handling scheduled account assignment deletion\", extra={\"revoke_event\": revoke_event})\n\t    user_account_assignment = revoke_event.user_account_assignment\n\t    assignment_status = sso.delete_account_assignment_and_wait_for_result(\n\t        sso_client,\n", "        user_account_assignment,\n\t    )\n\t    permission_set = sso.describe_permission_set(\n\t        sso_client,\n\t        sso_instance_arn=user_account_assignment.instance_arn,\n\t        permission_set_arn=user_account_assignment.permission_set_arn,\n\t    )\n\t    s3.log_operation(\n\t        s3.AuditEntry(\n\t            role_name=permission_set.name,\n", "            account_id=user_account_assignment.account_id,\n\t            reason=\"scheduled_revocation\",\n\t            requester_slack_id=revoke_event.requester.id,\n\t            requester_email=revoke_event.requester.email,\n\t            request_id=assignment_status.request_id,\n\t            approver_slack_id=revoke_event.approver.id,\n\t            approver_email=revoke_event.approver.email,\n\t            operation_type=\"revoke\",\n\t            permission_duration=revoke_event.permission_duration,\n\t        ),\n", "    )\n\t    schedule.delete_schedule(scheduler_client, revoke_event.schedule_name)\n\t    if cfg.post_update_to_slack:\n\t        account = organizations.describe_account(org_client, user_account_assignment.account_id)\n\t        slack_notify_user_on_revoke(\n\t            cfg=cfg,\n\t            account_assignment=user_account_assignment,\n\t            permission_set=permission_set,\n\t            account=account,\n\t            sso_client=sso_client,\n", "            identitystore_client=identitystore_client,\n\t            slack_client=slack_client,\n\t        )\n\tdef handle_check_on_inconsistency(  # noqa: PLR0913\n\t    sso_client: SSOAdminClient,\n\t    cfg: config.Config,\n\t    scheduler_client: EventBridgeSchedulerClient,\n\t    org_client: OrganizationsClient,\n\t    slack_client: slack_sdk.WebClient,\n\t    identitystore_client: IdentityStoreClient,\n", "    events_client: EventBridgeClient,\n\t) -> None:\n\t    account_assignments = sso.get_account_assignment_information(sso_client, cfg, org_client)\n\t    scheduled_revoke_events = schedule.get_scheduled_events(scheduler_client)\n\t    account_assignments_from_events = [\n\t        sso.AccountAssignment(\n\t            permission_set_arn=scheduled_event.revoke_event.user_account_assignment.permission_set_arn,\n\t            account_id=scheduled_event.revoke_event.user_account_assignment.account_id,\n\t            principal_id=scheduled_event.revoke_event.user_account_assignment.user_principal_id,\n\t            principal_type=\"USER\",\n", "        )\n\t        for scheduled_event in scheduled_revoke_events\n\t    ]\n\t    for account_assignment in account_assignments:\n\t        if account_assignment not in account_assignments_from_events:\n\t            account = organizations.describe_account(org_client, account_assignment.account_id)\n\t            logger.warning(\"Found an inconsistent account assignment\", extra={\"account_assignment\": account_assignment})\n\t            mention = slack_helpers.create_slack_mention_by_principal_id(\n\t                account_assignment=account_assignment,\n\t                sso_client=sso_client,\n", "                cfg=cfg,\n\t                identitystore_client=identitystore_client,\n\t                slack_client=slack_client,\n\t            )\n\t            rule = schedule.get_event_brige_rule(\n\t                event_brige_client=events_client, rule_name=cfg.sso_elevator_scheduled_revocation_rule_name\n\t            )\n\t            next_run_time_or_expression = schedule.check_rule_expression_and_get_next_run(rule)\n\t            time_notice = \"\"\n\t            if isinstance(next_run_time_or_expression, datetime):\n", "                time_notice = f\" The next scheduled revocation is set for {next_run_time_or_expression}.\"\n\t            elif isinstance(next_run_time_or_expression, str):\n\t                time_notice = f\" The revocation schedule is set as: {next_run_time_or_expression}.\"  # noqa: Q000\n\t            slack_client.chat_postMessage(\n\t                channel=cfg.slack_channel_id,\n\t                text=(\n\t                    f\"Inconsistent account assignment detected in {account.name}-{account.id} for {mention}. \"\n\t                    f\"The unidentified assignment will be automatically revoked.{time_notice}\"\n\t                ),\n\t            )\n", "def handle_sso_elevator_scheduled_revocation(  # noqa: PLR0913\n\t    sso_client: SSOAdminClient,\n\t    cfg: config.Config,\n\t    scheduler_client: EventBridgeSchedulerClient,\n\t    org_client: OrganizationsClient,\n\t    slack_client: slack_sdk.WebClient,\n\t    identitystore_client: IdentityStoreClient,\n\t) -> None:\n\t    account_assignments = sso.get_account_assignment_information(sso_client, cfg, org_client)\n\t    scheduled_revoke_events = schedule.get_scheduled_events(scheduler_client)\n", "    sso_instance = sso.describe_sso_instance(sso_client, cfg.sso_instance_arn)\n\t    account_assignments_from_events = [\n\t        sso.AccountAssignment(\n\t            permission_set_arn=scheduled_event.revoke_event.user_account_assignment.permission_set_arn,\n\t            account_id=scheduled_event.revoke_event.user_account_assignment.account_id,\n\t            principal_id=scheduled_event.revoke_event.user_account_assignment.user_principal_id,\n\t            principal_type=\"USER\",\n\t        )\n\t        for scheduled_event in scheduled_revoke_events\n\t    ]\n", "    for account_assignment in account_assignments:\n\t        if account_assignment in account_assignments_from_events:\n\t            logger.info(\n\t                \"Account assignment already scheduled for revocation. Skipping.\",\n\t                extra={\"account_assignment\": account_assignment},\n\t            )\n\t            continue\n\t        else:\n\t            handle_account_assignment_deletion(\n\t                account_assignment=sso.UserAccountAssignment(\n", "                    account_id=account_assignment.account_id,\n\t                    permission_set_arn=account_assignment.permission_set_arn,\n\t                    user_principal_id=account_assignment.principal_id,\n\t                    instance_arn=sso_instance.arn,\n\t                ),\n\t                sso_client=sso_client,\n\t                org_client=org_client,\n\t                slack_client=slack_client,\n\t                identitystore_client=identitystore_client,\n\t                cfg=cfg,\n", "            )\n\tdef handle_discard_buttons_event(\n\t    event: DiscardButtonsEvent, slack_client: slack_sdk.WebClient, scheduler_client: EventBridgeSchedulerClient\n\t) -> None:\n\t    message = slack_helpers.get_message_from_timestamp(\n\t        channel_id=event.channel_id,\n\t        message_ts=event.time_stamp,\n\t        slack_client=slack_client,\n\t    )\n\t    schedule.delete_schedule(scheduler_client, event.schedule_name)\n", "    if message is None:\n\t        logger.warning(\"Message was not found\", extra={\"event\": event})\n\t        return\n\t    for block in message[\"blocks\"]:\n\t        if slack_helpers.get_block_id(block) == \"buttons\":\n\t            blocks = slack_helpers.remove_blocks(message[\"blocks\"], block_ids=[\"buttons\"])\n\t            blocks.append(\n\t                slack_helpers.SectionBlock(\n\t                    block_id=\"footer\",\n\t                    text=slack_helpers.MarkdownTextObject(\n", "                        text=f\"Request expired after {cfg.request_expiration_hours} hour(s).\",\n\t                    ),\n\t                )\n\t            )\n\t            slack_client.chat_update(\n\t                channel=event.channel_id,\n\t                ts=message[\"ts\"],\n\t                blocks=blocks,\n\t                text=\"Request expired\",\n\t            )\n", "            logger.info(\"Buttons were removed\", extra={\"event\": event})\n\t            return\n\t    logger.info(\"Buttons were not found\", extra={\"event\": event})\n\tdef handle_approvers_renotification_event(\n\t    event: ApproverNotificationEvent, slack_client: slack_sdk.WebClient, scheduler_client: EventBridgeSchedulerClient\n\t) -> None:\n\t    message = slack_helpers.get_message_from_timestamp(\n\t        channel_id=event.channel_id,\n\t        message_ts=event.time_stamp,\n\t        slack_client=slack_client,\n", "    )\n\t    schedule.delete_schedule(scheduler_client, event.schedule_name)\n\t    if message is None:\n\t        logger.warning(\"Message not found\", extra={\"event\": event})\n\t        return\n\t    for block in message[\"blocks\"]:\n\t        if slack_helpers.get_block_id(block) == \"buttons\":\n\t            time_to_wait = timedelta(seconds=event.time_to_wait_in_seconds)\n\t            if cfg.approver_renotification_backoff_multiplier != 0:\n\t                time_to_wait = time_to_wait * cfg.approver_renotification_backoff_multiplier\n", "            slack_response = slack_client.chat_postMessage(\n\t                channel=event.channel_id,\n\t                thread_ts=message[\"ts\"],\n\t                text=\"The request is still awaiting approval. The next reminder will be \"\n\t                    f\"sent in {time_to_wait}, unless the request is approved or \"\n\t                    \"discarded beforehand.\",\n\t            )\n\t            logger.info(\"Notifications to approvers were sent.\")\n\t            logger.debug(\"Slack response:\", extra={\"slack_response\": slack_response})\n\t            schedule.schedule_approver_notification_event(\n", "                schedule_client=scheduler_client,\n\t                channel_id=event.channel_id,\n\t                message_ts=message[\"ts\"],\n\t                time_to_wait=time_to_wait\n\t            )\n\t            return\n\t    logger.info(\"The request has already been approved or discarded.\", extra={\"event\": event})\n\t    return\n"]}
{"filename": "src/statement.py", "chunked_list": ["from enum import Enum\n\tfrom typing import FrozenSet, Union\n\tfrom pydantic import ConstrainedStr, EmailStr, Field\n\tfrom entities import BaseModel\n\tclass ResourceType(str, Enum):\n\t    Account = \"Account\"\n\t    OU = \"OU\"\n\tclass AWSAccountId(ConstrainedStr):\n\t    regex = r\"^\\d{12}$\"\n\tclass AWSOUName(ConstrainedStr):\n", "    regex = r\"^[\\s\\S]{1,128}$\"\n\tclass PermissionSetName(ConstrainedStr):\n\t    regex = r\"^[\\w+=,.@-]{1,32}$\"\n\tclass WildCard(ConstrainedStr):\n\t    regex = r\"^\\*$\"\n\tclass BaseStatement(BaseModel):\n\t    permission_set: FrozenSet[Union[PermissionSetName, WildCard]]\n\t    allow_self_approval: bool = False\n\t    approval_is_not_required: bool = False\n\t    approvers: FrozenSet[EmailStr] = Field(default_factory=frozenset)\n", "class Statement(BaseStatement):\n\t    resource_type: ResourceType = Field(ResourceType.Account, const=True)\n\t    resource: FrozenSet[Union[AWSAccountId, WildCard]]\n\t    def affects(self, account_id: str, permission_set_name: str) -> bool:  # noqa: ANN101\n\t        return (account_id in self.resource or \"*\" in self.resource) and (\n\t            permission_set_name in self.permission_set or \"*\" in self.permission_set\n\t        )\n\tdef get_affected_statements(statements: FrozenSet[Statement], account_id: str, permission_set_name: str) -> FrozenSet[Statement]:\n\t    return frozenset(statement for statement in statements if statement.affects(account_id, permission_set_name))\n\tclass OUStatement(BaseStatement):\n", "    resource_type: ResourceType = Field(ResourceType.OU, const=True)\n\t    resource: FrozenSet[Union[AWSOUName, WildCard]]\n"]}
{"filename": "src/config.py", "chunked_list": ["import os\n\tfrom typing import Optional\n\tfrom aws_lambda_powertools import Logger\n\tfrom pydantic import BaseSettings, root_validator\n\timport entities\n\tfrom statement import Statement\n\tdef parse_statement(_dict: dict) -> Statement:\n\t    def to_set_if_list_or_str(v: list | str) -> frozenset[str]:\n\t        if isinstance(v, list):\n\t            return frozenset(v)\n", "        return frozenset([v]) if isinstance(v, str) else v\n\t    return Statement.parse_obj(\n\t        {\n\t            \"permission_set\": to_set_if_list_or_str(_dict[\"PermissionSet\"]),\n\t            \"resource\": to_set_if_list_or_str(_dict[\"Resource\"]),\n\t            \"approvers\": to_set_if_list_or_str(_dict.get(\"Approvers\", set())),\n\t            \"resource_type\": _dict.get(\"ResourceType\"),\n\t            \"approval_is_not_required\": _dict.get(\"ApprovalIsNotRequired\", False),\n\t            \"allow_self_approval\": _dict.get(\"AllowSelfApproval\", False),\n\t        }\n", "    )\n\tclass Config(BaseSettings):\n\t    schedule_policy_arn: str\n\t    revoker_function_arn: str\n\t    revoker_function_name: str\n\t    schedule_group_name: str\n\t    post_update_to_slack: bool = False\n\t    slack_channel_id: str\n\t    slack_bot_token: str\n\t    approver_renotification_initial_wait_time: int\n", "    approver_renotification_backoff_multiplier: int\n\t    sso_instance_arn: str\n\t    log_level: str = \"INFO\"\n\t    slack_app_log_level: str = \"INFO\"\n\t    statements: frozenset[Statement]\n\t    accounts: frozenset[str]\n\t    permission_sets: frozenset[str]\n\t    s3_bucket_for_audit_entry_name: str\n\t    s3_bucket_prefix_for_partitions: str\n\t    sso_elevator_scheduled_revocation_rule_name: str\n", "    request_expiration_hours: int = 8\n\t    max_permissions_duration_time: int\n\t    class Config:\n\t        frozen = True\n\t    @root_validator(pre=True)\n\t    def get_accounts_and_permission_sets(cls, values: dict) -> dict:  # noqa: ANN101\n\t        statements = {parse_statement(st) for st in values.get(\"statements\", [])}  # type: ignore # noqa: PGH003\n\t        permission_sets = set()\n\t        accounts = set()\n\t        for statement in statements:\n", "            permission_sets.update(statement.permission_set)\n\t            if statement.resource_type == \"Account\":\n\t                accounts.update(statement.resource)\n\t        return values | {\"accounts\": accounts, \"permission_sets\": permission_sets, \"statements\": frozenset(statements)}\n\tdef get_logger(service: Optional[str] = None, level: Optional[str] = None) -> Logger:\n\t    kwargs = {\n\t        \"json_default\": entities.json_default,\n\t        \"level\": level or os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n\t    }\n\t    if service:\n", "        kwargs[\"service\"] = service\n\t    return Logger(**kwargs)\n\t_config: Optional[Config] = None\n\tdef get_config() -> Config:\n\t    global _config  # noqa: PLW0603\n\t    if _config is None:\n\t        _config = Config()  # type: ignore # noqa: PGH003\n\t    return _config\n"]}
{"filename": "src/errors.py", "chunked_list": ["class ConfigurationError(Exception):\n\t    ...\n\tclass AccountAssignmentError(ConfigurationError):\n\t    ...\n\tclass NotFound(ConfigurationError):\n\t    ...\n"]}
{"filename": "src/organizations.py", "chunked_list": ["from mypy_boto3_organizations import OrganizationsClient, type_defs\n\timport config\n\tfrom entities.aws import Account\n\tdef parse_account(td: type_defs.AccountTypeDef) -> Account:\n\t    return Account.parse_obj({\"id\": td.get(\"Id\"), \"name\": td.get(\"Name\")})\n\tdef list_accounts(client: OrganizationsClient) -> list[Account]:\n\t    accounts = []\n\t    paginator = client.get_paginator(\"list_accounts\")\n\t    for page in paginator.paginate():\n\t        accounts.extend(page[\"Accounts\"])\n", "    return [parse_account(account) for account in accounts]\n\tdef describe_account(client: OrganizationsClient, account_id: str) -> Account:\n\t    account = client.describe_account(AccountId=account_id)[\"Account\"]\n\t    return parse_account(account)\n\tdef get_accounts_from_config(client: OrganizationsClient, cfg: config.Config) -> list[Account]:\n\t    if \"*\" in cfg.accounts:\n\t        accounts = list_accounts(client)\n\t    else:\n\t        accounts = [ac for ac in list_accounts(client) if ac.id in cfg.accounts]\n\t    return accounts\n"]}
{"filename": "src/slack_helpers.py", "chunked_list": ["import datetime\n\timport time\n\tfrom datetime import timedelta\n\tfrom typing import Optional, TypeVar, Union\n\timport jmespath as jp\n\timport slack_sdk.errors\n\tfrom mypy_boto3_identitystore import IdentityStoreClient\n\tfrom mypy_boto3_sso_admin import SSOAdminClient\n\tfrom pydantic import root_validator\n\tfrom slack_sdk import WebClient\n", "from slack_sdk.models.blocks import (\n\t    ActionsBlock,\n\t    Block,\n\t    ButtonElement,\n\t    DividerBlock,\n\t    InputBlock,\n\t    MarkdownTextObject,\n\t    Option,\n\t    PlainTextInputElement,\n\t    PlainTextObject,\n", "    SectionBlock,\n\t    StaticSelectElement,\n\t)\n\tfrom slack_sdk.models.views import View\n\tfrom slack_sdk.web.slack_response import SlackResponse\n\timport config\n\timport entities\n\timport sso\n\tfrom entities import BaseModel\n\t# ruff: noqa: ANN102, PGH003\n", "logger = config.get_logger(service=\"slack\")\n\tcfg = config.get_config()\n\tclass RequestForAccess(BaseModel):\n\t    permission_set_name: str\n\t    account_id: str\n\t    reason: str\n\t    requester_slack_id: str\n\t    permission_duration: timedelta\n\tclass RequestForAccessView:\n\t    CALLBACK_ID = \"request_for_access_submitted\"\n", "    REASON_BLOCK_ID = \"provide_reason\"\n\t    REASON_ACTION_ID = \"provided_reason\"\n\t    ACCOUNT_BLOCK_ID = \"select_account\"\n\t    ACCOUNT_ACTION_ID = \"selected_account\"\n\t    PERMISSION_SET_BLOCK_ID = \"select_permission_set\"\n\t    PERMISSION_SET_ACTION_ID = \"selected_permission_set\"\n\t    DURATION_BLOCK_ID = \"duration_picker\"\n\t    DURATION_ACTION_ID = \"duration_picker_action\"\n\t    LOADING_BLOCK_ID = \"loading\"\n\t    @classmethod\n", "    def build(cls) -> View:\n\t        return View(\n\t            type=\"modal\",\n\t            callback_id=cls.CALLBACK_ID,\n\t            submit=PlainTextObject(text=\"Request\"),\n\t            close=PlainTextObject(text=\"Cancel\"),\n\t            title=PlainTextObject(text=\"Get AWS access\"),\n\t            blocks=[\n\t                SectionBlock(text=MarkdownTextObject(text=\":wave: Hey! Please fill form below to request AWS access.\")),\n\t                DividerBlock(),\n", "                SectionBlock(\n\t                    block_id=cls.DURATION_BLOCK_ID,\n\t                    text=MarkdownTextObject(text=\"Select the duration for which the authorization will be provided\"),\n\t                    accessory=StaticSelectElement(\n\t                        action_id=cls.DURATION_ACTION_ID,\n\t                        initial_option=get_max_duration_block(cfg)[0],\n\t                        options=get_max_duration_block(cfg),\n\t                        placeholder=PlainTextObject(text=\"Select duration\"),\n\t                    ),\n\t                ),\n", "                InputBlock(\n\t                    block_id=cls.REASON_BLOCK_ID,\n\t                    label=PlainTextObject(text=\"What is it you are going to do\"),\n\t                    element=PlainTextInputElement(\n\t                        action_id=cls.REASON_ACTION_ID,\n\t                        multiline=True,\n\t                    ),\n\t                ),\n\t                DividerBlock(),\n\t                SectionBlock(\n", "                    text=MarkdownTextObject(\n\t                        text=\"Remember to use access responsibly. All actions (AWS API calls) are being recorded.\",\n\t                    ),\n\t                ),\n\t                SectionBlock(\n\t                    block_id=cls.LOADING_BLOCK_ID,\n\t                    text=MarkdownTextObject(\n\t                        text=\":hourglass: Loading available accounts and permission sets...\",\n\t                    ),\n\t                ),\n", "            ],\n\t        )\n\t    @classmethod\n\t    def build_select_account_input_block(cls, accounts: list[entities.aws.Account]) -> InputBlock:\n\t        # TODO: handle case when there are more than 100 accounts\n\t        # 99 is the limit for StaticSelectElement\n\t        # https://slack.dev/python-slack-sdk/api-docs/slack_sdk/models/blocks/block_elements.html#:~:text=StaticSelectElement(InputInteractiveElement)%3A%0A%20%20%20%20type%20%3D%20%22static_select%22-,options_max_length%20%3D%20100,-option_groups_max_length%20%3D%20100%0A%0A%20%20%20%20%40property%0A%20%20%20%20def%20attributes(\n\t        if len(accounts) >99: # noqa: PLR2004\n\t            accounts = accounts[:99]\n\t        sorted_accounts = sorted(accounts, key=lambda account: account.name)\n", "        return InputBlock(\n\t            block_id=cls.ACCOUNT_BLOCK_ID,\n\t            label=PlainTextObject(text=\"Select account\"),\n\t            element=StaticSelectElement(\n\t                action_id=cls.ACCOUNT_ACTION_ID,\n\t                placeholder=PlainTextObject(text=\"Select account\"),\n\t                options=[\n\t                    Option(text=PlainTextObject(text=f\"{account.id} - {account.name}\"), value=account.id) for account in sorted_accounts\n\t                ],\n\t            ),\n", "        )\n\t    @classmethod\n\t    def build_select_permission_set_input_block(cls, permission_sets: list[entities.aws.PermissionSet]) -> InputBlock:\n\t        sorted_permission_sets = sorted(permission_sets, key=lambda permission_set: permission_set.name)\n\t        return InputBlock(\n\t            block_id=cls.PERMISSION_SET_BLOCK_ID,\n\t            label=PlainTextObject(text=\"Select permission set\"),\n\t            element=StaticSelectElement(\n\t                action_id=cls.PERMISSION_SET_ACTION_ID,\n\t                placeholder=PlainTextObject(text=\"Select permission set\"),\n", "                options=[\n\t                    Option(text=PlainTextObject(text=permission_set.name), value=permission_set.name)\n\t                    for permission_set in sorted_permission_sets\n\t                ],\n\t            ),\n\t        )\n\t    @classmethod\n\t    def update_with_accounts_and_permission_sets(\n\t        cls, accounts: list[entities.aws.Account], permission_sets: list[entities.aws.PermissionSet]\n\t    ) -> View:\n", "        view = cls.build()\n\t        view.blocks = remove_blocks(view.blocks, block_ids=[cls.LOADING_BLOCK_ID])\n\t        view.blocks = insert_blocks(\n\t            blocks=view.blocks,\n\t            blocks_to_insert=[\n\t                cls.build_select_account_input_block(accounts),\n\t                cls.build_select_permission_set_input_block(permission_sets),\n\t            ],\n\t            after_block_id=cls.REASON_BLOCK_ID,\n\t        )\n", "        return view\n\t    @classmethod\n\t    def parse(cls, obj: dict) -> RequestForAccess:\n\t        values = jp.search(\"view.state.values\", obj)\n\t        hhmm = jp.search(f\"{cls.DURATION_BLOCK_ID}.{cls.DURATION_ACTION_ID}.selected_option.value\", values)\n\t        hours, minutes = map(int, hhmm.split(\":\"))\n\t        duration = timedelta(hours=hours, minutes=minutes)\n\t        return RequestForAccess.parse_obj(\n\t            {\n\t                \"permission_duration\": duration,\n", "                \"permission_set_name\": jp.search(\n\t                    f\"{cls.PERMISSION_SET_BLOCK_ID}.{cls.PERMISSION_SET_ACTION_ID}.selected_option.value\", values\n\t                ),\n\t                \"account_id\": jp.search(f\"{cls.ACCOUNT_BLOCK_ID}.{cls.ACCOUNT_ACTION_ID}.selected_option.value\", values),\n\t                \"reason\": jp.search(f\"{cls.REASON_BLOCK_ID}.{cls.REASON_ACTION_ID}.value\", values),\n\t                \"requester_slack_id\": jp.search(\"user.id\", obj),\n\t            }\n\t        )\n\tT = TypeVar(\"T\", Block, dict)\n\tdef get_block_id(block: Union[Block, dict]) -> Optional[str]:\n", "    return block[\"block_id\"] if isinstance(block, dict) else block.block_id\n\tdef remove_blocks(blocks: list[T], block_ids: list[str]) -> list[T]:\n\t    return [block for block in blocks if get_block_id(block) not in block_ids]\n\tdef insert_blocks(blocks: list[T], blocks_to_insert: list[Block], after_block_id: str) -> list[T]:\n\t    index = next(i for i, block in enumerate(blocks) if get_block_id(block) == after_block_id)\n\t    return blocks[: index + 1] + blocks_to_insert + blocks[index + 1 :]  # type: ignore\n\tdef humanize_timedelta(td: timedelta) -> str:\n\t    # example 12h 30m\n\t    hours, remainder = divmod(td.seconds, 3600)\n\t    minutes, _ = divmod(remainder, 60)\n", "    return f\"{hours}h {minutes}m\"\n\tdef unhumanize_timedelta(td_str: str) -> timedelta:\n\t    hours, minutes = td_str.split(\" \")\n\t    hours = hours.removesuffix(\"h\")\n\t    minutes = minutes.removesuffix(\"m\")\n\t    return timedelta(hours=int(hours), minutes=int(minutes))\n\tdef build_approval_request_message_blocks(  # noqa: PLR0913\n\t    requester_slack_id: str,\n\t    account: entities.aws.Account,\n\t    role_name: str,\n", "    reason: str,\n\t    permission_duration: timedelta,\n\t    show_buttons: bool = True,\n\t) -> list[Block]:\n\t    blocks: list[Block] = [\n\t        SectionBlock(block_id=\"header\", text=MarkdownTextObject(text=\"AWS account access request.\")),\n\t        SectionBlock(\n\t            block_id=\"content\",\n\t            fields=[\n\t                MarkdownTextObject(text=f\"Requester: <@{requester_slack_id}>\"),\n", "                MarkdownTextObject(text=f\"Account: {account.name} #{account.id}\"),\n\t                MarkdownTextObject(text=f\"Role name: {role_name}\"),\n\t                MarkdownTextObject(text=f\"Reason: {reason}\"),\n\t                MarkdownTextObject(text=f\"Permission duration: {humanize_timedelta(permission_duration)}\"),\n\t            ],\n\t        ),\n\t    ]\n\t    if show_buttons:\n\t        blocks.append(\n\t            ActionsBlock(\n", "                block_id=\"buttons\",\n\t                elements=[\n\t                    ButtonElement(\n\t                        action_id=entities.ApproverAction.Approve.value,\n\t                        text=PlainTextObject(text=\"Approve\"),\n\t                        style=\"primary\",\n\t                        value=entities.ApproverAction.Approve.value,\n\t                    ),\n\t                    ButtonElement(\n\t                        action_id=entities.ApproverAction.Discard.value,\n", "                        text=PlainTextObject(text=\"Discard\"),\n\t                        style=\"danger\",\n\t                        value=entities.ApproverAction.Discard.value,\n\t                    ),\n\t                ],\n\t            )\n\t        )\n\t    return blocks\n\tdef button_click_info_block(action: entities.ApproverAction, approver_slack_id: str) -> SectionBlock:\n\t    return SectionBlock(\n", "        block_id=\"footer\",\n\t        text=MarkdownTextObject(\n\t            text=f\"<@{approver_slack_id}> pressed {action.value} button\",\n\t        ),\n\t    )\n\tclass ButtonClickedPayload(BaseModel):\n\t    action: entities.ApproverAction\n\t    approver_slack_id: str\n\t    thread_ts: str\n\t    channel_id: str\n", "    message: dict\n\t    request: RequestForAccess\n\t    class Config:\n\t        frozen = True\n\t    @root_validator(pre=True)\n\t    def validate_payload(cls, values: dict) -> dict:  # noqa: ANN101\n\t        fields = jp.search(\"message.blocks[?block_id == 'content'].fields[]\", values)\n\t        requester_mention = cls.find_in_fields(fields, \"Requester\")\n\t        requester_slack_id = requester_mention.removeprefix(\"<@\").removesuffix(\">\")\n\t        humanized_permission_duration = cls.find_in_fields(fields, \"Permission duration\")\n", "        permission_duration = unhumanize_timedelta(humanized_permission_duration)\n\t        account = cls.find_in_fields(fields, \"Account\")\n\t        account_id = account.split(\"#\")[-1]\n\t        return {\n\t            \"action\": jp.search(\"actions[0].value\", values),\n\t            \"approver_slack_id\": jp.search(\"user.id\", values),\n\t            \"thread_ts\": jp.search(\"message.ts\", values),\n\t            \"channel_id\": jp.search(\"channel.id\", values),\n\t            \"message\": values.get(\"message\"),\n\t            \"request\": RequestForAccess(\n", "                requester_slack_id=requester_slack_id,\n\t                account_id=account_id,\n\t                permission_set_name=cls.find_in_fields(fields, \"Role name\"),\n\t                reason=cls.find_in_fields(fields, \"Reason\"),\n\t                permission_duration=permission_duration,\n\t            ),\n\t        }\n\t    @staticmethod\n\t    def find_in_fields(fields: list[dict[str, str]], key: str) -> str:\n\t        for field in fields:\n", "            if field[\"text\"].startswith(key):\n\t                return field[\"text\"].split(\": \")[1].strip()\n\t        raise ValueError(f\"Failed to parse message. Could not find {key} in fields: {fields}\")\n\tdef parse_user(user: dict) -> entities.slack.User:\n\t    return entities.slack.User.parse_obj(\n\t        {\"id\": jp.search(\"user.id\", user), \"email\": jp.search(\"user.profile.email\", user), \"real_name\": jp.search(\"user.real_name\", user)}\n\t    )\n\tdef get_user(client: WebClient, id: str) -> entities.slack.User:\n\t    response = client.users_info(user=id)\n\t    return parse_user(response.data)  # type: ignore\n", "def get_user_by_email(client: WebClient, email: str) -> entities.slack.User:\n\t    start = datetime.datetime.now()\n\t    timeout_seconds = 30\n\t    try:\n\t        r = client.users_lookupByEmail(email=email)\n\t        return parse_user(r.data)  # type: ignore\n\t    except slack_sdk.errors.SlackApiError as e:\n\t        if e.response[\"error\"] == \"ratelimited\":\n\t            if datetime.datetime.now() - start >= datetime.timedelta(seconds=timeout_seconds):\n\t                raise e\n", "            logger.info(f\"Rate limited when getting slack user by email. Sleeping for 3 seconds. {e}\")\n\t            time.sleep(3)\n\t            return get_user_by_email(client, email)\n\t        else:\n\t            raise e\n\t    except Exception as e:\n\t        raise e\n\tdef remove_buttons(payload: ButtonClickedPayload, client: WebClient, approver: entities.slack.User) -> SlackResponse:\n\t    blocks = remove_blocks(payload.message[\"blocks\"], block_ids=[\"buttons\"])\n\t    blocks.append(button_click_info_block(payload.action, approver.id))\n", "    return client.chat_update(\n\t        channel=payload.channel_id,\n\t        ts=payload.thread_ts,\n\t        blocks=blocks,\n\t        text=\"Buttons were removed.\",\n\t    )\n\tdef create_slack_mention_by_principal_id(\n\t    account_assignment: sso.AccountAssignment | sso.UserAccountAssignment,\n\t    sso_client: SSOAdminClient,\n\t    cfg: config.Config,\n", "    identitystore_client: IdentityStoreClient,\n\t    slack_client: WebClient,\n\t) -> str:\n\t    sso_instance = sso.describe_sso_instance(sso_client, cfg.sso_instance_arn)\n\t    aws_user_emails = sso.get_user_emails(\n\t        identitystore_client,\n\t        sso_instance.identity_store_id,\n\t        account_assignment.principal_id if isinstance(account_assignment, sso.AccountAssignment) else account_assignment.user_principal_id,\n\t    )\n\t    user_name = None\n", "    for email in aws_user_emails:\n\t        try:\n\t            slack_user = get_user_by_email(slack_client, email)\n\t            user_name = slack_user.real_name\n\t        except Exception:\n\t            continue\n\t    return f\"{user_name}\" if user_name is not None else aws_user_emails[0]\n\tdef get_message_from_timestamp(channel_id: str, message_ts: str, slack_client: slack_sdk.WebClient) -> dict | None:\n\t    response = slack_client.conversations_history(channel=channel_id)\n\t    if response[\"ok\"]:\n", "        messages = response.get(\"messages\")\n\t        if messages is not None:\n\t            for message in messages:\n\t                if \"ts\" in message and message[\"ts\"] == message_ts:\n\t                    return message\n\t    return None\n\tdef get_max_duration_block(cfg: config.Config) -> list[Option]:\n\t    return [\n\t        Option(text=PlainTextObject(text=f\"{i // 2:02d}:{(i % 2) * 30:02d}\"), value=f\"{i // 2:02d}:{(i % 2) * 30:02d}\")\n\t        for i in range(1, cfg.max_permissions_duration_time * 2 + 1)\n", "    ]\n"]}
{"filename": "src/sso.py", "chunked_list": ["from __future__ import annotations\n\timport datetime\n\timport time\n\tfrom dataclasses import dataclass\n\tfrom typing import TYPE_CHECKING, Callable, Generator, Optional, TypeVar\n\timport config\n\timport entities\n\timport errors\n\timport organizations\n\tif TYPE_CHECKING:\n", "    from mypy_boto3_identitystore import IdentityStoreClient\n\t    from mypy_boto3_organizations import OrganizationsClient\n\t    from mypy_boto3_sso_admin import SSOAdminClient, type_defs\n\t    from entities.aws import PermissionSet\n\t# ruff: noqa: PGH003\n\tT = TypeVar(\"T\")\n\tlogger = config.get_logger(service=\"sso\")\n\t@dataclass\n\tclass AccountAssignmentStatus:\n\t    status: str\n", "    request_id: str\n\t    failure_reason: Optional[str]\n\t    target_id: str\n\t    target_type: str\n\t    permission_set_arn: str\n\t    principal_type: str\n\t    principal_id: str\n\t    created_date: Optional[str]\n\t    @staticmethod\n\t    def from_type_def(d: type_defs.AccountAssignmentOperationStatusTypeDef) -> AccountAssignmentStatus:\n", "        return AccountAssignmentStatus(\n\t            status=d[\"Status\"],  # type: ignore\n\t            request_id=d[\"RequestId\"],  # type: ignore\n\t            failure_reason=d.get(\"FailureReason\"),  # type: ignore\n\t            target_id=d[\"TargetId\"],  # type: ignore\n\t            target_type=d[\"TargetType\"],  # type: ignore\n\t            permission_set_arn=d[\"PermissionSetArn\"],  # type: ignore\n\t            principal_type=d[\"PrincipalType\"],  # type: ignore\n\t            principal_id=d[\"PrincipalId\"],  # type: ignore\n\t            created_date=d.get(\"CreatedDate\"),  # type: ignore\n", "        )\n\t    @staticmethod\n\t    def is_in_progress(status: AccountAssignmentStatus) -> bool:\n\t        return status.status == \"IN_PROGRESS\"\n\t    @staticmethod\n\t    def is_ready(status: AccountAssignmentStatus) -> bool:\n\t        return status.status == \"SUCCEEDED\"\n\t    @staticmethod\n\t    def is_failed(status: AccountAssignmentStatus) -> bool:\n\t        return status.status == \"FAILED\"\n", "@dataclass\n\tclass UserAccountAssignment:\n\t    instance_arn: str\n\t    account_id: str\n\t    permission_set_arn: str\n\t    user_principal_id: str\n\t    def as_dict(self: UserAccountAssignment) -> dict:\n\t        return {\n\t            \"InstanceArn\": self.instance_arn,\n\t            \"TargetId\": self.account_id,\n", "            \"PermissionSetArn\": self.permission_set_arn,\n\t            \"PrincipalId\": self.user_principal_id,\n\t            \"TargetType\": \"AWS_ACCOUNT\",\n\t            \"PrincipalType\": \"USER\",\n\t        }\n\tdef create_account_assignment(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n\t    response = client.create_account_assignment(**assignment.as_dict())\n\t    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentCreationStatus\"])\n\tdef delete_account_assignment(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n\t    response = client.delete_account_assignment(**assignment.as_dict())\n", "    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentDeletionStatus\"])\n\tdef describe_account_assignment_creation_status(\n\t    client: SSOAdminClient, assignment: UserAccountAssignment, request_id: str\n\t) -> AccountAssignmentStatus:\n\t    response = client.describe_account_assignment_creation_status(\n\t        InstanceArn=assignment.instance_arn,\n\t        AccountAssignmentCreationRequestId=request_id,\n\t    )\n\t    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentCreationStatus\"])\n\tdef describe_account_assignment_deletion_status(\n", "    client: SSOAdminClient, assignment: UserAccountAssignment, request_id: str\n\t) -> AccountAssignmentStatus:\n\t    response = client.describe_account_assignment_deletion_status(\n\t        InstanceArn=assignment.instance_arn,\n\t        AccountAssignmentDeletionRequestId=request_id,\n\t    )\n\t    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentDeletionStatus\"])\n\tdef retry_while(\n\t    fn: Callable[[], T],\n\t    condition: Callable[[T], bool],\n", "    retry_period_seconds: int = 1,\n\t    timeout_seconds: int = 20,\n\t) -> T:\n\t    # If timeout_seconds -1, then retry forever.\n\t    start = datetime.datetime.now()\n\t    def is_timeout(timeout_seconds: int) -> bool:\n\t        if timeout_seconds == -1:\n\t            return False\n\t        return datetime.datetime.now() - start >= datetime.timedelta(seconds=timeout_seconds)\n\t    while True:\n", "        response = fn()\n\t        if is_timeout(timeout_seconds):\n\t            return response\n\t        if condition(response):\n\t            time.sleep(retry_period_seconds)\n\t            continue\n\t        else:\n\t            return response\n\tdef create_account_assignment_and_wait_for_result(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n\t    response = create_account_assignment(client, assignment)\n", "    if AccountAssignmentStatus.is_ready(response):\n\t        return response\n\t    else:\n\t        def fn() -> AccountAssignmentStatus:\n\t            return describe_account_assignment_creation_status(client, assignment, response.request_id)\n\t        result = retry_while(fn, condition=AccountAssignmentStatus.is_in_progress, timeout_seconds=-1)\n\t    if AccountAssignmentStatus.is_failed(result):\n\t        e = errors.AccountAssignmentError(\"Failed to create account assignment.\")\n\t        logger.exception(e, extra={\"status\": result})\n\t        raise e\n", "    logger.info(\"Account assignment creation finished successfully.\")\n\t    return result\n\tdef delete_account_assignment_and_wait_for_result(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n\t    response = delete_account_assignment(client, assignment)\n\t    if AccountAssignmentStatus.is_ready(response):\n\t        return response\n\t    else:\n\t        def fn() -> AccountAssignmentStatus:\n\t            return describe_account_assignment_deletion_status(client, assignment, response.request_id)\n\t        result = retry_while(fn, condition=AccountAssignmentStatus.is_in_progress, timeout_seconds=-1)\n", "    if AccountAssignmentStatus.is_failed(result):\n\t        e = errors.AccountAssignmentError(\"Failed to delete account assignment.\")\n\t        logger.exception(e, extra={\"status\": result})\n\t        raise e\n\t    logger.info(\"Account assignment deletion finished successfully.\")\n\t    return result\n\t@dataclass\n\tclass IAMIdentityCenterInstance:\n\t    \"\"\"IAM Identity Center Instance\n\t    Attributes:\n", "        arn (str): ARN of the IAM Identity Center Instance\n\t        identity_store_id (str): ID of the Identity Store\n\t    \"\"\"\n\t    arn: str\n\t    identity_store_id: str\n\t    @staticmethod\n\t    def from_instance_metadata_type_def(td: type_defs.InstanceMetadataTypeDef) -> \"IAMIdentityCenterInstance\":\n\t        return IAMIdentityCenterInstance(\n\t            arn=td[\"InstanceArn\"],  # type: ignore\n\t            identity_store_id=td[\"IdentityStoreId\"],  # type: ignore\n", "        )\n\tdef list_sso_instances(client: SSOAdminClient) -> list[IAMIdentityCenterInstance]:\n\t    \"\"\"List all IAM Identity Center Instances\n\t    Returns:\n\t        list[IAMIdentityCenterInstance]: List of IAM Identity Center Instances\n\t    \"\"\"\n\t    instances: list[IAMIdentityCenterInstance] = []\n\t    paginator = client.get_paginator(\"list_instances\")\n\t    for page in paginator.paginate():\n\t        instances.extend(IAMIdentityCenterInstance.from_instance_metadata_type_def(instance) for instance in page[\"Instances\"])\n", "    return instances\n\tdef describe_sso_instance(client: SSOAdminClient, instance_arn: str) -> IAMIdentityCenterInstance:\n\t    \"\"\"Describe IAM Identity Center Instance\n\t    Args:\n\t        instance_arn (str): ARN of the IAM Identity Center Instance\n\t    Returns:\n\t        IAMIdentityCenterInstance: IAM Identity Center Instance\n\t    \"\"\"\n\t    sso_instances = list_sso_instances(client)\n\t    return next(instance for instance in sso_instances if instance.arn == instance_arn)\n", "@dataclass\n\tclass AccountAssignment:\n\t    account_id: str\n\t    permission_set_arn: str\n\t    principal_id: str\n\t    principal_type: str\n\t    @staticmethod\n\t    def from_type_def(td: type_defs.AccountAssignmentTypeDef) -> AccountAssignment:\n\t        return AccountAssignment(\n\t            account_id=td[\"AccountId\"],  # type: ignore\n", "            permission_set_arn=td[\"PermissionSetArn\"],  # type: ignore\n\t            principal_id=td[\"PrincipalId\"],  # type: ignore\n\t            principal_type=td[\"PrincipalType\"],  # type: ignore\n\t        )\n\tdef list_user_account_assignments(\n\t    client: SSOAdminClient,\n\t    instance_arn: str,\n\t    account_ids: list[str],\n\t    permission_set_arns: list[str],\n\t) -> list[\"AccountAssignment\"]:\n", "    paginator = client.get_paginator(\"list_account_assignments\")\n\t    account_assignments: list[AccountAssignment] = []\n\t    for account_id in account_ids:\n\t        for permission_set_arn in permission_set_arns:\n\t            for page in paginator.paginate(\n\t                InstanceArn=instance_arn,\n\t                AccountId=account_id,\n\t                PermissionSetArn=permission_set_arn,\n\t            ):\n\t                for account_assignment in page[\"AccountAssignments\"]:\n", "                    aa = AccountAssignment.from_type_def(account_assignment)\n\t                    if aa.principal_type == \"USER\":\n\t                        account_assignments.append(aa)\n\t    return account_assignments\n\tdef parse_permission_set(td: type_defs.DescribePermissionSetResponseTypeDef) -> entities.aws.PermissionSet:\n\t    ps = td.get(\"PermissionSet\", {})\n\t    return entities.aws.PermissionSet.parse_obj(\n\t        {\n\t            \"name\": ps.get(\"Name\"),\n\t            \"arn\": ps.get(\"PermissionSetArn\"),\n", "            \"description\": ps.get(\"Description\"),\n\t        }\n\t    )\n\tdef describe_permission_set(client: SSOAdminClient, sso_instance_arn: str, permission_set_arn: str) -> entities.aws.PermissionSet:\n\t    td = client.describe_permission_set(InstanceArn=sso_instance_arn, PermissionSetArn=permission_set_arn)\n\t    return parse_permission_set(td)\n\tdef get_permission_set_by_name(client: SSOAdminClient, sso_instance_arn: str, permission_set_name: str) -> entities.aws.PermissionSet:\n\t    if ps := next(\n\t        (permission_set for permission_set in list_permission_sets(client, sso_instance_arn) if permission_set.name == permission_set_name),\n\t        None,\n", "    ):\n\t        return ps\n\t    raise errors.NotFound(f\"Permission set with name {permission_set_name} not found\")\n\tdef list_permission_sets_arns(client: SSOAdminClient, sso_instance_arn: str) -> Generator[str, None, None]:\n\t    paginator = client.get_paginator(\"list_permission_sets\")\n\t    for page in paginator.paginate(InstanceArn=sso_instance_arn):\n\t        yield from page[\"PermissionSets\"]\n\tdef list_permission_sets(client: SSOAdminClient, sso_instance_arn: str) -> Generator[entities.aws.PermissionSet, None, None]:\n\t    for permission_set_arn in list_permission_sets_arns(client, sso_instance_arn):\n\t        yield describe_permission_set(client, sso_instance_arn, permission_set_arn)\n", "def get_user_principal_id_by_email(client: IdentityStoreClient, identity_store_id: str, email: str) -> str:\n\t    response = client.list_users(IdentityStoreId=identity_store_id)\n\t    for user in response[\"Users\"]:\n\t        for user_email in user.get(\"Emails\", []):\n\t            if user_email.get(\"Value\") == email:\n\t                return user[\"UserId\"]\n\t    raise errors.NotFound(f\"AWS SSO User with email {email} not found\")\n\tdef get_user_emails(client: IdentityStoreClient, identity_store_id: str, user_id: str) -> list[str]:\n\t    user = client.describe_user(\n\t        IdentityStoreId=identity_store_id,\n", "        UserId=user_id,\n\t    )\n\t    return [email[\"Value\"] for email in user[\"Emails\"] if \"Value\" in email]\n\tdef get_permission_sets_from_config(client: SSOAdminClient, cfg: config.Config) -> list[PermissionSet]:\n\t    if \"*\" in cfg.permission_sets:\n\t        permission_sets = list(list_permission_sets(client, cfg.sso_instance_arn))\n\t    else:\n\t        permission_sets = [ps for ps in list_permission_sets(client, cfg.sso_instance_arn) if ps.name in cfg.permission_sets]\n\t    return permission_sets\n\tdef get_account_assignment_information(\n", "    sso_client: SSOAdminClient, cfg: config.Config, org_client: OrganizationsClient\n\t) -> list[AccountAssignment]:\n\t    describe_sso_instance(sso_client, cfg.sso_instance_arn)\n\t    accounts = organizations.get_accounts_from_config(org_client, cfg)\n\t    permission_sets = get_permission_sets_from_config(sso_client, cfg)\n\t    account_assignments = list_user_account_assignments(\n\t        sso_client,\n\t        cfg.sso_instance_arn,\n\t        [a.id for a in accounts],\n\t        [ps.arn for ps in permission_sets],\n", "    )\n\t    return account_assignments\n"]}
{"filename": "src/s3.py", "chunked_list": ["import json\n\timport uuid\n\tfrom dataclasses import asdict, dataclass\n\tfrom datetime import datetime, timedelta\n\tfrom mypy_boto3_s3 import S3Client, type_defs\n\timport boto3\n\tfrom config import get_config, get_logger\n\tcfg = get_config()\n\tlogger = get_logger(service=\"s3\")\n\ts3: S3Client = boto3.client(\"s3\")\n", "@dataclass\n\tclass AuditEntry:\n\t    role_name: str\n\t    account_id: str\n\t    reason: str\n\t    requester_slack_id: str\n\t    requester_email: str\n\t    request_id: str\n\t    approver_slack_id: str\n\t    approver_email: str\n", "    operation_type: str\n\t    permission_duration: str | timedelta\n\tdef log_operation(audit_entry: AuditEntry) -> type_defs.PutObjectOutputTypeDef:\n\t    now = datetime.now()\n\t    logger.debug(\"Posting audit entry to s3\", extra={\"audit_entry\": audit_entry})\n\t    logger.info(\"Posting audit entry to s3\")\n\t    if isinstance(audit_entry.permission_duration, timedelta):\n\t        permission_duration = str(int(audit_entry.permission_duration.total_seconds()))\n\t    else:\n\t        permission_duration = \"NA\"\n", "    audit_entry_dict = asdict(audit_entry) | {\n\t        \"permission_duration\": permission_duration,\n\t        \"time\": str(now),\n\t        \"timestamp\": int(now.timestamp() * 1000),\n\t    }\n\t    json_data = json.dumps(audit_entry_dict)\n\t    bucket_name = cfg.s3_bucket_for_audit_entry_name\n\t    bucket_prefix = cfg.s3_bucket_prefix_for_partitions\n\t    return s3.put_object(\n\t        Bucket=bucket_name,\n", "        Key=f\"{bucket_prefix}/{now.strftime('%Y/%m/%d')}/{uuid.uuid4()}.json\",\n\t        Body=json_data,\n\t        ContentType=\"application/json\",\n\t    )\n"]}
{"filename": "src/schedule.py", "chunked_list": ["import json\n\tfrom datetime import datetime, timedelta, timezone\n\timport botocore.exceptions\n\timport jmespath as jp\n\tfrom croniter import croniter\n\tfrom mypy_boto3_events import EventBridgeClient\n\tfrom mypy_boto3_events import type_defs as events_type_defs\n\tfrom mypy_boto3_scheduler import EventBridgeSchedulerClient\n\tfrom mypy_boto3_scheduler import type_defs as scheduler_type_defs\n\tfrom pydantic import ValidationError\n", "import config\n\timport entities\n\timport sso\n\tfrom events import DiscardButtonsEvent, Event, RevokeEvent, ScheduledRevokeEvent, ApproverNotificationEvent\n\tlogger = config.get_logger(service=\"schedule\")\n\tcfg = config.get_config()\n\tdef get_event_brige_rule(event_brige_client: EventBridgeClient, rule_name: str) -> events_type_defs.DescribeRuleResponseTypeDef:\n\t    return event_brige_client.describe_rule(Name=rule_name)\n\tdef get_next_cron_run_time(cron_expression: str, base_time: datetime) -> datetime:\n\t    # Replace ? with * to comply with croniter\n", "    cron_expression = cron_expression.replace(\"?\", \"*\")\n\t    cron_iter = croniter(cron_expression, base_time)\n\t    next_run_time = cron_iter.get_next(datetime)\n\t    logger.debug(f\"Next run time: {next_run_time}\")\n\t    return next_run_time\n\tdef check_rule_expression_and_get_next_run(rule: events_type_defs.DescribeRuleResponseTypeDef) -> datetime | str:\n\t    schedule_expression = rule[\"ScheduleExpression\"]\n\t    current_time = datetime.utcnow()\n\t    logger.debug(f\"Current time: {current_time}\")\n\t    logger.debug(f\"Schedule expression: {schedule_expression}\")\n", "    if schedule_expression.startswith(\"rate\"):\n\t        return schedule_expression\n\t    elif schedule_expression.startswith(\"cron\"):\n\t        clean_expression = schedule_expression.replace(\"cron(\", \"\").replace(\")\", \"\")\n\t        try:\n\t            return get_next_cron_run_time(clean_expression, current_time)\n\t        except Exception as e:\n\t            logger.warning(f\"Unable to parse cron expression: {clean_expression}\", extra={\"error\": e})\n\t            return schedule_expression\n\t    else:\n", "        raise ValueError(\"Unknown schedule expression format!\")\n\tdef get_schedules(client: EventBridgeSchedulerClient) -> list[scheduler_type_defs.GetScheduleOutputTypeDef]:\n\t    paginator = client.get_paginator(\"list_schedules\")\n\t    scheduled_events = []\n\t    for page in paginator.paginate(GroupName=cfg.schedule_group_name):\n\t        schedules_names = jp.search(\"Schedules[*].Name\", page)\n\t        for schedule_name in schedules_names:\n\t            if not schedule_name:\n\t                continue\n\t            full_schedule = client.get_schedule(GroupName=cfg.schedule_group_name, Name=schedule_name)\n", "            scheduled_events.append(full_schedule)\n\t    return scheduled_events\n\tdef get_scheduled_events(client: EventBridgeSchedulerClient) -> list[ScheduledRevokeEvent]:\n\t    scheduled_events = get_schedules(client)\n\t    scheduled_revoke_events: list[ScheduledRevokeEvent] = []\n\t    for full_schedule in scheduled_events:\n\t        if full_schedule[\"Name\"].startswith(\"discard-buttons\"):\n\t            continue\n\t        event = json.loads(jp.search(\"Target.Input\", full_schedule))\n\t        try:\n", "            event = Event.parse_obj(event)\n\t        except ValidationError as e:\n\t            logger.warning(\"Got unexpected event\", extra={\"event\": event, \"error\": e})\n\t            continue\n\t        if isinstance(event.__root__, ScheduledRevokeEvent):\n\t            scheduled_revoke_events.append(event.__root__)\n\t            print(\"case: ScheduledRevokeEvent\")\n\t    return scheduled_revoke_events\n\tdef delete_schedule(client: EventBridgeSchedulerClient, schedule_name: str) -> None:\n\t    try:\n", "        client.delete_schedule(GroupName=cfg.schedule_group_name, Name=schedule_name)\n\t        logger.info(\"Schedule deleted\", extra={\"schedule_name\": schedule_name})\n\t    except botocore.exceptions.ClientError as e:\n\t        if jp.search(\"Error.Code\", e.response) == \"ResourceNotFoundException\":\n\t            logger.info(\"Schedule for deletion was not found\", extra={\"schedule_name\": schedule_name})\n\t        else:\n\t            raise e\n\tdef get_and_delete_scheduled_revoke_event_if_already_exist(\n\t    client: EventBridgeSchedulerClient,\n\t    user_account_assignment: sso.UserAccountAssignment,\n", ") -> None:\n\t    for scheduled_event in get_scheduled_events(client):\n\t        if scheduled_event.revoke_event.user_account_assignment == user_account_assignment:\n\t            logger.info(\"Schedule already exist, deleting it\", extra={\"schedule_name\": scheduled_event.revoke_event.schedule_name})\n\t            delete_schedule(client, scheduled_event.revoke_event.schedule_name)\n\tdef event_bridge_schedule_after(td: timedelta) -> str:\n\t    now = datetime.now(timezone.utc)\n\t    return f\"at({(now + td).replace(microsecond=0).isoformat().replace('+00:00', '')})\"\n\tdef schedule_revoke_event(\n\t    schedule_client: EventBridgeSchedulerClient,\n", "    permission_duration: timedelta,\n\t    approver: entities.slack.User,\n\t    requester: entities.slack.User,\n\t    user_account_assignment: sso.UserAccountAssignment,\n\t) -> scheduler_type_defs.CreateScheduleOutputTypeDef:\n\t    logger.info(\"Scheduling revoke event\")\n\t    schedule_name = f\"{cfg.revoker_function_name}\" + datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\")\n\t    get_and_delete_scheduled_revoke_event_if_already_exist(schedule_client, user_account_assignment)\n\t    revoke_event = RevokeEvent(\n\t        schedule_name=schedule_name,\n", "        approver=approver,\n\t        requester=requester,\n\t        user_account_assignment=user_account_assignment,\n\t        permission_duration=permission_duration,\n\t    )\n\t    logger.debug(\"Creating schedule\", extra={\"revoke_event\": revoke_event})\n\t    return schedule_client.create_schedule(\n\t        FlexibleTimeWindow={\"Mode\": \"OFF\"},\n\t        Name=schedule_name,\n\t        GroupName=cfg.schedule_group_name,\n", "        ScheduleExpression=event_bridge_schedule_after(permission_duration),\n\t        State=\"ENABLED\",\n\t        Target=scheduler_type_defs.TargetTypeDef(\n\t            Arn=cfg.revoker_function_arn,\n\t            RoleArn=cfg.schedule_policy_arn,\n\t            Input=json.dumps(\n\t                {\n\t                    \"action\": \"event_bridge_revoke\",\n\t                    \"revoke_event\": revoke_event.json(),\n\t                },\n", "            ),\n\t        ),\n\t    )\n\tdef schedule_discard_buttons_event(\n\t    schedule_client: EventBridgeSchedulerClient,\n\t    time_stamp: str,\n\t    channel_id: str,\n\t) -> scheduler_type_defs.CreateScheduleOutputTypeDef | None:\n\t    if cfg.request_expiration_hours == 0:\n\t        logger.info(\"Request expiration is disabled, not scheduling discard buttons event\")\n", "        return\n\t    permission_duration = timedelta(hours=cfg.request_expiration_hours)\n\t    logger.info(\"Scheduling discard buttons event\")\n\t    schedule_name = \"discard-buttons\" + datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\")\n\t    logger.debug(\n\t        \"Creating schedule\",\n\t        extra={\n\t            \"schedule_name\": schedule_name,\n\t            \"permission_duration\": permission_duration,\n\t            \"time_stamp\": time_stamp,\n", "            \"channel_id\": channel_id,\n\t        },\n\t    )\n\t    return schedule_client.create_schedule(\n\t        FlexibleTimeWindow={\"Mode\": \"OFF\"},\n\t        Name=schedule_name,\n\t        GroupName=cfg.schedule_group_name,\n\t        ScheduleExpression=event_bridge_schedule_after(permission_duration),\n\t        State=\"ENABLED\",\n\t        Target=scheduler_type_defs.TargetTypeDef(\n", "            Arn=cfg.revoker_function_arn,\n\t            RoleArn=cfg.schedule_policy_arn,\n\t            Input=json.dumps(\n\t                DiscardButtonsEvent(\n\t                    action=\"discard_buttons_event\",\n\t                    schedule_name=schedule_name,\n\t                    time_stamp=time_stamp,\n\t                    channel_id=channel_id,\n\t                ).dict()\n\t            ),\n", "        ),\n\t    )\n\tdef schedule_approver_notification_event(\n\t    schedule_client: EventBridgeSchedulerClient,\n\t    message_ts: str,\n\t    channel_id: str,\n\t    time_to_wait: timedelta,\n\t) ->scheduler_type_defs.CreateScheduleOutputTypeDef | None:\n\t    # If the initial wait time is 0, we don't schedule the event\n\t    if cfg.approver_renotification_initial_wait_time == 0:\n", "        logger.info(\"Approver renotification is disabled, not scheduling approver notification event\")\n\t        return\n\t    logger.info(\"Scheduling approver notification event\")\n\t    schedule_name = \"approvers-renotification\" + datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\")\n\t    logger.debug(\n\t        \"Creating schedule\",\n\t        extra={\n\t            \"schedule_name\": schedule_name,\n\t            \"time_to_wait\": time_to_wait,\n\t            \"time_stamp\": message_ts,\n", "            \"channel_id\": channel_id,\n\t        },\n\t    )\n\t    return schedule_client.create_schedule(\n\t        FlexibleTimeWindow={\"Mode\": \"OFF\"},\n\t        Name=schedule_name,\n\t        GroupName=cfg.schedule_group_name,\n\t        ScheduleExpression=event_bridge_schedule_after(time_to_wait),\n\t        State=\"ENABLED\",\n\t        Target=scheduler_type_defs.TargetTypeDef(\n", "            Arn=cfg.revoker_function_arn,\n\t            RoleArn=cfg.schedule_policy_arn,\n\t            Input=json.dumps(\n\t                ApproverNotificationEvent(\n\t                    action=\"approvers_renotification\",\n\t                    schedule_name=schedule_name,\n\t                    time_stamp=message_ts,\n\t                    channel_id=channel_id,\n\t                    time_to_wait_in_seconds=time_to_wait.total_seconds()\n\t                ).dict()\n", "            ),\n\t        ),\n\t    )\n"]}
{"filename": "src/access_control.py", "chunked_list": ["import datetime\n\tfrom enum import Enum\n\tfrom typing import FrozenSet\n\timport boto3\n\timport config\n\timport entities\n\timport s3\n\timport schedule\n\timport sso\n\tfrom entities import BaseModel\n", "from statement import Statement, get_affected_statements\n\tlogger = config.get_logger(\"access_control\")\n\tcfg = config.get_config()\n\tsession = boto3._get_default_session()\n\torg_client = session.client(\"organizations\")\n\tsso_client = session.client(\"sso-admin\")\n\tidentitystore_client = session.client(\"identitystore\")\n\tschedule_client = session.client(\"scheduler\")\n\tclass DecisionReason(Enum):\n\t    RequiresApproval = \"RequiresApproval\"\n", "    ApprovalNotRequired = \"ApprovalNotRequired\"\n\t    SelfApproval = \"SelfApproval\"\n\t    NoStatements = \"NoStatements\"\n\t    NoApprovers = \"NoApprovers\"\n\tclass AccessRequestDecision(BaseModel):\n\t    grant: bool\n\t    reason: DecisionReason\n\t    based_on_statements: FrozenSet[Statement]\n\t    approvers: FrozenSet[str] = frozenset()\n\tdef make_decision_on_access_request(\n", "    statements: FrozenSet[Statement],\n\t    permission_set_name: str,\n\t    account_id: str,\n\t    requester_email: str,\n\t) -> AccessRequestDecision:\n\t    affected_statements = get_affected_statements(statements, account_id, permission_set_name)\n\t    decision_based_on_statements: set[Statement] = set()\n\t    potential_approvers = set()\n\t    for statement in affected_statements:\n\t        if statement.approval_is_not_required:\n", "            return AccessRequestDecision(\n\t                grant=True,\n\t                reason=DecisionReason.ApprovalNotRequired,\n\t                based_on_statements=frozenset([statement]),\n\t            )\n\t        if requester_email in statement.approvers and statement.allow_self_approval:\n\t            return AccessRequestDecision(\n\t                grant=True,\n\t                reason=DecisionReason.SelfApproval,\n\t                based_on_statements=frozenset([statement]),\n", "            )\n\t        decision_based_on_statements.add(statement)\n\t        potential_approvers.update(approver for approver in statement.approvers if approver != requester_email)\n\t    if len(decision_based_on_statements) == 0:  # sourcery skip\n\t        return AccessRequestDecision(\n\t            grant=False,\n\t            reason=DecisionReason.NoStatements,\n\t            based_on_statements=frozenset(decision_based_on_statements),\n\t        )\n\t    if not potential_approvers:\n", "        return AccessRequestDecision(\n\t            grant=False,\n\t            reason=DecisionReason.NoApprovers,\n\t            based_on_statements=frozenset(decision_based_on_statements),\n\t        )\n\t    return AccessRequestDecision(\n\t        grant=False,\n\t        reason=DecisionReason.RequiresApproval,\n\t        approvers=frozenset(potential_approvers),\n\t        based_on_statements=frozenset(decision_based_on_statements),\n", "    )\n\tclass ApproveRequestDecision(BaseModel):\n\t    \"\"\"Decision on approver request\n\t    grant: bool - Create account assignment, if grant is True\n\t    permit: bool - Allow approver to make an action Approve if permit is True\n\t    based_on_statements: FrozenSet[Statement]\n\t    \"\"\"\n\t    grant: bool\n\t    permit: bool\n\t    based_on_statements: FrozenSet[Statement]\n", "def make_decision_on_approve_request(  # noqa: PLR0913\n\t    action: entities.ApproverAction,\n\t    statements: frozenset[Statement],\n\t    permission_set_name: str,\n\t    account_id: str,\n\t    approver_email: str,\n\t    requester_email: str,\n\t) -> ApproveRequestDecision:\n\t    affected_statements = get_affected_statements(statements, account_id, permission_set_name)\n\t    for statement in affected_statements:\n", "        if approver_email in statement.approvers:\n\t            is_self_approval = approver_email == requester_email\n\t            if is_self_approval and statement.allow_self_approval or not is_self_approval:\n\t                return ApproveRequestDecision(\n\t                    grant=action == entities.ApproverAction.Approve,\n\t                    permit=True,\n\t                    based_on_statements=frozenset([statement]),\n\t                )\n\t    return ApproveRequestDecision(\n\t        grant=False,\n", "        permit=False,\n\t        based_on_statements=affected_statements,\n\t    )\n\tdef execute_decision(  # noqa: PLR0913\n\t    decision: AccessRequestDecision | ApproveRequestDecision,\n\t    permission_set_name: str,\n\t    account_id: str,\n\t    permission_duration: datetime.timedelta,\n\t    approver: entities.slack.User,\n\t    requester: entities.slack.User,\n", "    reason: str,\n\t) -> bool:\n\t    logger.info(\"Executing decision\")\n\t    if not decision.grant:\n\t        logger.info(\"Access request denied\")\n\t        return False  # Temporary solution for testing\n\t    sso_instance = sso.describe_sso_instance(sso_client, cfg.sso_instance_arn)\n\t    permission_set = sso.get_permission_set_by_name(sso_client, sso_instance.arn, permission_set_name)\n\t    user_principal_id = sso.get_user_principal_id_by_email(identitystore_client, sso_instance.identity_store_id, requester.email)\n\t    account_assignment = sso.UserAccountAssignment(\n", "        instance_arn=sso_instance.arn,\n\t        account_id=account_id,\n\t        permission_set_arn=permission_set.arn,\n\t        user_principal_id=user_principal_id,\n\t    )\n\t    logger.info(\"Creating account assignment\", extra={\"account_assignment\": account_assignment})\n\t    account_assignment_status = sso.create_account_assignment_and_wait_for_result(\n\t        sso_client,\n\t        account_assignment,\n\t    )\n", "    s3.log_operation(\n\t        audit_entry=s3.AuditEntry(\n\t            account_id=account_id,\n\t            role_name=permission_set.name,\n\t            reason=reason,\n\t            requester_slack_id=requester.id,\n\t            requester_email=requester.email,\n\t            approver_slack_id=approver.id,\n\t            approver_email=approver.email,\n\t            request_id=account_assignment_status.request_id,\n", "            operation_type=\"grant\",\n\t            permission_duration=permission_duration,\n\t        ),\n\t    )\n\t    schedule.schedule_revoke_event(\n\t        permission_duration=permission_duration,\n\t        schedule_client=schedule_client,\n\t        approver=approver,\n\t        requester=requester,\n\t        user_account_assignment=sso.UserAccountAssignment(\n", "            instance_arn=sso_instance.arn,\n\t            account_id=account_id,\n\t            permission_set_arn=permission_set.arn,\n\t            user_principal_id=user_principal_id,\n\t        ),\n\t    )\n\t    return True  # Temporary solution for testing\n"]}
{"filename": "src/tests/test_access_control.py", "chunked_list": ["import datetime\n\timport pytest\n\timport entities\n\tfrom access_control import (\n\t    AccessRequestDecision,\n\t    ApproveRequestDecision,\n\t    DecisionReason,\n\t    execute_decision,\n\t    make_decision_on_access_request,\n\t    make_decision_on_approve_request,\n", ")\n\tfrom statement import Statement\n\t# ruff: noqa: ANN201, ANN001\n\t@pytest.fixture\n\tdef execute_decision_info():\n\t    return {\n\t        \"permission_set_name\": \"1233321\",\n\t        \"account_id\": \"1233321\",\n\t        \"permission_duration\": datetime.timedelta(days=1),\n\t        \"approver\": entities.slack.User(email=\"email@email\", id=\"123\", real_name=\"123\"),\n", "        \"requester\": entities.slack.User(email=\"email@email\", id=\"123\", real_name=\"123\"),\n\t        \"reason\": \"\",\n\t    }\n\t@pytest.fixture(\n\t    params=[\n\t        {\n\t            \"description\": \"Grant access if approval is not required\",\n\t            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n", "                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"*\"],\n\t                                \"permission_set\": [\"*\"],\n\t                                \"approval_is_not_required\": True,\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n", "                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"anybody@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=True,\n\t                reason=DecisionReason.ApprovalNotRequired,\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n", "                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"*\"],\n\t                                \"permission_set\": [\"*\"],\n\t                                \"approval_is_not_required\": True,\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t            ),\n", "        },\n\t        {\n\t            \"description\": \"Request requires approval if requester is not an approver\",\n\t            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n", "                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"one@example.com\"],\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"second@example.com\",\n\t            },\n", "            \"out\": AccessRequestDecision(\n\t                grant=False,\n\t                reason=DecisionReason.RequiresApproval,\n\t                approvers=frozenset([\"one@example.com\"]),\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n", "                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"one@example.com\"],\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t            ),\n\t        },\n\t        {\n\t            \"description\": \"requester is not an approver and self approval is allowed - RequiresApproval\",\n", "            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"one@example.com\"],\n\t                                \"allow_self_approval\": True,\n", "                            }\n\t                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"second@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=False,\n", "                reason=DecisionReason.RequiresApproval,\n\t                approvers=frozenset([\"one@example.com\"]),\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"one@example.com\"],\n", "                                \"allow_self_approval\": True,\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t            ),\n\t        },\n\t        {\n\t            \"description\": \"requester is an approver, but self approval is not allowed, and there is other approver - RequiresApproval\",\n\t            \"in\": {\n", "                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\", \"approver2@example.com\"],\n\t                            }\n\t                        )\n", "                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"approver@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=False,\n\t                reason=DecisionReason.RequiresApproval,\n\t                based_on_statements=frozenset(\n", "                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\", \"approver2@example.com\"],\n\t                            }\n\t                        )\n\t                    ]\n", "                ),\n\t                approvers=frozenset({\"approver2@example.com\"}),\n\t            ),\n\t        },\n\t        {\n\t            \"description\": \"self approval is allowed and requester is approver -SelfApproval\",\n\t            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n", "                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"*\"],\n\t                                \"permission_set\": [\"*\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                                \"allow_self_approval\": True,\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n", "                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"approver@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=True,\n\t                reason=DecisionReason.SelfApproval,\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n", "                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"*\"],\n\t                                \"permission_set\": [\"*\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                                \"allow_self_approval\": True,\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n", "            ),\n\t        },\n\t        {\n\t            \"description\": \"no approvers - NoApprovers\",\n\t            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n", "                                \"resource\": [\"*\"],\n\t                                \"permission_set\": [\"*\"],\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"example@example.com\",\n\t            },\n", "            \"out\": AccessRequestDecision(\n\t                grant=False,\n\t                reason=DecisionReason.NoApprovers,\n\t                based_on_statements=frozenset(\n\t                    frozenset(\n\t                        [\n\t                            Statement.parse_obj(\n\t                                {\n\t                                    \"resource_type\": \"Account\",\n\t                                    \"resource\": [\"*\"],\n", "                                    \"permission_set\": [\"*\"],\n\t                                }\n\t                            )\n\t                        ]\n\t                    )\n\t                ),\n\t            ),\n\t        },\n\t        {\n\t            \"description\": \"requester is an approver, but self approval is not allowed - NoApprovers\",\n", "            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                            }\n", "                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"approver@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=False,\n\t                reason=DecisionReason.NoApprovers,\n", "                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                            }\n\t                        )\n", "                    ]\n\t                ),\n\t            ),\n\t        },\n\t        {\n\t            \"description\": \"no approvers but self approval is allowed - NoApprovers\",\n\t            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n", "                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"*\"],\n\t                                \"permission_set\": [\"*\"],\n\t                                \"allow_self_approval\": True,\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n", "                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"example@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=False,\n\t                reason=DecisionReason.NoApprovers,\n\t                based_on_statements=frozenset(\n\t                    frozenset(\n\t                        [\n\t                            Statement.parse_obj(\n", "                                {\n\t                                    \"resource_type\": \"Account\",\n\t                                    \"resource\": [\"*\"],\n\t                                    \"permission_set\": [\"*\"],\n\t                                    \"allow_self_approval\": True,\n\t                                }\n\t                            )\n\t                        ]\n\t                    )\n\t                ),\n", "            ),\n\t        },\n\t        {\n\t            \"description\": \"statement is not affected by the access request - NoStatements\",\n\t            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n", "                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"ReadOnlyAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                            }\n\t                        ),\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"requester@example.com\",\n", "            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=False,\n\t                reason=DecisionReason.NoStatements,\n\t                based_on_statements=frozenset([]),\n\t            ),\n\t        },\n\t        {\n\t            \"description\": \"multiple statements affecting the access request, some require approval and some don't\",\n\t            \"in\": {\n", "                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                            }\n\t                        ),\n", "                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approval_is_not_required\": True,\n\t                            }\n\t                        ),\n\t                    ]\n\t                ),\n", "                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"approver@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=True,\n\t                reason=DecisionReason.ApprovalNotRequired,\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n", "                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approval_is_not_required\": True,\n\t                            }\n\t                        ),\n\t                    ]\n\t                ),\n\t            ),\n", "        },\n\t        {\n\t            \"description\": \"multiple statements affecting the access request, with different sets of approvers.\",\n\t            \"in\": {\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n", "                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver1@example.com\"],\n\t                            }\n\t                        ),\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver2@example.com\"],\n", "                            }\n\t                        ),\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"requester@example.com\",\n\t            },\n\t            \"out\": AccessRequestDecision(\n\t                grant=False,\n", "                reason=DecisionReason.RequiresApproval,\n\t                approvers=frozenset([\"approver1@example.com\", \"approver2@example.com\"]),\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver1@example.com\"],\n", "                            }\n\t                        ),\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver2@example.com\"],\n\t                            }\n\t                        ),\n", "                    ]\n\t                ),\n\t            ),\n\t        },\n\t    ],\n\t    ids=lambda t: t[\"description\"],\n\t)\n\tdef test_cases_for_access_request_decision(request):\n\t    return request.param\n\t@pytest.fixture(\n", "    params=[\n\t        {\n\t            \"description\": \"approver is approver\",\n\t            \"in\": {\n\t                \"action\": entities.ApproverAction.Approve,\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n", "                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"requester@example.com\",\n", "                \"approver_email\": \"approver@example.com\",\n\t            },\n\t            \"out\": ApproveRequestDecision(\n\t                grant=True,\n\t                permit=True,\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n", "                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t            ),\n\t        },\n\t        {\n", "            \"description\": \"approver is approver but self approval is not allowed\",\n\t            \"in\": {\n\t                \"action\": entities.ApproverAction.Approve,\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n", "                                \"approvers\": [\"approver@example.com\"],\n\t                                \"allow_self_approval\": False,\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"111111111111\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"approver@example.com\",\n\t                \"approver_email\": \"approver@example.com\",\n", "            },\n\t            \"out\": ApproveRequestDecision(\n\t                grant=False,\n\t                permit=False,\n\t                based_on_statements=frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n", "                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n\t                            }\n\t                        )\n\t                    ]\n\t                ),\n\t            ),\n\t        },\n\t        {\n\t            \"description\": \"approver is not an approver\",\n", "            \"in\": {\n\t                \"action\": entities.ApproverAction.Approve,\n\t                \"statements\": frozenset(\n\t                    [\n\t                        Statement.parse_obj(\n\t                            {\n\t                                \"resource_type\": \"Account\",\n\t                                \"resource\": [\"111111111111\"],\n\t                                \"permission_set\": [\"AdministratorAccess\"],\n\t                                \"approvers\": [\"approver@example.com\"],\n", "                            }\n\t                        )\n\t                    ]\n\t                ),\n\t                \"account_id\": \"222222222222\",\n\t                \"permission_set_name\": \"AdministratorAccess\",\n\t                \"requester_email\": \"requester@example.com\",\n\t                \"approver_email\": \"notapprover@example.com\",\n\t            },\n\t            \"out\": ApproveRequestDecision(\n", "                grant=False,\n\t                permit=False,\n\t                based_on_statements=frozenset(),\n\t            ),\n\t        },\n\t    ],\n\t    ids=lambda t: t[\"description\"],\n\t)\n\tdef test_cases_for_approve_request_decision(request):\n\t    return request.param\n", "def test_make_decision_on_access_request(test_cases_for_access_request_decision):\n\t    assert make_decision_on_access_request(**test_cases_for_access_request_decision[\"in\"]) == test_cases_for_access_request_decision[\"out\"]\n\tdef test_make_decision_on_approve_request(test_cases_for_approve_request_decision):\n\t    assert (\n\t        make_decision_on_approve_request(**test_cases_for_approve_request_decision[\"in\"]) == test_cases_for_approve_request_decision[\"out\"]\n\t    )\n\tdef test_execute_access_request_decision(\n\t    test_cases_for_access_request_decision,\n\t    execute_decision_info,\n\t):\n", "    if test_cases_for_access_request_decision[\"out\"].grant is not True:\n\t        assert execute_decision(decision=test_cases_for_access_request_decision[\"out\"], **execute_decision_info) is False\n\tdef test_execute_approve_request_decision(\n\t    test_cases_for_approve_request_decision,\n\t    execute_decision_info,\n\t):\n\t    if test_cases_for_approve_request_decision[\"out\"].grant is not True:\n\t        assert execute_decision(decision=test_cases_for_approve_request_decision[\"out\"], **execute_decision_info) is False\n\tdef test_make_and_excute_access_request_decision(\n\t    test_cases_for_access_request_decision,\n", "    execute_decision_info,\n\t):\n\t    decision = make_decision_on_access_request(**test_cases_for_access_request_decision[\"in\"])\n\t    if decision.grant is not True:\n\t        assert execute_decision(decision=decision, **execute_decision_info) is False\n\tdef test_make_and_excute_approve_request_decision(\n\t    test_cases_for_approve_request_decision,\n\t    execute_decision_info,\n\t):\n\t    decision = make_decision_on_approve_request(**test_cases_for_approve_request_decision[\"in\"])\n", "    if decision.grant is not True:\n\t        assert execute_decision(decision=decision, **execute_decision_info) is False\n"]}
{"filename": "src/tests/__init__.py", "chunked_list": []}
{"filename": "src/tests/test_config.py", "chunked_list": ["import json\n\timport os\n\tfrom hypothesis import example, given, settings\n\tfrom hypothesis import strategies as st\n\tfrom hypothesis.strategies import SearchStrategy\n\tfrom pydantic import ValidationError\n\timport config\n\tfrom . import strategies\n\t# ruff: noqa\n\tVALID_STATEMENT_DICT = {\n", "    \"ResourceType\": \"Account\",\n\t    \"Resource\": [\"111111111111\"],\n\t    \"PermissionSet\": \"AdministratorAccess\",\n\t    \"Approvers\": \"example@gmail.com\",\n\t}\n\t@given(strategies.statement_dict())\n\t@settings(max_examples=100)\n\t@example({}).xfail(raises=KeyError, reason=\"Empty dict is not a valid statement\")\n\t@example(VALID_STATEMENT_DICT)\n\tdef test_parse_statement(dict_statement: dict):\n", "    try:\n\t        config.parse_statement(dict_statement)\n\t    except ValidationError:\n\t        assert False\n\tdef config_dict(statements: SearchStrategy = strategies.jsonstr(st.lists(strategies.statement_dict()))):\n\t    return st.fixed_dictionaries(\n\t        {\n\t            \"schedule_policy_arn\": strategies.json_safe_text,\n\t            \"revoker_function_arn\": strategies.json_safe_text,\n\t            \"revoker_function_name\": strategies.json_safe_text,\n", "            \"schedule_group_name\": strategies.json_safe_text,\n\t            \"slack_channel_id\": strategies.json_safe_text,\n\t            \"slack_bot_token\": strategies.json_safe_text,\n\t            \"sso_instance_arn\": strategies.json_safe_text,\n\t            \"s3_bucket_for_audit_entry_name\": strategies.json_safe_text,\n\t            \"s3_bucket_prefix_for_partitions\": strategies.json_safe_text,\n\t            \"sso_elevator_scheduled_revocation_rule_name\": strategies.json_safe_text,\n\t            \"log_level\": st.one_of(st.just(\"INFO\"), st.just(\"DEBUG\"), st.just(\"WARNING\"), st.just(\"ERROR\"), st.just(\"CRITICAL\")),\n\t            \"post_update_to_slack\": strategies.str_bool,\n\t            \"statements\": statements,\n", "            \"request_expiration_hours\": st.integers(min_value=0, max_value=24),\n\t            \"approver_renotification_initial_wait_time\": st.integers(min_value=0, max_value=60),\n\t            \"approver_renotification_backoff_multiplier\": st.integers(min_value=0, max_value=10),\n\t            \"max_permissions_duration_time\": st.integers(min_value=0, max_value=24),\n\t        }\n\t    )\n\tdef valid_config_dict(statements_as_json: bool = True):\n\t    if statements_as_json:\n\t        statements = json.dumps([VALID_STATEMENT_DICT])\n\t    else:\n", "        statements = [VALID_STATEMENT_DICT]\n\t    return {\n\t        \"schedule_policy_arn\": \"x\",\n\t        \"revoker_function_arn\": \"x\",\n\t        \"revoker_function_name\": \"x\",\n\t        \"schedule_group_name\": \"x\",\n\t        \"slack_channel_id\": \"x\",\n\t        \"slack_bot_token\": \"x\",\n\t        \"sso_instance_arn\": \"x\",\n\t        \"log_level\": \"INFO\",\n", "        \"post_update_to_slack\": \"False\",\n\t        \"statements\": statements,\n\t        \"s3_bucket_for_audit_entry_name\": \"x\",\n\t        \"s3_bucket_prefix_for_partitions\": \"x\",\n\t        \"sso_elevator_scheduled_revocation_rule_name\": \"x\",\n\t        \"request_expiration_hours\": \"8\",\n\t        \"approver_renotification_initial_wait_time\": \"15\",\n\t        \"approver_renotification_backoff_multiplier\": \"2\",\n\t        \"max_permissions_duration_time\": \"24\",\n\t    }\n", "@given(config_dict())\n\t@example(valid_config_dict())\n\t@example({}).xfail(raises=ValidationError, reason=\"Empty dict is not a valid config\")\n\t@example(valid_config_dict() | {\"post_update_to_slack\": \"x\"}).xfail(raises=ValidationError, reason=\"Invalid bool\")\n\t@settings(max_examples=50)\n\tdef test_config_load_environment_variables(dict_config: dict):\n\t    os.environ = dict_config\n\t    config.Config()  # type: ignore\n\t@given(config_dict(statements=st.lists(strategies.statement_dict(), max_size=20)))\n\t@settings(max_examples=50)\n", "@example(valid_config_dict(statements_as_json=False))\n\t@example(valid_config_dict(statements_as_json=False) | {\"post_update_to_slack\": \"x\"}).xfail(raises=ValidationError, reason=\"Invalid bool\")\n\tdef test_config_init(dict_config: dict):\n\t    config.Config(**dict_config)\n"]}
{"filename": "src/tests/utils.py", "chunked_list": ["import base64\n\timport json\n\timport os\n\timport uuid\n\tfrom urllib.parse import parse_qsl, urlencode\n\tfrom aws_lambda_powertools.utilities.typing import LambdaContext\n\t# ruff: noqa: ANN201, ANN001, ANN204, ANN101\n\tdef decode_body(raw_body: str) -> dict:\n\t    \"\"\"Decode the body of a Slack request\"\"\"\n\t    body = base64.b64decode(raw_body).decode(\"utf-8\")\n", "    body_dict = dict(parse_qsl(body))\n\t    json_payload = body_dict[\"payload\"]\n\t    return json.loads(json_payload)\n\tdef encode_body(payload: dict) -> str:\n\t    \"\"\"Encode the body of a Slack request\"\"\"\n\t    json_payload = json.dumps(payload, separators=(\",\", \":\"))\n\t    body_dict = {\"payload\": json_payload}\n\t    qls = urlencode(body_dict)\n\t    return base64.b64encode(qls.encode(\"utf-8\")).decode(\"utf-8\")\n\tdef get_lambda_env_vars(lambda_client, function_name: str, qualifier: str = \"$LATEST\") -> dict:\n", "    print(f\"Getting environment variables from lambda {function_name}:{qualifier}...\")\n\t    return lambda_client.get_function_configuration(FunctionName=function_name, Qualifier=qualifier)[\"Environment\"][\"Variables\"]\n\tdef update_local_env_vars_from_lambda(lambda_client, function_name: str, qualifier: str = \"$LATEST\"):\n\t    lambda_env_vars = get_lambda_env_vars(lambda_client, function_name, qualifier)\n\t    os.environ |= lambda_env_vars\n\t    print(f\"Local environment variables updated from lambda {function_name}:{qualifier}!\")\n\tclass LambdaTestContext(LambdaContext):\n\t    def __init__(self, name: str, version: int = 1, region: str = \"us-east-1\", account_id: str = \"111122223333\"):\n\t        self._function_name = name\n\t        self._function_version = str(version)\n", "        self._memory_limit_in_mb = 128\n\t        self._invoked_function_arn = f\"arn:aws:lambda:{region}:{account_id}:function:{name}:{version}\"\n\t        self._aws_request_id = str(uuid.uuid4())\n\t        self._log_group_name = f\"/aws/lambda/{name}\"\n\t        self._log_stream_name = str(uuid.uuid4())\n"]}
{"filename": "src/tests/strategies.py", "chunked_list": ["import json\n\timport string\n\tfrom typing import Literal\n\tfrom hypothesis import strategies as st\n\tfrom hypothesis.strategies import SearchStrategy\n\t# ruff: noqa: ANN201\n\tdef jsonstr(strategy: SearchStrategy) -> SearchStrategy:\n\t    return st.builds(\n\t        json.dumps,\n\t        strategy,\n", "    )\n\t# https://docs.aws.amazon.com/organizations/latest/APIReference/API_CreateAccountStatus.html\n\taws_account_id = st.text(min_size=12, max_size=12, alphabet=string.digits)\n\t# https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_CreatePermissionSet.html#singlesignon-CreatePermissionSet-request-Name\n\taws_permission_set_name = st.text(min_size=1, max_size=32, alphabet=string.ascii_letters + string.digits + \"_+=,.@-\")\n\t# https://docs.aws.amazon.com/organizations/latest/APIReference/API_CreateOrganizationalUnit.html#organizations-CreateOrganizationalUnit-request-Name\n\taws_organization_unit_name = st.text(min_size=1, max_size=128, alphabet=string.ascii_letters)\n\tstatement_approvers = st.frozensets(st.emails(), min_size=1, max_size=10)\n\tstr_bool = st.one_of(st.just(str(True)), st.just(str(False)))\n\tjson_safe_text = st.text(\n", "    alphabet=st.characters(\n\t        blacklist_categories=(\"Cs\", \"Cc\", \"Cf\", \"Co\", \"Cn\"),\n\t        blacklist_characters=(\"/\"),\n\t    ),\n\t    min_size=1,\n\t    max_size=200,\n\t)\n\tdef resource_type_st(resource_type: Literal[\"Account\", \"OU\", \"Any\"] = \"Any\"):\n\t    if resource_type == \"Account\":\n\t        return st.just(\"Account\")\n", "    elif resource_type == \"OU\":\n\t        return st.just(\"OU\")\n\t    elif resource_type == \"Any\":\n\t        return st.sampled_from([\"Account\", \"OU\"])\n\t    raise ValueError(f\"Unknown resource type: {resource_type}\")\n\t@st.composite\n\tdef resource(draw: st.DrawFn, resource_type: SearchStrategy[str]):\n\t    r_type = draw(resource_type)\n\t    if r_type == \"Account\":\n\t        return draw(aws_account_id)\n", "    elif r_type == \"OU\":\n\t        return draw(aws_organization_unit_name)\n\t    raise ValueError(f\"Unknown resource type: {r_type}\")\n\tdef statement_dict(\n\t    resource_type: Literal[\"Account\", \"OU\", \"Any\"] = \"Account\",\n\t):\n\t    resource_type_strategy = st.shared(resource_type_st(resource_type))\n\t    resource_strategy = resource(resource_type_strategy)\n\t    return st.fixed_dictionaries(\n\t        mapping={\n", "            \"ResourceType\": resource_type_strategy,\n\t            \"Resource\": st.one_of(resource_strategy, st.lists(resource_strategy, max_size=20), st.just(\"*\")),\n\t            \"PermissionSet\": st.one_of(\n\t                aws_permission_set_name,\n\t                st.lists(aws_permission_set_name, max_size=20),\n\t                st.just(\"*\"),\n\t            ),\n\t        },\n\t        optional={\n\t            \"Approvers\": st.one_of(st.emails(), st.lists(st.emails(), max_size=20)),\n", "            \"ApprovalIsNotRequired\": st.booleans(),\n\t            \"AllowSelfApproval\": st.booleans(),\n\t        },\n\t    )\n"]}
{"filename": "src/tests/conftest.py", "chunked_list": ["import os\n\timport boto3\n\tdef pytest_sessionstart(session):  # noqa: ANN201, ARG001, ANN001\n\t    mock_env = {\n\t        \"schedule_policy_arn\": \"x\",\n\t        \"revoker_function_arn\": \"x\",\n\t        \"revoker_function_name\": \"x\",\n\t        \"schedule_group_name\": \"x\",\n\t        \"post_update_to_slack\": \"true\",\n\t        \"slack_channel_id\": \"x\",\n", "        \"slack_bot_token\": \"x\",\n\t        \"sso_instance_arn\": \"x\",\n\t        \"log_level\": \"DEBUG\",\n\t        \"slack_app_log_level\": \"INFO\",\n\t        \"s3_bucket_for_audit_entry_name\": \"x\",\n\t        \"s3_bucket_prefix_for_partitions\": \"x\",\n\t        \"sso_elevator_scheduled_revocation_rule_name\": \"x\",\n\t        \"request_expiration_hours\": \"8\",\n\t        \"approver_renotification_initial_wait_time\": \"15\",\n\t        \"approver_renotification_backoff_multiplier\": \"2\",\n", "        \"max_permissions_duration_time\": \"24\"\n\t    }\n\t    os.environ |= mock_env\n\t    boto3.setup_default_session(region_name=\"us-east-1\")\n"]}
{"filename": "src/entities/aws.py", "chunked_list": ["from typing import Optional\n\tfrom .model import BaseModel\n\tclass Account(BaseModel):\n\t    id: str\n\t    name: str\n\tclass PermissionSet(BaseModel):\n\t    name: str\n\t    arn: str\n\t    description: Optional[str]\n"]}
{"filename": "src/entities/model.py", "chunked_list": ["import dataclasses\n\timport enum\n\tfrom typing import FrozenSet\n\tfrom pydantic import BaseModel as PydanticBaseModel\n\tclass BaseModel(PydanticBaseModel):\n\t    class Config:\n\t        frozen = True\n\t    def dict(self, *args, **kwargs) -> dict:  # noqa: ANN101, ANN003, ANN002\n\t        \"\"\"Converts instance to dict representation of it. Workaround for https://github.com/pydantic/pydantic/issues/1090\"\"\"\n\t        cp = super().copy()\n", "        cp.Config.frozen = False\n\t        for field_name in cp.__fields__.keys():\n\t            attr = cp.__getattribute__(field_name)\n\t            if isinstance(attr, FrozenSet):\n\t                cp.__setattr__(field_name, list(attr))\n\t        cp.Config.frozen = True\n\t        # frozendict.frozendict(?)\n\t        return PydanticBaseModel.dict(cp, *args, **kwargs)\n\tdef json_default(o: object) -> str | dict:\n\t    if isinstance(o, PydanticBaseModel):\n", "        return o.dict()\n\t    elif dataclasses.is_dataclass(o):\n\t        return dataclasses.asdict(o)\n\t    elif isinstance(o, enum.Enum):\n\t        return o.value\n\t    return str(o)\n"]}
{"filename": "src/entities/slack.py", "chunked_list": ["from enum import Enum\n\tfrom .model import BaseModel\n\tclass ApproverAction(Enum):\n\t    Approve = \"approve\"\n\t    Discard = \"discard\"\n\tclass User(BaseModel):\n\t    id: str\n\t    email: str\n\t    real_name: str\n"]}
{"filename": "src/entities/__init__.py", "chunked_list": ["# ruff: noqa: F401\n\tfrom . import aws, slack\n\tfrom .model import BaseModel, json_default\n\tfrom .slack import ApproverAction\n"]}
