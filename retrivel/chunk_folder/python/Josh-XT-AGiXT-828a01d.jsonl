{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\timport os\n\t# Read the contents of your README file\n\tthis_directory = os.path.dirname(os.path.realpath(__file__))\n\treadme_path = os.path.join(this_directory, \"docs\", \"README.md\")\n\t# Read the contents of the README file\n\twith open(readme_path, encoding=\"utf-8\") as f:\n\t    long_description = f.read()\n\t# Get requirements from requirements.txt to a list\n\twith open(os.path.join(this_directory, \"requirements.txt\"), encoding=\"utf-8\") as f:\n", "    install_requires = f.read().splitlines()\n\trequirements = []\n\tfor reqs in install_requires:\n\t    if \"--\" not in reqs and \":\" not in reqs and \"#\" not in reqs:\n\t        requirements.append(reqs)\n\t# Get version from version file in agixt/version\n\twith open(os.path.join(this_directory, \"agixt/version\"), encoding=\"utf-8\") as f:\n\t    version = f.read().strip()\n\tsetup(\n\t    name=\"agixt\",\n", "    version=version,\n\t    description=\"An Artificial Intelligence Automation Platform. AI Instruction management from various providers, has an adaptive memory, and a versatile plugin system with many commands including web browsing. Supports many AI providers and models and growing support every day.\",\n\t    long_description=long_description,\n\t    long_description_content_type=\"text/markdown\",  # This should match the format of your README\n\t    author=\"Josh XT\",\n\t    author_email=\"josh@devxt.com\",\n\t    packages=find_packages(),\n\t    python_requires=\">=3.10\",\n\t    install_requires=requirements,\n\t)\n"]}
{"filename": "agixt/Hub.py", "chunked_list": ["import io\n\timport os\n\timport time\n\timport stat\n\timport shutil\n\timport requests\n\timport zipfile\n\timport hashlib\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n", "db_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\n\tif db_connected:\n\t    from db.imports import (\n\t        import_extensions,\n\t        import_prompts,\n\t        import_providers,\n\t        import_agents,\n\t        import_chains,\n\t        import_conversations,\n\t    )\n", "else:\n\t    import_extensions = lambda: None\n\t    import_prompts = lambda: None\n\t    import_providers = lambda: None\n\t    import_agents = lambda: None\n\t    import_chains = lambda: None\n\t    import_conversations = lambda: None\n\tdef import_agixt_hub():\n\t    github_user = os.getenv(\"GITHUB_USER\")\n\t    github_token = os.getenv(\"GITHUB_TOKEN\")\n", "    github_repo = os.getenv(\"AGIXT_HUB\", \"AGiXT/light-hub\")\n\t    repo_name = github_repo.split(\"/\")[1]\n\t    repo_url = f\"https://github.com/{github_repo}/archive/refs/heads/main.zip\"\n\t    zip_file_name = f\"{repo_name}_main.zip\"\n\t    try:\n\t        response = requests.get(repo_url, auth=(github_user, github_token))\n\t        response.raise_for_status()\n\t        new_zip_hash = hashlib.sha256(response.content).hexdigest()\n\t        if os.path.exists(zip_file_name):\n\t            with open(zip_file_name, \"rb\") as f:\n", "                old_zip_hash = hashlib.sha256(f.read()).hexdigest()\n\t            if old_zip_hash == new_zip_hash:\n\t                print(\n\t                    f\"No changes detected in the AGiXT Hub at {github_repo}, moving on...\"\n\t                )\n\t                return\n\t        with open(zip_file_name, \"wb\") as f:\n\t            f.write(response.content)\n\t        zip_ref = zipfile.ZipFile(io.BytesIO(response.content))\n\t        zip_ref.extractall(\".\")\n", "        zip_ref.close()\n\t        for root, dirs, files in os.walk(f\"{repo_name}-main\"):\n\t            for dir_name in dirs:\n\t                dir_path = os.path.join(root, dir_name)\n\t                os.chmod(dir_path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n\t            for file_name in files:\n\t                file_path = os.path.join(root, file_name)\n\t                os.chmod(\n\t                    file_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH\n\t                )\n", "        print(f\"Updating AGiXT Hub from {github_repo}\")\n\t        for file in os.listdir(f\"{repo_name}-main\"):\n\t            src_file = os.path.join(f\"{repo_name}-main\", file)\n\t            dest_file = os.path.join(\".\", file)\n\t            if os.path.isdir(src_file):\n\t                if not os.path.exists(dest_file):\n\t                    os.makedirs(dest_file, exist_ok=True)\n\t                for item in os.listdir(src_file):\n\t                    src_item = os.path.join(src_file, item)\n\t                    dest_item = os.path.join(dest_file, item)\n", "                    if os.path.isdir(src_item):\n\t                        if not os.path.exists(dest_item):\n\t                            os.makedirs(dest_item, exist_ok=True)\n\t                        for dirpath, dirnames, filenames in os.walk(src_item):\n\t                            destination = dirpath.replace(src_item, dest_item, 1)\n\t                            if not os.path.exists(destination):\n\t                                os.makedirs(destination)\n\t                            for filename in filenames:\n\t                                if filename != \"config.json\" or not os.path.exists(\n\t                                    os.path.join(destination, filename)\n", "                                ):\n\t                                    shutil.copy2(\n\t                                        os.path.join(dirpath, filename), destination\n\t                                    )\n\t                    else:\n\t                        if not (\n\t                            dest_item.endswith(\"config.json\")\n\t                            and os.path.exists(dest_item)\n\t                        ):\n\t                            shutil.copy2(src_item, dest_item)\n", "            else:\n\t                if not (\n\t                    dest_file.endswith(\"config.json\") and os.path.exists(dest_file)\n\t                ):\n\t                    shutil.move(src_file, dest_file)\n\t        shutil.rmtree(f\"{repo_name}-main\")\n\t        print(f\"Updated AGiXT Hub from {github_repo}\")\n\t    except Exception as e:\n\t        print(f\"AGiXT Hub Import Error: {e}\")\n\t    if db_connected:\n", "        print(f\"DB Connected: {db_connected}\")\n\t        time.sleep(5)\n\t        import_extensions()\n\t        import_prompts()\n\t        import_providers()\n\t        import_agents()\n\t        import_chains()\n\t        import_conversations()\n\tif __name__ == \"__main__\":\n\t    import_agixt_hub()\n"]}
{"filename": "agixt/Websearch.py", "chunked_list": ["import os\n\timport re\n\timport json\n\timport random\n\timport requests\n\timport logging\n\timport asyncio\n\tfrom urllib.parse import urlparse\n\tfrom playwright.async_api import async_playwright\n\tfrom Embedding import get_tokens\n", "from Memories import Memories\n\tfrom bs4 import BeautifulSoup\n\tfrom agixtsdk import AGiXTSDK\n\tfrom typing import List\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tAGIXT_API_KEY = os.getenv(\"AGIXT_API_KEY\")\n\tdb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\n\tif db_connected:\n\t    from db.Agent import Agent\n", "else:\n\t    from fb.Agent import Agent\n\tApiClient = AGiXTSDK(\n\t    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n\t)\n\tclass Websearch:\n\t    def __init__(\n\t        self,\n\t        agent: Agent,\n\t        memories: Memories,\n", "        **kwargs,\n\t    ):\n\t        self.agent = agent\n\t        self.memories = memories\n\t        self.agent_name = self.agent.agent_name\n\t        try:\n\t            self.max_tokens = self.agent.PROVIDER_SETTINGS[\"MAX_TOKENS\"]\n\t        except:\n\t            self.max_tokens = 2048\n\t        self.searx_instance_url = (\n", "            self.agent.PROVIDER_SETTINGS[\"SEARXNG_INSTANCE_URL\"]\n\t            if \"SEARXNG_INSTANCE_URL\" in self.agent.PROVIDER_SETTINGS\n\t            else \"\"\n\t        )\n\t        self.requirements = [\"agixtsdk\"]\n\t        self.failures = []\n\t        self.browsed_links = []\n\t        self.tasks = []\n\t    async def get_web_content(self, url):\n\t        try:\n", "            async with async_playwright() as p:\n\t                browser = await p.chromium.launch()\n\t                context = await browser.new_context()\n\t                page = await context.new_page()\n\t                await page.goto(url)\n\t                content = await page.content()\n\t                # Scrape links and their titles\n\t                links = await page.query_selector_all(\"a\")\n\t                link_list = []\n\t                for link in links:\n", "                    title = await page.evaluate(\"(link) => link.textContent\", link)\n\t                    title = title.replace(\"\\n\", \"\")\n\t                    title = title.replace(\"\\t\", \"\")\n\t                    title = title.replace(\"  \", \"\")\n\t                    href = await page.evaluate(\"(link) => link.href\", link)\n\t                    link_list.append((title, href))\n\t                await browser.close()\n\t                soup = BeautifulSoup(content, \"html.parser\")\n\t                text_content = soup.get_text()\n\t                text_content = \" \".join(text_content.split())\n", "                return text_content, link_list\n\t        except:\n\t            return None, None\n\t    async def resursive_browsing(self, user_input, links):\n\t        chunk_size = int(int(self.max_tokens) / 3)\n\t        try:\n\t            words = links.split()\n\t            links = [\n\t                word for word in words if urlparse(word).scheme in [\"http\", \"https\"]\n\t            ]\n", "        except:\n\t            links = links\n\t        if links is not None:\n\t            for link in links:\n\t                if \"href\" in link:\n\t                    try:\n\t                        url = link[\"href\"]\n\t                    except:\n\t                        url = link\n\t                else:\n", "                    url = link\n\t                url = re.sub(r\"^.*?(http)\", r\"http\", url)\n\t                if url in self.browsed_links:\n\t                    continue\n\t                # Check if url is an actual url\n\t                if url.startswith(\"http\"):\n\t                    logging.info(f\"Scraping: {url}\")\n\t                    if url not in self.browsed_links:\n\t                        self.browsed_links.append(url)\n\t                        (\n", "                            collected_data,\n\t                            link_list,\n\t                        ) = await self.get_web_content(url=url)\n\t                        # Split the collected data into agent max tokens / 3 character chunks\n\t                        if collected_data is not None:\n\t                            if len(collected_data) > 0:\n\t                                tokens = get_tokens(collected_data)\n\t                                chunks = [\n\t                                    collected_data[i : i + chunk_size]\n\t                                    for i in range(\n", "                                        0,\n\t                                        int(tokens),\n\t                                        chunk_size,\n\t                                    )\n\t                                ]\n\t                                for chunk in chunks:\n\t                                    summarized_content = ApiClient.prompt_agent(\n\t                                        agent_name=self.agent_name,\n\t                                        prompt_name=\"Summarize Web Content\",\n\t                                        prompt_args={\n", "                                            \"link\": url,\n\t                                            \"chunk\": chunk,\n\t                                            \"user_input\": user_input,\n\t                                            \"browse_links\": False,\n\t                                            \"disable_memory\": True,\n\t                                        },\n\t                                    )\n\t                                    if not summarized_content.startswith(\"None\"):\n\t                                        await self.memories.store_result(\n\t                                            input=url,\n", "                                            result=summarized_content,\n\t                                            external_source_name=url,\n\t                                        )\n\t        if links is not None:\n\t            for link in links:\n\t                if \"href\" in link:\n\t                    try:\n\t                        url = link[\"href\"]\n\t                    except:\n\t                        url = link\n", "                else:\n\t                    url = link\n\t                url = re.sub(r\"^.*?(http)\", r\"http\", url)\n\t                if url in self.browsed_links:\n\t                    continue\n\t                # Check if url is an actual url\n\t                if url.startswith(\"http\"):\n\t                    logging.info(f\"Scraping: {url}\")\n\t                    if url not in self.browsed_links:\n\t                        self.browsed_links.append(url)\n", "                        (\n\t                            collected_data,\n\t                            link_list,\n\t                        ) = await self.get_web_content(url=url)\n\t                        if link_list is not None:\n\t                            if len(link_list) > 0:\n\t                                if len(link_list) > 5:\n\t                                    link_list = link_list[:3]\n\t                                try:\n\t                                    pick_a_link = ApiClient.prompt_agent(\n", "                                        agent_name=self.agent_name,\n\t                                        prompt_name=\"Pick-a-Link\",\n\t                                        prompt_args={\n\t                                            \"url\": url,\n\t                                            \"links\": link_list,\n\t                                            \"visited_links\": self.browsed_links,\n\t                                            \"disable_memory\": True,\n\t                                            \"browse_links\": False,\n\t                                            \"user_input\": user_input,\n\t                                            \"context_results\": 0,\n", "                                        },\n\t                                    )\n\t                                    if not pick_a_link.startswith(\"None\"):\n\t                                        logging.info(\n\t                                            f\"AI has decided to click: {pick_a_link}\"\n\t                                        )\n\t                                        await self.resursive_browsing(\n\t                                            user_input=user_input, links=pick_a_link\n\t                                        )\n\t                                except:\n", "                                    logging.info(f\"Issues reading {url}. Moving on...\")\n\t    async def search(self, query: str) -> List[str]:\n\t        if self.searx_instance_url == \"\":\n\t            try:  # SearXNG - List of these at https://searx.space/\n\t                response = requests.get(\"https://searx.space/data/instances.json\")\n\t                data = json.loads(response.text)\n\t                if self.failures != []:\n\t                    for failure in self.failures:\n\t                        if failure in data[\"instances\"]:\n\t                            del data[\"instances\"][failure]\n", "                servers = list(data[\"instances\"].keys())\n\t                random_index = random.randint(0, len(servers) - 1)\n\t                self.searx_instance_url = servers[random_index]\n\t            except:  # Select default remote server that typically works if unable to get list.\n\t                self.searx_instance_url = \"https://search.us.projectsegfau.lt\"\n\t        server = self.searx_instance_url.rstrip(\"/\")\n\t        endpoint = f\"{server}/search\"\n\t        try:\n\t            logging.info(f\"Trying to connect to SearXNG Search at {endpoint}...\")\n\t            response = requests.get(\n", "                endpoint,\n\t                params={\n\t                    \"q\": query,\n\t                    \"language\": \"en\",\n\t                    \"safesearch\": 1,\n\t                    \"format\": \"json\",\n\t                },\n\t            )\n\t            results = response.json()\n\t            summaries = [\n", "                result[\"title\"] + \" - \" + result[\"url\"] for result in results[\"results\"]\n\t            ]\n\t            if len(summaries) < 1:\n\t                self.failures.append(self.searx_instance_url)\n\t                self.searx_instance_url = \"\"\n\t                return await self.search(query=query)\n\t            return summaries\n\t        except:\n\t            self.failures.append(self.searx_instance_url)\n\t            self.searx_instance_url = \"\"\n", "            # The SearXNG server is down or refusing connection, so we will use the default one.\n\t            return await self.search(query=query)\n\t    async def websearch_agent(\n\t        self,\n\t        user_input: str = \"What are the latest breakthroughs in AI?\",\n\t        depth: int = 3,\n\t        timeout: int = 0,\n\t    ):\n\t        results = ApiClient.prompt_agent(\n\t            agent_name=self.agent_name,\n", "            prompt_name=\"WebSearch\",\n\t            prompt_args={\n\t                \"user_input\": user_input,\n\t                \"disable_memory\": True,\n\t            },\n\t        )\n\t        results = results.split(\"\\n\")\n\t        if len(results) > 0:\n\t            for result in results:\n\t                links = []\n", "                search_string = result.lstrip(\"0123456789. \")\n\t                logging.info(f\"Searching for: {search_string}\")\n\t                links = await self.search(query=search_string)\n\t                logging.info(f\"Found {len(links)} results for {search_string}\")\n\t                if len(links) > depth:\n\t                    links = links[:depth]\n\t                if links is not None and len(links) > 0:\n\t                    task = asyncio.create_task(\n\t                        self.resursive_browsing(user_input=user_input, links=links)\n\t                    )\n", "                    self.tasks.append(task)\n\t            if int(timeout) == 0:\n\t                await asyncio.gather(*self.tasks)\n\t            else:\n\t                logging.info(f\"Web searching for {timeout} seconds... Please wait...\")\n\t                await asyncio.sleep(int(timeout))\n\t                logging.info(\"Websearch tasks completed.\")\n\t        else:\n\t            logging.info(\"No results found.\")\n"]}
{"filename": "agixt/app.py", "chunked_list": ["import uvicorn\n\timport os\n\timport logging\n\timport base64\n\timport string\n\timport random\n\timport time\n\tfrom fastapi import FastAPI, HTTPException, Depends, Request, Header\n\tfrom fastapi.middleware.cors import CORSMiddleware\n\tfrom pydantic import BaseModel\n", "from Interactions import Interactions\n\tfrom Embedding import Embedding\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tAGIXT_API_KEY = os.getenv(\"AGIXT_API_KEY\")\n\tdb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\n\tif db_connected:\n\t    from db.Agent import Agent, add_agent, delete_agent, rename_agent, get_agents\n\t    from db.Chain import Chain\n\t    from db.Prompts import Prompts\n", "    from db.History import (\n\t        get_conversation,\n\t        delete_history,\n\t        delete_message,\n\t        get_conversations,\n\t        new_conversation,\n\t    )\n\telse:\n\t    from fb.Agent import Agent, add_agent, delete_agent, rename_agent, get_agents\n\t    from fb.Chain import Chain\n", "    from fb.Prompts import Prompts\n\t    from fb.History import (\n\t        get_conversation,\n\t        delete_history,\n\t        delete_message,\n\t        get_conversations,\n\t        new_conversation,\n\t    )\n\tfrom typing import Optional, Dict, List, Any\n\tfrom Providers import get_provider_options, get_providers\n", "from Embedding import get_embedding_providers, get_tokens\n\tfrom Extensions import Extensions\n\tos.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n\tthis_directory = os.path.abspath(os.path.dirname(__file__))\n\twith open(os.path.join(this_directory, \"version\"), encoding=\"utf-8\") as f:\n\t    version = f.read().strip()\n\tlogging.basicConfig(\n\t    level=os.environ.get(\"LOGLEVEL\", \"INFO\"),\n\t    format=\"%(asctime)s | %(levelname)s | %(message)s\",\n\t)\n", "app = FastAPI(\n\t    title=\"AGiXT\",\n\t    description=\"AGiXT is an Artificial Intelligence Automation platform for creating and managing AI agents. Visit the GitHub repo for more information or to report issues. https://github.com/Josh-XT/AGiXT/\",\n\t    version=version,\n\t    docs_url=\"/\",\n\t)\n\tapp.add_middleware(\n\t    CORSMiddleware,\n\t    allow_origins=[\"*\"],\n\t    allow_credentials=True,\n", "    allow_methods=[\"*\"],\n\t    allow_headers=[\"*\"],\n\t)\n\tasync def get_api_key(authorization: str = Header(None)):\n\t    if AGIXT_API_KEY:\n\t        if authorization is None:\n\t            raise HTTPException(\n\t                status_code=400, detail=\"Authorization header is missing\"\n\t            )\n\t        scheme, _, api_key = authorization.partition(\" \")\n", "        if scheme.lower() != \"bearer\":\n\t            raise HTTPException(\n\t                status_code=400, detail=\"Authorization scheme is not Bearer\"\n\t            )\n\t        return api_key\n\t    else:\n\t        return None\n\tdef verify_api_key(api_key: str = Depends(get_api_key)):\n\t    if AGIXT_API_KEY and api_key != AGIXT_API_KEY:\n\t        raise HTTPException(status_code=403, detail=\"Invalid API Key\")\n", "    return api_key\n\tclass AgentName(BaseModel):\n\t    agent_name: str\n\tclass AgentNewName(BaseModel):\n\t    new_name: str\n\tclass AgentPrompt(BaseModel):\n\t    prompt_name: str\n\t    prompt_args: dict\n\tclass Objective(BaseModel):\n\t    objective: str\n", "class Prompt(BaseModel):\n\t    prompt: str\n\tclass PromptName(BaseModel):\n\t    prompt_name: str\n\tclass PromptList(BaseModel):\n\t    prompts: List[str]\n\tclass Completions(BaseModel):\n\t    # Everything in this class except prompt, n, and model (agent_name) are unused currently.\n\t    prompt: str\n\t    max_tokens: int = 100\n", "    temperature: float = 0.9\n\t    top_p: float = 1.0\n\t    n: int = 1\n\t    stream: bool = False\n\t    logprobs: int = None\n\t    stop: List[str] = None\n\t    presence_penalty: float = 0.0\n\t    frequency_penalty: float = 0.0\n\t    best_of: int = 1\n\t    echo: bool = False\n", "    user: str = None\n\t    model: str = None  # Model is actually the agent_name\n\t    stop_sequence: List[str] = None\n\t    metadata: Dict[str, str] = None\n\tclass ChainNewName(BaseModel):\n\t    new_name: str\n\tclass ChainName(BaseModel):\n\t    chain_name: str\n\tclass ChainData(BaseModel):\n\t    chain_name: str\n", "    steps: Dict[str, Any]\n\tclass RunChain(BaseModel):\n\t    prompt: str\n\t    agent_override: Optional[str] = \"\"\n\t    all_responses: Optional[bool] = False\n\t    from_step: Optional[int] = 1\n\tclass RunChainStep(BaseModel):\n\t    prompt: str\n\t    agent_override: Optional[str] = \"\"\n\tclass StepInfo(BaseModel):\n", "    step_number: int\n\t    agent_name: str\n\t    prompt_type: str\n\t    prompt: dict\n\tclass RunChainResponse(BaseModel):\n\t    response: str\n\t    agent_name: str\n\t    prompt: dict\n\t    prompt_type: str\n\tclass ChainStep(BaseModel):\n", "    step_number: int\n\t    agent_name: str\n\t    prompt_type: str\n\t    prompt: dict\n\tclass ChainStepNewInfo(BaseModel):\n\t    old_step_number: int\n\t    new_step_number: int\n\tclass ResponseMessage(BaseModel):\n\t    message: str\n\tclass UrlInput(BaseModel):\n", "    url: str\n\tclass EmbeddingModel(BaseModel):\n\t    input: str\n\t    model: str\n\tclass FileInput(BaseModel):\n\t    file_name: str\n\t    file_content: str\n\tclass TaskOutput(BaseModel):\n\t    output: str\n\t    message: Optional[str] = None\n", "class ToggleCommandPayload(BaseModel):\n\t    command_name: str\n\t    enable: bool\n\tclass CustomPromptModel(BaseModel):\n\t    prompt_name: str\n\t    prompt: str\n\tclass AgentSettings(BaseModel):\n\t    agent_name: str\n\t    settings: Dict[str, Any]\n\tclass AgentConfig(BaseModel):\n", "    agent_name: str\n\t    settings: Dict[str, Any]\n\t    commands: Dict[str, Any]\n\tclass AgentCommands(BaseModel):\n\t    agent_name: str\n\t    commands: Dict[str, Any]\n\tclass HistoryModel(BaseModel):\n\t    agent_name: str\n\t    conversation_name: str\n\t    limit: int = 100\n", "    page: int = 1\n\tclass ConversationHistoryModel(BaseModel):\n\t    agent_name: str\n\t    conversation_name: str\n\tclass ConversationHistoryMessageModel(BaseModel):\n\t    agent_name: str\n\t    conversation_name: str\n\t    message: str\n\t@app.get(\"/api/provider\", tags=[\"Provider\"], dependencies=[Depends(verify_api_key)])\n\tasync def getproviders():\n", "    providers = get_providers()\n\t    return {\"providers\": providers}\n\t@app.get(\n\t    \"/api/provider/{provider_name}\",\n\t    tags=[\"Provider\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_provider_settings(provider_name: str):\n\t    settings = get_provider_options(provider_name=provider_name)\n\t    return {\"settings\": settings}\n", "@app.get(\n\t    \"/api/embedding_providers\",\n\t    tags=[\"Provider\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_embed_providers():\n\t    providers = get_embedding_providers()\n\t    return {\"providers\": providers}\n\t@app.post(\"/api/agent\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\n\tasync def addagent(agent: AgentSettings) -> Dict[str, str]:\n", "    return add_agent(agent_name=agent.agent_name, provider_settings=agent.settings)\n\t@app.post(\"/api/agent/import\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\n\tasync def import_agent(agent: AgentConfig) -> Dict[str, str]:\n\t    return add_agent(\n\t        agent_name=agent.agent_name,\n\t        provider_settings=agent.settings,\n\t        commands=agent.commands,\n\t    )\n\t@app.patch(\n\t    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n", ")\n\tasync def renameagent(agent_name: str, new_name: AgentNewName) -> ResponseMessage:\n\t    rename_agent(agent_name=agent_name, new_name=new_name.new_name)\n\t    return ResponseMessage(message=\"Agent renamed.\")\n\t@app.put(\n\t    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def update_agent_settings(\n\t    agent_name: str, settings: AgentSettings\n\t) -> ResponseMessage:\n", "    update_config = Agent(agent_name=agent_name).update_agent_config(\n\t        new_config=settings.settings, config_key=\"settings\"\n\t    )\n\t    return ResponseMessage(message=update_config)\n\t@app.post(\n\t    \"/api/agent/{agent_name}/learn/file\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def learn_file(agent_name: str, file: FileInput) -> ResponseMessage:\n", "    # Strip any path information from the file name\n\t    file.file_name = os.path.basename(file.file_name)\n\t    base_path = os.path.join(os.getcwd(), \"WORKSPACE\")\n\t    file_path = os.path.normpath(os.path.join(base_path, file.file_name))\n\t    if not file_path.startswith(base_path):\n\t        raise Exception(\"Path given not allowed\")\n\t    file_content = base64.b64decode(file.file_content)\n\t    with open(file_path, \"wb\") as f:\n\t        f.write(file_content)\n\t    try:\n", "        memories = Agent(agent_name=agent_name).get_memories()\n\t        await memories.read_file(file_path=file_path)\n\t        try:\n\t            os.remove(file_path)\n\t        except Exception:\n\t            pass\n\t        return ResponseMessage(message=\"Agent learned the content from the file.\")\n\t    except Exception as e:\n\t        try:\n\t            os.remove(file_path)\n", "        except Exception:\n\t            pass\n\t        raise HTTPException(status_code=500, detail=str(e))\n\t@app.post(\n\t    \"/api/agent/{agent_name}/learn/url\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def learn_url(agent_name: str, url: UrlInput) -> ResponseMessage:\n\t    try:\n", "        memories = Agent(agent_name=agent_name).get_memories()\n\t        await memories.read_website(url=url.url)\n\t        return ResponseMessage(message=\"Agent learned the content from the url.\")\n\t    except Exception as e:\n\t        raise HTTPException(status_code=500, detail=str(e))\n\t@app.put(\n\t    \"/api/agent/{agent_name}/commands\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n", "async def update_agent_commands(\n\t    agent_name: str, commands: AgentCommands\n\t) -> ResponseMessage:\n\t    update_config = Agent(agent_name=agent_name).update_agent_config(\n\t        new_config=commands.commands, config_key=\"commands\"\n\t    )\n\t    return ResponseMessage(message=update_config)\n\t@app.delete(\n\t    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n\t)\n", "async def deleteagent(agent_name: str) -> ResponseMessage:\n\t    delete_agent(agent_name=agent_name)\n\t    return ResponseMessage(message=f\"Agent {agent_name} deleted.\")\n\t@app.get(\"/api/agent\", tags=[\"Agent\"])\n\tasync def getagents():\n\t    agents = get_agents()\n\t    return {\"agents\": agents}\n\t@app.get(\n\t    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n\t)\n", "async def get_agentconfig(agent_name: str):\n\t    agent_config = Agent(agent_name=agent_name).get_agent_config()\n\t    return {\"agent\": agent_config}\n\t@app.get(\n\t    \"/api/{agent_name}/conversations\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_conversations_list(agent_name: str):\n\t    conversations = get_conversations(\n", "        agent_name=agent_name,\n\t    )\n\t    if conversations is None:\n\t        conversations = []\n\t    return {\"conversations\": conversations}\n\t@app.get(\"/api/conversation\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\n\tasync def get_conversation_history(history: HistoryModel):\n\t    conversation_history = get_conversation(\n\t        agent_name=history.agent_name,\n\t        conversation_name=history.conversation_name,\n", "        limit=history.limit,\n\t        page=history.page,\n\t    )\n\t    if conversation_history is None:\n\t        conversation_history = []\n\t    if \"interactions\" in conversation_history:\n\t        conversation_history = conversation_history[\"interactions\"]\n\t    return {\"conversation_history\": conversation_history}\n\t@app.post(\"/api/conversation\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\n\tasync def new_conversation_history(history: ConversationHistoryModel):\n", "    new_conversation(\n\t        agent_name=history.agent_name,\n\t        conversation_name=history.conversation_name,\n\t    )\n\t    return {\"conversation_history\": []}\n\t@app.delete(\n\t    \"/api/conversation\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n", "async def delete_conversation_history(\n\t    history: ConversationHistoryModel,\n\t) -> ResponseMessage:\n\t    delete_history(\n\t        agent_name=history.agent_name, conversation_name=history.conversation_name\n\t    )\n\t    return ResponseMessage(\n\t        message=f\"Conversation `{history.conversation_name}` for agent {history.agent_name} deleted.\"\n\t    )\n\t@app.delete(\n", "    \"/api/conversation/message\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def delete_history_message(\n\t    history: ConversationHistoryMessageModel,\n\t) -> ResponseMessage:\n\t    delete_message(\n\t        agent_name=history.agent_name,\n\t        message=history.message,\n", "        conversation_name=f\"{history.agent_name} History\",\n\t    )\n\t    return ResponseMessage(message=f\"Message deleted.\")\n\t@app.delete(\n\t    \"/api/agent/{agent_name}/memory\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def wipe_agent_memories(agent_name: str) -> ResponseMessage:\n\t    Agent(agent_name=agent_name).wipe_agent_memories()\n", "    return ResponseMessage(message=f\"Memories for agent {agent_name} deleted.\")\n\t@app.post(\n\t    \"/api/agent/{agent_name}/prompt\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def prompt_agent(agent_name: str, agent_prompt: AgentPrompt):\n\t    agent = Interactions(agent_name=agent_name)\n\t    response = await agent.run(\n\t        prompt=agent_prompt.prompt_name,\n", "        **agent_prompt.prompt_args,\n\t    )\n\t    return {\"response\": str(response)}\n\t@app.post(\"/api/v1/completions\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\n\tasync def completion(prompt: Completions):\n\t    # prompt.model is the agent name\n\t    agent = Interactions(agent_name=prompt.model)\n\t    agent_config = Agent(agent_name=prompt.model).get_agent_config()\n\t    if \"settings\" in agent_config:\n\t        if \"AI_MODEL\" in agent_config[\"settings\"]:\n", "            model = agent_config[\"settings\"][\"AI_MODEL\"]\n\t        else:\n\t            model = \"undefined\"\n\t    else:\n\t        model = \"undefined\"\n\t    response = await agent.run(\n\t        user_input=prompt.prompt,\n\t        prompt=\"Custom Input\",\n\t        context_results=3,\n\t        shots=prompt.n,\n", "    )\n\t    characters = string.ascii_letters + string.digits\n\t    prompt_tokens = get_tokens(prompt.prompt)\n\t    completion_tokens = get_tokens(response)\n\t    total_tokens = int(prompt_tokens) + int(completion_tokens)\n\t    random_chars = \"\".join(random.choice(characters) for _ in range(15))\n\t    res_model = {\n\t        \"id\": f\"cmpl-{random_chars}\",\n\t        \"object\": \"text_completion\",\n\t        \"created\": int(time.time()),\n", "        \"model\": model,\n\t        \"choices\": [\n\t            {\n\t                \"text\": response,\n\t                \"index\": 0,\n\t                \"logprobs\": None,\n\t                \"finish_reason\": \"stop\",\n\t            }\n\t        ],\n\t        \"usage\": {\n", "            \"prompt_tokens\": prompt_tokens,\n\t            \"completion_tokens\": completion_tokens,\n\t            \"total_tokens\": total_tokens,\n\t        },\n\t    }\n\t    return res_model\n\t@app.post(\n\t    \"/api/v1/chat/completions\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def chat_completion(prompt: Completions):\n", "    # prompt.model is the agent name\n\t    agent = Interactions(agent_name=prompt.model)\n\t    agent_config = Agent(agent_name=prompt.model).get_agent_config()\n\t    if \"settings\" in agent_config:\n\t        if \"AI_MODEL\" in agent_config[\"settings\"]:\n\t            model = agent_config[\"settings\"][\"AI_MODEL\"]\n\t        else:\n\t            model = \"undefined\"\n\t    else:\n\t        model = \"undefined\"\n", "    response = await agent.run(\n\t        user_input=prompt.prompt,\n\t        prompt=\"Custom Input\",\n\t        context_results=3,\n\t        shots=prompt.n,\n\t    )\n\t    characters = string.ascii_letters + string.digits\n\t    prompt_tokens = get_tokens(prompt.prompt)\n\t    completion_tokens = get_tokens(response)\n\t    total_tokens = int(prompt_tokens) + int(completion_tokens)\n", "    random_chars = \"\".join(random.choice(characters) for _ in range(15))\n\t    res_model = {\n\t        \"id\": f\"chatcmpl-{random_chars}\",\n\t        \"object\": \"chat.completion\",\n\t        \"created\": int(time.time()),\n\t        \"model\": model,\n\t        \"choices\": [\n\t            {\n\t                \"index\": 0,\n\t                \"message\": [\n", "                    {\n\t                        \"role\": \"assistant\",\n\t                        \"content\": response,\n\t                    },\n\t                ],\n\t                \"finish_reason\": \"stop\",\n\t            }\n\t        ],\n\t        \"usage\": {\n\t            \"prompt_tokens\": prompt_tokens,\n", "            \"completion_tokens\": completion_tokens,\n\t            \"total_tokens\": total_tokens,\n\t        },\n\t    }\n\t    return res_model\n\t# Use agent name in the model field to use embedding.\n\t@app.post(\"/api/v1/embedding\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\n\tasync def embedding(embedding: EmbeddingModel):\n\t    agent_name = embedding.model\n\t    agent_config = Agent(agent_name=agent_name).get_agent_config()\n", "    tokens = get_tokens(embedding.input)\n\t    embedding = Embedding(AGENT_CONFIG=agent_config).embed_text(embedding.input)\n\t    return {\n\t        \"data\": [{\"embedding\": embedding, \"index\": 0, \"object\": \"embedding\"}],\n\t        \"model\": agent_name,\n\t        \"object\": \"list\",\n\t        \"usage\": {\"prompt_tokens\": tokens, \"total_tokens\": tokens},\n\t    }\n\t@app.get(\n\t    \"/api/agent/{agent_name}/command\",\n", "    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_commands(agent_name: str):\n\t    agent = Agent(agent_name=agent_name)\n\t    return {\"commands\": agent.AGENT_CONFIG[\"commands\"]}\n\t@app.patch(\n\t    \"/api/agent/{agent_name}/command\",\n\t    tags=[\"Agent\"],\n\t    dependencies=[Depends(verify_api_key)],\n", ")\n\tasync def toggle_command(\n\t    agent_name: str, payload: ToggleCommandPayload\n\t) -> ResponseMessage:\n\t    agent = Agent(agent_name=agent_name)\n\t    try:\n\t        if payload.command_name == \"*\":\n\t            for each_command_name in agent.AGENT_CONFIG[\"commands\"]:\n\t                agent.AGENT_CONFIG[\"commands\"][each_command_name] = payload.enable\n\t            agent.update_agent_config(\n", "                new_config=agent.AGENT_CONFIG[\"commands\"], config_key=\"commands\"\n\t            )\n\t            return ResponseMessage(\n\t                message=f\"All commands enabled for agent '{agent_name}'.\"\n\t            )\n\t        else:\n\t            agent.AGENT_CONFIG[\"commands\"][payload.command_name] = payload.enable\n\t            agent.update_agent_config(\n\t                new_config=agent.AGENT_CONFIG[\"commands\"], config_key=\"commands\"\n\t            )\n", "            return ResponseMessage(\n\t                message=f\"Command '{payload.command_name}' toggled for agent '{agent_name}'.\"\n\t            )\n\t    except Exception as e:\n\t        logging.info(e)\n\t        raise HTTPException(\n\t            status_code=500,\n\t            detail=f\"Error enabling all commands for agent '{agent_name}': {str(e)}\",\n\t        )\n\t@app.get(\"/api/chain\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)])\n", "async def get_chains():\n\t    chains = Chain().get_chains()\n\t    return chains\n\t@app.get(\n\t    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def get_chain(chain_name: str):\n\t    # try:\n\t    chain_data = Chain().get_chain(chain_name=chain_name)\n\t    return {\"chain\": chain_data}\n", "    # except:\n\t    #    raise HTTPException(status_code=404, detail=\"Chain not found\")\n\t@app.get(\"/api/chain/{chain_name}/responses\", tags=[\"Chain\"])\n\tasync def get_chain_responses(chain_name: str):\n\t    try:\n\t        chain_data = Chain().get_step_response(chain_name=chain_name, step_number=\"all\")\n\t        return {\"chain\": chain_data}\n\t    except:\n\t        raise HTTPException(status_code=404, detail=\"Chain not found\")\n\t@app.post(\n", "    \"/api/chain/{chain_name}/run\",\n\t    tags=[\"Chain\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def run_chain(chain_name: str, user_input: RunChain):\n\t    chain_response = await Chain().run_chain(\n\t        chain_name=chain_name,\n\t        user_input=user_input.prompt,\n\t        agent_override=user_input.agent_override,\n\t        all_responses=user_input.all_responses,\n", "        from_step=user_input.from_step,\n\t    )\n\t    return chain_response\n\t@app.post(\n\t    \"/api/chain/{chain_name}/run/step/{step_number}\",\n\t    tags=[\"Chain\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def run_chain_step(chain_name: str, step_number: str, user_input: RunChainStep):\n\t    chain = Chain()\n", "    chain_steps = chain.get_chain(chain_name=chain_name)\n\t    try:\n\t        step = chain_steps[\"step\"][step_number]\n\t    except Exception as e:\n\t        raise HTTPException(\n\t            status_code=404, detail=f\"Step {step_number} not found. {e}\"\n\t        )\n\t    chain_step_response = await chain.run_chain_step(\n\t        step=step,\n\t        chain_name=chain_name,\n", "        user_input=user_input.prompt,\n\t        agent_override=user_input.agent_override,\n\t    )\n\t    return chain_step_response\n\t@app.post(\"/api/chain\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)])\n\tasync def add_chain(chain_name: ChainName) -> ResponseMessage:\n\t    Chain().add_chain(chain_name=chain_name.chain_name)\n\t    return ResponseMessage(message=f\"Chain '{chain_name.chain_name}' created.\")\n\t@app.post(\"/api/chain/import\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)])\n\tasync def importchain(chain: ChainData) -> ResponseMessage:\n", "    response = Chain().import_chain(chain_name=chain.chain_name, steps=chain.steps)\n\t    return ResponseMessage(message=response)\n\t@app.put(\n\t    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def rename_chain(chain_name: str, new_name: ChainNewName) -> ResponseMessage:\n\t    Chain().rename_chain(chain_name=chain_name, new_name=new_name.new_name)\n\t    return ResponseMessage(\n\t        message=f\"Chain '{chain_name}' renamed to '{new_name.new_name}'.\"\n\t    )\n", "@app.delete(\n\t    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def delete_chain(chain_name: str) -> ResponseMessage:\n\t    Chain().delete_chain(chain_name=chain_name)\n\t    return ResponseMessage(message=f\"Chain '{chain_name}' deleted.\")\n\t@app.post(\n\t    \"/api/chain/{chain_name}/step\",\n\t    tags=[\"Chain\"],\n\t    dependencies=[Depends(verify_api_key)],\n", ")\n\tasync def add_step(chain_name: str, step_info: StepInfo) -> ResponseMessage:\n\t    Chain().add_chain_step(\n\t        chain_name=chain_name,\n\t        step_number=step_info.step_number,\n\t        prompt_type=step_info.prompt_type,\n\t        prompt=step_info.prompt,\n\t        agent_name=step_info.agent_name,\n\t    )\n\t    return {\"message\": f\"Step {step_info.step_number} added to chain '{chain_name}'.\"}\n", "@app.put(\n\t    \"/api/chain/{chain_name}/step/{step_number}\",\n\t    tags=[\"Chain\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def update_step(\n\t    chain_name: str, step_number: int, chain_step: ChainStep\n\t) -> ResponseMessage:\n\t    Chain().update_step(\n\t        chain_name=chain_name,\n", "        step_number=chain_step.step_number,\n\t        prompt_type=chain_step.prompt_type,\n\t        prompt=chain_step.prompt,\n\t        agent_name=chain_step.agent_name,\n\t    )\n\t    return {\n\t        \"message\": f\"Step {chain_step.step_number} updated for chain '{chain_name}'.\"\n\t    }\n\t@app.patch(\n\t    \"/api/chain/{chain_name}/step/move\",\n", "    tags=[\"Chain\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def move_step(\n\t    chain_name: str, chain_step_new_info: ChainStepNewInfo\n\t) -> ResponseMessage:\n\t    Chain().move_step(\n\t        chain_name=chain_name,\n\t        current_step_number=chain_step_new_info.old_step_number,\n\t        new_step_number=chain_step_new_info.new_step_number,\n", "    )\n\t    return {\n\t        \"message\": f\"Step {chain_step_new_info.old_step_number} moved to {chain_step_new_info.new_step_number} in chain '{chain_name}'.\"\n\t    }\n\t@app.delete(\n\t    \"/api/chain/{chain_name}/step/{step_number}\",\n\t    tags=[\"Chain\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def delete_step(chain_name: str, step_number: int) -> ResponseMessage:\n", "    Chain().delete_step(chain_name=chain_name, step_number=step_number)\n\t    return {\"message\": f\"Step {step_number} deleted from chain '{chain_name}'.\"}\n\t@app.post(\"/api/prompt\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)])\n\tasync def add_prompt(prompt: CustomPromptModel) -> ResponseMessage:\n\t    try:\n\t        Prompts().add_prompt(prompt_name=prompt.prompt_name, prompt=prompt.prompt)\n\t        return ResponseMessage(message=f\"Prompt '{prompt.prompt_name}' added.\")\n\t    except Exception as e:\n\t        raise HTTPException(status_code=400, detail=str(e))\n\t@app.get(\n", "    \"/api/prompt/{prompt_name}\",\n\t    tags=[\"Prompt\"],\n\t    response_model=CustomPromptModel,\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_prompt(prompt_name: str):\n\t    # try:\n\t    prompt_content = Prompts().get_prompt(prompt_name=prompt_name)\n\t    return {\"prompt_name\": prompt_name, \"prompt\": prompt_content}\n\t    # except Exception as e:\n", "    #    raise HTTPException(status_code=404, detail=str(e))\n\t@app.get(\n\t    \"/api/prompt\",\n\t    response_model=PromptList,\n\t    tags=[\"Prompt\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_prompts():\n\t    prompts = Prompts().get_prompts()\n\t    return {\"prompts\": prompts}\n", "@app.delete(\n\t    \"/api/prompt/{prompt_name}\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def delete_prompt(prompt_name: str) -> ResponseMessage:\n\t    try:\n\t        Prompts().delete_prompt(prompt_name=prompt_name)\n\t        return ResponseMessage(message=f\"Prompt '{prompt_name}' deleted.\")\n\t    except Exception as e:\n\t        raise HTTPException(status_code=404, detail=str(e))\n\t# Rename prompt\n", "@app.patch(\n\t    \"/api/prompt/{prompt_name}\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def rename_prompt(prompt_name: str, new_name: PromptName) -> ResponseMessage:\n\t    try:\n\t        Prompts().rename_prompt(prompt_name=prompt_name, new_name=new_name.prompt_name)\n\t        return ResponseMessage(\n\t            message=f\"Prompt '{prompt_name}' renamed to '{new_name.prompt_name}'.\"\n\t        )\n\t    except Exception as e:\n", "        raise HTTPException(status_code=404, detail=str(e))\n\t@app.put(\n\t    \"/api/prompt/{prompt_name}\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)]\n\t)\n\tasync def update_prompt(prompt: CustomPromptModel) -> ResponseMessage:\n\t    try:\n\t        Prompts().update_prompt(prompt_name=prompt.prompt_name, prompt=prompt.prompt)\n\t        return ResponseMessage(message=f\"Prompt '{prompt.prompt_name}' updated.\")\n\t    except Exception as e:\n\t        raise HTTPException(status_code=404, detail=str(e))\n", "@app.get(\n\t    \"/api/prompt/{prompt_name}/args\",\n\t    tags=[\"Prompt\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_prompt_arg(prompt_name: str):\n\t    prompt_name = prompt_name.replace(\"%20\", \" \")\n\t    prompt = Prompts().get_prompt(prompt_name=prompt_name)\n\t    return {\"prompt_args\": Prompts().get_prompt_args(prompt)}\n\t@app.get(\n", "    \"/api/extensions/settings\",\n\t    tags=[\"Extensions\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_extension_settings():\n\t    try:\n\t        return {\"extension_settings\": Extensions().get_extension_settings()}\n\t    except Exception:\n\t        raise HTTPException(status_code=400, detail=\"Unable to retrieve settings.\")\n\t@app.get(\n", "    \"/api/extensions/{command_name}/args\",\n\t    tags=[\"Extension\"],\n\t    dependencies=[Depends(verify_api_key)],\n\t)\n\tasync def get_command_args(command_name: str):\n\t    return {\"command_args\": Extensions().get_command_args(command_name=command_name)}\n\t@app.get(\"/api/extensions\", tags=[\"Extension\"], dependencies=[Depends(verify_api_key)])\n\tasync def get_extensions():\n\t    extensions = Extensions().get_extensions()\n\t    return {\"extensions\": extensions}\n", "if __name__ == \"__main__\":\n\t    uvicorn.run(app, host=\"0.0.0.0\", port=7437)\n"]}
{"filename": "agixt/Interactions.py", "chunked_list": ["import re\n\timport os\n\timport regex\n\timport json\n\timport time\n\timport logging\n\timport asyncio\n\tfrom datetime import datetime\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n", "db_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\n\tif db_connected:\n\t    from db.Agent import Agent\n\t    from db.Prompts import Prompts\n\t    from db.Chain import Chain\n\t    from db.History import log_interaction\n\telse:\n\t    from fb.Agent import Agent\n\t    from fb.Prompts import Prompts\n\t    from fb.Chain import Chain\n", "    from fb.History import log_interaction\n\tfrom Embedding import get_tokens\n\tfrom concurrent.futures import Future\n\tfrom agixtsdk import AGiXTSDK\n\tfrom Websearch import Websearch\n\tApiClient = AGiXTSDK(\n\t    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n\t)\n\tchain = Chain()\n\tcp = Prompts()\n", "class Interactions:\n\t    def __init__(self, agent_name: str = \"\"):\n\t        if agent_name != \"\":\n\t            self.agent_name = agent_name\n\t            self.agent = Agent(self.agent_name)\n\t            self.agent_commands = self.agent.get_commands_string()\n\t            self.memories = self.agent.get_memories()\n\t            self.websearch = Websearch(agent=self.agent, memories=self.memories)\n\t        else:\n\t            self.agent_name = \"\"\n", "            self.agent = None\n\t            self.agent_commands = \"\"\n\t            self.memories = None\n\t        self.stop_running_event = None\n\t        self.browsed_links = []\n\t        self.failures = 0\n\t    def custom_format(self, string, **kwargs):\n\t        if isinstance(string, list):\n\t            string = \"\".join(str(x) for x in string)\n\t        def replace(match):\n", "            key = match.group(1)\n\t            value = kwargs.get(key, match.group(0))\n\t            if isinstance(value, list):\n\t                return \"\".join(str(x) for x in value)\n\t            else:\n\t                return str(value)\n\t        pattern = r\"(?<!{){([^{}\\n]+)}(?!})\"\n\t        result = re.sub(pattern, replace, string)\n\t        return result\n\t    async def format_prompt(\n", "        self,\n\t        user_input: str = \"\",\n\t        top_results: int = 5,\n\t        prompt=\"\",\n\t        chain_name=\"\",\n\t        step_number=0,\n\t        **kwargs,\n\t    ):\n\t        if prompt == \"\":\n\t            prompt = user_input\n", "        else:\n\t            try:\n\t                prompt = cp.get_prompt(\n\t                    prompt_name=prompt,\n\t                    prompt_category=self.agent.AGENT_CONFIG[\"settings\"][\"AI_MODEL\"],\n\t                )\n\t            except:\n\t                prompt = prompt\n\t        logging.info(f\"CONTEXT RESULTS: {top_results}\")\n\t        if top_results == 0:\n", "            context = \"\"\n\t        else:\n\t            # try:\n\t            context = await self.memories.context_agent(\n\t                query=user_input, top_results_num=top_results\n\t            )\n\t            # except:\n\t            # context = \"\"\n\t        command_list = self.agent.get_commands_string()\n\t        if chain_name != \"\":\n", "            try:\n\t                for arg, value in kwargs.items():\n\t                    if \"{STEP\" in value:\n\t                        # get the response from the step number\n\t                        step_response = chain.get_step_response(\n\t                            chain_name=chain_name, step_number=step_number\n\t                        )\n\t                        # replace the {STEPx} with the response\n\t                        value = value.replace(f\"{{STEP{step_number}}}\", step_response)\n\t                        kwargs[arg] = value\n", "            except:\n\t                logging.info(\"No args to replace.\")\n\t            if \"{STEP\" in prompt:\n\t                step_response = chain.get_step_response(\n\t                    chain_name=chain_name, step_number=step_number\n\t                )\n\t                prompt = prompt.replace(f\"{{STEP{step_number}}}\", step_response)\n\t            if \"{STEP\" in user_input:\n\t                step_response = chain.get_step_response(\n\t                    chain_name=chain_name, step_number=step_number\n", "                )\n\t                user_input = user_input.replace(f\"{{STEP{step_number}}}\", step_response)\n\t        try:\n\t            working_directory = self.agent.AGENT_CONFIG[\"settings\"][\"WORKING_DIRECTORY\"]\n\t        except:\n\t            working_directory = \"./WORKSPACE\"\n\t        if \"helper_agent_name\" not in kwargs:\n\t            if \"helper_agent_name\" in self.agent.AGENT_CONFIG[\"settings\"]:\n\t                helper_agent_name = self.agent.AGENT_CONFIG[\"settings\"][\n\t                    \"helper_agent_name\"\n", "                ]\n\t            else:\n\t                helper_agent_name = self.agent_name\n\t        formatted_prompt = self.custom_format(\n\t            string=prompt,\n\t            user_input=user_input,\n\t            agent_name=self.agent_name,\n\t            COMMANDS=self.agent_commands,\n\t            context=context,\n\t            command_list=command_list,\n", "            date=datetime.now().strftime(\"%B %d, %Y %I:%M %p\"),\n\t            working_directory=working_directory,\n\t            helper_agent_name=helper_agent_name,\n\t            **kwargs,\n\t        )\n\t        tokens = get_tokens(formatted_prompt)\n\t        logging.info(f\"FORMATTED PROMPT: {formatted_prompt}\")\n\t        return formatted_prompt, prompt, tokens\n\t    async def run(\n\t        self,\n", "        user_input: str = \"\",\n\t        prompt: str = \"\",\n\t        context_results: int = 5,\n\t        websearch: bool = False,\n\t        websearch_depth: int = 3,\n\t        chain_name: str = \"\",\n\t        step_number: int = 0,\n\t        shots: int = 1,\n\t        disable_memory: bool = False,\n\t        conversation_name: str = \"\",\n", "        browse_links: bool = False,\n\t        **kwargs,\n\t    ):\n\t        shots = int(shots)\n\t        disable_memory = True if str(disable_memory).lower() == \"true\" else False\n\t        browse_links = True if str(browse_links).lower() == \"true\" else False\n\t        if conversation_name != \"\":\n\t            conversation_name = f\"{self.agent_name} History\"\n\t        if \"WEBSEARCH_TIMEOUT\" in self.agent.PROVIDER_SETTINGS:\n\t            try:\n", "                websearch_timeout = int(\n\t                    self.agent.PROVIDER_SETTINGS[\"WEBSEARCH_TIMEOUT\"]\n\t                )\n\t            except:\n\t                websearch_timeout = 0\n\t        else:\n\t            websearch_timeout = 0\n\t        if browse_links != False:\n\t            links = re.findall(r\"(?P<url>https?://[^\\s]+)\", user_input)\n\t            if links is not None and len(links) > 0:\n", "                for link in links:\n\t                    if link not in self.websearch.browsed_links:\n\t                        logging.info(f\"Browsing link: {link}\")\n\t                        self.websearch.browsed_links.append(link)\n\t                        text_content, link_list = await self.memories.read_website(\n\t                            url=link\n\t                        )\n\t                        if link_list is not None and len(link_list) > 0:\n\t                            i = 0\n\t                            for sublink in link_list:\n", "                                if sublink[1] not in self.websearch.browsed_links:\n\t                                    logging.info(f\"Browsing link: {sublink[1]}\")\n\t                                    if i <= 10:\n\t                                        (\n\t                                            text_content,\n\t                                            link_list,\n\t                                        ) = await self.memories.read_website(\n\t                                            url=sublink[1]\n\t                                        )\n\t                                        i = i + 1\n", "        if websearch:\n\t            if user_input == \"\":\n\t                if \"primary_objective\" in kwargs and \"task\" in kwargs:\n\t                    search_string = f\"Primary Objective: {kwargs['primary_objective']}\\n\\nTask: {kwargs['task']}\"\n\t                else:\n\t                    search_string = \"\"\n\t            else:\n\t                search_string = user_input\n\t            if search_string != \"\":\n\t                await self.websearch.websearch_agent(\n", "                    user_input=search_string,\n\t                    depth=websearch_depth,\n\t                    timeout=websearch_timeout,\n\t                )\n\t        formatted_prompt, unformatted_prompt, tokens = await self.format_prompt(\n\t            user_input=user_input,\n\t            top_results=int(context_results),\n\t            prompt=prompt,\n\t            chain_name=chain_name,\n\t            step_number=step_number,\n", "            **kwargs,\n\t        )\n\t        try:\n\t            # Workaround for non-threaded providers\n\t            run_response = await self.agent.instruct(formatted_prompt, tokens=tokens)\n\t            self.response = (\n\t                run_response.result()\n\t                if isinstance(run_response, Future)\n\t                else run_response\n\t            )\n", "        except Exception as e:\n\t            logging.info(f\"Error: {e}\")\n\t            logging.info(f\"PROMPT CONTENT: {formatted_prompt}\")\n\t            logging.info(f\"TOKENS: {tokens}\")\n\t            self.failures += 1\n\t            if self.failures == 5:\n\t                self.failures == 0\n\t                logging.info(\"Failed to get a response 5 times in a row.\")\n\t                return None\n\t            logging.info(f\"Retrying in 10 seconds...\")\n", "            time.sleep(10)\n\t            if context_results > 0:\n\t                context_results = context_results - 1\n\t            self.response = ApiClient.prompt_agent(\n\t                agent_name=self.agent_name,\n\t                prompt_name=prompt,\n\t                prompt_args={\n\t                    \"chain_name\": chain_name,\n\t                    \"step_number\": step_number,\n\t                    \"shots\": shots,\n", "                    \"disable_memory\": disable_memory,\n\t                    \"user_input\": user_input,\n\t                    \"context_results\": context_results,\n\t                    \"conversation_name\": conversation_name,\n\t                    **kwargs,\n\t                },\n\t            )\n\t        # Handle commands if the prompt contains the {COMMANDS} placeholder\n\t        # We handle command injection that DOESN'T allow command execution by using {command_list} in the prompt\n\t        if \"{COMMANDS}\" in unformatted_prompt:\n", "            execution_response = await self.execution_agent(\n\t                execution_response=self.response,\n\t                user_input=user_input,\n\t                context_results=context_results,\n\t                **kwargs,\n\t            )\n\t            return_response = \"\"\n\t            if \"AUTONOMOUS_EXECUTION\" in self.agent.AGENT_CONFIG[\"settings\"]:\n\t                autonomous = (\n\t                    True\n", "                    if self.agent.AGENT_CONFIG[\"settings\"][\"AUTONOMOUS_EXECUTION\"]\n\t                    == True\n\t                    else False\n\t                )\n\t            else:\n\t                autonomous = False\n\t            if autonomous == True:\n\t                try:\n\t                    self.response = json.loads(self.response)\n\t                    if \"response\" in self.response:\n", "                        return_response = self.response[\"response\"]\n\t                    if \"commands\" in self.response:\n\t                        if self.response[\"commands\"] != {}:\n\t                            return_response += (\n\t                                f\"\\n\\nCommands Executed:\\n{self.response['commands']}\"\n\t                            )\n\t                    if execution_response:\n\t                        return_response += (\n\t                            f\"\\n\\nCommand Execution Response:\\n{execution_response}\"\n\t                        )\n", "                except:\n\t                    return_response = self.response\n\t            else:\n\t                return_response = f\"{self.response}\\n\\n{execution_response}\"\n\t            self.response = return_response\n\t        logging.info(f\"Response: {self.response}\")\n\t        if self.response != \"\" and self.response != None:\n\t            if disable_memory != True:\n\t                try:\n\t                    await self.memories.store_result(\n", "                        input=user_input, result=self.response\n\t                    )\n\t                except:\n\t                    pass\n\t            if user_input != \"\":\n\t                log_interaction(\n\t                    agent_name=self.agent_name,\n\t                    conversation_name=conversation_name,\n\t                    role=\"USER\",\n\t                    message=user_input,\n", "                )\n\t            else:\n\t                log_interaction(\n\t                    agent_name=self.agent_name,\n\t                    conversation_name=conversation_name,\n\t                    role=\"USER\",\n\t                    message=formatted_prompt,\n\t                )\n\t            log_interaction(\n\t                agent_name=self.agent_name,\n", "                conversation_name=conversation_name,\n\t                role=self.agent_name,\n\t                message=self.response,\n\t            )\n\t        if shots > 1:\n\t            responses = [self.response]\n\t            for shot in range(shots - 1):\n\t                shot_response = ApiClient.prompt_agent(\n\t                    agent_name=self.agent_name,\n\t                    prompt_name=prompt,\n", "                    prompt_args={\n\t                        \"chain_name\": chain_name,\n\t                        \"step_number\": step_number,\n\t                        \"user_input\": user_input,\n\t                        \"context_results\": context_results,\n\t                        \"conversation_name\": conversation_name,\n\t                        **kwargs,\n\t                    },\n\t                )\n\t                time.sleep(1)\n", "                responses.append(shot_response)\n\t            return \"\\n\".join(\n\t                [\n\t                    f\"Response {shot + 1}:\\n{response}\"\n\t                    for shot, response in enumerate(responses)\n\t                ]\n\t            )\n\t        return self.response\n\t    # Worker Sub-Agents\n\t    async def validation_agent(\n", "        self, user_input, execution_response, context_results, **kwargs\n\t    ):\n\t        try:\n\t            pattern = regex.compile(r\"\\{(?:[^{}]|(?R))*\\}\")\n\t            cleaned_json = pattern.findall(execution_response)\n\t            if len(cleaned_json) == 0:\n\t                return {}\n\t            if isinstance(cleaned_json, list):\n\t                cleaned_json = cleaned_json[0]\n\t            response = json.loads(cleaned_json)\n", "            return response\n\t        except:\n\t            logging.info(\"INVALID JSON RESPONSE\")\n\t            logging.info(execution_response)\n\t            logging.info(\"... Trying again.\")\n\t            if context_results != 0:\n\t                context_results = context_results - 1\n\t            else:\n\t                context_results = 0\n\t            execution_response = ApiClient.prompt_agent(\n", "                agent_name=self.agent_name,\n\t                prompt_name=\"JSONFormatter\",\n\t                prompt_args={\n\t                    \"user_input\": user_input,\n\t                    \"context_results\": context_results,\n\t                    **kwargs,\n\t                },\n\t            )\n\t            return await self.validation_agent(\n\t                user_input=user_input,\n", "                execution_response=execution_response,\n\t                context_results=context_results,\n\t                **kwargs,\n\t            )\n\t    def create_command_suggestion_chain(self, agent_name, command_name, command_args):\n\t        chains = ApiClient.get_chains()\n\t        chain_name = f\"{agent_name} Command Suggestions\"\n\t        if chain_name in chains:\n\t            step = (\n\t                int(ApiClient.get_chain(chain_name=chain_name)[\"steps\"][-1][\"step\"]) + 1\n", "            )\n\t        else:\n\t            ApiClient.add_chain(chain_name=chain_name)\n\t            step = 1\n\t        ApiClient.add_step(\n\t            chain_name=chain_name,\n\t            agent_name=agent_name,\n\t            step_number=step,\n\t            prompt_type=\"Command\",\n\t            prompt={\n", "                \"command_name\": command_name,\n\t                **command_args,\n\t            },\n\t        )\n\t        return f\"The command has been added to a chain called '{agent_name} Command Suggestions' for you to review and execute manually.\"\n\t    async def execution_agent(\n\t        self, execution_response, user_input, context_results, **kwargs\n\t    ):\n\t        validated_response = await self.validation_agent(\n\t            user_input=user_input,\n", "            execution_response=execution_response,\n\t            context_results=context_results,\n\t            **kwargs,\n\t        )\n\t        if \"commands\" in validated_response:\n\t            for command_name, command_args in validated_response[\"commands\"].items():\n\t                # Search for the command in the available_commands list, and if found, use the command's name attribute for execution\n\t                if command_name is not None:\n\t                    for available_command in self.agent.available_commands:\n\t                        if command_name == available_command[\"friendly_name\"]:\n", "                            # Check if the command is a valid command in the self.avent.available_commands list\n\t                            try:\n\t                                if bool(self.agent.AUTONOMOUS_EXECUTION) == True:\n\t                                    command_output = await self.agent.execute(\n\t                                        command_name=command_name,\n\t                                        command_args=command_args,\n\t                                    )\n\t                                else:\n\t                                    command_output = (\n\t                                        self.create_command_suggestion_chain(\n", "                                            agent_name=self.agent_name,\n\t                                            command_name=command_name,\n\t                                            command_args=command_args,\n\t                                        )\n\t                                    )\n\t                            except Exception as e:\n\t                                logging.info(\"Command validation failed, retrying...\")\n\t                                validate_command = ApiClient.prompt_agent(\n\t                                    agent_name=self.agent_name,\n\t                                    prompt_name=\"ValidationFailed\",\n", "                                    prompt_args={\n\t                                        \"command_name\": command_name,\n\t                                        \"command_args\": command_args,\n\t                                        \"command_output\": e,\n\t                                        \"user_input\": user_input,\n\t                                        \"context_results\": context_results,\n\t                                        **kwargs,\n\t                                    },\n\t                                )\n\t                                return await self.execution_agent(\n", "                                    execution_response=validate_command,\n\t                                    user_input=user_input,\n\t                                    context_results=context_results,\n\t                                    **kwargs,\n\t                                )\n\t                            logging.info(\n\t                                f\"Command {command_name} executed successfully with args {command_args}. Command Output: {command_output}\"\n\t                            )\n\t                            response = f\"\\nExecuted Command:{command_name} with args {command_args}.\\nCommand Output: {command_output}\\n\"\n\t                            return response\n", "                else:\n\t                    if command_name == \"None.\":\n\t                        return \"\\nNo commands were executed.\\n\"\n\t                    else:\n\t                        return f\"\\Command not recognized: `{command_name}`.\"\n\t        else:\n\t            return \"\\nNo commands were executed.\\n\"\n"]}
{"filename": "agixt/Providers.py", "chunked_list": ["import importlib\n\timport subprocess\n\timport pkg_resources\n\timport glob\n\timport os\n\timport inspect\n\tdef get_providers():\n\t    providers = []\n\t    for provider in glob.glob(\"providers/*.py\"):\n\t        if \"__init__.py\" not in provider:\n", "            providers.append(os.path.splitext(os.path.basename(provider))[0])\n\t    return providers\n\tdef get_provider_options(provider_name):\n\t    provider_name = provider_name.lower()\n\t    module = importlib.import_module(f\"providers.{provider_name}\")\n\t    provider_class = getattr(module, f\"{provider_name.capitalize()}Provider\")\n\t    signature = inspect.signature(provider_class.__init__)\n\t    options = {\n\t        name: param.default if param.default is not inspect.Parameter.empty else None\n\t        for name, param in signature.parameters.items()\n", "        if name != \"self\" and name != \"kwargs\"\n\t    }\n\t    options[\"provider\"] = provider_name\n\t    return options\n\tclass Providers:\n\t    def __init__(self, name, **kwargs):\n\t        try:\n\t            module = importlib.import_module(f\"providers.{name}\")\n\t            provider_class = getattr(module, f\"{name.capitalize()}Provider\")\n\t            self.instance = provider_class(**kwargs)\n", "            # Install the requirements if any\n\t            self.install_requirements()\n\t        except (ModuleNotFoundError, AttributeError) as e:\n\t            raise AttributeError(f\"module {__name__} has no attribute {name}\") from e\n\t    def __getattr__(self, attr):\n\t        return getattr(self.instance, attr)\n\t    def get_providers(self):\n\t        providers = []\n\t        for provider in glob.glob(\"providers/*.py\"):\n\t            if \"__init__.py\" not in provider:\n", "                providers.append(os.path.splitext(os.path.basename(provider))[0])\n\t        return providers\n\t    def install_requirements(self):\n\t        requirements = getattr(self.instance, \"requirements\", [])\n\t        installed_packages = {pkg.key: pkg.version for pkg in pkg_resources.working_set}\n\t        for requirement in requirements:\n\t            if requirement.lower() not in installed_packages:\n\t                subprocess.run([\"pip\", \"install\", requirement], check=True)\n\tdef __getattr__(name):\n\t    return Providers(name)\n"]}
{"filename": "agixt/Extensions.py", "chunked_list": ["import importlib\n\timport os\n\timport glob\n\tfrom inspect import signature, Parameter\n\timport logging\n\timport inspect\n\tclass Extensions:\n\t    def __init__(self, agent_config=None, load_commands_flag: bool = True):\n\t        self.agent_config = agent_config\n\t        if load_commands_flag:\n", "            self.commands = self.load_commands()\n\t        else:\n\t            self.commands = []\n\t        if agent_config != None:\n\t            if \"commands\" not in self.agent_config:\n\t                self.agent_config[\"commands\"] = {}\n\t            if self.agent_config[\"commands\"] == None:\n\t                self.agent_config[\"commands\"] = {}\n\t            self.available_commands = self.get_available_commands()\n\t    def get_available_commands(self):\n", "        if self.commands == []:\n\t            return []\n\t        available_commands = []\n\t        for command in self.commands:\n\t            friendly_name, command_module, command_name, command_args = command\n\t            if (\n\t                \"commands\" in self.agent_config\n\t                and friendly_name in self.agent_config[\"commands\"]\n\t            ):\n\t                if (\n", "                    self.agent_config[\"commands\"][friendly_name] == \"true\"\n\t                    or self.agent_config[\"commands\"][friendly_name] == True\n\t                ):\n\t                    # Add command to list of commands to return\n\t                    available_commands.append(\n\t                        {\n\t                            \"friendly_name\": friendly_name,\n\t                            \"name\": command_name,\n\t                            \"args\": command_args,\n\t                            \"enabled\": True,\n", "                        }\n\t                    )\n\t        return available_commands\n\t    def get_enabled_commands(self):\n\t        enabled_commands = []\n\t        for command in self.available_commands:\n\t            if command[\"enabled\"]:\n\t                enabled_commands.append(command)\n\t        return enabled_commands\n\t    def get_command_args(self, command_name: str):\n", "        extensions = self.get_extensions()\n\t        for extension in extensions:\n\t            for command in extension[\"commands\"]:\n\t                if command[\"friendly_name\"] == command_name:\n\t                    return command[\"command_args\"]\n\t        return {}\n\t    def load_commands(self):\n\t        try:\n\t            settings = self.agent_config[\"settings\"]\n\t        except:\n", "            settings = {}\n\t        commands = []\n\t        command_files = glob.glob(\"extensions/*.py\")\n\t        for command_file in command_files:\n\t            module_name = os.path.splitext(os.path.basename(command_file))[0]\n\t            module = importlib.import_module(f\"extensions.{module_name}\")\n\t            if issubclass(getattr(module, module_name), Extensions):\n\t                command_class = getattr(module, module_name)(**settings)\n\t                if hasattr(command_class, \"commands\"):\n\t                    for (\n", "                        command_name,\n\t                        command_function,\n\t                    ) in command_class.commands.items():\n\t                        params = self.get_command_params(command_function)\n\t                        # Store the module along with the function name\n\t                        commands.append(\n\t                            (\n\t                                command_name,\n\t                                getattr(module, module_name),\n\t                                command_function.__name__,\n", "                                params,\n\t                            )\n\t                        )\n\t        # Return the commands list\n\t        logging.debug(f\"loaded commands: {commands}\")\n\t        return commands\n\t    def get_extension_settings(self):\n\t        settings = {}\n\t        command_files = glob.glob(\"extensions/*.py\")\n\t        for command_file in command_files:\n", "            module_name = os.path.splitext(os.path.basename(command_file))[0]\n\t            module = importlib.import_module(f\"extensions.{module_name}\")\n\t            if issubclass(getattr(module, module_name), Extensions):\n\t                command_class = getattr(module, module_name)()\n\t                params = self.get_command_params(command_class.__init__)\n\t                # Remove self and kwargs from params\n\t                if \"self\" in params:\n\t                    del params[\"self\"]\n\t                if \"kwargs\" in params:\n\t                    del params[\"kwargs\"]\n", "                if params != {}:\n\t                    settings[module_name] = params\n\t        return settings\n\t    def find_command(self, command_name: str):\n\t        for name, module, function_name, params in self.commands:\n\t            if name == command_name:\n\t                command_function = getattr(module, function_name)\n\t                return command_function, module, params  # Updated return statement\n\t        return None, None, None  # Updated return statement\n\t    def get_commands_list(self):\n", "        self.commands = self.load_commands()\n\t        commands_list = [command_name for command_name, _, _ in self.commands]\n\t        return commands_list\n\t    async def execute_command(self, command_name: str, command_args: dict = None):\n\t        command_function, module, params = self.find_command(command_name=command_name)\n\t        logging.info(\n\t            f\"Executing command: {command_name} with args: {command_args}. Command Function: {command_function}\"\n\t        )\n\t        if command_function is None:\n\t            logging.error(f\"Command {command_name} not found\")\n", "            return False\n\t        for param in params:\n\t            if param not in command_args:\n\t                if param != \"self\" and param != \"kwargs\":\n\t                    command_args[param] = None\n\t        args = command_args.copy()\n\t        for param in command_args:\n\t            if param not in params:\n\t                del args[param]\n\t        try:\n", "            output = await getattr(module(), command_function.__name__)(**args)\n\t        except Exception as e:\n\t            output = f\"Error: {str(e)}\"\n\t        logging.info(f\"Command Output: {output}\")\n\t        return output\n\t    def get_command_params(self, func):\n\t        params = {}\n\t        sig = signature(func)\n\t        for name, param in sig.parameters.items():\n\t            if name == \"self\":\n", "                continue\n\t            if param.default == Parameter.empty:\n\t                params[name] = \"\"\n\t            else:\n\t                params[name] = param.default\n\t        return params\n\t    def get_extensions(self):\n\t        commands = []\n\t        command_files = glob.glob(\"extensions/*.py\")\n\t        for command_file in command_files:\n", "            module_name = os.path.splitext(os.path.basename(command_file))[0]\n\t            module = importlib.import_module(f\"extensions.{module_name}\")\n\t            command_class = getattr(module, module_name.lower())()\n\t            extension_name = command_file.split(\"/\")[-1].split(\".\")[0]\n\t            extension_name = extension_name.replace(\"_\", \" \").title()\n\t            constructor = inspect.signature(command_class.__init__)\n\t            params = constructor.parameters\n\t            extension_settings = [\n\t                name for name in params if name != \"self\" and name != \"kwargs\"\n\t            ]\n", "            extension_commands = []\n\t            if hasattr(command_class, \"commands\"):\n\t                try:\n\t                    for (\n\t                        command_name,\n\t                        command_function,\n\t                    ) in command_class.commands.items():\n\t                        params = self.get_command_params(command_function)\n\t                        extension_commands.append(\n\t                            {\n", "                                \"friendly_name\": command_name,\n\t                                \"command_name\": command_function.__name__,\n\t                                \"command_args\": params,\n\t                            }\n\t                        )\n\t                except Exception as e:\n\t                    logging.error(f\"Error getting commands: {e}\")\n\t            commands.append(\n\t                {\n\t                    \"extension_name\": extension_name,\n", "                    \"description\": extension_name,\n\t                    \"settings\": extension_settings,\n\t                    \"commands\": extension_commands,\n\t                }\n\t            )\n\t        return commands\n"]}
{"filename": "agixt/__init__.py", "chunked_list": ["from agixtsdk import AGiXTSDK\n\timport os\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tApiClient = AGiXTSDK(\n\t    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n\t)\n"]}
{"filename": "agixt/Embedding.py", "chunked_list": ["import requests\n\timport inspect\n\tfrom chromadb.utils import embedding_functions\n\tfrom chromadb.api.types import Documents, EmbeddingFunction, Embeddings\n\tfrom semantic_kernel.connectors.ai.hugging_face import HuggingFaceTextEmbedding\n\tfrom semantic_kernel.connectors.ai.open_ai import (\n\t    AzureTextEmbedding,\n\t    OpenAITextEmbedding,\n\t)\n\timport logging\n", "import spacy\n\tclass LlamacppEmbeddingFunction(EmbeddingFunction):\n\t    def __init__(self, api_host: str):\n\t        self._api_host = api_host\n\t        self._session = requests.Session()\n\t    def __call__(self, texts: Documents) -> Embeddings:\n\t        response = self._session.post(\n\t            self._api_url, json={\"content\": texts, \"threads\": 5}\n\t        ).json()\n\t        if \"data\" in response:\n", "            if \"embedding\" in response[\"data\"]:\n\t                return response[\"data\"][\"embedding\"]\n\t        return {}\n\tclass Embedding:\n\t    def __init__(self, AGENT_CONFIG=None):\n\t        self.AGENT_CONFIG = AGENT_CONFIG\n\t    async def get_embedder(self):\n\t        try:\n\t            embedder = self.AGENT_CONFIG[\"settings\"][\"embedder\"]\n\t            embed, chunk_size = await self.__getattribute__(embedder)()\n", "        except:\n\t            embed, chunk_size = await self.default()\n\t            logging.info(\"Embedder not found, using default embedder\")\n\t        return embed, chunk_size\n\t    async def embed_text(self, text):\n\t        embed, chunk_size = await self.get_embedder()\n\t        return await embed(text)\n\t    async def default(self):\n\t        chunk_size = 128\n\t        embed = HuggingFaceTextEmbedding(\n", "            model_id=\"all-mpnet-base-v2\", log=logging\n\t        ).generate_embeddings_async\n\t        return embed, chunk_size\n\t    async def large_local(self):\n\t        chunk_size = 500\n\t        embed = HuggingFaceTextEmbedding(\n\t            model_id=\"gtr-t5-large\", log=logging\n\t        ).generate_embeddings_async\n\t        return embed, chunk_size\n\t    async def azure(self):\n", "        chunk_size = 1000\n\t        embed = AzureTextEmbedding(\n\t            deployment_name=self.AGENT_CONFIG[\"settings\"][\"AZURE_DEPLOYMENT_NAME\"],\n\t            endpoint=self.AGENT_CONFIG[\"settings\"][\"AZURE_OPENAI_ENDPOINT\"],\n\t            api_key=self.AGENT_CONFIG[\"settings\"][\"AZURE_API_KEY\"],\n\t            logger=logging,\n\t        ).generate_embeddings_async\n\t        return embed, chunk_size\n\t    async def openai(self):\n\t        chunk_size = 1000\n", "        if \"API_URI\" in self.AGENT_CONFIG[\"settings\"]:\n\t            if self.AGENT_CONFIG[\"settings\"][\"API_URI\"] != \"\":\n\t                api_base = self.AGENT_CONFIG[\"settings\"][\"API_URI\"]\n\t            else:\n\t                api_base = None\n\t        else:\n\t            api_base = None\n\t        embed = OpenAITextEmbedding(\n\t            model_id=\"text-embedding-ada-002\",\n\t            api_key=self.AGENT_CONFIG[\"settings\"][\"OPENAI_API_KEY\"],\n", "            endpoint=api_base,\n\t            log=logging,\n\t        ).generate_embeddings_async\n\t        return embed, chunk_size\n\t    async def google_palm(self):\n\t        chunk_size = 1000\n\t        embed = embedding_functions.GooglePalmEmbeddingFunction(\n\t            api_key=self.AGENT_CONFIG[\"settings\"][\"GOOGLE_API_KEY\"],\n\t        )\n\t        return embed, chunk_size\n", "    async def google_vertex(self):\n\t        chunk_size = 1000\n\t        embed = embedding_functions.GoogleVertexEmbeddingFunction(\n\t            api_key=self.AGENT_CONFIG[\"settings\"][\"GOOGLE_API_KEY\"],\n\t            project_id=self.AGENT_CONFIG[\"settings\"][\"GOOGLE_PROJECT_ID\"],\n\t        )\n\t        return embed, chunk_size\n\t    async def cohere(self):\n\t        chunk_size = 500\n\t        embed = embedding_functions.CohereEmbeddingFunction(\n", "            api_key=self.AGENT_CONFIG[\"settings\"][\"COHERE_API_KEY\"],\n\t        )\n\t        return embed, chunk_size\n\t    async def llamacpp(self):\n\t        chunk_size = 250\n\t        embed = LlamacppEmbeddingFunction(\n\t            model_name=self.AGENT_CONFIG[\"settings\"][\"EMBEDDING_URI\"],\n\t        )\n\t        return embed, chunk_size\n\tdef get_embedding_providers():\n", "    return [\n\t        func\n\t        for func, _ in inspect.getmembers(Embedding, predicate=inspect.isfunction)\n\t        if not func.startswith(\"__\")\n\t    ]\n\tdef nlp(text):\n\t    try:\n\t        sp = spacy.load(\"en_core_web_sm\")\n\t    except:\n\t        spacy.cli.download(\"en_core_web_sm\")\n", "        sp = spacy.load(\"en_core_web_sm\")\n\t    sp.max_length = 99999999999999999999999\n\t    return sp(text)\n\tdef get_tokens(text):\n\t    return len(nlp(text))\n"]}
{"filename": "agixt/Memories.py", "chunked_list": ["from typing import List\n\timport os\n\tfrom hashlib import sha256\n\tfrom Embedding import Embedding, get_tokens, nlp\n\tfrom datetime import datetime\n\tfrom collections import Counter\n\timport pandas as pd\n\timport docx2txt\n\timport pdfplumber\n\tfrom playwright.async_api import async_playwright\n", "from semantic_kernel.connectors.memory.chroma import ChromaMemoryStore\n\tfrom semantic_kernel.memory.memory_record import MemoryRecord\n\tfrom chromadb.config import Settings\n\tfrom bs4 import BeautifulSoup\n\timport logging\n\timport asyncio\n\timport sys\n\tif sys.platform == \"win32\":\n\t    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())\n\tclass Memories:\n", "    def __init__(self, agent_name: str = \"AGiXT\", agent_config=None):\n\t        self.agent_name = agent_name\n\t        self.agent_config = agent_config\n\t        self.chroma_client = None\n\t        self.collection = None\n\t        self.chunk_size = 128\n\t        memories_dir = os.path.join(os.getcwd(), \"agents\", self.agent_name, \"memories\")\n\t        self.chroma_client = ChromaMemoryStore(\n\t            persist_directory=memories_dir,\n\t            client_settings=Settings(\n", "                chroma_db_impl=\"chromadb.db.duckdb.PersistentDuckDB\",\n\t                persist_directory=memories_dir,\n\t                anonymized_telemetry=False,\n\t            ),\n\t        )\n\t    async def get_embedder(self):\n\t        embedder, chunk_size = await Embedding(\n\t            AGENT_CONFIG=self.agent_config\n\t        ).get_embedder()\n\t        return embedder, chunk_size\n", "    async def get_collection(self):\n\t        try:\n\t            memories_exist = await self.chroma_client.does_collection_exist_async(\n\t                \"memories\"\n\t            )\n\t            if not memories_exist:\n\t                await self.chroma_client.create_collection_async(\n\t                    collection_name=\"memories\"\n\t                )\n\t                memories = await self.chroma_client.get_collection_async(\n", "                    collection_name=\"memories\"\n\t                )\n\t            else:\n\t                memories = await self.chroma_client.get_collection_async(\n\t                    collection_name=\"memories\"\n\t                )\n\t            return memories\n\t        except Exception as e:\n\t            raise RuntimeError(f\"Unable to initialize chroma client: {e}\")\n\t    async def store_result(\n", "        self, input: str, result: str, external_source_name: str = None\n\t    ):\n\t        if result:\n\t            embedder, chunk_size = await self.get_embedder()\n\t            collection = await self.get_collection()\n\t            if not isinstance(result, str):\n\t                result = str(result)\n\t            chunks = await self.chunk_content(content=result, chunk_size=chunk_size)\n\t            for chunk in chunks:\n\t                record = MemoryRecord(\n", "                    is_reference=False,\n\t                    id=sha256(\n\t                        (chunk + datetime.now().isoformat()).encode()\n\t                    ).hexdigest(),\n\t                    text=chunk,\n\t                    timestamp=datetime.now().isoformat(),\n\t                    description=input,\n\t                    external_source_name=external_source_name,  # URL or File path\n\t                    embedding=await embedder(chunk),\n\t                    additional_metadata=chunk,\n", "                )\n\t                try:\n\t                    await self.chroma_client.upsert_async(\n\t                        collection_name=\"memories\",\n\t                        record=record,\n\t                    )\n\t                except Exception as e:\n\t                    logging.info(f\"Failed to store memory: {e}\")\n\t            self.chroma_client._client.persist()\n\t    async def context_agent(self, query: str, top_results_num: int) -> List[str]:\n", "        embedder, chunk_size = await self.get_embedder()\n\t        collection = await self.get_collection()\n\t        if collection == None:\n\t            return []\n\t        embed = await Embedding(AGENT_CONFIG=self.agent_config).embed_text(text=query)\n\t        try:\n\t            results = await self.chroma_client.get_nearest_matches_async(\n\t                collection_name=\"memories\",\n\t                embedding=embed,\n\t                limit=top_results_num,\n", "                min_relevance_score=0.0,\n\t            )\n\t        except:\n\t            return \"\"\n\t        context = []\n\t        for memory, score in results:\n\t            context.append(memory._text)\n\t        trimmed_context = []\n\t        total_tokens = 0\n\t        for item in context:\n", "            item_tokens = get_tokens(item)\n\t            if total_tokens + item_tokens <= chunk_size:\n\t                trimmed_context.append(item)\n\t                total_tokens += item_tokens\n\t            else:\n\t                break\n\t        logging.info(f\"Context Injected: {trimmed_context}\")\n\t        context_str = \"\\n\".join(trimmed_context)\n\t        response = (\n\t            f\"The user's input causes you remember these things:\\n {context_str} \\n\\n\"\n", "        )\n\t        return response\n\t    def score_chunk(self, chunk: str, keywords: set):\n\t        \"\"\"Score a chunk based on the number of query keywords it contains.\"\"\"\n\t        chunk_counter = Counter(chunk.split())\n\t        score = sum(chunk_counter[keyword] for keyword in keywords)\n\t        return score\n\t    async def chunk_content(\n\t        self, content: str, chunk_size: int, overlap: int = 2\n\t    ) -> List[str]:\n", "        doc = nlp(content)\n\t        sentences = list(doc.sents)\n\t        content_chunks = []\n\t        chunk = []\n\t        chunk_len = 0\n\t        keywords = [\n\t            token.text for token in doc if token.pos_ in {\"NOUN\", \"PROPN\", \"VERB\"}\n\t        ]\n\t        for i, sentence in enumerate(sentences):\n\t            sentence_tokens = len(sentence)\n", "            if chunk_len + sentence_tokens > chunk_size and chunk:\n\t                chunk_text = \" \".join(token.text for token in chunk)\n\t                content_chunks.append(\n\t                    (self.score_chunk(chunk_text, keywords), chunk_text)\n\t                )\n\t                chunk = list(sentences[i - overlap : i]) if i - overlap >= 0 else []\n\t                chunk_len = sum(len(s) for s in chunk)\n\t            chunk.extend(sentence)\n\t            chunk_len += sentence_tokens\n\t        if chunk:\n", "            chunk_text = \" \".join(token.text for token in chunk)\n\t            content_chunks.append((self.score_chunk(chunk_text, keywords), chunk_text))\n\t        # Sort the chunks by their score in descending order before returning them\n\t        content_chunks.sort(key=lambda x: x[0], reverse=True)\n\t        return [chunk_text for score, chunk_text in content_chunks]\n\t    async def read_file(self, file_path: str):\n\t        base_path = os.path.join(os.getcwd(), \"WORKSPACE\")\n\t        file_path = os.path.normpath(os.path.join(base_path, file_path))\n\t        if not file_path.startswith(base_path):\n\t            raise Exception(\"Path given not allowed\")\n", "        try:\n\t            # If file extension is pdf, convert to text\n\t            if file_path.endswith(\".pdf\"):\n\t                with pdfplumber.open(file_path) as pdf:\n\t                    content = \"\\n\".join([page.extract_text() for page in pdf.pages])\n\t            # If file extension is xls, convert to csv\n\t            elif file_path.endswith(\".xls\") or file_path.endswith(\".xlsx\"):\n\t                content = pd.read_excel(file_path).to_csv()\n\t            # If file extension is doc, convert to text\n\t            elif file_path.endswith(\".doc\") or file_path.endswith(\".docx\"):\n", "                content = docx2txt.process(file_path)\n\t            # TODO: If file is an image, classify it in text.\n\t            # Otherwise just read the file\n\t            else:\n\t                with open(file_path, \"r\") as f:\n\t                    content = f.read()\n\t            await self.store_result(\n\t                input=file_path, result=content, external_source_name=file_path\n\t            )\n\t            return True\n", "        except:\n\t            return False\n\t    async def read_website(self, url):\n\t        # try:\n\t        async with async_playwright() as p:\n\t            browser = await p.chromium.launch()\n\t            context = await browser.new_context()\n\t            page = await context.new_page()\n\t            await page.goto(url)\n\t            content = await page.content()\n", "            # Scrape links and their titles\n\t            links = await page.query_selector_all(\"a\")\n\t            link_list = []\n\t            for link in links:\n\t                title = await page.evaluate(\"(link) => link.textContent\", link)\n\t                href = await page.evaluate(\"(link) => link.href\", link)\n\t                link_list.append((title, href))\n\t            await browser.close()\n\t            soup = BeautifulSoup(content, \"html.parser\")\n\t            text_content = soup.get_text()\n", "            text_content = \" \".join(text_content.split())\n\t            if text_content:\n\t                await self.store_result(\n\t                    input=url, result=text_content, external_source_name=url\n\t                )\n\t            return text_content, link_list\n\t        # except:\n\t        #    return None, None\n"]}
{"filename": "agixt/DBConnection.py", "chunked_list": ["import os\n\timport uuid\n\tfrom sqlalchemy import (\n\t    create_engine,\n\t    Column,\n\t    Text,\n\t    String,\n\t    Integer,\n\t    ForeignKey,\n\t    DateTime,\n", "    Boolean,\n\t)\n\tfrom sqlalchemy.orm import sessionmaker, relationship, declarative_base\n\tfrom sqlalchemy.dialects.postgresql import UUID\n\tfrom sqlalchemy.sql import text\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tusername = os.getenv(\"POSTGRES_USER\", \"postgres\")\n\tpassword = os.getenv(\"POSTGRES_PASSWORD\", \"postgres\")\n\tserver = os.getenv(\"POSTGRES_SERVER\", \"localhost\")\n", "port = os.getenv(\"POSTGRES_PORT\", \"5432\")\n\tdatabase_name = os.getenv(\"POSTGRES_DB\", \"postgres\")\n\tdb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\n\tBase = declarative_base()\n\tif db_connected:\n\t    try:\n\t        engine = create_engine(\n\t            f\"postgresql://{username}:{password}@{server}:{port}/{database_name}\"\n\t        )\n\t    except Exception as e:\n", "        print(f\"Error connecting to database: {e}\")\n\t    Session = sessionmaker(bind=engine)\n\t    session = Session()\n\t    connection = engine.connect()\n\telse:\n\t    session = None\n\tclass Provider(Base):\n\t    __tablename__ = \"provider\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    name = Column(Text, nullable=False)\n", "    provider_settings = relationship(\"ProviderSetting\", backref=\"provider\")\n\tclass ProviderSetting(Base):\n\t    __tablename__ = \"provider_setting\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    provider_id = Column(UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=False)\n\t    name = Column(Text, nullable=False)\n\t    value = Column(\n\t        Text\n\t    )  # Add the 'value' column without the 'nullable=False' constraint\n\tclass AgentProviderSetting(Base):\n", "    __tablename__ = \"agent_provider_setting\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    provider_setting_id = Column(\n\t        UUID(as_uuid=True), ForeignKey(\"provider_setting.id\"), nullable=False\n\t    )\n\t    agent_provider_id = Column(\n\t        UUID(as_uuid=True), ForeignKey(\"agent_provider.id\"), nullable=False\n\t    )\n\t    value = Column(Text, nullable=False)\n\tclass AgentProvider(Base):\n", "    __tablename__ = \"agent_provider\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    provider_id = Column(UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=False)\n\t    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n\t    settings = relationship(\"AgentProviderSetting\", backref=\"agent_provider\")\n\tclass Agent(Base):\n\t    __tablename__ = \"agent\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    name = Column(Text, nullable=False)\n\t    provider_id = Column(\n", "        UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=True, default=None\n\t    )\n\t    settings = relationship(\"AgentSetting\", backref=\"agent\")  # One-to-many relationship\n\tclass Command(Base):\n\t    __tablename__ = \"command\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    name = Column(Text, nullable=False)\n\t    extension_id = Column(UUID(as_uuid=True), ForeignKey(\"extension.id\"))\n\t    extension = relationship(\"Extension\", backref=\"commands\")\n\tclass AgentCommand(Base):\n", "    __tablename__ = \"agent_command\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    command_id = Column(UUID(as_uuid=True), ForeignKey(\"command.id\"), nullable=False)\n\t    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n\t    state = Column(Boolean, nullable=False)\n\t    command = relationship(\"Command\")  # Add this line to define the relationship\n\tclass Conversation(Base):\n\t    __tablename__ = \"conversation\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n", "    name = Column(Text, nullable=False)\n\tclass Message(Base):\n\t    __tablename__ = \"message\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    role = Column(Text, nullable=False)\n\t    content = Column(Text, nullable=False)\n\t    timestamp = Column(DateTime, server_default=text(\"now()\"))\n\t    conversation_id = Column(\n\t        UUID(as_uuid=True), ForeignKey(\"conversation.id\"), nullable=False\n\t    )\n", "class Setting(Base):\n\t    __tablename__ = \"setting\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    name = Column(Text, nullable=False)\n\t    extension_id = Column(UUID(as_uuid=True), ForeignKey(\"extension.id\"))\n\t    value = Column(Text)\n\tclass AgentSetting(Base):\n\t    __tablename__ = \"agent_setting\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n", "    name = Column(String)\n\t    value = Column(String)\n\tclass Chain(Base):\n\t    __tablename__ = \"chain\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    name = Column(Text, nullable=False)\n\t    description = Column(Text, nullable=True)\n\t    steps = relationship(\n\t        \"ChainStep\",\n\t        backref=\"chain\",\n", "        cascade=\"all, delete\",  # Add the cascade option for deleting steps\n\t        passive_deletes=True,\n\t        foreign_keys=\"ChainStep.chain_id\",\n\t    )\n\t    target_steps = relationship(\n\t        \"ChainStep\", backref=\"target_chain\", foreign_keys=\"ChainStep.target_chain_id\"\n\t    )\n\tclass ChainStep(Base):\n\t    __tablename__ = \"chain_step\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n", "    chain_id = Column(\n\t        UUID(as_uuid=True), ForeignKey(\"chain.id\", ondelete=\"CASCADE\"), nullable=False\n\t    )\n\t    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n\t    prompt_type = Column(Text)  # Add the prompt_type field\n\t    prompt = Column(Text)  # Add the prompt field\n\t    target_chain_id = Column(\n\t        UUID(as_uuid=True), ForeignKey(\"chain.id\", ondelete=\"SET NULL\")\n\t    )\n\t    target_command_id = Column(\n", "        UUID(as_uuid=True), ForeignKey(\"command.id\", ondelete=\"SET NULL\")\n\t    )\n\t    target_prompt_id = Column(\n\t        UUID(as_uuid=True), ForeignKey(\"prompt.id\", ondelete=\"SET NULL\")\n\t    )\n\t    step_number = Column(Integer, nullable=False)\n\t    responses = relationship(\n\t        \"ChainStepResponse\", backref=\"chain_step\", cascade=\"all, delete\"\n\t    )\n\t    def add_response(self, content):\n", "        response = ChainStepResponse(content=content, chain_step=self)\n\t        session.add(response)\n\t        session.commit()\n\tclass ChainStepArgument(Base):\n\t    __tablename__ = \"chain_step_argument\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    argument_id = Column(UUID(as_uuid=True), ForeignKey(\"argument.id\"), nullable=False)\n\t    chain_step_id = Column(\n\t        UUID(as_uuid=True),\n\t        ForeignKey(\"chain_step.id\", ondelete=\"CASCADE\"),\n", "        nullable=False,  # Add the ondelete option\n\t    )\n\t    value = Column(Text, nullable=False)\n\tclass ChainStepResponse(Base):\n\t    __tablename__ = \"chain_step_response\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    chain_step_id = Column(\n\t        UUID(as_uuid=True),\n\t        ForeignKey(\"chain_step.id\", ondelete=\"CASCADE\"),\n\t        nullable=False,  # Add the ondelete option\n", "    )\n\t    timestamp = Column(DateTime, server_default=text(\"now()\"))\n\t    content = Column(Text, nullable=False)\n\tclass Extension(Base):\n\t    __tablename__ = \"extension\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    name = Column(Text, nullable=False)\n\t    description = Column(Text, nullable=True, default=\"\")\n\tclass Argument(Base):\n\t    __tablename__ = \"argument\"\n", "    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    prompt_id = Column(UUID(as_uuid=True), ForeignKey(\"prompt.id\"))\n\t    command_id = Column(UUID(as_uuid=True), ForeignKey(\"command.id\"))\n\t    chain_id = Column(UUID(as_uuid=True), ForeignKey(\"chain.id\"))\n\t    name = Column(Text, nullable=False)\n\tclass PromptCategory(Base):\n\t    __tablename__ = \"prompt_category\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    name = Column(Text, nullable=False)\n\t    description = Column(Text, nullable=False)\n", "class Prompt(Base):\n\t    __tablename__ = \"prompt\"\n\t    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n\t    prompt_category_id = Column(\n\t        UUID(as_uuid=True), ForeignKey(\"prompt_category.id\"), nullable=False\n\t    )\n\t    name = Column(Text, nullable=False)\n\t    description = Column(Text, nullable=False)\n\t    content = Column(Text, nullable=False)\n\t    prompt_category = relationship(\"PromptCategory\", backref=\"prompts\")\n", "if __name__ == \"__main__\":\n\t    Base.metadata.create_all(engine)\n"]}
{"filename": "agixt/db/History.py", "chunked_list": ["import os\n\timport yaml\n\tfrom datetime import datetime\n\tfrom DBConnection import (\n\t    Conversation,\n\t    Message,\n\t    Agent,\n\t    session,\n\t)\n\tdef export_conversation(agent_name, conversation_name=None):\n", "    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t    if not agent:\n\t        print(f\"Agent '{agent_name}' not found in the database.\")\n\t        return\n\t    conversation_name = (\n\t        f\"{agent_name} History\" if not conversation_name else conversation_name\n\t    )\n\t    conversation = (\n\t        session.query(Conversation)\n\t        .filter(\n", "            Conversation.agent_id == agent.id,\n\t            Conversation.name == conversation_name,\n\t        )\n\t        .first()\n\t    )\n\t    if not conversation:\n\t        print(f\"No conversation found for agent '{agent_name}'.\")\n\t        return\n\t    messages = (\n\t        session.query(Message).filter(Message.conversation_id == conversation.id).all()\n", "    )\n\t    history = {\"interactions\": []}\n\t    for message in messages:\n\t        interaction = {\n\t            \"role\": message.role,\n\t            \"message\": message.content,\n\t            \"timestamp\": message.timestamp,\n\t        }\n\t        history[\"interactions\"].append(interaction)\n\t    agent_dir = os.path.join(\"agents\", agent_name)\n", "    os.makedirs(agent_dir, exist_ok=True)\n\t    history_file = os.path.join(agent_dir, \"history.yaml\")\n\t    with open(history_file, \"w\") as file:\n\t        yaml.dump(history, file)\n\t    print(f\"Exported conversation for agent '{agent_name}' to {history_file}.\")\n\tdef get_conversations(agent_name):\n\t    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t    if not agent:\n\t        print(f\"Agent '{agent_name}' not found in the database.\")\n\t        return\n", "    conversations = (\n\t        session.query(Conversation)\n\t        .filter(\n\t            Conversation.agent_id == agent.id,\n\t        )\n\t        .all()\n\t    )\n\t    return [conversation.name for conversation in conversations]\n\tdef get_conversation(agent_name, conversation_name=None, limit=100, page=1):\n\t    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n", "    if not agent:\n\t        print(f\"Agent '{agent_name}' not found in the database.\")\n\t        return\n\t    if not conversation_name:\n\t        conversation_name = f\"{agent_name} History\"\n\t    conversation = (\n\t        session.query(Conversation)\n\t        .filter(\n\t            Conversation.agent_id == agent.id,\n\t            Conversation.name == conversation_name,\n", "        )\n\t        .first()\n\t    )\n\t    if not conversation:\n\t        print(f\"No conversation found for agent '{agent_name}'.\")\n\t        return\n\t    messages = (\n\t        session.query(Message).filter(Message.conversation_id == conversation.id).all()\n\t    )\n\t    return_messages = []\n", "    for message in messages:\n\t        msg = {\n\t            \"role\": message.role,\n\t            \"message\": message.content,\n\t            \"timestamp\": message.timestamp,\n\t        }\n\t        return_messages.append(msg)\n\t    return return_messages\n\tdef new_conversation(agent_name, conversation_name):\n\t    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n", "    if not agent:\n\t        print(f\"Agent '{agent_name}' not found in the database.\")\n\t        return\n\t    # Check if the conversation already exists for the agent\n\t    existing_conversation = (\n\t        session.query(Conversation)\n\t        .filter(\n\t            Conversation.agent_id == agent.id,\n\t            Conversation.name == conversation_name,\n\t        )\n", "        .first()\n\t    )\n\t    if existing_conversation:\n\t        print(\n\t            f\"Conversation '{conversation_name}' already exists for agent '{agent_name}'.\"\n\t        )\n\t        return\n\t    # Create a new conversation\n\t    conversation = Conversation(agent_id=agent.id, name=conversation_name)\n\t    session.add(conversation)\n", "    session.commit()\n\t    print(\n\t        f\"Created a new conversation: '{conversation_name}' for agent '{agent_name}'.\"\n\t    )\n\tdef log_interaction(agent_name, conversation_name, role, message):\n\t    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t    if not agent:\n\t        print(f\"Agent '{agent_name}' not found in the database.\")\n\t        return\n\t    conversation = (\n", "        session.query(Conversation)\n\t        .filter(\n\t            Conversation.agent_id == agent.id,\n\t            Conversation.name == conversation_name,\n\t        )\n\t        .first()\n\t    )\n\t    if not conversation:\n\t        # Create a new conversation if it doesn't exist\n\t        conversation = Conversation(agent_id=agent.id, name=conversation_name)\n", "        session.add(conversation)\n\t        session.commit()\n\t    timestamp = datetime.now().strftime(\"%B %d, %Y %I:%M %p\")\n\t    new_message = Message(\n\t        role=role,\n\t        content=message,\n\t        timestamp=timestamp,\n\t        conversation_id=conversation.id,\n\t    )\n\t    session.add(new_message)\n", "    session.commit()\n\t    print(f\"Logged interaction: [{timestamp}] {role}: {message}\")\n\tdef delete_history(agent_name, conversation_name=None):\n\t    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t    if not agent:\n\t        print(f\"Agent '{agent_name}' not found in the database.\")\n\t        return\n\t    if not conversation_name:\n\t        conversation_name = f\"{agent_name} History\"\n\t    conversation = (\n", "        session.query(Conversation)\n\t        .filter(\n\t            Conversation.agent_id == agent.id,\n\t            Conversation.name == conversation_name,\n\t        )\n\t        .first()\n\t    )\n\t    if not conversation:\n\t        print(f\"No conversation found for agent '{agent_name}'.\")\n\t        return\n", "    session.query(Message).filter(Message.conversation_id == conversation.id).delete()\n\t    session.query(Conversation).filter(Conversation.id == conversation.id).delete()\n\t    session.commit()\n\t    print(f\"Deleted conversation '{conversation_name}' for agent '{agent_name}'.\")\n\tdef delete_message(agent_name, conversation_name, message_id):\n\t    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t    if not agent:\n\t        print(f\"Agent '{agent_name}' not found in the database.\")\n\t        return\n\t    conversation = (\n", "        session.query(Conversation)\n\t        .filter(\n\t            Conversation.agent_id == agent.id,\n\t            Conversation.name == conversation_name,\n\t        )\n\t        .first()\n\t    )\n\t    if not conversation:\n\t        print(f\"No conversation found for agent '{agent_name}'.\")\n\t        return\n", "    message = (\n\t        session.query(Message)\n\t        .filter(\n\t            Message.conversation_id == conversation.id,\n\t            Message.id == message_id,\n\t        )\n\t        .first()\n\t    )\n\t    if not message:\n\t        print(\n", "            f\"No message found with ID '{message_id}' in conversation '{conversation_name}'.\"\n\t        )\n\t        return\n\t    session.delete(message)\n\t    session.commit()\n\t    print(\n\t        f\"Deleted message with ID '{message_id}' from conversation '{conversation_name}'.\"\n\t    )\n\t# Example usage:\n\t# delete_history(\"Agent1\")\n", "# delete_message(\"Agent1\", \"Agent1 History\", 1)\n"]}
{"filename": "agixt/db/imports.py", "chunked_list": ["import os\n\timport yaml\n\timport json\n\tfrom DBConnection import (\n\t    session,\n\t    Provider,\n\t    ProviderSetting,\n\t    Conversation,\n\t    Message,\n\t    Agent,\n", "    Prompt,\n\t    PromptCategory,\n\t    Argument,\n\t    Agent,\n\t    Argument,\n\t    Prompt,\n\t    Extension,\n\t    Setting,\n\t    Command,\n\t    Agent,\n", "    session,\n\t)\n\tfrom Providers import get_providers, get_provider_options\n\tfrom db.Agent import import_agent_config\n\tdef import_agents():\n\t    agent_folder = \"agents\"\n\t    agents = [\n\t        f.name\n\t        for f in os.scandir(agent_folder)\n\t        if f.is_dir() and not f.name.startswith(\"__\")\n", "    ]\n\t    existing_agents = session.query(Agent).all()\n\t    existing_agent_names = [agent.name for agent in existing_agents]\n\t    for agent_name in agents:\n\t        agent = session.query(Agent).filter_by(name=agent_name).one_or_none()\n\t        if agent:\n\t            print(f\"Updating agent: {agent_name}\")\n\t        else:\n\t            agent = Agent(name=agent_name)\n\t            session.add(agent)\n", "            session.flush()  # Save the agent object to generate an ID\n\t            existing_agent_names.append(agent_name)\n\t            print(f\"Adding agent: {agent_name}\")\n\t        import_agent_config(agent_name)\n\t    session.commit()\n\tdef import_extensions():\n\t    from Extensions import Extensions\n\t    extensions_data = Extensions().get_extensions()\n\t    extension_settings_data = Extensions().get_extension_settings()\n\t    # Get the existing extensions and commands from the database\n", "    existing_extensions = session.query(Extension).all()\n\t    existing_commands = session.query(Command).all()\n\t    # Delete commands that don't exist in the extensions data\n\t    for command in existing_commands:\n\t        command_exists = any(\n\t            extension_data[\"extension_name\"] == command.extension.name\n\t            and any(\n\t                cmd[\"friendly_name\"] == command.name\n\t                for cmd in extension_data[\"commands\"]\n\t            )\n", "            for extension_data in extensions_data\n\t        )\n\t        if not command_exists:\n\t            session.delete(command)\n\t    # Add new extensions and commands, and update existing commands\n\t    for extension_data in extensions_data:\n\t        extension_name = extension_data[\"extension_name\"]\n\t        description = extension_data.get(\n\t            \"description\", \"\"\n\t        )  # Assign an empty string if description is missing\n", "        # Find the existing extension or create a new one\n\t        extension = next(\n\t            (ext for ext in existing_extensions if ext.name == extension_name),\n\t            None,\n\t        )\n\t        if extension is None:\n\t            extension = Extension(name=extension_name, description=description)\n\t            session.add(extension)\n\t            session.flush()\n\t            existing_extensions.append(extension)\n", "        commands = extension_data[\"commands\"]\n\t        for command_data in commands:\n\t            if \"friendly_name\" not in command_data:\n\t                continue\n\t            command_name = command_data[\"friendly_name\"]\n\t            # Find the existing command or create a new one\n\t            command = next(\n\t                (\n\t                    cmd\n\t                    for cmd in existing_commands\n", "                    if cmd.extension_id == extension.id and cmd.name == command_name\n\t                ),\n\t                None,\n\t            )\n\t            if command is None:\n\t                command = Command(\n\t                    extension_id=extension.id,\n\t                    name=command_name,\n\t                )\n\t                session.add(command)\n", "                session.flush()\n\t                existing_commands.append(command)\n\t                print(f\"Adding command: {command_name}\")\n\t            # Add command arguments\n\t            if \"command_args\" in command_data:\n\t                command_args = command_data[\"command_args\"]\n\t                for arg, arg_type in command_args.items():\n\t                    if (\n\t                        session.query(Argument)\n\t                        .filter_by(command_id=command.id, name=arg)\n", "                        .first()\n\t                    ):\n\t                        continue\n\t                    command_arg = Argument(\n\t                        command_id=command.id,\n\t                        name=arg,\n\t                    )\n\t                    session.add(command_arg)\n\t                    print(f\"Adding argument: {arg} to command: {command_name}\")\n\t    session.commit()\n", "    # Add extensions to the database if they don't exist\n\t    for extension_name in extension_settings_data.keys():\n\t        extension = session.query(Extension).filter_by(name=extension_name).first()\n\t        if not extension:\n\t            extension = Extension(name=extension_name)\n\t            session.add(extension)\n\t            session.flush()\n\t            existing_extensions.append(extension)\n\t            print(f\"Adding extension: {extension_name}\")\n\t    session.commit()\n", "    # Migrate extension settings\n\t    for extension_name, settings in extension_settings_data.items():\n\t        extension = session.query(Extension).filter_by(name=extension_name).first()\n\t        if not extension:\n\t            print(f\"Extension '{extension_name}' not found.\")\n\t            continue\n\t        for setting_name, setting_value in settings.items():\n\t            setting = (\n\t                session.query(Setting)\n\t                .filter_by(extension_id=extension.id, name=setting_name)\n", "                .first()\n\t            )\n\t            if setting:\n\t                setting.value = setting_value\n\t                print(\n\t                    f\"Updating setting: {setting_name} for extension: {extension_name}\"\n\t                )\n\t            else:\n\t                setting = Setting(\n\t                    extension_id=extension.id,\n", "                    name=setting_name,\n\t                    value=setting_value,\n\t                )\n\t                session.add(setting)\n\t                print(f\"Adding setting: {setting_name} for extension: {extension_name}\")\n\t    session.commit()\n\tdef import_chains():\n\t    chain_dir = os.path.abspath(\"chains\")\n\t    chain_files = [\n\t        file\n", "        for file in os.listdir(chain_dir)\n\t        if os.path.isfile(os.path.join(chain_dir, file)) and file.endswith(\".json\")\n\t    ]\n\t    if not chain_files:\n\t        print(f\"No JSON files found in chains directory.\")\n\t        return\n\t    from db.Chain import Chain\n\t    chain_importer = Chain()\n\t    for file in chain_files:\n\t        chain_name = os.path.splitext(file)[0]\n", "        file_path = os.path.join(chain_dir, file)\n\t        with open(file_path, \"r\") as f:\n\t            try:\n\t                chain_data = json.load(f)\n\t                result = chain_importer.import_chain(chain_name, chain_data)\n\t                print(result)\n\t            except json.JSONDecodeError as e:\n\t                print(f\"Error importing chain from '{file}': Invalid JSON format.\")\n\t            except Exception as e:\n\t                print(f\"Error importing chain from '{file}': {str(e)}\")\n", "def import_prompts():\n\t    # Add default category if it doesn't exist\n\t    default_category = session.query(PromptCategory).filter_by(name=\"Default\").first()\n\t    if not default_category:\n\t        default_category = PromptCategory(\n\t            name=\"Default\", description=\"Default category\"\n\t        )\n\t        session.add(default_category)\n\t        session.commit()\n\t        print(\"Adding Default prompt category\")\n", "    # Get all prompt files in the specified folder\n\t    for root, dirs, files in os.walk(\"prompts\"):\n\t        for file in files:\n\t            prompt_category = None\n\t            if root != \"prompts\":\n\t                # Use subfolder name as the prompt category\n\t                category_name = os.path.basename(root)\n\t                prompt_category = (\n\t                    session.query(PromptCategory).filter_by(name=category_name).first()\n\t                )\n", "                if not prompt_category:\n\t                    prompt_category = PromptCategory(\n\t                        name=category_name, description=f\"{category_name} category\"\n\t                    )\n\t                    session.add(prompt_category)\n\t                    session.commit()\n\t            else:\n\t                # Assign to \"Uncategorized\" category if prompt is in the root folder\n\t                prompt_category = default_category\n\t            # Read the prompt content from the file\n", "            with open(os.path.join(root, file), \"r\") as f:\n\t                prompt_content = f.read()\n\t            # Check if prompt with the same name and category already exists\n\t            prompt_name = os.path.splitext(file)[0]\n\t            prompt = (\n\t                session.query(Prompt)\n\t                .filter_by(name=prompt_name, prompt_category=prompt_category)\n\t                .first()\n\t            )\n\t            prompt_args = []\n", "            for word in prompt_content.split():\n\t                if word.startswith(\"{\") and word.endswith(\"}\"):\n\t                    prompt_args.append(word[1:-1])\n\t            if not prompt:\n\t                # Create the prompt entry in the database\n\t                prompt = Prompt(\n\t                    name=prompt_name,\n\t                    description=\"\",\n\t                    content=prompt_content,\n\t                    prompt_category=prompt_category,\n", "                )\n\t                session.add(prompt)\n\t                session.commit()\n\t                print(f\"Adding prompt: {prompt_name}\")\n\t            # Populate prompt arguments\n\t            for arg in prompt_args:\n\t                if (\n\t                    session.query(Argument)\n\t                    .filter_by(prompt_id=prompt.id, name=arg)\n\t                    .first()\n", "                ):\n\t                    continue\n\t                argument = Argument(\n\t                    prompt_id=prompt.id,\n\t                    name=arg,\n\t                )\n\t                session.add(argument)\n\t                session.commit()\n\t                print(f\"Adding prompt argument: {arg} for {prompt_name}\")\n\tdef import_conversations():\n", "    agents_dir = \"agents\"  # Directory containing agent folders\n\t    for agent_name in os.listdir(agents_dir):\n\t        agent_dir = os.path.join(agents_dir, agent_name)\n\t        history_file = os.path.join(agent_dir, \"history.yaml\")\n\t        if not os.path.exists(history_file):\n\t            continue  # Skip agent if history file doesn't exist\n\t        # Get agent ID from the database based on agent name\n\t        agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t        if not agent:\n\t            print(f\"Agent '{agent_name}' not found in the database.\")\n", "            continue\n\t        # Load conversation history from the YAML file\n\t        with open(history_file, \"r\") as file:\n\t            history = yaml.safe_load(file)\n\t        # Check if the conversation already exists for the agent\n\t        existing_conversation = (\n\t            session.query(Conversation)\n\t            .filter(\n\t                Conversation.agent_id == agent.id,\n\t                Conversation.name == f\"{agent_name} History\",\n", "            )\n\t            .first()\n\t        )\n\t        if existing_conversation:\n\t            continue\n\t        # Create a new conversation\n\t        conversation = Conversation(agent_id=agent.id, name=f\"{agent_name} History\")\n\t        session.add(conversation)\n\t        session.commit()\n\t        for conversation_data in history[\"interactions\"]:\n", "            # Create a new message for the conversation\n\t            try:\n\t                role = conversation_data[\"role\"]\n\t                content = conversation_data[\"message\"]\n\t                timestamp = conversation_data[\"timestamp\"]\n\t            except KeyError:\n\t                continue\n\t            message = Message(\n\t                role=role,\n\t                content=content,\n", "                timestamp=timestamp,\n\t                conversation_id=conversation.id,\n\t            )\n\t            session.add(message)\n\t            session.commit()\n\t        print(f\"Imported `{agent_name} History` conversation for agent '{agent_name}'.\")\n\tdef import_providers():\n\t    providers = get_providers()\n\t    existing_providers = session.query(Provider).all()\n\t    existing_provider_names = [provider.name for provider in existing_providers]\n", "    for provider in existing_providers:\n\t        if provider.name not in providers:\n\t            session.delete(provider)\n\t    for provider_name in providers:\n\t        provider_options = get_provider_options(provider_name)\n\t        provider = session.query(Provider).filter_by(name=provider_name).one_or_none()\n\t        if provider:\n\t            print(f\"Updating provider: {provider_name}\")\n\t        else:\n\t            provider = Provider(name=provider_name)\n", "            session.add(provider)\n\t            existing_provider_names.append(provider_name)\n\t            print(f\"Adding provider: {provider_name}\")\n\t        for option_name, option_value in provider_options.items():\n\t            provider_setting = (\n\t                session.query(ProviderSetting)\n\t                .filter_by(provider_id=provider.id, name=option_name)\n\t                .one_or_none()\n\t            )\n\t            if provider_setting:\n", "                provider_setting.value = option_value\n\t                print(\n\t                    f\"Updating provider setting: {option_name} for provider: {provider_name}\"\n\t                )\n\t            else:\n\t                provider_setting = ProviderSetting(\n\t                    provider_id=provider.id,\n\t                    name=option_name,\n\t                    value=option_value,\n\t                )\n", "                session.add(provider_setting)\n\t                print(\n\t                    f\"Adding provider setting: {option_name} for provider: {provider_name}\"\n\t                )\n\t    session.commit()\n"]}
{"filename": "agixt/db/Agent.py", "chunked_list": ["import os\n\timport json\n\timport shutil\n\tfrom DBConnection import (\n\t    Agent as AgentModel,\n\t    AgentSetting as AgentSettingModel,\n\t    Command,\n\t    AgentCommand,\n\t    ProviderSetting,\n\t    AgentProvider,\n", "    AgentProviderSetting,\n\t    ChainStep,\n\t    ChainStepArgument,\n\t    ChainStepResponse,\n\t    Provider as ProviderModel,\n\t    session,\n\t)\n\tfrom Providers import Providers\n\tfrom Memories import Memories\n\tfrom Extensions import Extensions\n", "DEFAULT_SETTINGS = {\n\t    \"provider\": \"openai\",\n\t    \"embedder\": \"openai\",\n\t    \"AI_MODEL\": \"gpt-3.5-turbo-16k-0613\",\n\t    \"AI_TEMPERATURE\": \"0.7\",\n\t    \"AI_TOP_P\": \"1\",\n\t    \"MAX_TOKENS\": \"16000\",\n\t    \"helper_agent_name\": \"OpenAI\",\n\t    \"WEBSEARCH_TIMEOUT\": 0,\n\t    \"OPENAI_API_KEY\": \"YOUR_OPENAI_API_KEY_HERE\",\n", "    \"WAIT_BETWEEN_REQUESTS\": 1,\n\t    \"WAIT_AFTER_FAILURE\": 3,\n\t    \"stream\": False,\n\t    \"WORKING_DIRECTORY\": \"./WORKSPACE\",\n\t    \"WORKING_DIRECTORY_RESTRICTED\": True,\n\t    \"AUTONOMOUS_EXECUTION\": False,\n\t}\n\tdef add_agent(agent_name, provider_settings=None, commands=None):\n\t    if not agent_name:\n\t        return {\"message\": \"Agent name cannot be empty.\"}\n", "    agent = AgentModel(name=agent_name)\n\t    session.add(agent)\n\t    session.commit()\n\t    if provider_settings is None or provider_settings == \"\" or provider_settings == {}:\n\t        provider_settings = DEFAULT_SETTINGS\n\t    settings = {\n\t        \"commands\": commands,\n\t        \"settings\": provider_settings,\n\t    }\n\t    agent_setting = AgentSettingModel(\n", "        agent_id=agent.id,\n\t        name=\"config\",\n\t        value=json.dumps(settings),\n\t    )\n\t    session.add(agent_setting)\n\t    session.commit()\n\t    return {\"message\": f\"Agent {agent_name} created.\"}\n\tdef delete_agent(agent_name):\n\t    agent = session.query(AgentModel).filter_by(name=agent_name).first()\n\t    if not agent:\n", "        return {\"message\": f\"Agent {agent_name} not found.\"}, 404\n\t    # Delete associated chain steps\n\t    chain_steps = session.query(ChainStep).filter_by(agent_id=agent.id).all()\n\t    for chain_step in chain_steps:\n\t        # Delete associated chain step arguments\n\t        session.query(ChainStepArgument).filter_by(chain_step_id=chain_step.id).delete()\n\t        # Delete associated chain step responses\n\t        session.query(ChainStepResponse).filter_by(chain_step_id=chain_step.id).delete()\n\t        session.delete(chain_step)\n\t    # Delete associated agent commands\n", "    agent_commands = session.query(AgentCommand).filter_by(agent_id=agent.id).all()\n\t    for agent_command in agent_commands:\n\t        session.delete(agent_command)\n\t    # Delete associated agent_provider records\n\t    agent_providers = session.query(AgentProvider).filter_by(agent_id=agent.id).all()\n\t    for agent_provider in agent_providers:\n\t        # Delete associated agent_provider_settings\n\t        session.query(AgentProviderSetting).filter_by(\n\t            agent_provider_id=agent_provider.id\n\t        ).delete()\n", "        session.delete(agent_provider)\n\t    # Delete associated agent settings\n\t    session.query(AgentSettingModel).filter_by(agent_id=agent.id).delete()\n\t    # Delete the agent\n\t    session.delete(agent)\n\t    session.commit()\n\t    return {\"message\": f\"Agent {agent_name} deleted.\"}, 200\n\tdef rename_agent(agent_name, new_name):\n\t    agent = session.query(AgentModel).filter_by(name=agent_name).first()\n\t    if not agent:\n", "        return {\"message\": f\"Agent {agent_name} not found.\"}, 404\n\t    agent.name = new_name\n\t    session.commit()\n\t    return {\"message\": f\"Agent {agent_name} renamed to {new_name}.\"}, 200\n\tdef get_agents():\n\t    agents = session.query(AgentModel).all()\n\t    output = []\n\t    for agent in agents:\n\t        output.append({\"name\": agent.name, \"status\": False})\n\t    return output\n", "def import_agent_config(agent_name):\n\t    config_path = f\"agents/{agent_name}/config.json\"\n\t    # Load the config JSON file\n\t    with open(config_path) as f:\n\t        config = json.load(f)\n\t    # Get the agent from the database\n\t    agent = session.query(AgentModel).filter_by(name=agent_name).first()\n\t    if not agent:\n\t        print(f\"Agent '{agent_name}' does not exist in the database.\")\n\t        return\n", "    # Get the provider ID based on the provider name in the config\n\t    provider_name = config[\"settings\"][\"provider\"]\n\t    provider = session.query(ProviderModel).filter_by(name=provider_name).first()\n\t    if not provider:\n\t        print(f\"Provider '{provider_name}' does not exist in the database.\")\n\t        return\n\t    # Update the agent's provider_id\n\t    agent.provider_id = provider.id\n\t    # Import agent commands\n\t    commands = config.get(\"commands\", {})\n", "    for command_name, enabled in commands.items():\n\t        if enabled:\n\t            command = session.query(Command).filter_by(name=command_name).first()\n\t            if command:\n\t                agent_command = AgentCommand(\n\t                    agent_id=agent.id, command_id=command.id, state=True\n\t                )\n\t                session.add(agent_command)\n\t    # Import agent settings\n\t    settings = config.get(\"settings\", {})\n", "    for setting_name, setting_value in settings.items():\n\t        if provider.id:\n\t            provider_setting = (\n\t                session.query(ProviderSetting)\n\t                .filter_by(provider_id=provider.id, name=setting_name)\n\t                .first()\n\t            )\n\t            if provider_setting:\n\t                agent_provider = (\n\t                    session.query(AgentProvider)\n", "                    .filter_by(provider_id=provider.id, agent_id=agent.id)\n\t                    .first()\n\t                )\n\t                if not agent_provider:\n\t                    agent_provider = AgentProvider(\n\t                        provider_id=provider.id, agent_id=agent.id\n\t                    )\n\t                    session.add(agent_provider)\n\t                    session.flush()  # Save the agent_provider object to generate an ID\n\t                if setting_value:\n", "                    agent_provider_setting = AgentProviderSetting(\n\t                        provider_setting_id=provider_setting.id,\n\t                        agent_provider_id=agent_provider.id,\n\t                        value=setting_value,\n\t                    )\n\t                    session.add(agent_provider_setting)\n\t            else:\n\t                if setting_value:\n\t                    agent_setting = AgentSettingModel(\n\t                        agent_id=agent.id, name=setting_name, value=setting_value\n", "                    )\n\t                    session.add(agent_setting)\n\t    session.commit()\n\t    print(f\"Agent config imported successfully for agent: {agent_name}\")\n\tclass Agent:\n\t    def __init__(self, agent_name=None):\n\t        self.agent_name = agent_name if agent_name is not None else \"AGiXT\"\n\t        self.AGENT_CONFIG = self.get_agent_config()\n\t        self.load_config_keys()\n\t        if \"settings\" not in self.AGENT_CONFIG:\n", "            self.AGENT_CONFIG[\"settings\"] = {}\n\t        self.PROVIDER_SETTINGS = self.AGENT_CONFIG[\"settings\"]\n\t        for setting in DEFAULT_SETTINGS:\n\t            if setting not in self.PROVIDER_SETTINGS:\n\t                self.PROVIDER_SETTINGS[setting] = DEFAULT_SETTINGS[setting]\n\t        self.AI_PROVIDER = self.AGENT_CONFIG[\"settings\"][\"provider\"]\n\t        self.PROVIDER = Providers(self.AI_PROVIDER, **self.PROVIDER_SETTINGS)\n\t        self.available_commands = Extensions(\n\t            agent_config=self.AGENT_CONFIG\n\t        ).get_available_commands()\n", "    def load_config_keys(self):\n\t        config_keys = [\n\t            \"AI_MODEL\",\n\t            \"AI_TEMPERATURE\",\n\t            \"MAX_TOKENS\",\n\t            \"AUTONOMOUS_EXECUTION\",\n\t            \"embedder\",\n\t        ]\n\t        for key in config_keys:\n\t            if key in self.AGENT_CONFIG:\n", "                setattr(self, key, self.AGENT_CONFIG[key])\n\t    def get_agent_config(self):\n\t        agent = (\n\t            session.query(AgentModel).filter(AgentModel.name == self.agent_name).first()\n\t        )\n\t        if agent:\n\t            agent_setting = (\n\t                session.query(AgentSettingModel)\n\t                .filter(\n\t                    AgentSettingModel.agent_id == agent.id,\n", "                    AgentSettingModel.name == \"config\",\n\t                )\n\t                .first()\n\t            )\n\t            if agent_setting:\n\t                config = json.loads(agent_setting.value)\n\t                # Retrieve the enabled commands for the agent\n\t                agent_commands = (\n\t                    session.query(AgentCommand)\n\t                    .join(Command)\n", "                    .filter(\n\t                        AgentCommand.agent_id == agent.id,\n\t                        AgentCommand.state == True,  # Only get enabled commands\n\t                    )\n\t                    .all()\n\t                )\n\t                enabled_commands = [ac.command.name for ac in agent_commands]\n\t                # Add the enabled commands to the config\n\t                config[\"enabled_commands\"] = enabled_commands\n\t                return config\n", "        return {}\n\t    def get_memories(self):\n\t        return Memories(self.agent_name, self.AGENT_CONFIG)\n\t    async def execute(self, command_name, command_args):\n\t        return await Extensions(agent_config=self.AGENT_CONFIG).execute_command(\n\t            command_name=command_name, command_args=command_args\n\t        )\n\t    async def instruct(self, prompt, tokens):\n\t        if not prompt:\n\t            return \"\"\n", "        answer = await self.PROVIDER.instruct(prompt=prompt, tokens=tokens)\n\t        return answer\n\t    def get_commands_string(self):\n\t        if len(self.available_commands) == 0:\n\t            return None\n\t        enabled_commands = filter(\n\t            lambda command: command.get(\"enabled\", True), self.available_commands\n\t        )\n\t        if not enabled_commands:\n\t            return None\n", "        friendly_names = map(\n\t            lambda command: f\"`{command['friendly_name']}` - Arguments: {command['args']}\",\n\t            enabled_commands,\n\t        )\n\t        command_list = \"\\n\".join(friendly_names)\n\t        return f\"Commands Available To Complete Task:\\n{command_list}\\n\\n\"\n\t    def update_agent_config(self, new_config, config_key):\n\t        agent = (\n\t            session.query(AgentModel).filter(AgentModel.name == self.agent_name).first()\n\t        )\n", "        if agent:\n\t            if config_key == \"commands\":\n\t                # Update AgentCommand relation\n\t                for command_name, enabled in new_config.items():\n\t                    command = (\n\t                        session.query(Command).filter_by(name=command_name).first()\n\t                    )\n\t                    if command:\n\t                        agent_command = (\n\t                            session.query(AgentCommand)\n", "                            .filter_by(agent_id=agent.id, command_id=command.id)\n\t                            .first()\n\t                        )\n\t                        if agent_command:\n\t                            agent_command.state = enabled\n\t                        else:\n\t                            agent_command = AgentCommand(\n\t                                agent_id=agent.id, command_id=command.id, state=enabled\n\t                            )\n\t                            session.add(agent_command)\n", "            else:\n\t                provider = (\n\t                    session.query(ProviderModel)\n\t                    .filter_by(name=self.AI_PROVIDER)\n\t                    .first()\n\t                )\n\t                if not provider:\n\t                    print(\n\t                        f\"Provider '{self.AI_PROVIDER}' does not exist in the database.\"\n\t                    )\n", "                    return\n\t                agent_provider = (\n\t                    session.query(AgentProvider)\n\t                    .filter_by(provider_id=provider.id, agent_id=agent.id)\n\t                    .first()\n\t                )\n\t                if not agent_provider:\n\t                    agent_provider = AgentProvider(\n\t                        provider_id=provider.id, agent_id=agent.id\n\t                    )\n", "                    session.add(agent_provider)\n\t                    session.flush()  # Save the agent_provider object to generate an ID\n\t                if config_key in [\"provider_settings\", \"settings\"]:\n\t                    config_dict = (\n\t                        agent_provider.provider_settings\n\t                        if config_key == \"provider_settings\"\n\t                        else agent_provider.settings\n\t                    )\n\t                    for setting_name, setting_value in new_config.items():\n\t                        setting = (\n", "                            session.query(ProviderSetting)\n\t                            .filter_by(provider_id=provider.id, name=setting_name)\n\t                            .first()\n\t                        )\n\t                        if setting:\n\t                            agent_provider_setting = (\n\t                                session.query(AgentProviderSetting)\n\t                                .filter_by(\n\t                                    provider_setting_id=setting.id,\n\t                                    agent_provider_id=agent_provider.id,\n", "                                )\n\t                                .first()\n\t                            )\n\t                            if agent_provider_setting:\n\t                                agent_provider_setting.value = setting_value\n\t                            else:\n\t                                agent_provider_setting = AgentProviderSetting(\n\t                                    provider_setting_id=setting.id,\n\t                                    agent_provider_id=agent_provider.id,\n\t                                    value=setting_value,\n", "                                )\n\t                                session.add(agent_provider_setting)\n\t                else:\n\t                    agent_setting = (\n\t                        session.query(AgentSettingModel)\n\t                        .filter_by(agent_id=agent.id, name=config_key)\n\t                        .first()\n\t                    )\n\t                    if agent_setting:\n\t                        agent_setting.value = new_config\n", "                    else:\n\t                        agent_setting = AgentSettingModel(\n\t                            agent_id=agent.id, name=config_key, value=new_config\n\t                        )\n\t                        session.add(agent_setting)\n\t            session.commit()\n\t            return f\"Agent {self.agent_name} configuration updated.\"\n\t        else:\n\t            return f\"Agent {self.agent_name} not found.\"\n\t    def wipe_agent_memories(self):\n", "        memories_folder = os.path.normpath(\n\t            os.path.join(os.getcwd(), self.agent_name, \"memories\")\n\t        )\n\t        if not memories_folder.startswith(os.getcwd()):\n\t            raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n\t        if os.path.exists(memories_folder):\n\t            shutil.rmtree(memories_folder)\n"]}
{"filename": "agixt/db/Chain.py", "chunked_list": ["from DBConnection import (\n\t    session,\n\t    Chain as ChainDB,\n\t    ChainStep,\n\t    ChainStepResponse,\n\t    Agent,\n\t    Argument,\n\t    ChainStepArgument,\n\t    Prompt,\n\t    Command,\n", ")\n\tfrom agixtsdk import AGiXTSDK\n\tfrom Extensions import Extensions\n\timport logging\n\timport os\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tApiClient = AGiXTSDK(\n\t    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n\t)\n", "class Chain:\n\t    def get_chain(self, chain_name):\n\t        chain_name = chain_name.replace(\"%20\", \" \")\n\t        chain_db = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        if chain_db is None:\n\t            return None\n\t        chain_steps = (\n\t            session.query(ChainStep)\n\t            .filter(ChainStep.chain_id == chain_db.id)\n\t            .order_by(ChainStep.step_number)\n", "            .all()\n\t        )\n\t        steps = []\n\t        for step in chain_steps:\n\t            agent_name = session.query(Agent).get(step.agent_id).name\n\t            prompt = {}\n\t            if step.target_chain_id:\n\t                prompt[\"chain_name\"] = (\n\t                    session.query(ChainDB).get(step.target_chain_id).name\n\t                )\n", "            elif step.target_command_id:\n\t                prompt[\"command_name\"] = (\n\t                    session.query(Command).get(step.target_command_id).name\n\t                )\n\t            elif step.target_prompt_id:\n\t                prompt[\"prompt_name\"] = (\n\t                    session.query(Prompt).get(step.target_prompt_id).name\n\t                )\n\t            # Retrieve argument data for the step\n\t            arguments = (\n", "                session.query(Argument, ChainStepArgument)\n\t                .join(ChainStepArgument, ChainStepArgument.argument_id == Argument.id)\n\t                .filter(ChainStepArgument.chain_step_id == step.id)\n\t                .all()\n\t            )\n\t            prompt_args = {}\n\t            for argument, chain_step_argument in arguments:\n\t                prompt_args[argument.name] = chain_step_argument.value\n\t            prompt.update(prompt_args)\n\t            step_data = {\n", "                \"step\": step.step_number,\n\t                \"agent_name\": agent_name,\n\t                \"prompt_type\": step.prompt_type,\n\t                \"prompt\": prompt,\n\t            }\n\t            steps.append(step_data)\n\t        chain_data = {\n\t            \"chain_name\": chain_db.name,\n\t            \"steps\": steps,\n\t        }\n", "        return chain_data\n\t    def get_chains(self):\n\t        chains = session.query(ChainDB).all()\n\t        return [chain.name for chain in chains]\n\t    def add_chain(self, chain_name):\n\t        chain = ChainDB(name=chain_name)\n\t        session.add(chain)\n\t        session.commit()\n\t    def rename_chain(self, chain_name, new_name):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n", "        chain.name = new_name\n\t        session.commit()\n\t    def add_chain_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t        if \"prompt_name\" in prompt:\n\t            argument_key = \"prompt_name\"\n\t            target_id = (\n\t                session.query(Prompt)\n\t                .filter(Prompt.name == prompt[\"prompt_name\"])\n", "                .first()\n\t                .id\n\t            )\n\t            target_type = \"prompt\"\n\t        elif \"chain_name\" in prompt:\n\t            argument_key = \"chain_name\"\n\t            target_id = (\n\t                session.query(Chain)\n\t                .filter(Chain.name == prompt[\"chain_name\"])\n\t                .first()\n", "                .id\n\t            )\n\t            target_type = \"chain\"\n\t        elif \"command_name\" in prompt:\n\t            argument_key = \"command_name\"\n\t            target_id = (\n\t                session.query(Command)\n\t                .filter(Command.name == prompt[\"command_name\"])\n\t                .first()\n\t                .id\n", "            )\n\t            target_type = \"command\"\n\t        argument_value = prompt[argument_key]\n\t        prompt_arguments = prompt.copy()\n\t        del prompt_arguments[argument_key]\n\t        chain_step = ChainStep(\n\t            chain_id=chain.id,\n\t            step_number=step_number,\n\t            agent_id=agent.id,\n\t            prompt_type=prompt_type,\n", "            prompt=argument_value,\n\t            target_chain_id=target_id if target_type == \"chain\" else None,\n\t            target_command_id=target_id if target_type == \"command\" else None,\n\t            target_prompt_id=target_id if target_type == \"prompt\" else None,\n\t        )\n\t        session.add(chain_step)\n\t        session.commit()\n\t        for argument_name, argument_value in prompt_arguments.items():\n\t            argument = (\n\t                session.query(Argument).filter(Argument.name == argument_name).first()\n", "            )\n\t            if not argument:\n\t                # Handle the case where argument not found based on argument_name\n\t                # You can choose to skip this argument or raise an exception\n\t                continue\n\t            chain_step_argument = ChainStepArgument(\n\t                chain_step_id=chain_step.id,\n\t                argument_id=argument.id,\n\t                value=argument_value,\n\t            )\n", "            session.add(chain_step_argument)\n\t            session.commit()\n\t    def update_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        chain_step = (\n\t            session.query(ChainStep)\n\t            .filter(\n\t                ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n\t            )\n\t            .first()\n", "        )\n\t        agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t        agent_id = agent.id if agent else None\n\t        target_chain_id = None\n\t        target_command_id = None\n\t        target_prompt_id = None\n\t        if prompt_type == \"Command\":\n\t            command_name = prompt.get(\"command_name\")\n\t            command_args = prompt.copy()\n\t            del command_args[\"command_name\"]\n", "            command = (\n\t                session.query(Command).filter(Command.name == command_name).first()\n\t            )\n\t            if command:\n\t                target_command_id = command.id\n\t        elif prompt_type == \"Prompt\":\n\t            prompt_name = prompt.get(\"prompt_name\")\n\t            prompt_args = prompt.copy()\n\t            del prompt_args[\"prompt_name\"]\n\t            prompt_obj = (\n", "                session.query(Prompt).filter(Prompt.name == prompt_name).first()\n\t            )\n\t            if prompt_obj:\n\t                target_prompt_id = prompt_obj.id\n\t        elif prompt_type == \"Chain\":\n\t            chain_name = prompt.get(\"chain_name\")\n\t            chain_args = prompt.copy()\n\t            del chain_args[\"chain_name\"]\n\t            chain_obj = (\n\t                session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n", "            )\n\t            if chain_obj:\n\t                target_chain_id = chain_obj.id\n\t        chain_step.agent_id = agent_id\n\t        chain_step.prompt_type = prompt_type\n\t        chain_step.prompt = prompt.get(\"prompt_name\", None)\n\t        chain_step.target_chain_id = target_chain_id\n\t        chain_step.target_command_id = target_command_id\n\t        chain_step.target_prompt_id = target_prompt_id\n\t        session.commit()\n", "        # Update the arguments for the step\n\t        session.query(ChainStepArgument).filter(\n\t            ChainStepArgument.chain_step_id == chain_step.id\n\t        ).delete()\n\t        for argument_name, argument_value in prompt_args.items():\n\t            argument = (\n\t                session.query(Argument).filter(Argument.name == argument_name).first()\n\t            )\n\t            if argument:\n\t                chain_step_argument = ChainStepArgument(\n", "                    chain_step_id=chain_step.id,\n\t                    argument_id=argument.id,\n\t                    value=argument_value,\n\t                )\n\t                session.add(chain_step_argument)\n\t                session.commit()\n\t    def delete_step(self, chain_name, step_number):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        if chain:\n\t            chain_step = (\n", "                session.query(ChainStep)\n\t                .filter(\n\t                    ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n\t                )\n\t                .first()\n\t            )\n\t            if chain_step:\n\t                session.delete(chain_step)  # Remove the chain step from the session\n\t                session.commit()\n\t            else:\n", "                print(\n\t                    f\"No step found with number {step_number} in chain '{chain_name}'\"\n\t                )\n\t        else:\n\t            print(f\"No chain found with name '{chain_name}'\")\n\t    def delete_chain(self, chain_name):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        session.delete(chain)\n\t        session.commit()\n\t    def get_step(self, chain_name, step_number):\n", "        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        chain_step = (\n\t            session.query(ChainStep)\n\t            .filter(\n\t                ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n\t            )\n\t            .first()\n\t        )\n\t        return chain_step\n\t    def get_steps(self, chain_name):\n", "        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        chain_steps = (\n\t            session.query(ChainStep)\n\t            .filter(ChainStep.chain_id == chain.id)\n\t            .order_by(ChainStep.step_number)\n\t            .all()\n\t        )\n\t        return chain_steps\n\t    def move_step(self, chain_name, current_step_number, new_step_number):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n", "        chain_step = (\n\t            session.query(ChainStep)\n\t            .filter(\n\t                ChainStep.chain_id == chain.id,\n\t                ChainStep.step_number == current_step_number,\n\t            )\n\t            .first()\n\t        )\n\t        chain_step.step_number = new_step_number\n\t        if new_step_number < current_step_number:\n", "            session.query(ChainStep).filter(\n\t                ChainStep.chain_id == chain.id,\n\t                ChainStep.step_number >= new_step_number,\n\t                ChainStep.step_number < current_step_number,\n\t            ).update(\n\t                {\"step_number\": ChainStep.step_number + 1}, synchronize_session=False\n\t            )\n\t        else:\n\t            session.query(ChainStep).filter(\n\t                ChainStep.chain_id == chain.id,\n", "                ChainStep.step_number > current_step_number,\n\t                ChainStep.step_number <= new_step_number,\n\t            ).update(\n\t                {\"step_number\": ChainStep.step_number - 1}, synchronize_session=False\n\t            )\n\t        session.commit()\n\t    def get_step_response(self, chain_name, step_number=\"all\"):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        if step_number == \"all\":\n\t            chain_steps = (\n", "                session.query(ChainStep)\n\t                .filter(ChainStep.chain_id == chain.id)\n\t                .order_by(ChainStep.step_number)\n\t                .all()\n\t            )\n\t            responses = {}\n\t            for step in chain_steps:\n\t                chain_step_responses = (\n\t                    session.query(ChainStepResponse)\n\t                    .filter(ChainStepResponse.chain_step_id == step.id)\n", "                    .order_by(ChainStepResponse.timestamp)\n\t                    .all()\n\t                )\n\t                step_responses = [response.content for response in chain_step_responses]\n\t                responses[str(step.step_number)] = step_responses\n\t            return responses\n\t        else:\n\t            chain_step = (\n\t                session.query(ChainStep)\n\t                .filter(\n", "                    ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n\t                )\n\t                .first()\n\t            )\n\t            if chain_step:\n\t                chain_step_responses = (\n\t                    session.query(ChainStepResponse)\n\t                    .filter(ChainStepResponse.chain_step_id == chain_step.id)\n\t                    .order_by(ChainStepResponse.timestamp)\n\t                    .all()\n", "                )\n\t                step_responses = [response.content for response in chain_step_responses]\n\t                return step_responses\n\t            else:\n\t                return None\n\t    def get_chain_responses(self, chain_name):\n\t        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\t        chain_steps = (\n\t            session.query(ChainStep)\n\t            .filter(ChainStep.chain_id == chain.id)\n", "            .order_by(ChainStep.step_number)\n\t            .all()\n\t        )\n\t        responses = {}\n\t        for step in chain_steps:\n\t            chain_step_responses = (\n\t                session.query(ChainStepResponse)\n\t                .filter(ChainStepResponse.chain_step_id == step.id)\n\t                .order_by(ChainStepResponse.timestamp)\n\t                .all()\n", "            )\n\t            step_responses = [response.content for response in chain_step_responses]\n\t            responses[str(step.step_number)] = step_responses\n\t        return responses\n\t    def import_chain(self, chain_name: str, steps: dict):\n\t        chain = ChainDB(name=chain_name)\n\t        session.add(chain)\n\t        session.commit()\n\t        steps = steps[\"steps\"] if \"steps\" in steps else steps\n\t        for step_data in steps:\n", "            agent_name = step_data[\"agent_name\"]\n\t            agent = session.query(Agent).filter(Agent.name == agent_name).first()\n\t            if not agent:\n\t                # Handle the case where agent not found based on agent_name\n\t                # You can choose to skip this step or raise an exception\n\t                continue\n\t            prompt = step_data[\"prompt\"]\n\t            if \"prompt_name\" in prompt:\n\t                argument_key = \"prompt_name\"\n\t                target_id = (\n", "                    session.query(Prompt)\n\t                    .filter(Prompt.name == prompt[\"prompt_name\"])\n\t                    .first()\n\t                    .id\n\t                )\n\t                target_type = \"prompt\"\n\t            elif \"chain_name\" in prompt:\n\t                argument_key = \"chain_name\"\n\t                target_id = (\n\t                    session.query(Chain)\n", "                    .filter(Chain.name == prompt[\"chain_name\"])\n\t                    .first()\n\t                    .id\n\t                )\n\t                target_type = \"chain\"\n\t            elif \"command_name\" in prompt:\n\t                argument_key = \"command_name\"\n\t                target_id = (\n\t                    session.query(Command)\n\t                    .filter(Command.name == prompt[\"command_name\"])\n", "                    .first()\n\t                    .id\n\t                )\n\t                target_type = \"command\"\n\t            else:\n\t                # Handle the case where the argument key is not found\n\t                # You can choose to skip this step or raise an exception\n\t                continue\n\t            argument_value = prompt[argument_key]\n\t            prompt_arguments = prompt.copy()\n", "            del prompt_arguments[argument_key]\n\t            chain_step = ChainStep(\n\t                chain_id=chain.id,\n\t                step_number=step_data[\"step\"],\n\t                agent_id=agent.id,\n\t                prompt_type=step_data[\"prompt_type\"],\n\t                prompt=argument_value,\n\t                target_chain_id=target_id if target_type == \"chain\" else None,\n\t                target_command_id=target_id if target_type == \"command\" else None,\n\t                target_prompt_id=target_id if target_type == \"prompt\" else None,\n", "            )\n\t            session.add(chain_step)\n\t            session.commit()\n\t            for argument_name, argument_value in prompt_arguments.items():\n\t                argument = (\n\t                    session.query(Argument)\n\t                    .filter(Argument.name == argument_name)\n\t                    .first()\n\t                )\n\t                if not argument:\n", "                    # Handle the case where argument not found based on argument_name\n\t                    # You can choose to skip this argument or raise an exception\n\t                    continue\n\t                chain_step_argument = ChainStepArgument(\n\t                    chain_step_id=chain_step.id,\n\t                    argument_id=argument.id,\n\t                    value=argument_value,\n\t                )\n\t                session.add(chain_step_argument)\n\t                session.commit()\n", "        return f\"Chain '{chain_name}' imported.\"\n\t    def get_step_content(self, chain_name, prompt_content, user_input, agent_name):\n\t        if isinstance(prompt_content, dict):\n\t            new_prompt_content = {}\n\t            for arg, value in prompt_content.items():\n\t                if isinstance(value, str):\n\t                    if \"{user_input}\" in value:\n\t                        value = value.replace(\"{user_input}\", user_input)\n\t                    if \"{agent_name}\" in value:\n\t                        value = value.replace(\"{agent_name}\", agent_name)\n", "                    if \"{STEP\" in value:\n\t                        step_count = value.count(\"{STEP\")\n\t                        for i in range(step_count):\n\t                            new_step_number = int(value.split(\"{STEP\")[1].split(\"}\")[0])\n\t                            step_response = self.get_step_response(\n\t                                chain_name=chain_name, step_number=new_step_number\n\t                            )\n\t                            if step_response:\n\t                                resp = (\n\t                                    step_response[0]\n", "                                    if isinstance(step_response, list)\n\t                                    else step_response\n\t                                )\n\t                                value = value.replace(\n\t                                    f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n\t                                )\n\t                new_prompt_content[arg] = value\n\t            return new_prompt_content\n\t        elif isinstance(prompt_content, str):\n\t            new_prompt_content = prompt_content\n", "            if \"{user_input}\" in prompt_content:\n\t                new_prompt_content = new_prompt_content.replace(\n\t                    \"{user_input}\", user_input\n\t                )\n\t            if \"{agent_name}\" in new_prompt_content:\n\t                new_prompt_content = new_prompt_content.replace(\n\t                    \"{agent_name}\", agent_name\n\t                )\n\t            if \"{STEP\" in prompt_content:\n\t                step_count = prompt_content.count(\"{STEP\")\n", "                for i in range(step_count):\n\t                    new_step_number = int(\n\t                        prompt_content.split(\"{STEP\")[1].split(\"}\")[0]\n\t                    )\n\t                    step_response = self.get_step_response(\n\t                        chain_name=chain_name, step_number=new_step_number\n\t                    )\n\t                    if step_response:\n\t                        resp = (\n\t                            step_response[0]\n", "                            if isinstance(step_response, list)\n\t                            else step_response\n\t                        )\n\t                        new_prompt_content = new_prompt_content.replace(\n\t                            f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n\t                        )\n\t            return new_prompt_content\n\t        else:\n\t            return prompt_content\n\t    async def run_chain_step(\n", "        self, step: dict = {}, chain_name=\"\", user_input=\"\", agent_override=\"\"\n\t    ):\n\t        if step:\n\t            if \"prompt_type\" in step:\n\t                if agent_override != \"\":\n\t                    agent_name = agent_override\n\t                else:\n\t                    agent_name = step[\"agent_name\"]\n\t                prompt_type = step[\"prompt_type\"]\n\t                step_number = step[\"step\"]\n", "                if \"prompt_name\" in step[\"prompt\"]:\n\t                    prompt_name = step[\"prompt\"][\"prompt_name\"]\n\t                else:\n\t                    prompt_name = \"\"\n\t                args = self.get_step_content(\n\t                    chain_name=chain_name,\n\t                    prompt_content=step[\"prompt\"],\n\t                    user_input=user_input,\n\t                    agent_name=step[\"agent_name\"],\n\t                )\n", "                if prompt_type == \"Command\":\n\t                    return await Extensions().execute_command(\n\t                        command_name=step[\"prompt\"][\"command_name\"], command_args=args\n\t                    )\n\t                elif prompt_type == \"Prompt\":\n\t                    result = ApiClient.prompt_agent(\n\t                        agent_name=agent_name,\n\t                        prompt_name=prompt_name,\n\t                        prompt_args={\n\t                            \"chain_name\": chain_name,\n", "                            \"step_number\": step_number,\n\t                            \"user_input\": user_input,\n\t                            **args,\n\t                        },\n\t                    )\n\t                elif prompt_type == \"Chain\":\n\t                    result = ApiClient.run_chain(\n\t                        chain_name=args[\"chain\"],\n\t                        user_input=args[\"input\"],\n\t                        agent_name=agent_name,\n", "                        all_responses=False,\n\t                        from_step=1,\n\t                    )\n\t        if result:\n\t            return result\n\t        else:\n\t            return None\n\t    async def run_chain(\n\t        self,\n\t        chain_name,\n", "        user_input=None,\n\t        all_responses=True,\n\t        agent_override=\"\",\n\t        from_step=1,\n\t    ):\n\t        chain_data = ApiClient.get_chain(chain_name=chain_name)\n\t        if chain_data == {}:\n\t            return f\"Chain `{chain_name}` not found.\"\n\t        logging.info(f\"Running chain '{chain_name}'\")\n\t        responses = {}  # Create a dictionary to hold responses.\n", "        last_response = \"\"\n\t        for step_data in chain_data[\"steps\"]:\n\t            if int(step_data[\"step\"]) >= int(from_step):\n\t                if \"prompt\" in step_data and \"step\" in step_data:\n\t                    step = {}\n\t                    step[\"agent_name\"] = (\n\t                        agent_override\n\t                        if agent_override != \"\"\n\t                        else step_data[\"agent_name\"]\n\t                    )\n", "                    step[\"prompt_type\"] = step_data[\"prompt_type\"]\n\t                    step[\"prompt\"] = step_data[\"prompt\"]\n\t                    logging.info(\n\t                        f\"Running step {step_data['step']} with agent {step['agent_name']}.\"\n\t                    )\n\t                    # Get the chain step based on the step number\n\t                    chain_step = self.get_step(chain_name, step_data[\"step\"])\n\t                    step_response = await self.run_chain_step(\n\t                        step=step_data,\n\t                        chain_name=chain_name,\n", "                        user_input=user_input,\n\t                        agent_override=agent_override,\n\t                    )  # Get the response of the current step.\n\t                    step[\"response\"] = step_response\n\t                    last_response = step_response\n\t                    responses[step_data[\"step\"]] = step  # Store the response.\n\t                    logging.info(f\"Response: {step_response}\")\n\t                    # Write the response to the json file.\n\t                    response_content = {\n\t                        \"chain_step_id\": chain_step.id,\n", "                        \"content\": step_response,\n\t                    }\n\t                    chain_step_response = ChainStepResponse(**response_content)\n\t                    session.add(chain_step_response)\n\t                    session.commit()\n\t        if all_responses:\n\t            return responses\n\t        else:\n\t            # Return only the last response in the chain.\n\t            return last_response\n"]}
{"filename": "agixt/db/Prompts.py", "chunked_list": ["from DBConnection import Prompt, PromptCategory, Argument, session\n\tclass Prompts:\n\t    def add_prompt(self, prompt_name, prompt, prompt_category_name=None):\n\t        if not prompt_category_name:\n\t            prompt_category_name = \"Default\"\n\t        prompt_category = (\n\t            session.query(PromptCategory).filter_by(name=prompt_category_name).first()\n\t        )\n\t        if not prompt_category:\n\t            prompt_category = PromptCategory(\n", "                name=prompt_category_name,\n\t                description=f\"{prompt_category_name} category\",\n\t            )\n\t            session.add(prompt_category)\n\t            session.commit()\n\t        prompt_obj = Prompt(\n\t            name=prompt_name,\n\t            description=\"\",\n\t            content=prompt,\n\t            prompt_category=prompt_category,\n", "        )\n\t        session.add(prompt_obj)\n\t        session.commit()\n\t        # Populate prompt arguments\n\t        prompt_args = self.get_prompt_args(prompt)\n\t        for arg in prompt_args:\n\t            argument = Argument(\n\t                prompt_id=prompt_obj.id,\n\t                name=arg,\n\t            )\n", "            session.add(argument)\n\t        session.commit()\n\t    def get_prompt(self, prompt_name, prompt_category=\"Default\"):\n\t        prompt = (\n\t            session.query(Prompt)\n\t            .filter_by(name=prompt_name)\n\t            .join(PromptCategory)\n\t            .filter(PromptCategory.name == prompt_category)\n\t            .first()\n\t        )\n", "        if not prompt and prompt_category != \"Default\":\n\t            # Prompt not found in specified category, try the default category\n\t            prompt = (\n\t                session.query(Prompt)\n\t                .filter_by(name=prompt_name)\n\t                .join(PromptCategory)\n\t                .filter(PromptCategory.name == \"Default\")\n\t                .first()\n\t            )\n\t        if prompt:\n", "            return prompt.content\n\t        return None\n\t    def get_prompts(self):\n\t        prompts = session.query(Prompt).all()\n\t        return [prompt.name for prompt in prompts]\n\t    def get_prompt_args(self, prompt_text):\n\t        prompt_args = []\n\t        start_index = prompt_text.find(\"{\")\n\t        while start_index != -1:\n\t            end_index = prompt_text.find(\"}\", start_index)\n", "            if end_index != -1:\n\t                prompt_args.append(prompt_text[start_index + 1 : end_index])\n\t                start_index = prompt_text.find(\"{\", end_index)\n\t            else:\n\t                break\n\t        return prompt_args\n\t    def delete_prompt(self, prompt_name):\n\t        prompt = session.query(Prompt).filter_by(name=prompt_name).first()\n\t        if prompt:\n\t            # Delete associated arguments\n", "            arguments = session.query(Argument).filter_by(prompt_id=prompt.id).all()\n\t            for argument in arguments:\n\t                session.delete(argument)\n\t            session.delete(prompt)\n\t            session.commit()\n\t    def update_prompt(self, prompt_name, prompt, prompt_category_name=None):\n\t        prompt_obj = session.query(Prompt).filter_by(name=prompt_name).first()\n\t        if prompt_obj:\n\t            if prompt_category_name:\n\t                prompt_category = (\n", "                    session.query(PromptCategory)\n\t                    .filter_by(name=prompt_category_name)\n\t                    .first()\n\t                )\n\t                if not prompt_category:\n\t                    prompt_category = PromptCategory(\n\t                        name=prompt_category_name,\n\t                        description=f\"{prompt_category_name} category\",\n\t                    )\n\t                    session.add(prompt_category)\n", "                    session.commit()\n\t                prompt_obj.prompt_category = prompt_category\n\t            prompt_obj.content = prompt\n\t            session.commit()\n\t            # Update prompt arguments\n\t            prompt_args = self.get_prompt_args(prompt)\n\t            existing_args = (\n\t                session.query(Argument).filter_by(prompt_id=prompt_obj.id).all()\n\t            )\n\t            existing_arg_names = {arg.name for arg in existing_args}\n", "            # Delete removed arguments\n\t            for arg in existing_args:\n\t                if arg.name not in prompt_args:\n\t                    session.delete(arg)\n\t            # Add new arguments\n\t            for arg in prompt_args:\n\t                if arg not in existing_arg_names:\n\t                    argument = Argument(\n\t                        prompt_id=prompt_obj.id,\n\t                        name=arg,\n", "                    )\n\t                    session.add(argument)\n\t            session.commit()\n\t    def rename_prompt(self, prompt_name, new_prompt_name):\n\t        prompt = session.query(Prompt).filter_by(name=prompt_name).first()\n\t        if prompt:\n\t            prompt.name = new_prompt_name\n\t            session.commit()\n"]}
{"filename": "agixt/fb/History.py", "chunked_list": ["from datetime import datetime\n\timport yaml\n\timport os\n\tdef export_conversation(agent_name, conversation_name=None):\n\t    if not conversation_name:\n\t        conversation_name = f\"{agent_name} History\"\n\t    history_file = os.path.join(\n\t        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n\t    )\n\t    if os.path.exists(history_file):\n", "        with open(history_file, \"r\") as file:\n\t            history = yaml.safe_load(file)\n\t        return history\n\t    return {\"interactions\": []}\n\tdef get_conversation(agent_name, conversation_name=None, limit=100, page=1):\n\t    if not conversation_name:\n\t        conversation_name = f\"{agent_name} History\"\n\t    history_file = os.path.join(\n\t        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n\t    )\n", "    os.makedirs(os.path.dirname(history_file), exist_ok=True)\n\t    if os.path.exists(history_file):\n\t        with open(history_file, \"r\") as file:\n\t            history = yaml.safe_load(file)\n\t        if not history:\n\t            history = {\"interactions\": []}\n\t        return history\n\t    return new_conversation(agent_name=agent_name, conversation_name=conversation_name)\n\tdef get_conversations(agent_name):\n\t    agent_dir = os.path.join(\"conversations\", agent_name)\n", "    if os.path.exists(agent_dir):\n\t        conversations = os.listdir(agent_dir)\n\t        return [conversation.split(\".\")[0] for conversation in conversations]\n\t    new_conversation(agent_name=agent_name, conversation_name=f\"{agent_name} History\")\n\t    return [f\"{agent_name} History\"]\n\tdef new_conversation(agent_name, conversation_name):\n\t    history = {\"interactions\": []}\n\t    history_file = os.path.join(\n\t        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n\t    )\n", "    os.makedirs(os.path.dirname(history_file), exist_ok=True)\n\t    with open(history_file, \"w\") as file:\n\t        yaml.safe_dump(history, file)\n\t    return history\n\tdef log_interaction(role: str, message: str, agent_name: str, conversation_name=None):\n\t    history = get_conversation(\n\t        agent_name=agent_name, conversation_name=conversation_name\n\t    )\n\t    history_file = os.path.join(\n\t        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n", "    )\n\t    os.makedirs(os.path.dirname(history_file), exist_ok=True)\n\t    if not history:\n\t        history = {\"interactions\": []}\n\t    if \"interactions\" not in history:\n\t        history[\"interactions\"] = []\n\t    history[\"interactions\"].append(\n\t        {\n\t            \"role\": role,\n\t            \"message\": message,\n", "            \"timestamp\": datetime.now().strftime(\"%B %d, %Y %I:%M %p\"),\n\t        }\n\t    )\n\t    with open(history_file, \"w\") as file:\n\t        yaml.safe_dump(history, file)\n\tdef delete_history(agent_name, conversation_name=None):\n\t    if not conversation_name:\n\t        conversation_name = f\"{agent_name} History\"\n\t    history_file = os.path.join(\n\t        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n", "    )\n\t    if os.path.exists(history_file):\n\t        os.remove(history_file)\n\tdef delete_message(agent_name, message, conversation_name=None):\n\t    history = get_conversation(\n\t        agent_name=agent_name, conversation_name=conversation_name\n\t    )\n\t    history[\"interactions\"] = [\n\t        interaction\n\t        for interaction in history[\"interactions\"]\n", "        if interaction[\"message\"] != message\n\t    ]\n\t    if not conversation_name:\n\t        conversation_name = \"history\"\n\t    history_file = os.path.join(\n\t        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n\t    )\n\t    with open(history_file, \"w\") as file:\n\t        yaml.safe_dump(history, file)\n"]}
{"filename": "agixt/fb/Agent.py", "chunked_list": ["import os\n\timport json\n\timport glob\n\timport shutil\n\timport importlib\n\tfrom inspect import signature, Parameter\n\tfrom Providers import Providers\n\tfrom Memories import Memories\n\tfrom Extensions import Extensions\n\tDEFAULT_SETTINGS = {\n", "    \"provider\": \"openai\",\n\t    \"embedder\": \"openai\",\n\t    \"AI_MODEL\": \"gpt-3.5-turbo-16k-0613\",\n\t    \"AI_TEMPERATURE\": \"0.7\",\n\t    \"AI_TOP_P\": \"1\",\n\t    \"MAX_TOKENS\": \"16000\",\n\t    \"helper_agent_name\": \"OpenAI\",\n\t    \"WEBSEARCH_TIMEOUT\": 0,\n\t    \"OPENAI_API_KEY\": \"YOUR_OPENAI_API_KEY_HERE\",\n\t    \"WAIT_BETWEEN_REQUESTS\": 1,\n", "    \"WAIT_AFTER_FAILURE\": 3,\n\t    \"stream\": False,\n\t    \"WORKING_DIRECTORY\": \"./WORKSPACE\",\n\t    \"WORKING_DIRECTORY_RESTRICTED\": True,\n\t    \"AUTONOMOUS_EXECUTION\": False,\n\t}\n\tdef get_agent_file_paths(agent_name):\n\t    base_path = os.path.join(os.getcwd(), \"agents\")\n\t    folder_path = os.path.normpath(os.path.join(base_path, agent_name))\n\t    config_path = os.path.normpath(os.path.join(folder_path, \"config.json\"))\n", "    if not config_path.startswith(base_path) or not folder_path.startswith(base_path):\n\t        raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n\t    if not os.path.exists(folder_path):\n\t        os.mkdir(folder_path)\n\t    return config_path, folder_path\n\tdef add_agent(agent_name, provider_settings=None, commands={}):\n\t    if not agent_name:\n\t        return \"Agent name cannot be empty.\"\n\t    provider_settings = (\n\t        DEFAULT_SETTINGS\n", "        if not provider_settings or provider_settings == {}\n\t        else provider_settings\n\t    )\n\t    config_path, folder_path = get_agent_file_paths(agent_name=agent_name)\n\t    if provider_settings is None or provider_settings == \"\" or provider_settings == {}:\n\t        provider_settings = DEFAULT_SETTINGS\n\t    settings = json.dumps(\n\t        {\n\t            \"commands\": commands,\n\t            \"settings\": provider_settings,\n", "        }\n\t    )\n\t    # Write the settings to the agent config file\n\t    with open(config_path, \"w\") as f:\n\t        f.write(settings)\n\t    return {\"message\": f\"Agent {agent_name} created.\"}\n\tdef delete_agent(agent_name):\n\t    config_path, folder_path = get_agent_file_paths(agent_name=agent_name)\n\t    try:\n\t        if os.path.exists(folder_path):\n", "            shutil.rmtree(folder_path)\n\t        return {\"message\": f\"Agent {agent_name} deleted.\"}, 200\n\t    except:\n\t        return {\"message\": f\"Agent {agent_name} could not be deleted.\"}, 400\n\tdef rename_agent(agent_name, new_name):\n\t    config_path, folder_path = get_agent_file_paths(agent_name=agent_name)\n\t    base_path = os.path.join(os.getcwd(), \"agents\")\n\t    new_agent_folder = os.path.normpath(os.path.join(base_path, new_name))\n\t    if not new_agent_folder.startswith(base_path):\n\t        raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n", "    if os.path.exists(folder_path):\n\t        # Check if the new name is already taken\n\t        if os.path.exists(new_agent_folder):\n\t            # Add a number to the end of the new name\n\t            i = 1\n\t            while os.path.exists(new_agent_folder):\n\t                i += 1\n\t                new_name = f\"{new_name}_{i}\"\n\t                new_agent_folder = os.path.normpath(os.path.join(base_path, new_name))\n\t            if not new_agent_folder.startswith(base_path):\n", "                raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n\t        os.rename(folder_path, new_agent_folder)\n\t        return {\"message\": f\"Agent {agent_name} renamed to {new_name}.\"}, 200\n\tdef get_agents():\n\t    agents_dir = \"agents\"\n\t    if not os.path.exists(agents_dir):\n\t        os.makedirs(agents_dir)\n\t    agents = [\n\t        dir_name\n\t        for dir_name in os.listdir(agents_dir)\n", "        if os.path.isdir(os.path.join(agents_dir, dir_name))\n\t    ]\n\t    output = []\n\t    if agents:\n\t        for agent in agents:\n\t            output.append({\"name\": agent, \"status\": False})\n\t    return output\n\tclass Agent:\n\t    def __init__(self, agent_name=None):\n\t        self.agent_name = agent_name if agent_name is not None else \"AGiXT\"\n", "        self.config_path, self.folder_path = get_agent_file_paths(\n\t            agent_name=self.agent_name\n\t        )\n\t        self.AGENT_CONFIG = self.get_agent_config()\n\t        if \"settings\" in self.AGENT_CONFIG:\n\t            self.PROVIDER_SETTINGS = self.AGENT_CONFIG[\"settings\"]\n\t            if self.PROVIDER_SETTINGS == {}:\n\t                self.PROVIDER_SETTINGS = DEFAULT_SETTINGS\n\t            if \"provider\" in self.PROVIDER_SETTINGS:\n\t                self.AI_PROVIDER = self.PROVIDER_SETTINGS[\"provider\"]\n", "                self.PROVIDER = Providers(self.AI_PROVIDER, **self.PROVIDER_SETTINGS)\n\t                self._load_agent_config_keys(\n\t                    [\"AI_MODEL\", \"AI_TEMPERATURE\", \"MAX_TOKENS\", \"AUTONOMOUS_EXECUTION\"]\n\t                )\n\t            if \"AI_MODEL\" in self.PROVIDER_SETTINGS:\n\t                self.AI_MODEL = self.PROVIDER_SETTINGS[\"AI_MODEL\"]\n\t                if self.AI_MODEL == \"\":\n\t                    self.AI_MODEL = \"default\"\n\t            else:\n\t                self.AI_MODEL = \"openassistant\"\n", "            if \"embedder\" in self.PROVIDER_SETTINGS:\n\t                self.EMBEDDER = self.PROVIDER_SETTINGS[\"embedder\"]\n\t            else:\n\t                if self.AI_PROVIDER == \"openai\":\n\t                    self.EMBEDDER = \"openai\"\n\t                else:\n\t                    self.EMBEDDER = \"default\"\n\t            if \"MAX_TOKENS\" in self.PROVIDER_SETTINGS:\n\t                self.MAX_TOKENS = self.PROVIDER_SETTINGS[\"MAX_TOKENS\"]\n\t            else:\n", "                self.MAX_TOKENS = 4000\n\t            if \"AUTONOMOUS_EXECUTION\" in self.PROVIDER_SETTINGS:\n\t                self.AUTONOMOUS_EXECUTION = self.PROVIDER_SETTINGS[\n\t                    \"AUTONOMOUS_EXECUTION\"\n\t                ]\n\t                if isinstance(self.AUTONOMOUS_EXECUTION, str):\n\t                    self.AUTONOMOUS_EXECUTION = self.AUTONOMOUS_EXECUTION.lower()\n\t                    self.AUTONOMOUS_EXECUTION = (\n\t                        True if self.AUTONOMOUS_EXECUTION == \"true\" else False\n\t                    )\n", "            else:\n\t                self.AUTONOMOUS_EXECUTION = True\n\t            self.commands = self.load_commands()\n\t            self.available_commands = Extensions(\n\t                agent_config=self.AGENT_CONFIG\n\t            ).get_available_commands()\n\t            self.clean_agent_config_commands()\n\t    def get_memories(self):\n\t        return Memories(self.agent_name, self.AGENT_CONFIG)\n\t    async def execute(self, command_name, command_args):\n", "        return await Extensions(agent_config=self.AGENT_CONFIG).execute_command(\n\t            command_name=command_name, command_args=command_args\n\t        )\n\t    async def instruct(self, prompt, tokens):\n\t        if not prompt:\n\t            return \"\"\n\t        answer = await self.PROVIDER.instruct(prompt=prompt, tokens=tokens)\n\t        return answer\n\t    def _load_agent_config_keys(self, keys):\n\t        for key in keys:\n", "            if key in self.AGENT_CONFIG:\n\t                setattr(self, key, self.AGENT_CONFIG[key])\n\t    def clean_agent_config_commands(self):\n\t        for command in self.commands:\n\t            friendly_name = command[0]\n\t            if friendly_name not in self.AGENT_CONFIG[\"commands\"]:\n\t                self.AGENT_CONFIG[\"commands\"][friendly_name] = False\n\t        for command in list(self.AGENT_CONFIG[\"commands\"]):\n\t            if command not in [cmd[0] for cmd in self.commands]:\n\t                del self.AGENT_CONFIG[\"commands\"][command]\n", "        with open(self.config_path, \"w\") as f:\n\t            json.dump(self.AGENT_CONFIG, f)\n\t    def get_commands_string(self):\n\t        if len(self.available_commands) == 0:\n\t            return None\n\t        enabled_commands = filter(\n\t            lambda command: command.get(\"enabled\", True), self.available_commands\n\t        )\n\t        if not enabled_commands:\n\t            return None\n", "        friendly_names = map(\n\t            lambda command: f\"`{command['friendly_name']}` - Arguments: {command['args']}\",\n\t            enabled_commands,\n\t        )\n\t        command_list = \"\\n\".join(friendly_names)\n\t        return f\"Commands Available To Complete Task:\\n{command_list}\\n\\n\"\n\t    def get_provider(self):\n\t        config_file = self.get_agent_config()\n\t        if \"provider\" in config_file:\n\t            return config_file[\"provider\"]\n", "        else:\n\t            return \"openai\"\n\t    def get_command_params(self, func):\n\t        params = {}\n\t        sig = signature(func)\n\t        for name, param in sig.parameters.items():\n\t            if param.default == Parameter.empty:\n\t                params[name] = None\n\t            else:\n\t                params[name] = param.default\n", "        return params\n\t    def load_commands(self):\n\t        commands = []\n\t        command_files = glob.glob(\"extensions/*.py\")\n\t        for command_file in command_files:\n\t            module_name = os.path.splitext(os.path.basename(command_file))[0]\n\t            module = importlib.import_module(f\"extensions.{module_name}\")\n\t            command_class = getattr(module, module_name.lower())()\n\t            if hasattr(command_class, \"commands\"):\n\t                for command_name, command_function in command_class.commands.items():\n", "                    params = self.get_command_params(command_function)\n\t                    commands.append((command_name, command_function.__name__, params))\n\t        return commands\n\t    def get_agent_config(self):\n\t        while True:\n\t            if os.path.exists(self.config_path):\n\t                try:\n\t                    with open(self.config_path, \"r\") as f:\n\t                        file_content = f.read().strip()\n\t                        if file_content:\n", "                            return json.loads(file_content)\n\t                except:\n\t                    None\n\t            add_agent(agent_name=self.agent_name)\n\t            return self.get_agent_config()\n\t    def update_agent_config(self, new_config, config_key):\n\t        if os.path.exists(self.config_path):\n\t            with open(self.config_path, \"r\") as f:\n\t                current_config = json.load(f)\n\t            # Ensure the config_key is present in the current configuration\n", "            if config_key not in current_config:\n\t                current_config[config_key] = {}\n\t            # Update the specified key with new_config while preserving other keys and values\n\t            for key, value in new_config.items():\n\t                current_config[config_key][key] = value\n\t            # Save the updated configuration back to the file\n\t            with open(self.config_path, \"w\") as f:\n\t                json.dump(current_config, f)\n\t            return f\"Agent {self.agent_name} configuration updated.\"\n\t        else:\n", "            return f\"Agent {self.agent_name} configuration not found.\"\n\t    def wipe_agent_memories(self):\n\t        memories_folder = os.path.normpath(\n\t            os.path.join(os.getcwd(), self.agent_name, \"memories\")\n\t        )\n\t        if not memories_folder.startswith(os.getcwd()):\n\t            raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n\t        if os.path.exists(memories_folder):\n\t            shutil.rmtree(memories_folder)\n"]}
{"filename": "agixt/fb/Chain.py", "chunked_list": ["import os\n\timport json\n\timport logging\n\tfrom agixtsdk import AGiXTSDK\n\tfrom Extensions import Extensions\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tApiClient = AGiXTSDK(\n\t    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n\t)\n", "def create_command_suggestion_chain(agent_name, command_name, command_args):\n\t    chain = Chain()\n\t    chains = chain.get_chains()\n\t    chain_name = f\"{agent_name} Command Suggestions\"\n\t    if chain_name in chains:\n\t        step = int(chain.get_chain(chain_name=chain_name)[\"steps\"][-1][\"step\"]) + 1\n\t    else:\n\t        chain.add_chain(chain_name=chain_name)\n\t        step = 1\n\t    chain.add_chain_step(\n", "        chain_name=chain_name,\n\t        agent_name=agent_name,\n\t        step_number=step,\n\t        prompt_type=\"Command\",\n\t        prompt={\n\t            \"command_name\": command_name,\n\t            **command_args,\n\t        },\n\t    )\n\t    return f\"The command has been added to a chain called '{agent_name} Command Suggestions' for you to review and execute manually.\"\n", "def get_chain_file_path(chain_name):\n\t    base_path = os.path.join(os.getcwd(), \"chains\")\n\t    folder_path = os.path.normpath(os.path.join(base_path, chain_name))\n\t    file_path = os.path.normpath(os.path.join(base_path, f\"{chain_name}.json\"))\n\t    if not file_path.startswith(base_path) or not folder_path.startswith(base_path):\n\t        raise ValueError(\"Invalid path, chain name must not contain slashes.\")\n\t    if not os.path.exists(folder_path):\n\t        os.mkdir(folder_path)\n\t    return file_path\n\tdef get_chain_responses_file_path(chain_name):\n", "    base_path = os.path.join(os.getcwd(), \"chains\")\n\t    file_path = os.path.normpath(os.path.join(base_path, chain_name, \"responses.json\"))\n\t    if not file_path.startswith(base_path):\n\t        raise ValueError(\"Invalid path, chain name must not contain slashes.\")\n\t    return file_path\n\tclass Chain:\n\t    def import_chain(self, chain_name: str, steps: dict):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        steps = steps[\"steps\"] if \"steps\" in steps else steps\n\t        with open(file_path, \"w\") as f:\n", "            json.dump({\"chain_name\": chain_name, \"steps\": steps}, f)\n\t        return f\"Chain '{chain_name}' imported.\"\n\t    def get_chain(self, chain_name):\n\t        try:\n\t            file_path = get_chain_file_path(chain_name=chain_name)\n\t            with open(file_path, \"r\") as f:\n\t                chain_data = json.load(f)\n\t            return chain_data\n\t        except:\n\t            return {}\n", "    def get_chains(self):\n\t        chains = [\n\t            f.replace(\".json\", \"\") for f in os.listdir(\"chains\") if f.endswith(\".json\")\n\t        ]\n\t        return chains\n\t    def add_chain(self, chain_name):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        chain_data = {\"chain_name\": chain_name, \"steps\": []}\n\t        with open(file_path, \"w\") as f:\n\t            json.dump(chain_data, f)\n", "    def rename_chain(self, chain_name, new_name):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        new_file_path = get_chain_file_path(chain_name=new_name)\n\t        os.rename(\n\t            os.path.join(file_path),\n\t            os.path.join(new_file_path),\n\t        )\n\t        chain_data = self.get_chain(chain_name=new_name)\n\t        chain_data[\"chain_name\"] = new_name\n\t        with open(new_file_path, \"w\") as f:\n", "            json.dump(chain_data, f)\n\t    def add_chain_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        chain_data = self.get_chain(chain_name=chain_name)\n\t        chain_data[\"steps\"].append(\n\t            {\n\t                \"step\": step_number,\n\t                \"agent_name\": agent_name,\n\t                \"prompt_type\": prompt_type,\n\t                \"prompt\": prompt,\n", "            }\n\t        )\n\t        with open(file_path, \"w\") as f:\n\t            json.dump(chain_data, f)\n\t    def update_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        chain_data = self.get_chain(chain_name=chain_name)\n\t        for step in chain_data[\"steps\"]:\n\t            if step[\"step\"] == step_number:\n\t                step[\"agent_name\"] = agent_name\n", "                step[\"prompt_type\"] = prompt_type\n\t                step[\"prompt\"] = prompt\n\t                break\n\t        with open(file_path, \"w\") as f:\n\t            json.dump(chain_data, f)\n\t    def delete_step(self, chain_name, step_number):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        chain_data = self.get_chain(chain_name=chain_name)\n\t        chain_data[\"steps\"] = [\n\t            step for step in chain_data[\"steps\"] if step[\"step\"] != step_number\n", "        ]\n\t        with open(file_path, \"w\") as f:\n\t            json.dump(chain_data, f)\n\t    def delete_chain(self, chain_name):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        os.remove(file_path)\n\t    def get_step(self, chain_name, step_number):\n\t        chain_data = self.get_chain(chain_name=chain_name)\n\t        for step in chain_data[\"steps\"]:\n\t            if step[\"step\"] == step_number:\n", "                return step\n\t        return None\n\t    def get_steps(self, chain_name):\n\t        chain_data = self.get_chain(chain_name=chain_name)\n\t        return chain_data[\"steps\"]\n\t    def move_step(self, chain_name, current_step_number, new_step_number):\n\t        file_path = get_chain_file_path(chain_name=chain_name)\n\t        chain_data = self.get_chain(chain_name=chain_name)\n\t        if not 1 <= new_step_number <= len(\n\t            chain_data[\"steps\"]\n", "        ) or current_step_number not in [step[\"step\"] for step in chain_data[\"steps\"]]:\n\t            print(f\"Error: Invalid step numbers.\")\n\t            return\n\t        moved_step = None\n\t        for step in chain_data[\"steps\"]:\n\t            if step[\"step\"] == current_step_number:\n\t                moved_step = step\n\t                chain_data[\"steps\"].remove(step)\n\t                break\n\t        for step in chain_data[\"steps\"]:\n", "            if new_step_number < current_step_number:\n\t                if new_step_number <= step[\"step\"] < current_step_number:\n\t                    step[\"step\"] += 1\n\t            else:\n\t                if current_step_number < step[\"step\"] <= new_step_number:\n\t                    step[\"step\"] -= 1\n\t        moved_step[\"step\"] = new_step_number\n\t        chain_data[\"steps\"].append(moved_step)\n\t        chain_data[\"steps\"] = sorted(chain_data[\"steps\"], key=lambda x: x[\"step\"])\n\t        with open(file_path, \"w\") as f:\n", "            json.dump(chain_data, f)\n\t    def get_step_response(self, chain_name, step_number=\"all\"):\n\t        file_path = get_chain_responses_file_path(chain_name=chain_name)\n\t        try:\n\t            with open(file_path, \"r\") as f:\n\t                responses = json.load(f)\n\t            if step_number == \"all\":\n\t                return responses\n\t            else:\n\t                data = responses.get(str(step_number))\n", "                if isinstance(data, dict) and \"response\" in data:\n\t                    data = data[\"response\"]\n\t                logging.info(f\"Step {step_number} response: {data}\")\n\t                return data\n\t        except:\n\t            return \"\"\n\t    def get_chain_responses(self, chain_name):\n\t        file_path = get_chain_responses_file_path(chain_name=chain_name)\n\t        try:\n\t            with open(file_path, \"r\") as f:\n", "                responses = json.load(f)\n\t            return responses\n\t        except:\n\t            return {}\n\t    def get_step_content(self, chain_name, prompt_content, user_input, agent_name):\n\t        if isinstance(prompt_content, dict):\n\t            new_prompt_content = {}\n\t            for arg, value in prompt_content.items():\n\t                if isinstance(value, str):\n\t                    if \"{user_input}\" in value:\n", "                        value = value.replace(\"{user_input}\", user_input)\n\t                    if \"{agent_name}\" in value:\n\t                        value = value.replace(\"{agent_name}\", agent_name)\n\t                    if \"{STEP\" in value:\n\t                        step_count = value.count(\"{STEP\")\n\t                        for i in range(step_count):\n\t                            new_step_number = int(value.split(\"{STEP\")[1].split(\"}\")[0])\n\t                            step_response = self.get_step_response(\n\t                                chain_name=chain_name, step_number=new_step_number\n\t                            )\n", "                            if step_response:\n\t                                resp = (\n\t                                    step_response[0]\n\t                                    if isinstance(step_response, list)\n\t                                    else step_response\n\t                                )\n\t                                value = value.replace(\n\t                                    f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n\t                                )\n\t                new_prompt_content[arg] = value\n", "            return new_prompt_content\n\t        elif isinstance(prompt_content, str):\n\t            new_prompt_content = prompt_content\n\t            if \"{user_input}\" in prompt_content:\n\t                new_prompt_content = new_prompt_content.replace(\n\t                    \"{user_input}\", user_input\n\t                )\n\t            if \"{agent_name}\" in new_prompt_content:\n\t                new_prompt_content = new_prompt_content.replace(\n\t                    \"{agent_name}\", agent_name\n", "                )\n\t            if \"{STEP\" in prompt_content:\n\t                step_count = prompt_content.count(\"{STEP\")\n\t                for i in range(step_count):\n\t                    new_step_number = int(\n\t                        prompt_content.split(\"{STEP\")[1].split(\"}\")[0]\n\t                    )\n\t                    step_response = self.get_step_response(\n\t                        chain_name=chain_name, step_number=new_step_number\n\t                    )\n", "                    if step_response:\n\t                        resp = (\n\t                            step_response[0]\n\t                            if isinstance(step_response, list)\n\t                            else step_response\n\t                        )\n\t                        new_prompt_content = new_prompt_content.replace(\n\t                            f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n\t                        )\n\t            return new_prompt_content\n", "        else:\n\t            return prompt_content\n\t    async def run_chain_step(\n\t        self, step: dict = {}, chain_name=\"\", user_input=\"\", agent_override=\"\"\n\t    ):\n\t        if step:\n\t            if \"prompt_type\" in step:\n\t                if agent_override != \"\":\n\t                    agent_name = agent_override\n\t                else:\n", "                    agent_name = step[\"agent_name\"]\n\t                prompt_type = step[\"prompt_type\"]\n\t                step_number = step[\"step\"]\n\t                if \"prompt_name\" in step[\"prompt\"]:\n\t                    prompt_name = step[\"prompt\"][\"prompt_name\"]\n\t                else:\n\t                    prompt_name = \"\"\n\t                args = self.get_step_content(\n\t                    chain_name=chain_name,\n\t                    prompt_content=step[\"prompt\"],\n", "                    user_input=user_input,\n\t                    agent_name=step[\"agent_name\"],\n\t                )\n\t                if \"conversation_name\" not in args:\n\t                    args[\"conversation_name\"] = f\"Chain Execution History: {chain_name}\"\n\t                if prompt_type == \"Command\":\n\t                    return await Extensions().execute_command(\n\t                        command_name=step[\"prompt\"][\"command_name\"], command_args=args\n\t                    )\n\t                elif prompt_type == \"Prompt\":\n", "                    result = ApiClient.prompt_agent(\n\t                        agent_name=agent_name,\n\t                        prompt_name=prompt_name,\n\t                        prompt_args={\n\t                            \"chain_name\": chain_name,\n\t                            \"step_number\": step_number,\n\t                            \"user_input\": user_input,\n\t                            **args,\n\t                        },\n\t                    )\n", "                elif prompt_type == \"Chain\":\n\t                    result = ApiClient.run_chain(\n\t                        chain_name=args[\"chain\"],\n\t                        user_input=args[\"input\"],\n\t                        agent_name=agent_name,\n\t                        all_responses=args[\"all_responses\"]\n\t                        if \"all_responses\" in args\n\t                        else False,\n\t                        from_step=args[\"from_step\"] if \"from_step\" in args else 1,\n\t                    )\n", "        if result:\n\t            if isinstance(result, dict) and \"response\" in result:\n\t                result = result[\"response\"]\n\t            if result == \"Unable to retrieve data.\":\n\t                result = None\n\t            return result\n\t        else:\n\t            return None\n\t    async def run_chain(\n\t        self,\n", "        chain_name,\n\t        user_input=None,\n\t        all_responses=True,\n\t        agent_override=\"\",\n\t        from_step=1,\n\t    ):\n\t        chain_data = ApiClient.get_chain(chain_name=chain_name)\n\t        if chain_data == {}:\n\t            return f\"Chain `{chain_name}` not found.\"\n\t        logging.info(f\"Running chain '{chain_name}'\")\n", "        responses = {}  # Create a dictionary to hold responses.\n\t        last_response = \"\"\n\t        for step_data in chain_data[\"steps\"]:\n\t            if int(step_data[\"step\"]) >= int(from_step):\n\t                if \"prompt\" in step_data and \"step\" in step_data:\n\t                    step = {}\n\t                    step[\"agent_name\"] = (\n\t                        agent_override\n\t                        if agent_override != \"\"\n\t                        else step_data[\"agent_name\"]\n", "                    )\n\t                    step[\"prompt_type\"] = step_data[\"prompt_type\"]\n\t                    step[\"prompt\"] = step_data[\"prompt\"]\n\t                    step[\"step\"] = step_data[\"step\"]\n\t                    logging.info(\n\t                        f\"Running step {step_data['step']} with agent {step['agent_name']}.\"\n\t                    )\n\t                    try:\n\t                        step_response = await self.run_chain_step(\n\t                            step=step,\n", "                            chain_name=chain_name,\n\t                            user_input=user_input,\n\t                            agent_override=agent_override,\n\t                        )  # Get the response of the current step.\n\t                    except Exception as e:\n\t                        logging.error(e)\n\t                        step_response = None\n\t                    if step_response == None:\n\t                        return f\"Chain failed to complete, it failed on step {step_data['step']}. You can resume by starting the chain from the step that failed.\"\n\t                    step[\"response\"] = step_response\n", "                    last_response = step_response\n\t                    logging.info(f\"Last response: {last_response}\")\n\t                    responses[step_data[\"step\"]] = step  # Store the response.\n\t                    logging.info(f\"Step {step_data['step']} response: {step_response}\")\n\t                    # Write the response to the chain responses file.\n\t                    file_path = get_chain_responses_file_path(chain_name=chain_name)\n\t                    with open(file_path, \"w\") as f:\n\t                        json.dump(responses, f)\n\t        if all_responses:\n\t            return responses\n", "        else:\n\t            # Return only the last response in the chain.\n\t            return last_response\n"]}
{"filename": "agixt/fb/Prompts.py", "chunked_list": ["import os\n\tdef get_prompt_file_path(prompt_name, prompt_category=\"Default\"):\n\t    base_path = os.path.join(os.getcwd(), \"prompts\")\n\t    base_model_path = os.path.normpath(\n\t        os.path.join(os.getcwd(), \"prompts\", prompt_category)\n\t    )\n\t    model_prompt_file = os.path.normpath(\n\t        os.path.join(base_model_path, f\"{prompt_name}.txt\")\n\t    )\n\t    default_prompt_file = os.path.normpath(\n", "        os.path.join(base_path, \"Default\", f\"{prompt_name}.txt\")\n\t    )\n\t    if (\n\t        not base_model_path.startswith(base_path)\n\t        or not model_prompt_file.startswith(base_model_path)\n\t        or not default_prompt_file.startswith(base_path)\n\t    ):\n\t        raise ValueError(\n\t            \"Invalid file path. Prompt name cannot contain '/', '\\\\' or '..' in\"\n\t        )\n", "    if not os.path.exists(base_path):\n\t        os.mkdir(base_path)\n\t    if not os.path.exists(base_model_path):\n\t        os.mkdir(base_model_path)\n\t    prompt_file = (\n\t        model_prompt_file if os.path.isfile(model_prompt_file) else default_prompt_file\n\t    )\n\t    return prompt_file\n\tclass Prompts:\n\t    def add_prompt(self, prompt_name, prompt, prompt_category_name=\"Default\"):\n", "        # if prompts folder does not exist, create it\n\t        file_path = get_prompt_file_path(\n\t            prompt_name=prompt_name, prompt_category=prompt_category_name\n\t        )\n\t        # if prompt file does not exist, create it\n\t        if not os.path.exists(file_path):\n\t            with open(file_path, \"w\") as f:\n\t                f.write(prompt)\n\t    def get_prompt(self, prompt_name, prompt_category=\"Default\"):\n\t        prompt_file = get_prompt_file_path(\n", "            prompt_name=prompt_name, prompt_category=prompt_category\n\t        )\n\t        with open(prompt_file, \"r\") as f:\n\t            prompt = f.read()\n\t        return prompt\n\t    def get_prompts(self):\n\t        # Get all files in prompts folder that end in .txt and replace .txt with empty string\n\t        prompts = []\n\t        # For each folder in prompts folder, get all files that end in .txt and replace .txt with empty string\n\t        for folder in os.listdir(\"prompts\"):\n", "            if os.path.isdir(os.path.join(\"prompts\", folder)):\n\t                for file in os.listdir(os.path.join(\"prompts\", folder)):\n\t                    if file.endswith(\".txt\"):\n\t                        prompts.append(file.replace(\".txt\", \"\"))\n\t        return prompts\n\t    def get_prompt_args(self, prompt_text):\n\t        # Find anything in the file between { and } and add them to a list to return\n\t        prompt_vars = []\n\t        for word in prompt_text.split():\n\t            if word.startswith(\"{\") and word.endswith(\"}\"):\n", "                prompt_vars.append(word[1:-1])\n\t        return prompt_vars\n\t    def delete_prompt(self, prompt_name):\n\t        prompt_file = get_prompt_file_path(prompt_name=prompt_name)\n\t        os.remove(prompt_file)\n\t    def update_prompt(self, prompt_name, prompt):\n\t        prompt_file = get_prompt_file_path(prompt_name=prompt_name)\n\t        with open(prompt_file, \"w\") as f:\n\t            f.write(prompt)\n\t    def rename_prompt(self, prompt_name, new_prompt_name):\n", "        prompt_file = get_prompt_file_path(prompt_name=prompt_name)\n\t        new_prompt_file = get_prompt_file_path(prompt_name=new_prompt_name)\n\t        os.rename(prompt_file, new_prompt_file)\n"]}
