{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\tsetup(\n\t    name='xapi-python',\n\t    author='Paweł Knioła',\n\t    author_email='pawel.kn@gmail.com',\n\t    description='The xStation5 API Python library',\n\t    long_description=open('README.md', encoding='utf-8').read(),\n\t    license='MIT',\n\t    keywords='python python3 bitcoin trading websocket trading-api forex xapi forex-trading exchange-api forex-data xstation xstation5 xtb xopenhub forex-api xopenhub-api xtb-api xstation-api x-trade-brokers bfbcapital',\n\t    url='https://github.com/pawelkn/xapi-python',\n", "    classifiers=[\n\t        \"Operating System :: OS Independent\",\n\t        \"License :: OSI Approved :: MIT License\",\n\t        \"Programming Language :: Python :: 3.7\",\n\t        \"Programming Language :: Python :: 3.8\",\n\t        \"Programming Language :: Python :: 3.9\",\n\t        \"Programming Language :: Python :: 3.10\",\n\t        \"Programming Language :: Python :: 3.11\",\n\t        \"Programming Language :: Python :: 3.12\"\n\t    ],\n", "    python_requires='>=3.7',\n\t    version=\"0.1.6\",\n\t    packages=['xapi'],\n\t)"]}
{"filename": "tests/test_xapi.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import AsyncMock, patch\n\tfrom xapi import connect, XAPI, Socket, Stream, LoginFailed\n\tclass TestXAPI(unittest.IsolatedAsyncioTestCase):\n\t    async def test_xapi(self):\n\t        async with XAPI() as x:\n\t            self.assertIsInstance(x.socket, Socket)\n\t            self.assertIsInstance(x.stream, Stream)\n\t    @patch('xapi.xapi.Stream', return_value=AsyncMock())\n\t    @patch('xapi.xapi.Socket', return_value=AsyncMock())\n", "    async def test_connect_successful_login(self, SocketMock, _):\n\t        SocketMock().login.return_value = {\"status\": True, \"streamSessionId\": \"abc123\"}\n\t        async with await connect(\"myaccount\", \"mypassword\", \"ws.xtb.com\", \"real\", False) as x:\n\t            self.assertIsInstance(x, XAPI)\n\t            self.assertEqual(x.stream.safe, False)\n\t            self.assertEqual(x.socket.safe, False)\n\t            self.assertEqual(x.stream.streamSessionId, \"abc123\")\n\t            x.socket.connect.assert_called_once_with(\"wss://ws.xtb.com/real\")\n\t            x.stream.connect.assert_called_once_with(\"wss://ws.xtb.com/realStream\")\n\t            x.socket.login.assert_called_once_with(\"myaccount\", \"mypassword\")\n", "    @patch('xapi.xapi.Stream', return_value=AsyncMock())\n\t    @patch('xapi.xapi.Socket', return_value=AsyncMock())\n\t    async def test_connect_failed_login(self, SocketMock, _):\n\t        SocketMock().login.return_value = AsyncMock(return_value = {\"status\": False, \"errorCode\": 1001})\n\t        with self.assertRaises(LoginFailed):\n\t            await connect(\"myaccount\", \"mypassword\", \"ws.xtb.com\", \"real\", False)\n"]}
{"filename": "tests/test_stream.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import AsyncMock\n\tfrom xapi import Stream, TradeCmd, TradeType, PeriodCode\n\tclass TestStream(unittest.IsolatedAsyncioTestCase):\n\t    def setUp(self):\n\t        self.stream = Stream()\n\t        self.stream._request = AsyncMock()\n\t        self.stream.streamSessionId = \"abc123\"\n\t    async def test_getBalance(self):\n\t        await self.stream.getBalance()\n", "        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getBalance\",\n\t            \"streamSessionId\": \"abc123\"\n\t        })\n\t    async def test_stopBalance(self):\n\t        await self.stream.stopBalance()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"stopBalance\"\n\t        })\n\t    async def test_getCandles(self):\n", "        await self.stream.getCandles(\"symbol\")\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getCandles\",\n\t            \"streamSessionId\": \"abc123\",\n\t            \"symbol\": \"symbol\"\n\t        })\n\t    async def test_stopCandles(self):\n\t        await self.stream.stopCandles(\"symbol\")\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"stopCandles\",\n", "            \"symbol\": \"symbol\"\n\t        })\n\t    async def test_getKeepAlive(self):\n\t        await self.stream.getKeepAlive()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getKeepAlive\",\n\t            \"streamSessionId\": \"abc123\"\n\t        })\n\t    async def test_stopKeepAlive(self):\n\t        await self.stream.stopKeepAlive()\n", "        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"stopKeepAlive\"\n\t        })\n\t    async def test_getNews(self):\n\t        await self.stream.getNews()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getNews\",\n\t            \"streamSessionId\": \"abc123\"\n\t        })\n\t    async def test_stopNews(self):\n", "        await self.stream.stopNews()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"stopNews\"\n\t        }\n\t        )\n\t    async def test_getProfits(self):\n\t        await self.stream.getProfits()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getProfits\",\n\t            \"streamSessionId\": \"abc123\"\n", "        })\n\t    async def test_stopProfits(self):\n\t        await self.stream.stopProfits()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"stopProfits\"\n\t        })\n\t    async def test_getTickPrices(self):\n\t        await self.stream.getTickPrices(\"symbol\", 123, 456)\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getTickPrices\",\n", "            \"streamSessionId\": \"abc123\",\n\t            \"symbol\": \"symbol\",\n\t            \"minArrivalTime\": 123,\n\t            \"maxLevel\": 456\n\t        })\n\t    async def test_stopTickPrices(self):\n\t        await self.stream.stopTickPrices(\"symbol\")\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"stopTickPrices\",\n\t            \"symbol\": \"symbol\"\n", "        })\n\t    async def test_getTrades(self):\n\t        await self.stream.getTrades()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getTrades\",\n\t            \"streamSessionId\": \"abc123\"\n\t        })\n\t    async def test_stopTrades(self):\n\t        await self.stream.stopTrades()\n\t        self.stream._request.assert_awaited_once_with({\n", "            \"command\": \"stopTrades\"\n\t        })\n\t    async def test_getTradeStatus(self):\n\t        await self.stream.getTradeStatus()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"getTradeStatus\",\n\t            \"streamSessionId\": \"abc123\"\n\t        })\n\t    async def test_stopTradeStatus(self):\n\t        await self.stream.stopTradeStatus()\n", "        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"stopTradeStatus\"\n\t        })\n\t    async def test_ping(self):\n\t        await self.stream.ping()\n\t        self.stream._request.assert_awaited_once_with({\n\t            \"command\": \"ping\",\n\t            \"streamSessionId\": \"abc123\"\n\t        })"]}
{"filename": "tests/test_connection.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import AsyncMock, patch\n\timport websockets.client\n\timport websockets.exceptions\n\timport websockets.datastructures\n\timport socket\n\timport json\n\timport asyncio\n\timport time\n\tfrom xapi import Connection, ConnectionClosed\n", "class TestConnection(unittest.IsolatedAsyncioTestCase):\n\t    async def test_connect_websocket_exception(self):\n\t        c = Connection()\n\t        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n\t            mocked_connect.side_effect = websockets.exceptions.InvalidStatusCode(status_code=404, headers=websockets.datastructures.Headers())\n\t            with self.assertRaises(ConnectionClosed) as cm:\n\t                await c.connect(\"ws://127.0.0.1:9000\")\n\t            self.assertEqual(str(cm.exception), \"WebSocket exception: server rejected WebSocket connection: HTTP 404\")\n\t    async def test_connect_socket_gaierror(self):\n\t        c = Connection()\n", "        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n\t            mocked_connect.side_effect = socket.gaierror()\n\t            with self.assertRaises(ConnectionClosed) as cm:\n\t                await c.connect(\"ws://127.0.0.1:9000\")\n\t            self.assertEqual(str(cm.exception), \"Hostname cannot be resolved\")\n\t    async def test_connect_timeout_error(self):\n\t        c = Connection()\n\t        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n\t            mocked_connect.side_effect = asyncio.exceptions.TimeoutError()\n\t            with self.assertRaises(ConnectionClosed) as cm:\n", "                await c.connect(\"ws://127.0.0.1:9000\")\n\t            self.assertEqual(str(cm.exception), \"Connection timed out\")\n\t    async def test_connect_refused_error(self):\n\t        c = Connection()\n\t        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n\t            mocked_connect.side_effect = ConnectionRefusedError()\n\t            with self.assertRaises(ConnectionClosed) as cm:\n\t                await c.connect(\"ws://127.0.0.1:9000\")\n\t            self.assertEqual(str(cm.exception), \"Connection refused\")\n\t    async def test_disconnect(self):\n", "        c = Connection()\n\t        c._conn = AsyncMock(spec=websockets.client.WebSocketClientProtocol)\n\t        await c.disconnect()\n\t        self.assertIsNone(c._conn)\n\t    async def test_disconnect_connection_closed(self):\n\t        c = Connection()\n\t        c._conn = AsyncMock(spec=websockets.client.WebSocketClientProtocol)\n\t        c._conn.close.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n\t        await c.disconnect()\n\t        self.assertIsNone(c._conn)\n", "    async def test_listen_with_connection(self):\n\t        c = Connection()\n\t        c._conn = AsyncMock()\n\t        c._conn.__aiter__.return_value = iter(['{\"message\": \"Hello, world!\"}'])\n\t        messages = []\n\t        async for message in c.listen():\n\t            messages.append(message)\n\t        self.assertEqual(messages, [{\"message\": \"Hello, world!\"}])\n\t    async def test_listen_without_connection(self):\n\t        c = Connection()\n", "        with self.assertRaises(ConnectionClosed) as cm:\n\t            async for _ in c.listen(): pass\n\t        self.assertEqual(str(cm.exception), \"Not connected\")\n\t    async def test_listen_connection_closed(self):\n\t        c = Connection()\n\t        c._conn = AsyncMock()\n\t        c._conn.__aiter__.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n\t        with self.assertRaises(ConnectionClosed) as cm:\n\t            async for _ in c.listen(): pass\n\t        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")\n", "    async def test_request_with_connection(self):\n\t        conn = Connection()\n\t        conn._conn = AsyncMock()\n\t        command = {\"command\": \"test\"}\n\t        await conn._request(command)\n\t        conn._conn.send.assert_called_once_with(json.dumps(command))\n\t    async def test_request_without_connection(self):\n\t        conn = Connection()\n\t        command = {\"command\": \"test\"}\n\t        with self.assertRaises(ConnectionClosed) as cm:\n", "            await conn._request(command)\n\t        self.assertEqual(str(cm.exception), \"Not connected\")\n\t    async def test_request_with_delay(self):\n\t        conn = Connection()\n\t        conn._conn = AsyncMock()\n\t        command = {\"command\": \"test\"}\n\t        # first run without delay\n\t        await conn._request(command)\n\t        # second run postponed by at least 200ms\n\t        start_time = time.time()\n", "        await conn._request(command)\n\t        end_time = time.time()\n\t        elapsed_time = end_time - start_time\n\t        self.assertGreaterEqual(elapsed_time, 0.2)\n\t    async def test_request_connection_closed(self):\n\t        conn = Connection()\n\t        conn._conn = AsyncMock()\n\t        conn._conn.send.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n\t        command = {\"command\": \"test\"}\n\t        with self.assertRaises(ConnectionClosed) as cm:\n", "            await conn._request(command)\n\t        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")\n\t    async def test_transaction_with_connection(self):\n\t        conn = Connection()\n\t        conn._conn = AsyncMock()\n\t        command = {\"command\": \"test\"}\n\t        response = {\"response\": \"test\"}\n\t        conn._conn.recv.return_value = json.dumps(response)\n\t        result = await conn._transaction(command)\n\t        conn._conn.send.assert_called_once_with(json.dumps(command))\n", "        conn._conn.recv.assert_called_once()\n\t        self.assertEqual(result, response)\n\t    async def test_transaction_without_connection(self):\n\t        conn = Connection()\n\t        command = {\"command\": \"test\"}\n\t        with self.assertRaises(ConnectionClosed) as cm:\n\t            await conn._transaction(command)\n\t        self.assertEqual(str(cm.exception), \"Not connected\")\n\t    async def test_transaction_with_delay(self):\n\t        conn = Connection()\n", "        conn._conn = AsyncMock()\n\t        command = {\"command\": \"test\"}\n\t        response = {\"response\": \"test\"}\n\t        conn._conn.recv.return_value = json.dumps(response)\n\t        # first run without delay\n\t        await conn._transaction(command)\n\t        # second run postponed by at least 200ms\n\t        start_time = time.time()\n\t        await conn._transaction(command)\n\t        end_time = time.time()\n", "        elapsed_time = end_time - start_time\n\t        self.assertGreaterEqual(elapsed_time, 0.2)\n\t    async def test_transaction_send_connection_closed(self):\n\t        conn = Connection()\n\t        conn._conn = AsyncMock()\n\t        conn._conn.send.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n\t        command = {\"command\": \"test\"}\n\t        with self.assertRaises(ConnectionClosed) as cm:\n\t            await conn._transaction(command)\n\t        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")\n", "    async def test_transaction_recv_connection_closed(self):\n\t        conn = Connection()\n\t        conn._conn = AsyncMock()\n\t        conn._conn.recv.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n\t        command = {\"command\": \"test\"}\n\t        with self.assertRaises(ConnectionClosed) as cm:\n\t            await conn._transaction(command)\n\t        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_socket.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import AsyncMock\n\tfrom xapi import Socket, TradeCmd, TradeType, PeriodCode\n\tclass TestSocket(unittest.IsolatedAsyncioTestCase):\n\t    def setUp(self):\n\t        self.socket = Socket()\n\t        self.socket._transaction = AsyncMock()\n\t    async def test_login(self):\n\t        await self.socket.login(\"my_account_id\", \"my_password\")\n\t        self.socket._transaction.assert_called_once_with({\n", "            \"command\": \"login\",\n\t            \"arguments\": {\n\t                \"userId\": \"my_account_id\",\n\t                \"password\": \"my_password\"\n\t            }\n\t        })\n\t    async def test_logout(self):\n\t        await self.socket.logout()\n\t        self.socket._transaction.assert_awaited_once_with({\"command\": \"logout\"})\n\t    async def test_getAllSymbols(self):\n", "        await self.socket.getAllSymbols()\n\t        self.socket._transaction.assert_awaited_once_with({\"command\": \"getAllSymbols\"})\n\t    async def test_getCalendar(self):\n\t        await self.socket.getCalendar()\n\t        self.socket._transaction.assert_awaited_once_with({\"command\": \"getCalendar\"})\n\t    async def test_getChartLastRequest(self):\n\t        await self.socket.getChartLastRequest(\"symbol\", 123, PeriodCode.PERIOD_H4)\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getChartLastRequest\",\n\t            \"arguments\": {\n", "                \"info\": {\n\t                    \"period\": PeriodCode.PERIOD_H4.value,\n\t                    \"start\": 123,\n\t                    \"symbol\": \"symbol\"\n\t                }\n\t            }\n\t        })\n\t    async def test_getChartRangeRequest(self):\n\t        await self.socket.getChartRangeRequest(\"symbol\", 123, 456, PeriodCode.PERIOD_M1, 10)\n\t        self.socket._transaction.assert_awaited_once_with({\n", "            \"command\": \"getChartRangeRequest\",\n\t            \"arguments\": {\n\t                \"info\": {\n\t                    \"end\": 456,\n\t                    \"period\": PeriodCode.PERIOD_M1.value,\n\t                    \"start\": 123,\n\t                    \"symbol\": \"symbol\",\n\t                    \"ticks\": 10\n\t                }\n\t            }\n", "        })\n\t    async def test_getCommissionDef(self):\n\t        await self.socket.getCommissionDef(\"symbol\", 123)\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getCommissionDef\",\n\t            \"arguments\": {\n\t                \"symbol\": \"symbol\",\n\t                \"volume\": 123\n\t            }\n\t        })\n", "    async def test_getCurrentUserData(self):\n\t        await self.socket.getCurrentUserData()\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getCurrentUserData\"\n\t        })\n\t    async def test_getIbsHistory(self):\n\t        await self.socket.getIbsHistory(123, 456)\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getIbsHistory\",\n\t            \"arguments\": {\n", "                \"end\": 456,\n\t                \"start\": 123\n\t            }\n\t        })\n\t    async def test_getMarginLevel(self):\n\t        await self.socket.getMarginLevel()\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getMarginLevel\"\n\t        })\n\t    async def test_getMarginTrade(self):\n", "        await self.socket.getMarginTrade(\"symbol\", 123)\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getMarginTrade\",\n\t            \"arguments\": {\n\t                \"symbol\": \"symbol\",\n\t                \"volume\": 123\n\t            }\n\t        })\n\t    async def test_getNews(self):\n\t        await self.socket.getNews(123, 456)\n", "        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getNews\",\n\t            \"arguments\": {\n\t                \"end\": 456,\n\t                \"start\": 123\n\t            }\n\t        })\n\t    async def test_getProfitCalculation(self):\n\t        await self.socket.getProfitCalculation(\"symbol\", 1, 1.23, 4.56, 10)\n\t        self.socket._transaction.assert_awaited_once_with({\n", "            \"command\": \"getProfitCalculation\",\n\t            \"arguments\": {\n\t                \"closePrice\": 4.56,\n\t                \"cmd\": 1,\n\t                \"openPrice\": 1.23,\n\t                \"symbol\": \"symbol\",\n\t                \"volume\": 10\n\t            }\n\t        })\n\t    async def test_getServerTime(self):\n", "        await self.socket.getServerTime()\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getServerTime\"\n\t        })\n\t    async def test_getStepRules(self):\n\t        await self.socket.getStepRules()\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getStepRules\"\n\t        })\n\t    async def test_getSymbol(self):\n", "        await self.socket.getSymbol(\"symbol\")\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getSymbol\",\n\t            \"arguments\": {\n\t                \"symbol\": \"symbol\"\n\t            }\n\t        })\n\t    async def test_getTickPrices(self):\n\t        await self.socket.getTickPrices([\"symbol_a\", \"symbol_b\"], 123)\n\t        self.socket._transaction.assert_awaited_once_with({\n", "            \"command\": \"getTickPrices\",\n\t            \"arguments\": {\n\t                \"level\": 0,\n\t                \"symbols\": [\"symbol_a\", \"symbol_b\"],\n\t                \"timestamp\": 123\n\t            }\n\t        })\n\t    async def test_getTradeRecords(self):\n\t        await self.socket.getTradeRecords([123, 456])\n\t        self.socket._transaction.assert_awaited_once_with({\n", "            \"command\": \"getTradeRecords\",\n\t            \"arguments\": {\n\t                \"orders\": [123, 456]\n\t            }\n\t        })\n\t    async def test_getTrades(self):\n\t        await self.socket.getTrades()\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getTrades\",\n\t            \"arguments\": {\n", "                \"openedOnly\": True\n\t            }\n\t        })\n\t    async def test_getTradesHistory(self):\n\t        await self.socket.getTradesHistory(123)\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getTradesHistory\",\n\t            \"arguments\": {\n\t                \"end\": 0,\n\t                \"start\": 123\n", "            }\n\t        })\n\t    async def test_getTradingHours(self):\n\t        await self.socket.getTradingHours([\"symbol_a\", \"symbol_b\"])\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getTradingHours\",\n\t            \"arguments\": {\n\t                \"symbols\": [\"symbol_a\", \"symbol_b\"]\n\t            }\n\t        })\n", "    async def test_getVersion(self):\n\t        await self.socket.getVersion()\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"getVersion\"\n\t        })\n\t    async def test_ping(self):\n\t        await self.socket.ping()\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"ping\"\n\t        })\n", "    async def test_tradeTransaction(self):\n\t        self.socket.safe = True\n\t        await self.socket.tradeTransaction(\"symbol\", TradeCmd.BUY, TradeType.OPEN, 1.23, 4.56)\n\t        self.socket._transaction.assert_not_awaited()\n\t        self.socket.safe = False\n\t        await self.socket.tradeTransaction(\"symbol\", TradeCmd.BUY, TradeType.OPEN, 1.23, 4.56)\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"tradeTransaction\",\n\t            \"arguments\": {\n\t                \"tradeTransInfo\": {\n", "                    \"cmd\": TradeCmd.BUY.value,\n\t                    \"customComment\": str(),\n\t                    \"expiration\": 0,\n\t                    \"offset\": 0,\n\t                    \"order\": 0,\n\t                    \"price\": 1.23,\n\t                    \"sl\": 0,\n\t                    \"symbol\": \"symbol\",\n\t                    \"tp\": 0,\n\t                    \"type\": TradeType.OPEN.value,\n", "                    \"volume\": 4.56\n\t                }\n\t            }\n\t        })\n\t    async def test_tradeTransactionStatus(self):\n\t        await self.socket.tradeTransactionStatus(123)\n\t        self.socket._transaction.assert_awaited_once_with({\n\t            \"command\": \"tradeTransactionStatus\",\n\t            \"arguments\": {\n\t                \"order\": 123\n", "            }\n\t        })\n"]}
{"filename": "xapi/enums.py", "chunked_list": ["from enum import IntEnum\n\tclass TradeCmd(IntEnum):\n\t    BUY = 0             # buy\n\t    SELL = 1            # sell\n\t    BUY_LIMIT = 2       # buy limit\n\t    SELL_LIMIT = 3      # sell limit\n\t    BUY_STOP = 4        # buy stop\n\t    SELL_STOP = 5       # sell stop\n\t    BALANCE = 6         # Read only. Used in getTradesHistory for manager's deposit/withdrawal operations (profit>0 for deposit, profit<0 for withdrawal).\n\t    CREDIT = 7          # Read only\n", "class TradeType(IntEnum):\n\t    OPEN = 0            # order open, used for opening orders\n\t    PENDING = 1         # order pending, only used in the streaming getTrades command\n\t    CLOSE = 2           # order close\n\t    MODIFY = 3          # order modify, only used in the tradeTransaction command\n\t    DELETE = 4          # order delete, only used in the tradeTransaction command\n\tclass TradeStatus(IntEnum):\n\t    ERROR = 0           # error\n\t    PENDING = 1         # pending\n\t    ACCEPTED = 3        # The transaction has been executed successfully\n", "    REJECTED = 4        # The transaction has been rejected\n\tclass PeriodCode(IntEnum):\n\t    PERIOD_M1 = 1       # 1 minute\n\t    PERIOD_M5 = 5       # 5 minutes\n\t    PERIOD_M15 = 15     # 15 minutes\n\t    PERIOD_M30 = 30     # 30 minutes\n\t    PERIOD_H1 = 60      # 60 minutes (1 hour)\n\t    PERIOD_H4 = 240     # 240 minutes (4 hours)\n\t    PERIOD_D1 = 1440    # 1440 minutes (1 day)\n\t    PERIOD_W1 = 10080   # 10080 minutes (1 week)\n", "    PERIOD_MN1 = 43200  # 43200 minutes (30 days)"]}
{"filename": "xapi/__init__.py", "chunked_list": ["\"\"\"\n\t.. moduleauthor:: Paweł Knioła <pawel.kn@gmail.com>\n\t\"\"\"\n\tname = \"xapi\"\n\t__version__ = \"0.1.6\"\n\tfrom .xapi import XAPI, connect\n\tfrom .enums import TradeCmd, TradeType, TradeStatus, PeriodCode\n\tfrom .connection import Connection\n\tfrom .socket import Socket\n\tfrom .stream import Stream\n", "from .exceptions import ConnectionClosed, LoginFailed"]}
{"filename": "xapi/stream.py", "chunked_list": ["from .connection import Connection\n\tclass Stream(Connection):\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.streamSessionId = str()\n\t    async def getBalance(self):\n\t        return await self._request({\n\t            \"command\": \"getBalance\",\n\t            \"streamSessionId\": self.streamSessionId\n\t        })\n", "    async def stopBalance(self):\n\t        return await self._request({\n\t            \"command\": \"stopBalance\"\n\t        })\n\t    async def getCandles(self, symbol: str):\n\t        return await self._request({\n\t            \"command\": \"getCandles\",\n\t            \"streamSessionId\": self.streamSessionId,\n\t            \"symbol\": symbol\n\t        })\n", "    async def stopCandles(self, symbol: str):\n\t        return await self._request({\n\t            \"command\": \"stopCandles\",\n\t            \"symbol\": symbol\n\t        })\n\t    async def getKeepAlive(self):\n\t        return await self._request({\n\t            \"command\": \"getKeepAlive\",\n\t            \"streamSessionId\": self.streamSessionId\n\t        })\n", "    async def stopKeepAlive(self):\n\t        return await self._request({\n\t            \"command\": \"stopKeepAlive\"\n\t        })\n\t    async def getNews(self):\n\t        return await self._request({\n\t            \"command\": \"getNews\",\n\t            \"streamSessionId\": self.streamSessionId\n\t        })\n\t    async def stopNews(self):\n", "        return await self._request({\n\t            \"command\": \"stopNews\"\n\t        }\n\t        )\n\t    async def getProfits(self):\n\t        return await self._request({\n\t            \"command\": \"getProfits\",\n\t            \"streamSessionId\": self.streamSessionId\n\t        })\n\t    async def stopProfits(self):\n", "        return await self._request({\n\t            \"command\": \"stopProfits\"\n\t        })\n\t    async def getTickPrices(self, symbol: str, minArrivalTime: int = 0, maxLevel: int = 2):\n\t        return await self._request({\n\t            \"command\": \"getTickPrices\",\n\t            \"streamSessionId\": self.streamSessionId,\n\t            \"symbol\": symbol,\n\t            \"minArrivalTime\": minArrivalTime,\n\t            \"maxLevel\": maxLevel\n", "        })\n\t    async def stopTickPrices(self, symbol: str):\n\t        return await self._request({\n\t            \"command\": \"stopTickPrices\",\n\t            \"symbol\": symbol\n\t        })\n\t    async def getTrades(self):\n\t        return await self._request({\n\t            \"command\": \"getTrades\",\n\t            \"streamSessionId\": self.streamSessionId\n", "        })\n\t    async def stopTrades(self):\n\t        return await self._request({\n\t            \"command\": \"stopTrades\"\n\t        })\n\t    async def getTradeStatus(self):\n\t        return await self._request({\n\t            \"command\": \"getTradeStatus\",\n\t            \"streamSessionId\": self.streamSessionId\n\t        })\n", "    async def stopTradeStatus(self):\n\t        return await self._request({\n\t            \"command\": \"stopTradeStatus\"\n\t        })\n\t    async def ping(self):\n\t        return await self._request({\n\t            \"command\": \"ping\",\n\t            \"streamSessionId\": self.streamSessionId\n\t        })\n"]}
{"filename": "xapi/xapi.py", "chunked_list": ["from .socket import Socket\n\tfrom .stream import Stream\n\tfrom .exceptions import LoginFailed\n\tclass XAPI:\n\t    def __init__(self):\n\t        self.socket = Socket()\n\t        self.stream = Stream()\n\t    async def __aenter__(self):\n\t        return self\n\t    async def __aexit__(self, *args):\n", "        await self.disconnect()\n\t    async def disconnect(self):\n\t        \"\"\"\n\t        This is an asynchronous function that closes connection to the xStation5 trading platform.\n\t        \"\"\"\n\t        await self.socket.disconnect()\n\t        await self.stream.disconnect()\n\tasync def connect(\n\t        accountId: str,\n\t        password: str,\n", "        host: str = \"ws.xtb.com\",\n\t        type: str = \"real\",\n\t        safe: bool = False\n\t    ):\n\t    \"\"\"\n\t    This is an asynchronous function that establishes a connection to the xStation5 trading platform.\n\t    Parameters\n\t    ----------\n\t    `accountId` : `str`\n\t        User's xStation5 account ID\n", "    `password` : `str`\n\t        User's xStation5 account password\n\t    `host` : `str`, `optional`\n\t        The xStation5 trading platform host name or IP address (default is `ws.xtb.com`)\n\t    `type` : `str`, `optional`\n\t        A type of the xStation5 account, which can be either `real` or `demo` (default is `real`)\n\t    `safe` : `boolean`, `optional`\n\t        A parameter indicating whether the connection should disallow trade execution (default is `False`)\n\t    Returns\n\t    -------\n", "    `XAPI`\n\t        An object of XAPI that can be utilized to communicate with the xStation 5 trading platform.\n\t    Raises\n\t    ------\n\t    `LoginFailed`\n\t        Raised when a log in failed.\n\t    `ConnectionClosed`\n\t        Raised when a connection has never been opened or closed unexpectedly.\n\t    \"\"\"\n\t    x = XAPI()\n", "    x.stream.safe = safe\n\t    x.socket.safe = safe\n\t    if not host.startswith(\"wss://\") and not host.startswith(\"ws://\"):\n\t        host = f\"wss://{host}\"\n\t    socket_url = f\"{host}/{type}\"\n\t    stream_url = f\"{host}/{type}Stream\"\n\t    await x.socket.connect(socket_url)\n\t    await x.stream.connect(stream_url)\n\t    result = await x.socket.login(accountId, password)\n\t    if result['status'] != True:\n", "        raise LoginFailed(result)\n\t    x.stream.streamSessionId = result['streamSessionId']\n\t    return x"]}
{"filename": "xapi/socket.py", "chunked_list": ["from .connection import Connection\n\tfrom .enums import TradeCmd, TradeType, PeriodCode\n\tfrom typing import List\n\tclass Socket(Connection):\n\t    async def login(self, accountId: str, password: str):\n\t        return await self._transaction({\n\t            \"command\": \"login\",\n\t            \"arguments\": {\n\t                \"userId\": accountId,\n\t                \"password\": password\n", "            }\n\t        })\n\t    async def logout(self):\n\t        return await self._transaction({\n\t            \"command\": \"logout\"\n\t        })\n\t    async def getAllSymbols(self):\n\t        return await self._transaction({\n\t            \"command\": \"getAllSymbols\"\n\t        })\n", "    async def getCalendar(self):\n\t        return await self._transaction({\n\t            \"command\": \"getCalendar\"\n\t        })\n\t    async def getChartLastRequest(self, symbol: str, start: int, period: PeriodCode):\n\t        return await self._transaction({\n\t            \"command\": \"getChartLastRequest\",\n\t            \"arguments\": {\n\t                \"info\": {\n\t                    \"period\": period.value,\n", "                    \"start\": start,\n\t                    \"symbol\": symbol\n\t                }\n\t            }\n\t        })\n\t    async def getChartRangeRequest(self, symbol: str, start: int, end: int, period: PeriodCode, ticks: int):\n\t        return await self._transaction({\n\t            \"command\": \"getChartRangeRequest\",\n\t            \"arguments\": {\n\t                \"info\": {\n", "                    \"end\": end,\n\t                    \"period\": period.value,\n\t                    \"start\": start,\n\t                    \"symbol\": symbol,\n\t                    \"ticks\": ticks\n\t                }\n\t            }\n\t        })\n\t    async def getCommissionDef(self, symbol: str, volume: float):\n\t        return await self._transaction({\n", "            \"command\": \"getCommissionDef\",\n\t            \"arguments\": {\n\t                \"symbol\": symbol,\n\t                \"volume\": volume\n\t            }\n\t        })\n\t    async def getCurrentUserData(self):\n\t        return await self._transaction({\n\t            \"command\": \"getCurrentUserData\"\n\t        })\n", "    async def getIbsHistory(self, start: int, end: int):\n\t        return await self._transaction({\n\t            \"command\": \"getIbsHistory\",\n\t            \"arguments\": {\n\t                \"end\": end,\n\t                \"start\": start\n\t            }\n\t        })\n\t    async def getMarginLevel(self):\n\t        return await self._transaction({\n", "            \"command\": \"getMarginLevel\"\n\t        })\n\t    async def getMarginTrade(self, symbol: str, volume: float):\n\t        return await self._transaction({\n\t            \"command\": \"getMarginTrade\",\n\t            \"arguments\": {\n\t                \"symbol\": symbol,\n\t                \"volume\": volume\n\t            }\n\t        })\n", "    async def getNews(self, start: int, end: int):\n\t        return await self._transaction({\n\t            \"command\": \"getNews\",\n\t            \"arguments\": {\n\t                \"end\": end,\n\t                \"start\": start\n\t            }\n\t        })\n\t    async def getProfitCalculation(self, symbol: str, cmd: int, openPrice: float, closePrice: float, volume: float):\n\t        return await self._transaction({\n", "            \"command\": \"getProfitCalculation\",\n\t            \"arguments\": {\n\t                \"closePrice\": closePrice,\n\t                \"cmd\": cmd,\n\t                \"openPrice\": openPrice,\n\t                \"symbol\": symbol,\n\t                \"volume\": volume\n\t            }\n\t        })\n\t    async def getServerTime(self):\n", "        return await self._transaction({\n\t            \"command\": \"getServerTime\"\n\t        })\n\t    async def getStepRules(self):\n\t        return await self._transaction({\n\t            \"command\": \"getStepRules\"\n\t        })\n\t    async def getSymbol(self, symbol: str):\n\t        return await self._transaction({\n\t            \"command\": \"getSymbol\",\n", "            \"arguments\": {\n\t                \"symbol\": symbol\n\t            }\n\t        })\n\t    async def getTickPrices(self, symbols: List[str], timestamp: int, level: int = 0 ):\n\t        return await self._transaction({\n\t            \"command\": \"getTickPrices\",\n\t            \"arguments\": {\n\t                \"level\": level,\n\t                \"symbols\": symbols,\n", "                \"timestamp\": timestamp\n\t            }\n\t        })\n\t    async def getTradeRecords(self, orders: List[int]):\n\t        return await self._transaction({\n\t            \"command\": \"getTradeRecords\",\n\t            \"arguments\": {\n\t                \"orders\": orders\n\t            }\n\t        })\n", "    async def getTrades(self, openedOnly: bool = True):\n\t        return await self._transaction({\n\t            \"command\": \"getTrades\",\n\t            \"arguments\": {\n\t                \"openedOnly\": openedOnly\n\t            }\n\t        })\n\t    async def getTradesHistory(self, start: int, end: int = 0):\n\t        return await self._transaction({\n\t            \"command\": \"getTradesHistory\",\n", "            \"arguments\": {\n\t                \"end\": end,\n\t                \"start\": start\n\t            }\n\t        })\n\t    async def getTradingHours(self, symbols: List[str]):\n\t        return await self._transaction({\n\t            \"command\": \"getTradingHours\",\n\t            \"arguments\": {\n\t                \"symbols\": symbols\n", "            }\n\t        })\n\t    async def getVersion(self):\n\t        return await self._transaction({\n\t            \"command\": \"getVersion\"\n\t        })\n\t    async def ping(self):\n\t        return await self._transaction({\n\t            \"command\": \"ping\"\n\t        })\n", "    async def tradeTransaction(self, symbol: str, cmd: TradeCmd, type: TradeType, price: float, volume: float,\n\t                               sl: float = 0, tp: float = 0, order: int = 0, expiration: int = 0,\n\t                               offset: int = 0, customComment: str = str()):\n\t        if self.safe == True:\n\t            return {\n\t                \"status\": False,\n\t                'errorCode': 'N/A',\n\t                'errorDescr': 'Trading is disabled when safe=True'\n\t            }\n\t        return await self._transaction({\n", "            \"command\": \"tradeTransaction\",\n\t            \"arguments\": {\n\t                \"tradeTransInfo\": {\n\t                    \"cmd\": cmd.value,\n\t                    \"customComment\": customComment,\n\t                    \"expiration\": expiration,\n\t                    \"offset\": offset,\n\t                    \"order\": order,\n\t                    \"price\": price,\n\t                    \"sl\": sl,\n", "                    \"symbol\": symbol,\n\t                    \"tp\":   tp,\n\t                    \"type\": type.value,\n\t                    \"volume\": volume\n\t                }\n\t            }\n\t        })\n\t    async def tradeTransactionStatus(self, order: int):\n\t        return await self._transaction({\n\t            \"command\": \"tradeTransactionStatus\",\n", "            \"arguments\": {\n\t                \"order\": order\n\t            }\n\t        })\n"]}
{"filename": "xapi/exceptions.py", "chunked_list": ["class LoginFailed(Exception):\n\t    \"\"\"\n\t    Raised when a log in failed.\n\t    \"\"\"\n\tclass ConnectionClosed(Exception):\n\t    \"\"\"\n\t    Raised when a connection has never been opened or closed unexpectedly.\n\t    \"\"\""]}
{"filename": "xapi/connection.py", "chunked_list": ["from .exceptions import ConnectionClosed\n\timport websockets.client\n\timport websockets.exceptions\n\timport socket\n\timport asyncio\n\timport json\n\timport time\n\tclass Connection():\n\t    def __init__(self):\n\t        self.safe = False\n", "        self._conn = None\n\t        self._lock = asyncio.Lock()\n\t        self._last_request_time = None\n\t    async def connect(self, url):\n\t        try:\n\t            self._conn = await websockets.client.connect(url, close_timeout=0, max_size=None)\n\t        except websockets.exceptions.WebSocketException as e:\n\t            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\t        except socket.gaierror:\n\t            raise ConnectionClosed(\"Hostname cannot be resolved\")\n", "        except asyncio.exceptions.TimeoutError:\n\t            raise ConnectionClosed(\"Connection timed out\")\n\t        except ConnectionRefusedError:\n\t            raise ConnectionClosed(\"Connection refused\")\n\t    async def disconnect(self):\n\t        try:\n\t            if self._conn:\n\t                await self._conn.close()\n\t        except websockets.exceptions.ConnectionClosed:\n\t            pass\n", "        self._conn = None\n\t    async def listen(self):\n\t        try:\n\t            if self._conn:\n\t                async for message in self._conn:\n\t                    yield json.loads(message)\n\t            else:\n\t                raise ConnectionClosed(\"Not connected\")\n\t        except websockets.exceptions.WebSocketException as e:\n\t            self._conn = None\n", "            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\t    async def _request(self, command):\n\t        if self._last_request_time is not None:\n\t            elapsed_time = time.time() - self._last_request_time\n\t            if elapsed_time < 0.2:\n\t                await asyncio.sleep(0.2 - elapsed_time)\n\t        try:\n\t            if self._conn:\n\t                await self._conn.send(json.dumps(command))\n\t                self._last_request_time = time.time()\n", "            else:\n\t                raise ConnectionClosed(\"Not connected\")\n\t        except websockets.exceptions.WebSocketException as e:\n\t            self._conn = None\n\t            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\t    async def _transaction(self, command):\n\t        async with self._lock:\n\t            try:\n\t                if self._conn:\n\t                    await self._request(command)\n", "                    response = await self._conn.recv()\n\t                    return json.loads(response)\n\t                else:\n\t                    raise ConnectionClosed(\"Not connected\")\n\t            except websockets.exceptions.WebSocketException as e:\n\t                self._conn = None\n\t                raise ConnectionClosed(f\"WebSocket exception: {e}\")"]}
{"filename": "examples/get-symbol.py", "chunked_list": ["import logging\n\timport asyncio\n\timport json\n\timport xapi\n\tlogging.basicConfig(level=logging.INFO)\n\twith open(\"credentials.json\", \"r\") as f:\n\t    CREDENTIALS = json.load(f)\n\tasync def main():\n\t    try:\n\t        async with await xapi.connect(**CREDENTIALS) as x:\n", "            response = await x.socket.getSymbol(\"BITCOIN\")\n\t            if response['status'] == True:\n\t                print(response['returnData'])\n\t            else:\n\t                print(\"Failed to get symbol\", response)\n\t    except xapi.LoginFailed as e:\n\t        print(f\"Log in failed: {e}\")\n\t    except xapi.ConnectionClosed as e:\n\t        print(f\"Connection closed: {e}\")\n\tif __name__ == \"__main__\":\n", "    asyncio.run(main())"]}
{"filename": "examples/get-balance.py", "chunked_list": ["import logging\n\timport asyncio\n\timport json\n\timport xapi\n\tlogging.basicConfig(level=logging.INFO)\n\twith open(\"credentials.json\", \"r\") as f:\n\t    CREDENTIALS = json.load(f)\n\tasync def main():\n\t    while True:\n\t        try:\n", "            async with await xapi.connect(**CREDENTIALS) as x:\n\t                await x.stream.getBalance()\n\t                async for message in x.stream.listen():\n\t                    print(message['data'])\n\t        except xapi.LoginFailed as e:\n\t            print(f\"Log in failed: {e}\")\n\t            return\n\t        except xapi.ConnectionClosed as e:\n\t            print(f\"Connection closed: {e}, reconnecting ...\")\n\t            await asyncio.sleep(1)\n", "            continue\n\tif __name__ == \"__main__\":\n\t    try:\n\t        asyncio.run(main())\n\t    except KeyboardInterrupt:\n\t        pass"]}
{"filename": "examples/get-trades-history.py", "chunked_list": ["import logging\n\timport asyncio\n\timport json\n\timport xapi\n\tlogging.basicConfig(level=logging.INFO)\n\twith open(\"credentials.json\", \"r\") as f:\n\t    CREDENTIALS = json.load(f)\n\t# start from the first day of a current year\n\tfrom datetime import datetime as dt\n\tSTART = round(dt.today().replace(month=1, day=1).timestamp() * 1000)\n", "async def main():\n\t    try:\n\t        async with await xapi.connect(**CREDENTIALS) as x:\n\t            response = await x.socket.getTradesHistory(START)\n\t            if response['status'] == True:\n\t                print(response['returnData'])\n\t            else:\n\t                print(\"Failed to get trades history\", response)\n\t    except xapi.LoginFailed as e:\n\t        print(f\"Log in failed: {e}\")\n", "    except xapi.ConnectionClosed as e:\n\t        print(f\"Connection closed: {e}\")\n\tif __name__ == \"__main__\":\n\t    asyncio.run(main())"]}
{"filename": "examples/get-margin-level.py", "chunked_list": ["import logging\n\timport asyncio\n\timport json\n\timport xapi\n\tlogging.basicConfig(level=logging.INFO)\n\twith open(\"credentials.json\", \"r\") as f:\n\t    CREDENTIALS = json.load(f)\n\tasync def main():\n\t    try:\n\t        async with await xapi.connect(**CREDENTIALS) as x:\n", "            response = await x.socket.getMarginLevel()\n\t            if response['status'] == True:\n\t                print(response['returnData'])\n\t            else:\n\t                print(\"Failed to get margin level\", response)\n\t    except xapi.LoginFailed as e:\n\t        print(f\"Log in failed: {e}\")\n\t    except xapi.ConnectionClosed as e:\n\t        print(f\"Connection closed: {e}\")\n\tif __name__ == \"__main__\":\n", "    asyncio.run(main())"]}
{"filename": "examples/get-all-symbols.py", "chunked_list": ["import logging\n\timport asyncio\n\timport json\n\timport xapi\n\tlogging.basicConfig(level=logging.INFO)\n\twith open(\"credentials.json\", \"r\") as f:\n\t    CREDENTIALS = json.load(f)\n\tasync def main():\n\t    try:\n\t        async with await xapi.connect(**CREDENTIALS) as x:\n", "            response = await x.socket.getAllSymbols()\n\t            if response['status'] == True:\n\t                print(response['returnData'])\n\t            else:\n\t                print(\"Failed to get all symbols\", response)\n\t    except xapi.LoginFailed as e:\n\t        print(f\"Log in failed: {e}\")\n\t    except xapi.ConnectionClosed as e:\n\t        print(f\"Connection closed: {e}\")\n\tif __name__ == \"__main__\":\n", "    asyncio.run(main())"]}
{"filename": "examples/get-tick-prices.py", "chunked_list": ["import logging\n\timport asyncio\n\timport json\n\timport xapi\n\tlogging.basicConfig(level=logging.INFO)\n\twith open(\"credentials.json\", \"r\") as f:\n\t    CREDENTIALS = json.load(f)\n\tasync def main():\n\t    while True:\n\t        try:\n", "            async with await xapi.connect(**CREDENTIALS) as x:\n\t                await x.stream.getTickPrices(\"BITCOIN\")\n\t                await x.stream.getTickPrices(\"ETHEREUM\")\n\t                async for message in x.stream.listen():\n\t                    print(message['data'])\n\t        except xapi.LoginFailed as e:\n\t            print(f\"Log in failed: {e}\")\n\t            return\n\t        except xapi.ConnectionClosed as e:\n\t            print(f\"Connection closed: {e}, reconnecting ...\")\n", "            await asyncio.sleep(1)\n\t            continue\n\tif __name__ == \"__main__\":\n\t    try:\n\t        asyncio.run(main())\n\t    except KeyboardInterrupt:\n\t        pass"]}
{"filename": "examples/trade-transaction.py", "chunked_list": ["import logging\n\timport asyncio\n\timport json\n\timport xapi\n\tfrom xapi import TradeCmd, TradeType, TradeStatus\n\tlogging.basicConfig(level=logging.INFO)\n\twith open(\"credentials.json\", \"r\") as f:\n\t    CREDENTIALS = json.load(f)\n\tasync def main():\n\t    try:\n", "        async with await xapi.connect(**CREDENTIALS) as x:\n\t            response = await x.socket.tradeTransaction(\n\t                symbol=\"BITCOIN\",\n\t                cmd=TradeCmd.BUY_LIMIT,\n\t                type=TradeType.OPEN,\n\t                price=10.00,\n\t                volume=1\n\t            )\n\t            if response['status'] != True:\n\t                print(\"Failed to trade a transaction\", response)\n", "                return\n\t            order = response['returnData']['order']\n\t            response = await x.socket.tradeTransactionStatus(order)\n\t            if response['status'] != True:\n\t                print(\"Failed to trade a transaction\", response)\n\t                return\n\t            requestStatus = response['returnData']['requestStatus']\n\t            if requestStatus == TradeStatus.ERROR.value:\n\t                print(f\"The transaction finished with error: {response['returnData']['message']}\")\n\t            elif requestStatus == TradeStatus.PENDING.value:\n", "                print(f\"The transaction is pending\")\n\t            elif requestStatus == TradeStatus.ACCEPTED.value:\n\t                print(f\"The transaction has been executed successfully\")\n\t            elif requestStatus == TradeStatus.REJECTED.value:\n\t                print(f\"The transaction has been rejected: {response['returnData']['message']}\")\n\t    except xapi.LoginFailed as e:\n\t        print(f\"Log in failed: {e}\")\n\t    except xapi.ConnectionClosed as e:\n\t        print(f\"Connection closed: {e}\")\n\tif __name__ == \"__main__\":\n", "    asyncio.run(main())"]}
