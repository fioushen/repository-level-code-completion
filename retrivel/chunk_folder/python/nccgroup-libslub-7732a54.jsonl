{"filename": "libslub.py", "chunked_list": ["import os\n\timport sys\n\t# We reload all modules everywhere so when we develop libslub in gdb\n\t# our changes are reflected as soon as we reimport this main script\n\timport importlib\n\t# Add the root path\n\tmodule_path = os.path.dirname(os.path.abspath(os.path.realpath(__file__)))\n\tif module_path not in sys.path:\n\t    #print(\"DEBUG: adding module path...\")\n\t    sys.path.insert(0, module_path)\n", "#print(sys.path) # DEBUG\n\t# We need that after the above so it finds it\n\timport libslub\n\timportlib.reload(libslub)\n"]}
{"filename": "libslub/pyslub.py", "chunked_list": ["import os\n\timport sys\n\timport importlib\n\timport gdb\n\ttry:\n\t    import configparser  # py3\n\texcept:\n\t    import ConfigParser as configparser  # py2\n\timport libslub.frontend.frontend_gdb as fg\n\timportlib.reload(fg)\n", "import libslub.slub.sb as sb\n\timportlib.reload(sb)\n\timport libslub.pydbg.debugger as d\n\timportlib.reload(d)\n\timport libslub.pydbg.pygdbpython as pgp\n\timportlib.reload(pgp)\n\tclass pyslab:\n\t    \"\"\"Entry point of libslub\"\"\"\n\t    def __init__(self):\n\t        # Setup GDB debugger interface\n", "        debugger = pgp.pygdbpython()\n\t        self.dbg = d.pydbg(debugger)\n\t        config = configparser.SafeConfigParser()\n\t        path = os.path.abspath(os.path.dirname(__file__))\n\t        config_path = os.path.join(path, \"libslub.cfg\")\n\t        config.read(config_path)\n\t        try:\n\t            breakpoints_enabled = config.getboolean(\"Slab\", \"breakpoints_enabled\")\n\t        except configparser.NoOptionError:\n\t            breakpoints_enabled = False\n", "        self.sb = sb.sb(debugger=self.dbg, breakpoints_enabled=breakpoints_enabled)\n\t        # Register GDB commands\n\t        fg.frontend_gdb(self.sb)\n"]}
{"filename": "libslub/logger.py", "chunked_list": ["import logging\n\t# https://stackoverflow.com/questions/2183233/how-to-add-a-custom-loglevel-to-pythons-logging-facility\n\tdef trace(self, message, *args, **kws):\n\t    if self.isEnabledFor(logging.TRACE):\n\t        # Yes, logger takes its '*args' as 'args'.\n\t        self._log(logging.TRACE, message, args, **kws) \n\tclass MyFormatter(logging.Formatter):\n\t    \"\"\"Defines how we format logs in stdout and files\n\t    \"\"\"\n\t    # We use the TRACE level to check loaded files in gdb after reloading the script\n", "    # so is mainly useful during development\n\t    logging.TRACE = 5\n\t    logging.addLevelName(logging.TRACE, 'TRACE')\n\t    logging.Logger.trace = trace\n\t    FORMATS = {\n\t        logging.ERROR: \"(%(asctime)s) [!] %(msg)s\",\n\t        logging.WARNING: \"(%(asctime)s) WARNING: %(msg)s\",\n\t        logging.INFO: \"(%(asctime)s) [*] %(msg)s\",\n\t        logging.DEBUG: \"(%(asctime)s) DBG: %(msg)s\",\n\t        logging.TRACE: \"(%(asctime)s) TRACE: %(msg)s\",\n", "        \"DEFAULT\": \"%(asctime)s - %(msg)s\"\n\t    }\n\t    def format(self, record):\n\t        \"\"\"Hooked Formatter.format() method to modify its behaviour\n\t        \"\"\"\n\t        format_orig = self._style._fmt\n\t        self._style._fmt = self.FORMATS.get(record.levelno, self.FORMATS['DEFAULT'])\n\t        result = logging.Formatter.format(self, record)\n\t        self._style._fmt = format_orig\n\t        return result"]}
{"filename": "libslub/__init__.py", "chunked_list": ["import sys\n\timport importlib\n\timport logging\n\timport libslub.logger as logger\n\timportlib.reload(logger)\n\timport libslub.pyslub as pyslub\n\timportlib.reload(pyslub)\n\ttry:\n\t    log\n\texcept:\n", "    log = logging.getLogger(\"libslub\")\n\t    handler = logging.StreamHandler(sys.stdout)\n\t    handler.setFormatter(logger.MyFormatter(datefmt=\"%H:%M:%S\"))\n\t    log.addHandler(handler)\n\t# This allows changing the log level and reloading in gdb even if the logger was already defined\n\t# XXX - however this file is not reloaded early when we reload in gdb, so we need to re-source in gdb 2x\n\t# for the logger level to be changed atm\n\t#log.setLevel(logging.TRACE) # use for debugging reloading .py files only\n\t#log.setLevel(logging.DEBUG) # all other types of debugging\n\tlog.setLevel(logging.NOTSET)\n", "if log.isEnabledFor(logging.TRACE):\n\t    log.warning(f\"logging TRACE enabled\")\n\telif log.isEnabledFor(logging.DEBUG):\n\t    log.warning(f\"logging DEBUG enabled\")\n\t# elif log.isEnabledFor(logging.INFO):\n\t#     log.warning(f\"logging INFO enabled\")\n\t# elif log.isEnabledFor(logging.WARNING):\n\t#     log.warning(f\"logging WARNING enabled\")\n\tlog.trace(\"libslub/__init__.py\")\n\tpyslub.pyslab()\n"]}
{"filename": "libslub/pydbg/__init__.py", "chunked_list": []}
{"filename": "libslub/pydbg/pygdbpython.py", "chunked_list": ["import sys\n\timport logging\n\timport re\n\timport importlib\n\timport hexdump\n\tfrom pathlib import Path\n\tfrom functools import wraps\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n", "log = logging.getLogger(\"libslub\")\n\tlog.trace(\"pygdbpython.py\")\n\t# XXX - could have that into a helper.py instead?\n\tdef gdb_is_running(f):\n\t    \"\"\"Decorator to make sure gdb is running\n\t    \"\"\"\n\t    @wraps(f)\n\t    def _gdb_is_running(*args, **kwargs):\n\t        if gdb.selected_thread() is not None:\n\t            return f(*args, **kwargs)\n", "        else:\n\t            pu.print_error(\"GDB is not running.\")\n\t    return _gdb_is_running\n\tclass pygdbpython:\n\t    \"\"\"Debugger bridge calling into gdb-specific APIs\n\t    See debugger.py interface\n\t    \"\"\"\n\t    def __init__(self):\n\t        log.debug(\"pygdbpython.__init__()\")\n\t        self.inferior = None\n", "        self.SIZE_SZ = 0\n\t    #\n\t    # Methods from the debugger abstraction\n\t    #\n\t    @gdb_is_running\n\t    def execute(self, cmd, to_string=True):\n\t        \"\"\"See debugger.py interface\n\t        \"\"\"\n\t        log.debug(\"pygdbpython.execute()\")\n\t        return gdb.execute(cmd, to_string=to_string)\n", "    @gdb_is_running\n\t    def get_size_sz(self):\n\t        \"\"\"See debugger.py interface\n\t        \"\"\"\n\t        return 8 # hardcoded for now\n\t    @gdb_is_running\n\t    def read_memory(self, address, length):\n\t        \"\"\"See debugger.py interface\n\t        \"\"\"\n\t        if log.level <= logging.DEBUG:\n", "            if type(address) == int:\n\t                printed_address = \"0x%x\" % address\n\t            else:\n\t                printed_address = str(address)\n\t            if type(length) == int:\n\t                printed_length = \"0x%x\" % length\n\t            else:\n\t                printed_length = str(length)\n\t            log.debug(f\"pygdbpython.read_memory({printed_address}, {printed_length})\")\n\t        if self.inferior is None:\n", "            self.inferior = self.get_inferior()\n\t        return self.inferior.read_memory(address, length)\n\t    @gdb_is_running\n\t    def parse_variable(self, variable=None):\n\t        \"\"\"See debugger.py interface\n\t        \"\"\"\n\t        log.debug(\"pygdbpython.parse_variable()\")\n\t        if variable is None:\n\t            pu.print_error(\"Please specify a variable to read\")\n\t            return None\n", "        evaluated = int(gdb.parse_and_eval(variable))\n\t        log.info(\"pygdbpython.parse_variable(): evaluated variable = 0x%x\" % evaluated)\n\t        if self.get_size_sz() == 4:\n\t            p = self.tohex(evaluated, 32)\n\t        elif self.get_size_sz() == 8:\n\t            p = self.tohex(evaluated, 64)\n\t        return int(p, 16)\n\t    @gdb_is_running\n\t    def print_hexdump(self, address, size, unit=8):\n\t        \"\"\"See debugger.py interface\n", "        \"\"\"\n\t        # See https://visualgdb.com/gdbreference/commands/x\n\t        if unit == 1:\n\t            #cmd = \"x/%dbx 0x%x\\n\" % (size, address)\n\t            try:\n\t                mem = self.read_memory(address, size)\n\t            except TypeError:\n\t                pu.print_error(\"Invalid address specified\")\n\t                return\n\t            except RuntimeError:\n", "                pu.print_error(\"Could not read address {0:#x}\".format(addr))\n\t                return\n\t            i = 0\n\t            for line in hexdump.hexdump(bytes(mem), result='generator'):\n\t                elts = line.split(\":\")\n\t                txt = \":\".join(elts[1:])\n\t                print(\"0x%x: %s\" % (address+i*0x10, txt))\n\t                i += 1\n\t            return\n\t        elif unit == 2:\n", "            cmd = \"x/%dhx 0x%x\\n\" % (size/2, address)\n\t        elif unit == 4:\n\t            cmd = \"x/%dwx 0x%x\\n\" % (size/4, address)\n\t        elif unit == 8:\n\t            cmd = \"x/%dgx 0x%x\\n\" % (size/8, address)\n\t        elif unit == \"dps\":\n\t            # XXX - call into dps_like_for_gdb.py command for now\n\t            # but we want to just add it to libslub maybe\n\t            cmd = \"dps 0x%x %d\\n\" % (address, size/self.get_size_sz())\n\t        else:\n", "            print(\"[!] Invalid unit specified\")\n\t            return\n\t        print(self.execute(cmd, to_string=True))\n\t        return\n\t    def parse_address(self, addresses):\n\t        \"\"\"See debugger.py interface\n\t        It should be able to handle gdb variables starting with $ or if we ommit it too\n\t        \"\"\"\n\t        log.debug(\"pygdbpython.parse_address()\")\n\t        resolved = []\n", "        if type(addresses) != list:\n\t            addresses = [addresses]\n\t        for item in addresses:\n\t            addr = None\n\t            try:\n\t                # This should parse most cases like integers,\n\t                # variables (exact name), registers (if we specify $ in front), as well\n\t                # as arithmetic with integers, variables and registers.\n\t                # i.e. as long as \"p ABC\" or \"x /x ABC\" works, it should work within here too\n\t                addr = self.parse_variable(item)\n", "                log.info(\"parsed address (default) = 0x%x\" % addr)\n\t            except:\n\t                # XXX - Not sure what this is for?\n\t                try:\n\t                    addr = self.parse_variable(\"&\" + item)\n\t                    log.info(\"parsed address (unknown) = 0x%x\" % addr)\n\t                except:\n\t                    # Parse registers if we don't specify the register, e.g. \"rdi\" instead of \"$rdi\"\n\t                    try:\n\t                        addr = self.parse_variable(\"$\" + item)\n", "                        log.info(\"parsed address (register) = 0x%x\" % addr)\n\t                    except:\n\t                        pu.print_error(f\"ERROR: Unable to parse {item}\")\n\t                        continue\n\t            if addr is not None:\n\t                resolved.append(addr)\n\t        return resolved\n\t    #\n\t    # gdb-specific methods\n\t    #\n", "    def get_inferior(self):\n\t        \"\"\"Get the gdb inferior, used for other gdb commands\n\t        \"\"\"\n\t        log.debug(\"pygdbpython.get_inferior()\")\n\t        try:\n\t            if self.inferior is None:\n\t                if len(gdb.inferiors()) == 0:\n\t                    pu.print_error(\"No gdb inferior could be found.\")\n\t                    return -1\n\t                else:\n", "                    self.inferior = gdb.inferiors()[0]\n\t                    return self.inferior\n\t            else:\n\t                return self.inferior\n\t        except AttributeError:\n\t            pu.print_error(\"This gdb's python support is too old.\")\n\t            raise Exception(\"sys.exit()\")\n\t    # XXX - move to generic helper shared by all debuggers?\n\t    def tohex(self, val, nbits):\n\t        \"\"\"Handle gdb adding extra char to hexadecimal values\n", "        \"\"\"\n\t        log.debug(\"pygdbpython.tohex()\")\n\t        result = hex((val + (1 << nbits)) % (1 << nbits))\n\t        # -1 because hex() only sometimes tacks on a L to hex values...\n\t        if result[-1] == \"L\":\n\t            return result[:-1]\n\t        else:\n\t            return result"]}
{"filename": "libslub/pydbg/debugger.py", "chunked_list": ["import importlib\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\tclass pydbg:\n\t    \"\"\"Python abstraction interface that allows calling into any specific debugger APIs\n\t    Any debugger implementation should implement the methods called on self.debugger\n\t    \"\"\"\n\t    def __init__(self, debugger):\n\t        \"\"\"Initialize the debugger to be used for any future API\n\t        \"\"\"\n", "        self.debugger = debugger\n\t    def execute(self, cmd, to_string=True):\n\t        \"\"\"Execute a command in the debugger CLI\n\t        \"\"\"\n\t        return self.debugger.execute(cmd, to_string=to_string)\n\t    def get_size_sz(self):\n\t        \"\"\"Retrieve the size_t size for the current architecture\n\t        \"\"\"\n\t        return self.debugger.get_size_sz()\n\t    def read_memory(self, address, length):\n", "        \"\"\"Read bytes at the given address of the given length\n\t        \"\"\"\n\t        return self.debugger.read_memory(address, length)\n\t    def parse_variable(self, variable):\n\t        \"\"\"Parse and evaluate a debugger variable expression\n\t        \"\"\"\n\t        return self.debugger.parse_variable(variable)\n\t    def parse_address(self, addresses):\n\t        \"\"\"Parse one or more addresses or debugger variables\n\t        :param address: an address string containing hex, int, or debugger variable\n", "        :return: the resolved addresses as integers\n\t        It this should be able to handle: hex, decimal, program variables\n\t        with or without special characters (like $, &, etc.),\n\t        basic addition and subtraction of variables, etc.\n\t        \"\"\"\n\t        return self.debugger.parse_address(addresses)\n\t    def print_hexdump_chunk(self, sb, o, maxlen=0, off=0, debug=False, unit=8, verbose=1):\n\t        \"\"\"Hexdump chunk data to stdout\n\t        :param sb: slab object\n\t        :param o: obj() object representing the chunk\n", "        :param maxlen: maximum amount of bytes to hexdump\n\t        :param off: offset into the chunk's data to hexdump (after the malloc_chunk header)\n\t        :param debug: debug enabled or not\n\t        :param unit: hexdump unit (e.g. 1, 2, 4, 8, \"dps\")\n\t        :param verbose: see ptchunk's ArgumentParser definition\n\t        \"\"\"\n\t        address = o.address + off\n\t        size = o.size - off\n\t        if size <= 0:\n\t            print(\"[!] Chunk corrupt? Bad size\")\n", "            return\n\t        print(\"0x%x bytes of object data:\" % size)\n\t        shown_size = size\n\t        if maxlen != 0:\n\t            if shown_size > maxlen:\n\t                shown_size = maxlen\n\t        self.print_hexdump(address, shown_size, unit=unit)\n\t    def print_hexdump(self, address, size, unit=8):\n\t        \"\"\"Hexdump data to stdout\n\t        :param address: starting address\n", "        :param size: number of bytes from the address\n\t        :param unit: hexdump unit (e.g. 1, 2, 4, 8, \"dps\")\n\t        \"\"\"\n\t        self.debugger.print_hexdump(address, size, unit=unit)\n"]}
{"filename": "libslub/frontend/frontend_gdb.py", "chunked_list": ["import logging\n\timport importlib\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(f\"frontend_gdb.py\")\n\timport libslub.frontend.commands.gdb.sbhelp as sbhelp\n\timportlib.reload(sbhelp)\n\timport libslub.frontend.commands.gdb.sbbreak as sbbreak\n\timportlib.reload(sbbreak)\n\timport libslub.frontend.commands.gdb.sblist as sblist\n\timportlib.reload(sblist)\n", "import libslub.frontend.commands.gdb.sbtrace as sbtrace\n\timportlib.reload(sbtrace)\n\timport libslub.frontend.commands.gdb.sbwatch as sbwatch\n\timportlib.reload(sbwatch)\n\timport libslub.frontend.commands.gdb.sbcrosscache as sbcrosscache\n\timportlib.reload(sbcrosscache)\n\timport libslub.frontend.commands.gdb.sbmeta as sbmeta\n\timportlib.reload(sbmeta)\n\timport libslub.frontend.commands.gdb.sbcache as sbcache\n\timportlib.reload(sbcache)\n", "import libslub.frontend.commands.gdb.sbslabdb as sbslabdb\n\timportlib.reload(sbslabdb)\n\timport libslub.frontend.commands.gdb.sbobject as sbobject\n\timportlib.reload(sbobject)\n\tclass frontend_gdb:\n\t    \"\"\"Register commands with GDB\"\"\"\n\t    def __init__(self, sb):\n\t        # We share slab among all commands below\n\t        # The below dictates in what order they will be shown in gdb\n\t        cmds = []\n", "        cmds.append(sbcache.sbcache(sb))\n\t        cmds.append(sbobject.sbobject(sb))\n\t        cmds.append(sblist.sblist(sb))\n\t        cmds.append(sbmeta.sbmeta(sb))\n\t        cmds.append(sbslabdb.sbslabdb(sb))\n\t        cmds.append(sbcrosscache.sbcrosscache(sb))\n\t        if sb.breakpoints_enabled:\n\t            cmds.append(sbbreak.sbbreak(sb))\n\t            cmds.append(sbtrace.sbtrace(sb))\n\t            cmds.append(sbwatch.sbwatch(sb))\n", "        sbhelp.sbhelp(sb, cmds)\n"]}
{"filename": "libslub/frontend/__init__.py", "chunked_list": ["import logging\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"libslub/frontend/__init__.py\")"]}
{"filename": "libslub/frontend/helpers2.py", "chunked_list": ["import argparse\n\timport struct\n\timport sys\n\timport traceback\n\timport gdb\n\timport shlex\n\timport logging\n\tfrom functools import wraps, lru_cache\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sb.py\")\n", "# START GEF STUFF\n\t# GEF stuff. This is stuff I took from gef for now, that we could probably\n\t# replace with something from lib ptmalloc or whatever\n\tdef is_alive():\n\t    \"\"\"Check if GDB is running.\"\"\"\n\t    try:\n\t        return gdb.selected_inferior().pid > 0\n\t    except Exception:\n\t        return False\n\t    return False\n", "def cached_lookup_type(_type):\n\t    try:\n\t        return gdb.lookup_type(_type).strip_typedefs()\n\t    except RuntimeError:\n\t        return None\n\tdef _ptr_width():\n\t    void = cached_lookup_type(\"void\")\n\t    if void is None:\n\t        uintptr_t = cached_lookup_type(\"uintptr_t\")\n\t        return uintptr_t.sizeof\n", "    else:\n\t        return void.pointer().sizeof\n\t@lru_cache()\n\tdef is_64bit():\n\t    \"\"\"Checks if current target is 64bit.\"\"\"\n\t    return _ptr_width() == 8\n\t@lru_cache()\n\tdef is_32bit():\n\t    \"\"\"Checks if current target is 32bit.\"\"\"\n\t    return _ptr_width() == 4\n", "def get_memory_alignment(in_bits=False):\n\t    \"\"\"Try to determine the size of a pointer on this system.\n\t    First, try to parse it out of the ELF header.\n\t    Next, use the size of `size_t`.\n\t    Finally, try the size of $pc.\n\t    If `in_bits` is set to True, the result is returned in bits, otherwise in\n\t    bytes.\"\"\"\n\t    if is_32bit():\n\t        return 4 if not in_bits else 32\n\t    elif is_64bit():\n", "        return 8 if not in_bits else 64\n\t    res = cached_lookup_type(\"size_t\")\n\t    if res is not None:\n\t        return res.sizeof if not in_bits else res.sizeof * 8\n\t    try:\n\t        return gdb.parse_and_eval(\"$pc\").type.sizeof\n\t    except:\n\t        pass\n\t    raise EnvironmentError(\"GEF is running under an unsupported mode\")\n\tdef style_byte(b, color=True):\n", "    sbyte = \"{:02x}\".format(b)\n\t    return sbyte\n\tdef hexdump(\n\t    source,\n\t    length=0x10,\n\t    separator=\".\",\n\t    show_raw=False,\n\t    show_symbol=False,\n\t    base=0x00,\n\t    pad=0,\n", "):\n\t    \"\"\"Return the hexdump of `src` argument.\n\t    @param source *MUST* be of type bytes or bytearray\n\t    @param length is the length of items per line\n\t    @param separator is the default character to use if one byte is not printable\n\t    @param show_raw if True, do not add the line nor the text translation\n\t    @param base is the start address of the block being hexdump\n\t    @return a string with the hexdump\"\"\"\n\t    result = []\n\t    align = get_memory_alignment() * 2 + 2 if is_alive() else 18\n", "    for i in range(0, len(source), length):\n\t        chunk = bytearray(source[i : i + length])\n\t        hexa = \" \".join([style_byte(b, color=not show_raw) for b in chunk])\n\t        if show_raw:\n\t            result.append(hexa)\n\t            continue\n\t        text = \"\".join([chr(b) if 0x20 <= b < 0x7F else separator for b in chunk])\n\t        if show_symbol:\n\t            sym = gdb_get_location_from_symbol(base + i)\n\t            sym = \"<{:s}+{:04x}>\".format(*sym) if sym else \"\"\n", "        else:\n\t            sym = \"\"\n\t        result.append(\n\t            \"{padding}{addr:#0{aw}x} {sym} {data:<{dw}} {text}\".format(\n\t                padding=\" \" * pad,\n\t                aw=align,\n\t                addr=base + i,\n\t                sym=sym,\n\t                dw=3 * length,\n\t                data=hexa,\n", "                text=text,\n\t            )\n\t        )\n\t    return \"\\n\".join(result)\n\t# END GEF STUFF\n\tdef get_breakpoint_list():\n\t    \"\"\"return a itemized list of breakpoints\"\"\"\n\t    break_list = gdb.execute(\"info breakpoints\", to_string=True)\n\t    breakpoints = []\n\t    for line in break_list.split(\"\\n\"):\n", "        if not len(line) or line.startswith(\"Num\"):\n\t            continue\n\t        if line.startswith(\"No breakpoints\"):\n\t            break\n\t        items = list(filter(None, line.split(\" \")))\n\t        # Skip \"breakpoint already hit N times\"\n\t        if \"breakpoint\" in items[0]:\n\t            continue\n\t        num = items[0]\n\t        try:\n", "            int(num)\n\t            # could be useful if later a multiple breakpoint is encountered\n\t            prev_num = num\n\t        except:\n\t            try:\n\t                float(num)\n\t                # multiple breakpoint detected\n\t            except:\n\t                continue\n\t        if len(items) != 7 and len(items) != 9:\n", "            continue\n\t        if len(items) == 7:\n\t            # multiple breakpoint needs to use previously saved bp num\n\t            num = prev_num\n\t            address = items[2]\n\t            function = items[4]\n\t            source = items[6]\n\t        elif len(items) == 9:\n\t            address = items[4]\n\t            function = items[6]\n", "            source = items[8]\n\t        breakpoints.append(\n\t            {\"id\": num, \"address\": address, \"function\": function, \"location\": source}\n\t        )\n\t    return breakpoints\n\tdef find_existing_breakpoints(location, single=False):\n\t    source_bp = False\n\t    address_bp = False\n\t    if \":\" in location:\n\t        source_bp = True\n", "    elif location.startswith(\"0x\"):\n\t        address_bp = True\n\t    breakpoints = get_breakpoint_list()\n\t    if not len(breakpoints):\n\t        return None\n\t    bps = []\n\t    for bp in breakpoints:\n\t        if source_bp:\n\t            if bp[\"location\"].endswith(location):\n\t                bps.append(bp)\n", "        elif address_bp:\n\t            if bp[\"address\"] == location:\n\t                bps.append(bp)\n\t        else:\n\t            if bp[\"function\"] == location:\n\t                bps.append(bp)\n\t    if len(bps):\n\t        if single:\n\t            return bps[0]\n\t        return bps\n", "    return None\n\tdef delete_breakpoint(bp):\n\t    log.debug(f'deleting breakpoint {bp[\"id\"]}')\n\t    gdb.execute(f'd br {bp[\"id\"]}')\n\tdef delete_breakpoints(bps):\n\t    for bp in bps:\n\t        delete_breakpoint(bp)\n\tdef clear_existing_breakpoints(name):\n\t    \"\"\"TODO: Docstring for clear_existing_breakpoints.\n\t    :returns: TODO\n", "    \"\"\"\n\t    bps = find_existing_breakpoints(name)\n\t    if bps:\n\t        delete_breakpoints(bps)"]}
{"filename": "libslub/frontend/printutils.py", "chunked_list": ["# taken from https://github.com/cloudburst/libheap/blob/master/libheap/frontend/printutils.py\n\tfrom __future__ import print_function\n\timport re\n\tcolors_enabled = True\n\t# bash color support, taken from pwndbg\n\tNORMAL = \"\\x1b[0m\"\n\tBLACK = \"\\x1b[30m\"\n\tRED = \"\\x1b[31m\"\n\tGREEN = \"\\x1b[32m\"\n\tYELLOW = \"\\x1b[33m\"\n", "BLUE = \"\\x1b[34m\"\n\tPURPLE = \"\\x1b[35m\"\n\tCYAN = \"\\x1b[36m\"\n\tLIGHT_GREY = LIGHT_GRAY = \"\\x1b[37m\"\n\tFOREGROUND = \"\\x1b[39m\"\n\tGREY = GRAY = \"\\x1b[90m\"\n\tLIGHT_RED = \"\\x1b[91m\"\n\tLIGHT_GREEN = \"\\x1b[92m\"\n\tLIGHT_YELLOW = \"\\x1b[93m\"\n\tLIGHT_BLUE = \"\\x1b[94m\"\n", "LIGHT_PURPLE = \"\\x1b[95m\"\n\tLIGHT_CYAN = \"\\x1b[96m\"\n\tWHITE = \"\\x1b[97m\"\n\tBOLD = \"\\x1b[1m\"\n\tUNDERLINE = \"\\x1b[4m\"\n\tdef none(x):\n\t    return str(x)\n\tdef normal(x):\n\t    return colorize(x, NORMAL)\n\tdef black(x):\n", "    return colorize(x, BLACK)\n\tdef red(x):\n\t    return colorize(x, RED)\n\tdef green(x):\n\t    return colorize(x, GREEN)\n\tdef yellow(x):\n\t    return colorize(x, YELLOW)\n\tdef blue(x):\n\t    return colorize(x, BLUE)\n\tdef purple(x):\n", "    return colorize(x, PURPLE)\n\tdef cyan(x):\n\t    return colorize(x, CYAN)\n\tdef foreground(x):\n\t    return colorize(x, FOREGROUND)\n\tdef gray(x):\n\t    return colorize(x, GRAY)\n\tdef light_red(x):\n\t    return colorize(x, LIGHT_RED)\n\tdef light_green(x):\n", "    return colorize(x, LIGHT_GREEN)\n\tdef light_yellow(x):\n\t    return colorize(x, LIGHT_YELLOW)\n\tdef light_blue(x):\n\t    return colorize(x, LIGHT_BLUE)\n\tdef light_purple(x):\n\t    return colorize(x, LIGHT_PURPLE)\n\tdef light_cyan(x):\n\t    return colorize(x, LIGHT_CYAN)\n\tdef light_gray(x):\n", "    return colorize(x, LIGHT_GRAY)\n\tdef white(x):\n\t    return colorize(x, WHITE)\n\tdef bold(x):\n\t    return colorize(x, BOLD)\n\tdef underline(x):\n\t    return colorize(x, UNDERLINE)\n\tdef colorize(x, color):\n\t    if colors_enabled:\n\t        return color + terminateWith(str(x), color) + NORMAL\n", "    else:\n\t        return x\n\tdef terminateWith(x, color):\n\t    return re.sub('\\x1b\\\\[0m', NORMAL + color, x)\n\tdef print_debug(s, end='\\n'):\n\t    debug = \"[#] {0}\".format(s)\n\t    color = LIGHT_PURPLE\n\t    debug = colorize(debug, color)\n\t    print(debug, end=end)\n\tdef print_error(s, end=\"\\n\"):\n", "    error = \"[!] {0}\".format(s)\n\t    color = RED\n\t    error = colorize(error, color)\n\t    print(error, end=end)\n\tdef print_title(s, end=\"\\n\"):\n\t    print(color_title(s), end=end)\n\tdef print_title_wide(s, end=\"\\n\"):\n\t    width = 80\n\t    lwidth = (width-len(s))/2\n\t    rwidth = (width-len(s))/2\n", "    title = '{:=<{lwidth}}{}{:=<{rwidth}}'.format(\n\t            '', s, '', lwidth=lwidth, rwidth=rwidth)\n\t    print(color_title(title), end=end)\n\tdef print_header(s, end=\"\"):\n\t    color = YELLOW\n\t    s = colorize(s, color)\n\t    print(s, end=end)\n\tdef print_footer(s, end=\"\"):\n\t    color = PURPLE\n\t    s = colorize(s, color)\n", "    print(s, end=end)\n\tdef print_value(s, end=\"\"):\n\t    print(color_value(s), end=end)\n\tdef color_header(s):\n\t    color = YELLOW\n\t    return colorize(s, color)\n\tdef color_title(s):\n\t    color = GREEN + UNDERLINE\n\t    return colorize(s, color)\n\tdef color_value(s):\n", "    color = BLUE\n\t    return colorize(s, color)\n\tdef color_footer(s):\n\t    color = PURPLE\n\t    return colorize(s, color)\n"]}
{"filename": "libslub/frontend/helpers.py", "chunked_list": ["import sys\n\timport traceback\n\timport argparse\n\timport struct\n\tfrom functools import wraps\n\tdef show_last_exception():\n\t    \"\"\"Taken from gef. Let us see proper backtraces from python exceptions\"\"\"\n\t    PYTHON_MAJOR = sys.version_info[0]\n\t    horizontal_line = \"-\"\n\t    right_arrow = \"->\"\n", "    down_arrow = \"\\\\->\"\n\t    print(\"\")\n\t    exc_type, exc_value, exc_traceback = sys.exc_info()\n\t    print(\" Exception raised \".center(80, horizontal_line))\n\t    print(\"{}: {}\".format(exc_type.__name__, exc_value))\n\t    print(\" Detailed stacktrace \".center(80, horizontal_line))\n\t    for fs in traceback.extract_tb(exc_traceback)[::-1]:\n\t        if PYTHON_MAJOR == 2:\n\t            filename, lineno, method, code = fs\n\t        else:\n", "            try:\n\t                filename, lineno, method, code = (\n\t                    fs.filename,\n\t                    fs.lineno,\n\t                    fs.name,\n\t                    fs.line,\n\t                )\n\t            except:\n\t                filename, lineno, method, code = fs\n\t        print(\n", "            \"\"\"{} File \"{}\", line {:d}, in {}()\"\"\".format(\n\t                down_arrow, filename, lineno, method\n\t            )\n\t        )\n\t        print(\"   {}    {}\".format(right_arrow, code))\n\tdef is_ascii(s):\n\t    return all(c < 128 and c > 1 for c in s)\n\tdef hms_string(sec_elapsed):\n\t    h = int(sec_elapsed / (60 * 60))\n\t    m = int((sec_elapsed % (60 * 60)) / 60)\n", "    s = int(sec_elapsed % 60)\n\t    if h == 0:\n\t        if m == 0:\n\t            return \"{:>02}s\".format(s)\n\t        else:\n\t            return \"{:>02}m{:>02}s\".format(m, s)\n\t    else:\n\t        return \"{}h{:>02}m{:>02}s\".format(h, m, s)\n\t# https://stackoverflow.com/questions/2556108/rreplace-how-to-replace-the-last-occurrence-of-an-expression-in-a-string\n\tdef rreplace(s, old, new, occurrence):\n", "    li = s.rsplit(old, occurrence)\n\t    return new.join(li)\n\tdef prepare_list(L):\n\t    return rreplace(', '.join([str(x) for x in L]), ',', ' or', 1)\n\tdef string_to_int(num):\n\t    \"\"\"Convert an integer or hex integer string to an int\n\t    :returns: converted integer\n\t    especially helpful for using ArgumentParser()\n\t    \"\"\"\n\t    if num.find(\"0x\") != -1:\n", "        return int(num, 16)\n\t    else:\n\t        return int(num)\n\tdef catch_exceptions(f):\n\t    \"Decorator to catch exceptions\"\n\t    @wraps(f)\n\t    def _catch_exceptions(*args, **kwargs):\n\t        try:\n\t            f(*args, **kwargs)\n\t        except Exception:\n", "            show_last_exception()\n\t    return _catch_exceptions \n\tdef check_positive(value):\n\t    try:\n\t        ivalue = int(value)\n\t    except:\n\t        raise argparse.ArgumentTypeError(\"%s is an invalid positive int value\" % value)\n\t    if ivalue <= 0:\n\t        raise argparse.ArgumentTypeError(\"%s is an invalid positive int value\" % value)\n\t    return ivalue\n", "def check_count_value(value):\n\t    if value == \"unlimited\":\n\t        return None # unlimited\n\t    try:\n\t        ivalue = int(value)\n\t    except:\n\t        raise argparse.ArgumentTypeError(\"%s is an invalid int value\" % value)\n\t    if ivalue == 0:\n\t        return None # unlimited\n\t    return ivalue\n", "def check_count_value_positive(value):\n\t    if value == \"unlimited\":\n\t        return None # unlimited\n\t    try:\n\t        ivalue = int(value)\n\t    except:\n\t        raise argparse.ArgumentTypeError(\"%s is an invalid int value\" % value)\n\t    if ivalue < 0:\n\t        raise argparse.ArgumentTypeError(\"%s needs to be positive int value\" % value)\n\t    if ivalue == 0:\n", "        return None # unlimited\n\t    return ivalue\n\thexdump_units = [1, 2, 4, 8, \"dps\"]\n\tdef check_hexdump_unit(value):\n\t    \"\"\"Especially helpful for using ArgumentParser()\n\t    \"\"\"\n\t    if value == \"dps\":\n\t        return value\n\t    try:\n\t        ivalue = int(value)\n", "    except:\n\t        raise argparse.ArgumentTypeError(\"%s is not a valid hexdump unit\" % value)\n\t    if ivalue not in hexdump_units:\n\t        raise argparse.ArgumentTypeError(\"%s is not a valid hexdump unit\" % value)\n\t    return ivalue\n\tdef swap64(i):\n\t    return struct.unpack(\"<Q\", struct.pack(\">Q\", i))[0]"]}
{"filename": "libslub/frontend/commands/__init__.py", "chunked_list": []}
{"filename": "libslub/frontend/commands/gdb/sbmeta.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport binascii\n\timport struct\n\timport sys\n\timport logging\n\timport pprint\n\timport re\n\timport pickle\n\timport importlib\n", "import gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbmeta.py\")\n\tmeta_cache = {}\n", "backtrace_ignore = set([])\n\tcolorize_table = {\n\t    \"red\": pu.red,\n\t    \"green\": pu.green,\n\t    \"yellow\": pu.yellow,\n\t    \"blue\": pu.blue,\n\t    \"purple\": pu.purple,\n\t    \"cyan\": pu.cyan,\n\t    \"gray\": pu.gray,\n\t    \"lightred\": pu.light_red,\n", "    \"lightgreen\": pu.light_green,\n\t    \"lightyellow\": pu.light_yellow,\n\t    \"lightblue\": pu.light_blue,\n\t    \"lightpurple\": pu.light_purple,\n\t    \"lightcyan\": pu.light_cyan,\n\t    \"lightgray\": pu.light_gray,\n\t    \"white\": pu.white,\n\t    \"black\": pu.black,\n\t}\n\tMETADATA_DB = \"metadata.pickle\"\n", "def save_metadata_to_file(filename):\n\t    \"\"\"During development, we reload libslub and lose the metadata database\n\t    so this allows saving it easily into a file before doing so\n\t    \"\"\"\n\t    d = {}\n\t    d[\"meta_cache\"] = meta_cache\n\t    d[\"backtrace_ignore\"] = backtrace_ignore\n\t    pickle.dump(d, open(filename, \"wb\"))\n\tdef load_metadata_from_file(filename):\n\t    \"\"\"During development, we reload libslub and lose the metadata database\n", "    so this allows reloading it easily from a file\n\t    \"\"\"\n\t    global meta_cache, backtrace_ignore\n\t    d = pickle.load(open(filename, \"rb\"))\n\t    meta_cache = d[\"meta_cache\"]\n\t    backtrace_ignore = d[\"backtrace_ignore\"]\n\tdef get_metadata(address, list_metadata=[]):\n\t    \"\"\"\n\t    :param address: the address to retrieve metatada from\n\t    :param list_metadata: If a list, the list of metadata to retrieve (even empty list).\n", "                          If the \"all\" string, means to retrieve all metadata\n\t    :return: the following L, suffix, epilog, colorize_func\n\t    \"\"\"\n\t    L = [] # used for json output\n\t    suffix = \"\" # used for one-line output\n\t    epilog = \"\" # used for verbose output\n\t    colorize_func = str # do not colorize by default\n\t    if address not in meta_cache:\n\t        epilog += \"chunk address not found in metadata database\\n\"\n\t        return None, suffix, epilog, colorize_func\n", "    # This allows calling get_metadata() by not specifying any metadata\n\t    # but meaning we want to retrieve them all\n\t    if list_metadata == \"all\":\n\t        list_metadata = list(meta_cache[address].keys())\n\t        if \"backtrace\" in list_metadata:\n\t            # enforce retrieving all the functions from the backtrace\n\t            list_metadata.remove(\"backtrace\")\n\t            list_metadata.append(\"backtrace:-1\")\n\t    opened = False\n\t    for key in list_metadata:\n", "        param = None\n\t        if \":\" in key:\n\t            key, param = key.split(\":\")\n\t        if key not in meta_cache[address]:\n\t            if key != \"color\":\n\t                suffix += \" | N/A\"\n\t                epilog += \"'%s' key not found in metadata database\\n\" % key\n\t                opened = True\n\t                L.append(None)\n\t            continue\n", "        if key == \"backtrace\":\n\t            if param == None:\n\t                funcs_list = get_first_function(address)\n\t            else:\n\t                funcs_list = get_functions(address, max_len=int(param))\n\t            if funcs_list == None:\n\t                suffix += \" | N/A\"\n\t            elif len(funcs_list) == 0:\n\t                # XXX - atm if we failed to parse the functions from the debugger\n\t                # we will also show \"filtered\" even if it is not the case\n", "                suffix += \" | filtered\"\n\t            else:\n\t                suffix += \" | %s\" % \",\".join(funcs_list)\n\t            epilog += \"%s\" % meta_cache[address][\"backtrace\"][\"raw\"]\n\t            L.append(funcs_list)\n\t            opened = True\n\t        elif key == \"color\":\n\t            color = meta_cache[address][key]\n\t            colorize_func = colorize_table[color]\n\t        else:\n", "            suffix += \" | %s\" % meta_cache[address][key]\n\t            epilog += \"%s\\n\" % meta_cache[address][key]\n\t            L.append(meta_cache[address][key])\n\t            opened = True\n\t    if opened:\n\t        suffix += \" |\"\n\t    return L, suffix, epilog, colorize_func\n\tdef get_first_function(address):\n\t    return get_functions(address, max_len=1)\n\tdef get_functions(address, max_len=None):\n", "    L = []\n\t    if address not in meta_cache:\n\t        return None\n\t    if \"backtrace\" not in meta_cache[address]:\n\t        return None\n\t    funcs = meta_cache[address][\"backtrace\"][\"funcs\"]\n\t    for f in funcs:\n\t        if f in backtrace_ignore:\n\t            continue\n\t        L.append(f)\n", "        if max_len != None and len(L) == max_len:\n\t            break\n\t    return L\n\tclass sbmeta(sbcmd.sbcmd):\n\t    \"\"\"Command to manage metadata for a given address\"\"\"\n\t    def __init__(self, sb):\n\t        log.debug(\"sbmeta.__init__()\")\n\t        super(sbmeta, self).__init__(sb, \"sbmeta\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Handle metadata associated with object/chunk addresses\"\"\", \n", "            formatter_class=argparse.RawTextHelpFormatter,\n\t            add_help=False,\n\t            epilog=\"\"\"NOTE: use 'sbmeta <action> -h' to get more usage info\"\"\")\n\t        self.parser.add_argument(\n\t            \"-v\", \"--verbose\", dest=\"verbose\", action=\"count\", default=0,\n\t            help=\"Use verbose output (multiple for more verbosity)\"\n\t        )\n\t        self.parser.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n\t            help=\"Show this help\"\n", "        )\n\t        actions = self.parser.add_subparsers(\n\t            help=\"Action to perform\", \n\t            dest=\"action\"\n\t        )\n\t        add_parser = actions.add_parser(\n\t            \"add\",\n\t            help=\"\"\"Save metadata for a given chunk address\"\"\",\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            epilog=\"\"\"The saved metadata can then be shown in any other commands like \n", "'sbcache', etc.\n\tE.g.\n\t  sbmeta add mem-0x10 tag \"service_user struct\"\n\t  sbmeta add 0xdead0030 color green\n\t  sbmeta add 0xdead0030 backtrace\"\"\"\n\t        )\n\t        add_parser.add_argument(\n\t            'address', \n\t            help='Address to link the metadata to'\n\t        )\n", "        add_parser.add_argument(\n\t            'key', \n\t            help='Key name of the metadata (e.g. \"backtrace\", \"color\", \"tag\" or any name)'\n\t        )\n\t        add_parser.add_argument(\n\t            'value', nargs=\"?\",\n\t            help='Value of the metadata, associated with the key (required except when adding a \"backtrace\")'\n\t        )\n\t        add_parser.add_argument(\n\t            '--append', dest=\"append\", action=\"store_true\",\n", "            help='Append value if the key/value already exist instead of overwriting previous value'\n\t        )\n\t        del_parser = actions.add_parser(\n\t            \"del\", \n\t            help=\"\"\"Delete metadata associated with a given chunk address\"\"\",\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            epilog=\"\"\"E.g.\n\t  sbmeta del mem-0x10\n\t  sbmeta del 0xdead0030\"\"\"\n\t        )\n", "        del_parser.add_argument('address', help='Address to remove the metadata for')\n\t        list_parser = actions.add_parser(\n\t            \"list\", \n\t            help=\"\"\"List metadata for a chunk address or all chunk addresses (debugging)\"\"\",\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            epilog=\"\"\"E.g.\n\t  sbmeta list mem-0x10\n\t  sbmeta list 0xdead0030 -M backtrace\n\t  sbmeta list\n\t  sbmeta list -vvvv\n", "  sbmeta list -M \"tag, backtrace:3\"\"\"\n\t        )\n\t        list_parser.add_argument(\n\t            'address', nargs=\"?\", \n\t            help='Address to remove the metadata for'\n\t        )\n\t        list_parser.add_argument(\n\t            \"-M\", \"--metadata\", dest=\"metadata\", type=str, default=None,\n\t            help=\"Comma separated list of metadata to print\"\n\t        )\n", "        config_parser = actions.add_parser(\n\t            \"config\", \n\t            help=\"Configure general metadata behaviour\",\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            epilog=\"\"\"E.g.\n\t  sbmeta config ignore backtrace _nl_make_l10nflist __GI___libc_free\"\"\"\n\t        )\n\t        config_parser.add_argument(\n\t            'feature',  \n\t            help='Feature to configure (e.g. \"ignore\")'\n", "        )\n\t        config_parser.add_argument(\n\t            'key', \n\t            help='Key name of the metadata (e.g. \"backtrace\")'\n\t        )\n\t        config_parser.add_argument(\n\t            'values', nargs=\"+\",\n\t            help='Values of the metadata, associated with the key (e.g. list of function to ignore in a backtrace)'\n\t        )\n\t        # allows to enable a different log level during development/debugging\n", "        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        # allows to save metadata to file during development/debugging\n\t        self.parser.add_argument(\n\t            \"-S\", \"--save-db\", dest=\"save\", action=\"store_true\", default=False,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        # allows to load metadata from file during development/debugging\n", "        self.parser.add_argument(\n\t            \"-L\", \"--load-db\", dest=\"load\", action=\"store_true\", default=False,\n\t            help=argparse.SUPPRESS\n\t        )\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        \"\"\"\n", "        log.debug(\"sbmeta.invoke()\")\n\t        if self.args.action is None and not self.args.save and not self.args.load:\n\t            pu.print_error(\"WARNING: requires an action\")\n\t            self.parser.print_help()\n\t            return\n\t        if self.args.action == \"list\" \\\n\t        or self.args.action == \"add\" \\\n\t        or self.args.action == \"del\":\n\t            address = None\n\t            if self.args.address != None:\n", "                addresses = self.dbg.parse_address(self.args.address)\n\t                if len(addresses) == 0:\n\t                    pu.print_error(\"WARNING: No valid address supplied\")\n\t                    self.parser.print_help()\n\t                    return\n\t                address = addresses[0]\n\t        if self.args.action == \"list\":\n\t            self.list_metadata(address)\n\t            return\n\t        if self.args.action == \"del\":\n", "            self.delete_metadata(address)\n\t            return\n\t        if self.args.action == \"config\":\n\t            self.configure_metadata(self.args.feature, self.args.key, self.args.values)\n\t            return\n\t        if self.args.action == \"add\":\n\t            self.add_metadata(address, self.args.key, self.args.value, self.args.append)\n\t            return\n\t        if self.args.save:\n\t            if self.args.verbose >= 0: # always print since debugging feature\n", "                print(\"Saving metadata database to file...\")\n\t            save_metadata_to_file(METADATA_DB)\n\t            return\n\t        if self.args.load:\n\t            if self.args.verbose >= 0: # always print since debugging feature\n\t                print(\"Loading metadata database from file...\")\n\t            load_metadata_from_file(METADATA_DB)\n\t            return\n\t    def list_metadata(self, address):\n\t        \"\"\"Show the metadata database for all addresses or a given address\n", "        if verbose == 0, shows single-line entries (no \"backtrace\" if not requested)\n\t        if verbose == 1, shows single-line entries (all keys)\n\t        if verbose == 2, shows multi-line entries (no \"backtrace\" if not requested)\n\t        if verbose == 3, shows multi-line entries (all keys)\n\t        \"\"\"\n\t        if len(meta_cache) != 0:\n\t            pu.print_header(\"Metadata database\", end=None)\n\t            if self.args.metadata == None:\n\t                # if no metadata provided by user, we get them all\n\t                list_metadata = []\n", "                for k, d in meta_cache.items():\n\t                    for k2, d2 in d.items():\n\t                        if k2 not in list_metadata:\n\t                            list_metadata.append(k2)\n\t                if self.args.verbose == 0 and \"backtrace\" in list_metadata:\n\t                    list_metadata.remove(\"backtrace\")\n\t            else:\n\t                list_metadata = [e.strip() for e in self.args.metadata.split(\",\")]\n\t            if self.args.verbose <= 1:\n\t                print(\"| address | \", end=\"\")\n", "                print(\" | \".join(list_metadata), end=\"\")\n\t                print(\" |\")\n\t                for k, d in meta_cache.items():\n\t                    if address == None or k == address:\n\t                        L, s, e, colorize_func = get_metadata(k, list_metadata=list_metadata)\n\t                        addr = colorize_func(f\"0x{k:x}\")\n\t                        print(f\"| {addr}\", end=\"\")\n\t                        print(s)\n\t            else:\n\t                for k, d in meta_cache.items():\n", "                    if address == None or k == address:\n\t                        L, s, e, colorize_func = get_metadata(k, list_metadata=list_metadata)\n\t                        addr = colorize_func(f\"0x{k:x}\")\n\t                        print(f\"{addr}:\")\n\t                        print(e)\n\t        else:\n\t            pu.print_header(\"Metadata database\", end=None)\n\t            print(\"N/A\")\n\t        print(\"\")\n\t        if len(backtrace_ignore) != 0:\n", "            pu.print_header(\"Function ignore list for backtraces\", end=None)\n\t            pprint.pprint(backtrace_ignore)\n\t        else:\n\t            pu.print_header(\"Function ignore list for backtraces\", end=None)\n\t            print(\"N/A\")\n\t    def configure_metadata(self, feature, key, values):\n\t        \"\"\"Save given metadata (key, values) for a given feature (e.g. \"backtrace\")\n\t        :param feature: name of the feature (e.g. \"ignore\")\n\t        :param key: name of the metadata (e.g. \"backtrace\")\n\t        :param values: list of values to associate to the key\n", "        \"\"\"\n\t        if self.args.verbose >= 1:\n\t            print(\"Configuring metadata database...\")\n\t        if key == \"backtrace\":\n\t            if feature == \"ignore\":\n\t                backtrace_ignore.update(values)\n\t            else:\n\t                pu.print_error(\"WARNING: Unsupported feature\")\n\t                return\n\t        else:\n", "            pu.print_error(\"WARNING: Unsupported key\")\n\t            return\n\t    def delete_metadata(self, address):\n\t        \"\"\"Delete metadata for a given chunk's address\n\t        \"\"\"\n\t        if address not in meta_cache:\n\t            return\n\t        if self.args.verbose >= 1:\n\t            print(f\"Deleting metadata for {address} from database...\")\n\t        del meta_cache[address]\n", "    def add_metadata(self, address, key, value, append=False):\n\t        \"\"\"Save given metadata (key, value) for a given chunk's address\n\t        E.g. key = \"tag\" and value is an associated user-defined tag\n\t        \"\"\"\n\t        if self.args.verbose >= 1:\n\t            print(\"Adding to metadata database...\")\n\t        if key == \"backtrace\":\n\t            result = self.dbg.get_backtrace()\n\t        elif key == \"color\":\n\t            if value not in colorize_table:\n", "                pu.print_error(f\"ERROR: Unsupported color. Need one of: {', '.join(colorize_table.keys())}\")\n\t                return\n\t            result = value\n\t        else:\n\t            result = value\n\t        if address not in meta_cache:\n\t            meta_cache[address] = {}\n\t        if key != \"backtrace\" and key != \"color\":\n\t            if append is True and key in meta_cache[address].keys():\n\t                result = meta_cache[address][key] + \" ; \" + result\n", "        meta_cache[address][key] = result\n"]}
{"filename": "libslub/frontend/commands/gdb/sbobject.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport binascii\n\timport struct\n\timport sys\n\timport logging\n\timport os\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n", "importlib.reload(pu)\n\timport libslub.slub.kmem_cache as kc\n\timportlib.reload(kc)\n\timport libslub.slub.obj as obj\n\timportlib.reload(obj)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbmeta as sbmeta\n", "importlib.reload(sbmeta)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbobject.py\")\n\tclass sbobject(sbcmd.sbcmd):\n\t    \"\"\"Command to print information about objects aka chunk(s) inside a memory region\n\t    associated with a slab.\n\t    There are a couple of quirks to know. Other commands can share lots of\n\t    arguments and features with the \"sbobject\" command. It would have make\n", "    sense to inherit the other command classes from the \"sbobject\" class, however we \n\t    would have the same problem as with the \"sbcmd\" where we can't reload the \n\t    \"sbobject.py\" file without restarting gdb. This would have been annoying so \n\t    we work around that by having some methods of the \"sbobject\" class defined as \n\t    static methods and we just call into these from the other command classes\n\t    This is less \"clean\" but eases a lot development.\n\t    \"\"\"\n\t    search_types = [\"string\", \"byte\", \"word\", \"dword\", \"qword\"]\n\t    def __init__(self, sb):\n\t        log.debug(\"sbobject.__init__()\")\n", "        super(sbobject, self).__init__(sb, \"sbobject\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Print the metadata and contents of one or more objects/chunks \n\tCan provide you with a summary of a chunk (one-line) or more verbose information \n\tin multiple lines (e.g. hexdump of the object contents). \n\tYou can also list information of multiple chunks, search chunks, etc.\n\t\"\"\", \n\t            add_help=False, \n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            epilog=\"\"\"E.g.\n", "sbobject mem-0x10 -v -x -M \"tag, backtrace\"\n\tsbobject mem-0x10 -M \"backtrace:5\"\n\tAllocated/free flag: M=allocated, F=freed\"\"\")\n\t        sbobject.add_arguments(self)\n\t    @staticmethod\n\t    def add_arguments(self):\n\t        \"\"\"Most arguments are shared by the \"sbobject\" commands and other commands.\n\t        This function allows to initialize them in other commands too\n\t        E.g. if we created a \"sbcache\" class, we will add arguments later\n\t        after we create our own parser\n", "        Note that it is a static method but it has self as a first\n\t        argument to make it easier to read its implementation\n\t        \"\"\"\n\t        if self.name == \"sbobject\":\n\t            group = self.parser\n\t        else:\n\t            group = self.parser.add_argument_group(\"generic optional arguments\")\n\t        if self.name == \"sbobject\":\n\t            self.parser.add_argument(\n\t                \"addresses\", nargs=\"*\", default=None,\n", "                help=\"Address(es) to object(s)/chunk(s) in a memory region associated with a slab\"\n\t            )\n\t        self.parser.add_argument(\n\t            \"-n\",\n\t            dest=\"name\",\n\t            default=None, # None means search in all slab caches\n\t            help=\"The slab cache name (e.g. kmalloc-64). Use \\\"sblist\\\" to get them all\",\n\t        )\n\t        group.add_argument(\n\t            \"-v\", \"--verbose\", dest=\"verbose\", action=\"count\", default=0,\n", "            help=\"Use verbose output (multiple for more verbosity)\"\n\t        )\n\t        group.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n\t            help=\"Show this help\"\n\t        )\n\t        if self.name == \"sbobject\":\n\t            group.add_argument(\n\t                \"-c\", \"--count\", dest=\"count\", type=h.check_count_value, default=1,\n\t                help=\"\"\"Number of objects/chunks to print linearly (also supports \"unlimited\"/0\n", "or negative numbers to print objects/chunks going backwards)\"\"\"\n\t            )\n\t        group.add_argument(\n\t            \"-x\", \"--hexdump\", dest=\"hexdump\", action=\"store_true\", default=False,\n\t            help=\"Hexdump the object/chunk contents\"\n\t        )\n\t        group.add_argument(\n\t            \"-X\", dest=\"hexdump_unit\", type=h.check_hexdump_unit, default=1,\n\t            help=f\"Specify hexdump unit ({h.prepare_list(h.hexdump_units)}) when using -x (default: %(default)s)\"\n\t        )\n", "        group.add_argument(\n\t            \"-m\", \"--maxbytes\", dest=\"maxbytes\", type=h.string_to_int, default=0,\n\t            help=\"Max bytes to dump with -x\"\n\t        )\n\t        if self.name == \"sbobject\" or self.name == \"sbcache\":\n\t            group.add_argument(\n\t                \"-N\", dest=\"no_newline\", action=\"store_true\", default=False,\n\t                help=\"Do not output the trailing newline (summary representation)\"\n\t            )\n\t        group.add_argument(\n", "            \"-p\", dest=\"print_offset\", type=h.string_to_int, default=0,\n\t            help=\"Print data inside at given offset (summary representation)\"\n\t        )\n\t        group.add_argument(\n\t            \"-M\", \"--metadata\", dest=\"metadata\", type=str, default=None,\n\t            help=\"Comma separated list of metadata to print (previously stored with the 'sbmeta' command)\"\n\t        )\n\t        if self.name == \"sbobject\" or self.name == \"sbcache\":\n\t            group.add_argument(\n\t                \"-I\", \"--highlight-types\", dest=\"highlight_types\", type=str, default=None,\n", "                help=\"Comma separated list of chunk types (M, F) for objects/chunks we want to highlight in the output\"\n\t            )\n\t        group.add_argument(\n\t            \"-H\", \"--highlight-addresses\", dest=\"highlight_addresses\", type=str, default=None,\n\t            help=\"Comma separated list of addresses for objects/chunks we want to highlight in the output\"\n\t        )\n\t        group.add_argument(\n\t            \"-G\", \"--highlight-metadata\", dest=\"highlight_metadata\", type=str, default=None,\n\t            help=\"\"\"Comma separated list of metadata (previously stored with the 'sbmeta' command) \n\tfor objects/chunks we want to highlight in the output\"\"\"\n", "        )\n\t        group.add_argument(\n\t            \"--highlight-only\", dest=\"highlight_only\", action=\"store_true\", default=False,\n\t            help=\"Only show the highlighted objects/chunks (instead of just '*' them)\"\n\t        )\n\t        if self.name != \"sbfree\":\n\t            group.add_argument(\n\t                \"--use-cache\", dest=\"use_cache\", action=\"store_true\", default=False,\n\t                help=\"\"\"Do not fetch any internal slab data if you know they haven't changed since\n\tlast time they were cached\"\"\"\n", "            )\n\t        group.add_argument(\n\t            \"-s\", \"--search\", dest=\"search_value\", type=str, default=None,\n\t            help=\"Search a value and show match/no match\"\n\t        )\n\t        group.add_argument(\n\t            \"-S\", \"--search-type\", dest=\"search_type\", type=str, default=\"string\",\n\t            help=f\"Specify search type ({h.prepare_list(sbobject.search_types)}) when using -s (default: %(default)s)\"\n\t        )\n\t        group.add_argument(\n", "            \"--match-only\", dest=\"match_only\", action=\"store_true\", default=False,\n\t            help=\"Only show the matched chunks (instead of just show match/no match)\"\n\t        )\n\t        group.add_argument(\n\t            \"--skip-header\", dest=\"skip_header\", action=\"store_true\", default=False,\n\t            help=\"Don't include chunk header contents in search results\"\n\t        )\n\t        group.add_argument(\n\t            \"--depth\", dest=\"search_depth\", type=h.string_to_int, default=0,\n\t            help=\"How far into each chunk to search, starting from chunk header address\"\n", "        )\n\t        group.add_argument(\n\t            \"--cmds\", dest=\"commands\", type=str, default=None,\n\t            help=\"\"\"Semi-colon separated list of debugger commands to be executed for each chunk that is displayed \n\t('@' is replaced by the chunk address)\"\"\"\n\t        )\n\t        group.add_argument(\n\t            \"--object-info\", dest=\"object_info\", action=\"store_true\", default=False,\n\t            help=\"Show object info such as its slab/cpu/node/etc. (summary representation)\"\n\t        )\n", "        # allows to enable a different log level during development/debugging\n\t        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        # Debug and force printing stuff\n\t        self.parser.add_argument(\n\t            \"-d\", \"--debug\", dest=\"debug\", action=\"store_true\", default=False,\n\t            help=argparse.SUPPRESS\n\t        )\n", "        group.add_argument(\n\t            \"-o\", \"--address-offset\", dest=\"address_offset\", action=\"store_true\", default=False,\n\t            help=\"Print offsets from the first printed chunk instead of addresses\"\n\t        )\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        \"\"\"\n", "        log.debug(\"sbobject.invoke()\")\n\t        self.sb.cache.update_all(name=self.args.name, show_status=self.args.debug, use_cache=self.args.use_cache)\n\t        log.debug(\"sbobject.invoke() (2)\")\n\t        sbobject.prepare_args_if_negative_count(self)\n\t        ret = sbobject.parse_arguments(self)\n\t        if ret == None:\n\t            return\n\t        addresses, highlight_addresses, highlight_metadata, highlight_types = ret\n\t        # we enforced updating the cache once above so no need to do it for every chunk\n\t        chunks = sbobject.parse_many2(\n", "            self, \n\t            addresses, \n\t            highlight_addresses=highlight_addresses, \n\t            highlight_metadata=highlight_metadata, \n\t            highlight_types=highlight_types, \n\t            use_cache=True,\n\t            is_region=True,\n\t        )\n\t    @staticmethod \n\t    def prepare_args_if_negative_count(self):\n", "        \"\"\"This is a little bit of a hack. The idea is to handle cases\n\t        where the user wants to print N chunks going backwards.\n\t        We are going to list all the chunks in the memory region associated with\n\t        a slab until we find all the addresses requested and then craft new arguments \n\t        as if the user requested to print from new addresses N chunks before the requested\n\t        addresses before calling parse_many2()\n\t        \"\"\"\n\t        self.args.reverse = False\n\t        # Nothing to do if the count is positive or unlimited\n\t        if self.args.count == None or self.args.count >= 0:\n", "            return\n\t        # We are making the count positive\n\t        self.args.count = self.args.count*-1\n\t        # And we print N chunks before the requested chunk + the actual chunk\n\t        self.args.count += 1\n\t        addresses = self.dbg.parse_address(self.args.addresses)\n\t        if len(addresses) == 0:\n\t            pu.print_error(\"WARNING: No valid address supplied\")\n\t            self.parser.print_help()\n\t            return\n", "        # We will fill it with new addresses later below\n\t        self.args.addresses = []\n\t        # In what slab caches to look for objects?\n\t        name = self.args.name\n\t        if name != None and name in self.sb.cache.slab_caches.keys():\n\t            kmem_caches = [self.sb.cache.slab_caches[name]]\n\t        elif name == None:\n\t            kmem_caches = list(self.sb.cache.slab_caches.values())\n\t        # Prepare arguments for \"sbobject\" format\n\t        # i.e. for every address, get the new address N chunks before\n", "        for addr in addresses:\n\t            ret = obj.obj.is_object_address_in_slab_caches(kmem_caches, addr)\n\t            if ret is None and name != None:\n\t                pu.print_error(f\"WARNING: Could not find {addr:#x} in slab cache, skipping\")\n\t                continue\n\t            (index, objects_list) = ret\n\t            index -= (self.args.count-1)\n\t            if index < 0:\n\t                pu.print_error(f\"WARNING: Reaching beginning of memory region with {addr:#x}\")\n\t                index = 0\n", "            self.args.addresses.append(f\"{objects_list[index].address:#x}\")\n\t    @staticmethod\n\t    def parse_arguments(self):\n\t        log.debug(\"sbobject.parse_arguments()\")\n\t        addresses = []\n\t        if not self.args.addresses:\n\t            print(\"WARNING: No address supplied?\")\n\t            #self.parser.print_help()\n\t            return None\n\t        else:\n", "            addresses = self.dbg.parse_address(self.args.addresses)\n\t            if len(addresses) == 0:\n\t                pu.print_error(\"WARNING: No valid address supplied\")\n\t                #self.parser.print_help()\n\t                return None\n\t        if self.args.hexdump_unit not in h.hexdump_units:\n\t            pu.print_error(\"Wrong hexdump unit specified\")\n\t            #self.parser.print_help()\n\t            return None\n\t        if self.args.name != None and self.args.name not in self.sb.cache.slab_caches.keys():\n", "            pu.print_error(f\"Wrong slab cache name specified {self.args.name}\")\n\t            #self.parser.print_help()\n\t            return None\n\t        if self.args.search_type not in sbobject.search_types:\n\t            pu.print_error(f\"Wrong search type specified {self.args.search_type}\")\n\t            #self.parser.print_help()\n\t            return None\n\t        if self.args.search_type != \"string\" and not self.args.search_value.startswith(\"0x\"):\n\t            pu.print_error(\"Wrong search value for specified type\")\n\t            #self.parser.print_help()\n", "            return None\n\t        highlight_addresses = []\n\t        if self.args.highlight_addresses:\n\t            list_highlight_addresses = [e.strip() for e in self.args.highlight_addresses.split(\",\")]\n\t            highlight_addresses = self.dbg.parse_address(list_highlight_addresses)\n\t            if len(highlight_addresses) == 0:\n\t                pu.print_error(\"WARNING: No valid address to highlight supplied\")\n\t                #self.parser.print_help()\n\t                return None\n\t        highlight_metadata = []\n", "        if self.args.highlight_metadata:\n\t            highlight_metadata = [e.strip() for e in self.args.highlight_metadata.split(\",\")]\n\t        # some commands inheriting sbobject arguments don't support highlighting types\n\t        try:\n\t            highlight_types = self.args.highlight_types\n\t        except AttributeError:\n\t            highlight_types = None\n\t        if highlight_types:\n\t            highlight_types = [e.strip() for e in highlight_types.split(\",\")]\n\t            for e in highlight_types:\n", "                if e not in [\"M\", \"F\"]:\n\t                    pu.print_error(\"WARNING: Invalid type to highlight supplied\")\n\t                    #self.parser.print_help()\n\t                    return None\n\t        else:\n\t            highlight_types = []\n\t        return addresses, highlight_addresses, highlight_metadata, highlight_types\n\t    @staticmethod\n\t    def parse_many2(self,\n\t        addresses, \n", "        highlight_addresses=[], \n\t        highlight_metadata=[], \n\t        highlight_types=[],\n\t        inuse=None,\n\t        main_slab_freelist=None,\n\t        allow_invalid=False,\n\t        separate_addresses_non_verbose=True,\n\t        header_once=None,\n\t        count_handle=None,\n\t        count_printed=None,\n", "        use_cache=False, \n\t        is_region=False,\n\t        is_freelist=False,\n\t    ):\n\t        \"\"\"Most arguments are shared by \"sbobject\" and other commands.\n\t        This function allows for other commands to call into \"sbobject\"\n\t        :param inuse: True if we know it is an inuse chunk (i.e. not in any bin) (not required)\n\t        :param main_slab_freelist: True if we know all the chunks are in the cpu main slab freelist,\n\t                        False if we know they are NOT in the cpu main slab freelist. \n\t                        None otherwise.\n", "        :param allow_invalid: sometimes these structures will be used for\n\t                              that isn't actually a complete chunk, like a freebin, in these cases we\n\t                              still wanted to be able to parse so that we can access the forward and\n\t                              backward pointers, so shouldn't complain about their being invalid size\n\t        :param separate_addresses_non_verbose: False to avoid a separation when printing\n\t                                               one-line chunks, like in feelists\n\t        :param header_once: string to print before printing the first chunk, or None if not needed\n\t        :param count_handle: maximum number of chunks to handle per address, even if not printed, or None if unlimited\n\t        :param count_printed: maximum number of chunks to print in total for all addresses, or None if unlimited.\n\t                              Only useful if handling a freebin.\n", "        :return: the list of objects found\n\t        Note that it is a static method but it has self as a first\n\t        argument to make it easier to read its implementation\n\t        \"\"\"\n\t        hexdump_unit = self.args.hexdump_unit\n\t        count = self.args.count\n\t        search_depth = self.args.search_depth\n\t        skip_header = self.args.skip_header\n\t        print_offset = self.args.print_offset\n\t        metadata = self.args.metadata\n", "        verbose = self.args.verbose\n\t        no_newline = self.args.no_newline\n\t        debug = self.args.debug\n\t        hexdump = self.args.hexdump\n\t        maxbytes = self.args.maxbytes\n\t        commands = self.args.commands\n\t        address_offset = self.args.address_offset\n\t        name = self.args.name\n\t        search_value = self.args.search_value\n\t        search_type = self.args.search_type\n", "        match_only = self.args.match_only\n\t        highlight_only = self.args.highlight_only\n\t        object_info = self.args.object_info\n\t        # In what slab caches to look for objects?\n\t        if name != None and name in self.sb.cache.slab_caches.keys():\n\t            kmem_caches = [self.sb.cache.slab_caches[name]]\n\t        elif name == None:\n\t            kmem_caches = list(self.sb.cache.slab_caches.values())\n\t        all_chunks = []\n\t        chunks = None\n", "        for address in addresses:\n\t            if chunks is not None and len(chunks) > 0 and \\\n\t            (separate_addresses_non_verbose or verbose > 0):\n\t                print(\"-\" * 60)\n\t            if count_printed == None:\n\t                count_linear = count\n\t            elif count == None:\n\t                count_linear = count_printed\n\t            else:\n\t                count_linear = min(count_printed, count)\n", "            ret = obj.obj.is_object_address_in_slab_caches(kmem_caches, address)\n\t            if ret is None:\n\t                return\n\t            (index, objects_list) = ret\n\t            chunks = sbobject.parse_many(\n\t                objects_list, \n\t                index, \n\t                self.sb, \n\t                self.dbg, \n\t                count_linear, \n", "                count_handle, \n\t                search_depth,\n\t                skip_header, \n\t                hexdump_unit, \n\t                search_value, \n\t                search_type, \n\t                match_only, \n\t                print_offset, \n\t                verbose,\n\t                no_newline,\n", "                debug, \n\t                hexdump, \n\t                maxbytes, \n\t                metadata,\n\t                highlight_types=highlight_types,\n\t                highlight_addresses=highlight_addresses,\n\t                highlight_metadata=highlight_metadata,\n\t                highlight_only=highlight_only,\n\t                inuse=inuse, \n\t                allow_invalid=allow_invalid,\n", "                header_once=header_once, \n\t                commands=commands,\n\t                use_cache=use_cache,\n\t                address_offset=address_offset,\n\t                name=name,\n\t                is_region=is_region,\n\t                is_freelist=is_freelist,\n\t                object_info=object_info,\n\t            )\n\t            if chunks is not None and len(chunks) > 0:\n", "                all_chunks.extend(chunks)\n\t                if count_printed != None:\n\t                    count_printed -= len(chunks)\n\t                header_once = None\n\t            if count_printed == 0:\n\t                break\n\t        return all_chunks\n\t    # XXX - probably sb can just have the debugger\n\t    @staticmethod\n\t    def parse_many(\n", "        objects_list, \n\t        index, \n\t        sb, \n\t        dbg=None, \n\t        count=1, \n\t        count_handle=None, \n\t        search_depth=0, \n\t        skip_header=False, \n\t        hexdump_unit=1, \n\t        search_value=None,\n", "        search_type=None, \n\t        match_only=False, \n\t        print_offset=0, \n\t        verbose=0, \n\t        no_newline=False,\n\t        debug=False, \n\t        hexdump=False, \n\t        maxbytes=0, \n\t        metadata=None,\n\t        highlight_types=[], \n", "        highlight_addresses=[], \n\t        highlight_metadata=[], \n\t        highlight_only=False, \n\t        inuse=None, \n\t        allow_invalid=False,\n\t        header_once=None, \n\t        commands=None,\n\t        use_cache=False, \n\t        address_offset=False, \n\t        name=None,\n", "        indent=\"\",\n\t        is_region=False,\n\t        is_freelist=False,\n\t        object_info=False,\n\t    ):\n\t        \"\"\"Parse many chunks starting from a given address and show them based\n\t        passed arguments\n\t        :param objects_list: list of objects (linear view for memory regions or freelist)\n\t        :param index: index in objects_list[] to start parsing from\n\t        :param sb: slab object (libslub constants and helpers)\n", "        :param dbg: pydbg object (debugger interface)\n\t        :param count: see sbobject's ArgumentParser definition\n\t                      maximum number of chunks to print, or None if unlimited\n\t        :param count_handle: maximum number of chunks to handle per address, even if not printed, or None if unlimited\n\t        :param search_depth: see sbobject's ArgumentParser definition\n\t        :param skip_header: see sbobject's ArgumentParser definition\n\t        :param hexdump_unit: see sbobject's ArgumentParser definition\n\t        :param search_value: see sbobject's ArgumentParser definition\n\t        :param search_type: see sbobject's ArgumentParser definition\n\t        :param match_only: see sbobject's ArgumentParser definition\n", "        :param print_offset: see sbobject's ArgumentParser definition\n\t        :param verbose: see sbobject's ArgumentParser definition\n\t        :param no_newline: see sbobject's ArgumentParser definition\n\t        :param debug: see sbobject's ArgumentParser definition\n\t        :param hexdump: see sbobject's ArgumentParser definition\n\t        :param maxbytes: see sbobject's ArgumentParser definition\n\t        :param metadata: see sbobject's ArgumentParser definition\n\t        :param highlight_types: list of types. highlight chunks with matching type with a '*' e.g. to be used by 'ptlist'\n\t        :param highlight_addresses: list of addresses. highlight chunks with matching address with a '*' e.g. to be used by 'ptlist'\n\t        :param highlight_metadata: list of metadata. highlight chunks with matching metadata with a '*' e.g. to be used by 'ptlist'\n", "        :param highlight_only: see sbobject's ArgumentParser definition\n\t        :param inuse: True if we know all the chunks are inuse (i.e. not in any bin)\n\t                      False if we know they are NOT in inuse.\n\t                      None otherwise.\n\t                      Useful to specify when parsing a regular bin\n\t        :param allow_invalid: sometimes these structures will be used for\n\t                              that isn't actually a complete chunk, like a freebin, in these cases we\n\t                              still wanted to be able to parse so that we can access the forward and\n\t                              backward pointers, so shouldn't complain about their being invalid size\n\t        :param header_once: string to print before printing the first chunk, or None if not needed\n", "        :param commands: see sbobject's ArgumentParser definition\n\t        :param use_cache: see sbobject's ArgumentParser definition\n\t        :param address_offset: see sbobject's ArgumentParser definition\n\t        :param name: see sbobject's ArgumentParser definition\n\t        :return: the list of malloc_chunk being parsed and already shown\n\t        \"\"\"\n\t        chunks = []\n\t        if len(objects_list) == 0 or index >= len(objects_list):\n\t            return chunks\n\t        highlight_types = set(highlight_types)\n", "        for t in highlight_types:\n\t            if t != \"M\" and t != \"F\":\n\t                print(\"ERROR: invalid chunk type provided, should not happen\")\n\t                return []\n\t        highlight_addresses = set(highlight_addresses)\n\t        highlight_metadata = set(highlight_metadata)\n\t        highlight_metadata_found = set([])\n\t        count_objects = len(objects_list)\n\t        o = objects_list[index]\n\t        first_address = o.address\n", "        dump_offset = 0\n\t        while True:\n\t            prefix = \"\" # used for one-line output\n\t            suffix = \"\" # used for one-line output\n\t            epilog = \"\" # used for verbose output\n\t            if object_info:\n\t                show_slab_cache = name is None\n\t                suffix += f\" ({o.info(show_slab_cache=show_slab_cache)})\"\n\t            colorize_func = str # do not colorize by default\n\t            if metadata is not None:\n", "                opened = False\n\t                list_metadata = [e.strip() for e in metadata.split(\",\")]\n\t                L, s, e, colorize_func = sbmeta.get_metadata(o.address, list_metadata=list_metadata)\n\t                suffix += s\n\t                epilog += e\n\t                o.metadata = L # save so we can easily export to json later\n\t            if search_value is not None:\n\t                if not dbg.search_chunk(\n\t                    sb, o, search_value, search_type=search_type,\n\t                    depth=search_depth, skip=skip_header\n", "                ):\n\t                    found_match = False\n\t                    suffix += \" [NO MATCH]\"\n\t                else:\n\t                    suffix += pu.light_green(\" [MATCH]\")\n\t                    found_match = True\n\t            # XXX - the current representation is not really generic as we print the first short\n\t            # as an ID and the second 2 bytes as 2 characters. We may want to support passing the\n\t            # format string as an argument but this is already useful\n\t            if print_offset != 0:\n", "                mem = dbg.read_memory(\n\t                    o.address + print_offset, 4\n\t                )\n\t                (id_, desc) = struct.unpack_from(\"<H2s\", mem, 0x0)\n\t                if h.is_ascii(desc):\n\t                    suffix += \" 0x%04x %s\" % (id_, str(desc, encoding=\"utf-8\"))\n\t                else:\n\t                    suffix += \" 0x%04x hex(%s)\" % (\n\t                        id_,\n\t                        str(binascii.hexlify(desc), encoding=\"utf-8\"),\n", "                    )\n\t            if is_region:\n\t                if index == 0:\n\t                    suffix += \" (region start)\"\n\t                elif index == count_objects-1:\n\t                    suffix += \" (region end)\"\n\t            if is_freelist:\n\t                suffix += f\" [{index+1:#d}]\"\n\t            # Only print the chunk type for non verbose\n\t            printed = False\n", "            if verbose == 0:\n\t                found_highlight = False\n\t                # Only highlight chunks for non verbose\n\t                if o.address in highlight_addresses:\n\t                    found_highlight = True\n\t                    highlight_addresses.remove(o.address)\n\t                if (o.inuse is True and \"M\" in highlight_types) or \\\n\t                    (o.inuse is False and \"F\" in highlight_types):\n\t                    found_highlight = True\n\t                if len(highlight_metadata) > 0:\n", "                    # We retrieve all metadata since we want to highlight chunks containing any of the\n\t                    # metadata, even if we don't show some of the metadata\n\t                    _, s, _, _ = sbmeta.get_metadata(o.address, list_metadata=\"all\")\n\t                    for m in highlight_metadata:\n\t                        # we check in the one-line output as it should have less non-useful information\n\t                        if m in s:\n\t                            found_highlight = True\n\t                            highlight_metadata_found.add(m)\n\t                if found_highlight:\n\t                    prefix += \"* \"\n", "                if (not highlight_only or found_highlight) \\\n\t                    and (not match_only or found_match):\n\t                    if header_once != None:\n\t                        print(indent + header_once)\n\t                        header_once = None\n\t                    if no_newline:\n\t                        print(indent + prefix + o.to_string(colorize_func=colorize_func) + suffix, end=\"\")\n\t                    else:\n\t                        print(indent + prefix + o.to_string(colorize_func=colorize_func) + suffix)\n\t                    printed = True\n", "            elif verbose >= 1 and (not match_only or found_match):\n\t                if header_once != None:\n\t                    print(indent + header_once)\n\t                    header_once = None\n\t                print(indent + o)\n\t                printed = True\n\t            if printed:\n\t                if hexdump:\n\t                    dbg.print_hexdump_chunk(sb, o, maxlen=maxbytes, off=dump_offset, unit=hexdump_unit, verbose=verbose)\n\t                if verbose >= 1 and epilog:\n", "                    print(indent + epilog, end=\"\")\n\t                if commands:\n\t                    for command in commands.split(\";\"):\n\t                        formatted_command = command.replace(\"@\", f\"{o.address:#x}\")\n\t                        if no_newline:\n\t                            print(indent + dbg.execute(formatted_command), end=\"\")\n\t                        else:\n\t                            print(indent + dbg.execute(formatted_command))\n\t                chunks.append(o)\n\t                if count != None:\n", "                    count -= 1\n\t            if count_handle != None:\n\t                count_handle -= 1\n\t            index += 1\n\t            if count != 0 and count_handle != 0:\n\t                if printed and (verbose >= 1 or hexdump):\n\t                    print(indent+\"--\")\n\t                if index == count_objects:\n\t                    # Only print the chunk type for non verbose\n\t                    print(\"Stopping due to end of memory region\")\n", "                    break\n\t                o = objects_list[index]\n\t            else:\n\t                break\n\t        # XXX - can't really show that atm as we have lots of memory regions\n\t        # each associated with a given slab, so would spam messages\n\t        #if len(highlight_addresses) != 0:\n\t        #    pu.print_error(\"WARNING: Could not find these chunk addresses: %s\" % (\", \".join([\"0x%x\" % x for x in highlight_addresses])))\n\t        #if len(highlight_metadata-highlight_metadata_found) != 0:\n\t        #    pu.print_error(\"WARNING: Could not find these metadata: %s\" % (\", \".join(list(highlight_metadata-highlight_metadata_found))))\n", "        return chunks"]}
{"filename": "libslub/frontend/commands/gdb/sbbreak.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport struct\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.sb as sb\n", "importlib.reload(sb)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbbreak.py\")\n\tclass sbbreak(sbcmd.sbcmd):\n\t    \"\"\"Command to start/stop breaking on object allocations for a slab cache\"\"\"\n\t    def __init__(self, sb):\n", "        log.debug(\"sbbreak.__init__()\")\n\t        super(sbbreak, self).__init__(sb, \"sbbreak\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Start/stop breaking on object allocations for a slab cache\n\tSetup break points for the specified slab names\"\"\", \n\t            add_help=False,\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t        )\n\t        self.parser.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n", "            help=\"Show this help\"\n\t        )\n\t        # allows to enable a different log level during development/debugging\n\t        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        self.parser.add_argument(\n\t            \"names\", nargs=\"*\", default=[],\n\t            help=\"Slab names (e.g. 'kmalloc-1k')\"\n", "        )\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        \"\"\"\n\t        log.debug(\"sbbreak.invoke()\")\n\t        for name in self.args.names:\n\t            slab_cache = sb.sb.find_slab_cache(name)\n", "            if slab_cache is None:\n\t                print(\"Slab cache '%s' not found\" % name)\n\t                return\n\t            if name in self.sb.break_caches:\n\t                print(\"Stopped breaking slab cache '%s'\" % name)\n\t                self.sb.break_caches.remove(name)\n\t            else:\n\t                print(\"Started breaking slab cache '%s'\" % name)\n\t                self.sb.break_caches.append(name)\n\t            self.sb.breakpoints.update_breakpoints()"]}
{"filename": "libslub/frontend/commands/gdb/sbhelp.py", "chunked_list": ["from __future__ import print_function\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\timport libslub.frontend.helpers as h\n", "importlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbhelp.py\")\n\tclass sbhelp(sbcmd.sbcmd):\n\t    \"\"\"Command to list all available commands\"\"\"\n\t    def __init__(self, sb, commands=[]):\n\t        log.debug(\"sbhelp.__init__()\")\n\t        super(sbhelp, self).__init__(sb, \"sbhelp\")\n", "        self.cmds = commands\n\t    @h.catch_exceptions\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        Print the usage of all the commands\n\t        \"\"\"\n\t        pu.print_header(\"{:<20}\".format(\"sbhelp\"), end=\"\")\n\t        print(\"List all libslub commands\")\n\t        for cmd in self.cmds:\n", "            if cmd.parser != None:\n\t                # Only keep the first line of the description which should be short\n\t                description = cmd.parser.description.split(\"\\n\")[0]\n\t            elif cmd.description != None:\n\t                description = cmd.description\n\t            else:\n\t                description = \"Unknown\"\n\t            pu.print_header(\"{:<20}\".format(cmd.name), end=\"\")\n\t            print(description)\n\t        print(\"Note: Use a command name with -h to get additional help\")\n", "        print(\"Note: Modify libslub.cfg if you want to enable or disable sbbreak/sbtrace/sbwatch commands (may crash GDB due to broken finish)\")"]}
{"filename": "libslub/frontend/commands/gdb/sbcache.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport struct\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.sb as sb\n", "importlib.reload(sb)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.slub.kmem_cache as kc\n\timportlib.reload(kc)\n\timport libslub.frontend.commands.gdb.sbobject as sbobject\n\timportlib.reload(sbobject)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n", "log.trace(\"sbcache.py\")\n\tclass sbcache(sbcmd.sbcmd):\n\t    \"\"\"Command to print the metadata and contents of one or all slab cache(s)\"\"\"\n\t    def __init__(self, sb):\n\t        log.debug(\"sbcache.__init__()\")\n\t        super(sbcache, self).__init__(sb, \"sbcache\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Print the metadata and contents of one or all slab cache(s)\n\tIf you don't specify any slab cache name, it will print all of them but it will take some time to parse structures in memory\"\"\", \n\t            add_help=False,\n", "            formatter_class=argparse.RawTextHelpFormatter,\n\t        )\n\t        # \"sbobject\" also has this argument but default for \n\t        # \"sbcache\" is to show unlimited number of chunks\n\t        self.parser.add_argument(\n\t            \"-c\", \"--count\", dest=\"count\", type=h.check_count_value_positive, default=None,\n\t            help=\"\"\"Number of chunks to print linearly in each slab or in each freelist\"\"\"\n\t        )\n\t        # XXX - is it a feature we want for filtering too?\n\t        #self.parser.add_argument(\n", "        #    \"-C\", \"--count-slab\", dest=\"count_slab\", type=h.check_count_value_positive, default=None,\n\t        #    help=\"\"\"Number of slabs to print for each cpu\"\"\"\n\t        #)\n\t        self.parser.add_argument(\n\t            \"--cpu\", dest=\"cpu\", type=int, default=None,\n\t            help=\"\"\"Show CPU specified only, instead of all slabs (Ignore node's partial slabs and full slabs)\"\"\"\n\t        )\n\t        self.parser.add_argument(\n\t            \"--main-slab\", dest=\"main_slab\", action=\"store_true\", default=None,\n\t            help=\"\"\"Show main slabs for CPUs only, instead of all slabs (Ignore CPU partial slabs, node's partial slabs and full slabs)\"\"\"\n", "        )\n\t        self.parser.add_argument(\n\t            \"--partial-slab\", dest=\"partial_slab\", action=\"store_true\", default=None,\n\t            help=\"\"\"Show partial slabs for CPUs only, instead of all slabs (Ignore CPU main slabs, node's partial slabs and full slabs)\"\"\"\n\t        )\n\t        self.parser.add_argument(\n\t            \"--node-slab\", dest=\"node_slab\", action=\"store_true\", default=None,\n\t            help=\"\"\"Show partial slabs for nodes only, instead of all slabs (Ignore CPU main/partial slabs and node's full slabs)\"\"\"\n\t        )\n\t        self.parser.add_argument(\n", "            \"--full-slab\", dest=\"full_slab\", action=\"store_true\", default=None,\n\t            help=\"\"\"Show full slabs only, instead of all slabs (Ignore CPU main and partial slabs, node's partial slabs)\"\"\"\n\t        )\n\t        self.parser.add_argument(\n\t            \"--show-freelist\", dest=\"show_freelist\", action=\"store_true\", default=None,\n\t            help=\"\"\"Show the freelists for each slab (not shown by default)\"\"\"\n\t        )\n\t        self.parser.add_argument(\n\t            \"--show-lockless-freelist\", dest=\"show_lockless_freelist\", action=\"store_true\", default=None,\n\t            help=\"\"\"Show the freelist associated to a CPU for the main slab (not shown by default)\"\"\"\n", "        )\n\t        self.parser.add_argument(\n\t            \"--show-region\", dest=\"show_region\", action=\"store_true\", default=None,\n\t            help=\"\"\"Show the objects in the memory region for each slab (not shown by default)\"\"\"\n\t        )\n\t        self.parser.add_argument(\n\t            \"--hide-title\", dest=\"hide_title\", action=\"store_true\", default=False,\n\t            help=\"\"\"Hide the \"region:\" or \"freelist:\" titles (shown by default) when showing regions or freelists\"\"\"\n\t        )\n\t        self.parser.add_argument(\n", "            \"--object-only\", dest=\"object_only\", action=\"store_true\", default=None,\n\t            help=\"\"\"Do not show structures' fields and show objects only (still requires --show-freelist and/or --show-region)\"\"\"\n\t        )\n\t        # other arguments are implemented in the \"sbobject\" command\n\t        # and will be shown after the above\n\t        sbobject.sbobject.add_arguments(self)\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n", "        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        \"\"\"\n\t        log.debug(\"sbcache.invoke()\")\n\t        self.sb.cache.update_all(name=self.args.name, show_status=self.args.debug, use_cache=self.args.use_cache)\n\t        self.args.use_cache = True # we can use the cache from now on\n\t        log.debug(\"sbcache.invoke() (2)\")\n\t        # Prepare fake arguments for \"sbobject\" format\n\t        self.args.addresses = [\"0x0\"] # won't use it until we parse actual memory regions\n\t                                      # where we will parse cached memory regions directly at that time anyway\n\t        ret = sbobject.sbobject.parse_arguments(self)\n", "        if ret == None:\n\t            return\n\t        addresses, self.highlight_addresses, self.highlight_metadata, self.highlight_types = ret\n\t        # this is not a real user argument but is used internally to know if we need to print stuff\n\t        self.output_filtered = False\n\t        self.cpu_filtered = False\n\t        if self.args.main_slab is True or self.args.partial_slab is True \\\n\t            or self.args.node_slab is True or self.args.full_slab is True:\n\t            self.output_filtered = True\n\t        if self.args.cpu is not None:\n", "            self.cpu_filtered = True\n\t        if self.args.cpu is not None and (self.args.node_slab is True or self.args.full_slab is True) \\\n\t            and self.args.main_slab is not True and self.args.partial_slab is not True:\n\t            print(\"WARNING: --cpu will be ignored\")\n\t        name = self.args.name\n\t        if name != None and name in self.sb.cache.slab_caches.keys():\n\t            self.sb.cache.slab_caches[name].print(cmd=self)\n\t        elif name == None:\n\t            for name, kmem_cache in self.sb.cache.slab_caches.items():\n\t                kmem_cache.print(cmd=self)\n", "        return"]}
{"filename": "libslub/frontend/commands/gdb/sbcmd.py", "chunked_list": ["# Note: We can't importlib.reload() this file atm because\n\t# otherwise we get an \"super(type, obj): obj must be an instance \n\t# or subtype of type\" when instanciating\n\t# several classes inheriting from the same ptcmd class.\n\t# See https://thomas-cokelaer.info/blog/2011/09/382/\n\t# This file should not change much anyway but if we modify it, we need to restart gdb\n\t# entirely instead of reloading libslub only\n\timport logging\n\timport shlex\n\tfrom functools import wraps\n", "import gdb\n\tfrom libslub.frontend import printutils as pu\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbcmd.py\")\n\tclass sbcmd(gdb.Command):\n\t    \"\"\"This is a super class with convenience methods shared by all the commands to:\n\t    - parse the command's arguments/options\n\t    - set/reset a logging level (debugging only)\n\t    \"\"\"\n\t    def __init__(self, sb, name):\n", "        self.sb = sb\n\t        if self.sb.dbg is None:\n\t            pu.print_error(\"Please specify a debugger\")\n\t            raise Exception(\"sys.exit()\")\n\t        self.name = name\n\t        self.old_level = None\n\t        self.parser = None      # ArgumentParser\n\t        self.description = None # Only use if not in the parser\n\t        super(sbcmd, self).__init__(name, gdb.COMMAND_DATA, gdb.COMPLETE_NONE)\n\t    @property\n", "    def version(self):\n\t        \"\"\"Easily access the version string without going through the slab object\"\"\"\n\t        return self.sb.version\n\t    @property\n\t    def dbg(self):\n\t        \"\"\"Easily access the pydbg object without going through the slab object\"\"\"\n\t        return self.sb.dbg\n\t    @property\n\t    def cache(self):\n\t        \"\"\"Easily access the cache object without going through the slab object\"\"\"\n", "        return self.sb.cache\n\t    def set_loglevel(self, loglevel):\n\t        \"\"\"Change the logging level. This is changed temporarily for the duration\n\t        of the command since reset_loglevel() is called at the end after the command is executed\n\t        \"\"\"\n\t        if loglevel != None:\n\t            numeric_level = getattr(logging, loglevel.upper(), None)\n\t            if not isinstance(numeric_level, int):\n\t                print(\"WARNING: Invalid log level: %s\" % loglevel)\n\t                return\n", "            self.old_level = log.getEffectiveLevel()\n\t            #print(\"old loglevel: %d\" % self.old_level)\n\t            #print(\"new loglevel: %d\" % numeric_level)\n\t            log.setLevel(numeric_level)\n\t    def reset_loglevel(self):\n\t        \"\"\"Reset the logging level to the previous one\"\"\"\n\t        if self.old_level != None:\n\t            #print(\"restore loglevel: %d\" % self.old_level)\n\t            log.setLevel(self.old_level)\n\t            self.old_level = None\n", "    def init_and_cleanup(f):\n\t        \"\"\"Decorator for a command's invoke() method\n\t        This allows:\n\t        - not having to duplicate the argument parsing in all commands\n\t        - not having to reset the log level before each of the \"return\"\n\t          in the invoke() of each command\n\t        \"\"\"\n\t        @wraps(f)\n\t        def _init_and_cleanup(self, arg, from_tty):\n\t            try:\n", "                self.args = self.parser.parse_args(shlex.split(arg))\n\t            except SystemExit as e:\n\t                # If we specified an unsupported argument/option, argparse will try to call sys.exit()\n\t                # which will trigger such an exception, so we can safely catch it to avoid error messages\n\t                # in gdb\n\t                #h.show_last_exception()\n\t                #raise e\n\t                return\n\t            if self.args.help:\n\t                self.parser.print_help()\n", "                return\n\t            self.set_loglevel(self.args.loglevel)\n\t            f(self, arg, from_tty) # Call actual invoke()\n\t            self.reset_loglevel()\n\t        return _init_and_cleanup"]}
{"filename": "libslub/frontend/commands/gdb/sbslabdb.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport binascii\n\timport struct\n\timport sys\n\timport logging\n\timport pprint\n\timport re\n\timport pickle\n\timport importlib\n", "import gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n", "log.trace(\"sbslabdb.py\")\n\t# The actual database of slabs and associated chunk addresses\n\t# that are tracked as part of the \"add\" and \"del\" commands\n\tslab_db = {}\n\t# just a cache to avoid querying structure in memory each time\n\t# but we will query it again if the address we \"add\" or \"delete\"\n\t# is not there\n\tcached_info = {}\n\tSLAB_DB = \"slabdb.pickle\"\n\tdef save_slab_db_to_file(filename):\n", "    \"\"\"During development, we reload libslub and lose the slab database\n\t    so this allows saving it easily into a file before doing so\n\t    \"\"\"\n\t    d = {}\n\t    d[\"slab_db\"] = slab_db\n\t    pickle.dump(d, open(filename, \"wb\"))\n\tdef load_slab_db_from_file(filename):\n\t    \"\"\"During development, we reload libslub and lose the slab database\n\t    so this allows reloading it easily from a file\n\t    \"\"\"\n", "    global slab_db\n\t    d = pickle.load(open(filename, \"rb\"))\n\t    slab_db = d[\"slab_db\"]\n\tclass sbslabdb(sbcmd.sbcmd):\n\t    \"\"\"Command to add/delete known slab addresses when they are created/deleted\n\t    This is an alternative way to save slab addresses to \"sbwatch\" since gdb breakpoints in Python\n\t    crash gdb a lot...\"\"\"\n\t    def __init__(self, sb):\n\t        log.debug(\"sbslabdb.__init__()\")\n\t        super(sbslabdb, self).__init__(sb, \"sbslabdb\")\n", "        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Handle saving slab addresses associated with object/chunk addresses\"\"\", \n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            add_help=False,\n\t            epilog=\"\"\"This is particularly useful to be able to track full slabs\n\tNOTE: use 'sbslabdb <action> -h' to get more usage info\"\"\")\n\t        self.parser.add_argument(\n\t            \"-v\", \"--verbose\", dest=\"verbose\", action=\"count\", default=0,\n\t            help=\"Use verbose output (multiple for more verbosity)\"\n\t        )\n", "        self.parser.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n\t            help=\"Show this help\"\n\t        )\n\t        actions = self.parser.add_subparsers(\n\t            help=\"Action to perform\", \n\t            dest=\"action\"\n\t        )\n\t        add_parser = actions.add_parser(\n\t            \"add\",\n", "            help=\"\"\"Add slab address to the list\"\"\",\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            epilog=\"\"\"XXX\"\"\"\n\t        )\n\t        add_parser.add_argument(\n\t            'cache', \n\t            help='slab cache (e.g. \"kmalloc-1k\")'\n\t        )\n\t        add_parser.add_argument(\n\t            'address', \n", "            help='Chunk address to add'\n\t        )\n\t        del_parser = actions.add_parser(\n\t            \"del\", \n\t            help=\"\"\"Delete slab address from the list\"\"\",\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t            epilog=\"\"\"XXX\"\"\"\n\t        )\n\t        del_parser.add_argument(\n\t            'cache', \n", "            help='slab cache (e.g. \"kmalloc-1k\")'\n\t        )\n\t        del_parser.add_argument(\n\t            'address', \n\t            help='Chunk address to remove'\n\t        )\n\t        list_parser = actions.add_parser(\n\t            \"list\", \n\t            help=\"\"\"List all the slab addresses from the list (debugging)\"\"\",\n\t            formatter_class=argparse.RawTextHelpFormatter,\n", "            epilog=\"\"\"XXX\"\"\"\n\t        )\n\t        # allows to enable a different log level during development/debugging\n\t        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        # allows to save the slab db to file during development/debugging\n\t        self.parser.add_argument(\n\t            \"-S\", \"--save-db\", dest=\"save\", action=\"store_true\", default=False,\n", "            help=argparse.SUPPRESS\n\t        )\n\t        # allows to load the slab db from file during development/debugging\n\t        self.parser.add_argument(\n\t            \"-L\", \"--load-db\", dest=\"load\", action=\"store_true\", default=False,\n\t            help=argparse.SUPPRESS\n\t        )\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n", "        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        \"\"\"\n\t        log.debug(\"sbslabdb.invoke()\")\n\t        if self.args.action is None and not self.args.save and not self.args.load:\n\t            pu.print_error(\"WARNING: requires an action\")\n\t            self.parser.print_help()\n\t            return\n\t        if self.args.action == \"list\":\n\t            for cache_name, d in slab_db.items():\n", "                print(f\"slab cache: {cache_name}\")\n\t                for slab_addr, L in d.items():\n\t                    print(f\"\\tslab @ {slab_addr:#x}\")\n\t                    for addr in L:\n\t                        print(f\"\\t\\t- {addr:#x}\")\n\t            return\n\t        if self.args.save:\n\t            if self.args.verbose >= 0: # always print since debugging feature\n\t                print(\"Saving slabs database to file...\")\n\t            save_slab_db_to_file(SLAB_DB)\n", "            return\n\t        if self.args.load:\n\t            if self.args.verbose >= 0: # always print since debugging feature\n\t                print(\"Loading slabs database from file...\")\n\t            load_slab_db_from_file(SLAB_DB)\n\t            return\n\t        address = None\n\t        if self.args.address != None:\n\t            addresses = self.dbg.parse_address(self.args.address)\n\t            if len(addresses) == 0:\n", "                pu.print_error(\"WARNING: No valid address supplied\")\n\t                self.parser.print_help()\n\t                return\n\t            address = addresses[0]\n\t        if not self.args.cache:\n\t            pu.print_error(\"WARNING: No valid cache name supplied\")\n\t            self.parser.print_help()\n\t            return\n\t        if self.args.action == \"del\":\n\t            if self.args.cache not in slab_db.keys():\n", "                log.debug(f\"Warning: tried to remove from non-tracked cache: {self.args.cache}\")\n\t                return\n\t            slab_addr = self.get_slab_address2(address, self.args.cache)\n\t            if not slab_addr:\n\t                log.debug(f\"Warning: tried to remove chunk address: {address:#x} from non-existing slab in cache: {self.args.cache}\")\n\t                return\n\t            if slab_addr not in slab_db[self.args.cache].keys():\n\t                log.debug(f\"Warning: tried to remove chunk address: {address:#x} from non-tracked slab in cache: {self.args.cache}\")\n\t                return\n\t            if address not in slab_db[self.args.cache][slab_addr]:\n", "                log.debug(f\"Warning: tried to remove non-existing chunk address: {address:#x} from slab address: {slab_addr:#x} in cache: {self.args.cache}\")\n\t                return\n\t            slab_db[self.args.cache][slab_addr].remove(address)\n\t            if len(slab_db[self.args.cache][slab_addr]) == 0:\n\t                del slab_db[self.args.cache][slab_addr]\n\t            return\n\t        if self.args.action == \"add\":\n\t            if self.args.cache not in slab_db.keys():\n\t                slab_db[self.args.cache] = {}\n\t            slab_addr = self.get_slab_address2(address, self.args.cache)\n", "            if not slab_addr:\n\t                log.debug(f\"Warning: tried to add chunk address: {address:#x} from non-existing slab in cache: {self.args.cache}\")\n\t                return\n\t            if slab_addr not in slab_db[self.args.cache].keys():\n\t                slab_db[self.args.cache][slab_addr] = set([])\n\t            if address in slab_db[self.args.cache][slab_addr]:\n\t                log.debug(f\"Warning: tried to add existing chunk address: {address:#x} to slab @ {slab_addr:#x} and cache: {self.args.cache}\")\n\t            else:\n\t                slab_db[self.args.cache][slab_addr].add(address)\n\t            return\n", "    def get_slab_address2(self, chunk_addr, cache_name):\n\t        global cached_info\n\t        # Check our local cache first\n\t        log.debug(\"Checking\")\n\t        if cache_name in cached_info.keys():\n\t            for page_addr, (region_start, region_end) in cached_info[cache_name].items():\n\t                if chunk_addr >= region_start and chunk_addr < region_end:\n\t                    return page_addr\n\t        # Not found in our cache, so query structures and memory to update our cache\n\t        log.debug(\"Updating cache\")\n", "        cached_info[cache_name] = self.sb.get_slab_cache_memory_pages_ranges(name=self.args.cache, dict_enabled=True)\n\t        # And check again\n\t        log.debug(\"Checking again\")\n\t        for page_addr, (region_start, region_end) in cached_info[cache_name].items():\n\t            if chunk_addr >= region_start and chunk_addr < region_end:\n\t                return page_addr\n\t        log.debug(\"Not found\")\n\t        return None"]}
{"filename": "libslub/frontend/commands/gdb/__init__.py", "chunked_list": []}
{"filename": "libslub/frontend/commands/gdb/sblist.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport struct\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.sb as sb\n", "importlib.reload(sb)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sblist.py\")\n\tclass sblist(sbcmd.sbcmd):\n\t    \"\"\"Command to show information about all the slab caches on the system\"\"\"\n\t    def __init__(self, sb):\n", "        log.debug(\"sblist.__init__()\")\n\t        super(sblist, self).__init__(sb, \"sblist\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Show information about all the slab caches on the system\n\tEquivalent to \"cat /proc/slabinfo\" in userland.\"\"\", \n\t            add_help=False,\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t        )\n\t        self.parser.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n", "            help=\"Show this help\"\n\t        )\n\t        # allows to enable a different log level during development/debugging\n\t        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        self.parser.add_argument(\n\t            \"-p\",\n\t            dest=\"pattern\",\n", "            default=None,\n\t            help=\"Only show caches that contain that pattern\",\n\t        )\n\t        self.parser.add_argument(\n\t            \"-k\",\n\t            dest=\"kmalloc\",\n\t            default=False,\n\t            action=\"store_true\",\n\t            help=\"Only show most usual caches (kmalloc-8, ... kmalloc-8k)\",\n\t        )\n", "    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        \"\"\"\n\t        log.debug(\"sblist.invoke()\")\n\t        page_type = gdb.lookup_type(\"struct page\")\n\t        print(\"name                    objs inuse slabs size obj_size objs_per_slab pages_per_slab\")\n\t        # Each slab_cache is a dictionary matching the kmem_cache structure of the current slab cache\n", "        # struct kmem_cache {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/slub_def.h#L90\n\t        for slab_cache in sb.sb.iter_slab_caches():\n\t            name = slab_cache[\"name\"].string() # Name (only for display!)\n\t            # skip if don't want to see them all\n\t            if self.args.pattern and self.args.pattern not in name:\n\t                continue\n\t            if self.args.kmalloc and name not in sb.sb.kmalloc_caches:\n\t                continue\n\t            size = int(slab_cache[\"size\"]) # The size of an object including metadata\n\t            obj_size = int(slab_cache[\"object_size\"]) # The size of an object without metadata\n", "            cnt_objs, cnt_inuse, cnt_slabs = 0, 0, 0\n\t            # Get the gdb.Value representing the current kmem_cache_cpu\n\t            cpu_cache = self.sb.get_current_slab_cache_cpu(slab_cache)\n\t            # kmem_cache_cpu->page == The slab from which we are allocating\n\t            # struct page {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/mm_types.h#L70\n\t            if cpu_cache[\"page\"]: \n\t                cnt_objs = cnt_inuse = int(cpu_cache[\"page\"][\"objects\"]) & self.sb.UNSIGNED_INT\n\t                # kmem_cache_cpu->freelist == Pointer to next available object\n\t                if cpu_cache[\"freelist\"]:\n\t                    cnt_inuse -= len(\n", "                        list(sb.sb.walk_freelist(slab_cache, cpu_cache[\"freelist\"]))\n\t                    )\n\t                cnt_slabs += 1\n\t            # kmem_cache_cpu->partial == Partially allocated frozen slabs\n\t            # struct page {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/mm_types.h#L70\n\t            if cpu_cache[\"partial\"]:\n\t                slab = cpu_cache[\"partial\"]\n\t                while slab:\n\t                    cnt_objs += int(slab[\"objects\"]) & self.sb.UNSIGNED_INT # number of chunks in that slab\n\t                    cnt_inuse += int(slab[\"inuse\"]) & self.sb.UNSIGNED_INT # number of allocated chunks in that slab\n", "                    cnt_slabs += 1\n\t                    slab = slab.dereference()[\"next\"] # next partial slab\n\t            # kmem_cache->node == The slab lists for all objects\n\t            # struct kmem_cache_node {: https://elixir.bootlin.com/linux/v5.15/source/mm/slab.h#L533\n\t            node_cache = slab_cache[\"node\"].dereference().dereference()\n\t            for slab in self.sb.for_each_entry(page_type, node_cache[\"partial\"], \"lru\"):\n\t                cnt_objs += int(slab[\"objects\"]) & self.sb.UNSIGNED_INT\n\t                cnt_inuse += int(slab[\"inuse\"]) & self.sb.UNSIGNED_INT\n\t                cnt_slabs += 1\n\t            # Word size structure that can be atomically updated or read and that\n", "            # contains both the order and the number of objects that a slab of the\n\t            # given order would contain.\n\t            # struct kmem_cache_order_objects {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/slub_def.h#L83\n\t            oo = slab_cache[\"oo\"][\"x\"]\n\t            # https://elixir.bootlin.com/linux/v5.15/source/mm/slub.c#L412 and https://elixir.bootlin.com/linux/v5.15/source/mm/slub.c#L252\n\t            objs_per_slab = oo & ((1 << 16) - 1)\n\t            # https://elixir.bootlin.com/linux/v5.15/source/mm/slub.c#L407 and https://elixir.bootlin.com/linux/v5.15/source/mm/slub.c#L251\n\t            pages_per_slab = 2 ** (oo >> 16)\n\t            print(\n\t                \"%-23s %4d %5d %5d %4d %8d %13d %14d\"\n", "                % (\n\t                    name,\n\t                    cnt_objs,\n\t                    cnt_inuse,\n\t                    cnt_slabs,\n\t                    size,\n\t                    obj_size,\n\t                    objs_per_slab,\n\t                    pages_per_slab,\n\t                )\n", "            )\n\t        # XXX - could be displayed only if we use -v\n\t        print(\"\")\n\t        print(\"name: slab cache name used for display\")\n\t        print(\"objs: total number of chunks in that slab cache\")\n\t        print(\"inuse: number of allocated chunks in that slab cache\")\n\t        print(\"slabs: number of slabs allocated for that slab cache\")\n\t        print(\"size: chunk size (with metadata)\")\n\t        print(\"obj_size: object size (without metadata)\")\n\t        print(\"objs_per_slab: number of objects per slab\")\n", "        print(\"pages_per_slab: number of pages per slab\")\n"]}
{"filename": "libslub/frontend/commands/gdb/sbwatch.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport struct\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.sb as sb\n", "importlib.reload(sb)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbwatch.py\")\n\tclass sbwatch(sbcmd.sbcmd):\n\t    \"\"\"Command to start/stop watching full-slabs for a slab cache\"\"\"\n\t    def __init__(self, sb):\n", "        log.debug(\"sbwatch.__init__()\")\n\t        super(sbwatch, self).__init__(sb, \"sbwatch\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Start/stop watching full-slabs for a slab cache\n\tSetup break points for the specified slab names\n\tIt is recommended to enable it when analyzing objects allocated/freed.\n\tThis is required in order to be able to list objects allocated in full slabs \n\tsince otherwise the SLUB allocator won't know them until they are not in a \n\tfull-slabs anymore\"\"\",\n\t            add_help=False,\n", "            formatter_class=argparse.RawTextHelpFormatter,\n\t        )\n\t        self.parser.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n\t            help=\"Show this help\"\n\t        )\n\t        # allows to enable a different log level during development/debugging\n\t        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n", "        )\n\t        self.parser.add_argument(\n\t            \"names\", nargs=\"*\", default=[],\n\t            help=\"Slab names (e.g. 'kmalloc-1k')\"\n\t        )\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n", "        \"\"\"\n\t        log.debug(\"sbwatch.invoke()\")\n\t        for name in self.args.names:\n\t            slab_cache = sb.sb.find_slab_cache(name)\n\t            if slab_cache is None:\n\t                print(\"Slab cache '%s' not found\" % name)\n\t                return\n\t            if name in self.sb.watch_caches:\n\t                print(\"Stopped watching slab cache '%s'\" % name)\n\t                self.sb.watch_caches.remove(name)\n", "            else:\n\t                print(\"Started watching slab cache '%s'\" % name)\n\t                self.sb.watch_caches.append(name)\n\t            self.sb.breakpoints.update_breakpoints()"]}
{"filename": "libslub/frontend/commands/gdb/sbtrace.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport struct\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.sb as sb\n", "importlib.reload(sb)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbtrace.py\")\n\tclass sbtrace(sbcmd.sbcmd):\n\t    \"\"\"Command to start/stop tracing object allocations for a slab cache\"\"\"\n\t    def __init__(self, sb):\n", "        log.debug(\"sbtrace.__init__()\")\n\t        super(sbtrace, self).__init__(sb, \"sbtrace\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Start/stop tracing object allocations for a slab cache\n\tSetup break points for the specified slab names\"\"\", \n\t            add_help=False,\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t        )\n\t        self.parser.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n", "            help=\"Show this help\"\n\t        )\n\t        # allows to enable a different log level during development/debugging\n\t        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        self.parser.add_argument(\n\t            \"names\", nargs=\"*\", default=[],\n\t            help=\"Slab names (e.g. 'kmalloc-1k')\"\n", "        )\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n\t        \"\"\"\n\t        log.debug(\"sbtrace.invoke()\")\n\t        for name in self.args.names:\n\t            slab_cache = sb.sb.find_slab_cache(name)\n", "            if slab_cache is None:\n\t                print(\"Slab cache '%s' not found\" % name)\n\t                return\n\t            if name in self.sb.trace_caches:\n\t                print(\"Stopped tracing slab cache '%s'\" % name)\n\t                self.sb.trace_caches.remove(name)\n\t            else:\n\t                print(\"Started tracing slab cache '%s'\" % name)\n\t                self.sb.trace_caches.append(name)\n\t            self.sb.breakpoints.update_breakpoints()"]}
{"filename": "libslub/frontend/commands/gdb/sbcrosscache.py", "chunked_list": ["from __future__ import print_function\n\timport argparse\n\timport struct\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.sb as sb\n", "importlib.reload(sb)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n\timport libslub.frontend.commands.gdb.sbcmd as sbcmd\n\t#importlib.reload(sbcmd)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbcrosscache.py\")\n\tclass sbcrosscache(sbcmd.sbcmd):\n\t    \"\"\"Command to identify adjacent memory regions from two different slabs\"\"\"\n\t    def __init__(self, sb):\n", "        log.debug(\"sbcrosscache.__init__()\")\n\t        super(sbcrosscache, self).__init__(sb, \"sbcrosscache\")\n\t        self.parser = argparse.ArgumentParser(\n\t            description=\"\"\"Identify adjacent memory regions from two different slabs\n\tThis is particularly useful when you want to do cross cache attacks.\"\"\", \n\t            add_help=False,\n\t            formatter_class=argparse.RawTextHelpFormatter,\n\t        )\n\t        self.parser.add_argument(\n\t            \"-h\", \"--help\", dest=\"help\", action=\"store_true\", default=False,\n", "            help=\"Show this help\"\n\t        )\n\t        # allows to enable a different log level during development/debugging\n\t        self.parser.add_argument(\n\t            \"--loglevel\", dest=\"loglevel\", default=None,\n\t            help=argparse.SUPPRESS\n\t        )\n\t        self.parser.add_argument(\n\t            \"slab_cache_a\", default=None,\n\t            help=\"First slab cache name (e.g. 'kmalloc-64')\"\n", "        )\n\t        self.parser.add_argument(\n\t            \"slab_cache_b\", default=None,\n\t            help=\"Second slab cache name (e.g. 'kmalloc-96')\"\n\t        )\n\t    @h.catch_exceptions\n\t    @sbcmd.sbcmd.init_and_cleanup\n\t    def invoke(self, arg, from_tty):\n\t        \"\"\"Inherited from gdb.Command\n\t        See https://sourceware.org/gdb/current/onlinedocs/gdb/Commands-In-Python.html\n", "        \"\"\"\n\t        log.debug(\"sbcrosscache.invoke()\")\n\t        slab_cache_a = self.args.slab_cache_a\n\t        slab_cache_b = self.args.slab_cache_b\n\t        a = sb.sb.find_slab_cache(slab_cache_a)\n\t        if a is None:\n\t            print(\"Slab cache '%s' not found\" % slab_cache_a)\n\t            return\n\t        b = sb.sb.find_slab_cache(slab_cache_b)\n\t        if a is None:\n", "            print(\"Slab cache '%s' not found\" % slab_cache_b)\n\t            return\n\t        a_pages = self.sb.get_slab_cache_memory_pages(a)\n\t        b_pages = self.sb.get_slab_cache_memory_pages(b)\n\t        a_pages.sort()\n\t        b_pages.sort()\n\t        for a_page in a_pages:\n\t            if a_page < b_pages[0] - 4096 or a_page > b_pages[-1] + 4096:\n\t                continue\n\t            first = True\n", "            for b_page in b_pages:\n\t                if a_page == b_page - 4096:\n\t                    if first:\n\t                        print(\"---\")\n\t                        first = False\n\t                        print(f\"0x{a_page:08x} - {slab_cache_a}\")\n\t                    print(f\"0x{b_page:08x} - {slab_cache_b}\")\n\t                elif a_page == b_page + 4096:\n\t                    if first:\n\t                        print(\"---\")\n", "                        first = False\n\t                    print(f\"0x{b_page:08x} - {slab_cache_b}\")\n\t                    print(f\"0x{a_page:08x} - {slab_cache_a}\")\n\t            pass"]}
{"filename": "libslub/frontend/breakpoints/__init__.py", "chunked_list": []}
{"filename": "libslub/frontend/breakpoints/gdb/slab_free.py", "chunked_list": ["import argparse\n\timport struct\n\timport sys\n\timport traceback\n\timport gdb\n\timport shlex\n\timport importlib\n\timport logging\n\tfrom functools import wraps, lru_cache\n\timport libslub.frontend.helpers2 as h2\n", "importlib.reload(h2)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(f\"slab_free.py\")\n\tclass DiscardSlab(gdb.Breakpoint):\n\t    \"\"\"Track slab destructions/frees\n\t    \"\"\"\n\t    def __init__(self, sb):\n\t        h2.clear_existing_breakpoints(\"discard_slab\")\n", "        super(DiscardSlab, self).__init__(\"discard_slab\", internal=sb.bps_hidden)\n\t        self.sb = sb\n\t    def stop(self):\n\t        slab_cache = gdb.selected_frame().read_var(\"s\")\n\t        name = slab_cache[\"name\"].string()\n\t        page = gdb.selected_frame().read_var(\"page\")\n\t        addr = int(page) & sb.sb.UNSIGNED_LONG\n\t        self.sb.notify_slab_free(name, addr)\n\t        return False # continue execution"]}
{"filename": "libslub/frontend/breakpoints/gdb/breakpoints.py", "chunked_list": ["import argparse\n\timport struct\n\timport sys\n\timport traceback\n\timport gdb\n\timport shlex\n\timport importlib\n\timport logging\n\tfrom functools import wraps, lru_cache\n\timport libslub.frontend.helpers as h\n", "importlib.reload(h)\n\timport libslub.frontend.helpers2 as h2\n\timportlib.reload(h2)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\timport libslub.frontend.breakpoints.gdb.slab_alloc as slab_alloc\n\timportlib.reload(slab_alloc)\n\timport libslub.frontend.breakpoints.gdb.slab_free as slab_free\n\timportlib.reload(slab_free)\n\timport libslub.frontend.breakpoints.gdb.obj_alloc as obj_alloc\n", "importlib.reload(obj_alloc)\n\timport libslub.frontend.breakpoints.gdb.obj_free as obj_free\n\timportlib.reload(obj_free)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"breakpoints.py\")\n\tclass breakpoints:\n\t    def __init__(self, sb):\n\t        \"\"\"\n\t        Holds all the breakpoints that are useful to trace/log SLUB allocator internal behaviours\n\t        such as when a new slab is created or when objects are allocated on a given slab\n", "        \"\"\"\n\t        log.debug(\"breakpoints.__init__()\")\n\t        self.sb = sb\n\t        # XXX - Some breakpoints do not work well in some environments\n\t        # or crash gdb so enable the ones that work for you :)\n\t        #self.obj_alloc_bp = obj_alloc.KmemCacheAlloc(self.sb)\n\t        self.obj_alloc_bp = obj_alloc.KmemCacheAllocReturned(self.sb)\n\t        #self.obj_free_bp = obj_free.KmemCacheFree(self.sb)\n\t        self.obj_free_bp = obj_free.KmemCacheFreeReturned(self.sb)\n\t        #self.slab_alloc_bp = slab_alloc.NewSlab(self)\n", "        #self.slab_alloc_bp = slab_alloc.AllocateSlab(self.sb)\n\t        self.slab_alloc_bp = slab_alloc.AllocateSlabReturned(self.sb)\n\t        self.slab_free_bp = slab_free.DiscardSlab(self.sb)\n\t        self.update_breakpoints()\n\t    def update_breakpoints(self):\n\t        enabled = bool(self.sb.trace_caches) or bool(self.sb.break_caches)\n\t        self.obj_alloc_bp.enabled = enabled\n\t        self.obj_free_bp.enabled = enabled\n\t        enabled = bool(self.sb.watch_caches)\n\t        self.slab_alloc_bp.enabled = enabled\n", "        self.slab_free_bp.enabled = enabled"]}
{"filename": "libslub/frontend/breakpoints/gdb/__init__.py", "chunked_list": []}
{"filename": "libslub/frontend/breakpoints/gdb/obj_free.py", "chunked_list": ["import argparse\n\timport struct\n\timport sys\n\timport traceback\n\timport gdb\n\timport shlex\n\timport importlib\n\timport logging\n\tfrom functools import wraps, lru_cache\n\timport libslub.frontend.helpers2 as h2\n", "importlib.reload(h2)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(f\"obj_free.py\")\n\tclass KmemCacheFreeFinish(gdb.FinishBreakpoint):\n\t    \"\"\"Method 1 to track object frees on a given slab associated with a slab cache\n\t    See KmemCacheFree()\n\t    NOTE: if gdb crashes when you use this FinishBreakpoint, you may want\n\t    to use the normal Breakpoint in Method 2 below instead\n", "    \"\"\"\n\t    def __init__(self, sb, name, addr):\n\t        frame = gdb.newest_frame().older()\n\t        super(KmemCacheFreeFinish, self).__init__(frame, internal=sb.bps_hidden)\n\t        self.sb = sb\n\t        self.name = name\n\t        self.addr = addr\n\t    def stop(self):\n\t        self.sb.notify_obj_free(self.name, self.addr)\n\t        if self.name in self.sb.break_caches:\n", "            return True\n\t        return False # continue execution\n\tclass KmemCacheFree(gdb.Breakpoint):\n\t    \"\"\"Method 1 to track object frees on a given slab associated with a slab cache\n\t    An invisible breakpoint for intercepting kmem_cache_free calls\n\t    \"\"\"\n\t    def __init__(self, sb):\n\t        h2.clear_existing_breakpoints(\"kmem_cache_free\")\n\t        super(KmemCacheFree, self).__init__(\"kmem_cache_free\", internal=sb.bps_hidden)\n\t        self.sb = sb\n", "    def stop(self):\n\t        slab_cache = gdb.selected_frame().read_var(\"s\")\n\t        name = slab_cache[\"name\"].string()\n\t        x = gdb.selected_frame().read_var(\"x\")\n\t        addr = int(x) & sb.sb.UNSIGNED_LONG\n\t        if name in self.sb.trace_caches or name in self.sb.break_caches:\n\t            KmemCacheFreeFinish(self.sb, name, addr)\n\tclass KmemCacheFreeReturned(gdb.Breakpoint):\n\t    \"\"\"Method 2 to track object frees on a given slab associated with a slab cache\"\"\"\n\t    def __init__(self, sb):\n", "        # ubuntu 22.04 - kernel 5.15.0-27\n\t        bp_address = \"mm/slub.c:3509\"\n\t        h2.clear_existing_breakpoints(bp_address)\n\t        super(KmemCacheFreeReturned, self).__init__(bp_address, internal=sb.bps_hidden)\n\t        self.sb = sb\n\t    def stop(self):\n\t        slab_cache = gdb.selected_frame().read_var(\"s\")\n\t        name = slab_cache[\"name\"].string()\n\t        x = gdb.selected_frame().read_var(\"x\")\n\t        addr = int(x) & sb.sb.UNSIGNED_LONG\n", "        self.sb.notify_obj_free(name, addr)\n\t        if self.name in self.sb.break_caches:\n\t            return True\n\t        return False # continue execution"]}
{"filename": "libslub/frontend/breakpoints/gdb/slab_alloc.py", "chunked_list": ["import argparse\n\timport struct\n\timport sys\n\timport traceback\n\timport gdb\n\timport shlex\n\timport importlib\n\timport logging\n\tfrom functools import wraps, lru_cache\n\timport libslub.frontend.helpers2 as h2\n", "importlib.reload(h2)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(f\"slab_alloc.py\")\n\t# You may have to choose which method works best for your environment\n\t#\n\t# allocate_slab() is the function we are interested to track since it returns the struct page*\n\t# for the newly allocated slab\n\t#\n", "# The following call trace exists:\n\t# __slab_alloc()                  - return address of new_slab() hooked in method 3\n\t#    |- new_slab()                - hooked + finish by method 1\n\t#       |- allocate_slab()        - hooked + finish by method 2\n\tclass NewSlabFinish(gdb.FinishBreakpoint):\n\t    \"\"\"Method 1 to track slab allocations\n\t    See NewSlab()\n\t    NOTE: if gdb crashes when you use this FinishBreakpoint, you may want\n\t    to use the normal Breakpoint in Method 3 below instead\n\t    \"\"\"\n", "    def __init__(self, sb, name):\n\t        frame = gdb.newest_frame().older()\n\t        super(NewSlabFinish, self).__init__(frame, internal=sb.bps_hidden)\n\t        self.sb = sb\n\t        self.name = name\n\t    def stop(self):\n\t        # self.return_value is only valid for functions with debug symbols\n\t        # enabled... which doesn't seem to work for this function in stock\n\t        # Ubuntu for instance.\n\t        addr = int(self.return_value) & sb.sb.UNSIGNED_LONG\n", "        self.sb.notify_slab_alloc(self.name, addr)\n\t        return False # continue execution\n\tclass NewSlab(gdb.Breakpoint):\n\t    \"\"\"Method 1 to track slab allocations\"\"\"\n\t    def __init__(self, sb):\n\t        h2.clear_existing_breakpoints(\"new_slab\")\n\t        super(NewSlab, self).__init__(\"new_slab\", internal=sb.bps_hidden)\n\t        self.sb = sb\n\t        # This register is used to read the slab_cache variable in the event\n\t        # that this symbol is optimized out by the compiler... this is normally\n", "        # the first argument to the function so it should be in rdi, but it may\n\t        # change...\n\t        # XXX - add ARM support\n\t        self.register = \"rdi\"\n\t    def stop(self):\n\t        slab_cache = gdb.selected_frame().read_var(\"s\")\n\t        if str(slab_cache) == \"<optimized out>\":\n\t            kmem_cache = gdb.lookup_type(\"struct kmem_cache\")\n\t            # print(\"Found slab at: 0x%x\" % entry)\n\t            slab_cache_addr = gdb.selected_frame().read_register(self.register)\n", "            entry = gdb.Value(slab_cache_addr)\n\t            slab_cache = entry.cast(kmem_cache.pointer())\n\t        name = slab_cache[\"name\"].string()\n\t        if name in self.sb.watch_caches:\n\t            NewSlabFinish(self.sb, name)\n\t        return False # continue execution\n\tclass NewSlabFinish(gdb.FinishBreakpoint):\n\t    \"\"\"Method 2 to track slab allocations\n\t    See AllocateSlab()\n\t    NOTE: if gdb crashes when you use this FinishBreakpoint, you may want\n", "    to use the normal Breakpoint in Method 3 below instead\n\t    \"\"\"\n\t    def __init__(self, sb, name):\n\t        # frame = gdb.newest_frame()\n\t        frame = gdb.newest_frame().older()\n\t        super(NewSlabFinish, self).__init__(frame, internal=sb.bps_hidden)\n\t        self.sb = sb\n\t        self.name = name\n\t    def stop(self):\n\t        print(\"NewSlabFinish.stop()\")\n", "        addr = int(self.return_value) & sb.sb.UNSIGNED_LONG\n\t        self.sb.notify_slab_alloc(self.name, addr)\n\t        return False # continue execution\n\t# This function works more reliably on Ubuntu\n\t# XXX - if we assume the gdb session has lx tools we could parse lx-version to\n\t# try to work some of it out....\n\tclass AllocateSlab(gdb.Breakpoint):\n\t    \"\"\"Method 2 to track slab allocations\"\"\"\n\t    def __init__(self, sb):\n\t        h2.clear_existing_breakpoints(\"allocate_slab\")\n", "        super(AllocateSlab, self).__init__(\"allocate_slab\", internal=sb.bps_hidden)\n\t        self.sb = sb\n\t        # This register is used to read the slab_cache variable in the event\n\t        # that this symbol is optimized out by the compiler... this is normally\n\t        # the first argument to the function so it should be in rdi, but it may\n\t        # change...\n\t        # XXX - add ARM support\n\t        self.register = \"rdi\"\n\t    def stop(self):\n\t        slab_cache = gdb.selected_frame().read_var(\"s\")\n", "        if str(slab_cache) == \"<optimized out>\":\n\t            kmem_cache = gdb.lookup_type(\"struct kmem_cache\")\n\t            # print(\"Found slab at: 0x%x\" % entry)\n\t            slab_cache_addr = gdb.selected_frame().read_register(self.register)\n\t            entry = gdb.Value(slab_cache_addr)\n\t            slab_cache = entry.cast(kmem_cache.pointer())\n\t        name = slab_cache[\"name\"].string()\n\t        if name in self.sb.watch_caches:\n\t            NewSlabFinish(self.sb, name)\n\t        return False # continue execution\n", "# XXX - I am using this technique because the original seems to be broken, in\n\t# so far as the finish breakpoint never hits from inside python.\n\t# If you need to change this, find \"new_slab_objects()\" or \"___slab_alloc()\" \n\t# and look for the location where there is an assignment `page = new_slab()`. Ex:\n\t# ```\n\t# static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t# int node, struct kmem_cache_cpu **pc)\n\t# {\n\t# void *freelist;\n\t# struct kmem_cache_cpu *c = *pc;\n", "# struct page *page;\n\t#\n\t# WARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));\n\t#\n\t# freelist = get_partial(s, flags, node, c);\n\t#\n\t# if (freelist)\n\t# return freelist;\n\t#\n\t# page = new_slab(s, flags, node);\n", "# if (page) {                                           // breakpoint here\n\t# ```\n\tclass AllocateSlabReturned(gdb.Breakpoint):\n\t    \"\"\"Method 3 to track slab allocations\"\"\"\n\t    def __init__(self, sb):\n\t        log.debug(\"AllocateSlabReturned.__init__()\")\n\t        # ubuntu 21.10 - kernel 5.13.0-40\n\t        #bp_address = \"mm/slub.c:2603\"\n\t        # ubuntu 22.04 - kernel 5.15.0-27\n\t        bp_address = \"mm/slub.c:3002\"\n", "        h2.clear_existing_breakpoints(bp_address)\n\t        super(AllocateSlabReturned, self).__init__(bp_address, internal=sb.bps_hidden)\n\t        self.sb = sb\n\t    def stop(self):\n\t        log.debug(\"AllocateSlabReturned.stop()\")\n\t        slab_cache = gdb.selected_frame().read_var(\"s\")\n\t        name = slab_cache[\"name\"].string()\n\t        addr = gdb.selected_frame().read_var(\"page\")\n\t        addr = int(addr) & sb.sb.UNSIGNED_LONG\n\t        self.sb.notify_slab_alloc(name, addr)\n", "        return False # continue execution"]}
{"filename": "libslub/frontend/breakpoints/gdb/obj_alloc.py", "chunked_list": ["import argparse\n\timport struct\n\timport sys\n\timport traceback\n\timport gdb\n\timport shlex\n\timport importlib\n\timport logging\n\tfrom functools import wraps, lru_cache\n\tlog = logging.getLogger(\"libslub\")\n", "log.trace(f\"obj_alloc.py\")\n\timport libslub.frontend.helpers2 as h2\n\timportlib.reload(h2)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\tclass KmemCacheAllocFinish(gdb.FinishBreakpoint):\n\t    \"\"\"Method 1 to track object allocations on a given slab associated with a slab cache\n\t    See KmemCacheAlloc()\n\t    NOTE: if gdb crashes when you use this FinishBreakpoint, you may want\n\t    to use the normal Breakpoint in Method 2 below instead\n", "    \"\"\"\n\t    def __init__(self, sb, name):\n\t        super(KmemCacheAllocFinish, self).__init__(internal=sb.bps_hidden)\n\t        self.sb = sb\n\t        self.name = name\n\t    def stop(self):\n\t        addr = int(self.return_value) & sb.sb.UNSIGNED_LONG\n\t        self.sb.notify_obj_alloc(self.name, addr)\n\t        if self.name in self.sb.break_caches:\n\t            return True\n", "        return False # continue execution\n\tclass KmemCacheAlloc(gdb.Breakpoint):\n\t    \"\"\"Method 1 to track object allocations on a given slab associated with a slab cache\n\t    An invisible breakpoint for intercepting kmem_cache_alloc calls\n\t    \"\"\"\n\t    def __init__(self, command):\n\t        h2.clear_existing_breakpoints(\"kmem_cache_alloc\")\n\t        super(KmemCacheAlloc, self).__init__(\"kmem_cache_alloc\", internal=sb.bps_hidden)\n\t        self.sb = sb\n\t    def stop(self):\n", "        slab_cache = gdb.selected_frame().read_var(\"s\")\n\t        try:\n\t            name = slab_cache[\"name\"].string()\n\t        except:\n\t            print(\"Warning: can't track object allocation\")\n\t            return False\n\t        if name in self.sb.trace_caches or name in self.sb.break_caches:\n\t            KmemCacheAllocFinish(self.sb, name)\n\t        return False # continue execution\n\t# void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)\n", "# {\n\t# \tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_, s->object_size);\n\t#\n\t# \ttrace_kmem_cache_alloc(_RET_IP_, ret, s->object_size,           // breakpoint here\n\t# \t\t\t\ts->size, gfpflags);\n\t#\n\t# \treturn ret;\n\t# }\n\tclass KmemCacheAllocReturned(gdb.Breakpoint):\n\t    \"\"\"Method 2 to track object allocations on a given slab associated with a slab cache\"\"\"\n", "    def __init__(self, sb):\n\t        # ubuntu 22.04 - kernel 5.15.0-27\n\t        bp_address = \"mm/slub.c:3228\"\n\t        h2.clear_existing_breakpoints(bp_address)\n\t        super(KmemCacheAllocReturned, self).__init__(bp_address, internal=sb.bps_hidden)\n\t        self.sb = sb\n\t    def stop(self):\n\t        slab_cache = gdb.selected_frame().read_var(\"s\")\n\t        name = slab_cache[\"name\"].string()\n\t        addr = gdb.selected_frame().read_var(\"ret\")\n", "        addr = int(addr) & sb.sb.UNSIGNED_LONG\n\t        self.sb.notify_obj_alloc(name, addr)\n\t        if name in self.sb.break_caches:\n\t            return True\n\t        return False # continue execution"]}
{"filename": "libslub/slub/kmem_cache_cpu.py", "chunked_list": ["import struct\n\timport sys\n\timport importlib\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.heap_structure as hs\n\timportlib.reload(hs)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\timport libslub.slub.page as p\n", "importlib.reload(p)\n\timport libslub.slub.obj as obj\n\timportlib.reload(obj)\n\timport libslub.frontend.commands.gdb.sbobject as sbobject\n\timportlib.reload(sbobject)\n\tclass kmem_cache_cpu(hs.heap_structure):\n\t    \"\"\"python representation of a struct kmem_cache_cpu\n\t    struct kmem_cache_cpu {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/slub_def.h#L48\n\t    \"\"\"\n\t    def __init__(self, sb, cpu_id, kmem_cache, value=None, address=None):\n", "        \"\"\"\n\t        Parse kmem_cache_cpu's data and initialize the kmem_cache_cpu object\n\t        :param sb: slab object holding all our useful info\n\t        :param value: gdb.Value of type kmem_cache_cpu with structure's content read from the debugger (represented by a dictionary)\n\t        :param address: address for a kmem_cache_cpu where to read the structure's content from the debugger (not supported yet)\n\t        \"\"\"\n\t        super(kmem_cache_cpu, self).__init__(sb)\n\t        # kmem_cache_cpu structure's fields can be looked up directly from the gdb.Value\n\t        self.value = value # gdb.Value representing the kmem_cache_cpu\n\t        self.kmem_cache = kmem_cache # kmem_cache object\n", "        self.init(cpu_id)\n\t    def init(self, cpu_id):\n\t        # our own abstraction fields\n\t        self.cpu_id = cpu_id # CPU index in the kmem_cache\n\t        self.address = int(self.value.address) & sb.sb.UNSIGNED_LONG\n\t        self.fp = int(self.value[\"freelist\"]) & sb.sb.UNSIGNED_LONG # freelist head address\n\t        freelist_addresses = list(sb.sb.walk_freelist(self.kmem_cache.value, self.fp)) # list of addresses\n\t        self.freelist = []\n\t        for address in freelist_addresses:\n\t            # we pass None as the page as it is not built yet but we'll update it after creating the main slab\n", "            o = obj.obj(self.sb, address, self.kmem_cache, self, None, None, inuse=False)\n\t            self.freelist.append(o)\n\t        # the slab from which we are allocating for that cpu core\n\t        self.main_slab = None\n\t        if self.value[\"page\"]:\n\t            self.main_slab = p.page(self.sb, self.kmem_cache, self, None, sb.SlabType.MAIN_SLAB, value=self.value[\"page\"].dereference(), is_main_slab=True)\n\t        # update the main freelist's objects \"page\"\n\t        for o in self.freelist:\n\t            o.page = self.main_slab\n\t        # the partial slabs\n", "        self.partial_slabs = []\n\t        slab_ptr = self.value[\"partial\"]\n\t        slab_count = 0\n\t        while slab_ptr:\n\t            slab_count += 1\n\t            slab = slab_ptr.dereference()\n\t            slab_ptr = slab[\"next\"]\n\t        slab_index = 1\n\t        slab_ptr = self.value[\"partial\"]\n\t        while slab_ptr:\n", "            slab = slab_ptr.dereference()\n\t            partial_slab = p.page(self.sb, self.kmem_cache, self, None, sb.SlabType.PARTIAL_SLAB, index=slab_index, count=slab_count, value=slab)\n\t            self.partial_slabs.append(partial_slab)\n\t            slab_ptr = slab[\"next\"]\n\t            slab_index += 1\n\t    def print(self, verbose=0, use_cache=False, indent=0, cmd=None):\n\t        \"\"\"Pretty printer for the kmem_cache_cpu supporting different level of verbosity\n\t        :param verbose: 0 for non-verbose. 1 for more verbose. 2 for even more verbose.\n\t        :param use_cache: True if we want to use the cached information from the cache object.\n\t                          False if we want to fetch the data again\n", "        :param cmd: cmd.args == arguments so we know what options have been passed by the user\n\t                     e.g. to print hexdump of objects/chunks, highlight chunks, etc.\n\t        \"\"\"\n\t        if cmd.args.object_only is not True:\n\t            txt = \" \"*indent\n\t            title = \"struct kmem_cache_cpu @ 0x%x (cpu %d) {\" % (self.address, self.cpu_id)\n\t            txt += pu.color_title(title)\n\t            txt += \"\\n\"\n\t            print(txt, end=\"\")\n\t        # print the objects in the the main freelist\n", "        # it only make sense if we want to show the main slab as are chunked from that main slab\n\t        if cmd.output_filtered is False or cmd.args.main_slab is True or cmd.args.show_lockless_freelist:\n\t            if cmd.args.object_only is not True:\n\t                txt = \"{:s}  {:8} = \".format(\" \"*indent, \"freelist\")\n\t                txt += pu.color_value(\"{:#x}\".format(self.fp))\n\t                txt += \" ({:#d} elements)\".format(len(self.freelist))\n\t                txt += \"\\n\"\n\t                print(txt, end=\"\")\n\t            if cmd.args.show_lockless_freelist:\n\t                if cmd.args.object_only is True and cmd.args.hide_title is False:\n", "                    txt = pu.color_value(\"{:s}  lockless freelist:\").format(\" \"*indent)\n\t                    txt += \"\\n\"\n\t                    print(txt, end=\"\")\n\t                # Prepare arguments for \"sbobject\" format\n\t                # i.e. the chunks to print are from the freelist\n\t                # The amount of printed addresses will be limited by \n\t                # parse_many()'s \"count\" argument\n\t                if cmd.args.count == None:\n\t                    count = len(self.freelist)\n\t                else:\n", "                    count = cmd.args.count\n\t                sbobject.sbobject.parse_many(\n\t                    self.freelist, \n\t                    0, \n\t                    cmd.sb, \n\t                    cmd.dbg, \n\t                    None, # count\n\t                    count, # count_handle\n\t                    cmd.args.search_depth,\n\t                    cmd.args.skip_header, \n", "                    cmd.args.hexdump_unit, \n\t                    cmd.args.search_value, \n\t                    cmd.args.search_type, \n\t                    cmd.args.match_only, \n\t                    cmd.args.print_offset, \n\t                    cmd.args.verbose, \n\t                    cmd.args.no_newline,\n\t                    cmd.args.debug, \n\t                    cmd.args.hexdump, \n\t                    cmd.args.maxbytes, \n", "                    cmd.args.metadata,\n\t                    highlight_types=cmd.highlight_types,\n\t                    highlight_addresses=cmd.highlight_addresses,\n\t                    highlight_metadata=cmd.highlight_metadata,\n\t                    highlight_only=cmd.args.highlight_only,\n\t                    commands=cmd.args.commands,\n\t                    use_cache=cmd.args.use_cache,\n\t                    address_offset=cmd.args.address_offset,\n\t                    name=cmd.args.name,\n\t                    indent=\" \"*(indent+4),\n", "                    is_freelist=True,\n\t                    object_info=cmd.args.object_info,\n\t                )\n\t        if cmd.output_filtered is False or cmd.args.main_slab is True:\n\t            self.main_slab.print(name=\"page\", indent=indent+2, cmd=cmd)\n\t        if cmd.output_filtered is False or cmd.args.partial_slab is True:\n\t            for partial_slab in self.partial_slabs:\n\t                partial_slab.print(name=\"partial\", indent=indent+2, cmd=cmd)"]}
{"filename": "libslub/slub/obj.py", "chunked_list": ["from operator import index\n\timport struct\n\timport sys\n\timport importlib\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.heap_structure as hs\n\timportlib.reload(hs)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n", "import libslub.slub.kmem_cache as kc\n\timportlib.reload(kc)\n\tclass obj(hs.heap_structure):\n\t    \"\"\"python representation of a chunk/object\n\t    This is not associated to any structure since the object is dependent on the actual data being manipulated\n\t    and not on the SLAB allocator but we track it here to ease manipulating them\n\t    \"\"\"\n\t    def __init__(self, sb, address, kmem_cache, kmem_cache_cpu, kmem_cache_node, page, inuse=None):\n\t        \"\"\"\n\t        :param sb: slab object holding all our useful info\n", "        :param address: chunk/object address\n\t        :param kmem_cache: kmem_cache Python object\n\t        :param kmem_cache_cpu: kmem_cache_cpu Python object\n\t        :param page: page Python object\n\t        :param inuse: True if we know it is inuse. False if we know it is in a freelist. None if we don't know.\n\t        \"\"\"\n\t        super(obj, self).__init__(sb)\n\t        self.kmem_cache = kmem_cache # kmem_cache Python object\n\t        self.kmem_cache_cpu = kmem_cache_cpu # kmem_cache_cpu Python object or None\n\t        self.kmem_cache_node = kmem_cache_node # kmem_cache_node Python object or None\n", "        self.page = page # page Python object\n\t        self.address = address # address of the chunk/object in memory\n\t        self.init(inuse)\n\t    def init(self, inuse):\n\t        # our own abstraction fields\n\t        self.size = self.kmem_cache.size\n\t        if inuse is None:\n\t            self.inuse = True\n\t            if self.page.is_main_slab:\n\t                cpu_freelist = self.kmem_cache_cpu.freelist\n", "            else:\n\t                cpu_freelist = [] # not applicable\n\t            for o in self.page.freelist:\n\t                if self.address == o.address:\n\t                    self.inuse = False\n\t                    break\n\t            if self.inuse is True:\n\t                for o in cpu_freelist:\n\t                    if self.address == o.address:\n\t                        self.inuse = False\n", "        else:\n\t            self.inuse = inuse\n\t    def __str__(self):\n\t        \"\"\"Pretty printer for the obj\n\t        \"\"\"\n\t        return self.to_string()\n\t    def to_string(self, name=\"\", verbose=0, use_cache=False, indent=0, colorize_func=str):\n\t        \"\"\"Pretty printer for the obj supporting different level of verbosity\n\t        :param verbose: 0 for non-verbose. 1 for more verbose. 2 for even more verbose.\n\t        :param use_cache: True if we want to use the cached information from the cache object.\n", "                          False if we want to fetch the data again\n\t        \"\"\"\n\t        txt = \"\"\n\t        if self.inuse:\n\t            t = \"M\"\n\t        else:\n\t            t = \"F\"\n\t        address = \"{:#x}\".format(self.address)\n\t        txt += \"{:s}{:s} {:s}\".format(\" \"*indent, colorize_func(address), t)\n\t        return txt\n", "    def info(self, show_slab_cache=False):\n\t        txt = \"\"\n\t        if show_slab_cache:\n\t            txt += f\"{self.kmem_cache.name} \"\n\t        if self.kmem_cache_cpu is not None:\n\t            txt += f\"cpu{self.kmem_cache_cpu.cpu_id} \"\n\t            if self.page.type == sb.SlabType.MAIN_SLAB:\n\t                txt += \"main \"\n\t            elif self.page.type == sb.SlabType.PARTIAL_SLAB:\n\t                txt += \"partial \"\n", "        elif self.kmem_cache_node is not None:\n\t            txt += f\"node{self.kmem_cache_node.node_id} \"\n\t            if self.page.type == sb.SlabType.NODE_SLAB:\n\t                txt += f\"partial \"\n\t        else:\n\t            if self.page.type == sb.SlabType.FULL_SLAB:\n\t                txt += f\"full \"\n\t        if self.page.count != 0:\n\t            txt += f\"{self.page.index}/{self.page.count}\"\n\t        else:\n", "            txt = txt[:-1] # remove ending space\n\t        return txt\n\t    @staticmethod\n\t    def indexof(address, list_objects):\n\t        \"\"\"Helper to quickly find if a given address is the start of a given chunk/object in a list of obj()\n\t        @param address: an integer address\n\t        @param list_objects: a list of obj()\n\t        @param the index of the obj() starting at address if found, or -1 if not found\n\t        \"\"\"\n\t        for index, obj in enumerate(list_objects):\n", "            if address == obj.address:\n\t                return index\n\t        return -1\n\t    @staticmethod\n\t    def is_object_address_in_slab_caches(kmem_caches, address):\n\t        \"\"\"Check if a given address is in one of the memory regions in a given slab cache or multiple slab caches\n\t        @param kmem_caches: a single kmem_cache Python object representing a slab cache or a list of them\n\t        @param address: address we want to check if it is a chunk/object in that slab cache\n\t        @param return a tuple (index, objects_list) where objects_list is the list of obj()\n\t               where the chunk/object address was found and index is the index in objects_list\n", "               where it was found. If it is not found, it returns None instead of the tuple\n\t        \"\"\"\n\t        if type(kmem_caches) == kc.kmem_cache:\n\t            kmem_caches = [kmem_caches]\n\t        elif type(kmem_caches) == list:\n\t            pass\n\t        else:\n\t            pu.print_error(\"Invalid kmem_caches type passed to is_object_address_in_slab_cache(), should not happen\")\n\t            return None\n\t        for kmem_cache in kmem_caches:\n", "            for kmem_cache_cpu in kmem_cache.kmem_cache_cpu_list:\n\t                main_slab = kmem_cache_cpu.main_slab\n\t                # sometimes, a cpu has no slab especially (e.g. with threadripper)\n\t                if main_slab != None:\n\t                    index = obj.indexof(address, main_slab.objects_list)\n\t                    if index >= 0:\n\t                        return index, main_slab.objects_list\n\t                for partial_slab in kmem_cache_cpu.partial_slabs:\n\t                    index = obj.indexof(address, partial_slab.objects_list)\n\t                    if index >= 0:\n", "                        return index, partial_slab.objects_list\n\t            for kmem_cache_node in kmem_cache.kmem_cache_node_list:\n\t                for partial_slab in kmem_cache_node.partial_slabs:\n\t                    index = obj.indexof(address, partial_slab.objects_list)\n\t                    if index >= 0:\n\t                        return index, partial_slab.objects_list\n\t            for full_slab in kmem_cache.full_slabs:\n\t                index = obj.indexof(address, full_slab.objects_list)\n\t                if index >= 0:\n\t                    return index, full_slab.objects_list\n", "        return None"]}
{"filename": "libslub/slub/page.py", "chunked_list": ["from operator import index\n\timport struct\n\timport sys\n\timport importlib\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.heap_structure as hs\n\timportlib.reload(hs)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n", "import libslub.slub.obj as obj\n\timportlib.reload(obj)\n\timport libslub.frontend.commands.gdb.sbobject as sbobject\n\timportlib.reload(sbobject)\n\tclass page(hs.heap_structure):\n\t    \"\"\"python representation of a struct page\n\t    struct page {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/mm_types.h#L70\n\t    \"\"\"\n\t    def __init__(self, sb, kmem_cache, kmem_cache_cpu, kmem_cache_node, type, index=0, count=0, value=None, address=None, is_main_slab=False):\n\t        \"\"\"\n", "        Parse page's data and initialize the page object\n\t        :param sb: slab object holding all our useful info\n\t        :param value: gdb.Value of type page with structure's content read from the debugger (represented by a dictionary)\n\t        :param address: address for a page where to read the structure's content from the debugger (not supported yet)\n\t        \"\"\"\n\t        super(page, self).__init__(sb)\n\t        # page structure's fields can be looked up directly from the gdb.Value\n\t        self.value = value # gdb.Value representing the page\n\t        self.kmem_cache = kmem_cache # kmem_cache Python object\n\t        self.kmem_cache_cpu = kmem_cache_cpu # kmem_cache_cpu Python object or None\n", "        self.kmem_cache_node = kmem_cache_node # kmem_cache_node Python object or None\n\t        self.type = type   # SlabType enum representing the slab type\n\t        self.init(index, count, is_main_slab)\n\t    def init(self, index, count, is_main_slab):\n\t        # our own abstraction fields\n\t        self.address = int(self.value.address) & sb.sb.UNSIGNED_LONG\n\t        self.index = index # index in the slab linked list (struct page*)\n\t        self.count = count # count of slabs in the linked list (struct page*)\n\t        self.is_main_slab = is_main_slab # boolean to indicate if main slab associated with given cpu\n\t        self.objects = int(self.value[\"objects\"]) & sb.sb.UNSIGNED_INT\n", "        self.inuse = int(self.value[\"inuse\"]) & sb.sb.UNSIGNED_INT\n\t        self.frozen = int(self.value[\"frozen\"])\n\t        self.fp = int(self.value[\"freelist\"]) & sb.sb.UNSIGNED_LONG # freelist head address\n\t        kmem_cache_value = self.value[\"slab_cache\"].dereference() # gdb.Value representing the parent kmem_cache\n\t        freelist_addresses = list(sb.sb.walk_freelist(kmem_cache_value, self.fp)) # list of addresses\n\t        self.freelist = []\n\t        for address in freelist_addresses:\n\t            o = obj.obj(self.sb, address, self.kmem_cache, self.kmem_cache_cpu, self.kmem_cache_node, self, inuse=False)\n\t            self.freelist.append(o)\n\t        self.region_start = self.sb.page_addr(self.address)\n", "        self.region_end = self.region_start + self.objects*int(kmem_cache_value[\"size\"])\n\t        object_addresses = list(sb.sb.walk_linear_memory_region(kmem_cache_value, self.value, self.region_start))\n\t        self.objects_list = []\n\t        for address in object_addresses:\n\t            found = False\n\t            # have unique obj() shared between freelist and objects_list\n\t            # is it the main slab and is the object in the main freelist\n\t            if self.is_main_slab:\n\t                for o in self.kmem_cache_cpu.freelist:\n\t                    if address == o.address:\n", "                        self.objects_list.append(o)\n\t                        found = True\n\t                        break\n\t            if found is True:\n\t                continue\n\t            # is the object tracked in the slab's free list?\n\t            try:\n\t                index = freelist_addresses.index(address)\n\t            except ValueError:\n\t                pass\n", "            else:\n\t                self.objects_list.append(self.freelist[index])\n\t                found = True\n\t            if found is True:\n\t                continue\n\t            # not in any freelist, so creating obj()\n\t            o = obj.obj(self.sb, address, self.kmem_cache, self.kmem_cache_cpu, self.kmem_cache_node, self, inuse=True)\n\t            self.objects_list.append(o)\n\t    def print(self, name=\"\", verbose=0, use_cache=False, indent=0, cmd=None):\n\t        \"\"\"Pretty printer for the page supporting different level of verbosity\n", "        :param verbose: 0 for non-verbose. 1 for more verbose. 2 for even more verbose.\n\t        :param use_cache: True if we want to use the cached information from the cache object.\n\t                          False if we want to fetch the data again\n\t        :param cmd: cmd.args == arguments so we know what options have been passed by the user\n\t                     e.g. to print hexdump of objects/chunks, highlight chunks, etc.\n\t        \"\"\"\n\t        if cmd.args.object_only is not True:\n\t            txt = \" \"*indent\n\t            if name:\n\t                txt += \"{:8} = \".format(name)\n", "            if self.is_main_slab:\n\t                title = \"struct page @ 0x%x {\" % (self.address)\n\t            else:\n\t                title = \"struct page @ 0x%x (%d/%d) {\" % (self.address, self.index, self.count)\n\t            txt += pu.color_title(title)\n\t            txt += \"\\n{:s}  {:8} = \".format(\" \"*indent, \"objects\")\n\t            txt += pu.color_value(\"{:#d}\".format(self.objects))\n\t            if self.is_main_slab:\n\t                txt += \"\\n{:s}  {:8} = \".format(\" \"*indent, \"inuse\")\n\t                txt += pu.color_value(\"{:#d}\".format(self.inuse))\n", "                # the inuse value is kind of a lie in this case\n\t                txt += \" (real = {:#d})\".format(self.inuse-len(self.kmem_cache_cpu.freelist))\n\t            else: # partial slab, full slab, etc.\n\t                txt += \"\\n{:s}  {:8} = \".format(\" \"*indent, \"inuse\")\n\t                txt += pu.color_value(\"{:#d}\".format(self.inuse))\n\t            txt += \"\\n{:s}  {:8} = \".format(\" \"*indent, \"frozen\")\n\t            txt += pu.color_value(\"{:#d}\".format(self.frozen))\n\t            txt += \"\\n{:s}  {:8} = \".format(\" \"*indent, \"freelist\")\n\t            txt += pu.color_value(\"{:#x}\".format(self.fp))\n\t            txt += \" ({:#d} elements)\".format(len(self.freelist))\n", "            txt += \"\\n\"\n\t            print(txt, end=\"\")\n\t        if cmd.args.show_freelist:\n\t            if cmd.args.object_only is True and cmd.args.hide_title is False:\n\t                txt = pu.color_value(\"{:s}regular freelist:\").format(\" \"*indent)\n\t                txt += \"\\n\"\n\t                print(txt, end=\"\")\n\t            # print the objects in the the freelist\n\t            # Prepare arguments for \"sbobject\" format\n\t            # i.e. the chunks to print are from the freelist\n", "            # The amount of printed addresses will be limited by \n\t            # parse_many()'s \"count\" argument\n\t            if cmd.args.count == None:\n\t                count = len(self.freelist)\n\t            else:\n\t                count = cmd.args.count\n\t            sbobject.sbobject.parse_many(\n\t                self.freelist, \n\t                0, \n\t                cmd.sb, \n", "                cmd.dbg, \n\t                None, # count\n\t                count, # count_handle,\n\t                cmd.args.search_depth,\n\t                cmd.args.skip_header, \n\t                cmd.args.hexdump_unit, \n\t                cmd.args.search_value, \n\t                cmd.args.search_type, \n\t                cmd.args.match_only, \n\t                cmd.args.print_offset, \n", "                cmd.args.verbose, \n\t                cmd.args.no_newline,\n\t                cmd.args.debug, \n\t                cmd.args.hexdump, \n\t                cmd.args.maxbytes, \n\t                cmd.args.metadata,\n\t                highlight_types=cmd.highlight_types,\n\t                highlight_addresses=cmd.highlight_addresses,\n\t                highlight_metadata=cmd.highlight_metadata,\n\t                highlight_only=cmd.args.highlight_only,\n", "                commands=cmd.args.commands,\n\t                use_cache=cmd.args.use_cache,\n\t                address_offset=cmd.args.address_offset,\n\t                name=cmd.args.name,\n\t                indent=\" \"*(indent+4),\n\t                is_freelist=True,\n\t                object_info=cmd.args.object_info,\n\t            )\n\t        if cmd.args.object_only is not True:\n\t            txt = \"{:s}  region   @ {:#x}-{:#x}\".format(\" \"*indent, self.region_start, self.region_end)\n", "            txt += \" ({:#d} elements)\".format(len(self.objects_list))\n\t            txt += \"\\n\"\n\t            print(txt, end=\"\")\n\t        if cmd.args.show_region:\n\t            if cmd.args.object_only is True and cmd.args.hide_title is False:\n\t                txt = pu.color_value(\"{:s}  region:\").format(\" \"*indent)\n\t                txt += \"\\n\"\n\t                print(txt, end=\"\")\n\t            # print the linear objects in the the slab\n\t            if cmd.args.count == None:\n", "                count = len(self.objects_list)\n\t            else:\n\t                count = cmd.args.count\n\t            sbobject.sbobject.parse_many(\n\t                self.objects_list, \n\t                0, \n\t                cmd.sb, \n\t                cmd.dbg, \n\t                None, # count \n\t                count, # count_handle\n", "                cmd.args.search_depth,\n\t                cmd.args.skip_header, \n\t                cmd.args.hexdump_unit, \n\t                cmd.args.search_value, \n\t                cmd.args.search_type, \n\t                cmd.args.match_only, \n\t                cmd.args.print_offset, \n\t                cmd.args.verbose, \n\t                cmd.args.no_newline,\n\t                cmd.args.debug, \n", "                cmd.args.hexdump, \n\t                cmd.args.maxbytes, \n\t                cmd.args.metadata,\n\t                highlight_types=cmd.highlight_types,\n\t                highlight_addresses=cmd.highlight_addresses,\n\t                highlight_metadata=cmd.highlight_metadata,\n\t                highlight_only=cmd.args.highlight_only,\n\t                commands=cmd.args.commands,\n\t                use_cache=cmd.args.use_cache,\n\t                address_offset=cmd.args.address_offset,\n", "                name=cmd.args.name,\n\t                indent=\" \"*(indent+4),\n\t                is_region=True,\n\t                object_info=cmd.args.object_info,\n\t            )"]}
{"filename": "libslub/slub/sb.py", "chunked_list": ["import struct\n\timport sys\n\timport logging\n\timport importlib\n\timport gdb\n\tfrom enum import Enum\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.frontend.helpers as h\n\timportlib.reload(h)\n", "import libslub.frontend.helpers2 as h2\n\timportlib.reload(h2)\n\timport libslub.frontend.breakpoints.gdb.breakpoints as breakpoints\n\timportlib.reload(breakpoints)\n\t# XXX - may be want to move the sbslabdb stuff in the sbcache command so sb.py does not rely on sbslabdb.py\n\timport libslub.frontend.commands.gdb.sbslabdb as sbslabdb\n\timportlib.reload(sbslabdb)\n\timport libslub.slub.cache as c\n\timportlib.reload(c)\n\tlog = logging.getLogger(\"libslub\")\n", "log.trace(\"sb.py\")\n\tclass SlabType(Enum):\n\t    MAIN_SLAB = 0\n\t    PARTIAL_SLAB = 1\n\t    NODE_SLAB = 2  # partial slab in node\n\t    FULL_SLAB = 3  # full slab in node\n\t# XXX - some methods in this helper class could be changed to fetch information from the cache instead of fetching it from\n\t# memory again\n\tclass sb:\n\t    UNSIGNED_INT = 0xFFFFFFFF\n", "    UNSIGNED_LONG = 0xFFFFFFFFFFFFFFFF\n\t    TYPE_CODE_HAS_FIELDS = [gdb.TYPE_CODE_STRUCT, gdb.TYPE_CODE_UNION]\n\t    # XXX - move to sblist.py?\n\t    kmalloc_caches = [\n\t        \"kmalloc-%s\" % n\n\t        for n in [\n\t            \"8\",\n\t            \"16\",\n\t            \"32\",\n\t            \"64\",\n", "            \"96\",\n\t            \"128\",\n\t            \"192\",\n\t            \"256\",\n\t            \"512\",\n\t            \"1k\",\n\t            \"2k\",\n\t            \"4k\",\n\t            \"8k\",\n\t        ]\n", "    ]\n\t    FLAGS = {\n\t        0x00000100: \"SLAB_DEBUG_FREE\",\n\t        0x00000400: \"SLAB_RED_ZONE\",\n\t        0x00000800: \"SLAB_POISON\",\n\t        0x00002000: \"SLAB_HWCACHE_ALIGN\",\n\t        0x00004000: \"SLAB_CACHE_DMA\",\n\t        0x00008000: \"SLAB_CACHE_DMA32\",\n\t        0x00010000: \"SLAB_STORE_USER\",\n\t        0x00020000: \"SLAB_RECLAIM_ACCOUNT\",\n", "        0x00040000: \"SLAB_PANIC\",\n\t        0x00080000: \"SLAB_DESTROY_BY_RCU\",\n\t        0x00100000: \"SLAB_MEM_SPREAD\",\n\t        0x00200000: \"SLAB_TRACE\",\n\t        0x00400000: \"SLAB_DEBUG_OBJECTS\",\n\t        0x00800000: \"SLAB_NOLEAKTRACE\",\n\t        0x01000000: \"SLAB_NOTRACK\",\n\t        0x02000000: \"SLAB_FAILSLAB\",\n\t        0x40000000: \"__CMPXCHG_DOUBLE\",\n\t        0x80000000: \"__OBJECT_POISON\",\n", "    }\n\t    def __init__(self, SIZE_SZ=None, debugger=None, breakpoints_enabled=False):\n\t        \"\"\"\n\t        :param debugger: the pydbg object\n\t        Internally, everything is kept as gdb.Value\n\t        \"\"\"\n\t        self.SIZE_SZ = SIZE_SZ\n\t        self.dbg = debugger\n\t        self.breakpoints_enabled = breakpoints_enabled\n\t        self.node_num = self._get_node_num()  # number of NUMA node\n", "        self.arch = self.get_arch()\n\t        self._check_slub()\n\t        self.cpu_num = gdb.lookup_global_symbol(\"nr_cpu_ids\").value()\n\t        self.per_cpu_offset = gdb.lookup_global_symbol(\"__per_cpu_offset\").value()\n\t        try:\n\t            self.memstart_addr = gdb.lookup_global_symbol(\"memstart_addr\").value()\n\t        except Exception:\n\t            self.memstart_addr = None\n\t        # Defines if the breakpoints used for tracking should be hidden to the user\n\t        # as used for \"internal\" in https://sourceware.org/gdb/onlinedocs/gdb/Breakpoints-In-Python.html\n", "        self.bps_hidden = True  # set to False for debugging only\n\t        # List of cache names (e.g. \"kmalloc-1k\") to track object allocations/frees\n\t        # for logging purpose or for breaking in the debugger\n\t        self.trace_caches = []\n\t        self.break_caches = []\n\t        # List of cache names (e.g. \"kmalloc-1k\") to track slab allocations/frees so\n\t        # we can list the full-slabs contents since they are not tracked by SLUB\n\t        self.watch_caches = []\n\t        # List of slab addresses (struct page*) for previously allocated slabs that we\n\t        # managed to track. This is so we can list the full-slabs contents when needed\n", "        self.slabs_list = []\n\t        if self.breakpoints_enabled:\n\t            self.breakpoints = breakpoints.breakpoints(self)\n\t        self.cache = c.cache(self)\n\t        self.set_globals(SIZE_SZ=self.SIZE_SZ)\n\t    def set_globals(self, SIZE_SZ=None):\n\t        if SIZE_SZ is None:\n\t            if self.dbg is None:\n\t                pu.print_error(\"Please specify a SIZE_SZ value or run in debugger.\")\n\t                raise Exception(\"sys.exit()\")\n", "            self.SIZE_SZ = self.dbg.get_size_sz()\n\t            if self.SIZE_SZ is None:\n\t                pu.print_error(\"error fetching size\")\n\t                raise Exception(\"sys.exit()\")\n\t        else:\n\t            self.SIZE_SZ = SIZE_SZ\n\t    def _get_node_num(self):\n\t        \"\"\"\n\t        get the number of NUMA nodes in the hardware\n\t        reference:\n", "        https://futurewei-cloud.github.io/ARM-Datacenter/qemu/how-to-configure-qemu-numa-nodes/\n\t        https://elixir.bootlin.com/linux/v4.15/source/include/linux/nodemask.h#L433\n\t        \"\"\"\n\t        node_states = gdb.lookup_global_symbol(\"node_states\").value()\n\t        node_mask = node_states[1][\"bits\"][0]  # 1 means N_ONLINE\n\t        return bin(node_mask).count(\"1\")\n\t    def _check_slub(self):\n\t        \"\"\"\n\t        make sure the target kernel is compiled with SLUB, not SLAB or SLOB\n\t        \"\"\"\n", "        allocator = \"SLOB\"\n\t        kmem_cache = gdb.lookup_type(\"struct kmem_cache\")\n\t        for field in gdb.types.deep_items(kmem_cache):\n\t            name = field[0]\n\t            if name == \"batchcount\":\n\t                allocator = \"SLAB\"\n\t                break\n\t            elif name == \"inuse\":\n\t                allocator = \"SLUB\"\n\t                break\n", "        if allocator != \"SLUB\":\n\t            raise ValueError(\"slabdbg does not support allocator: %s\" % allocator)\n\t    def get_arch(self):\n\t        \"\"\"Return the binary's architecture.\"\"\"\n\t        if h2.is_alive():\n\t            arch = gdb.selected_frame().architecture()\n\t            return arch.name()\n\t        arch_str = gdb.execute(\"show architecture\", to_string=True).strip()\n\t        if (\n\t            \"The target architecture is set automatically (currently \" in arch_str\n", "            or 'The target architecture is set to \"auto\" (currently ' in arch_str\n\t        ):\n\t            # architecture can be auto detected\n\t            arch_str = arch_str.split(\"(currently \", 1)[1]\n\t            arch_str = arch_str.split(\")\", 1)[0]\n\t        elif \"The target architecture is assumed to be \" in arch_str:\n\t            # architecture can be assumed\n\t            arch_str = arch_str.replace(\"The target architecture is assumed to be \", \"\")\n\t        else:\n\t            # unknown, we throw an exception to be safe\n", "            raise RuntimeError(\"Unknown architecture: {}\".format(arch_str))\n\t        return arch_str\n\t    @staticmethod\n\t    def get_field_bitpos(type, member):\n\t        \"\"\"XXX\"\"\"\n\t        for field in type.fields():\n\t            if field.name == member:\n\t                return field.bitpos\n\t            if field.type.code in sb.TYPE_CODE_HAS_FIELDS:\n\t                bitpos = sb.get_field_bitpos(field.type, member)\n", "                if bitpos is not None:\n\t                    return field.bitpos + bitpos\n\t        return None\n\t    @staticmethod\n\t    def for_each_entry(type, head, member):\n\t        \"\"\"Iterator for a linked list pointed by head (i.e. starting address) where each element\n\t        of the linked list is of the \"type\" type and the next element being found at the \"member\"\n\t        member of the \"type\" type.\n\t        @param type: a gdb.Type (e.g. representing \"struct kmem_cache\") to cast elements in the linked list pointed by head\n\t        @param head: a gdb.Value for a \"struct list_head\" (linked list) represented by a dictionary (so having the \"next\" and \"prev\" keys)\n", "        @param member: the name of the linked list pointed by head in the provided type\n\t                       e.g. \"struct kmem_cache\" has its linked list named \"list\"\n\t        @return: iterator returning the gdb.Type casted objects found at the different elements\n\t                 in the linked list pointed by head\n\t        \"\"\"\n\t        void_p = gdb.lookup_type(\"void\").pointer()  # type represents a void*\n\t        offset = sb.get_field_bitpos(type, member) // 8\n\t        pos = head[\"next\"].dereference()\n\t        while pos.address != head.address:\n\t            entry = gdb.Value(pos.address.cast(void_p) - offset)\n", "            # print(entry)\n\t            # print(entry.cast(type.pointer()).dereference())\n\t            # print(\"Found list entry: 0x%x\" % entry)\n\t            # Cast the gdb.Value address to the right type and return that as a dictionary\n\t            yield entry.cast(type.pointer()).dereference()\n\t            pos = pos[\"next\"].dereference()\n\t    @staticmethod\n\t    def iter_slab_caches():\n\t        \"\"\"Iterator for the \"struct list_head slab_caches\" which is a linked list of \"struct kmem_cache*\"\n\t        representing all the slab caches on the system.\n", "        struct kmem_cache* kmem_cache: https://elixir.bootlin.com/linux/v5.15/source/mm/slab_common.c#L38\n\t        @return: iterator returning the the different \"struct kmem_cache\" elements (represented as dictionaries)\n\t                 part of the \"list\" linked list of the \"struct kmem_cache\" structure, which head starts\n\t                 at the \"slab_caches\" global.\n\t        \"\"\"\n\t        # The \"kmem_cache\" type as a dictionary\n\t        # struct kmem_cache {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/slub_def.h#L90\n\t        # lookup_type(), see https://sourceware.org/gdb/onlinedocs/gdb/Types-In-Python.html\n\t        kmem_cache_type = gdb.lookup_type(\"struct kmem_cache\")\n\t        # The head of the list for all slab caches on the system (e.g. \"kmalloc-64\", etc.)\n", "        # https://elixir.bootlin.com/linux/v5.15/source/mm/slab.h#L72\n\t        # lookup_global_symbol(), see https://sourceware.org/gdb/onlinedocs/gdb/Symbols-In-Python.html\n\t        slab_caches = gdb.lookup_global_symbol(\"slab_caches\").value()\n\t        return sb.for_each_entry(kmem_cache_type, slab_caches, \"list\")\n\t    @staticmethod\n\t    def find_slab_cache(name):\n\t        for slab_cache in sb.iter_slab_caches():\n\t            if slab_cache[\"name\"].string() == name:\n\t                return slab_cache\n\t        return None\n", "    @staticmethod\n\t    def get_cache_names():\n\t        for slab_cache in sb.iter_slab_caches():\n\t            yield slab_cache[\"name\"].string()\n\t    @staticmethod\n\t    def get_flags_list(flags):\n\t        return [sb.FLAGS[x] for x in sb.FLAGS if flags & x == x]\n\t    @staticmethod\n\t    def freelist_ptr(slab_cache, freelist, freelist_addr):\n\t        \"\"\"Return a possibly decoded freelist value\n", "        This function only actually does anything if the random member is found\n\t        in the slab_cache, otherwise we assume that freelist coding isn't\n\t        supported\n\t        Note: At some point in additional bit diffusion technique was added,\n\t        which changes the way there encoding is done... we need a way to test\n\t        for this probably. apossibly decoding it twice and seeing which one is\n\t        a valid address? See XXX below..\n\t        https://patchwork.kernel.org/project/linux-mm/patch/202003051623.AF4F8CB@keescook/\n\t        Newer versions of the linux kernel encode this pointer\n\t        See freelist_ptr in slub.c for implementation:\n", "        static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t                         unsigned long ptr_addr)\n\t        {\n\t        #ifdef CONFIG_SLAB_FREELIST_HARDENED\n\t            /*\n\t            return (void *)((unsigned long)ptr ^ s->random ^\n\t                    swab((unsigned long)kasan_reset_tag((void *)ptr_addr)));\n\t        #else\n\t            return ptr;\n\t        #endif\n", "        }\n\t        ptr_addr is the address of the ptr in the kmem_cache structure itself.\n\t        \"\"\"\n\t        # Not sure how to check for keys in gdb.Value struct... so try instead\n\t        try:\n\t            random = int(slab_cache[\"random\"])\n\t        except Exception:\n\t            return freelist\n\t        # print(\"Freelist address: 0x%x\" % freelist_addr)\n\t        random = int(slab_cache[\"random\"])\n", "        decoded = (\n\t            random\n\t            ^ int(freelist.cast(gdb.lookup_type(\"unsigned long\")))\n\t            ^ h.swap64(freelist_addr)\n\t        )\n\t        # XXX To solve the swap64() possibly not existing, we could check if\n\t        # the decoded address lives inside the slab cache page, since all of\n\t        # the objects should be inside of it...\n\t        return decoded\n\t    @staticmethod\n", "    def walk_linear_memory_region(slab_cache, slab, region_start):\n\t        \"\"\"Iterator returns each object/chunk address in the slab memory region\n\t        @param slab_cache: slab cache (gdb.Value) associated with a given slab. The reason we pas it is because it contains\n\t               fields to know the size of objects, etc.\n\t        @param slab: slab (gdb.Value) we want to get the objects/chunks from its memory region\n\t        @param region_start: start address of the memory region holding the objects/chunks for that slab\n\t        @return: iterator returns each object/chunk address in the slab memory region\n\t        \"\"\"\n\t        objects = int(slab[\"objects\"]) & sb.UNSIGNED_INT\n\t        size = int(slab_cache[\"size\"])\n", "        for address in range(region_start, region_start + objects * size, size):\n\t            yield address\n\t    @staticmethod\n\t    def walk_freelist(slab_cache, freelist):\n\t        \"\"\"Iterator return each object address in the slab's free list\n\t        @param slab_cache: slab cache associated with a given slab. The reason we pas it is because it contains\n\t                offsets and random values used to find the next element in the freelist\n\t        @param freelist: address of the head of the freelist\n\t        @return: iterator returns each object address in the slab's free list\n\t        \"\"\"\n", "        void = gdb.lookup_type(\"void\").pointer().pointer()\n\t        offset = int(slab_cache[\"offset\"])\n\t        # Stop when we encounter a NULL pointer\n\t        while freelist:\n\t            address = int(freelist) & sb.UNSIGNED_LONG\n\t            yield address\n\t            freelist = gdb.Value(address + offset).cast(void).dereference()\n\t            freelist = sb.freelist_ptr(slab_cache, freelist, address + offset)\n\t    # XXX - move to class: kmem_cache_cpu\n\t    def get_current_slab_cache_cpu(self, slab_cache):\n", "        \"\"\"\n\t        See https://elixir.bootlin.com/linux/v5.15/source/include/linux/slub_def.h#L91\n\t        @return a gdb.Value representing the current kmem_cache_cpu for that slab cache\n\t        i.e. representing kmem_cache->cpu_slab\n\t        NOTE: The gdb.Value represents a structure and is a simple dictionary\n\t        see https://sourceware.org/gdb/onlinedocs/gdb/Values-From-Inferior.html\n\t        \"\"\"\n\t        void_p = gdb.lookup_type(\"void\").pointer()  # type represents a void*\n\t        kmem_cache_cpu = gdb.lookup_type(\n\t            \"struct kmem_cache_cpu\"\n", "        ).pointer()  # type represents a kmem_cache_cpu*\n\t        # selected_thread(), see: https://sourceware.org/gdb/onlinedocs/gdb/Threads-In-Python.html\n\t        current_cpu = gdb.selected_thread().num - 1\n\t        cpu_offset = self.per_cpu_offset[current_cpu]\n\t        cpu_slab = gdb.Value(slab_cache[\"cpu_slab\"].cast(void_p) + cpu_offset)\n\t        return cpu_slab.cast(kmem_cache_cpu).dereference()\n\t    # XXX - move to class: kmem_cache_cpu\n\t    def get_all_slab_cache_cpus(self, slab_cache):\n\t        \"\"\"\n\t        See https://elixir.bootlin.com/linux/v5.15/source/include/linux/slub_def.h#L91\n", "        @return a list of all the gdb.Value representing all the kmem_cache_cpu for that slab cache\n\t        i.e. representing the different kmem_cache->cpu_slab\n\t        NOTE: The gdb.Value represents a structure and is a simple dictionary\n\t        see https://sourceware.org/gdb/onlinedocs/gdb/Values-From-Inferior.html\n\t        \"\"\"\n\t        void_p = gdb.lookup_type(\"void\").pointer()  # type represents a void*\n\t        kmem_cache_cpu = gdb.lookup_type(\n\t            \"struct kmem_cache_cpu\"\n\t        ).pointer()  # type represents a kmem_cache_cpu*\n\t        offset = slab_cache[\"cpu_slab\"]\n", "        result = []\n\t        for cpu_idx in range(self.cpu_num):\n\t            cpu_offset = self.per_cpu_offset[cpu_idx]\n\t            cpu_slab = gdb.Value(offset.cast(void_p) + cpu_offset)\n\t            cpu_slab = cpu_slab.cast(kmem_cache_cpu).dereference()\n\t            result.append(cpu_slab)\n\t        return result\n\t    def notify_obj_alloc(self, name, addr):\n\t        \"\"\"Called when a breakpoint tracking objects allocations in a given slab hits\"\"\"\n\t        if name in self.trace_caches:\n", "            print(\"Object 0x%x allocated in %s\" % (addr, name))\n\t    def notify_obj_free(self, name, addr):\n\t        \"\"\"Called when a breakpoint tracking objects frees in a given slab hits\"\"\"\n\t        if name in self.trace_caches:\n\t            print(\"Object 0x%x freed in %s\" % (addr, name))\n\t    def notify_slab_alloc(self, name, addr):\n\t        \"\"\"Called when a breakpoint tracking slabs allocations hits\"\"\"\n\t        if name in self.watch_caches:\n\t            print(\"Slab 0x%x allocated in %s\" % (addr, name))\n\t            self.slabs_list.append(addr)\n", "    def notify_slab_free(self, name, addr):\n\t        \"\"\"Called when a breakpoint tracking slabs frees hits\"\"\"\n\t        if name in self.watch_caches:\n\t            if addr in self.slabs_list:\n\t                print(\"Slab 0x%x freed in %s\" % (addr, name))\n\t                self.slabs_list.remove(addr)\n\t    # XXX - move to the actual slab object that matches the structure\n\t    def get_full_slabs(self, slab_cache_name):\n\t        \"\"\"Yield all tracked slab allocations that are determined to be full\n\t        for a given slab cache\n", "        @slab_cache_name: the slab cache name we want the full slabs of (e.g. \"kmalloc-1k\")\n\t        @return: Yield all the gdb.Value for the slab caches that are full (i.e. dictionaries\n\t                 representing the \"struct page*\" type)\n\t        \"\"\"\n\t        # We rely on breakpoints to keep track of allocations/frees of slabs,\n\t        # and keep them inside of slabs_list. This lets us view full slabs that\n\t        # would otherwise not be accessible.\n\t        if slab_cache_name in self.watch_caches:\n\t            yield from sb.full_slab_from_list(self.slabs_list, slab_cache_name)\n\t        # Alternatively, we rely on the sbslabdb command being used by us to track certain slabs\n", "        # associated with certain chunks address we want to track the slabs of\n\t        if slab_cache_name in sbslabdb.slab_db.keys():\n\t            yield from sb.full_slab_from_list(\n\t                sbslabdb.slab_db[slab_cache_name].keys(), slab_cache_name\n\t            )\n\t    @staticmethod\n\t    def full_slab_from_list(slabs_list, slab_cache_name):\n\t        \"\"\"Yield all tracked slab allocations that are determined to be full\n\t        for a given slab cache\n\t        @slabs_list: the list of struct page* addresses for certain slabs we tracked previously\n", "        @slab_cache_name: the slab cache name we want the full slabs of (e.g. \"kmalloc-1k\")\n\t        @return: Yield all the gdb.Value for the slab caches that are full (i.e. dictionaries\n\t                 representing the \"struct page*\" type)\n\t        We make sure that each slab in the\n\t        list is not on the free list (implying non-full), is not frozen\n\t        (implying it's not associated with this specific CPU at the moment?),\n\t        and the name matches whatever cache we are interested in\n\t        \"\"\"\n\t        page_type = gdb.lookup_type(\"struct page\").pointer()\n\t        for addr in slabs_list:\n", "            slab = gdb.Value(addr).cast(page_type)\n\t            slab_cache = slab[\"slab_cache\"]\n\t            if (\n\t                int(slab_cache) != 0x0\n\t                and slab_cache[\"name\"].string() == slab_cache_name\n\t                and int(slab[\"frozen\"]) == 0\n\t                and not slab[\"freelist\"]\n\t            ):\n\t                yield slab.dereference()\n\t    def page_addr(self, page):\n", "        \"\"\"XXX - I dont entirely understand why this is necessary\n\t        Comes from arch/x86/include/asm/page_64_types.h\n\t        #define __PAGE_OFFSET_BASE_L4 _AC(0xffff888000000000, UL)\n\t        \"\"\"\n\t        # Some configurations it stored in this variable, but it isnt queriable\n\t        # foo = gdb.lookup_global_symbol(\"__ro_after_init\").value()\n\t        if \"x86-64\" in self.arch:\n\t            offset = (page - 0xFFFFEA0000000000) >> 6 << 0xC\n\t            return (\n\t                # 0xFFFF880000000000 + offset\n", "                0xFFFF888000000000\n\t                + offset\n\t            )  # this value depends on kernel version if could be 0xFFFF888000000000\n\t        else:\n\t            memstart_addr = int(self.memstart_addr) & sb.UNSIGNED_LONG\n\t            addr = (memstart_addr >> 6) & sb.UNSIGNED_LONG\n\t            addr = (addr & 0xFFFFFFFFFF000000) & sb.UNSIGNED_LONG\n\t            addr = (0xFFFFFFBDC0000000 - addr) & sb.UNSIGNED_LONG\n\t            addr = (page - addr) & sb.UNSIGNED_LONG\n\t            addr = (addr >> 6 << 0xC) & sb.UNSIGNED_LONG\n", "            addr = (addr - memstart_addr) & sb.UNSIGNED_LONG\n\t            return addr | 0xFFFFFFC000000000\n\t    def get_slabs(self, slab_cache):\n\t        \"\"\"Collect a full list of all the slabs associated with a slab cache\"\"\"\n\t        pages = []  # these are actual \"struct page*\" (gdb.Value) representing a slab\n\t        cpu_cache_list = self.get_all_slab_cache_cpus(slab_cache)\n\t        for cpu_id, cpu_cache in enumerate(cpu_cache_list):\n\t            if cpu_cache[\"page\"]:\n\t                slab = cpu_cache[\"page\"].dereference()\n\t                pages.append(slab)\n", "            if cpu_cache[\"partial\"]:\n\t                slab_ptr = cpu_cache[\"partial\"]\n\t                while slab_ptr:\n\t                    slab = slab_ptr.dereference()\n\t                    pages.append(slab)\n\t                    slab_ptr = slab[\"next\"]\n\t        for node_id in range(self.node_num):\n\t            node_cache = slab_cache[\"node\"][node_id]\n\t            page = gdb.lookup_type(\"struct page\")\n\t            partials = list(self.for_each_entry(page, node_cache[\"partial\"], \"lru\"))\n", "            if partials:\n\t                for slab in partials:\n\t                    pages.append(slab)\n\t        fulls = list(self.get_full_slabs(slab_cache))\n\t        if fulls:\n\t            for slab in fulls:\n\t                pages.append(slab)\n\t        return pages\n\t    def get_slab_cache_memory_pages(self, slab_cache):\n\t        \"\"\"Collect a full list of all memory pages holding chunks associated with a slab cache\n", "        Similar to get_slab_cache_memory_pages_ranges() but returning start addresses\"\"\"\n\t        pages = self.get_slabs(\n\t            slab_cache\n\t        )  # these are actual \"struct page*\" (gdb.Value) representing a slab\n\t        page_addrs = []  # these are memory pages ranges holding chunks\n\t        for page in pages:\n\t            address = int(page.address) & sb.UNSIGNED_LONG\n\t            page_addrs.append(self.page_addr(address))\n\t        return page_addrs\n\t    def get_slab_cache_memory_pages_ranges(self, name=None, dict_enabled=False):\n", "        \"\"\"Collect a full list of all memory pages ranges holding chunks associated with one or several slab caches\n\t        @param name: slab cache name if known (optional)\n\t        Similar to get_slab_cache_memory_pages() but returning ranges\"\"\"\n\t        if dict_enabled is True:\n\t            page_addrs = (\n\t                {}\n\t            )  # key = page* address, and value = array for memory pages ranges holding chunks\n\t        else:\n\t            page_addrs = []  # these are memory pages ranges holding chunks\n\t        if not name:\n", "            slab_caches = sb.iter_slab_caches()\n\t        else:\n\t            slab_cache = sb.find_slab_cache(name)\n\t            if slab_cache is None:\n\t                print(\"Slab cache '%s' not found\" % name)\n\t                return None\n\t            slab_caches = [slab_cache]\n\t        for slab_cache in slab_caches:\n\t            pages = self.get_slabs(\n\t                slab_cache\n", "            )  # these are actual \"struct page*\" (gdb.Value) representing a slab\n\t            for page in pages:\n\t                objects = int(page[\"objects\"]) & sb.UNSIGNED_INT\n\t                size = int(slab_cache[\"size\"])\n\t                address = int(page.address) & sb.UNSIGNED_LONG\n\t                page_addr = self.page_addr(address)\n\t                page_end = page_addr + objects * size\n\t                if dict_enabled is True:\n\t                    page_addrs[address] = (page_addr, page_end)\n\t                else:\n", "                    page_addrs.append((page_addr, page_end))\n\t        return page_addrs\n\t    def get_slab_address(self, chunk_addr, name=None):\n\t        \"\"\"Get the slab address (struct page*) holding a given chunk address\n\t        @param chunk_addr: a chunk address we are looking for\n\t        @param name: slab cache name if known (optional)\n\t        @return the slab address (struct page*) holding that chunk\"\"\"\n\t        if not name:\n\t            slab_caches = sb.iter_slab_caches()\n\t        else:\n", "            slab_cache = sb.find_slab_cache(name)\n\t            if slab_cache is None:\n\t                print(\"Slab cache '%s' not found\" % name)\n\t                return None\n\t            slab_caches = [slab_cache]\n\t        for slab_cache in slab_caches:\n\t            pages = self.get_slabs(\n\t                slab_cache\n\t            )  # these are actual \"struct page*\" (gdb.Value) representing a slab\n\t            for page in pages:\n", "                objects = int(page[\"objects\"]) & sb.UNSIGNED_INT\n\t                size = int(slab_cache[\"size\"])\n\t                address = int(page.address) & sb.UNSIGNED_LONG\n\t                page_addr = self.page_addr(address)\n\t                page_end = page_addr + objects * size\n\t                if chunk_addr >= page_addr and chunk_addr < page_end:\n\t                    return address\n\t        return None\n\t    @staticmethod\n\t    def print_slab_cache_pages(name, pages):\n", "        pages.sort()\n\t        last_page = 0\n\t        print(f\"{name} has {len(pages)} memory pages:\")\n\t        for page in pages:\n\t            if last_page == page - 4096:\n\t                print(f\"0x{page:08x}*\")\n\t            else:\n\t                print(f\"0x{page:08x}\")\n\t            last_page = page\n\t    @staticmethod\n", "    def print_slab_cache_pages_ranges(name, pages):\n\t        pages.sort()\n\t        last_page = 0\n\t        print(f\"{name} has {len(pages)} memory pages:\")\n\t        for start_addr, end_addr in pages:\n\t            if last_page == start_addr - 4096:\n\t                print(f\"0x{start_addr:08x}-0x{end_addr:08x}*\")\n\t            else:\n\t                print(f\"0x{start_addr:08x}-0x{end_addr:08x}\")\n\t            last_page = start_addr\n"]}
{"filename": "libslub/slub/cache.py", "chunked_list": ["import struct\n\timport sys\n\timport logging\n\timport importlib\n\timport time\n\timport libslub.slub.kmem_cache as kc\n\timportlib.reload(kc)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n\timport libslub.frontend.helpers as h\n", "importlib.reload(h)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"cache.py\")\n\tclass cache:\n\t    \"\"\"Hold cached information such as our own classes representing slab structures, \n\t    as well as objects/chunk's addresses in the respective freelists.\n\t    Since browsing all these big structures and arrays can be slow in gdb, we cache\n\t    them in this class.\"\"\"\n\t    def __init__(self, sb):\n\t        self.sb = sb\n", "        # each key is a slab cache name (e.g. \"kmalloc-1k\")\n\t        # each value is a kmem_cache class holding all the useful information\n\t        self.slab_caches = {}\n\t    def update_kmem_cache(self, name=None, show_status=False, use_cache=False):\n\t        \"\"\"Update the kmem_cache object\n\t        :param name: slab cache name (e.g. \"kmalloc-1k\")\n\t        \"\"\"\n\t        log.debug(\"cache.update_kmem_cache()\")\n\t        # nothing to update if we use the cache\n\t        if use_cache:\n", "            return\n\t        if name is None:\n\t            slab_caches = sb.sb.iter_slab_caches()\n\t            print(\"Fetching all slab caches, this will take a while... (use -n to specify a slab cache)\")\n\t        else:\n\t            slab_cache = sb.sb.find_slab_cache(name)\n\t            if slab_cache is None:\n\t                print(\"Slab cache '%s' not found\" % name)\n\t                return\n\t            slab_caches = [slab_cache]\n", "        start_time = time.time()\n\t        for slab_cache in slab_caches:\n\t            kmem_cache = kc.kmem_cache(self.sb, value=slab_cache)\n\t            if show_status:\n\t                print(f\"Caching slab cache: {kmem_cache.name}\")\n\t            self.slab_caches[kmem_cache.name] = kmem_cache\n\t        end_time = time.time()\n\t        if name is None:\n\t            print(\"Fetched in %s\" % h.hms_string(end_time-start_time))\n\t    def update_all(self, name=None, show_status=False, use_cache=False):\n", "        self.update_kmem_cache(name=name, show_status=show_status, use_cache=use_cache)\n"]}
{"filename": "libslub/slub/kmem_cache_node.py", "chunked_list": ["import struct\n\timport sys\n\timport importlib\n\timport gdb\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.heap_structure as hs\n\timportlib.reload(hs)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n", "import libslub.slub.page as p\n\timportlib.reload(p)\n\tclass kmem_cache_node(hs.heap_structure):\n\t    \"\"\"python representation of a struct kmem_cache_node\n\t    struct kmem_cache_node {: https://elixir.bootlin.com/linux/v5.15/source/mm/slab.h#L533\n\t    \"\"\"\n\t    def __init__(self, sb, node_id, kmem_cache, value=None, address=None):\n\t        \"\"\"\n\t        Parse kmem_cache_node's data and initialize the kmem_cache_node object\n\t        :param sb: slab object holding all our useful info\n", "        :param value: gdb.Value of type kmem_cache_node with structure's content read from the debugger (represented by a dictionary)\n\t        :param address: address for a kmem_cache_node where to read the structure's content from the debugger (not supported yet)\n\t        \"\"\"\n\t        super(kmem_cache_node, self).__init__(sb)\n\t        # kmem_cache_node structure's fields can be looked up directly from the gdb.Value\n\t        self.value = value # gdb.Value representing the kmem_cache_node\n\t        self.kmem_cache = kmem_cache # kmem_cache object\n\t        self.init(node_id)\n\t    def init(self, node_id):\n\t        # our own abstraction fields\n", "        self.node_id = node_id # node index in the kmem_cache\n\t        self.address = int(self.value.address) & sb.sb.UNSIGNED_LONG\n\t        self.partial_slabs = [] # list of kmem_cache_cpu objects for that kmem_cache\n\t        # browse the list of gdb.Value (representing the kmem_cache_cpu->node[node_id].partial linked list of struct page*)\n\t        page_type = gdb.lookup_type(\"struct page\")\n\t        partial_slabs_values = list(self.sb.for_each_entry(page_type, self.value[\"partial\"], \"lru\"))\n\t        slab_count = len(partial_slabs_values)\n\t        for slab_index, slab_value in enumerate(partial_slabs_values):\n\t            partial_slab = p.page(self.sb, self.kmem_cache, None, self, sb.SlabType.NODE_SLAB, index=slab_index+1, count=slab_count, value=slab_value)\n\t            self.partial_slabs.append(partial_slab)\n", "    def print(self, verbose=0, use_cache=False, indent=0, cmd=None):\n\t        \"\"\"Pretty printer for the kmem_cache_node supporting different level of verbosity\n\t        :param verbose: 0 for non-verbose. 1 for more verbose. 2 for even more verbose.\n\t        :param use_cache: True if we want to use the cached information from the cache object.\n\t                          False if we want to fetch the data again\n\t        :param cmd: cmd.args == arguments so we know what options have been passed by the user\n\t                     e.g. to print hexdump of objects/chunks, highlight chunks, etc.\n\t        \"\"\"\n\t        if cmd.args.object_only is not True:\n\t            txt = \" \"*indent\n", "            title = \"struct kmem_cache_node @ 0x%x (node %d) {\" % (self.address, self.node_id)\n\t            txt += pu.color_title(title)\n\t            txt += \"\\n\"\n\t            print(txt, end=\"\")\n\t        if len(self.partial_slabs) == 0:\n\t            if cmd.args.object_only is not True:\n\t                print(\"{:s}  partial = (none)\".format(\" \"*indent))\n\t        else:\n\t            for partial_slab in self.partial_slabs:\n\t                partial_slab.print(name=\"partial\", indent=indent+2, cmd=cmd)"]}
{"filename": "libslub/slub/__init__.py", "chunked_list": ["import logging\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"slab/__init__.py\")"]}
{"filename": "libslub/slub/kmem_cache.py", "chunked_list": ["import struct\n\timport sys\n\timport importlib\n\timport logging\n\timport libslub.frontend.printutils as pu\n\timportlib.reload(pu)\n\timport libslub.slub.heap_structure as hs\n\timportlib.reload(hs)\n\timport libslub.slub.sb as sb\n\timportlib.reload(sb)\n", "import libslub.slub.kmem_cache_cpu as kcc\n\timportlib.reload(kcc)\n\timport libslub.slub.kmem_cache_node as kcn\n\timportlib.reload(kcn)\n\timport libslub.slub.page as p\n\timportlib.reload(p)\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"sbcache.py\")\n\tclass kmem_cache(hs.heap_structure):\n\t    \"\"\"python representation of a struct kmem_cache\n", "    struct kmem_cache {: https://elixir.bootlin.com/linux/v5.15/source/include/linux/slub_def.h#L90\"\"\"\n\t    def __init__(self, sb, value=None, address=None):\n\t        \"\"\"\n\t        Parse kmem_cache's data and initialize the kmem_cache object\n\t        :param sb: slab object holding all our useful info\n\t        :param value: gdb.Value of type kmem_cache with structure's content read from the debugger (represented by a dictionary)\n\t        :param address: address for a kmem_cache where to read the structure's content from the debugger (not supported yet)\n\t        \"\"\"\n\t        super(kmem_cache, self).__init__(sb)\n\t        # kmem_cache structure's fields can be looked up directly from the gdb.Value\n", "        self.value = value # gdb.Value representing the kmem_cache\n\t        self.init()\n\t    def init(self):\n\t        # our own abstraction fields\n\t        self.address = int(self.value.address) & sb.sb.UNSIGNED_LONG\n\t        self.name = self.value[\"name\"].string() # slab cache name (e.g. \"kmalloc-1k\")\n\t        log.debug(f\"kmem_cache.init({self.name})\")\n\t        self.flags = int(self.value[\"flags\"]) & sb.sb.UNSIGNED_LONG\n\t        self.offset = int(self.value[\"offset\"]) # Free pointer offset\n\t        self.size = int(self.value[\"size\"]) # The size of an object including metadata\n", "        self.object_size = int(self.value[\"object_size\"]) # The size of an object without metadata\n\t        self.kmem_cache_cpu_list = [] # list of kmem_cache_cpu objects for that kmem_cache\n\t        # browse the list of gdb.Value (representing the kmem_cache_cpu structure linked list for that kmem_cache)\n\t        for cpu_id, cache_cpu_value in enumerate(self.sb.get_all_slab_cache_cpus(self.value)):\n\t            kmem_cache_cpu = kcc.kmem_cache_cpu(self.sb, cpu_id, self, cache_cpu_value)\n\t            self.kmem_cache_cpu_list.append(kmem_cache_cpu)\n\t        self.kmem_cache_node_list = [] # list of kmem_cache_node objects for that kmem_cache\n\t        for node_id in range(self.sb.node_num):\n\t            node_value = self.value[\"node\"][node_id] # gdb.value representing kmem_cache->node[node_id] (struct kmem_cache_node *)\n\t            kmem_cache_node = kcn.kmem_cache_node(self.sb, node_id, kmem_cache=self, value=node_value)\n", "            self.kmem_cache_node_list.append(kmem_cache_node)\n\t        # NOTE: There will only be full slabs if one of the following condition is met:\n\t        # - there is/was a watch on a given slab. See 'slab watch' command logic for details\n\t        # - slabs were logged with the sbslabdb command\n\t        # XXX - Ideally we would need to track the full slabs per kmem_cache_node\n\t        # but we don't have that granularity yet\n\t        self.full_slabs = [] # the full slabs\n\t        full_slabs_values = list(self.sb.get_full_slabs(self.name))\n\t        slab_count = len(full_slabs_values)\n\t        for slab_index, full_slab_value in enumerate(full_slabs_values):\n", "            full_slab = p.page(self.sb, self, None, None, sb.SlabType.FULL_SLAB, index=slab_index+1, count=slab_count, value=full_slab_value)\n\t            self.full_slabs.append(full_slab)\n\t    def print(self, verbose=0, use_cache=False, cmd=None):\n\t        \"\"\"Pretty printer for the kmem_cache supporting different level of verbosity\n\t        :param verbose: 0 for non-verbose. 1 for more verbose. 2 for even more verbose.\n\t        :param use_cache: True if we want to use the cached information from the cache object.\n\t                          False if we want to fetch the data again\n\t        :param cmd: cmd.args == arguments so we know what options have been passed by the user\n\t                     e.g. to print hexdump of objects/chunks, highlight chunks, etc.\n\t        \"\"\"\n", "        if cmd.args.object_only is not True:\n\t            title = \"struct kmem_cache @ 0x%x {\" % self.address\n\t            txt = pu.color_title(title)\n\t            txt += \"\\n  {:11} = \".format(\"name\")\n\t            txt += pu.color_value(\"{:s}\".format(self.name))\n\t            txt += \"\\n  {:11} = \".format(\"flags\")\n\t            flags_list = sb.sb.get_flags_list(self.flags)\n\t            if flags_list:\n\t                txt += pu.color_value(\"{:s}\".format(\" | \".join(flags_list)))\n\t            else:\n", "                txt += pu.color_value(\"(none)\")\n\t            txt += \"\\n  {:11} = \".format(\"offset\")\n\t            txt += pu.color_value(\"{:#x}\".format(self.offset))\n\t            txt += \"\\n  {:11} = \".format(\"size\")\n\t            txt += pu.color_value(\"{:#d} ({:#x})\".format(self.size, self.size))\n\t            txt += \"\\n  {:11} = \".format(\"object_size\")\n\t            txt += pu.color_value(\"{:#d} ({:#x})\".format(self.object_size, self.object_size))\n\t            txt += \"\\n\"\n\t            print(txt, end=\"\")\n\t        for kmem_cache_cpu in self.kmem_cache_cpu_list:\n", "            # do not print when a cpu has no slab,\n\t            # especially useful with threadripper\n\t            if kmem_cache_cpu.main_slab == None:\n\t                continue\n\t            if (cmd.output_filtered is False or cmd.args.main_slab is True or cmd.args.partial_slab is True) and \\\n\t                (cmd.args.cpu is None or int(cmd.args.cpu) == kmem_cache_cpu.cpu_id):\n\t                kmem_cache_cpu.print(indent=2, cmd=cmd)\n\t        for kmem_cache_node in self.kmem_cache_node_list:\n\t            if (cmd.cpu_filtered is False and cmd.output_filtered is False) or cmd.args.node_slab is True:\n\t                kmem_cache_node.print(indent=2, cmd=cmd)\n", "        if (cmd.cpu_filtered is False and cmd.output_filtered is False) or cmd.args.full_slab is True:\n\t            # XXX - Ideally we would need to track the full slabs per kmem_cache_node\n\t            # but we don't have that granularity yet\n\t            if cmd.args.object_only is not True:\n\t                txt = \"  \"\n\t                title = \"struct kmem_cache_node @ unknown {\"\n\t                txt += pu.color_title(title)\n\t                txt += \"\\n\"\n\t                print(txt, end=\"\")\n\t            if len(self.full_slabs) == 0:\n", "                if cmd.args.object_only is not True:\n\t                    print(\"    {:8} = (none)\".format(\"full\"))\n\t            else:\n\t                for full_slab in self.full_slabs:\n\t                    full_slab.print(name=\"full\", indent=4, cmd=cmd)"]}
{"filename": "libslub/slub/heap_structure.py", "chunked_list": ["import logging\n\timport struct\n\tlog = logging.getLogger(\"libslub\")\n\tlog.trace(\"heap_structure.py\")\n\tclass heap_structure(object):\n\t    \"\"\"Represent a general structure. Can be inherited by any structure like malloc_chunk.\n\t    Allow factoring of functions used by many structures, so we don't duplicate code.\n\t    \"\"\"\n\t    def __init__(self, sb):\n\t        log.trace(\"heap_structure.__init__()\")\n", "        self.sb = sb\n\t        self.initOK = True\n\t        self.dbg = self.sb.dbg\n\t    def validate_address(self, address):\n\t        \"\"\"Valid that a given address can actually be used as chunk address\n\t        \"\"\"\n\t        log.trace(\"heap_structure.validate_address()\")\n\t        if address is None or address == 0 or type(address) != int:\n\t            print(\"Invalid address\")\n\t            #raise Exception(\"Invalid address\")\n", "            self.initOK = False\n\t            self.address = None\n\t            return False\n\t        else:\n\t            self.address = address\n\t        return True"]}
