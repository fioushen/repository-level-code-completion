{"filename": "run_jupyter.py", "chunked_list": ["#!/usr/bin/env python\n\timport os\n\timport sys\n\tfrom django.core.management import execute_from_command_line\n\tdef jupyter():\n\t    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"tests.settings\")\n\t    os.environ.setdefault(\"DJANGO_ALLOW_ASYNC_UNSAFE\", \"true\")\n\t    try:\n\t        import django_extensions\n\t    except ImportError:\n", "        raise ImportError(\"Необходимо установить django-extensions чтобы запустить юпитер (а также сам юпитер)\")\n\t    argv = sys.argv + ['shell_plus', '--notebook']\n\t    execute_from_command_line(sys.argv + ['makemigrations', 'tests'])\n\t    execute_from_command_line(sys.argv + ['migrate'])\n\t    execute_from_command_line(argv)\n\tif __name__ == \"__main__\":\n\t    jupyter()\n"]}
{"filename": "setup.py", "chunked_list": ["from setuptools import find_packages, setup\n\t__version__ = \"0.0.6\"\n\tdef readme():\n\t    with open('README.md', 'r') as f:\n\t        return f.read()\n\tsetup(\n\t    name=\"django_excel_report\",\n\t    version=__version__,\n\t    author=\"Boris Alekseev\",\n\t    author_email=\"i.borisalekseev@gmail.com\",\n", "    maintainer=\"\",\n\t    maintainer_email=\"\",\n\t    description=\"Simplify excel reports from django apps\",\n\t    long_description=readme(),\n\t    long_description_content_type='text/markdown',\n\t    packages=find_packages(exclude=[\"tests*\"]),\n\t    include_package_data=True,\n\t    zip_safe=False,\n\t    python_requires=\">=3.7\",\n\t    install_requires=[\n", "        \"XlsxWriter~=3.0.0\"\n\t    ],\n\t    license='MIT',\n\t    classifiers=[\n\t        'Development Status :: 3 - Alpha',\n\t        'License :: OSI Approved :: MIT License',\n\t        'Programming Language :: Python :: 3',\n\t        'Programming Language :: Python :: 3.7',\n\t        'Programming Language :: Python :: 3.8',\n\t        'Programming Language :: Python :: 3.9',\n", "        'Programming Language :: Python :: 3.10',\n\t    ],\n\t    project_urls={\n\t        'Source': 'https://github.com/dichem/django-excel-report'\n\t    },\n\t    keywords='django excel',\n\t)\n"]}
{"filename": "manage.py", "chunked_list": ["#!/usr/bin/env python\n\t\"\"\"Django's command-line utility for administrative tasks.\"\"\"\n\timport os\n\timport sys\n\tdef main():\n\t    \"\"\"Run administrative tasks.\"\"\"\n\t    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')\n\t    try:\n\t        from django.core.management import execute_from_command_line\n\t    except ImportError as exc:\n", "        raise ImportError(\n\t            \"Couldn't import Django. Are you sure it's installed and \"\n\t            \"available on your PYTHONPATH environment variable? Did you \"\n\t            \"forget to activate a virtual environment?\"\n\t        ) from exc\n\t    execute_from_command_line(sys.argv)\n\tif __name__ == '__main__':\n\t    main()\n"]}
{"filename": "test.py", "chunked_list": ["#!/usr/bin/env python\n\timport os\n\timport sys\n\tfrom django.core.management import execute_from_command_line\n\tdef runtests():\n\t    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"tests.settings\")\n\t    argv = sys.argv[:1] + [\"test\"] + sys.argv[1:]\n\t    execute_from_command_line(argv)\n\tif __name__ == \"__main__\":\n\t    runtests()\n"]}
{"filename": "django_excel_report/report.py", "chunked_list": ["from typing import Iterable, Any\n\tfrom django.db.models import QuerySet, Model\n\tfrom django.core.files.base import ContentFile\n\tfrom .writer import ReportMeta, Writer\n\tfrom .error import ReportError\n\tclass BaseReport(metaclass=ReportMeta):\n\t    model: Model = None\n\t    fields: str | Iterable[str] | dict[str, Any] = None\n\t    # annotations: dict = None\n\t    # next attrs builds in ReportMeta\n", "    _prefetch_related: set[str]\n\t    _select_related: set[str]\n\t    def __init__(self, queryset: QuerySet[Model]):\n\t        if not (queryset.model is self.model):\n\t            raise ReportError(\"%s class built for model %s, not for %s\" % (self.__class__, self.model, queryset.model))\n\t        self.queryset = queryset\n\t    def get_queryset(self) -> QuerySet[Model]:\n\t        # annotations do not ready yet\n\t        return self.queryset.select_related(*self._select_related).prefetch_related(*self._prefetch_related)\n\t    def get_django_file(self) -> ContentFile:\n", "        writer = Writer(sheet=\"report\")\n\t        writer.write_row([[field] for field in self.fields])\n\t        for obj in self:\n\t            writer.write_row(obj)\n\t        writer.wrap()\n\t        writer.save()\n\t        return writer.get_django_file()\n\t    def __iter__(self):\n\t        for obj in self.get_queryset():\n\t            yield self._get_row(obj)\n", "    def _get_row(self, obj: Model) -> list[str | list]:\n\t        return [getattr(self, f'get_{field}')(obj) for field in self.fields]\n"]}
{"filename": "django_excel_report/__init__.py", "chunked_list": ["try:\n\t    import django\n\texcept ImportError:\n\t    raise ImportError(\"django-excel-report extension requires django!\")\n\tfrom .report import BaseReport, ReportError\n"]}
{"filename": "django_excel_report/error.py", "chunked_list": ["class ReportError(Exception):\n\t    pass\n"]}
{"filename": "django_excel_report/writer/writer.py", "chunked_list": ["import io\n\timport xlsxwriter\n\timport math\n\tfrom django.core.files.base import ContentFile\n\tclass Writer:\n\t    \"\"\"Значения ширины и высоты в ячкйках подобраны эмпирически\"\"\"\n\t    def __init__(self, sheet):\n\t        self.io = io.BytesIO()\n\t        self.workbook = xlsxwriter.Workbook(self.io)\n\t        self.sheet = self.workbook.add_worksheet(sheet)\n", "        self.current_row = 0\n\t        self.columns_max_length = {}\n\t        self.format = self.get_format()\n\t    def write_row(self, row: list[list[str]]) -> None:\n\t        lcm = math.lcm(*map(list.__len__, row))\n\t        col_num = 0\n\t        for cell in row:\n\t            self._write_cell(cell, lcm, col_num)\n\t            col_num += 1\n\t        self.current_row += lcm\n", "    def _write_cell(self, cell: list[str], lcm: int, col_number: int):\n\t        merging_range = lcm // len(cell)\n\t        row_position = 0\n\t        row_height = 20\n\t        for data in cell:\n\t            row_height = min(max(len(data), row_height), 120)\n\t            self.columns_max_length[col_number] = max(len(data), self.columns_max_length.get(col_number, 0))\n\t            if merging_range == 1:\n\t                self.sheet.write(\n\t                    self.current_row + row_position,  # first row\n", "                    col_number,\n\t                    data,\n\t                    self.format\n\t                )\n\t            else:\n\t                self.sheet.merge_range(\n\t                    self.current_row + row_position,  # first row\n\t                    col_number,\n\t                    self.current_row + row_position + merging_range - 1,  # end row\n\t                    col_number,\n", "                    data,\n\t                    self.format\n\t                )\n\t            row_position += merging_range\n\t        for row in range(self.current_row, self.current_row + lcm):\n\t            self.sheet.set_row(row, max(row_height, self.sheet.row_sizes.get(row, [0])[0]))\n\t    def wrap(self):\n\t        for col_number, value in self.columns_max_length.items():\n\t            self.sheet.set_column(col_number, col_number, min(value + 5, 80))\n\t    def save(self):\n", "        self.workbook.close()\n\t    def get_django_file(self) -> ContentFile:\n\t        return ContentFile(self.io.getvalue())\n\t    def get_format(self):\n\t        format_ = self.workbook.add_format()\n\t        format_.set_text_wrap()\n\t        format_.set_align('center')\n\t        format_.set_align('vcenter')\n\t        return format_\n"]}
{"filename": "django_excel_report/writer/acessors_builder.py", "chunked_list": ["from typing import Iterable, Type, Callable\n\tfrom django.db import models\n\tfrom django.db.models.query_utils import DeferredAttribute\n\tfrom django.db.models.fields.related_descriptors import (\n\t    ManyToManyDescriptor,\n\t    ReverseManyToOneDescriptor,\n\t    ForwardManyToOneDescriptor,\n\t    ReverseOneToOneDescriptor,\n\t    ForwardOneToOneDescriptor\n\t)\n", "from ..error import ReportError\n\tfrom .accessors import Accessors\n\tPREFETCH_DESCRIPTORS_ATTRS = {\n\t    ReverseManyToOneDescriptor: lambda x: x.rel.related_model,\n\t    ManyToManyDescriptor: lambda x: x.rel.model\n\t}\n\tTO_SQL_JOIN_DESCRIPTORS = {\n\t    ForwardManyToOneDescriptor: lambda x: x.field.related_model,\n\t    ReverseOneToOneDescriptor: lambda x: x.related.related_model,\n\t    ForwardOneToOneDescriptor: lambda x: x.field.related_model\n", "}\n\tdef get_report_attributes(fields: Iterable[str], model: Type[models.Model]) -> dict[str, Callable | set]:\n\t    \"\"\"Проходится по полям, составляя словари с названиями связанных объектов для join и требуемыми полями\"\"\"\n\t    prefetch_related_fields = set()\n\t    select_related_fields = set()\n\t    attributes = {}\n\t    for field in fields:\n\t        parsed_field = field.split('__')\n\t        relation, prefetch_condition = \"\", 0\n\t        related_field = try_field = \"\"\n", "        current_model = model\n\t        reverse_access_methods = []  # sizes__picture__name [] for size in product_obj.sizes.all(): print(size.name)\n\t        while parsed_field:\n\t            try_field = parsed_field.pop(0)\n\t            descriptor = getattr(current_model, try_field, None)\n\t            if isinstance(descriptor, tuple(PREFETCH_DESCRIPTORS_ATTRS.keys())):\n\t                prefetch_condition = 1\n\t                current_model = PREFETCH_DESCRIPTORS_ATTRS[type(descriptor)](descriptor)\n\t                reverse_access_methods.append({'field': try_field, 'method': Accessors.M2M})\n\t            elif isinstance(descriptor, tuple(TO_SQL_JOIN_DESCRIPTORS.keys())):\n", "                current_model = TO_SQL_JOIN_DESCRIPTORS[type(descriptor)](descriptor)\n\t                reverse_access_methods.append({'field': try_field, 'method': Accessors.FK})\n\t            elif isinstance(descriptor, (DeferredAttribute, property)):\n\t                related_field = try_field\n\t                reverse_access_methods.append({'field': try_field, 'method': Accessors.FIELD})\n\t                if not parsed_field:\n\t                    break\n\t                else:\n\t                    raise ReportError(\"Поле %s модели %s не имеет связи к %s\" %\n\t                                      (related_field, current_model, parsed_field.pop(0)))\n", "            elif descriptor is None:\n\t                getattr(current_model, try_field)\n\t            else:\n\t                raise ReportError(\"Неправильно указано поле %s\" % field)\n\t            relation += \"__%s\" % try_field\n\t        if not related_field:\n\t            raise ReportError(\"Не удаётся найти поле '%s' в связанном объекте. Быть может, \"\n\t                              \"если вы имели ввиду модель %s, необходимо указать конкретное поле \"\n\t                              \"(%s__name_of_field)\" % (try_field, current_model, field))\n\t        if prefetch_condition and relation:\n", "            prefetch_related_fields.add(relation.strip('__'))\n\t        elif relation:\n\t            select_related_fields.add(relation.strip('__'))\n\t        # sizes__picture__name [] for size in product_obj.sizes.all(): print(size.name)\n\t        field_accessor_data = reverse_access_methods.pop() # {'field': try_field, 'method': Accessors.FIELD}\n\t        field_accessor = field_accessor_data['method'](field_accessor_data['field'])\n\t        for data in reverse_access_methods[::-1]:\n\t            field_accessor = data['method'](data['field'], field_accessor)\n\t        attributes[f\"get_{field}\"] = Accessors.GET_VALUES_LIST(field_accessor)\n\t    attributes[\"_prefetch_related\"] = prefetch_related_fields\n", "    attributes[\"_select_related\"] = select_related_fields\n\t    return attributes\n"]}
{"filename": "django_excel_report/writer/accessors.py", "chunked_list": ["from typing import Callable, Iterator, Generator\n\tfrom django.db.models import Model\n\tdef get_field(field: str) -> Callable:\n\t    def func(self, obj: Model, from_iterator=False):\n\t        if from_iterator:\n\t            return getattr(obj, field, \"\")\n\t        return [getattr(obj, field, \"\")]\n\t    return func\n\tdef get_m2m_generator(rel: str, other_func) -> Callable:\n\t    def func(self, obj: Model, from_iterator=False) -> Iterator[Callable | str]:\n", "        for m2m_obj in getattr(obj, rel).all():\n\t            yield other_func(self, m2m_obj, from_iterator=True)\n\t    return func\n\tdef get_foreign_field(field: str, other_func) -> Callable:\n\t    def func(self, obj: Model, from_iterator=False) -> Callable:\n\t        # if fk is null, get_field anyway returns empty string\n\t        return other_func(self, getattr(obj, field, \"\"), from_iterator)\n\t    return func\n\tdef get_values_list(func):\n\t    def wrapper(self, obj=None, result=None, recursive_call=False):\n", "        values_list = []\n\t        if obj:\n\t            result = func(self, obj)\n\t        if not isinstance(result, (list, Generator)):\n\t            if result is not None:\n\t                values_list.append(str(result))\n\t        else:\n\t            for entity in result:\n\t                if not isinstance(entity, (list, Generator)) and entity is not None:\n\t                    values_list.append(str(entity))\n", "                else:\n\t                    values_list.extend(wrapper(self, result=entity, recursive_call=True))\n\t        if recursive_call:\n\t            return values_list\n\t        return values_list or [\"\"]\n\t    return wrapper\n\tclass Accessors:\n\t    FIELD = get_field\n\t    M2M = get_m2m_generator\n\t    FK = get_foreign_field\n", "    GET_VALUES_LIST = get_values_list\n"]}
{"filename": "django_excel_report/writer/__init__.py", "chunked_list": ["from .report_meta import ReportMeta\n\tfrom .writer import Writer\n"]}
{"filename": "django_excel_report/writer/report_meta.py", "chunked_list": ["from .acessors_builder import get_report_attributes\n\tfrom ..error import ReportError\n\tclass ReportMeta(type):\n\t    def __new__(cls, name, bases, attrs: dict):\n\t        \"\"\"наша цель - принять в метаклассе заданные атрибуты (fields, related fields)\n\t        и на основании их построить класс Report, путём добавления в него нужных методов.\n\t        Обработка заданных параметров заключается в оптимизации запроса (prefetch_related, select_related) и\n\t        имплементации методов работы с каждым объектом queryset.\"\"\"\n\t        if not bases:\n\t            return super().__new__(cls, name, bases, attrs)\n", "        if attrs[\"model\"] is None:\n\t            raise ReportError(\"define model attr for %s class\" % name)\n\t        elif attrs[\"fields\"] is None:\n\t            raise ReportError(\"define report fields for %s class\" % name)\n\t        constructed_attrs = get_report_attributes(attrs[\"fields\"], attrs[\"model\"])\n\t        attrs.update(constructed_attrs)\n\t        return super().__new__(cls, name, bases, attrs)\n"]}
{"filename": "django_excel_report/writer/get_queryset_builder.py", "chunked_list": ["from typing import Iterable, Callable\n\tfrom django.db.models import QuerySet, Model\n\tdef get_queryset_builder(\n\t    select_related: Iterable[str], prefetch_related: Iterable[str], annotate_fields: dict\n\t) -> Callable:\n\t    def get_queryset(self) -> QuerySet[Model]:\n\t        return self.queryset\n\t    if select_related:\n\t        def select_related_decorator(func: Callable) -> Callable:\n\t            def wrapper(self) -> QuerySet[Model]:\n", "                return func(self).select_related(*select_related)\n\t            return wrapper\n\t        get_queryset = select_related_decorator(get_queryset)\n\t    if prefetch_related:\n\t        def prefetch_related_decorator(func: Callable) -> Callable:\n\t            def wrapper(self) -> QuerySet[Model]:\n\t                return func(self).prefetch_related(*prefetch_related)\n\t            return wrapper\n\t        get_queryset = prefetch_related_decorator(get_queryset)\n\t    if annotate_fields:\n", "        def annotate_decorator(func: Callable):\n\t            def wrapper(self) -> QuerySet[Model]:\n\t                return func(self).annotate(**annotate_fields)\n\t            return wrapper\n\t        get_queryset = annotate_decorator(get_queryset)\n\t    return get_queryset\n"]}
{"filename": "tests/test_get_values_list.py", "chunked_list": ["from django.test import TestCase\n\tfrom decimal import Decimal\n\timport datetime\n\tfrom django_excel_report.writer.accessors import get_values_list\n\tclass DefaultSettingsTests(TestCase):\n\t    @classmethod\n\t    def setUpTestData(cls):\n\t        def not_iterable1(*args): return \"s\"\n\t        def not_iterable2(*args): return 12\n\t        def not_iterable3(*args): return Decimal(\"12.1\")\n", "        def not_iterable4(*args, d=datetime.datetime.now()): return d\n\t        cls.not_iterable_funcs = [not_iterable1, not_iterable2, not_iterable3, not_iterable4]\n\t    def test_not_iterable(self):\n\t        for func in self.not_iterable_funcs:\n\t            self.assertListEqual(\n\t                get_values_list(func)(1, 1),\n\t                [func().__str__()]\n\t            )\n\t    def test_iterable(self):\n\t        def iterable1(*args): return [[\"2\", Decimal(\"1.2\")], 12, [], []]\n", "        self.assertListEqual(\n\t            get_values_list(iterable1)(1, 1),\n\t            [\"2\", \"1.2\", \"12\"]\n\t        )\n\t        def iterable2(*args): return [[\"2\", Decimal(\"1.2\")], 12, [\"\"], [\"\"]]\n\t        self.assertListEqual(\n\t            get_values_list(iterable2)(1, 1),\n\t            [\"2\", \"1.2\", \"12\", \"\", \"\"]\n\t        )\n\t        def iterable3(*args): return [[[[[[[]]]]]]]\n", "        self.assertListEqual(\n\t            get_values_list(iterable3)(1, 1),\n\t            [\"\"]\n\t        )\n\t        def iterable4(*args): return [None, [None, None]]\n\t        self.assertListEqual(\n\t            get_values_list(iterable4)(1, 1),\n\t            [\"\"]\n\t        )\n"]}
{"filename": "tests/settings.py", "chunked_list": ["DATABASES = {\n\t    \"default\": {\n\t        \"ENGINE\": \"django.db.backends.sqlite3\",\n\t        \"NAME\": \":memory:\"\n\t    },\n\t    'OPTIONS': {\n\t        'debug': True,\n\t    }\n\t}\n\tINSTALLED_APPS = (\n", "    'django_extensions',\n\t    \"tests\",\n\t)\n\tMIDDLEWARE = []\n\tUSE_TZ = True\n\tTIME_ZONE = \"UTC\"\n\tDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n\tLOGGING = {\n\t    'version': 1,\n\t    'handlers': {\n", "        'console': {\n\t            'class': 'logging.StreamHandler',\n\t        },\n\t    },\n\t    'loggers': {\n\t        'django': {\n\t            'level': 'DEBUG',\n\t        },\n\t        'django.db.backends': {\n\t            'handlers': ['console'],\n", "            'level': 'DEBUG'\n\t        },\n\t    },\n\t    'root': {\n\t        'handlers': ['console'],\n\t    }\n\t}\n"]}
{"filename": "tests/test_base_report_attributes.py", "chunked_list": ["from django.test import TestCase\n\tfrom .models import Product, Size, Pic\n\tfrom django_excel_report import BaseReport\n\tclass DefaultSettingsTests(TestCase):\n\t    @classmethod\n\t    def setUpTestData(cls):\n\t        p = Product.objects.create(name='p1', picture=Pic.objects.create(img='pic1'))\n\t        for i in range(5):\n\t            p.sizes.add(Size.objects.create(name=i))\n\t    @classmethod\n", "    def setUpClass(cls):\n\t        super().setUpClass()\n\t        class ReportClass(BaseReport):\n\t            model = Product\n\t            fields = ['name', 'sizes__name', 'sizes__picture__img', 'description__text']\n\t        cls.report_class = ReportClass\n\t        class EmptyRelatedClass(BaseReport):\n\t            model = Product\n\t            fields = ['name', 'pk']\n\t        cls.empty_related_class = EmptyRelatedClass\n", "    def test_has_prefetch_related(self):\n\t        self.assertIsNotNone(self.report_class._prefetch_related)\n\t        self.assertIsNotNone(self.report_class._select_related)\n\t    def test_has_empty_sets(self):\n\t        self.assertSetEqual(self.empty_related_class._prefetch_related, set())\n\t        self.assertSetEqual(self.empty_related_class._select_related, set())\n\t    def test_has_accessor_methods(self):\n\t        self.assertIsNotNone(getattr(self.report_class, 'get_name', None))\n\t        self.assertIsNotNone(getattr(self.report_class, 'get_sizes__name', None))\n\t        self.assertIsNotNone(getattr(self.report_class, 'get_sizes__picture__img', None))\n", "        self.assertIsNotNone(getattr(self.report_class, 'get_description__text', None))\n\t        self.assertIsNotNone(getattr(self.empty_related_class, 'get_name', None))\n\t        self.assertIsNotNone(getattr(self.empty_related_class, 'get_pk', None))\n\t    def test_metaclass_raises_error(self):\n\t        def attribute_error_raiser():\n\t            class BadReport(BaseReport):\n\t                model = Product\n\t                fields = ['sizes__asd']\n\t        self.assertRaises(\n\t            AttributeError,\n", "            attribute_error_raiser\n\t        )\n"]}
{"filename": "tests/models.py", "chunked_list": ["from django.db import models\n\tclass Pic(models.Model):\n\t    img = models.TextField()\n\tclass Size(models.Model):\n\t    name = models.TextField()\n\t    picture = models.ForeignKey(Pic, models.DO_NOTHING, null=True)\n\tclass Product(models.Model):\n\t    name = models.TextField()\n\t    sizes = models.ManyToManyField(Size)\n\t    picture = models.ForeignKey(Pic, models.DO_NOTHING)\n", "class Description(models.Model):\n\t    text = models.TextField()\n\t    product = models.OneToOneField(Product, models.CASCADE)\n\tclass FileModel(models.Model):\n\t    file = models.FileField(upload_to='test_files/')"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_report_get_row.py", "chunked_list": ["from django.test import TestCase\n\tfrom django_excel_report import BaseReport\n\tfrom .models import Product, Size, Pic\n\tclass DefaultSettingsTests(TestCase):\n\t    @classmethod\n\t    def setUpTestData(cls):\n\t        cls.product = p = Product.objects.create(name='p1', picture=Pic.objects.create(img='pic1'))\n\t        p.sizes.add(Size.objects.create(name='nopic'))\n\t        p.sizes.add(Size.objects.create(name='pic', picture=Pic.objects.create(img='1')))\n\t        class TestReport(BaseReport):\n", "            model = Product\n\t            fields = ['name', 'picture__img', 'sizes__name', 'sizes__picture__img']\n\t        cls.report_class = TestReport(Product.objects.all())\n\t    def test_find_related_fields(self):\n\t        row = self.report_class._get_row(self.product)\n\t        self.assertListEqual(\n\t            row,\n\t            [['p1'], ['pic1'], ['nopic', 'pic'], ['', '1']]\n\t        )\n"]}
{"filename": "tests/test_related_processors.py", "chunked_list": ["from django.test import TestCase\n\tfrom .models import Product, Size, Pic\n\tfrom django_excel_report.writer.acessors_builder import get_report_attributes\n\tfrom django_excel_report.error import ReportError\n\tclass DefaultSettingsTests(TestCase):\n\t    @classmethod\n\t    def setUpTestData(cls):\n\t        p = Product.objects.create(name='p1', picture=Pic.objects.create(img='pic1'))\n\t        for i in range(5):\n\t            p.sizes.add(Size.objects.create(name=i))\n", "    def test_find_related_fields(self):\n\t        attributes = get_report_attributes(\n\t            ['name', 'sizes__name', 'sizes__picture__img', 'description__text'], Product\n\t        )\n\t        self.assertSetEqual(\n\t            attributes[\"_prefetch_related\"], {'sizes', 'sizes__picture'}\n\t        )\n\t        self.assertSetEqual(\n\t            attributes[\"_select_related\"], {'description'}\n\t        )\n", "    def test_raises_error(self):\n\t        self.assertRaises(\n\t            ReportError,\n\t            get_report_attributes,\n\t            ['sizes'], Product\n\t        )\n\t        self.assertRaises(\n\t            ReportError,\n\t            get_report_attributes,\n\t            ['sizes__picture'], Product\n", "        )\n\t        self.assertRaises(\n\t            ReportError,\n\t            get_report_attributes,\n\t            ['description'], Product\n\t        )\n"]}
{"filename": "tests/migrations/0001_initial.py", "chunked_list": ["# Generated by Django 4.1.1 on 2023-04-13 09:42\n\tfrom django.db import migrations, models\n\timport django.db.models.deletion\n\tclass Migration(migrations.Migration):\n\t    initial = True\n\t    dependencies = [\n\t    ]\n\t    operations = [\n\t        migrations.CreateModel(\n\t            name='Pic',\n", "            fields=[\n\t                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n\t                ('img', models.TextField()),\n\t            ],\n\t        ),\n\t        migrations.CreateModel(\n\t            name='Size',\n\t            fields=[\n\t                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n\t                ('name', models.TextField()),\n", "                ('picture', models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='tests.pic')),\n\t            ],\n\t        ),\n\t        migrations.CreateModel(\n\t            name='Product',\n\t            fields=[\n\t                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n\t                ('name', models.TextField()),\n\t                ('picture', models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, to='tests.pic')),\n\t                ('sizes', models.ManyToManyField(to='tests.size')),\n", "            ],\n\t        ),\n\t        migrations.CreateModel(\n\t            name='Description',\n\t            fields=[\n\t                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n\t                ('text', models.TextField()),\n\t                ('product', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='tests.product')),\n\t            ],\n\t        ),\n", "    ]\n"]}
{"filename": "tests/migrations/__init__.py", "chunked_list": []}
{"filename": "tests/migrations/0002_filemodel.py", "chunked_list": ["# Generated by Django 4.1.1 on 2023-04-17 12:42\n\tfrom django.db import migrations, models\n\tclass Migration(migrations.Migration):\n\t    dependencies = [\n\t        ('tests', '0001_initial'),\n\t    ]\n\t    operations = [\n\t        migrations.CreateModel(\n\t            name='FileModel',\n\t            fields=[\n", "                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n\t                ('file', models.FileField(upload_to='test_files/')),\n\t            ],\n\t        ),\n\t    ]\n"]}
