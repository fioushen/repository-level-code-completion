{"filename": "Home.py", "chunked_list": ["from gptravel.prototype.pages import home as home_page\n\timport streamlit as st\n\tst.set_page_config(page_title=\"GPTravel\", page_icon=\"✈️\")\n\tif __name__ == \"__main__\":\n\t    home_page.main()"]}
{"filename": "prototype.py", "chunked_list": ["from gptravel.prototype.pages import home as home_page\n\timport streamlit as st\n\tst.set_page_config(page_title=\"GPTravel\", page_icon=\"✈️\")\n\tif __name__ == \"__main__\":\n\t    home_page.main()"]}
{"filename": "pages/About.py", "chunked_list": ["import streamlit as st\n\tst.set_page_config(page_title=\"GPTravel\", page_icon=\"✈️\")\n\tst.title(\"About\")\n\tst.markdown(\"\"\"\n\tGPTravel is a Web App that generates a travel plan based on Large-Language Models (LLMs). It helps users create personalized itineraries giving the best destinations, activities, and routes.\n\tThis is a simple web app that uses the power of Large Language Models to help you plan your next trip. By leveraging the GPT API, the app generates a personalized itinerary for your trip based on your destination.\n\tTo use the app, simply fill out the form on the Home page with your travel details and let GPT do the rest. You'll receive a customized travel plan that includes recommended destinations, activities, accommodations, and other useful information.\n\tWhether you're an experienced traveler or just looking for some inspiration, this app is a fun and easy way to explore new places and ideas. So why not give it a try and see where your next journey takes you?\n\t### Code Repository\n\tThe code for this web app is available on GitHub. You can find it [here](https://github.com/RobertoCorti/gptravel). Feel free to explore the code, contribute, and provide feedback.\n", "### Authors\n\t- Roberto Corti [![LinkedIn](https://img.shields.io/badge/LinkedIn-Connect-blue?logo=linkedin)](https://www.linkedin.com/in/roberto-corti-723346181/) [![GitHub](https://img.shields.io/badge/GitHub-Follow-black?logo=github)](https://github.com/robertocorti)\n\t- Stefano Polo [![LinkedIn](https://img.shields.io/badge/LinkedIn-Connect-blue?logo=linkedin)](https://www.linkedin.com/in/stefanopolo) [![GitHub](https://img.shields.io/badge/GitHub-Follow-black?logo=github)](https://github.com/stefano-polo)\n\t\"\"\", unsafe_allow_html=True)\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["from typing import Any, Dict, List\n\timport pytest\n\tfrom gptravel.core.travel_planner.prompt import PromptFactory\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\t@pytest.fixture\n\tdef travel_plan_single_city_per_day() -> TravelPlanJSON:\n\t    json_travel_plan = TravelPlanJSON(\n\t        destination_place=\"Thailand\",\n\t        departure_place=\"Milan\",\n\t        n_days=3,\n", "        json_keys_depth_map={\"day\": 0, \"city\": 1},\n\t        travel_plan_json={\n\t            \"Day 1\": {\n\t                \"Bangkok\": [\n\t                    \"Visit Wat Phra Kaew and the Grand Palace\",\n\t                    \"Explore the Wat Pho Temple\",\n\t                    \"Ride a boat in the Chao Phraya River\",\n\t                    \"Shop at Chatuchak weekend market\",\n\t                ]\n\t            },\n", "            \"Day 2\": {\n\t                \"Phuket\": [\n\t                    \"Spend time at the Patong Beach\",\n\t                    \"Visit Big Buddha Phuket\",\n\t                    \"Explore the Phuket Old Town\",\n\t                    \"Enjoy local street food at night markets\",\n\t                ]\n\t            },\n\t            \"Day 3\": {\n\t                \"Krabi\": [\n", "                    \"Visit Railay Beach and the Phra Nang Cave\",\n\t                    \"Island hopping tour to Phi Phi Islands\",\n\t                    \"Hike to the Tiger Cave Temple\",\n\t                    \"Relax at Ao Nang Beach\",\n\t                ]\n\t            },\n\t        },\n\t    )\n\t    return json_travel_plan\n\t@pytest.fixture\n", "def travel_plan_multiple_city_per_day_and_wrong_n_days() -> TravelPlanJSON:\n\t    json_travel_plan = TravelPlanJSON(\n\t        departure_place=\"Milan\",\n\t        destination_place=\"Thailand\",\n\t        n_days=3,\n\t        json_keys_depth_map={\"day\": 0, \"city\": 1},\n\t        travel_plan_json={\n\t            \"Day 1\": {\n\t                \"Bangkok\": [\n\t                    \"Visit Wat Phra Kaew and the Grand Palace\",\n", "                    \"Explore the Wat Pho Temple\",\n\t                    \"Ride a boat in the Chao Phraya River\",\n\t                    \"Shop at Chatuchak weekend market\",\n\t                ],\n\t                \"Phuket\": [\n\t                    \"Spend time at the Patong Beach\",\n\t                    \"Visit Big Buddha Phuket\",\n\t                    \"Explore the Phuket Old Town\",\n\t                    \"Enjoy local street food at night markets\",\n\t                ],\n", "            },\n\t            \"Day 2\": {\n\t                \"Krabi\": [\n\t                    \"Visit Railay Beach and the Phra Nang Cave\",\n\t                    \"Island hopping tour to Phi Phi Islands\",\n\t                    \"Hike to the Tiger Cave Temple\",\n\t                    \"Relax at Ao Nang Beach\",\n\t                ]\n\t            },\n\t        },\n", "    )\n\t    return json_travel_plan\n\t@pytest.fixture\n\tdef travel_plan_multiple_city_per_day_and_wrong_city_per_country() -> TravelPlanJSON:\n\t    json_travel_plan = TravelPlanJSON(\n\t        departure_place=\"Milan\",\n\t        destination_place=\"Thailand\",\n\t        n_days=2,\n\t        json_keys_depth_map={\"day\": 0, \"city\": 1},\n\t        travel_plan_json={\n", "            \"Day 1\": {\n\t                \"Bangkok\": [\n\t                    \"Visit Wat Phra Kaew and the Grand Palace\",\n\t                    \"Explore the Wat Pho Temple\",\n\t                    \"Ride a boat in the Chao Phraya River\",\n\t                    \"Shop at Chatuchak weekend market\",\n\t                ],\n\t                \"Milan\": [\n\t                    \"Spend time at the Patong Beach\",\n\t                    \"Visit Big Buddha Phuket\",\n", "                    \"Explore the Phuket Old Town\",\n\t                    \"Enjoy local street food at night markets\",\n\t                ],\n\t            },\n\t            \"Day 2\": {\n\t                \"Krabi\": [\n\t                    \"Visit Railay Beach and the Phra Nang Cave\",\n\t                    \"Island hopping tour to Phi Phi Islands\",\n\t                    \"Hike to the Tiger Cave Temple\",\n\t                    \"Relax at Ao Nang Beach\",\n", "                ]\n\t            },\n\t        },\n\t    )\n\t    return json_travel_plan\n\t@pytest.fixture\n\tdef travel_plan_fake_city() -> TravelPlanJSON:\n\t    json_travel_plan = TravelPlanJSON(\n\t        departure_place=\"Milan\",\n\t        destination_place=\"Thailand\",\n", "        n_days=2,\n\t        json_keys_depth_map={\"day\": 0, \"city\": 1},\n\t        travel_plan_json={\n\t            \"Day 1\": {\n\t                \"Bangkok\": [\n\t                    \"Visit Wat Phra Kaew and the Grand Palace\",\n\t                    \"Explore the Wat Pho Temple\",\n\t                    \"Ride a boat in the Chao Phraya River\",\n\t                    \"Shop at Chatuchak weekend market\",\n\t                ],\n", "                \"ChromeCastFrancesco\": [\n\t                    \"Spend time at the Patong Beach\",\n\t                    \"Visit Big Buddha Phuket\",\n\t                    \"Explore the Phuket Old Town\",\n\t                    \"Enjoy local street food at night markets\",\n\t                ],\n\t            },\n\t            \"Day 2\": {\n\t                \"Krabi\": [\n\t                    \"Visit Railay Beach and the Phra Nang Cave\",\n", "                    \"Island hopping tour to Phi Phi Islands\",\n\t                    \"Hike to the Tiger Cave Temple\",\n\t                    \"Relax at Ao Nang Beach\",\n\t                ]\n\t            },\n\t        },\n\t    )\n\t    return json_travel_plan\n\t@pytest.fixture\n\tdef italian_travel_plan() -> TravelPlanJSON:\n", "    return TravelPlanJSON(\n\t        destination_place=\"Italy\",\n\t        departure_place=\"Paris\",\n\t        n_days=4,\n\t        travel_plan_json={\n\t            \"Day 1\": {\n\t                \"Paris\": [\n\t                    \"Take flight to Venice\",\n\t                ]\n\t            },\n", "            \"Day 2\": {\n\t                \"Venice\": [\n\t                    \"See San Marco\",\n\t                ]\n\t            },\n\t            \"Day 3\": {\n\t                \"Venice\": [\n\t                    \"Take a ride on gondola\",\n\t                ],\n\t                \"Palermo\": [\"Eat an arancina\"],\n", "            },\n\t            \"Day 4\": {\"Florence\": [\"Eat fiorentina\"], \"Paris\": [\"Return back home\"]},\n\t        },\n\t        json_keys_depth_map={\"city\": 1, \"day\": 0},\n\t    )\n\t@pytest.fixture\n\tdef travel_properties() -> Dict[str, Any]:\n\t    return {\n\t        \"departure_place\": \"Milan\",\n\t        \"destination_place\": \"Thailand\",\n", "        \"n_travel_days\": 10,\n\t    }\n\t@pytest.fixture\n\tdef prompt_factory() -> PromptFactory:\n\t    return PromptFactory()\n\t@pytest.fixture()\n\tdef labels_activities() -> List[str]:\n\t    return [\n\t        \"mountain\",\n\t        \"sea\",\n", "        \"museum\",\n\t        \"monument\",\n\t        \"food\",\n\t        \"relax\",\n\t        \"sport\",\n\t        \"culture\",\n\t        \"shopping\",\n\t        \"transport\",\n\t    ]\n"]}
{"filename": "tests/test_gptravel/test_app_streamlit/test_pages/test_home.py", "chunked_list": ["import datetime\n\timport os\n\timport dotenv\n\timport pytest\n\tfrom gptravel.prototype.pages import home\n\tdotenv.load_dotenv()\n\t@pytest.fixture\n\tdef departure_date():\n\t    return datetime.datetime(2023, 6, 15)\n\t@pytest.fixture\n", "def return_date():\n\t    return datetime.datetime(2023, 6, 20)\n\t@pytest.fixture\n\tdef openai_key():\n\t    return os.environ.get(\"OPENAI_API_KEY\")\n\t@pytest.fixture\n\tdef departure_place():\n\t    return \"Milan\"\n\t@pytest.fixture\n\tdef destination_place():\n", "    return \"New York\"\n\t@pytest.mark.parametrize(\n\t    \"departure, destination\",\n\t    [\n\t        (\"Milan\", \"India\"),\n\t        (\"New York\", \"Italy\"),\n\t        (\"Japan\", \"United States\"),\n\t    ],\n\t)\n\tdef test_is_valid_input_correct(\n", "    departure, destination, departure_date, return_date, openai_key\n\t):\n\t    assert home._is_valid_input(\n\t        departure=departure,\n\t        destination=destination,\n\t        departure_date=departure_date,\n\t        return_date=return_date,\n\t        openai_key=openai_key,\n\t    )\n\tdef test_is_valid_input_wrong_dates(departure_place, destination_place, openai_key):\n", "    departure_date = datetime.date(2023, 1, 1)\n\t    return_date = datetime.date(2022, 11, 1)\n\t    assert not home._is_valid_input(\n\t        departure=departure_place,\n\t        destination=destination_place,\n\t        departure_date=departure_date,\n\t        return_date=return_date,\n\t        openai_key=openai_key,\n\t    )\n\t@pytest.mark.parametrize(\n", "    \"departure, destination\",\n\t    [\n\t        (\"Milan\", \"Pippo\"),\n\t        (\"New York\", \"Pluto\"),\n\t    ],\n\t)\n\tdef test_is_valid_input_wrong_places(\n\t    departure, destination, departure_date, return_date, openai_key\n\t):\n\t    assert not home._is_valid_input(\n", "        departure=departure,\n\t        destination=destination,\n\t        departure_date=departure_date,\n\t        return_date=return_date,\n\t        openai_key=openai_key,\n\t    )\n\tdef test_is_valid_input_wrong_openai_key(\n\t    departure_place, destination_place, departure_date, return_date, openai_key\n\t):\n\t    assert not home._is_valid_input(\n", "        departure=departure_place,\n\t        destination=destination_place,\n\t        departure_date=departure_date,\n\t        return_date=return_date,\n\t        openai_key=\"a\",\n\t    )\n"]}
{"filename": "tests/test_gptravel/test_app_streamlit/test_utils/test_general_streamlit_utils.py", "chunked_list": ["import datetime\n\timport os\n\tfrom typing import List\n\timport openai\n\timport pytest\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tfrom gptravel.prototype.utils import (\n\t    get_cities_coordinates_of_same_country_destionation,\n\t    get_score_map,\n\t    is_departure_before_return,\n", "    is_valid_openai_key,\n\t)\n\tdef test_is_valid_openai_key():\n\t    from dotenv import load_dotenv\n\t    load_dotenv()\n\t    valid_key = os.environ.get(\"OPENAI_API_KEY\")\n\t    invalid_key = \"pippo\"\n\t    openai.api_key = valid_key\n\t    assert is_valid_openai_key(valid_key) == True\n\t    openai.api_key = invalid_key\n", "    assert is_valid_openai_key(invalid_key) == False\n\t@pytest.mark.parametrize(\n\t    \"departure_date, return_date, expected_result\",\n\t    [\n\t        (datetime.date(2023, 6, 1), datetime.date(2023, 6, 2), True),\n\t        (datetime.date(2023, 6, 3), datetime.date(2023, 6, 2), False),\n\t        (datetime.date(2023, 6, 2), datetime.date(2023, 6, 2), True),\n\t        (datetime.date(2023, 5, 31), datetime.date(2023, 6, 2), True),\n\t    ],\n\t)\n", "def test_is_departure_before_return(departure_date, return_date, expected_result):\n\t    assert is_departure_before_return(departure_date, return_date) == expected_result\n\t@pytest.mark.parametrize(\n\t    \"cities, destination, expected_coordinates\",\n\t    [\n\t        (\n\t            [\"New York\", \"Los Angeles\"],\n\t            \"United States\",\n\t            {\n\t                \"New York\": (40.7127281, -74.0060152),\n", "                \"Los Angeles\": (34.0536909, -118.242766),\n\t            },\n\t        ),\n\t        (\n\t            [\"London\"],\n\t            \"London\",\n\t            {\n\t                \"London\": (51.5073359, -0.12765),\n\t            },\n\t        ),\n", "        (\n\t            [\"London\", \"Manchester\"],\n\t            \"United Kingdom\",\n\t            {\"London\": (51.5073359, -0.12765), \"Manchester\": (53.4794892, -2.2451148)},\n\t        ),\n\t        ([\"Paris\", \"Rome\"], \"France\", {\"Paris\": (48.8588897, 2.3200410217200766)}),\n\t    ],\n\t)\n\tdef test_get_cities_coordinates(cities, destination, expected_coordinates):\n\t    coordinates_cities_dict = get_cities_coordinates_of_same_country_destionation(\n", "        cities, destination\n\t    )\n\t    for city, coordinates in coordinates_cities_dict.items():\n\t        assert coordinates[0] == pytest.approx(expected_coordinates[city][0], abs=0.1)\n\t        assert coordinates[1] == pytest.approx(expected_coordinates[city][1], abs=0.1)\n\tdef test_get_score_map_on_travel_plan(\n\t    travel_plan_single_city_per_day: TravelPlanJSON, labels_activities: List[str]\n\t):\n\t    score_map = get_score_map(travel_plan_single_city_per_day).score_map\n\t    assert isinstance(score_map, dict)\n", "    assert \"Activities Variety\" in set(score_map.keys())\n\t    assert set(score_map[\"Activities Variety\"].keys()) == {\n\t        \"score_value\",\n\t        \"score_weight\",\n\t        \"activities_distribution\",\n\t        \"labeled_activities\",\n\t    }\n\t    assert isinstance(score_map[\"Activities Variety\"][\"score_value\"], float)\n\t    assert 0 <= score_map[\"Activities Variety\"][\"score_value\"] <= 1\n\t    assert isinstance(score_map[\"Activities Variety\"][\"score_weight\"], float)\n", "    assert 0 <= score_map[\"Activities Variety\"][\"score_weight\"] <= 1\n\t    assert isinstance(score_map[\"Activities Variety\"][\"activities_distribution\"], dict)\n\t    assert set(\n\t        score_map[\"Activities Variety\"][\"activities_distribution\"].keys()\n\t    ) == set(labels_activities)\n\t    for key in score_map[\"Activities Variety\"][\"activities_distribution\"].keys():\n\t        assert isinstance(\n\t            score_map[\"Activities Variety\"][\"activities_distribution\"][key], float\n\t        )\n\t        assert 0 <= score_map[\"Activities Variety\"][\"activities_distribution\"][key] <= 1\n", "    assert isinstance(score_map[\"Activities Variety\"][\"labeled_activities\"], dict)\n\t    assert set(score_map[\"Activities Variety\"][\"labeled_activities\"].keys()) == set(\n\t        travel_plan_single_city_per_day.travel_activities\n\t    )\n\t    for key in score_map[\"Activities Variety\"][\"labeled_activities\"].keys():\n\t        assert isinstance(\n\t            score_map[\"Activities Variety\"][\"labeled_activities\"][key], dict\n\t        )\n\t        assert set(\n\t            score_map[\"Activities Variety\"][\"labeled_activities\"][key].keys()\n", "        ) == set(labels_activities)\n\t        assert all(\n\t            isinstance(\n\t                score_map[\"Activities Variety\"][\"labeled_activities\"][key][label], float\n\t            )\n\t            for label in labels_activities\n\t        )\n\t        assert all(\n\t            0 <= score_map[\"Activities Variety\"][\"labeled_activities\"][key][label] <= 1\n\t            for label in labels_activities\n", "        )\n"]}
{"filename": "tests/test_gptravel/test_core/test_utils/test_regex_tool.py", "chunked_list": ["import json\n\tfrom inspect import cleandoc\n\tfrom gptravel.core.utils.regex_tool import JsonExtractor\n\tclass TestJsonExtractor:\n\t    def test_simple_json(self, extractor: JsonExtractor):\n\t        text = '{\"name\": \"John\", \"age\": 30}'\n\t        expected_output = [text]\n\t        assert json.loads(extractor(text)[0]) == json.loads(expected_output[0])\n\t    def test_nested_json(self, extractor):\n\t        text = '{\"name\": \"John\", \"age\": 30, \"address\": {\"street\": \"123 Main St\", \"city\": \"Anytown USA\"}}'\n", "        expected_output = [text, '{\"street\": \"123 Main St\", \"city\": \"Anytown USA\"}']\n\t        assert json.loads(extractor(text)[0]) == json.loads(expected_output[0])\n\t    def test_no_json(self, extractor):\n\t        text = \"This is not a JSON string\"\n\t        expected_output = []\n\t        assert extractor(text) == expected_output\n\t    def test_output_gpt(self, extractor):\n\t        text_gpt = cleandoc(\n\t            \"\"\"Sure! Here a json\n\t                      {\n", "                        \"Day 1\": {\n\t                            \"Bangkok\": [\n\t                            \"Visit Grand Palace\",\n\t                            \"Take a boat trip along the Chao Phraya River\",\n\t                            \"Shop at Chatuchak Weekend Market\"\n\t                            ]\n\t                        },\n\t                        \"Day 2\": {\n\t                            \"Chiang Mai\": [\n\t                            \"Explore Doi Suthep temple\",\n", "                            \"Experience the traditional Thai massage\",\n\t                            \"Visit Elephant Nature Park\"\n\t                            ]\n\t                        },\n\t                        \"Day 3\": {\n\t                            \"Phuket\": [\n\t                            \"Relax on the beautiful beaches of Phuket\",\n\t                            \"Take a speedboat cruise to visit Koh Phi Phi\",\n\t                            \"Watch the sunset at Promthep Cape\"\n\t                            ]\n", "                        }\n\t                        }\n\t                        Note: Keep in mind that this is just a sample travel plan and activities can be customized according to individual preferences.\"\"\"\n\t        )\n\t        expected_output = '{\\n\"Day 1\": {\\n    \"Bangkok\": [\\n    \"Visit Grand Palace\",\\n    \"Take a boat trip along the Chao Phraya River\",\\n    \"Shop at Chatuchak Weekend Market\"\\n    ]\\n},\\n\"Day 2\": {\\n    \"Chiang Mai\": [\\n    \"Explore Doi Suthep temple\",\\n    \"Experience the traditional Thai massage\",\\n    \"Visit Elephant Nature Park\"\\n    ]\\n},\\n\"Day 3\": {\\n    \"Phuket\": [\\n    \"Relax on the beautiful beaches of Phuket\",\\n    \"Take a speedboat cruise to visit Koh Phi Phi\",\\n    \"Watch the sunset at Promthep Cape\"\\n    ]\\n}\\n}'\n\t        assert json.loads(extractor(text_gpt)[0]) == json.loads(expected_output)\n"]}
{"filename": "tests/test_gptravel/test_core/test_utils/test_general.py", "chunked_list": ["import json\n\tfrom gptravel.core.utils.general import (\n\t    extract_inner_lists_from_json,\n\t    extract_keys_by_depth_from_json,\n\t)\n\tdef test_extract_keys_by_depth():\n\t    json_str = '{\"a\": {\"b\": {\"c\": 1, \"d\": 2}, \"e\": 3}, \"f\": {\"g\": {\"h\": {\"i\": 4}}}}'\n\t    json_obj = json.loads(json_str)\n\t    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\", \"f\"]\n\t    assert extract_keys_by_depth_from_json(json_obj, 1) == [\"b\", \"e\", \"g\"]\n", "    assert extract_keys_by_depth_from_json(json_obj, 2) == [\"c\", \"d\", \"h\"]\n\t    assert extract_keys_by_depth_from_json(json_obj, 3) == [\"i\"]\n\t    json_str = '{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": 1}}}}}}}'\n\t    json_obj = json.loads(json_str)\n\t    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\"]\n\t    assert extract_keys_by_depth_from_json(json_obj, 1) == [\"b\"]\n\t    assert extract_keys_by_depth_from_json(json_obj, 2) == [\"c\"]\n\t    assert extract_keys_by_depth_from_json(json_obj, 3) == [\"d\"]\n\t    assert extract_keys_by_depth_from_json(json_obj, 4) == [\"e\"]\n\t    assert extract_keys_by_depth_from_json(json_obj, 5) == [\"f\"]\n", "    assert extract_keys_by_depth_from_json(json_obj, 6) == [\"g\"]\n\t    json_str = '{\"a\": 1, \"b\": 2, \"c\": 3}'\n\t    json_obj = json.loads(json_str)\n\t    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\", \"b\", \"c\"]\n\t    assert not extract_keys_by_depth_from_json(json_obj, 1)\n\tdef test_extract_inner_lists_from_json():\n\t    # Simple example with only one level of nesting\n\t    data = {\n\t        \"Day 1\": {\n\t            \"City 1\": [\"activity 1\", \"activity 2\"],\n", "            \"City 2\": [\"activity 3\", \"activity 4\"],\n\t        }\n\t    }\n\t    assert extract_inner_lists_from_json(data) == [\n\t        \"activity 1\",\n\t        \"activity 2\",\n\t        \"activity 3\",\n\t        \"activity 4\",\n\t    ]\n\tdef test_extract_inner_lists_more_depth():\n", "    # Simple example with only one level of nesting\n\t    data = {\n\t        \"Day 1\": {\n\t            \"City 1\": {\"feet\": [\"activity 1\", \"activity 2\"]},\n\t            \"City 2\": {\"moto\": [\"activity 3\", \"activity 4\"]},\n\t        },\n\t        \"Day 2\": {\n\t            \"City 1\": {\"car\": [\"activity 5\", \"activity 6\"]},\n\t            \"City 2\": {\"boat\": [\"activity 7\", \"activity 8\"]},\n\t        },\n", "    }\n\t    assert extract_inner_lists_from_json(data) == [\n\t        \"activity 1\",\n\t        \"activity 2\",\n\t        \"activity 3\",\n\t        \"activity 4\",\n\t        \"activity 5\",\n\t        \"activity 6\",\n\t        \"activity 7\",\n\t        \"activity 8\",\n", "    ]\n\tdef test_extract_inner_list_nested():\n\t    # Example with nested dictionaries and lists\n\t    data = {\n\t        \"Day 1\": {\n\t            \"City 1\": [\"activity 1\", \"activity 2\"],\n\t            \"City 2\": [\"activity 3\", \"activity 4\"],\n\t        },\n\t        \"Day 2\": {\n\t            \"City 3\": [\"activity 5\", \"activity 6\"],\n", "            \"City 4\": [\n\t                {\"Subcity 1\": [\"activity 7\", \"activity 8\"]},\n\t                {\"Subcity 2\": [\"activity 9\", \"activity 10\"]},\n\t            ],\n\t        },\n\t    }\n\t    assert extract_inner_lists_from_json(data) == [\n\t        \"activity 1\",\n\t        \"activity 2\",\n\t        \"activity 3\",\n", "        \"activity 4\",\n\t        \"activity 5\",\n\t        \"activity 6\",\n\t        {\"Subcity 1\": [\"activity 7\", \"activity 8\"]},\n\t        {\"Subcity 2\": [\"activity 9\", \"activity 10\"]},\n\t    ]\n\tdef test_extract_inner_list_empty():\n\t    # Example with empty data\n\t    data = {}\n\t    assert not extract_inner_lists_from_json(data)\n", "def test_extract_inner_list_wrong_input():\n\t    # Example with wrong input type\n\t    data = \"wrong input type\"\n\t    assert not extract_inner_lists_from_json(data)\n"]}
{"filename": "tests/test_gptravel/test_core/test_utils/conftest.py", "chunked_list": ["import pytest\n\tfrom gptravel.core.utils.regex_tool import JsonExtractor\n\t@pytest.fixture\n\tdef extractor() -> JsonExtractor:\n\t    return JsonExtractor()\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_geocoder.py", "chunked_list": ["import pytest\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tclass TestGeoCoder:\n\t    def test_country_from_location_name(self, geo_coder: GeoCoder):\n\t        assert geo_coder.country_from_location_name(\"Paris, France\") == \"France\"\n\t        assert geo_coder.country_from_location_name(\"London, UK\") == \"United Kingdom\"\n\t        assert (\n\t            geo_coder.country_from_location_name(\"Los Angeles, US\") == \"United States\"\n\t        )\n\t        assert geo_coder.country_from_location_name(\"Mumbai, India\") == \"India\"\n", "        assert geo_coder.country_from_location_name(\"PortaSigrar\") is None\n\t    def test_location_coordinates(self, geo_coder: GeoCoder):\n\t        assert geo_coder.location_coordinates(\"kolkata\") == {\n\t            \"lat\": 22.5726459,\n\t            \"lon\": 88.3638953,\n\t        }\n\t        output = geo_coder.location_coordinates(\"delhi\")\n\t        assert output[\"lat\"] == pytest.approx(28.6, 0.1)\n\t        assert output[\"lon\"] == pytest.approx(77.2, 0.1)\n\t        assert geo_coder.location_coordinates(\"PortaSigrar\") == {\n", "            \"lat\": None,\n\t            \"lon\": None,\n\t        }\n\t    def test_location_distance(self, geo_coder: GeoCoder):\n\t        assert geo_coder.location_distance(\"kolkata\", \"delhi\") == pytest.approx(\n\t            1305.106, 0.001\n\t        )\n\t        assert geo_coder.location_distance(\"delhi\", \"delhi\") == pytest.approx(\n\t            0.0, 0.001\n\t        )\n", "    @pytest.mark.parametrize(\n\t        \"location_name, expected_result\",\n\t        [\n\t            (\"United States\", True),\n\t            (\"California\", True),\n\t            (\"New York\", True),\n\t            (\"Italy\", True),\n\t            (\"Rome\", True),\n\t            (\"Berlin\", True),\n\t            (\"Milan\", True),\n", "            (\"Pippo\", False),\n\t        ],\n\t    )\n\t    def test_is_location_country_city_state(\n\t        self, geo_coder, location_name, expected_result\n\t    ):\n\t        assert (\n\t            geo_coder.is_location_country_city_state(location_name) == expected_result\n\t        )\n\t    @pytest.mark.parametrize(\n", "        \"location_name, expected_result\",\n\t        [\n\t            (\"United States\", True),\n\t            (\"California\", True),\n\t            (\"New York\", False),\n\t            (\"Italy\", True),\n\t            (\"Rome\", False),\n\t            (\"Berlin\", False),\n\t            (\"Milan\", False),\n\t            (\"Pippo\", False),\n", "        ],\n\t    )\n\t    def test_is_location_country(self, geo_coder, location_name, expected_result):\n\t        assert geo_coder.is_a_country(location_name) == expected_result\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_checker.py", "chunked_list": ["import os\n\timport pytest\n\tfrom gptravel.core.services.checker import DaysChecker, ExistingDestinationsChecker\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\t@pytest.fixture\n\tdef existing_cities_checker(geo_coder: GeoCoder) -> ExistingDestinationsChecker:\n\t    return ExistingDestinationsChecker(geo_coder)\n\t@pytest.fixture\n\tdef days_checker() -> DaysChecker:\n", "    return DaysChecker()\n\tuat_test = pytest.mark.skipif(\n\t    os.getenv(\"ENV\", \"UAT\") == \"PROD\",\n\t    reason=\"Only run in UAT environment\",\n\t)\n\tclass TestExistinCityChecker:\n\t    def test_existing_destinations(\n\t        self,\n\t        existing_cities_checker: ExistingDestinationsChecker,\n\t        travel_plan_single_city_per_day: TravelPlanJSON,\n", "    ) -> None:\n\t        assert existing_cities_checker.check(travel_plan_single_city_per_day)\n\t    def test_not_existing_destinations(\n\t        self,\n\t        existing_cities_checker: ExistingDestinationsChecker,\n\t        travel_plan_fake_city: TravelPlanJSON,\n\t    ) -> None:\n\t        assert existing_cities_checker.check(travel_plan_fake_city) is False\n\tclass TestDaysChecker:\n\t    def test_correct_number_of_days(\n", "        self, days_checker: DaysChecker, travel_plan_single_city_per_day: TravelPlanJSON\n\t    ) -> None:\n\t        assert days_checker.check(travel_plan_single_city_per_day)\n\t        assert days_checker.travel_days == travel_plan_single_city_per_day.n_days\n\t    def test_no_same_number_of_days(\n\t        self,\n\t        days_checker: DaysChecker,\n\t        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n\t    ) -> None:\n\t        assert not days_checker.check(\n", "            travel_plan_multiple_city_per_day_and_wrong_n_days\n\t        )\n\t        assert days_checker.travel_days == 2\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_filters.py", "chunked_list": ["from copy import deepcopy\n\timport pytest\n\tfrom gptravel.core.services.filters import DeparturePlaceFilter, TravelPlanJSON\n\t@pytest.fixture\n\tdef departure_place_filter() -> DeparturePlaceFilter:\n\t    return DeparturePlaceFilter()\n\tclass TestDeparturePlaceFilter:\n\t    def test_on_travel_plan_with_departure(\n\t        self,\n\t        departure_place_filter: DeparturePlaceFilter,\n", "        italian_travel_plan: TravelPlanJSON,\n\t    ):\n\t        before_removal = deepcopy(italian_travel_plan)\n\t        departure_place_filter.filter(italian_travel_plan)\n\t        assert before_removal.travel_plan != italian_travel_plan.travel_plan\n\t        assert (\n\t            italian_travel_plan.departure_place not in italian_travel_plan.travel_cities\n\t        )\n\t        assert italian_travel_plan.get_key_values_by_name(\"day\") == [\n\t            \"Day 1\",\n", "            \"Day 2\",\n\t            \"Day 3\",\n\t        ]\n\t        assert italian_travel_plan.travel_activities == [\n\t            \"See San Marco\",\n\t            \"Take a ride on gondola\",\n\t            \"Eat an arancina\",\n\t            \"Eat fiorentina\",\n\t        ]\n\t    def test_on_travel_plan_with_nodeparture(\n", "        self,\n\t        departure_place_filter: DeparturePlaceFilter,\n\t        travel_plan_single_city_per_day: TravelPlanJSON,\n\t    ):\n\t        before_removal = deepcopy(travel_plan_single_city_per_day)\n\t        departure_place_filter.filter(travel_plan_single_city_per_day)\n\t        assert (\n\t            travel_plan_single_city_per_day.departure_place\n\t            not in travel_plan_single_city_per_day.travel_cities\n\t        )\n", "        assert before_removal.travel_plan == travel_plan_single_city_per_day.travel_plan\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_scorer.py", "chunked_list": ["import os\n\timport pytest\n\tfrom gptravel.core.services.scorer import (\n\t    CitiesCountryScorer,\n\t    DayGenerationScorer,\n\t    OptimizedItineraryScorer,\n\t    TravelPlanScore,\n\t)\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tuat_test = pytest.mark.skipif(\n", "    os.getenv(\"ENV\", \"UAT\") == \"PROD\",\n\t    reason=\"Only run in UAT environment\",\n\t)\n\tclass TestTravelPlanScore:\n\t    def test_add_score(self, score_container: TravelPlanScore):\n\t        score_container.add_score(\n\t            \"type score\", {\"score_value\": 100, \"score_weight\": 0.11}\n\t        )\n\t        score_container.add_score(\n\t            \"score livel\", {\"score_value\": 80, \"score_weight\": 0.23}\n", "        )\n\t        score_container.add_score(\n\t            \"score basso\", {\"score_value\": 60, \"score_weight\": 0.15}\n\t        )\n\t        score_container.add_score(\n\t            \"score extra\", {\"score_value\": 90, \"score_weight\": 0.10}\n\t        )\n\t        assert score_container.score_map[\"score extra\"] == {\n\t            \"score_value\": 90,\n\t            \"score_weight\": 0.10,\n", "        }\n\t    def test_weighted_score(self, score_container: TravelPlanScore):\n\t        score_container.add_score(\n\t            \"type score\", {\"score_value\": 100, \"score_weight\": 0.11}\n\t        )\n\t        score_container.add_score(\n\t            \"score livel\", {\"score_value\": 80, \"score_weight\": 0.23}\n\t        )\n\t        score_container.add_score(\n\t            \"score basso\", {\"score_value\": 60, \"score_weight\": 0.15}\n", "        )\n\t        assert score_container.weighted_score == pytest.approx(78.367, 0.001)\n\t    def test_weighted_score_empty(self, score_container: TravelPlanScore):\n\t        assert not score_container.weighted_score\n\t    def test_add_score_missing_key(self):\n\t        score = TravelPlanScore()\n\t        with pytest.raises(AssertionError):\n\t            score.add_score(\"score extra\", {\"score_value\": 90})\n\tclass TestDayGenerationScorer:\n\t    def test_day_generation_scorer_with_correct_days_travel_plan(\n", "        self,\n\t        score_container: TravelPlanScore,\n\t        travel_plan_single_city_per_day: TravelPlanJSON,\n\t        day_generation_scorer: DayGenerationScorer,\n\t    ) -> None:\n\t        day_generation_scorer.score(\n\t            travel_plan=travel_plan_single_city_per_day,\n\t            travel_plan_scores=score_container,\n\t        )\n\t        assert list(score_container.score_map.keys()) == [\n", "            day_generation_scorer.service_name\n\t        ]\n\t        score_dict = score_container.score_map[day_generation_scorer.service_name]\n\t        assert score_dict[\"score_value\"] == 1.0\n\t        assert score_dict[\"score_weight\"] == 0.4\n\t        assert score_dict[\"misaligned_days\"][\"extra_days\"] == []\n\t        assert score_dict[\"misaligned_days\"][\"missing_days\"] == []\n\t    def test_day_generation_scorer_with_no_correct_days_travel_plan(\n\t        self,\n\t        score_container: TravelPlanScore,\n", "        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n\t        day_generation_scorer: DayGenerationScorer,\n\t    ) -> None:\n\t        day_generation_scorer.score(\n\t            travel_plan=travel_plan_multiple_city_per_day_and_wrong_n_days,\n\t            travel_plan_scores=score_container,\n\t        )\n\t        assert list(score_container.score_map.keys()) == [\n\t            day_generation_scorer.service_name\n\t        ]\n", "        score_dict = score_container.score_map[day_generation_scorer.service_name]\n\t        assert score_dict[\"score_value\"] == pytest.approx(0.67, 0.01)\n\t        assert score_dict[\"score_weight\"] == pytest.approx(0.6, 0.01)\n\t        assert score_dict[\"misaligned_days\"][\"extra_days\"] == []\n\t        assert score_dict[\"misaligned_days\"][\"missing_days\"] == [3]\n\tclass TestCitiesCountryScorer:\n\t    def test_with_correct_travel_plan(\n\t        self,\n\t        cities_country_scorer: CitiesCountryScorer,\n\t        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n", "        score_container: TravelPlanScore,\n\t    ) -> None:\n\t        cities_country_scorer.score(\n\t            travel_plan_multiple_city_per_day_and_wrong_n_days, score_container\n\t        )\n\t        score_dict = score_container.score_map[cities_country_scorer.service_name]\n\t        assert score_dict[\"score_value\"] == pytest.approx(1.0, 0.01)\n\t        assert score_dict[\"latitude_check\"][\"score\"] == pytest.approx(1.0, 0.01)\n\t        assert score_dict[\"country_check\"][\"score\"] == pytest.approx(1.0, 0.01)\n\t    def test_with_wrong_city_travel_plan(\n", "        self,\n\t        cities_country_scorer: CitiesCountryScorer,\n\t        travel_plan_multiple_city_per_day_and_wrong_city_per_country: TravelPlanJSON,\n\t        score_container: TravelPlanScore,\n\t    ) -> None:\n\t        cities_country_scorer.score(\n\t            travel_plan_multiple_city_per_day_and_wrong_city_per_country,\n\t            score_container,\n\t        )\n\t        score_dict = score_container.score_map[cities_country_scorer.service_name]\n", "        assert score_dict[\"score_value\"] == pytest.approx(0.8, 0.01)\n\t        assert score_dict[\"latitude_check\"][\"score\"] == pytest.approx(1.0, 0.01)\n\t        assert score_dict[\"country_check\"][\"score\"] == pytest.approx(0.666, 0.01)\n\tclass TestOptimizedItineraryScorer:\n\t    def test_with_different_cities(\n\t        self,\n\t        itinerary_scorer: OptimizedItineraryScorer,\n\t        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n\t        score_container: TravelPlanScore,\n\t    ) -> None:\n", "        itinerary_scorer.score(\n\t            travel_plan_multiple_city_per_day_and_wrong_n_days, score_container\n\t        )\n\t        score_dict = score_container.score_map[itinerary_scorer.service_name]\n\t        assert score_dict[\"score_value\"] == pytest.approx(0.95181, 0.0001)\n\t        assert score_dict[\"tsp_solution\"][\"solution\"] == [\"bangkok\", \"krabi\", \"phuket\"]\n\t        assert score_dict[\"tsp_solution\"][\"open_problem\"]\n\t        assert score_dict[\"tsp_solution\"][\"distance\"] == pytest.approx(727.7, 0.1)\n\t        assert score_dict[\"itinerary\"][\"distance\"] == pytest.approx(770.2, 0.1)\n\t        assert score_dict[\"itinerary\"][\"solution\"] == [\"bangkok\", \"phuket\", \"krabi\"]\n", "    def test_with_departure_place_in_tp(\n\t        self,\n\t        itinerary_scorer: OptimizedItineraryScorer,\n\t        italian_travel_plan: TravelPlanJSON,\n\t        score_container: TravelPlanScore,\n\t    ) -> None:\n\t        itinerary_scorer.score(italian_travel_plan, score_container)\n\t        score_dict = score_container.score_map[itinerary_scorer.service_name]\n\t        assert score_dict[\"score_value\"] == pytest.approx(0.58256, 0.0001)\n\t        assert score_dict[\"tsp_solution\"][\"solution\"] == [\n", "            \"venice\",\n\t            \"florence\",\n\t            \"palermo\",\n\t        ]\n\t        assert score_dict[\"tsp_solution\"][\"open_problem\"]\n\t        assert score_dict[\"tsp_solution\"][\"distance\"] == pytest.approx(856.79, 0.1)\n\t        assert score_dict[\"itinerary\"][\"distance\"] == pytest.approx(1470.73, 0.1)\n\t        assert score_dict[\"itinerary\"][\"solution\"] == [\"venice\", \"palermo\", \"florence\"]\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_utils.py", "chunked_list": ["import os\n\timport numpy as np\n\timport pytest\n\tfrom gptravel.core.services.utils import (\n\t    is_location_a_country,\n\t    remove_consecutive_duplicates,\n\t    theil_diversity_entropy_index,\n\t)\n\tdef test_entropy_score():\n\t    input_list = [0.2, 0.2, 0.2, 0.2, 0.2]\n", "    expected_output = 0.0\n\t    assert np.isclose(\n\t        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n\t    )\n\t    input_list = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\t    input_list = [item / sum(input_list) for item in input_list]\n\t    expected_output = 0.0\n\t    assert np.isclose(\n\t        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n\t    )\n", "    input_list = [100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\t    input_list = [item / sum(input_list) for item in input_list]\n\t    expected_output = 0.7634496077289633\n\t    assert np.isclose(\n\t        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n\t    )\n\t    input_list = [100, 0.0, 0.0, 0, 0.0]\n\t    expected_output = 1.0\n\t    assert np.isclose(\n\t        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n", "    )\n\t    input_list = [0.9, 0.05, 0.05, 0.01, 0.01]\n\t    expected_output = 0.6913428710325702\n\t    assert np.isclose(\n\t        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n\t    )\n\t    input_list = [0.2, 0.3, 0.1, 0.2, 0.2]\n\t    expected_output = 0.03251123511643821\n\t    assert np.isclose(\n\t        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n", "    )\n\t@pytest.mark.skipif(\n\t    os.getenv(\"HUGGING_FACE_KEY\", \"\") == \"\", reason=\"no api key available\"\n\t)\n\tdef test_is_location_a_country():\n\t    assert is_location_a_country(\"Thailand\")\n\t    assert not is_location_a_country(\"Bangkok\")\n\t    assert is_location_a_country(\"United States\")\n\t    assert not is_location_a_country(\"Milan\")\n\t    assert is_location_a_country(\"Russia\")\n", "def test_remove_consecutive_duplicates():\n\t    assert remove_consecutive_duplicates([]) == []\n\t    assert remove_consecutive_duplicates([1]) == [1]\n\t    assert remove_consecutive_duplicates([1, 1, 1, 1]) == [1]\n\t    assert remove_consecutive_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4]\n\t    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 4]) == [1, 2, 3, 4]\n\t    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 4, 1]) == [1, 2, 3, 4, 1]\n\t    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 4, 1, 1]) == [1, 2, 3, 4, 1]\n\t    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 1, 4, 1]) == [\n\t        1,\n", "        2,\n\t        3,\n\t        4,\n\t        1,\n\t        4,\n\t        1,\n\t    ]\n\t    assert remove_consecutive_duplicates([1, \"a\", \"a\", 2, 2, \"b\", \"c\", \"c\", 4]) == [\n\t        1,\n\t        \"a\",\n", "        2,\n\t        \"b\",\n\t        \"c\",\n\t        4,\n\t    ]\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/conftest.py", "chunked_list": ["import pytest\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.core.services.scorer import (\n\t    CitiesCountryScorer,\n\t    DayGenerationScorer,\n\t    OptimizedItineraryScorer,\n\t    TravelPlanScore,\n\t)\n\t@pytest.fixture(autouse=True)\n\tdef geo_coder() -> GeoCoder:\n", "    return GeoCoder()\n\t@pytest.fixture\n\tdef score_container() -> TravelPlanScore:\n\t    return TravelPlanScore()\n\t@pytest.fixture\n\tdef cities_country_scorer(geo_coder: GeoCoder) -> CitiesCountryScorer:\n\t    return CitiesCountryScorer(geo_coder)\n\t@pytest.fixture\n\tdef day_generation_scorer() -> DayGenerationScorer:\n\t    return DayGenerationScorer()\n", "@pytest.fixture\n\tdef itinerary_scorer(geo_coder: GeoCoder) -> OptimizedItineraryScorer:\n\t    return OptimizedItineraryScorer(geo_coder)\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_engine.py/test_tsp_solver.py", "chunked_list": ["import os\n\timport pytest\n\tfrom gptravel.core.services.engine.tsp_solver import TSPSolver\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\t@pytest.fixture\n\tdef tsp_solver(geo_coder: GeoCoder) -> TSPSolver:\n\t    return TSPSolver(geo_coder)\n\tuat_test = pytest.mark.skipif(\n\t    os.getenv(\"ENV\", \"UAT\") == \"PROD\",\n\t    reason=\"Only run in UAT environment\",\n", ")\n\tclass TestTSPSolver:\n\t    def test_single_city(self, tsp_solver: TSPSolver) -> None:\n\t        cities = [\"Rome\"]\n\t        solution, distance = tsp_solver.solve(cities)\n\t        assert solution == cities\n\t        assert distance == 0.0\n\t    def test_closed_tsp(self, tsp_solver: TSPSolver) -> None:\n\t        cities = [\n\t            \"Milan\",\n", "            \"Rome\",\n\t            \"Venice\",\n\t            \"New York\",\n\t            \"Verona\",\n\t            \"Bologna\",\n\t        ]\n\t        solution, distance = tsp_solver.solve(cities=cities, open_problem=False)\n\t        assert solution == [\"Milan\", \"New York\", \"Rome\", \"Bologna\", \"Venice\", \"Verona\"]\n\t        assert distance == pytest.approx(14068.795, 0.001)\n\t    def test_open_tsp(self, tsp_solver: TSPSolver) -> None:\n", "        cities = [\n\t            \"Milan\",\n\t            \"Rome\",\n\t            \"Venice\",\n\t            \"New York\",\n\t            \"Verona\",\n\t            \"Bologna\",\n\t        ]\n\t        solution, distance = tsp_solver.solve(cities=cities, open_problem=True)\n\t        assert solution == [\"Milan\", \"Verona\", \"Venice\", \"Bologna\", \"Rome\", \"New York\"]\n", "        assert distance == pytest.approx(7587.457, 0.001)\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_engine.py/test_classifier.py", "chunked_list": ["import os\n\timport pytest\n\tfrom gptravel.core.services.engine.classifier import ZeroShotTextClassifier\n\t@pytest.fixture()\n\tdef classifier() -> ZeroShotTextClassifier:\n\t    return ZeroShotTextClassifier(multi_label=True)\n\t@pytest.mark.skipif(\n\t    os.getenv(\"HUGGING_FACE_KEY\", \"\") == \"\", reason=\"no api key available\"\n\t)\n\tclass TestZeroShotClassified:\n", "    def test_property(self, classifier: ZeroShotTextClassifier):\n\t        assert classifier.multi_label\n\t        classifier.multi_label = False\n\t        assert not classifier.multi_label\n\t    def test_prediction(self, classifier: ZeroShotTextClassifier):\n\t        labels = [\"sea\", \"land\", \"city\"]\n\t        input_text = [\"fish\"]\n\t        out = classifier.predict(input_text_list=input_text, label_classes=labels)[\n\t            input_text[0]\n\t        ]\n", "        for label in labels:\n\t            assert (out[label] < 1) & (out[label] >= 0)\n\t        assert max(out, key=out.get) == \"sea\"\n"]}
{"filename": "tests/test_gptravel/test_core/test_travel_planner/test_travel_engine.py", "chunked_list": ["from gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tclass TestTravelPlanJSON:\n\t    def test_travel_plan_properties(\n\t        self, travel_plan_single_city_per_day: TravelPlanJSON\n\t    ):\n\t        assert travel_plan_single_city_per_day.n_days == 3\n\t        assert travel_plan_single_city_per_day.departure_place == \"Milan\"\n\t        assert travel_plan_single_city_per_day.destination_place == \"Thailand\"\n\t        assert travel_plan_single_city_per_day.keys_map == {\"day\": 0, \"city\": 1}\n\t        assert travel_plan_single_city_per_day.travel_plan == {\n", "            \"Day 1\": {\n\t                \"Bangkok\": [\n\t                    \"Visit Wat Phra Kaew and the Grand Palace\",\n\t                    \"Explore the Wat Pho Temple\",\n\t                    \"Ride a boat in the Chao Phraya River\",\n\t                    \"Shop at Chatuchak weekend market\",\n\t                ]\n\t            },\n\t            \"Day 2\": {\n\t                \"Phuket\": [\n", "                    \"Spend time at the Patong Beach\",\n\t                    \"Visit Big Buddha Phuket\",\n\t                    \"Explore the Phuket Old Town\",\n\t                    \"Enjoy local street food at night markets\",\n\t                ]\n\t            },\n\t            \"Day 3\": {\n\t                \"Krabi\": [\n\t                    \"Visit Railay Beach and the Phra Nang Cave\",\n\t                    \"Island hopping tour to Phi Phi Islands\",\n", "                    \"Hike to the Tiger Cave Temple\",\n\t                    \"Relax at Ao Nang Beach\",\n\t                ]\n\t            },\n\t        }\n\t    def test_travel_plan_single_city_per_day(\n\t        self,\n\t        travel_plan_single_city_per_day: TravelPlanJSON,\n\t    ):\n\t        days = travel_plan_single_city_per_day.get_key_values_by_name(key_name=\"day\")\n", "        assert days == [\"Day 1\", \"Day 2\", \"Day 3\"]\n\t        cities = travel_plan_single_city_per_day.get_key_values_by_name(key_name=\"city\")\n\t        assert cities == [\"Bangkok\", \"Phuket\", \"Krabi\"]\n\t        activities = travel_plan_single_city_per_day.travel_activities\n\t        assert activities == [\n\t            \"Visit Wat Phra Kaew and the Grand Palace\",\n\t            \"Explore the Wat Pho Temple\",\n\t            \"Ride a boat in the Chao Phraya River\",\n\t            \"Shop at Chatuchak weekend market\",\n\t            \"Spend time at the Patong Beach\",\n", "            \"Visit Big Buddha Phuket\",\n\t            \"Explore the Phuket Old Town\",\n\t            \"Enjoy local street food at night markets\",\n\t            \"Visit Railay Beach and the Phra Nang Cave\",\n\t            \"Island hopping tour to Phi Phi Islands\",\n\t            \"Hike to the Tiger Cave Temple\",\n\t            \"Relax at Ao Nang Beach\",\n\t        ]\n\t    def test_travel_plan_multiple_city_per_day(\n\t        self,\n", "        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n\t    ):\n\t        days = (\n\t            travel_plan_multiple_city_per_day_and_wrong_n_days.get_key_values_by_name(\n\t                key_name=\"day\"\n\t            )\n\t        )\n\t        assert days == [\"Day 1\", \"Day 2\"]\n\t        cities = (\n\t            travel_plan_multiple_city_per_day_and_wrong_n_days.get_key_values_by_name(\n", "                key_name=\"city\"\n\t            )\n\t        )\n\t        assert cities == [\"Bangkok\", \"Phuket\", \"Krabi\"]\n\t        activities = (\n\t            travel_plan_multiple_city_per_day_and_wrong_n_days.travel_activities\n\t        )\n\t        assert activities == [\n\t            \"Visit Wat Phra Kaew and the Grand Palace\",\n\t            \"Explore the Wat Pho Temple\",\n", "            \"Ride a boat in the Chao Phraya River\",\n\t            \"Shop at Chatuchak weekend market\",\n\t            \"Spend time at the Patong Beach\",\n\t            \"Visit Big Buddha Phuket\",\n\t            \"Explore the Phuket Old Town\",\n\t            \"Enjoy local street food at night markets\",\n\t            \"Visit Railay Beach and the Phra Nang Cave\",\n\t            \"Island hopping tour to Phi Phi Islands\",\n\t            \"Hike to the Tiger Cave Temple\",\n\t            \"Relax at Ao Nang Beach\",\n", "        ]\n"]}
{"filename": "tests/test_gptravel/test_core/test_travel_planner/test_tokenizer.py", "chunked_list": ["import pytest\n\tfrom gptravel.core.travel_planner.token_manager import ChatGptTokenManager\n\t@pytest.fixture\n\tdef chatgpt_token_manager() -> ChatGptTokenManager:\n\t    return ChatGptTokenManager()\n\t@pytest.mark.parametrize(\n\t    \"n_days, distance, expected\",\n\t    [(10, 100, 757), (0, 0, 383), (10, 5000, 756), (-100000000, 5, 383)],\n\t)\n\tdef test_chatgpt_token_manager(\n", "    chatgpt_token_manager: ChatGptTokenManager,\n\t    n_days: int,\n\t    distance: float,\n\t    expected: int,\n\t):\n\t    result = chatgpt_token_manager.get_number_tokens(n_days=n_days, distance=distance)\n\t    assert result == pytest.approx(expected, 1)\n"]}
{"filename": "tests/test_gptravel/test_core/test_travel_planner/test_prompt.py", "chunked_list": ["from typing import Any, Dict\n\tfrom gptravel.core.travel_planner.prompt import (\n\t    CompletionTravelPrompt,\n\t    PlainTravelPrompt,\n\t    PromptFactory,\n\t    ThematicTravelPrompt,\n\t)\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tclass TestPrompt:\n\t    def test_plain_prompt_from_factory(\n", "        self, travel_properties: Dict[str, Any], prompt_factory: PromptFactory\n\t    ):\n\t        prompt_class = prompt_factory.build_prompt(**travel_properties)\n\t        assert isinstance(prompt_class, PlainTravelPrompt)\n\t        travel_properties[\"travel_theme\"] = None\n\t        prompt_class = prompt_factory.build_prompt(**travel_properties)\n\t        assert isinstance(prompt_class, PlainTravelPrompt)\n\t    def test_thematic_prompt_from_factory(\n\t        self, travel_properties: Dict[str, Any], prompt_factory: PromptFactory\n\t    ):\n", "        travel_properties[\"travel_theme\"] = \"romantic\"\n\t        prompt_class = prompt_factory.build_prompt(**travel_properties)\n\t        assert isinstance(prompt_class, ThematicTravelPrompt)\n\t        assert prompt_class.json_keys == {\"day\": 0, \"city\": 1}\n\t    def test_completion_travel_prompt_from_factory(\n\t        self,\n\t        travel_properties: Dict[str, Any],\n\t        prompt_factory: PromptFactory,\n\t        travel_plan_single_city_per_day: TravelPlanJSON,\n\t    ):\n", "        travel_properties[\"complention_travel_plan\"] = True\n\t        travel_properties[\"n_days_to_add\"] = 1\n\t        travel_properties[\"travel_plan\"] = travel_plan_single_city_per_day.travel_plan\n\t        prompt_class = prompt_factory.build_prompt(**travel_properties)\n\t        assert prompt_class.json_keys == {\"day\": 0, \"city\": 1}\n\t        assert isinstance(prompt_class, CompletionTravelPrompt)\n\t        travel_properties[\"complention_travel_plan\"] = False\n\t        prompt_class = prompt_factory.build_prompt(**travel_properties)\n\t        assert not isinstance(prompt_class, CompletionTravelPrompt)\n\t    def test_properties(\n", "        self, travel_properties: Dict[str, Any], prompt_factory: PromptFactory\n\t    ):\n\t        prompt = prompt_factory.build_prompt(**travel_properties)\n\t        assert prompt.departure_place == travel_properties[\"departure_place\"]\n\t        assert prompt.destination_place == travel_properties[\"destination_place\"]\n\t        assert prompt.n_travel_days == travel_properties[\"n_travel_days\"]\n"]}
{"filename": "src/gptravel/main.py", "chunked_list": ["import json\n\timport os\n\timport time\n\tfrom typing import Optional\n\timport openai\n\tfrom dotenv import load_dotenv\n\tfrom gptravel.core.services.checker import DaysChecker, ExistingDestinationsChecker\n\tfrom gptravel.core.services.engine.classifier import ZeroShotTextClassifier\n\tfrom gptravel.core.services.filters import DeparturePlaceFilter\n\tfrom gptravel.core.services.geocoder import GeoCoder\n", "from gptravel.core.services.score_builder import ScorerOrchestrator\n\tfrom gptravel.core.services.scorer import TravelPlanScore\n\tfrom gptravel.core.travel_planner.openai_engine import ChatGPTravelEngine\n\tfrom gptravel.core.travel_planner.prompt import PromptFactory\n\t# from gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tload_dotenv()\n\topenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\tdef main(\n\t    destination_place: str,\n\t    departure_place: str,\n", "    n_days: int,\n\t    travel_theme: Optional[str] = None,\n\t):\n\t    start_time = time.time()\n\t    travel_parameters = {\n\t        \"departure_place\": departure_place,\n\t        \"destination_place\": destination_place,\n\t        \"n_travel_days\": n_days,\n\t        \"travel_theme\": travel_theme,\n\t    }\n", "    prompt_factory = PromptFactory()\n\t    prompt = prompt_factory.build_prompt(**travel_parameters)\n\t    engine = ChatGPTravelEngine(max_tokens=350)\n\t    travel_plan_in_json_format = engine.get_travel_plan_json(prompt)\n\t    travel_plan_in_json_format = engine.get_travel_plan_json(prompt)\n\t    print(\n\t        \"** Execution time for travel generation\", time.time() - start_time, \"seconds\"\n\t    )\n\t    with open(\n\t        \"trave-l_plan_{}_{}.json\".format(destination_place, n_days), \"w\"\n", "    ) as jfile:\n\t        json.dump(travel_plan_in_json_format.travel_plan, jfile)\n\t    \"\"\"travel_plan_in_json_format = TravelPlanJSON(\n\t        destination_place=\"Malaysia\",\n\t        departure_place=\"Rome\",\n\t        n_days=4,\n\t        travel_plan_json={\n\t            \"Day 1\": {\n\t                \"Kuala Lumpur\": [\n\t                    \"Visit Petronas Towers\",\n", "                    \"Explore Batu Caves\",\n\t                    \"Shop at Central Market\",\n\t                    \"Try local street food at Jalan Alor\",\n\t                ]\n\t            },\n\t            \"Day 2\": {\n\t                \"Kuala Lumpur\": [\n\t                    \"Visit Islamic Arts Museum\",\n\t                    \"Explore Merdeka Square\",\n\t                    \"Enjoy panoramic views from KL Tower\",\n", "                ]\n\t            },\n\t            \"Day 3\": {\n\t                \"Penang\": [\n\t                    \"Discover George Town's street art\",\n\t                    \"Visit Kek Lok Si Temple\",\n\t                    \"Try local food at Gurney Drive Hawker Centre\",\n\t                ]\n\t            },\n\t        },\n", "        json_keys_depth_map={\"city\": 1, \"day\": 0},\n\t    )\"\"\"\n\t    filter_service = DeparturePlaceFilter()\n\t    filter_service.filter(travel_plan=travel_plan_in_json_format)\n\t    checker = DaysChecker()\n\t    is_ok = checker.check(travel_plan=travel_plan_in_json_format)\n\t    if not is_ok:\n\t        travel_parameters[\"complention_travel_plan\"] = True\n\t        travel_parameters[\"n_days_to_add\"] = (\n\t            travel_plan_in_json_format.n_days - checker.travel_days\n", "        )\n\t        travel_parameters[\"travel_plan\"] = travel_plan_in_json_format.travel_plan\n\t        prompt_completion = prompt_factory.build_prompt(**travel_parameters)\n\t        travel_plan_in_json_format = engine.get_travel_plan_json(prompt_completion)\n\t    middle_time = time.time()\n\t    zs_classifier = ZeroShotTextClassifier(True)\n\t    geo_decoder = GeoCoder()\n\t    score_container = TravelPlanScore()\n\t    city_checker = ExistingDestinationsChecker(geo_decoder)\n\t    city_checker.check(travel_plan_in_json_format)\n", "    scorers_orchestrator = ScorerOrchestrator(\n\t        geocoder=geo_decoder, text_classifier=zs_classifier\n\t    )\n\t    scorers_orchestrator.run(\n\t        travel_plan_json=travel_plan_in_json_format, scores_container=score_container\n\t    )\n\t    print(\n\t        \"** Execution time for scores computation\", time.time() - middle_time, \"seconds\"\n\t    )\n\t    print(\"** Total execution time\", time.time() - start_time, \"seconds\")\n", "    print(\"** Travel plan overall scores\", score_container.weighted_score)\n\t    with open(\n\t        \"trave-l_plan_{}_{}_scores.json\".format(destination_place, n_days), \"w\"\n\t    ) as jfile:\n\t        json.dump(score_container.score_map, jfile)\n\tif __name__ == \"__main__\":\n\t    main(\n\t        destination_place=\"Malaysia\",\n\t        departure_place=\"Milan\",\n\t        n_days=4,\n", "        travel_theme=None,\n\t    )\n"]}
{"filename": "src/gptravel/__init__.py", "chunked_list": []}
{"filename": "src/gptravel/prototype/help.py", "chunked_list": ["OPENAI_KEY_HELP = (\n\t    \"Enter your OpenAI key. If you don't have one, \"\n\t    \"you can sign up at https://openai.com/ to get your API key.\"\n\t)\n\tDEPARTURE_DATE_HELP = \"Choose the date of departure.\"\n\tRETURN_DATE_HELP = \"Choose the date of return.\"\n\tDEPARTURE_LOC_HELP = \"Enter the departure location.\"\n\tDESTINATION_LOC_HELP = \"Enter the destination location.\"\n\tTRAVEL_REASON_HELP = \"Select the reason for your travel.\"\n\tTRAVEL_SCORE_HELP = (\n", "    \"This is a rating from 0 to 100 that indicates the diversity of your travel experience.\"\n\t    \" It measures the balance of activities such as monuments, culture, transport, museums, relaxation, sports, food, shopping, mountains, and sea. \"\n\t    \"Aim for a high score to ensure a well-rounded trip with unforgettable memories and a deep connection to your destinations.\"\n\t)\n"]}
{"filename": "src/gptravel/prototype/__init__.py", "chunked_list": []}
{"filename": "src/gptravel/prototype/utils.py", "chunked_list": ["from datetime import date\n\tfrom typing import Dict, List, Tuple, Union\n\timport openai\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.services.engine import classifier\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.core.services.score_builder import ScorerOrchestrator\n\tfrom gptravel.core.services.scorer import TravelPlanScore\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tdef is_valid_openai_key(openai_key: str) -> bool:\n", "    \"\"\"\n\t    Checks if the provided OpenAI API key is valid by performing a test request.\n\t    Parameters\n\t    ----------\n\t    openai_key : str\n\t        The OpenAI API key to be tested.\n\t    Returns\n\t    -------\n\t    bool\n\t        True if the OpenAI API key is valid and the test request succeeds,\n", "        False otherwise.\n\t    Raises\n\t    ------\n\t    None\n\t    Examples\n\t    --------\n\t    >>> is_valid_openai_key(\"<OPENAI_API_KEY>\")\n\t    True\n\t    >>> is_valid_openai_key(\"foo\")\n\t    False\n", "    \"\"\"\n\t    openai.api_key = openai_key\n\t    try:\n\t        openai.Completion.create(engine=\"ada\", prompt=\"Hello, World!\", max_tokens=5)\n\t    except openai.error.InvalidRequestError:\n\t        return False\n\t    except openai.error.AuthenticationError:\n\t        return False\n\t    return True\n\tdef is_departure_before_return(departure_date: date, return_date: date) -> bool:\n", "    \"\"\"\n\t    Parameters\n\t    ----------\n\t    departure_date : np.datetime64\n\t        The date of departure.\n\t    return_date : np.datetime64\n\t        The date of return.\n\t    Returns\n\t    -------\n\t    bool_\n", "        True if the departure date is before or equal to the return date, False otherwise.\n\t    \"\"\"\n\t    return departure_date <= return_date\n\tdef get_score_map(\n\t    travel_plan_json: TravelPlanJSON,\n\t) -> TravelPlanScore:\n\t    \"\"\"\n\t    Calculates the score map for a given travel plan.\n\t    Parameters\n\t    ----------\n", "    travel_plan_json : TravelPlanJSON\n\t        The JSON representation of the travel plan.\n\t    Returns\n\t    -------\n\t    Dict[str, Dict[str, Union[float, int]]]\n\t        A dictionary containing the score map for the travel plan.\n\t    \"\"\"\n\t    geo_decoder = GeoCoder()\n\t    zs_classifier = classifier.ZeroShotTextClassifier(True)\n\t    score_container = TravelPlanScore()\n", "    logger.info(\"Score Engines: Start\")\n\t    scorers_orchestrator = ScorerOrchestrator(\n\t        geocoder=geo_decoder, text_classifier=zs_classifier\n\t    )\n\t    scorers_orchestrator.run(\n\t        travel_plan_json=travel_plan_json, scores_container=score_container\n\t    )\n\t    logger.info(\"Score Engines: End\")\n\t    return score_container\n\tdef get_cities_coordinates_of_same_country_destionation(\n", "    cities: Union[List[str], Tuple[str]], destination: str\n\t) -> Dict[str, Tuple]:\n\t    geo_coder = GeoCoder()\n\t    logger.info(\"Get Cities coordinates: Start\")\n\t    logger.debug(\"Get Cities coordinates: cities to analyze = {}\".format(cities))\n\t    logger.debug(\"Get Cities coordinates: destination = {}\".format(destination))\n\t    destination_country = destination.lower()\n\t    if not is_a_country(destination):\n\t        destination_country = geo_coder.country_from_location_name(destination).lower()\n\t        logger.debug(\n", "            \"Get Cities coordinates: destination country = {}\".format(\n\t                destination_country\n\t            )\n\t        )\n\t    cities_coordinates = {\n\t        city: tuple(coord for coord in geo_coder.location_coordinates(city).values())\n\t        for city in cities\n\t        if geo_coder.country_from_location_name(city).lower() == destination_country\n\t    }\n\t    logger.debug(\"Computed cities coordinates = {}\".format(cities_coordinates))\n", "    logger.info(\"Get Cities coordinates: End\")\n\t    return cities_coordinates\n\tdef is_a_country(place: str):\n\t    geo_coder = GeoCoder()\n\t    return geo_coder.is_a_country(place)\n"]}
{"filename": "src/gptravel/prototype/style.py", "chunked_list": ["COLOR_LABEL_ACTIVITY_DICT = {\n\t    \"culture\": \"#8dd3c7\",\n\t    \"monument\": \"#ff9900\",\n\t    \"transport\": \"#bebada\",\n\t    \"sport\": \"#fb8072\",\n\t    \"food\": \"#80b1d3\",\n\t    \"museum\": \"#fdb462\",\n\t    \"sea\": \"#b3de69\",\n\t    \"mountain\": \"#fccde5\",\n\t    \"relax\": \"#d9d9d9\",\n", "    \"shopping\": \"#0066cc\",\n\t}\n\tLABEL_BOX_STYLE = (\n\t    \"font-family: 'Roboto', sans-serif; font-size: 14px;\"\n\t    \" color: black; border: 1px solid black; padding: 5px; \"\n\t    \"border-radius: 5px; padding: 2px;\"\n\t)\n"]}
{"filename": "src/gptravel/prototype/pages/home.py", "chunked_list": ["from datetime import datetime\n\timport streamlit as st\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.prototype import help as prototype_help\n\tfrom gptravel.prototype import utils as prototype_utils\n\tfrom gptravel.prototype.pages import travel as travel_page\n\tdef main():\n\t    \"\"\"\n\t    Main function for running GPTravel.\n", "    It allows users to input travel parameters and generates a travel plan when the \"Let's go!\" button is clicked.\n\t    \"\"\"\n\t    st.title(\"GPTravel ✈️\")\n\t    st.write(\"\\n\\n\")\n\t    openai_key = st.sidebar.text_input(\n\t        \"OpenAI API Key\",\n\t        help=prototype_help.OPENAI_KEY_HELP,\n\t        placeholder=\"Enter your OpenAI key here\",\n\t    )\n\t    departure_date = st.sidebar.date_input(\n", "        \"Select a date\", help=prototype_help.DEPARTURE_DATE_HELP\n\t    )\n\t    return_date = st.sidebar.date_input(\n\t        label=\"Select a return date\",\n\t        key=\"return_date\",\n\t        help=prototype_help.RETURN_DATE_HELP,\n\t    )\n\t    departure = st.sidebar.text_input(\n\t        label=\"Departure\",\n\t        placeholder=\"Select a departure\",\n", "        help=prototype_help.DEPARTURE_LOC_HELP,\n\t    )\n\t    destination = st.sidebar.text_input(\n\t        label=\"Destination\",\n\t        placeholder=\"Select a destination\",\n\t        help=prototype_help.DESTINATION_LOC_HELP,\n\t    )\n\t    travel_reason = st.sidebar.selectbox(\n\t        \"Select a travel reason\",\n\t        options=[\"\", \"Business\", \"Romantic\", \"Solo\", \"Friends\", \"Family\"],\n", "        help=prototype_help.TRAVEL_REASON_HELP,\n\t    )\n\t    travel_reason_strp = travel_reason.strip()\n\t    input_options = {\n\t        \"openai_key\": openai_key,\n\t        \"departure_date\": departure_date,\n\t        \"return_date\": return_date,\n\t        \"departure\": departure,\n\t        \"destination\": destination,\n\t        \"travel_reason\": None if travel_reason_strp == \"\" else travel_reason_strp,\n", "    }\n\t    if st.sidebar.button(\"Let's go!\"):\n\t        if _is_valid_input(\n\t            openai_key=openai_key,\n\t            departure_date=departure_date,\n\t            return_date=return_date,\n\t            departure=departure,\n\t            destination=destination,\n\t        ):\n\t            with st.spinner(\"Preparing your travel plan...\"):\n", "                travel_page.main(**input_options)\n\tdef _is_valid_input(\n\t    departure: str,\n\t    destination: str,\n\t    departure_date: datetime,\n\t    return_date: datetime,\n\t    openai_key: str,\n\t) -> bool:\n\t    \"\"\"\n\t    Check if the input parameters are valid.\n", "    Parameters\n\t    ----------\n\t    departure : str\n\t        Departure location.\n\t    destination : str\n\t        Destination location.\n\t    departure_date : datetime\n\t        Departure date.\n\t    return_date : datetime\n\t        Return date.\n", "    openai_key : str\n\t        OpenAI API key.\n\t    Returns\n\t    -------\n\t    bool\n\t        True if the input parameters are valid, False otherwise.\n\t    \"\"\"\n\t    geo_coder = GeoCoder()\n\t    if (not geo_coder.is_location_country_city_state(departure)) or (\n\t        not geo_coder.is_location_country_city_state(destination)\n", "    ):\n\t        warn_message = \"Travel destination or/and departure is not valid.\"\n\t        st.sidebar.warning(warn_message)\n\t        logger.warning(warn_message)\n\t        return False\n\t    if not prototype_utils.is_departure_before_return(\n\t        departure_date=departure_date, return_date=return_date\n\t    ):\n\t        warn_message = (\n\t            \"Travel dates are not correct. Departure should be before return.\"\n", "        )\n\t        st.sidebar.warning(warn_message)\n\t        logger.warning(warn_message)\n\t        return False\n\t    if not prototype_utils.is_valid_openai_key(openai_key):\n\t        warn_message = \"Not valid OpenAI API Access Key\"\n\t        st.sidebar.warning(warn_message)\n\t        logger.warning(warn_message)\n\t        return False\n\t    return True\n"]}
{"filename": "src/gptravel/prototype/pages/__init__.py", "chunked_list": ["from gptravel.core.services.geocoder import GeoCoder\n\tgeo_coder = GeoCoder()\n"]}
{"filename": "src/gptravel/prototype/pages/travel.py", "chunked_list": ["import os\n\tfrom datetime import datetime, timedelta\n\tfrom typing import Any, Dict, Tuple\n\timport folium\n\timport numpy as np\n\timport streamlit as st\n\tfrom openai.error import RateLimitError\n\tfrom streamlit_folium import st_folium\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.services.checker import DaysChecker, ExistingDestinationsChecker\n", "from gptravel.core.services.filters import DeparturePlaceFilter\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.core.travel_planner import openai_engine\n\tfrom gptravel.core.travel_planner.prompt import Prompt, PromptFactory\n\tfrom gptravel.core.travel_planner.token_manager import ChatGptTokenManager\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tfrom gptravel.prototype import help as prototype_help\n\tfrom gptravel.prototype import style as prototype_style\n\tfrom gptravel.prototype import utils as prototype_utils\n\tdef main(\n", "    openai_key: str,\n\t    departure: str,\n\t    destination: str,\n\t    departure_date: datetime,\n\t    return_date: datetime,\n\t    travel_reason: str,\n\t):\n\t    \"\"\"\n\t     Main function for running travel plan in GPTravel.\n\t     It generates a travel page and display all functionalities of the page.\n", "    Parameters\n\t    ----------\n\t    openai_key : str\n\t        OpenAI API key.\n\t    departure : str\n\t        Departure place.\n\t    destination : str\n\t        Destination place.\n\t    departure_date : datetime\n\t        Departure date.\n", "    return_date : datetime\n\t        Return date.\n\t    travel_reason : str\n\t        Reason for travel.\n\t    \"\"\"\n\t    try:\n\t        travel_plan_dict, score_dict = _get_travel_plan(\n\t            openai_key=openai_key,\n\t            departure=departure,\n\t            destination=destination,\n", "            departure_date=departure_date,\n\t            return_date=return_date,\n\t            travel_reason=travel_reason,\n\t        )\n\t    except RateLimitError as openai_rate_limit_error:\n\t        st.error(openai_rate_limit_error)\n\t    _show_travel_itinerary(travel_plan_dict, destination)\n\t    st.markdown(\n\t        f\"#### Overall Travel Score: \\t\\t\\t\\t\"\n\t        f\"{score_dict.weighted_score * 100:.0f} / 100\",\n", "        help=prototype_help.TRAVEL_SCORE_HELP,\n\t    )\n\t    _create_expanders_travel_plan(departure_date, score_dict, travel_plan_dict)\n\tdef _show_travel_itinerary(travel_plan_dict: Dict[str, Any], destination: str) -> None:\n\t    logger.info(\"Show travel itinerary map: Start\")\n\t    travel_plan_cities_names = tuple(\n\t        city for day in travel_plan_dict.keys() for city in travel_plan_dict[day].keys()\n\t    )\n\t    cities_coordinates = (\n\t        prototype_utils.get_cities_coordinates_of_same_country_destionation(\n", "            cities=travel_plan_cities_names, destination=destination\n\t        )\n\t    )\n\t    logger.debug(\"Computed coordinates = {}\".format(cities_coordinates))\n\t    coordinates_array = np.array(\n\t        [[coords[0], coords[1]] for coords in cities_coordinates.values()]\n\t    )\n\t    mean_point_coordinates = np.median(coordinates_array, axis=0)\n\t    zoom_start = 6 if prototype_utils.is_a_country(destination) else 8\n\t    m = folium.Map(location=mean_point_coordinates, zoom_start=zoom_start)\n", "    for city, coordinates in cities_coordinates.items():\n\t        folium.Marker(coordinates, popup=city, tooltip=city).add_to(m)\n\t    # call to render Folium map in Streamlit\n\t    st_folium(m, height=400, width=1000, returned_objects=[])\n\t    logger.info(\"Show travel itinerary map: Start\")\n\t@st.cache_data(show_spinner=False)\n\tdef _get_travel_plan(\n\t    openai_key: str,\n\t    departure: str,\n\t    destination: str,\n", "    departure_date: datetime,\n\t    return_date: datetime,\n\t    travel_reason: str,\n\t) -> Tuple[Dict[Any, Any], prototype_utils.TravelPlanScore]:\n\t    \"\"\"\n\t    Get the travel plan and score dictionary.\n\t    Parameters\n\t    ----------\n\t    openai_key : str\n\t        OpenAI API key.\n", "    departure : str\n\t        Departure place.\n\t    destination : str\n\t        Destination place.\n\t    departure_date : datetime\n\t        Departure date.\n\t    return_date : datetime\n\t        Return date.\n\t    travel_reason : str\n\t        Reason for travel.\n", "    Returns\n\t    -------\n\t    Tuple[Dict[Any, Any], TravelPlanScore]\n\t        A tuple containing the travel plan dictionary and the travel plan score.\n\t    \"\"\"\n\t    os.environ[\"OPENAI_API_KEY\"] = openai_key\n\t    n_days = (return_date - departure_date).days + 1\n\t    travel_parameters = {\n\t        \"departure_place\": departure,\n\t        \"destination_place\": destination,\n", "        \"n_travel_days\": n_days,\n\t        \"travel_theme\": travel_reason,\n\t    }\n\t    token_manager = ChatGptTokenManager()\n\t    geocoder = GeoCoder()\n\t    travel_distance = geocoder.location_distance(departure, destination)\n\t    max_number_tokens = token_manager.get_number_tokens(\n\t        n_days=n_days, distance=travel_distance\n\t    )\n\t    travel_plan_json = _get_travel_plan_json(\n", "        travel_parameters=travel_parameters, max_tokens=max_number_tokens\n\t    )\n\t    checker = ExistingDestinationsChecker(geocoder)\n\t    checker.check(travel_plan_json)\n\t    travel_plan_dict = travel_plan_json.travel_plan\n\t    score_dict = prototype_utils.get_score_map(travel_plan_json)\n\t    return travel_plan_dict, score_dict\n\tdef _get_travel_plan_json(\n\t    travel_parameters: Dict[str, Any], max_tokens: int\n\t) -> TravelPlanJSON:\n", "    \"\"\"\n\t    Retrieves the travel plan JSON based on the provided prompt.\n\t    Args:\n\t        travel_parameters (Dict[str, Any]): travel parameters for plan generation.\n\t    Returns:\n\t        TravelPlanJSON: Travel plan JSON.\n\t    \"\"\"\n\t    logger.info(\"Building Prompt with travel parameters\")\n\t    prompt = _build_prompt(travel_parameters)\n\t    logger.info(\"Prompt Built successfully\")\n", "    logger.info(\"Generating Travel Plan: Start\")\n\t    engine = openai_engine.ChatGPTravelEngine(max_tokens=max_tokens)\n\t    generated_travel_plan = engine.get_travel_plan_json(prompt)\n\t    logger.info(\"Generating Travel Plan: End\")\n\t    travel_filter = DeparturePlaceFilter()\n\t    travel_filter.filter(generated_travel_plan)\n\t    days_checker = DaysChecker()\n\t    if not days_checker.check(generated_travel_plan):\n\t        logger.warning(\"Completing Travel Plan due to missing days\")\n\t        travel_parameters[\"complention_travel_plan\"] = True\n", "        travel_parameters[\"n_days_to_add\"] = (\n\t            generated_travel_plan.n_days - days_checker.travel_days\n\t        )\n\t        travel_parameters[\"travel_plan\"] = generated_travel_plan.travel_plan\n\t        completion_prompt = _build_prompt(travel_parameters)\n\t        generated_travel_plan = engine.get_travel_plan_json(completion_prompt)\n\t    return generated_travel_plan\n\tdef _build_prompt(travel_parameters: Dict[str, Any]) -> Prompt:\n\t    \"\"\"\n\t    Builds the prompt for the travel plan based on the travel parameters.\n", "    Args:\n\t        travel_parameters (Dict[str, Any]): Travel parameters.\n\t    Returns:\n\t        Prompt: Prompt for the travel plan.\n\t    \"\"\"\n\t    prompt_factory = PromptFactory()\n\t    logger.debug(\"Building Prompt with parameters = {}\".format(travel_parameters))\n\t    prompt = prompt_factory.build_prompt(**travel_parameters)\n\t    return prompt\n\tdef _create_expanders_travel_plan(\n", "    departure_date: datetime,\n\t    score_dict: prototype_utils.TravelPlanScore,\n\t    travel_plan_dict: Dict[Any, Any],\n\t) -> None:\n\t    \"\"\"\n\t    Create expanders for displaying the travel plan.\n\t    Parameters\n\t    ----------\n\t    departure_date : datetime\n\t        Departure date.\n", "    score_dict : prototype_utils.TravelPlanScore\n\t        Score container object.\n\t    travel_plan_dict : Dict[Any, Any]\n\t        Travel plan dictionary.\n\t    \"\"\"\n\t    for day_num, (day_key, places_dict) in enumerate(travel_plan_dict.items()):\n\t        date_str = (departure_date + timedelta(days=int(day_num))).strftime(\"%d-%m-%Y\")\n\t        expander_day_num = st.expander(f\"{day_key} ({date_str})\", expanded=True)\n\t        for place, activities in places_dict.items():\n\t            expander_day_num.markdown(f\"**{place}**\")\n", "            for activity in activities:\n\t                activity_descr = f\" {activity}\"\n\t                ### TODO (RC): add an if when filtered activities is empty; take the argmax\n\t                filtered_activities = filter(\n\t                    lambda x: x[1] > 0.5,\n\t                    score_dict.score_map[\"Activities Variety\"][\"labeled_activities\"][\n\t                        activity\n\t                    ].items(),\n\t                )\n\t                sorted_filtered_activities = sorted(\n", "                    filtered_activities, key=lambda x: x[1], reverse=True\n\t                )\n\t                activity_label = \" \".join(\n\t                    f'<span style=\"background-color:{prototype_style.COLOR_LABEL_ACTIVITY_DICT[label]}; {prototype_style.LABEL_BOX_STYLE}\">\\t\\t<b>{label.upper()}</b></span>'\n\t                    for label, _ in sorted_filtered_activities\n\t                )\n\t                expander_day_num.markdown(\n\t                    f\"- {activity_label} {activity_descr}\\n\", unsafe_allow_html=True\n\t                )\n"]}
{"filename": "src/gptravel/core/io/loggerconfig.py", "chunked_list": ["import logging\n\timport os\n\tfrom dotenv import load_dotenv\n\tload_dotenv()\n\tLOGLEVEL = os.environ.get(\"LOGLEVEL\", \"INFO\").upper()\n\tFORMAT = \"[%(asctime)s - %(levelname)s] %(message)s\"\n\tlogger = logging.getLogger(__name__)\n\tlogger.setLevel(LOGLEVEL)\n\thandler = logging.StreamHandler()\n\thandler.setLevel(LOGLEVEL)\n", "formatter = logging.Formatter(FORMAT)\n\thandler.setFormatter(formatter)\n\tlogger.addHandler(handler)\n"]}
{"filename": "src/gptravel/core/utils/general.py", "chunked_list": ["from typing import Any, Dict, List\n\tdef extract_keys_by_depth_from_json(json_obj: Dict[Any, Any], ndepth: int) -> List[Any]:\n\t    keys = []\n\t    def _extract_keys(json_obj: Dict[Any, Any], curr_depth: int) -> None:\n\t        for key, value in json_obj.items():\n\t            if curr_depth == ndepth:\n\t                keys.append(key)\n\t            elif isinstance(value, dict):\n\t                _extract_keys(value, curr_depth + 1)\n\t    _extract_keys(json_obj, 0)\n", "    return keys\n\tdef extract_inner_lists_from_json(json_obj: Dict[Any, Any]) -> List[Any]:\n\t    activities = []\n\t    if isinstance(json_obj, dict):\n\t        for value in json_obj.values():\n\t            activities.extend(extract_inner_lists_from_json(value))\n\t    elif isinstance(json_obj, list):\n\t        activities.extend(json_obj)\n\t    return activities\n"]}
{"filename": "src/gptravel/core/utils/regex_tool.py", "chunked_list": ["from typing import List\n\timport regex\n\tclass JsonExtractor:\n\t    def __init__(self) -> None:\n\t        self._pattern = regex.compile(r\"\\{(?:[^{}]|(?R))*\\}\")\n\t    def __call__(self, text: str) -> List[str]:\n\t        return self._pattern.findall(text)\n"]}
{"filename": "src/gptravel/core/travel_planner/token_manager.py", "chunked_list": ["from abc import ABC, abstractmethod\n\timport numpy as np\n\tfrom gptravel.core.io.loggerconfig import logger\n\tclass TokenManager(ABC):\n\t    @abstractmethod\n\t    def get_number_tokens(self, **kwargs) -> int:\n\t        pass\n\tclass ChatGptTokenManager(TokenManager):\n\t    def __init__(self) -> None:\n\t        self._intercept = 382.889143408946\n", "        self._ndays_coef = 37.3394858556992\n\t        self._distance_coef = -0.000176874844641827\n\t    def get_number_tokens(self, **kwargs) -> int:\n\t        logger.debug(\"Computing max number of tokens for chatgpt engine\")\n\t        logger.debug(\n\t            \"Token Manager inputs: n_days = {}, travel_distance = {}\".format(\n\t                kwargs[\"n_days\"], kwargs[\"distance\"]\n\t            )\n\t        )\n\t        n_tokens = int(\n", "            np.ceil(\n\t                max(\n\t                    self._intercept\n\t                    + self._ndays_coef * kwargs[\"n_days\"]\n\t                    + self._distance_coef * kwargs[\"distance\"],\n\t                    self._intercept,\n\t                )\n\t            )\n\t        )\n\t        logger.debug(\"Max number of tokens computed = {}\".format(n_tokens))\n", "        return n_tokens\n"]}
{"filename": "src/gptravel/core/travel_planner/prompt.py", "chunked_list": ["import json\n\tfrom abc import ABC, abstractmethod\n\tfrom collections import defaultdict\n\tfrom inspect import cleandoc\n\tfrom typing import Any, Dict\n\tclass Prompt(ABC):\n\t    def __init__(\n\t        self,\n\t        prompt: str,\n\t        departure_place: str,\n", "        destination_place: str,\n\t        n_travel_days: int,\n\t    ) -> None:\n\t        self._prompt = prompt\n\t        self._departure_place = departure_place\n\t        self._destination_place = destination_place\n\t        self._n_travel_days = n_travel_days\n\t    @property\n\t    def prompt(self) -> str:\n\t        return cleandoc(self._prompt)\n", "    @property\n\t    def departure_place(self) -> str:\n\t        return self._departure_place\n\t    @property\n\t    def destination_place(self) -> str:\n\t        return self._destination_place\n\t    @property\n\t    def n_travel_days(self) -> int:\n\t        return self._n_travel_days\n\t    @property\n", "    @abstractmethod\n\t    def json_keys(self) -> Dict[str, int]:\n\t        pass\n\tclass PlainTravelPrompt(Prompt):\n\t    def __init__(\n\t        self,\n\t        departure_place: str,\n\t        destination_place: str,\n\t        n_travel_days: int,\n\t        **kwargs,\n", "    ) -> None:\n\t        prompt = f\"\"\"Generate a JSON with inside a travel plan of {n_travel_days} days for a person who wants to visit {destination_place} from\n\t          {departure_place}. The structure of the JSON must be the following:\n\t          {{\"Day x\": {{\"City\": [\"activity 1\", \"activity2\",...], \"City\": [\"activity 1\", ...]}} , \"Day x+1\": {{\"City\": [...], \"City\": [...]}} }} \n\t          where City field is the city visited in the corresponding Day.\"\"\"\n\t        super().__init__(prompt, departure_place, destination_place, n_travel_days)\n\t    @property\n\t    def json_keys(self) -> Dict[str, int]:\n\t        return {\"day\": 0, \"city\": 1}\n\tclass ThematicTravelPrompt(Prompt):\n", "    def __init__(\n\t        self,\n\t        departure_place: str,\n\t        destination_place: str,\n\t        n_travel_days: int,\n\t        travel_theme: str,\n\t        **kwargs,\n\t    ) -> None:\n\t        prompt = f\"\"\"Generate a JSON with inside a travel plan of {n_travel_days} days for a person who wants to visit {destination_place} from\n\t          {departure_place}. The theme of the travel is {travel_theme}.\n", "          The structure of the JSON must be the following:\n\t          {{\"Day x\": {{\"City\": [\"activity 1\", \"activity2\",...], \"City\": [\"activity 1\", ...]}} , \"Day x+1\": {{\"City\": [...], \"City\": [...]}} }} \n\t          where City field is the city visited in the corresponding Day.\"\"\"\n\t        super().__init__(prompt, departure_place, destination_place, n_travel_days)\n\t    @property\n\t    def json_keys(self) -> Dict[str, int]:\n\t        return {\"day\": 0, \"city\": 1}\n\tclass CompletionTravelPrompt(Prompt):\n\t    def __init__(\n\t        self,\n", "        departure_place: str,\n\t        destination_place: str,\n\t        n_travel_days: int,\n\t        n_days_to_add: int,\n\t        travel_plan: Dict[Any, Any],\n\t        **kwargs,\n\t    ) -> None:\n\t        dumped_json = json.dumps(travel_plan)\n\t        prompt = f\"\"\"Rewrite the following travel plan where the destination is {destination_place} by adding {n_days_to_add} days:\n\t                     {dumped_json}\"\"\"\n", "        super().__init__(prompt, departure_place, destination_place, n_travel_days)\n\t    @property\n\t    def json_keys(self) -> Dict[str, int]:\n\t        return {\"day\": 0, \"city\": 1}\n\tclass PromptFactory:\n\t    def __init__(self) -> None:\n\t        pass\n\t    @staticmethod\n\t    def build_prompt(**kwargs) -> Prompt:\n\t        kwargs = defaultdict(str, kwargs)\n", "        if kwargs[\"complention_travel_plan\"]:\n\t            return CompletionTravelPrompt(**kwargs)\n\t        if kwargs[\"travel_theme\"]:\n\t            return ThematicTravelPrompt(**kwargs)\n\t        return PlainTravelPrompt(**kwargs)\n"]}
{"filename": "src/gptravel/core/travel_planner/openai_engine.py", "chunked_list": ["import json\n\tfrom abc import ABC, abstractmethod\n\tfrom typing import Any, Dict, Optional\n\timport openai\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.travel_planner.prompt import Prompt\n\tfrom gptravel.core.travel_planner.travel_engine import TravelEngine, TravelPlanJSON\n\tclass OpenAITravelEngine(TravelEngine, ABC):\n\t    def __init__(\n\t        self,\n", "        model: str,\n\t        max_tokens: int,\n\t        temperature: float,\n\t        top_p: float,\n\t        frequency_penalty: float,\n\t        presence_penalty: float,\n\t    ) -> None:\n\t        super().__init__()\n\t        assert (presence_penalty >= 0.0) & (presence_penalty <= 2.0)\n\t        assert (frequency_penalty >= 0.0) & (frequency_penalty <= 2.0)\n", "        self._model = model\n\t        self._temperature = temperature\n\t        self._max_tokens = max_tokens\n\t        self._top_p = top_p\n\t        self._frequency_penalty = frequency_penalty\n\t        self._presence_penalty = presence_penalty\n\t        self._finish_reason: Optional[str] = None\n\t        self._total_tokens: Optional[int] = None\n\t    @abstractmethod\n\t    def _openai_call(self, prompt: Prompt) -> Dict[Any, Any]:\n", "        pass\n\t    def get_travel_plan_json(self, prompt: Prompt) -> TravelPlanJSON:\n\t        response = self._openai_call(prompt)\n\t        message_response = response[\"choices\"][0][\"message\"][\"content\"]\n\t        logger.debug(\"Applying regex on OpenAI GPT response\")\n\t        json_parsed_list = self._regex(message_response)\n\t        if len(json_parsed_list) > 1:\n\t            logger.warning(\"Found multiple json in travel planner response\")\n\t        logger.debug(\"Regex complete successfully\")\n\t        try:\n", "            json_object = json.loads(json_parsed_list[0])\n\t        except json.decoder.JSONDecodeError:\n\t            json_object = json.loads(\n\t                r\"{}\".format(json_parsed_list[0].replace(\"'\", '\"'))\n\t            )\n\t        return TravelPlanJSON(\n\t            departure_place=prompt.departure_place,\n\t            destination_place=prompt.destination_place,\n\t            n_days=prompt.n_travel_days,\n\t            travel_plan_json=json_object,\n", "            json_keys_depth_map=prompt.json_keys,\n\t        )\n\t    @property\n\t    def finish_reason(self) -> Optional[str]:\n\t        return self._finish_reason\n\t    @property\n\t    def total_tokens(self) -> Optional[int]:\n\t        return self._total_tokens\n\tclass ChatGPTravelEngine(OpenAITravelEngine):\n\t    def __init__(\n", "        self,\n\t        temperature: float = 1.0,\n\t        top_p: float = 1.0,\n\t        frequency_penalty: float = 0.0,\n\t        presence_penalty: float = 0.0,\n\t        number_chat_completions: int = 1,\n\t        max_tokens: int = 280,\n\t    ) -> None:\n\t        model = \"gpt-3.5-turbo\"\n\t        super().__init__(\n", "            model, max_tokens, temperature, top_p, frequency_penalty, presence_penalty\n\t        )\n\t        self._max_tokens = min(self._max_tokens, 4096)  # max token for this engine\n\t        self._n = number_chat_completions\n\t    def _openai_call(self, prompt: Prompt) -> Dict[Any, Any]:\n\t        logger.debug(\"Fetching travel plan with ChatGpt engine API: Start\")\n\t        api_output = openai.ChatCompletion.create(\n\t            model=self._model,\n\t            messages=[\n\t                {\"role\": \"system\", \"content\": \"You are an expert travel planner.\"},\n", "                {\"role\": \"user\", \"content\": prompt.prompt},\n\t            ],\n\t            temperature=self._temperature,\n\t            max_tokens=self._max_tokens,\n\t            top_p=self._top_p,\n\t            presence_penalty=self._presence_penalty,\n\t            frequency_penalty=self._frequency_penalty,\n\t            n=self._n,\n\t        )\n\t        logger.debug(\"Fetching travel plan with ChatGpt engine API: Complete\")\n", "        self._finish_reason = api_output[\"choices\"][0][\"finish_reason\"]\n\t        self._total_tokens = api_output[\"usage\"][\"total_tokens\"]\n\t        logger.debug(\"OpenAI API: finish reason= {}\".format(self._finish_reason))\n\t        logger.debug(\"OpenAI API: total tokens = {}\".format(self._total_tokens))\n\t        return api_output\n\tclass CompletionGPTravelEngine(OpenAITravelEngine):\n\t    def __init__(\n\t        self,\n\t        model: str,\n\t        temperature: float = 1.0,\n", "        top_p: float = 1.0,\n\t        frequency_penalty: float = 0.0,\n\t        presence_penalty: float = 0.0,\n\t        max_tokens: int = 280,\n\t    ) -> None:\n\t        super().__init__(\n\t            model, max_tokens, temperature, top_p, frequency_penalty, presence_penalty\n\t        )\n\t    def _openai_call(self, prompt: Prompt) -> Dict[Any, Any]:\n\t        logger.debug(\"Fetching travel plan with ChatGpt engine API: Start\")\n", "        api_output = openai.Completion.create(\n\t            model=self._model,\n\t            prompt=prompt.prompt,\n\t            temperature=self._temperature,\n\t            max_tokens=self._max_tokens,\n\t            top_p=self._top_p,\n\t            presence_penalty=self._presence_penalty,\n\t            frequency_penalty=self._frequency_penalty,\n\t        )\n\t        logger.debug(\"Fetching travel plan with ChatGpt engine API: Complete\")\n", "        self._finish_reason = api_output[\"choices\"][0][\"finish_reason\"]\n\t        self._total_tokens = api_output[\"usage\"][\"total_tokens\"]\n\t        logger.debug(\"OpenAI API: finish reason= {}\".format(self._finish_reason))\n\t        logger.debug(\"OpenAI API: total tokens = {}\".format(self._total_tokens))\n\t        return api_output\n"]}
{"filename": "src/gptravel/core/travel_planner/travel_engine.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tfrom typing import Any, Dict, List\n\tfrom gptravel.core.travel_planner.prompt import Prompt\n\tfrom gptravel.core.utils.general import (\n\t    extract_inner_lists_from_json,\n\t    extract_keys_by_depth_from_json,\n\t)\n\tfrom gptravel.core.utils.regex_tool import JsonExtractor\n\tclass TravelPlanJSON:\n\t    def __init__(\n", "        self,\n\t        departure_place: str,\n\t        destination_place: str,\n\t        n_days: int,\n\t        travel_plan_json: Dict[Any, Any],\n\t        json_keys_depth_map: Dict[str, int],\n\t        **kwargs\n\t    ) -> None:\n\t        self._n_days = n_days\n\t        self._departure_place = departure_place\n", "        self._destination_place = destination_place\n\t        self._travel_plan = travel_plan_json\n\t        self._keys_map = json_keys_depth_map\n\t    @property\n\t    def departure_place(self) -> str:\n\t        return self._departure_place\n\t    @property\n\t    def destination_place(self) -> str:\n\t        return self._destination_place\n\t    @property\n", "    def n_days(self) -> int:\n\t        return self._n_days\n\t    @property\n\t    def travel_plan(self) -> Dict[Any, Any]:\n\t        return self._travel_plan\n\t    @property\n\t    def keys_map(self) -> Dict[str, int]:\n\t        return self._keys_map\n\t    @property\n\t    def travel_activities(self) -> List[str]:\n", "        return extract_inner_lists_from_json(self._travel_plan)\n\t    def get_key_values_by_depth(self, depth: int) -> List[Any]:\n\t        return extract_keys_by_depth_from_json(json_obj=self._travel_plan, ndepth=depth)\n\t    def get_key_values_by_name(self, key_name: str) -> List[Any]:\n\t        try:\n\t            return self.get_key_values_by_depth(self._keys_map[key_name])\n\t        except KeyError:\n\t            return []\n\t    @property\n\t    def travel_cities(self) -> List[str]:\n", "        return self.get_key_values_by_name(\"city\")\n\tclass TravelEngine(ABC):\n\t    def __init__(self) -> None:\n\t        self._regex = JsonExtractor()\n\t    @abstractmethod\n\t    def get_travel_plan_json(self, prompt: Prompt) -> TravelPlanJSON:\n\t        pass\n"]}
{"filename": "src/gptravel/core/services/score_builder.py", "chunked_list": ["from gptravel.core.services.engine.classifier import TextClassifier\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.core.services.scorer import (\n\t    ActivitiesDiversityScorer,\n\t    CitiesCountryScorer,\n\t    DayGenerationScorer,\n\t    OptimizedItineraryScorer,\n\t    TravelPlanScore,\n\t)\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n", "class ScorerOrchestrator:\n\t    def __init__(self, geocoder: GeoCoder, text_classifier: TextClassifier) -> None:\n\t        self._scorers = [\n\t            ActivitiesDiversityScorer(text_classifier),\n\t            DayGenerationScorer(),\n\t            CitiesCountryScorer(geolocator=geocoder),\n\t            OptimizedItineraryScorer(geolocator=geocoder),\n\t        ]\n\t    def run(\n\t        self, travel_plan_json: TravelPlanJSON, scores_container: TravelPlanScore\n", "    ) -> None:\n\t        for scorer in self._scorers:\n\t            scorer.score(\n\t                travel_plan=travel_plan_json, travel_plan_scores=scores_container\n\t            )\n"]}
{"filename": "src/gptravel/core/services/config.py", "chunked_list": ["ACTIVITIES_LABELS = [\n\t    \"mountain\",\n\t    \"sea\",\n\t    \"museum\",\n\t    \"monument\",\n\t    \"food\",\n\t    \"relax\",\n\t    \"sport\",\n\t    \"culture\",\n\t    \"shopping\",\n", "    \"transport\",\n\t]\n"]}
{"filename": "src/gptravel/core/services/utils.py", "chunked_list": ["import math\n\tfrom typing import Any, List, Union\n\tfrom gptravel.core.services.engine.classifier import ZeroShotTextClassifier\n\tdef theil_diversity_entropy_index(groups: List[Union[float, int]]) -> float:\n\t    total_population = sum(groups)\n\t    proportions = [group_size / total_population for group_size in groups]\n\t    entropy = -sum(\n\t        [\n\t            proportion * math.log(proportion)\n\t            for proportion in proportions\n", "            if proportion != 0\n\t        ]\n\t    )\n\t    max_entropy = math.log(len(groups))\n\t    return (max_entropy - entropy) / max_entropy\n\tdef weighted_average(\n\t    values: List[Union[int, float]], weights: List[Union[int, float]]\n\t) -> float:\n\t    assert len(values) == len(weights)\n\t    return sum([values[i] * weights[i] for i in range(len(values))]) / sum(weights)\n", "def is_location_a_country(location: str) -> bool:\n\t    country_value = \"country\"\n\t    key_with_max_value = \"\"\n\t    if \"milan\" not in location.lower():\n\t        classifier = ZeroShotTextClassifier(False)\n\t        labels = [country_value, \"city\", \"continent\"]\n\t        prediction = classifier.predict(\n\t            input_text_list=[location], label_classes=labels\n\t        )\n\t        key_with_max_value = max(\n", "            prediction[location], key=lambda key: prediction[location][key]\n\t        )\n\t    return True if key_with_max_value == country_value else False\n\tdef remove_consecutive_duplicates(input_list: List[Any]) -> List[Any]:\n\t    return [\n\t        elem for i, elem in enumerate(input_list) if i == 0 or input_list[i - 1] != elem\n\t    ]\n"]}
{"filename": "src/gptravel/core/services/filters.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tclass Filter(ABC):\n\t    def __init__(self, **kwargs):\n\t        pass\n\t    @abstractmethod\n\t    def filter(self, travel_plan: TravelPlanJSON) -> None:\n\t        pass\n\tclass DeparturePlaceFilter(Filter):\n", "    def filter(self, travel_plan: TravelPlanJSON) -> None:\n\t        logger.debug(\"DeparturePlaceFilter: Start\")\n\t        departure_place = travel_plan.departure_place.lower()\n\t        # if the departure place is present in the travel plan then remove it\n\t        if departure_place in [city.lower() for city in travel_plan.travel_cities]:\n\t            logger.debug(\"Found {} inside the travel plan\".format(departure_place))\n\t            day_depth = travel_plan.keys_map[\"day\"]\n\t            if day_depth == 0:\n\t                days_to_drop = []\n\t                for day in travel_plan.travel_plan.keys():\n", "                    key_to_remove = [\n\t                        city\n\t                        for city in travel_plan.travel_plan[day].keys()\n\t                        if city.lower() == departure_place\n\t                    ]\n\t                    if key_to_remove:\n\t                        logger.debug(\n\t                            \"Removed {} from the travel plan for {}\".format(\n\t                                departure_place, day\n\t                            )\n", "                        )\n\t                        del travel_plan.travel_plan[day][key_to_remove[0]]\n\t                    # if the day container is empty then remove it\n\t                    if travel_plan.travel_plan[day] == {}:\n\t                        days_to_drop.append(day)\n\t                        logger.debug(\n\t                            \"Removed {} completely from the travel plan\".format(day)\n\t                        )\n\t                if days_to_drop:\n\t                    for day_to_delete in days_to_drop:\n", "                        del travel_plan.travel_plan[day_to_delete]\n\t                    # fix the order of the\n\t                    day_first_word = days_to_drop[0].split(\" \")[0]\n\t                    day_keys = list(travel_plan.travel_plan.keys())\n\t                    n = 1\n\t                    for old_key in day_keys:\n\t                        new_key = day_first_word + \" \" + str(n)\n\t                        travel_plan.travel_plan[new_key] = travel_plan.travel_plan.pop(\n\t                            old_key\n\t                        )\n", "                        n += 1\n\t            else:\n\t                key_to_remove = [\n\t                    city\n\t                    for city in travel_plan.travel_plan.keys()\n\t                    if city.lower() == departure_place\n\t                ][0]\n\t                del travel_plan.travel_plan[key_to_remove]\n\t        logger.debug(\"DeparturePlaceFilter: End\")\n"]}
{"filename": "src/gptravel/core/services/scorer.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tfrom typing import Any, Dict, Optional, Union\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.services.config import ACTIVITIES_LABELS\n\tfrom gptravel.core.services.engine.classifier import TextClassifier\n\tfrom gptravel.core.services.engine.tsp_solver import TSPSolver\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.core.services.utils import (\n\t    remove_consecutive_duplicates,\n\t    theil_diversity_entropy_index,\n", "    weighted_average,\n\t)\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tclass TravelPlanScore:\n\t    def __init__(self) -> None:\n\t        self._score_map: Dict[str, Dict[str, Union[float, int]]] = {}\n\t        self._score_value_key = \"score_value\"\n\t        self._score_weight_key = \"score_weight\"\n\t        self._required_keys = set([self._score_value_key, self._score_weight_key])\n\t    def add_score(self, score_type: str, score_dict: Dict[str, Any]) -> None:\n", "        assert set(score_dict.keys()).intersection(self._required_keys) == set(\n\t            self._required_keys\n\t        )\n\t        self._score_map.update({score_type: score_dict})\n\t    @property\n\t    def score_value_key(self) -> str:\n\t        return self._score_value_key\n\t    @property\n\t    def score_weight_key(self) -> str:\n\t        return self._score_weight_key\n", "    @property\n\t    def score_map(self) -> Dict[str, Dict[str, Union[float, int]]]:\n\t        return self._score_map\n\t    @property\n\t    def weighted_score(self) -> Optional[float]:\n\t        if self._score_map:\n\t            weights = [\n\t                score[self._score_weight_key] for score in self._score_map.values()\n\t            ]\n\t            values = [\n", "                score[self._score_value_key] for score in self._score_map.values()\n\t            ]\n\t            return weighted_average(values=values, weights=weights)\n\t        return None\n\tclass ScoreService(ABC):\n\t    def __init__(self, service_name: str, score_weight: float) -> None:\n\t        self._service_name = service_name\n\t        self.score_weight = score_weight\n\t    @abstractmethod\n\t    def score(\n", "        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n\t    ) -> None:\n\t        pass\n\t    @property\n\t    def score_weight(self) -> float:\n\t        return self._score_weight\n\t    @score_weight.setter\n\t    def score_weight(self, score_weight: float) -> None:\n\t        assert (score_weight >= 0.0) & (score_weight <= 1.0)\n\t        self._score_weight = score_weight\n", "    @property\n\t    def service_name(self) -> str:\n\t        return self._service_name\n\tclass ActivitiesDiversityScorer(ScoreService):\n\t    def __init__(\n\t        self, text_classifier: TextClassifier, score_weight: float = 0.8\n\t    ) -> None:\n\t        service_name = \"Activities Variety\"\n\t        super().__init__(service_name, score_weight)\n\t        self._classifier = text_classifier\n", "        self._activities_labels = ACTIVITIES_LABELS\n\t    def score(\n\t        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n\t    ) -> None:\n\t        logger.debug(\"ActivitiesDiversityScorer: Start\")\n\t        activities_list = travel_plan.travel_activities\n\t        labeled_activities = self._classifier.predict(\n\t            input_text_list=activities_list, label_classes=self._activities_labels\n\t        )\n\t        aggregated_scores = {\n", "            key: sum(item[key] for item in labeled_activities.values())\n\t            for key in self._activities_labels\n\t        }\n\t        sum_scores = sum(aggregated_scores.values())\n\t        aggregated_scores_normalized = {\n\t            key: item / sum_scores for key, item in aggregated_scores.items()\n\t        }\n\t        score = 1.0 - theil_diversity_entropy_index(\n\t            list(aggregated_scores_normalized.values())\n\t        )\n", "        logger.debug(\"ActivitiesDiversityScorer: score value = {}\".format(score))\n\t        logger.debug(\n\t            \"ActivitiesDiversityScorer: score weight = {}\".format(self._score_weight)\n\t        )\n\t        travel_plan_scores.add_score(\n\t            score_type=self._service_name,\n\t            score_dict={\n\t                travel_plan_scores.score_value_key: score,\n\t                travel_plan_scores.score_weight_key: self._score_weight,\n\t                \"activities_distribution\": aggregated_scores_normalized,\n", "                \"labeled_activities\": labeled_activities,\n\t            },\n\t        )\n\t        logger.debug(\"ActivitiesDiversityScorer: Complete\")\n\tclass DayGenerationScorer(ScoreService):\n\t    def __init__(self, score_weight: float = 0.4, day_key: str = \"Day\") -> None:\n\t        service_name = \"Day Coherence\"\n\t        super().__init__(service_name, score_weight)\n\t        self._day_key = day_key\n\t    def score(\n", "        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n\t    ) -> None:\n\t        logger.debug(\"DayGenerationScorer: Start\")\n\t        required_days_by_the_user = travel_plan.n_days\n\t        travel_plan_day_list = list(\n\t            set(travel_plan.get_key_values_by_name(self._day_key.lower()))\n\t        )\n\t        travel_plan_days = [\n\t            int(item.split(self._day_key)[-1]) for item in travel_plan_day_list\n\t        ]\n", "        min_day = min(travel_plan_days)\n\t        tot_planned_days = len(travel_plan_days)\n\t        score = (\n\t            1.0\n\t            - abs(required_days_by_the_user - tot_planned_days)\n\t            / required_days_by_the_user\n\t        )\n\t        logger.debug(\"DayGenerationScorer: score value = {}\".format(score))\n\t        logger.debug(\n\t            \"DayGenerationScorer: score weight = {}\".format(self._score_weight)\n", "        )\n\t        if score < 1:\n\t            self.score_weight = min(self.score_weight * 1.5, 1)\n\t            logger.debug(\n\t                \"DayGenerationScorer: modified score weight = {}\".format(\n\t                    self._score_weight\n\t                )\n\t            )\n\t        expected_list = [min_day + item for item in range(required_days_by_the_user)]\n\t        extra_days_in_travel = set(travel_plan_days) - set(expected_list).intersection(\n", "            travel_plan_days\n\t        )\n\t        missing_days_in_travel = set(expected_list) - set(expected_list).intersection(\n\t            travel_plan_days\n\t        )\n\t        if len(missing_days_in_travel):\n\t            logger.debug(\n\t                \"DayGenerationScorer: missing days in travel plan = {}\".format(\n\t                    missing_days_in_travel\n\t                )\n", "            )\n\t        travel_plan_scores.add_score(\n\t            score_type=self._service_name,\n\t            score_dict={\n\t                travel_plan_scores.score_value_key: score,\n\t                travel_plan_scores.score_weight_key: self._score_weight,\n\t                \"misaligned_days\": {\n\t                    \"extra_days\": list(extra_days_in_travel),\n\t                    \"missing_days\": list(missing_days_in_travel),\n\t                },\n", "            },\n\t        )\n\t        logger.debug(\"DayGenerationScorer: End\")\n\tclass CitiesCountryScorer(ScoreService):\n\t    def __init__(self, geolocator: GeoCoder, score_weight: float = 1.0) -> None:\n\t        service_name = \"City Countries\"\n\t        super().__init__(service_name, score_weight)\n\t        self._geolocator = geolocator\n\t    def score(\n\t        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n", "    ) -> None:\n\t        logger.debug(\"CitiesCountryScorer: Start\")\n\t        # remove departure place: check the consistence among the visiting cities\n\t        unique_cities = list(\n\t            set(travel_plan.travel_cities) - set(travel_plan.departure_place)\n\t        )\n\t        # Check that all the cities are in the same emisphere as first start element\n\t        weight_for_latitude = 0.4\n\t        latitude_signs = [\n\t            1 if self._geolocator.location_coordinates(city)[\"lat\"] > 0 else -1\n", "            for city in unique_cities\n\t        ]\n\t        latitude_score = abs(sum(latitude_signs)) / len(unique_cities)\n\t        # Check cities are in the same country of the destination place\n\t        destination_country = self._geolocator.country_from_location_name(\n\t            location_name=travel_plan.destination_place\n\t        )\n\t        logger.debug(\n\t            \"CitiesCountryScorer: computed destination country = {}\".format(\n\t                destination_country\n", "            )\n\t        )\n\t        city_countries = [\n\t            self._geolocator.country_from_location_name(city) for city in unique_cities\n\t        ]\n\t        logger.debug(\"CitiesCountryScorer: analyzed cities = {}\".format(unique_cities))\n\t        logger.debug(\n\t            \"CitiesCountryScorer: predicted countries = {}\".format(city_countries)\n\t        )\n\t        scores = [\n", "            1 if city_country == destination_country else 0\n\t            for city_country in city_countries\n\t        ]\n\t        country_score = sum(scores) / len(unique_cities)\n\t        weight_for_country = 0.6\n\t        score = weighted_average(\n\t            values=[latitude_score, country_score],\n\t            weights=[weight_for_latitude, weight_for_country],\n\t        )\n\t        logger.debug(\"CitiesCountryScorer: score value = {}\".format(score))\n", "        logger.debug(\n\t            \"CitiesCountryScorer: score weight = {}\".format(self._score_weight)\n\t        )\n\t        travel_plan_scores.add_score(\n\t            score_type=self._service_name,\n\t            score_dict={\n\t                travel_plan_scores.score_value_key: score,\n\t                travel_plan_scores.score_weight_key: self._score_weight,\n\t                \"latitude_check\": {\n\t                    \"weight\": weight_for_latitude,\n", "                    \"score\": latitude_score,\n\t                },\n\t                \"country_check\": {\"weight\": weight_for_country, \"score\": country_score},\n\t                \"city_countries\": city_countries,\n\t                \"latitude_signs\": latitude_signs,\n\t                \"destination_country\": destination_country,\n\t            },\n\t        )\n\t        logger.debug(\"CitiesCountryScorer: End\")\n\tclass OptimizedItineraryScorer(ScoreService):\n", "    def __init__(self, geolocator: GeoCoder, score_weight: float = 1.0) -> None:\n\t        service_name = \"City Countries\"\n\t        super().__init__(service_name, score_weight)\n\t        self._geolocator = geolocator\n\t    def score(\n\t        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n\t    ) -> None:\n\t        cities = remove_consecutive_duplicates(\n\t            [city.lower() for city in travel_plan.travel_cities]\n\t        )\n", "        if len(cities) > 2:\n\t            logger.debug(\"CitiesCountryScorer: Start\")\n\t            departure_place = travel_plan.departure_place\n\t            cities = cities[1:] if cities[0] == departure_place.lower() else cities\n\t            cities = cities[:-1] if cities[-1] == departure_place.lower() else cities\n\t            logger.debug(\n\t                \"CitiesCountryScorer: cities eligible for optimiaztion computation =  {}\".format(\n\t                    cities\n\t                )\n\t            )\n", "            # the scorer evaluates the itinerary only if there are\n\t            # more than two different visited city excluded the departure place\n\t            if len(set(cities)) > 2:\n\t                open_problem = True if cities[0] != cities[-1] else False\n\t                cities = cities[:-1] if not open_problem else cities\n\t                solver = TSPSolver(geocoder=self._geolocator)\n\t                optimal_solution, optimal_distance = solver.solve(cities, open_problem)\n\t                current_distance = sum(\n\t                    [solver.distance_matrix[i, i + 1] for i in range(len(cities) - 1)]\n\t                )\n", "                if not open_problem:\n\t                    current_distance += solver.distance_matrix[0, -1]\n\t                score = optimal_distance / current_distance\n\t                logger.debug(\"CitiesCountryScorer: score value = {}\".format(score))\n\t                logger.debug(\n\t                    \"CitiesCountryScorer: score weight = {}\".format(self._score_weight)\n\t                )\n\t                logger.debug(\n\t                    \"CitiesCountryScorer: current distance = {}\".format(\n\t                        current_distance\n", "                    )\n\t                )\n\t                logger.debug(\n\t                    \"CitiesCountryScorer: optimal distance = {}\".format(\n\t                        optimal_distance\n\t                    )\n\t                )\n\t                logger.debug(\n\t                    \"CitiesCountryScorer: optimal solution = {}\".format(\n\t                        optimal_solution\n", "                    )\n\t                )\n\t                travel_plan_scores.add_score(\n\t                    score_type=self._service_name,\n\t                    score_dict={\n\t                        travel_plan_scores.score_value_key: score,\n\t                        travel_plan_scores.score_weight_key: self._score_weight,\n\t                        \"tsp_solution\": {\n\t                            \"solution\": optimal_solution,\n\t                            \"distance\": optimal_distance,\n", "                            \"open_problem\": open_problem,\n\t                        },\n\t                        \"itinerary\": {\n\t                            \"solution\": cities,\n\t                            \"distance\": current_distance,\n\t                        },\n\t                    },\n\t                )\n\t                logger.debug(\"CitiesCountryScorer: End\")\n\t            else:\n", "                logger.debug(\"CitiesCountryScorer: End -- No Computation needed\")\n"]}
{"filename": "src/gptravel/core/services/geocoder.py", "chunked_list": ["import os\n\tfrom functools import partial\n\tfrom typing import Dict, List, Optional\n\tfrom geopy import Location\n\tfrom geopy.distance import geodesic as GRC\n\tfrom geopy.extra.rate_limiter import RateLimiter\n\tfrom geopy.geocoders import Photon\n\tfrom gptravel.core.io.loggerconfig import logger\n\tLOCATION_CACHE: Dict[str, Location] = {}\n\tclass GeoCoder:\n", "    def __init__(self, language: str = \"en\") -> None:\n\t        self._geocoder = partial(\n\t            Photon().geocode,\n\t            language=language,\n\t        )\n\t        if os.getenv(\"ENV\", \"PROD\") == \"TEST\":\n\t            self._geocoder = partial(\n\t                RateLimiter(Photon().geocode, min_delay_seconds=1.2), language=language\n\t            )\n\t    def _query(self, location_name: str) -> Optional[Location]:\n", "        loc_name = location_name.lower()\n\t        logger.debug(\"Querying coordinates for {}\".format(loc_name))\n\t        if loc_name in LOCATION_CACHE:\n\t            logger.debug(\"Using cached coordinates\")\n\t            return LOCATION_CACHE[loc_name]\n\t        logger.debug(\"Downloading new Location for {}: Start\".format(loc_name))\n\t        qry_obj = self._geocoder(location_name)\n\t        logger.debug(\"Downloading new Location for {}: Complete\".format(loc_name))\n\t        LOCATION_CACHE[loc_name] = qry_obj\n\t        return qry_obj\n", "    def _location_type(self, location_name: str) -> Optional[List[str]]:\n\t        fetched_location = self._query(location_name)\n\t        location_type = None\n\t        if fetched_location is not None:\n\t            location_type = fetched_location.raw[\"properties\"][\"type\"]\n\t        logger.debug(\n\t            \"GeoCoder: type for {} is: {}\".format(location_name, location_type)\n\t        )\n\t        return location_type\n\t    def country_from_location_name(self, location_name: str) -> Optional[str]:\n", "        fetched_location = self._query(location_name)\n\t        if fetched_location:\n\t            return fetched_location.raw[\"properties\"][\"country\"]\n\t        return fetched_location\n\t    def location_coordinates(self, location_name: str) -> Dict[str, Optional[float]]:\n\t        fetched_location = self._query(location_name)\n\t        if fetched_location:\n\t            return {\"lat\": fetched_location.latitude, \"lon\": fetched_location.longitude}\n\t        return {\"lat\": None, \"lon\": None}\n\t    def location_distance(self, location_name_1: str, location_name_2: str) -> float:\n", "        if location_name_1.lower() == location_name_2.lower():\n\t            return 0.0\n\t        location1_coords = self.location_coordinates(location_name_1)\n\t        location2_coords = self.location_coordinates(location_name_2)\n\t        return GRC(\n\t            (location1_coords[\"lat\"], location1_coords[\"lon\"]),\n\t            (location2_coords[\"lat\"], location2_coords[\"lon\"]),\n\t        ).km\n\t    def is_location_country_city_state(self, location_name: str) -> bool:\n\t        location_type = self._location_type(location_name)\n", "        if location_type:\n\t            return location_type in [\"country\", \"state\", \"city\"]\n\t        return False\n\t    def is_a_country(self, location_name: str) -> bool:\n\t        location_type = self._location_type(location_name)\n\t        if location_type:\n\t            return location_type in [\"country\", \"state\"]\n\t        return False\n"]}
{"filename": "src/gptravel/core/services/checker.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\tclass Checker(ABC):\n\t    @abstractmethod\n\t    def check(self, travel_plan: TravelPlanJSON) -> bool:\n\t        pass\n\tclass ExistingDestinationsChecker(Checker):\n\t    def __init__(self, geolocator: GeoCoder) -> None:\n", "        self._geolocator = geolocator\n\t    def check(self, travel_plan: TravelPlanJSON) -> bool:\n\t        city_list = list(set(travel_plan.travel_cities))\n\t        logger.debug(\"Check the existence of cities in the generated travel\")\n\t        logger.debug(\"Check performed on cities: {}\".format(city_list))\n\t        existing_cities = [\n\t            True\n\t            if self._geolocator.location_coordinates(city)[\"lat\"] is not None\n\t            else False\n\t            for city in city_list\n", "        ]\n\t        all_exists = all(existing_cities)\n\t        if all_exists:\n\t            logger.debug(\"Check passed\")\n\t        else:\n\t            logger.warning(\"Check not passed\")\n\t        return all_exists\n\tclass DaysChecker(Checker):\n\t    def __init__(self, day_key: str = \"Day\") -> None:\n\t        self._travel_days = 0\n", "        self._day_key = day_key\n\t    @property\n\t    def travel_days(self) -> int:\n\t        return self._travel_days\n\t    def check(self, travel_plan: TravelPlanJSON) -> bool:\n\t        user_n_days = travel_plan.n_days\n\t        logger.debug(\"Check the number of days generated in the travel plan\")\n\t        self._travel_days = len(\n\t            set(travel_plan.get_key_values_by_name(self._day_key.lower()))\n\t        )\n", "        check = user_n_days == self._travel_days\n\t        if check:\n\t            logger.debug(\"Check passed\")\n\t        else:\n\t            missing_days = user_n_days - self._travel_days\n\t            logger.warning(\"Found missing {} days\".format(missing_days))\n\t        return check\n"]}
{"filename": "src/gptravel/core/services/engine/exception.py", "chunked_list": ["class HuggingFaceError(Exception):\n\t    pass\n"]}
{"filename": "src/gptravel/core/services/engine/tsp_solver.py", "chunked_list": ["from typing import List, Tuple\n\timport numpy as np\n\tfrom python_tsp.exact import solve_tsp_dynamic_programming\n\tfrom python_tsp.heuristics import solve_tsp_simulated_annealing\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.services.geocoder import GeoCoder\n\tclass TSPSolver:\n\t    def __init__(self, geocoder: GeoCoder) -> None:\n\t        self._geocoder = geocoder\n\t        self._distance_matrix: np.ndarray = np.empty([2, 2])\n", "    @property\n\t    def distance_matrix(self) -> np.ndarray:\n\t        return self._distance_matrix\n\t    def solve(\n\t        self, cities: List[str], open_problem: bool = False\n\t    ) -> Tuple[List[str], float]:\n\t        if len(cities) > 1:\n\t            logger.debug(\"TSP solver: start\")\n\t            logger.debug(\"TSP solver: solve the problem for cities = {}\".format(cities))\n\t            logger.debug(\"TSP solver: open problem = {}\".format(open_problem))\n", "            if len(cities) < 10:\n\t                solver = solve_tsp_dynamic_programming\n\t                logger.debug(\"TSP solver: use dynamic programming\")\n\t            else:\n\t                solver = solve_tsp_simulated_annealing\n\t                logger.debug(\"TSP solver: use simulated annealing\")\n\t            self._distance_matrix = np.array(\n\t                [\n\t                    [\n\t                        0.0\n", "                        if i == j\n\t                        else self._geocoder.location_distance(cities[i], cities[j])\n\t                        for j in range(len(cities))\n\t                    ]\n\t                    for i in range(len(cities))\n\t                ]\n\t            )\n\t            dist_mat = np.copy(self._distance_matrix)\n\t            if open_problem:\n\t                dist_mat[:, 0] = 0.0\n", "            solution_indexes, solution_distance = solver(distance_matrix=dist_mat)\n\t            return [cities[index] for index in solution_indexes], solution_distance\n\t        logger.debug(\"TSP solver: only one city provided -- no computation needed\")\n\t        return cities, 0.0\n"]}
{"filename": "src/gptravel/core/services/engine/classifier.py", "chunked_list": ["import os\n\tfrom abc import ABC, abstractmethod\n\tfrom typing import Any, Dict, List\n\timport requests\n\tfrom dotenv import load_dotenv\n\tfrom gptravel.core.io.loggerconfig import logger\n\tfrom gptravel.core.services.engine.exception import HuggingFaceError\n\tload_dotenv()\n\tclass TextClassifier(ABC):\n\t    def __init__(self, multi_label: bool) -> None:\n", "        self.multi_label = multi_label\n\t    @property\n\t    def multi_label(self) -> bool:\n\t        return self._multi_label\n\t    @multi_label.setter\n\t    def multi_label(self, multi_label: bool) -> None:\n\t        self._multi_label = multi_label\n\t    @abstractmethod\n\t    def predict(\n\t        self, input_text_list: List[str], label_classes: List[str]\n", "    ) -> Dict[str, Dict[str, float]]:\n\t        pass\n\tclass ZeroShotTextClassifier(TextClassifier):\n\t    def __init__(self, multi_label: bool = True) -> None:\n\t        super().__init__(multi_label)\n\t        self._api_token = os.getenv(\"HUGGING_FACE_KEY\")\n\t        self._api_url = (\n\t            \"https://api-inference.huggingface.co/models/facebook/bart-large-mnli\"\n\t        )\n\t    def _query(self, payload: Dict[str, Any]) -> Dict[str, Any]:\n", "        headers = {\"Authorization\": f\"Bearer {self._api_token}\"}\n\t        logger.debug(\"HuggingFace API fetching response: start\")\n\t        response = requests.post(self._api_url, headers=headers, json=payload).json()\n\t        logger.debug(\"HuggingFace API fetching response: complete\")\n\t        return response\n\t    def predict(\n\t        self,\n\t        input_text_list: List[str],\n\t        label_classes: List[str],\n\t    ) -> Dict[str, Dict[str, float]]:\n", "        payload = {\n\t            \"inputs\": input_text_list,\n\t            \"parameters\": {\n\t                \"candidate_labels\": label_classes,\n\t                \"multi_label\": self._multi_label,\n\t            },\n\t        }\n\t        try:\n\t            response = self._query(payload=payload)\n\t            return {\n", "                item[\"sequence\"]: {\n\t                    label: float(value)\n\t                    for label, value in zip(item[\"labels\"], item[\"scores\"])\n\t                }\n\t                for item in response\n\t            }\n\t        except:\n\t            logger.error(\"Hugging Face classifier: error in retrieving API response\")\n\t            raise HuggingFaceError\n"]}
