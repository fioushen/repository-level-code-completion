{"filename": "__init__.py", "chunked_list": ["bl_info = {\n\t    \"name\": \"Live Save 2\",\n\t    \"description\": \"Automatically saves the project with a timestamp when changes are made\",\n\t    \"author\": \"Your Name\",\n\t    \"version\": (0, 1),\n\t    \"blender\": (3, 3, 0),\n\t    \"location\": \"View3D > UI panel\",\n\t    \"warning\": \"Experimental\",\n\t    \"category\": \"System\"\n\t}\n", "from . import Live_Addon\n\tdef register():\n\t    Live_Addon.register()\n\tdef unregister():\n\t    Live_Addon.unregister()\n"]}
{"filename": "Live_Addon/__init__.py", "chunked_list": ["import re\n\tfrom . import props\n\tfrom . import ops\n\tfrom . import handlers\n\tfrom . import ui\n\tfrom . import timer\n\tfrom . import utils\n\timport bpy\n\timport os\n\timport shutil\n", "def register():\n\t    props.register()\n\t    ops.register()\n\t    timer.register()\n\t    handlers.register()\n\t    ui.register()\n\tdef unregister():\n\t    ui.unregister()\n\t    handlers.unregister()\n\t    timer.unregister()\n", "    ops.unregister()\n\t    file_path12 = bpy.context.window_manager.my_addon_props.file_path\n\t    version_folder_path = bpy.context.window_manager.my_addon_props.file_path_version\n\t    blend_match = r\"\\.blend\"\n\t    matched_blend = re.search(blend_match, file_path12)\n\t    # when it is not a folder and it is a blend file\n\t    if not os.path.isdir(file_path12) and matched_blend and os.path.exists(file_path12):\n\t        os.remove(file_path12)\n\t        if os.path.exists(version_folder_path):\n\t            shutil.rmtree(version_folder_path)\n", "    props.unregister()\n"]}
{"filename": "Live_Addon/utils/comparison.py", "chunked_list": ["import bpy\n\tfrom .. import props\n\timport numpy as np\n\timport sqlite3\n\tdef check_undo_redo(context):\n\t    print(\"i called \")\n\t    wm = context.window_manager\n\t    current_count = bpy.context.window_manager.my_addon_props.exec_count\n\t    print(\"current exec\")\n\t    print(current_count)\n", "    previous_count = wm.get(\"_previous_count\", 0)\n\t    if current_count != previous_count:\n\t        print(\"ungleich\")\n\t        wm[\"_previous_count\"] = current_count\n\t        print(\"setting current\")\n\t        return True\n\t    return False\n\tmy_dict = {}\n\tstored = my_dict.get(\"stored_data\", {})\n\tdef compare_blend_data():\n", "    global stored\n\t    if bpy.context.window_manager.my_addon_props.mouse_detect:\n\t        data_blocks = {\n\t            *bpy.data.meshes,\n\t            *bpy.data.materials,\n\t            *bpy.data.textures,\n\t            *bpy.data.images,\n\t            *bpy.data.objects,\n\t            *bpy.data.lights,\n\t            *bpy.data.cameras,\n", "            *bpy.data.curves,\n\t            *bpy.data.armatures,\n\t            *bpy.data.actions,\n\t            *bpy.data.libraries,\n\t            *bpy.data.scenes,\n\t            *bpy.data.sounds,\n\t            *bpy.data.worlds,\n\t            *bpy.data.fonts,\n\t            *bpy.data.grease_pencils,\n\t            *bpy.data.metaballs,\n", "            *bpy.data.paint_curves,\n\t            *bpy.data.particles,\n\t            *bpy.data.shape_keys,\n\t            *bpy.data.texts,\n\t            *bpy.data.volumes,\n\t            *bpy.data.pointclouds,\n\t            *bpy.data.movieclips,\n\t            *bpy.data.lightprobes,\n\t            *bpy.data.lattices,\n\t            *bpy.data.hair_curves,\n", "            *bpy.data.cache_files,\n\t            *bpy.data.linestyles,\n\t            *bpy.data.speakers\n\t        }\n\t        current_data = {\"data\": {}}\n\t        for obj in data_blocks:\n\t            obj_data = {}\n\t            for prop_name in dir(obj):\n\t                if prop_name:\n\t                    try:\n", "                        prop_value = getattr(obj, prop_name)\n\t                        if not prop_name.startswith(\"__\"):\n\t                            obj_data[prop_name] = prop_value\n\t                        for sub_prop_name in dir(prop_value):\n\t                            if not sub_prop_name.startswith(\"__\"):\n\t                                try:\n\t                                    sub_prop_value = getattr(prop_value, sub_prop_name)\n\t                                    if isinstance(sub_prop_value, (int, float, str, bool)):\n\t                                        obj_data[f\"{prop_name}.{sub_prop_name}\"] = sub_prop_value\n\t                                    elif isinstance(sub_prop_value, (tuple, list)):\n", "                                        # Convert tuple and list to list before storing in dictionary\n\t                                        obj_data[f\"{prop_name}.{sub_prop_name}\"] = list(sub_prop_value)\n\t                                    elif isinstance(sub_prop_value, np.ndarray):\n\t                                        # Convert numpy arrays to lists before storing in dictionary\n\t                                        obj_data[f\"{prop_name}.{sub_prop_name}\"] = sub_prop_value.tolist()\n\t                                    else:\n\t                                        # If the sub-property is not a supported data type, skip it\n\t                                        continue\n\t                                    for sub_sub_prop_name in dir(sub_prop_value):\n\t                                        if not sub_sub_prop_name.startswith(\"__\"):\n", "                                            try:\n\t                                                sub_sub_prop_value = getattr(sub_prop_value, sub_sub_prop_name)\n\t                                                if isinstance(sub_sub_prop_value, (int, float, str, bool)):\n\t                                                    obj_data[f\"{prop_name}.{sub_prop_name}.{sub_sub_prop_name}\"] = sub_sub_prop_value\n\t                                                elif isinstance(sub_sub_prop_value, (tuple, list)):\n\t                                                    # Convert tuple and list to list before storing in dictionary\n\t                                                    obj_data[f\"{prop_name}.{sub_prop_name}.{sub_sub_prop_name}\"] = list(sub_sub_prop_value)\n\t                                                elif isinstance(sub_sub_prop_value, np.ndarray):\n\t                                                    # Convert numpy arrays to lists before storing in dictionary\n\t                                                    obj_data[f\"{prop_name}.{sub_prop_name}.{sub_sub_prop_name}\"] = sub_sub_prop_value.tolist()\n", "                                                else:\n\t                                                    # If the sub-sub-property is not a supported data type, skip it\n\t                                                    continue\n\t                                            except:\n\t                                                # If there's an error, skip the sub-sub-property\n\t                                                pass\n\t                                except:\n\t                                    # If there's an error, skip the sub-property\n\t                                    pass\n\t                    except:\n", "                        # If there's an error, skip the property\n\t                        pass\n\t            current_data[\"data\"][obj] = obj_data\n\t        if current_data != stored:\n\t            my_dict['stored_data'] = current_data\n\t            stored = current_data\n\t            # print(stored)\n\t            # print(current_data)\n\t            print(\"made it here\")\n\t            bpy.context.window_manager.my_addon_props.mouse_detect = False\n", "            return True\n\t        bpy.context.window_manager.my_addon_props.mouse_detect = False\n\t    return False\n\t    # if not np.array_equal(current_data, stored):\n"]}
{"filename": "Live_Addon/utils/file_path.py", "chunked_list": ["import os\n\timport bpy\n\timport platform\n\timport datetime\n\timport re\n\timport tempfile\n\tfrom .. import props\n\tfrom . import common\n\tdef get_default_path():\n\t    if platform.system() == \"Windows\":\n", "        appdata_folder = os.path.join(os.environ[\"APPDATA\"])\n\t    else:\n\t        appdata_folder = os.path.join(os.environ[\"HOME\"], \".config\")\n\t    return appdata_folder\n\tdef build_new_file_path():\n\t    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n\t    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n\t    new_path = re.sub(timestep_regex, current_time, bpy.context.window_manager.my_addon_props.file_path)\n\t    return new_path\n\tdef match_in_timestep():\n", "    if os.path.exists(bpy.context.window_manager.my_addon_props.file_path):\n\t        timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n\t        matched1 = re.search(timestep_regex, bpy.context.window_manager.my_addon_props.file_path)\n\t        return matched1\n\t    else:\n\t        return False\n\tdef create_new_file_path():\n\t    file_name = \"my_blend_file_\"\n\t    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n\t    addonpref = props.preference.prefs()\n", "    created_filepath = os.path.join(addonpref.livesavede, file_name + current_time + \".blend\")\n\t    return created_filepath\n\tdef create_new_file_path_version():\n\t    project_name = os.path.splitext(os.path.basename(bpy.context.window_manager.my_addon_props.file_path))[0]\n\t    # Create the version folder name with the project name and version count\n\t    version_folder_name = f\"{project_name}_version_folder\"\n\t    # Create the full path for the version folder\n\t    version_folder_path = os.path.join(os.path.dirname(bpy.context.window_manager.my_addon_props.file_path),\n\t                                       version_folder_name)\n\t    return version_folder_path\n", "def build_new_p_file_path_version():\n\t    file_name = \"my_blend_file_\"\n\t    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n\t    addonpref = props.preference.prefs()\n\t    created_filepath = os.path.join(addonpref.livesavede, file_name + current_time)\n\t    version_folder_name = f\"{created_filepath}_permenant_version_folder\"\n\t    version_folder_path = os.path.join(os.path.dirname(bpy.context.window_manager.my_addon_props.file_path),\n\t                                       version_folder_name)\n\t    return version_folder_path\n\tdef make_image_dir():\n", "    addonpref = props.preference.prefs()\n\t    image_dir = os.path.join(addonpref.image_file_path, \"Images from Blender\")\n\t    if not os.path.exists(image_dir):\n\t        os.mkdir(image_dir)\n\t    return image_dir\n\tdef make_image_file_path_udim(image_name):\n\t        image_dir = make_image_dir()\n\t        currrent_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n\t        udim = '<UDIM>'\n\t        image_file_path = os.path.join(image_dir, image_name + currrent_time + udim + common.file_extension_format())\n", "        return image_file_path\n\tdef make_image_file_path(image_name):\n\t        image_dir = make_image_dir()\n\t        currrent_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n\t        image_file_path = os.path.join(image_dir, image_name + currrent_time + common.file_extension_format())\n\t        return image_file_path\n\t# file_name = \"live_backup\"\n\t# current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n\t# file_path = os.path.join(appdata_folder, file_name + current_time + \".blend\")\n"]}
{"filename": "Live_Addon/utils/__init__.py", "chunked_list": ["from . import comparison\n\tfrom . import saving_function\n\tfrom . import file_path\n\tfrom . import common\n\tdef register():\n\t    pass\n\tdef unregister():\n\t    pass\n"]}
{"filename": "Live_Addon/utils/saving_function.py", "chunked_list": ["import bpy\n\timport os\n\timport datetime\n\tfrom . import file_path\n\tfrom . import comparison\n\tfrom . import common\n\timport importlib\n\tfph = file_path\n\tdef run_once():\n\t    has_run = False\n", "    def inner():\n\t        nonlocal has_run\n\t        if not has_run:\n\t            print(\"This function will only execute once.\")\n\t            has_run = True\n\t            return True\n\t        else:\n\t            return False\n\t    return inner\n\tdef save_to_file(file_path1):\n", "    bpy.ops.wm.save_as_mainfile(filepath=file_path1, copy=True)\n\tdef save_image_textures():\n\t    for img in bpy.data.images:\n\t        try:\n\t            if img.is_dirty:\n\t                if img.filepath:\n\t                    img.save()\n\t                else:\n\t                    img.filepath = file_path.make_image_file_path(img.name)\n\t                    img.save()\n", "        except Exception as e:\n\t            print(str(e))\n\t            if not os.path.exists(img.filepath):\n\t                img.filepath = file_path.make_image_file_path_udim(img.name)\n\t                img.save()\n\tdef save_blend_file():\n\t    if bpy.data.is_saved:\n\t        bpy.ops.wm.save_mainfile()\n\t    elif comparison.compare_blend_data():\n\t        if fph.match_in_timestep():\n", "            new_file_path = fph.build_new_file_path()\n\t            print(\"im about to delete\")\n\t            print(bpy.context.window_manager.my_addon_props.file_path, new_file_path)\n\t            os.rename(bpy.context.window_manager.my_addon_props.file_path, new_file_path)\n\t            print(\"i deleted\")\n\t            bpy.context.window_manager.my_addon_props.file_path = new_file_path\n\t            if os.path.exists(bpy.context.window_manager.my_addon_props.file_path_version):\n\t                new_version_folder = fph.create_new_file_path_version()\n\t                os.rename(bpy.context.window_manager.my_addon_props.file_path_version, new_version_folder)\n\t                bpy.context.window_manager.my_addon_props.file_path_version = new_version_folder\n", "            elif bpy.context.window_manager.my_addon_props.is_enabled_version:\n\t                new_version_folder = fph.create_new_file_path_version()\n\t                bpy.context.window_manager.my_addon_props.file_path_version = new_version_folder\n\t        else:\n\t            bpy.context.window_manager.my_addon_props.file_path = fph.create_new_file_path()\n\t            print(\"wrong place\")\n\t            save_to_file(bpy.context.window_manager.my_addon_props.file_path)\n\t            if bpy.context.window_manager.my_addon_props.is_enabled_version:\n\t                new_version_folder = fph.create_new_file_path_version()\n\t                bpy.context.window_manager.my_addon_props.file_path_version = new_version_folder\n", "        # write all materials, textures and node groups to a library\n\t        data_blocks = {\n\t            *bpy.data.meshes,\n\t            *bpy.data.materials,\n\t            *bpy.data.textures,\n\t            *bpy.data.images,\n\t            *bpy.data.objects,\n\t            *bpy.data.lights,\n\t            *bpy.data.cameras,\n\t            *bpy.data.curves,\n", "            *bpy.data.armatures,\n\t            *bpy.data.actions,\n\t            *bpy.data.libraries,\n\t            *bpy.data.scenes,\n\t            *bpy.data.sounds,\n\t            *bpy.data.worlds,\n\t            *bpy.data.fonts,\n\t            *bpy.data.grease_pencils,\n\t            *bpy.data.metaballs,\n\t            *bpy.data.paint_curves,\n", "            *bpy.data.particles,\n\t            *bpy.data.shape_keys,\n\t            *bpy.data.speakers,\n\t            *bpy.data.texts,\n\t            *bpy.data.window_managers,\n\t            *bpy.data.workspaces,\n\t            *bpy.data.volumes,\n\t            *bpy.data.pointclouds,\n\t            *bpy.data.movieclips,\n\t            *bpy.data.lightprobes,\n", "            *bpy.data.libraries,\n\t            *bpy.data.lattices,\n\t            *bpy.data.hair_curves,\n\t            *bpy.data.collections,\n\t            *bpy.data.cache_files,\n\t            *bpy.data.linestyles,\n\t            *bpy.data.brushes,\n\t            *bpy.data.speakers,\n\t            *bpy.data.screens\n\t        }\n", "        bpy.data.libraries.write(bpy.context.window_manager.my_addon_props.file_path, data_blocks)\n\t        print(\"Data appended successfully to the copied blend file.\")\n\t    else:\n\t        pass\n"]}
{"filename": "Live_Addon/utils/common.py", "chunked_list": ["import re\n\timport bpy\n\timport importlib\n\tfrom .. import props\n\timport os\n\t\"\"\"\n\tprops_module1 = props.Live_Addon\n\t# Use props_module.addon here\n\tdef module() -> str:\n\t    return props_module1.name\n", "def prefs() -> bpy.types.AddonPreferences:\n\t    return bpy.context.preferences.addons[module()].preferences\n\t\"\"\"\n\tdef file_extension_format():\n\t    addon_prefs = props.preference.prefs()\n\t    image_format = addon_prefs.image_format\n\t    if image_format == 'PNG':\n\t        return '.png'\n\t    elif image_format == 'JPEG':\n\t        return '.jpg'\n", "    elif image_format == 'BMP':\n\t        return '.bmp'\n\t    elif image_format == 'TARGA':\n\t        return '.tga'\n\t    elif image_format == 'OPEN_EXR':\n\t        return '.exr'\n\t    elif image_format == 'HDR':\n\t        return '.hdr'\n\t    elif image_format == 'TIFF':\n\t        return '.tif'\n", "    elif image_format == 'AVI_JPEG':\n\t        return '.avi'\n\t    elif image_format == 'AVI_RAW':\n\t        return '.avi'\n\t    elif image_format == 'FRAMESERVER':\n\t        return '.fs'\n\t    elif image_format == 'Cineon':\n\t        return '.cin'\n\t    elif image_format == 'DPX':\n\t        return '.dpx'\n", "    elif image_format == 'OpenEXR_MULTILAYER':\n\t        return '.exr'\n\t    elif image_format == 'JP2':\n\t        return '.jp2'\n\t    elif image_format == 'IRIS':\n\t        return '.rgb'\n\t    elif image_format == 'J2C':\n\t        return '.j2c'\n\t    elif image_format == 'webp':\n\t        return '.webp'\n", "def file_path_test(number):\n\t    new_filepath = new_file_path_func(number)\n\t    # check if the new filepath exists\n\t    if os.path.exists(new_filepath):\n\t        print(f\"{new_filepath} already exists!\")\n\t        return True\n\t    else:\n\t        print(f\"{new_filepath} does not exist.\")\n\t        return False\n\tdef new_file_path_func(number):\n", "    new_filepath = \"Bernd\"\n\t    addon_prefs = props.preference.prefs()\n\t    print(bpy.context.window_manager.my_addon_props.p_version_path)\n\t    if bpy.data.is_saved or os.path.exists(bpy.context.window_manager.my_addon_props.p_version_path):\n\t        file_path = bpy.data.filepath\n\t        dirname = os.path.dirname(file_path)\n\t        matched = re.search(r\"_permenant_version\", file_path)\n\t        if matched:\n\t            target_folder = os.path.dirname(file_path)\n\t            # Get a list of all .blend files in the target folder\n", "            blend_files = [f for f in os.listdir(target_folder) if f.endswith(\".blend\")]\n\t            # Sort the blend files by their creation time, with the oldest file first\n\t            oldest_first = sorted(blend_files, key=lambda f: os.path.getctime(os.path.join(target_folder, f)))\n\t            # Extract just the filenames from the file paths\n\t            oldest_first_filenames = [os.path.basename(f) for f in oldest_first]\n\t            filename = os.path.basename(file_path)\n\t            try:\n\t                if isinstance(number, int):\n\t                    target_file_index = oldest_first_filenames.index(filename)\n\t                    print(f\"The index of {file_path} is {target_file_index}\")\n", "                    new_filepath = os.path.join(dirname, oldest_first[target_file_index + number])\n\t                elif isinstance(number, str):\n\t                    if number == \"first\":\n\t                        new_filepath = os.path.join(dirname, oldest_first[0])\n\t                    elif number == \"last\":\n\t                        new_filepath = os.path.join(dirname, oldest_first[-1])\n\t            except ValueError and IndexError:\n\t                print(f\"{file_path} is not in the list\")\n\t            return new_filepath\n\t        else:\n", "            project_name = os.path.splitext(os.path.basename(file_path))[0]\n\t            dirname = os.path.dirname(file_path)\n\t            p_version_folder_name = f\"{project_name}_permenant_version\"\n\t            p_version_folder_path = os.path.join(dirname, p_version_folder_name)\n\t            print(p_version_folder_path)\n\t            target_folder = p_version_folder_path\n\t            if os.path.exists(target_folder):\n\t                # get the directory and filename without extension\n\t                directory, filename = os.path.split(file_path)\n\t                filename, ext = os.path.splitext(filename)\n", "                # if not, start with version 1\n\t                new_version = number\n\t                if new_version == \"first\":\n\t                    new_version = 1\n\t                new_filename = f\"{filename}_v{new_version:03}{ext}\"\n\t                # create the new filepath with the new filename\n\t                new_filepath = os.path.join(target_folder, new_filename)\n\t                return new_filepath\n\t    elif os.path.exists(bpy.context.window_manager.my_addon_props.p_version_path):\n\t        target_folder = bpy.context.window_manager.my_addon_props.p_version_path\n", "        new_version = number\n\t        # loop through all blend files in the directory and find the matching filepath\n\t        version_files = sorted([f for f in os.listdir(target_folder) if f.endswith(\".blend\")])\n\t        new_filepath = os.path.join(target_folder, version_files[0])\n\t        return new_filepath\n\t    return new_filepath\n\tdef file_path_version_open(number):\n\t    new_filepath = new_file_path_func(number)\n\t    # check if the new filepath exists\n\t    if os.path.exists(new_filepath):\n", "        bpy.ops.wm.open_mainfile(filepath=new_filepath)\n\tdef go_to_original():\n\t    original_file_path = \"\"\n\t    file_path = bpy.data.filepath\n\t    matched = re.search(r\"_permenant_version\", file_path)\n\t    if matched:\n\t        directory, filename = os.path.split(file_path)\n\t        filename, ext = os.path.splitext(filename)\n\t        new_filename = directory.replace(\"_permenant_version\", \"\")\n\t        dirname = os.path.dirname(directory)\n", "        original_file_path = os.path.join(dirname, new_filename + ext)\n\t        return original_file_path\n\t    else:\n\t        print(\"This is the original file!\")\n\t        return original_file_path\n\tdef go_to_original_test():\n\t    new_filepath = go_to_original()\n\t    # check if the new filepath exists\n\t    if os.path.exists(new_filepath):\n\t        print(f\"{new_filepath} already exists!\")\n", "        return True\n\t    else:\n\t        print(f\"{new_filepath} does not exist.\")\n\t        return False\n\tdef go_to_original_open():\n\t    new_filepath = go_to_original()\n\t    # check if the new filepath exists\n\t    if os.path.exists(new_filepath):\n\t        bpy.ops.wm.open_mainfile(filepath=new_filepath)\n\tdef update_index(self, context):\n", "    index = bpy.context.window_manager.list_index\n\t    my_list = bpy.context.window_manager.my_list\n\t    file_path = my_list[index].p_version_file_path\n\t    if os.path.exists(file_path):\n\t        bpy.ops.wm.open_mainfile(filepath=file_path)\n"]}
{"filename": "Live_Addon/ops/open_original.py", "chunked_list": ["import bpy\n\tfrom bpy.types import Operator\n\tfrom .. import utils\n\tcom = utils.common\n\tclass LiveSaveLoadOriginal(Operator):\n\t    bl_idname = 'livesave.load_original'\n\t    bl_label = 'Load Next'\n\t    bl_options = {'INTERNAL'}\n\t    bl_description = 'Load the original iteration of this file'\n\t    @classmethod\n", "    def poll(cls, context):\n\t        return com.go_to_original_test()\n\t    def execute(self, context):\n\t        com.go_to_original_open()\n\t        return {'FINISHED'}\n"]}
{"filename": "Live_Addon/ops/save_p_version.py", "chunked_list": ["import os\n\timport re\n\tfrom .. import utils\n\timport bpy\n\tfph = utils.file_path\n\tclass save_p_version(bpy.types.Operator):\n\t    bl_idname = 'live_save.save_p_version'\n\t    bl_label = 'Save Previous Version'\n\t    bl_description = 'Save a permenant version of your file'\n\t    blend_match = r\"\\.blend\"\n", "    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n\t    def execute(self, context):\n\t        file_path12 = bpy.context.window_manager.my_addon_props.file_path\n\t        matched_blend = re.search(self.blend_match, file_path12)\n\t        if bpy.data.is_saved:\n\t            filepath = bpy.data.filepath\n\t            project_name = os.path.splitext(os.path.basename(filepath))[0]\n\t            p_version_folder_name = f\"{project_name}_permenant_version\"\n\t            p_version_folder_path = os.path.join(os.path.dirname(filepath), p_version_folder_name)\n\t            if not os.path.exists(p_version_folder_path):\n", "                os.makedirs(p_version_folder_path, exist_ok=True)\n\t            version_files = sorted([f for f in os.listdir(p_version_folder_path) if f.endswith(\".blend\")])\n\t            my_list = context.window_manager.my_list\n\t            for i in range(len(version_files)):\n\t                if len(version_files) == 0:\n\t                    break\n\t                old_path = os.path.join(p_version_folder_path, version_files[i])\n\t                match = re.search(r\"_v\\d{3}\", version_files[i])\n\t                if match:\n\t                    new_name = f\"{project_name}_v{i + 1:03}.blend\"\n", "                    new_path = os.path.join(p_version_folder_path, new_name)\n\t                    os.rename(old_path, new_path)\n\t                try:\n\t                    list_new_item = my_list[i]\n\t                    match = re.search(r\"_v\\d{3}\", list_new_item.name)\n\t                    if match:\n\t                        list_new_item.name = new_name\n\t                    elif not os.path.exists(os.path.join(p_version_folder_path, list_new_item.name)):\n\t                        os.rename(new_path, os.path.join(p_version_folder_path, list_new_item.name))\n\t                    list_new_item.p_version_file_path = new_path\n", "                except IndexError:\n\t                    list_new_item = bpy.context.window_manager.my_list.add()\n\t                    list_new_item.name = new_name\n\t                    list_new_item.p_version_file_path = new_path\n\t            version_count = len(version_files)\n\t            current_version_name = f\"{project_name}_v{version_count + 1:03d}.blend\"\n\t            current_version_path = os.path.join(p_version_folder_path, current_version_name)\n\t            bpy.ops.wm.save_as_mainfile(filepath=current_version_path, copy=True)\n\t            list_new_item = bpy.context.window_manager.my_list.add()\n\t            list_new_item.name = current_version_name\n", "            list_new_item.p_version_file_path = current_version_path\n\t        elif not os.path.isdir(file_path12) and matched_blend and os.path.exists(file_path12):\n\t            version_folder_path = bpy.context.window_manager.my_addon_props.p_version_path\n\t            if not os.path.exists(version_folder_path):\n\t                bpy.context.window_manager.my_addon_props.p_version_path = fph.build_new_p_file_path_version()\n\t                version_folder_path = bpy.context.window_manager.my_addon_props.p_version_path\n\t                os.makedirs(version_folder_path, exist_ok=True)\n\t            version_files = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n\t            my_list = context.window_manager.my_list\n\t            for i in range(len(version_files)):\n", "                if len(version_files) == 0:\n\t                    break\n\t                project_name = version_files[i].split(\"_v\")[0]\n\t                old_path = os.path.join(version_folder_path, version_files[i])\n\t                new_name = f\"{project_name}_v{i + 1:03}.blend\"\n\t                new_path = os.path.join(version_folder_path, new_name)\n\t                os.rename(old_path, new_path)\n\t                try:\n\t                    list_new_item = my_list[i]\n\t                    list_new_item.name = new_name\n", "                    list_new_item.p_version_file_path = new_path\n\t                except IndexError:\n\t                    list_new_item = bpy.context.window_manager.my_list.add()\n\t                    list_new_item.name = new_name\n\t                    list_new_item.p_version_file_path = new_path\n\t            project_name = os.path.basename(version_folder_path)\n\t            project_name = project_name[:-15]\n\t            version_count = len(version_files)\n\t            current_version_name = f\"{project_name}_v{version_count + 1:03d}.blend\"\n\t            current_version_path = os.path.join(version_folder_path, current_version_name)\n", "            list_new_item = bpy.context.window_manager.my_list.add()\n\t            list_new_item.name = current_version_name\n\t            list_new_item.p_version_file_path = current_version_path\n\t            bpy.ops.wm.save_as_mainfile(filepath=current_version_path, copy=True)\n\t        return {'FINISHED'}\n"]}
{"filename": "Live_Addon/ops/save_with_browser.py", "chunked_list": ["import bpy\n\tfrom bpy.props import StringProperty\n\tclass SaveAsMainfileOperator(bpy.types.Operator):\n\t    bl_idname = \"wm.save_as_mainfile_with_browser\"\n\t    bl_label = \"Save As Mainfile with Browser\"\n\t    filepath: StringProperty(subtype='FILE_PATH')\n\t    @classmethod\n\t    def poll(cls, context):\n\t        return not bpy.data.is_saved\n\t    def execute(self, context):\n", "        # Add \".blend\" to the end of the filepath\n\t        filepath_blend = self.filepath + \".blend\"\n\t        bpy.ops.wm.save_as_mainfile(filepath=filepath_blend)\n\t        return {'FINISHED'}\n\t    def invoke(self, context, event):\n\t        context.window_manager.fileselect_add(self)\n\t        return {'RUNNING_MODAL'}\n"]}
{"filename": "Live_Addon/ops/detect_mouseclick.py", "chunked_list": ["import importlib\n\timport bpy\n\tfrom .. import props\n\tprops_module = props.preference\n\tclass UserActionDetector(bpy.types.Operator):\n\t    bl_idname = \"wm.user_action_detector\"\n\t    bl_label = \"User Action Detector\"\n\t    def modal(self, context, event):\n\t        #i want to add the enter key to the list of keys that will trigger the operator\n\t        if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'RET'} and event.value == 'RELEASE':\n", "            print(\"User action detected\")\n\t            bpy.context.window_manager.my_addon_props.mouse_detect = True\n\t            addon_prefs = props_module.prefs()\n\t            if not addon_prefs.is_enabled:\n\t                self.cancel(context)\n\t                return {'CANCELLED'}\n\t        return {'PASS_THROUGH'}\n\t    def execute(self, context):\n\t        wm = context.window_manager\n\t        wm.modal_handler_add(self)\n", "        return {'RUNNING_MODAL'}\n\t    def cancel(self, context):\n\t        return {'CANCELLED'}\n"]}
{"filename": "Live_Addon/ops/__init__.py", "chunked_list": ["import bpy\n\tfrom .. import props\n\tfrom . import timer\n\tfrom . import save_with_browser\n\tfrom . import detect_mouseclick\n\tfrom . import save_p_version\n\tfrom . import load_p_version_pre\n\tfrom . import load_p_version_post\n\tfrom . import first_p_version\n\tfrom . import last_p_version\n", "from . import open_original\n\taddonpref = props.preference.prefs()\n\tCLASSES = [\n\t    timer.LiveSaveMessageHandler,\n\t    save_with_browser.SaveAsMainfileOperator,\n\t    detect_mouseclick.UserActionDetector,\n\t    save_p_version.save_p_version,\n\t    load_p_version_pre.LiveSaveLoadPre,\n\t    load_p_version_post.LiveSaveLoadNext,\n\t    first_p_version.LiveSaveLoadFirst,\n", "    last_p_version.LiveSaveLoadLast,\n\t    open_original.LiveSaveLoadOriginal,\n\t]\n\tregister, unregister = bpy.utils.register_classes_factory(CLASSES)\n"]}
{"filename": "Live_Addon/ops/timer.py", "chunked_list": ["import datetime\n\timport threading\n\timport pprint\n\timport bpy\n\tfrom .. import utils\n\timport importlib\n\tfrom .. import props\n\tprops_module = props.preference\n\tfrom .. import handlers\n\t# Use props_module.addon here\n", "class LiveSaveMessageHandler(bpy.types.Operator):\n\t    bl_idname = \"wm.live_save_message_handler\"\n\t    bl_label = \"Live Save Message Handler\"\n\t    _timer = None\n\t    is_running = False\n\t    onlyonce: bpy.props.BoolProperty(default=False)\n\t    def update_timer(self, context):\n\t        addon_prefs = props_module.prefs()\n\t        wm = context.window_manager\n\t        if self._timer != addon_prefs.Timer:\n", "            wm.event_timer_remove(self._timer)\n\t            self._timer = None\n\t        if not self._timer:\n\t            self._timer = wm.event_timer_add(addon_prefs.Timer, window=context.window)\n\t    def modal(self, context, event):\n\t        if event.type == 'TIMER':\n\t            addon_prefs = props_module.prefs()\n\t            if not addon_prefs.is_enabled:\n\t                self.cancel(context)\n\t                return {'CANCELLED'}\n", "            self.update_timer(context)\n\t            if bpy.data.is_dirty or utils.comparison.check_undo_redo(context):\n\t                if not self.is_running:\n\t                    self.is_running = True\n\t                    p = threading.Thread(target=self.my_thread_function)\n\t                    p.start()\n\t                    if not addon_prefs.background_save:\n\t                        p.join()\n\t        return {'PASS_THROUGH'}\n\t    def execute(self, context):\n", "        addon_prefs = props_module.prefs()\n\t        wm = context.window_manager\n\t        self._timer = wm.event_timer_add(addon_prefs.Timer, window=context.window)\n\t        wm.modal_handler_add(self)\n\t        bpy.app.handlers.undo_post.append(handlers.undo_redo.redo_handler)\n\t        bpy.app.handlers.redo_post.append(handlers.undo_redo.redo_handler)\n\t        return {'RUNNING_MODAL'}\n\t    def cancel(self, context):\n\t        wm = context.window_manager\n\t        wm.event_timer_remove(self._timer)\n", "        bpy.app.handlers.undo_post.remove(handlers.undo_redo.redo_handler)\n\t        bpy.app.handlers.redo_post.remove(handlers.undo_redo.redo_handler)\n\t        return {'CANCELLED'}\n\t    def my_thread_function(self):\n\t        start_time = datetime.datetime.now()\n\t        try:\n\t            utils.saving_function.save_blend_file()\n\t            utils.saving_function.save_image_textures()\n\t        except Exception as e:\n\t            print(e)\n", "        end_time = datetime.datetime.now()\n\t        execution_time = end_time - start_time\n\t        addon_prefs = props_module.prefs()\n\t        dyn_save = addon_prefs.dynamic_save\n\t        if dyn_save:\n\t            if execution_time > datetime.timedelta(seconds=1):\n\t                addon_prefs.Timer = 10\n\t            elif execution_time < datetime.timedelta(seconds=1):\n\t                addon_prefs.Timer = 1\n\t        self.is_running = False\n", "    @property\n\t    def timer(self):\n\t        return self._timer\n"]}
{"filename": "Live_Addon/ops/first_p_version.py", "chunked_list": ["import bpy\n\tfrom bpy.types import Operator\n\tfrom .. import utils\n\tcom = utils.common\n\tclass LiveSaveLoadFirst(Operator):\n\t    bl_idname = 'livesave.load_first'\n\t    bl_label = 'Load Next'\n\t    bl_options = {'INTERNAL'}\n\t    bl_description = 'Load the first iteration of this file'\n\t    @classmethod\n", "    def poll(cls, context):\n\t        return com.file_path_test(\"first\")\n\t    def execute(self, context):\n\t        com.file_path_version_open(\"first\")\n\t        return {'FINISHED'}\n"]}
{"filename": "Live_Addon/ops/last_p_version.py", "chunked_list": ["import bpy\n\tfrom bpy.types import Operator\n\tfrom .. import utils\n\tcom = utils.common\n\tclass LiveSaveLoadLast(Operator):\n\t    bl_idname = 'livesave.load_last'\n\t    bl_label = 'Load Next'\n\t    bl_options = {'INTERNAL'}\n\t    bl_description = 'Load the last iteration of this file'\n\t    @classmethod\n", "    def poll(cls, context):\n\t        return com.file_path_test(\"last\")\n\t    def execute(self, context):\n\t        com.file_path_version_open(\"last\")\n\t        return {'FINISHED'}\n"]}
{"filename": "Live_Addon/ops/load_p_version_post.py", "chunked_list": ["import bpy\n\tfrom bpy.types import Operator\n\tfrom .. import utils\n\tcom = utils.common\n\tclass LiveSaveLoadNext(Operator):\n\t    bl_idname = 'livesave.load_next'\n\t    bl_label = 'Load Next'\n\t    bl_options = {'INTERNAL'}\n\t    bl_description = 'Load the pre iteration of this file'\n\t    @classmethod\n", "    def poll(cls, context):\n\t        return com.file_path_test(1)\n\t    def execute(self, context):\n\t        com.file_path_version_open(1)\n\t        return {'FINISHED'}\n"]}
{"filename": "Live_Addon/ops/load_p_version_pre.py", "chunked_list": ["import bpy\n\tfrom .. import utils\n\tfrom bpy.types import Operator\n\tcom = utils.common\n\tclass LiveSaveLoadPre(Operator):\n\t    bl_idname = 'livesave.load_pre'\n\t    bl_label = 'Load Pre'\n\t    bl_options = {'INTERNAL'}\n\t    bl_description = 'Load the pre iteration of this file'\n\t    @classmethod\n", "    def poll(cls, context):\n\t        return com.file_path_test(-1)\n\t    def execute(self, context):\n\t        com.file_path_version_open(-1)\n\t        return {'FINISHED'}\n"]}
{"filename": "Live_Addon/handlers/undo_redo.py", "chunked_list": ["import bpy\n\tdef redo_handler(dummy):\n\t    print(\"undo did happend\")\n\t    bpy.context.window_manager.my_addon_props.exec_count += 1\n"]}
{"filename": "Live_Addon/handlers/__init__.py", "chunked_list": ["import bpy\n\tfrom . import live_load_hanlder\n\tfrom . import live_save_handler\n\tfrom . import undo_redo\n\tdef register():\n\t    if live_load_hanlder.auto_start not in bpy.app.handlers.load_post:\n\t        bpy.app.handlers.load_post.append(live_load_hanlder.auto_start)\n\t    if live_save_handler.on_save_post_handler not in bpy.app.handlers.save_post:\n\t        bpy.app.handlers.save_post.append(live_save_handler.on_save_post_handler)\n\tdef unregister():\n", "    if live_load_hanlder.auto_start in bpy.app.handlers.load_post:\n\t        bpy.app.handlers.load_post.remove(live_load_hanlder.auto_start)\n\t    if live_save_handler.on_save_post_handler in bpy.app.handlers.save_post:\n\t        bpy.app.handlers.save_post.remove(live_save_handler.on_save_post_handler)"]}
{"filename": "Live_Addon/handlers/live_save_handler.py", "chunked_list": ["import bpy\n\timport os\n\timport shutil\n\tfrom .. import props\n\t@bpy.app.handlers.persistent\n\tdef on_save_post_handler(dummy):\n\t    file_path12 = bpy.context.window_manager.my_addon_props.file_path\n\t    if bpy.data.filepath:\n\t        if os.path.exists(file_path12):\n\t            os.remove(file_path12)\n"]}
{"filename": "Live_Addon/handlers/live_load_hanlder.py", "chunked_list": ["import os\n\timport bpy\n\timport importlib\n\tfrom ..timer import save_version as sv\n\tfrom .. import props\n\tfrom .. import utils as u\n\tfph = u.file_path\n\tcom = u.common\n\tutils_module = props.preference\n\t# Use props_module.addon here\n", "@bpy.app.handlers.persistent\n\tdef auto_start(dummy):\n\t    prefs = utils_module.prefs()\n\t    window_manager = bpy.context.window_manager\n\t    if prefs.auto_start_save:\n\t        print(\"auto start save\")\n\t        file_path = fph.create_new_file_path()\n\t        bpy.ops.wm.save_as_mainfile(filepath=file_path)\n\t    if prefs.is_enabled:\n\t        bpy.ops.wm.live_save_message_handler('EXEC_DEFAULT')\n", "        bpy.ops.wm.user_action_detector('EXEC_DEFAULT')\n\t    if bpy.context.window_manager.my_addon_props.is_enabled_version:\n\t        if not bpy.app.timers.is_registered(sv.save_version):\n\t            bpy.app.timers.register(sv.save_version, first_interval=bpy.context.window_manager.my_addon_props.version_timer, persistent=True)\n\t    if com.file_path_test(\"first\"):\n\t        p_version_folder_path = os.path.dirname(com.new_file_path_func(\"first\"))\n\t        version_files = sorted([f for f in os.listdir(p_version_folder_path) if f.endswith(\".blend\")])\n\t        for i in range(len(version_files)):\n\t            if len(version_files) == 0:\n\t                break\n", "            new_path = os.path.join(p_version_folder_path, version_files[i])\n\t            list_new_item = bpy.context.window_manager.my_list.add()\n\t            list_new_item.name = version_files[i]\n\t            list_new_item.p_version_file_path = new_path\n"]}
{"filename": "Live_Addon/props/prefs.py", "chunked_list": ["import bpy\n\tfrom . import preference\n\tfrom ..utils import file_path\n\tclass LiveSavePreferences(bpy.types.AddonPreferences):\n\t    bl_idname = preference.module()\n\t    def update_timer(self, context):\n\t        wm = context.window_manager\n\t        operator = wm.operators.get(\"wm.live_save_message_handler\")\n\t        if operator:\n\t            wm.event_timer_remove(operator.timer)\n", "            operator.timer = wm.event_timer_add(self.Timer, window=context.window)\n\t    def update_live_save(self, context):\n\t        if self.is_enabled:\n\t            bpy.ops.wm.live_save_message_handler('EXEC_DEFAULT')\n\t            bpy.ops.wm.user_action_detector('EXEC_DEFAULT')\n\t    Timer: bpy.props.FloatProperty(\n\t        name=\"Timer\",\n\t        description=\"A slider for the timers\",\n\t        default=1.0,\n\t        min=0.1,\n", "        max=10.0,\n\t        soft_min=0.0,\n\t        soft_max=5.0,\n\t        step=1,\n\t        precision=2,\n\t        update=update_timer\n\t    )\n\t    is_enabled: bpy.props.BoolProperty(\n\t        name=\"Enable Live Save\",\n\t        description=\"Enable or disable Live Save\",\n", "        default=True,\n\t        update=update_live_save\n\t    )\n\t    livesavede: bpy.props.StringProperty(\n\t        name='Live Save Directory',\n\t        description='The directory where initial saves will be stored',\n\t        default=file_path.get_default_path(),\n\t        subtype='FILE_PATH'\n\t    )\n\t    background_save: bpy.props.BoolProperty(\n", "        name=\"Background Save\",\n\t        description=\"Enable or disable Background Save(when on data lost can happen)\",\n\t        default=False,\n\t    )\n\t    dynamic_save: bpy.props.BoolProperty(\n\t        name=\"Dynamic Save\",\n\t        description=\"Enable or disable Dynamic Save\",\n\t        default=True,\n\t    )\n\t    image_format: bpy.props.EnumProperty(\n", "        name=\"Image Format\",\n\t        description=\"Image Format\",\n\t        items=[\n\t            ('PNG', 'PNG', ' save images with the PNG format'),\n\t            ('JPEG', 'JPEG', 'save images with the JPEG format'),\n\t            ('BMP', 'BMP', 'save images with the BMP format'),\n\t            ('TARGA', 'TARGA', 'save images with the TARGA format'),\n\t            ('OPEN_EXR', 'OPEN_EXR', 'save images with the OPEN_EXR format'),\n\t            ('HDR', 'HDR', 'save images with the HDR format'),\n\t            ('TIFF', 'TIFF', 'save images with the TIFF format'),\n", "            ('AVI_JPEG', 'AVI_JPEG', 'save images with the AVI_JPEG format'),\n\t            ('AVI_RAW', 'AVI_RAW', 'save images with the AVI_RAW format'),\n\t            ('FRAMESERVER', 'FRAMESERVER', 'save images with the FRAMESERVER format'),\n\t            ('Cineon', 'Cineon', 'save images with the Cineon format'),\n\t            ('DPX', 'DPX', 'save images with the DPX format'),\n\t            ('OpenEXR_MULTILAYER', 'OpenEXR_MULTILAYER', 'save images with the OpenEXR_MULTILAYER format'),\n\t            ('JP2', 'JP2', 'save images with the JP2 format'),\n\t            ('IRIS', 'IRIS', 'save images with the IRIS format'),\n\t            ('J2C', 'J2C', 'save images with the J2C format'),\n\t            ('webp', 'webp', 'save images with the webp format')\n", "        ],\n\t        default='PNG',\n\t    )\n\t    image_file_path: bpy.props.StringProperty(\n\t        name='Image File Path',\n\t        description='The directory where initial saves will be stored',\n\t        default=file_path.get_default_path(),\n\t        subtype='FILE_PATH'\n\t    )\n\t    auto_start_save: bpy.props.BoolProperty(\n", "        name=\"Auto Start Save\",\n\t        description=\"Enable or disable Auto Start Save\",\n\t        default=False,\n\t    )\n\t    turn_on_off_p_version: bpy.props.BoolProperty(\n\t        name=\"Turn On/Off P Version\",\n\t        description=\"Enable or disable Turn On/Off P Version\",\n\t        default=False,\n\t    )\n\t    turn_on_off_version: bpy.props.BoolProperty(\n", "        name=\"Turn On/Off Version\",\n\t        description=\"Enable or disable Turn On/Off Version\",\n\t        default=False,\n\t    )\n\t    def draw(self, context):\n\t        layout = self.layout\n\t        layout.prop(self, \"is_enabled\")\n\t        layout.prop(self, \"Timer\")\n\t        layout.prop(self, \"livesavede\")\n\t        layout.prop(self, \"background_save\")\n", "        layout.prop(self, \"dynamic_save\")\n\t        layout.prop(self, \"image_format\")\n\t        layout.prop(self, \"image_file_path\")\n\t        layout.prop(self, \"auto_start_save\")\n\t        layout.prop(self, \"turn_on_off_p_version\")\n\t        layout.prop(self, \"turn_on_off_version\")\n"]}
{"filename": "Live_Addon/props/Live_Addon.py", "chunked_list": ["import bpy\n\tname = __name__.partition(\".\")[0]\n\tclass LiveSaveProps(bpy.types.PropertyGroup):\n\t    addon: bpy.props.StringProperty(\n\t        name='Live_Addon',\n\t        description='Live module',\n\t        default=name,\n\t    )\n\t    @property\n\t    def prefs(self) -> bpy.types.AddonPreferences:\n", "        from .. import props\n\t        return props.preference.prefs()\n"]}
{"filename": "Live_Addon/props/internal_prefs.py", "chunked_list": ["import bpy\n\tfrom bpy.props import StringProperty\n\tfrom bpy.types import PropertyGroup\n\tfrom ..timer import save_version\n\tfrom .. import utils\n\tfph = utils.file_path\n\tclass MyAddonProperties(bpy.types.PropertyGroup):\n\t    file_path: bpy.props.StringProperty(\n\t        name=\"File Path\",\n\t        description=\"Enter file path\",\n", "        default=\"Bernd\"\n\t    )\n\t    file_path_version: bpy.props.StringProperty(\n\t        name=\"File Path Version\",\n\t        description=\"Enter file path\",\n\t        default=\"Bernd\"\n\t    )\n\t    exec_count: bpy.props.IntProperty(\n\t        name=\"exec count\",\n\t        description='The count or the the undo/redo',\n", "        default=0,\n\t        step=1\n\t    )\n\t    mouse_detect: bpy.props.BoolProperty(\n\t        name=\"Detects mouse click\",\n\t        description=\"when you release the mouse it will set is to true\",\n\t        default=False\n\t    )\n\t    version_timer: bpy.props.FloatProperty(\n\t        name=\"Timer Version\",\n", "        description=\"A slider for the timers\",\n\t        default=1.0,\n\t        min=1,\n\t        max=60*60,\n\t        soft_min=2,\n\t        soft_max=600,\n\t        step=1,\n\t        precision=2,\n\t        update=save_version.update_version_timer\n\t    )\n", "    is_enabled_version: bpy.props.BoolProperty(\n\t        name=\"Enable Version\",\n\t        description=\"Enable or disable Version\",\n\t        default=True,\n\t        update=save_version.update_version_bool\n\t    )\n\t    version_count: bpy.props.IntProperty(\n\t        name=\"Version Number\",\n\t        description='The count of the version',\n\t        default=1,\n", "        step=1,\n\t        min=1\n\t    )\n\t    p_version_path: bpy.props.StringProperty(\n\t        name=\"Version Path\",\n\t        description=\"Enter file path\",\n\t        default=\"Bernd\"\n\t    )\n\tclass ListItem(PropertyGroup):\n\t    \"\"\"Group of properties representing an item in the list.\"\"\"\n", "    name: StringProperty(\n\t           name=\"Name\",\n\t           description=\"A name for this item\",\n\t           default=\"Untitled\")\n\t    p_version_file_path: StringProperty(\n\t           name=\"Any other property you want\",\n\t           description=\"\",\n\t           default=\"\")\n"]}
{"filename": "Live_Addon/props/__init__.py", "chunked_list": ["import bpy\n\tfrom . import Live_Addon\n\tfrom . import prefs\n\tfrom . import preference\n\tfrom . import internal_prefs\n\tfrom ..utils import common\n\tfrom bpy.props import StringProperty, IntProperty, CollectionProperty\n\tdef register():\n\t    bpy.utils.register_class(Live_Addon.LiveSaveProps)\n\t    bpy.utils.register_class(prefs.LiveSavePreferences)\n", "    bpy.utils.register_class(internal_prefs.MyAddonProperties)\n\t    bpy.utils.register_class(internal_prefs.ListItem)\n\t    bpy.types.WindowManager.LiveSave = bpy.props.PointerProperty(type=Live_Addon.LiveSaveProps)\n\t    bpy.types.WindowManager.my_addon_props = bpy.props.PointerProperty(type=internal_prefs.MyAddonProperties)\n\t    bpy.types.WindowManager.my_list = CollectionProperty(type=internal_prefs.ListItem)\n\t    bpy.types.WindowManager.list_index = IntProperty(name=\"Index for my_list\", default=0)\n\tdef unregister():\n\t    del bpy.types.WindowManager.my_list\n\t    del bpy.types.WindowManager.list_index\n\t    del bpy.types.WindowManager.my_addon_props\n", "    del bpy.types.WindowManager.LiveSave\n\t    bpy.utils.unregister_class(internal_prefs.ListItem)\n\t    bpy.utils.unregister_class(internal_prefs.MyAddonProperties)\n\t    bpy.utils.unregister_class(prefs.LiveSavePreferences)\n\t    bpy.utils.unregister_class(Live_Addon.LiveSaveProps)\n"]}
{"filename": "Live_Addon/props/preference.py", "chunked_list": ["import bpy\n\tfrom . import Live_Addon\n\tdef module() -> str:\n\t    return Live_Addon.name\n\tdef prefs() -> bpy.types.AddonPreferences:\n\t    return bpy.context.preferences.addons[module()].preferences\n"]}
{"filename": "Live_Addon/ui/n_panel.py", "chunked_list": ["import bpy\n\timport os\n\timport datetime\n\tfrom .. import props\n\tfrom .. import utils\n\tclass LiveSavePanel(bpy.types.Panel):\n\t    bl_label = \"Live Save\"\n\t    bl_idname = \"LIVE_SAVE_PT_panel\"\n\t    bl_space_type = 'VIEW_3D'\n\t    bl_region_type = 'UI'\n", "    bl_category = 'Live Save'\n\t    def draw(self, context):\n\t        layout = self.layout\n\t        addon_prefs = props.preference.prefs()\n\t        myaddonprops = bpy.context.window_manager.my_addon_props\n\t        row = layout.row()\n\t        row.prop(addon_prefs, \"is_enabled\", text=\"Enable Live Save\")\n\t        row = layout.row()\n\t        row.prop(addon_prefs, \"background_save\", text=\"Background Save\")\n\t        row = layout.row()\n", "        row.prop(addon_prefs, \"dynamic_save\", text=\"dynamic Save\")\n\t        layout.separator()\n\t        #only draw when dynamic save is enabled\n\t        if not addon_prefs.dynamic_save:\n\t            row = layout.row()\n\t            row.prop(addon_prefs, \"Timer\", text=\"Timer\")\n\t            layout.separator()\n\t        layout.operator(\"wm.save_as_mainfile_with_browser\")\n\t        layout.separator()\n\t        if addon_prefs.is_enabled:\n", "            layout.operator(\"wm.live_save_message_handler\", text=\"Start Live Save\", emboss=False)\n\t        else:\n\t            layout.operator(\"wm.live_save_message_handler\", text=\"Stop Live Save\", emboss=False)\n\t        layout.separator()\n\t        if bpy.data.is_saved:\n\t            if bpy.data.is_dirty:\n\t                layout.label(text=\"Edited\", icon='ERROR')\n\t            elif os.path.exists(bpy.data.filepath):\n\t                last_save_time = datetime.datetime.fromtimestamp(os.path.getmtime(bpy.data.filepath))\n\t                layout.label(text=f\"Saved at {last_save_time:%Y-%m-%d %H:%M:%S}\")\n", "        else:\n\t            if os.path.exists(bpy.context.window_manager.my_addon_props.file_path):\n\t                last_save_time = datetime.datetime.fromtimestamp(os.path.getmtime(bpy.context.window_manager.my_addon_props.file_path))\n\t                layout.label(text=f\"Saved at {last_save_time:%Y-%m-%d %H:%M:%S}\")\n\t            else:\n\t                layout.label(text=\"Edited\", icon='ERROR')\n"]}
{"filename": "Live_Addon/ui/__init__.py", "chunked_list": ["import bpy\n\tfrom . import n_panel\n\tfrom . import menu_label\n\tfrom . import p_version_n_panel\n\tfrom . import version_n_panel\n\tfrom . import uilist_p_version\n\tdef register():\n\t    bpy.utils.register_class(n_panel.LiveSavePanel)\n\t    bpy.utils.register_class(menu_label.SaveStatusPanel)\n\t    bpy.utils.register_class(p_version_n_panel.LiveSavePVersionPanel)\n", "    bpy.utils.register_class(version_n_panel.LiveSaveVersionPanel)\n\t    bpy.utils.register_class(uilist_p_version.MY_UL_List)\n\t    bpy.utils.register_class(uilist_p_version.LIST_OT_NewItem)\n\t    bpy.utils.register_class(uilist_p_version.LIST_OT_DeleteItem)\n\t    bpy.utils.register_class(uilist_p_version.OPEN_OT_P_VERSION_INDEX)\n\t    bpy.types.VIEW3D_MT_editor_menus.append(menu_label.SaveStatusPanel.draw)\n\t    if bpy.app.timers.is_registered(menu_label.redraw_menu):\n\t        bpy.app.timers.register(menu_label.redraw_menu, persistent=True, first_interval=1.0)\n\tdef unregister():\n\t    if bpy.app.timers.is_registered(menu_label.redraw_menu):\n", "        bpy.app.timers.unregister(menu_label.redraw_menu)\n\t    bpy.types.VIEW3D_MT_editor_menus.remove(menu_label.SaveStatusPanel.draw)\n\t    bpy.utils.unregister_class(menu_label.SaveStatusPanel)\n\t    bpy.utils.unregister_class(n_panel.LiveSavePanel)\n\t    bpy.utils.unregister_class(p_version_n_panel.LiveSavePVersionPanel)\n\t    bpy.utils.unregister_class(version_n_panel.LiveSaveVersionPanel)\n\t    bpy.utils.unregister_class(uilist_p_version.MY_UL_List)\n\t    bpy.utils.unregister_class(uilist_p_version.LIST_OT_NewItem)\n\t    bpy.utils.unregister_class(uilist_p_version.LIST_OT_DeleteItem)\n\t    bpy.utils.unregister_class(uilist_p_version.OPEN_OT_P_VERSION_INDEX)\n"]}
{"filename": "Live_Addon/ui/uilist_p_version.py", "chunked_list": ["import os\n\timport bpy\n\tfrom bpy.types import UIList, Operator\n\tclass MY_UL_List(UIList):\n\t    \"\"\"Demo UIList.\"\"\"\n\t    def draw_item(self, context, layout, data, item, icon, active_data,\n\t                  active_propname, index):\n\t        # We could write some code to decide which icon to use here...\n\t        custom_icon = 'OBJECT_DATAMODE'\n\t        # Make sure your code supports all 3 layout types\n", "        if self.layout_type in {'DEFAULT', 'COMPACT'}:\n\t            layout.label(text=item.name, icon = custom_icon)\n\t            #layout.operator('my_list.open_p_version_index', text=\"\", icon='GREASEPENCIL')\n\t        elif self.layout_type in {'GRID'}:\n\t            layout.alignment = 'CENTER'\n\t            layout.label(text=\"\", icon = custom_icon)\n\tclass LIST_OT_NewItem(Operator):\n\t    \"\"\"Add a new item to the list.\"\"\"\n\t    bl_idname = \"my_list.new_item\"\n\t    bl_label = \"Add a new item\"\n", "    def execute(self, context):\n\t        bpy.ops.live_save.save_p_version('EXEC_DEFAULT')\n\t        return{'FINISHED'}\n\tclass LIST_OT_DeleteItem(Operator):\n\t    \"\"\"Delete the selected item from the list.\"\"\"\n\t    bl_idname = \"my_list.delete_item\"\n\t    bl_label = \"Deletes an item\"\n\t    @classmethod\n\t    def poll(cls, context):\n\t        return context.window_manager.my_list\n", "    def execute(self, context):\n\t        my_list = context.window_manager.my_list\n\t        index = context.window_manager.list_index\n\t        if os.path.exists(my_list[index].p_version_file_path):\n\t            os.remove(my_list[index].p_version_file_path)\n\t        my_list.remove(index)\n\t        context.window_manager.list_index = min(max(0, index - 1), len(my_list) - 1)\n\t        return{'FINISHED'}\n\tclass OPEN_OT_P_VERSION_INDEX(Operator):\n\t    \"\"\"Open the selected item from the list.\"\"\"\n", "    bl_idname = \"my_list.open_p_version_index\"\n\t    bl_label = \"Open an item\"\n\t    @classmethod\n\t    def poll(cls, context):\n\t        return context.window_manager.my_list\n\t    def execute(self, context):\n\t        my_list = context.window_manager.my_list\n\t        index = context.window_manager.list_index\n\t        if os.path.exists(my_list[index].p_version_file_path):\n\t            bpy.ops.wm.open_mainfile(filepath=my_list[index].p_version_file_path)\n", "        else:\n\t            self.report({'ERROR'}, 'File not found')\n\t        return{'FINISHED'}\n\t\"\"\"\n\tclass LIST_OT_MoveItem(Operator):\n\t    \"\"\"\"Move an item in the list.\"\"\"\"\n\t    bl_idname = \"my_list.move_item\"\n\t    bl_label = \"Move an item in the list\"\n\t    direction: bpy.props.EnumProperty(items=(('UP', 'Up', \"\"), ('DOWN', 'Down', \"\"),))\n\t    @classmethod\n", "    def poll(cls, context):\n\t        return context.window_manager.my_list\n\t    def move_index(self):\n\t        \"\"\"\" Move index of an item render queue while clamping it. \"\"\"\"\n\t        index = bpy.context.window_manager.list_index\n\t        list_length = len(bpy.context.window_manager.my_list) - 1  # (index starts at 0)\n\t        new_index = index + (-1 if self.direction == 'UP' else 1)\n\t        bpy.context.window_manager.list_index = max(0, min(new_index, list_length))\n\t    def execute(self, context):\n\t        my_list = context.window_manager.my_list\n", "        index = context.window_manager.list_index\n\t        neighbor = index + (-1 if self.direction == 'UP' else 1)\n\t        my_list.move(neighbor, index)\n\t        self.move_index()\n\t        return{'FINISHED'}\n\t\"\"\"\n"]}
{"filename": "Live_Addon/ui/menu_label.py", "chunked_list": ["import bpy\n\timport os\n\timport time\n\tclass SaveStatusPanel(bpy.types.Operator):\n\t    bl_idname = \"wm.save_status_panel\"\n\t    bl_label = \"Save Status\"\n\t    def draw(self, context):\n\t        layout = self.layout\n\t        # check if file is dirty\n\t        if bpy.data.is_dirty:\n", "            row = layout.row(align=True)\n\t            row.label(text=\"Edited\", icon='ERROR')\n\t        else:\n\t            row = layout.row(align=True)\n\t            row.label(text=\"\", icon='NONE')\n\t    def modal(self, context, event):\n\t        if event.type in {'ESC'}:\n\t            wm = context.window_manager\n\t            wm.event_timer_remove(self._timer)\n\t            wm.modal_handler_remove(self)\n", "            return {'CANCELLED'}\n\t        elif event.type == 'TIMER':\n\t            if bpy.data.is_dirty:\n\t                self.tag_redraw()\n\t            else:\n\t                self.tag_redraw()\n\t        return {'PASS_THROUGH'}\n\tdef redraw_menu():\n\t    for area in bpy.context.screen.areas:\n\t        if area.type == 'VIEW_3D':\n", "            for region in area.regions:\n\t                if region.type == 'UI':\n\t                    region.tag_redraw()\n\t    return 0.1\n"]}
{"filename": "Live_Addon/ui/version_n_panel.py", "chunked_list": ["import bpy\n\timport os\n\timport datetime\n\tfrom .. import props\n\tfrom .. import utils\n\tclass LiveSaveVersionPanel(bpy.types.Panel):\n\t    bl_label = \"Version\"\n\t    bl_idname = \"LIVE_SAVE_VERSION_PT_panel\"\n\t    bl_space_type = 'VIEW_3D'\n\t    bl_region_type = 'UI'\n", "    bl_category = 'Live Save'\n\t    def draw(self, context):\n\t        layout = self.layout\n\t        props.preference.prefs()\n\t        myaddonprops = bpy.context.window_manager.my_addon_props\n\t        bx = layout.box().column()\n\t        bx.prop(myaddonprops, \"is_enabled_version\", text=\"Enable Version\")\n\t        col = bx.column()\n\t        col.enabled = myaddonprops.is_enabled_version\n\t        col.prop(myaddonprops, \"version_count\", text=\"Versions Count\")\n", "        col.prop(myaddonprops, \"version_timer\", text=\"Timer Version\")\n"]}
{"filename": "Live_Addon/ui/p_version_n_panel.py", "chunked_list": ["import bpy\n\timport os\n\timport datetime\n\tfrom .. import props\n\tfrom .. import utils\n\tclass LiveSavePVersionPanel(bpy.types.Panel):\n\t    bl_label = \"Permenant Version\"\n\t    bl_idname = \"LIVE_SAVE_P_VERSION_PT_panel\"\n\t    bl_space_type = 'VIEW_3D'\n\t    bl_region_type = 'UI'\n", "    bl_category = 'Live Save'\n\t    def draw(self, context):\n\t        layout = self.layout\n\t        addon_prefs = props.preference.prefs()\n\t        myaddonprops = bpy.context.window_manager.my_addon_props\n\t        WindowManager = context.window_manager\n\t        if WindowManager.my_list:\n\t            row = layout.box().column()\n\t            row.template_list(\"MY_UL_List\", \"The_List\", WindowManager,\n\t                              \"my_list\", WindowManager, \"list_index\")\n", "            raw = row.row(align=True)\n\t            raw.operator('my_list.new_item', text='NEW', icon='ADD')\n\t            raw.operator('my_list.delete_item', text='REMOVE', icon='REMOVE')\n\t            item = WindowManager.my_list[WindowManager.list_index]\n\t            row.operator('my_list.open_p_version_index', text=\"\", icon='GREASEPENCIL')\n\t            #row.prop(item, \"name\")\n\t        bx = layout.box().column()\n\t        sx = bx.grid_flow(align=True)\n\t        sx.operator(\"livesave.load_pre\", text=\"\", icon='REW')\n\t        sx.operator(\"livesave.load_next\", text=\"\", icon='FF')\n", "        bx.operator(\"live_save.save_p_version\", text=\"Save Permenant Version\")\n\t        bx = layout.box().column()\n\t        bx.operator(\"livesave.load_first\", text=\"First Permenant Version\")\n\t        bx.operator(\"livesave.load_last\", text=\"Last Permenant Version\")\n\t        bx.operator(\"livesave.load_original\", text=\"Load Original File\")\n\t        #bx.operator(\"live_save.open_p_version_folder\", text=\"Open Permenant Version Folder\")\n\t        #bx.operator(\"live_save.delete_p_version\", text=\"Delete Permenant Version\")\n"]}
{"filename": "Live_Addon/timer/save_version.py", "chunked_list": ["import re\n\timport bpy\n\timport os\n\timport shutil\n\tfrom .. import utils\n\tfrom .. import props\n\tprefs = props.preference.prefs()\n\tdef save_version():\n\t    file_path12 = bpy.context.window_manager.my_addon_props.file_path\n\t    blend_match = r\"\\.blend\"\n", "    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n\t    matched_blend = re.search(blend_match, file_path12)\n\t    # Get the current Blender file path\n\t    if bpy.data.is_saved and bpy.data.is_dirty:\n\t        filepath = bpy.data.filepath\n\t        # Extract the project name without the file extension\n\t        project_name = os.path.splitext(os.path.basename(filepath))[0]\n\t        # Create the version folder name with the project name and version count\n\t        version_folder_name = f\"{project_name}_version_folder\"\n\t        # Create the full path for the version folder\n", "        version_folder_path = os.path.join(os.path.dirname(filepath), version_folder_name)\n\t        # Create the version folder if it doesn't exist\n\t        if not os.path.exists(version_folder_path):\n\t            os.makedirs(version_folder_path, exist_ok=True)\n\t    elif not os.path.isdir(file_path12) and matched_blend and os.path.exists(file_path12) and utils.comparison.compare_blend_data():\n\t        version_folder_path = bpy.context.window_manager.my_addon_props.file_path_version\n\t        # Extract name without the .blender extension but not with os.path.splitext\n\t        #project_name = os.path.basename(version_folder_path)\n\t        #create project name without the .blend extension\n\t        #project_name = project_name[:-15]\n", "        # Create the version folder if it doesn't exist\n\t        if not os.path.exists(version_folder_path):\n\t            os.makedirs(version_folder_path, exist_ok=True)\n\t    else:\n\t        return bpy.context.window_manager.my_addon_props.version_timer\n\t    # get existing version files and sort by name\n\t    version_files = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n\t    # Delete the oldest version(s) if there are more than three versions\n\t    if len(version_files) >= bpy.context.window_manager.my_addon_props.version_count:\n\t        # delete the oldest version files until bpy.context.window_manager.my_addon_props.version_count is reached\n", "        for i in range(len(version_files) - bpy.context.window_manager.my_addon_props.version_count + 1):\n\t            os.remove(os.path.join(version_folder_path, version_files[i]))\n\t    version_files_new = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n\t        # rename existing version files to ensure unique names\n\t    for i in range(len(version_files_new)):\n\t        if len(version_files_new) == 0:\n\t            break\n\t        elif re.search(timestep_regex, version_files_new[i]):\n\t            project_name = version_files_new[i].split(\"_v\")[0]\n\t        old_path = os.path.join(version_folder_path, version_files_new[i])\n", "        new_name = f\"{project_name}_v{i + 1:03}.blend\"\n\t        new_path = os.path.join(version_folder_path, new_name)\n\t        os.rename(old_path, new_path)\n\t    version_count = len(os.listdir(version_folder_path))\n\t    if re.search(timestep_regex, version_folder_path):\n\t        # Extract name without the .blender extension but not with os.path.splitext\n\t        project_name = os.path.basename(version_folder_path)\n\t        #create project name without the .blend extension\n\t        project_name = project_name[:-15]\n\t    # Save the current version with a unique file name\n", "    current_version_name = f\"{project_name}_v{version_count + 1:03d}.blend\"\n\t    current_version_path = os.path.join(version_folder_path, current_version_name)\n\t    bpy.ops.wm.save_as_mainfile(filepath=current_version_path, copy=True)\n\t    return bpy.context.window_manager.my_addon_props.version_timer\n\tdef update_version_timer(self, context):\n\t    if bpy.app.timers.is_registered(save_version):\n\t        bpy.app.timers.unregister(save_version)\n\t        bpy.app.timers.register(save_version)\n\tdef update_version_bool(self, context):\n\t    if self.is_enabled_version:\n", "        if not bpy.app.timers.is_registered(save_version):\n\t            bpy.app.timers.register(save_version)\n\t    else:\n\t        if bpy.app.timers.is_registered(save_version):\n\t            bpy.app.timers.unregister(save_version)\n"]}
{"filename": "Live_Addon/timer/__init__.py", "chunked_list": ["import bpy\n\tfrom . import save_version\n\tfrom .. import props\n\tdef register():\n\t    if bpy.context.window_manager.my_addon_props.is_enabled_version:\n\t        if not bpy.app.timers.is_registered(save_version.save_version):\n\t            interval = bpy.context.window_manager.my_addon_props.version_timer\n\t            bpy.app.timers.register(save_version.save_version, first_interval=interval, persistent=True)\n\tdef unregister():\n\t    if bpy.app.timers.is_registered(save_version.save_version):\n", "        bpy.app.timers.unregister(save_version.save_version)\n"]}
