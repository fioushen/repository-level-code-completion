{"filename": "tests/test_sample.py", "chunked_list": ["# Sample Test passing with nose and pytest\n\tdef test_pass():\n\t    pass\n"]}
{"filename": "kplugins/async_utils.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\tasync def handle_return(\n\t    out_or_err: asyncio.streams.StreamReader,\n\t    log_file: Optional[Path] = None,\n\t    to_console: bool = True,\n\t) -> None:\n\t    with open(log_file, \"w\") as f:\n", "        while True:\n\t            # Without this sleep, the program won't exit\n\t            await asyncio.sleep(0)\n\t            data = await out_or_err.readline()\n\t            line = data.decode().strip()\n\t            if line:\n\t                if to_console:\n\t                    print(line)\n\t                f.write(line + \"\\n\")\n\tasync def execute_and_stream_output(\n", "    command: str, log_file_dir: Path, log_file_str: str\n\t) -> asyncio.subprocess.Process:\n\t    # Best not to use shell, but I can't get create_subprocess_exec to work here\n\t    proc = await asyncio.create_subprocess_shell(\n\t        command,\n\t        stdin=asyncio.subprocess.PIPE,\n\t        stdout=asyncio.subprocess.PIPE,\n\t        stderr=asyncio.subprocess.PIPE,\n\t    )\n\t    asyncio.create_task(\n", "        handle_return(proc.stdout, log_file=log_file_dir / f\"{log_file_str}_out.log\")\n\t    )\n\t    asyncio.create_task(\n\t        handle_return(proc.stderr, log_file=log_file_dir / f\"{log_file_str}_err.log\")\n\t    )\n\t    # This needs to also handle the \"wait_to_finish\" flag\n\t    await proc.wait()\n\t    return proc\n"]}
{"filename": "kplugins/materials.py", "chunked_list": ["\"\"\"Register materials.\"\"\"\n\tfrom __future__ import annotations\n\tfrom typing import Callable, Dict, Tuple, Union\n\timport numpy as np\n\tMaterialSpec = Union[str, float, Tuple[float, float], Callable]\n\tmaterial_name_to_meep: Dict[str, MaterialSpec] = {\n\t    \"si\": \"Si\",\n\t    \"sin\": \"Si3N4_NIR\",\n\t    \"sio2\": \"SiO2\",\n\t}\n", "material_name_to_lumerical: Dict[str, MaterialSpec] = {\n\t    \"si\": \"Si (Silicon) - Palik\",\n\t    \"sio2\": \"SiO2 (Glass) - Palik\",\n\t    \"sin\": \"Si3N4 (Silicon Nitride) - Phillip\",\n\t}\n\t# default materials\n\tdef si(wav: np.ndarray) -> np.ndarray:\n\t    \"\"\"Silicon crystalline.\"\"\"\n\t    from gdsfactory.simulation.gtidy3d.materials import si\n\t    return si(wav)\n", "def sio2(wav: np.ndarray) -> np.ndarray:\n\t    \"\"\"Silicon oxide.\"\"\"\n\t    from gdsfactory.simulation.gtidy3d.materials import sio2\n\t    return sio2(wav)\n\tdef sin(wav: np.ndarray) -> np.ndarray:\n\t    \"\"\"Silicon Nitride.\"\"\"\n\t    from gdsfactory.simulation.gtidy3d.materials import sin\n\t    return sin(wav)\n\tmaterials_index = {\"si\": si, \"sio2\": sio2, \"sin\": sin}\n\t__all__ = [\n", "    \"material_name_to_meep\",\n\t    \"material_name_to_lumerical\",\n\t    \"materials_index\",\n\t    \"si\",\n\t    \"sio2\",\n\t    \"sin\",\n\t]\n"]}
{"filename": "kplugins/get_sparameters_path.py", "chunked_list": ["from __future__ import annotations\n\timport hashlib\n\timport pathlib\n\tfrom copy import deepcopy\n\tfrom functools import partial\n\tfrom pathlib import Path\n\tfrom typing import Any, Optional\n\timport numpy as np\n\timport kfactory as kf\n\tfrom kgeneric import pdk\n", "from kgeneric.pdk import LayerStack\n\tfrom kfactory.kcell import clean_value\n\tfrom kfactory.typings import CellSpec\n\tdef get_kwargs_hash(**kwargs: Any) -> str:\n\t    \"\"\"Returns kwargs parameters hash.\"\"\"\n\t    kwargs_list = [f\"{key}={clean_value(kwargs[key])}\" for key in sorted(kwargs.keys())]\n\t    kwargs_string = \"_\".join(kwargs_list)\n\t    return hashlib.md5(kwargs_string.encode()).hexdigest()[:8]\n\tdef _get_sparameters_path(\n\t    cell: kf.KCell,\n", "    dirpath: Optional[Path] = None,\n\t    **kwargs: Any,\n\t) -> Path:\n\t    \"\"\"Return Sparameters npz filepath hashing simulation settings for \\\n\t            a consistent unique name.\n\t    Args:\n\t        component: component or component factory.\n\t        dirpath: directory to store sparameters in CSV.\n\t            Defaults to active Pdk.sparameters_path.\n\t        kwargs: simulation settings.\n", "    \"\"\"\n\t    dirpath_ = dirpath or pdk.sparameters_path\n\t    # component = f.get_component(component)\n\t    dirpath = pathlib.Path(dirpath_)\n\t    dirpath = (\n\t        dirpath / cell.function_name\n\t        if hasattr(cell, \"function_name\")\n\t        else dirpath\n\t    )\n\t    dirpath.mkdir(exist_ok=True, parents=True)\n", "    return dirpath / f\"{cell.hash().hex()}_{get_kwargs_hash(**kwargs)}.npz\"\n\tdef _get_sparameters_data(\n\t    component: ComponentSpec, **kwargs: Any\n\t) -> np.ndarray[str, np.dtype[Any]]:\n\t    \"\"\"Returns Sparameters data in a pandas DataFrame.\n\t    Keyword Args:\n\t        component: component.\n\t        dirpath: directory path to store sparameters.\n\t        kwargs: simulation settings.\n\t    \"\"\"\n", "    component = kf.get_component(component)\n\t    kwargs.update(component=component)\n\t    filepath = _get_sparameters_path(component=component, **kwargs)\n\t    return np.ndarray(np.load(filepath))\n\tget_sparameters_path_meow = partial(_get_sparameters_path, tool=\"meow\")\n\tget_sparameters_path_meep = partial(_get_sparameters_path, tool=\"meep\")\n\tget_sparameters_path_lumerical = partial(_get_sparameters_path, tool=\"lumerical\")\n\tget_sparameters_path_tidy3d = partial(_get_sparameters_path, tool=\"tidy3d\")\n\tget_sparameters_data_meep = partial(_get_sparameters_data, tool=\"meep\")\n\tget_sparameters_data_lumerical = partial(_get_sparameters_data, tool=\"lumerical\")\n", "get_sparameters_data_tidy3d = partial(_get_sparameters_data, tool=\"tidy3d\")\n\tif __name__ == \"__main__\":\n\t    # c = kf.pcells.taper(length=1.0, width1=0.5, width2=0.5, layer=1)\n\t    # p = get_sparameters_path_lumerical(c)\n\t    # sp = np.load(p)\n\t    # spd = dict(sp)\n\t    # print(spd)\n\t    # test_get_sparameters_path(test=False)\n\t    # test_get_sparameters_path(test=True)\n\t    print(\"\")\n"]}
{"filename": "kplugins/plot.py", "chunked_list": ["from __future__ import annotations\n\timport re\n\tfrom functools import partial\n\tfrom itertools import combinations\n\tfrom typing import Dict, Optional, Sequence, Tuple\n\timport matplotlib.pyplot as plt\n\timport numpy as np\n\timport kgeneric as kf\n\tdef _check_ports(sp: Dict[str, np.ndarray], ports: Sequence[str]):\n\t    \"\"\"Ensure ports exist in Sparameters.\"\"\"\n", "    for port in ports:\n\t        if port not in sp:\n\t            raise ValueError(f\"Did not find port {port!r} in {list(sp.keys())}\")\n\tdef plot_sparameters(\n\t    sp: Dict[str, np.ndarray],\n\t    logscale: bool = True,\n\t    keys: Optional[Tuple[str, ...]] = None,\n\t    with_simpler_input_keys: bool = False,\n\t    with_simpler_labels: bool = True,\n\t) -> None:\n", "    \"\"\"Plots Sparameters from a dict of np.ndarrays.\n\t    Args:\n\t        sp: Sparameters np.ndarray.\n\t        logscale: plots 20*log10(S).\n\t        keys: list of keys to plot, plots all by default.\n\t        with_simpler_input_keys: You can use S12 keys instead of o1@0,o2@0.\n\t        with_simpler_labels: uses S11, S12 in plot labels instead of o1@0,o2@0.\n\t    .. plot::\n\t        :include-source:\n\t        import gdsfactory as gf\n", "        import gdsfactory.simulation as sim\n\t        sp = sim.get_sparameters_data_lumerical(component=gf.components.mmi1x2)\n\t        sim.plot.plot_sparameters(sp, logscale=True)\n\t    \"\"\"\n\t    w = sp[\"wavelengths\"] * 1e3\n\t    keys = keys or [key for key in sp if not key.lower().startswith(\"wav\")]\n\t    for key in keys:\n\t        if with_simpler_input_keys:\n\t            key = f\"o{key[1]}@0,o{key[2]}@0\"\n\t            if key not in sp:\n", "                raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n\t        if with_simpler_labels and \"o\" in key and \"@\" in key:\n\t            port_mode1_port_mode2 = key.split(\",\")\n\t            if len(port_mode1_port_mode2) != 2:\n\t                raise ValueError(f\"{key!r} needs to be 'portin@mode,portout@mode'\")\n\t            port_mode1, port_mode2 = port_mode1_port_mode2\n\t            port1, _mode1 = port_mode1.split(\"@\")\n\t            port2, _mode2 = port_mode2.split(\"@\")\n\t            alias = f\"S{port1[1:]}{port2[1:]}\"\n\t        else:\n", "            alias = key\n\t        if key not in sp:\n\t            raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n\t        y = sp[key]\n\t        y = 20 * np.log10(np.abs(y)) if logscale else np.abs(y) ** 2\n\t        plt.plot(w, y, label=alias)\n\t    plt.legend()\n\t    plt.xlabel(\"wavelength (nm)\")\n\t    plt.ylabel(\"|S| (dB)\") if logscale else plt.ylabel(\"$|S|^2$\")\n\t    plt.show()\n", "def plot_sparameters_phase(\n\t    sp: Dict[str, np.ndarray],\n\t    logscale: bool = True,\n\t    keys: Optional[Tuple[str, ...]] = None,\n\t    with_simpler_input_keys: bool = False,\n\t    with_simpler_labels: bool = True,\n\t) -> None:\n\t    w = sp[\"wavelengths\"] * 1e3\n\t    keys = keys or [key for key in sp if not key.lower().startswith(\"wav\")]\n\t    for key in keys:\n", "        if with_simpler_input_keys:\n\t            key = f\"o{key[1]}@0,o{key[2]}@0\"\n\t            if key not in sp:\n\t                raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n\t        if with_simpler_labels and \"o\" in key and \"@\" in key:\n\t            port_mode1_port_mode2 = key.split(\",\")\n\t            if len(port_mode1_port_mode2) != 2:\n\t                raise ValueError(f\"{key!r} needs to be 'portin@mode,portout@mode'\")\n\t            port_mode1, port_mode2 = port_mode1_port_mode2\n\t            port1, _mode1 = port_mode1.split(\"@\")\n", "            port2, _mode2 = port_mode2.split(\"@\")\n\t            alias = f\"S{port1[1:]}{port2[1:]}\"\n\t        else:\n\t            alias = key\n\t        if key not in sp:\n\t            raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n\t        y = sp[key]\n\t        y = np.angle(y)\n\t        plt.plot(w, y, label=alias)\n\t    plt.legend()\n", "    plt.xlabel(\"wavelength (nm)\")\n\t    plt.ylabel(\"S (deg)\")\n\t    plt.show()\n\tdef plot_imbalance(\n\t    sp: Dict[str, np.ndarray], ports: Sequence[str], ax: Optional[plt.Axes] = None\n\t) -> None:\n\t    \"\"\"Plots imbalance in dB for coupler.\n\t    The imbalance is always defined between two ports, so this function plots the\n\t    imbalance between all unique port combinations.\n\t    Args:\n", "        sp: sparameters dict np.ndarray.\n\t        ports: list of port name @ mode index. o1@0 is the fundamental mode for o1 port.\n\t        ax: matplotlib axis object to draw into.\n\t    \"\"\"\n\t    _check_ports(sp, ports)\n\t    power = {port: np.abs(sp[port]) ** 2 for port in ports}\n\t    x = sp[\"wavelengths\"] * 1e3\n\t    if ax is None:\n\t        _, ax = plt.subplots()\n\t    for p1, p2 in combinations(ports, 2):\n", "        p1in, p1out = re.findall(r\"\\d+\", p1)[::2]\n\t        p2in, p2out = re.findall(r\"\\d+\", p2)[::2]\n\t        label = f\"$S_{{{p1in}{p1out}}}, S_{{{p2in}{p2out}}}$\"\n\t        ax.plot(x, 10 * np.log10(1 - (power[p1] - power[p2])), label=label)\n\t    ax.set_xlim((x[0], x[-1]))\n\t    ax.set_xlabel(\"wavelength (nm)\")\n\t    ax.set_ylabel(\"imbalance (dB)\")\n\t    plt.legend()\n\tdef plot_loss(\n\t    sp: Dict[str, np.ndarray], ports: Sequence[str], ax: Optional[plt.Axes] = None\n", ") -> None:\n\t    \"\"\"Plots loss dB for coupler.\n\t    Args:\n\t        sp: sparameters dict np.ndarray.\n\t        ports: list of port name @ mode index. o1@0 is the fundamental mode for o1 port.\n\t        ax: matplotlib axis object to draw into.\n\t    \"\"\"\n\t    _check_ports(sp, ports)\n\t    power = {port: np.abs(sp[port]) ** 2 for port in ports}\n\t    x = sp[\"wavelengths\"] * 1e3\n", "    if ax is None:\n\t        _, ax = plt.subplots()\n\t    for n, p in power.items():\n\t        pin, pout = re.findall(r\"\\d+\", n)[::2]\n\t        ax.plot(x, 10 * np.log10(p), label=f\"$|S_{{{pin}{pout}}}|^2$\")\n\t    if len(ports) > 1:\n\t        ax.plot(x, 10 * np.log10(sum(power.values())), \"k--\", label=\"Total\")\n\t    ax.set_xlim((x[0], x[-1]))\n\t    ax.set_xlabel(\"wavelength (nm)\")\n\t    ax.set_ylabel(\"excess loss (dB)\")\n", "    plt.legend()\n\tdef plot_reflection(\n\t    sp: Dict[str, np.ndarray], ports: Sequence[str], ax: Optional[plt.Axes] = None\n\t) -> None:\n\t    \"\"\"Plots reflection in dB for coupler.\n\t    Args:\n\t        sp: sparameters dict np.ndarray.\n\t        ports: list of port name @ mode index. o1@0 is the fundamental mode for o1 port.\n\t        ax: matplotlib axis object to draw into.\n\t    \"\"\"\n", "    _check_ports(sp, ports)\n\t    power = {port: np.abs(sp[port]) ** 2 for port in ports}\n\t    x = sp[\"wavelengths\"] * 1e3\n\t    if ax is None:\n\t        _, ax = plt.subplots()\n\t    for n, p in power.items():\n\t        pin, pout = re.findall(r\"\\d+\", n)[::2]\n\t        ax.plot(x, 10 * np.log10(p), label=f\"$|S_{{{pin}{pout}}}|^2$\")\n\t    if len(ports) > 1:\n\t        ax.plot(x, 10 * np.log10(sum(power.values())), \"k--\", label=\"Total\")\n", "    ax.set_xlim((x[0], x[-1]))\n\t    ax.set_xlabel(\"wavelength (nm)\")\n\t    ax.set_ylabel(\"reflection (dB)\")\n\t    plt.legend()\n\tplot_loss1x2 = partial(plot_loss, ports=[\"o1@0,o2@0\", \"o1@0,o3@0\"])\n\tplot_loss2x2 = partial(plot_loss, ports=[\"o1@0,o3@0\", \"o1@0,o4@0\"])\n\tplot_imbalance1x2 = partial(plot_imbalance, ports=[\"o1@0,o2@0\", \"o1@0,o3@0\"])\n\tplot_imbalance2x2 = partial(plot_imbalance, ports=[\"o1@0,o3@0\", \"o1@0,o4@0\"])\n\tplot_reflection1x2 = partial(plot_reflection, ports=[\"o1@0,o1@0\"])\n\tplot_reflection2x2 = partial(plot_reflection, ports=[\"o1@0,o1@0\", \"o2@0,o1@0\"])\n", "if __name__ == \"__main__\":\n\t    import gdsfactory.simulation as sim\n\t    sp = sim.get_sparameters_data_tidy3d(component=kf.cells.mmi1x2)\n\t    # plot_sparameters(sp, logscale=False, keys=[\"o1@0,o2@0\"])\n\t    # plot_sparameters(sp, logscale=False, keys=[\"S21\"])\n\t    # plt.show()\n"]}
{"filename": "kplugins/config.py", "chunked_list": ["\"\"\"Store configuration.\"\"\"\n\t__all__ = [\"PATH\"]\n\timport pathlib\n\thome = pathlib.Path.home()\n\tcwd = pathlib.Path.cwd()\n\tcwd_config = cwd / \"config.yml\"\n\thome_config = home / \".config\" / \"KFactory plugins.yml\"\n\tconfig_dir = home / \".config\"\n\tconfig_dir.mkdir(exist_ok=True)\n\tmodule_path = pathlib.Path(__file__).parent.absolute()\n", "repo_path = module_path.parent\n\tclass Path:\n\t    module = module_path\n\t    repo = repo_path\n\tPATH = Path()\n\tif __name__ == \"__main__\":\n\t    print(PATH)\n"]}
{"filename": "kplugins/port_symmetries.py", "chunked_list": ["port_symmetries_1x1 = {\n\t    \"o1@0,o1@0\": [\"o2@0,o2@0\"],\n\t    \"o2@0,o1@0\": [\"o1@0,o2@0\"],\n\t}\n\tport_symmetries_crossing = {\n\t    \"o1@0,o1@0\": [\"o2@0,o2@0\", \"o3@0,o3@0\", \"o4@0,o4@0\"],\n\t    \"o2@0,o1@0\": [\"o1@0,o2@0\", \"o3@0,o4@0\", \"o4@0,o3@0\"],\n\t    \"o3@0,o1@0\": [\"o1@0,o3@0\", \"o2@0,o4@0\", \"o4@0,o2@0\"],\n\t    \"o4@0,o1@0\": [\"o1@0,o4@0\", \"o2@0,o3@0\", \"o3@0,o2@0\"],\n\t}\n", "if __name__ == \"__main__\":\n\t    import numpy as np\n\t    port_symmetries = port_symmetries_crossing\n\t    sp = dict(wavelengths=np.linspace(1.5, 1.6, 3))\n\t    sp[\"o1@0,o1@0\"] = 2 * np.linspace(1.5, 1.6, 3)\n\t    for key, symmetries in port_symmetries.items():\n\t        for sym in symmetries:\n\t            if key in sp:\n\t                sp[sym] = sp[key]\n"]}
{"filename": "kplugins/__init__.py", "chunked_list": ["\"\"\"Kplugins - KFactory plugins\"\"\"\n\t__version__ = '0.0.2'\n"]}
{"filename": "kplugins/typings.py", "chunked_list": ["import pathlib\n\tfrom typing import Callable, Dict, Tuple, Union\n\tMaterialSpec = Union[str, float, Tuple[float, float], Callable]\n\tPathType = pathlib.Path | str\n"]}
{"filename": "kplugins/extensions.py", "chunked_list": ["import numpy as np\n\tfrom typing import List\n\tdef move_polar_rad_copy(pos: List(float), angle: float, length: float) -> np.ndarray:\n\t    \"\"\"Returns the points of a position (pos) with angle, by shifted by certain.\n\t    length.\n\t    Args:\n\t        pos: position.\n\t        angle: in radians.\n\t        length: extension length in um.\n\t    \"\"\"\n", "    c = np.cos(angle)\n\t    s = np.sin(angle)\n\t    return pos + length * np.array([c, s])\n"]}
{"filename": "kplugins/kmeep/get_simulation_grating_fiber.py", "chunked_list": ["\"\"\"Adapted from https://github.com/simbilod/option.\n\tSMF specs from photonics.byu.edu/FiberOpticConnectors.parts/images/smf28.pdf\n\tMFD:\n\t- 10.4 for Cband\n\t- 9.2 for Oband\n\t\"\"\"\n\tfrom __future__ import annotations\n\timport hashlib\n\tfrom typing import Any, Dict, Optional\n\timport meep as mp\n", "import numpy as np\n\tfrom kfactory.kcell import clean_value\n\tfrom typing import List\n\tnm = 1e-3\n\tnSi = 3.47\n\tnSiO2 = 1.44\n\tdef fiber_core_material(fiber_numerical_aperture, fiber_clad_material):\n\t    return (fiber_numerical_aperture**2 + fiber_clad_material**2) ** 0.5\n\tdef get_simulation_grating_fiber(\n\t    period: float = 0.66,\n", "    fill_factor: float = 0.5,\n\t    n_periods: int = 30,\n\t    widths: Optional[List[float]] = None,\n\t    gaps: Optional[List[float]] = None,\n\t    fiber_angle_deg: float = 20.0,\n\t    fiber_xposition: float = 1.0,\n\t    fiber_core_diameter: float = 10.4,\n\t    fiber_numerical_aperture: float = 0.14,\n\t    fiber_clad_material: float = nSiO2,\n\t    nwg: float = nSi,\n", "    nslab: Optional[float] = None,\n\t    clad_material: float = nSiO2,\n\t    nbox: float = nSiO2,\n\t    nsubstrate: float = nSi,\n\t    pml_thickness: float = 1.0,\n\t    substrate_thickness: float = 1.0,\n\t    box_thickness: float = 2.0,\n\t    core_thickness: float = 220 * nm,\n\t    slab_thickness: float = 150 * nm,\n\t    top_clad_thickness: float = 2.0,\n", "    air_gap_thickness: float = 1.0,\n\t    fiber_thickness: float = 2.0,\n\t    resolution: int = 64,  # pixels/um\n\t    wavelength_start: float = 1.4,\n\t    wavelength_stop: float = 1.7,\n\t    wavelength_points: int = 150,\n\t    decay_by: float = 1e-3,\n\t    eps_averaging: bool = False,\n\t    fiber_port_y_offset_from_air: float = 1,\n\t    waveguide_port_x_offset_from_grating_start: float = 10,\n", "    fiber_port_x_size: Optional[float] = None,\n\t    xmargin: float = 10.0,\n\t) -> Dict[str, Any]:\n\t    r\"\"\"Returns simulation results from grating coupler with fiber.\n\t    na**2 = core_material**2 - clad_material**2\n\t    core_material = sqrt(na**2 + core_material**2)\n\t    Args:\n\t        period: fiber grating period in um.\n\t        fill_factor: fraction of the grating period filled with the grating material.\n\t        n_periods: number of periods.\n", "        widths: Optional list of widths. Overrides period, fill_factor, n_periods.\n\t        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n\t        fiber_angle_deg: fiber angle in degrees.\n\t        fiber_xposition: xposition.\n\t        fiber_core_diameter: fiber diameter. 10.4 for Cband and 9.2um for Oband.\n\t        fiber_numerical_aperture: NA.\n\t        fiber_clad_material: fiber cladding index.\n\t        nwg: waveguide index.\n\t        nslab: slab refractive index.\n\t        clad_material: top cladding index.\n", "        nbox: box index bottom.\n\t        nsubstrate: index substrate.\n\t        pml_thickness: pml_thickness (um).\n\t        substrate_thickness: substrate_thickness (um).\n\t        box_thickness: thickness for bottom cladding (um).\n\t        core_thickness: core_thickness (um).\n\t        slab_thickness: slab thickness (um). etch_depth=core_thickness-slab_thickness.\n\t        top_clad_thickness: thickness of the top cladding.\n\t        air_gap_thickness: air gap thickness.\n\t        fiber_thickness: fiber_thickness.\n", "        resolution: resolution pixels/um.\n\t        wavelength_start: min wavelength (um).\n\t        wavelength_stop: max wavelength (um).\n\t        wavelength_points: wavelength points.\n\t        eps_averaging: epsilon averaging.\n\t        fiber_port_y_offset_from_air: y_offset from fiber to air (um).\n\t        waveguide_port_x_offset_from_grating_start: in um.\n\t        fiber_port_x_size: in um.\n\t        xmargin: margin from PML to grating end in um.\n\t    .. code::\n", "                fiber_xposition\n\t                     |\n\t                fiber_core_diameter\n\t             /     /  /     /       |\n\t            /     /  /     /        | fiber_thickness\n\t           /     /  /     /    _ _ _| _ _ _ _ _ _  _\n\t                                    |\n\t                                    | air_gap_thickness\n\t                               _ _ _| _ _ _ _ _ _  _\n\t                                    |\n", "                   clad_material            | top_clad_thickness\n\t                _   _   _      _ _ _| _ _ _ _ _ _  _\n\t          nwg _| |_| |_| |__________|              _\n\t                                    |               |\n\t                 nslab              |core_thickness   | slab_thickness\n\t                ______________ _ _ _|_ _ _ _ _ _ _ _|\n\t                                    |\n\t                 nbox               |box_thickness\n\t                ______________ _ _ _|_ _ _ _ _ _ _ _\n\t                                    |\n", "                 nsubstrate         |substrate_thickness\n\t                ______________ _ _ _|\n\t    |--------------------|<-------->\n\t                            xmargin\n\t    \"\"\"\n\t    wavelengths = np.linspace(wavelength_start, wavelength_stop, wavelength_points)\n\t    wavelength = np.mean(wavelengths)\n\t    freqs = 1 / wavelengths\n\t    widths = widths or n_periods * [period * fill_factor]\n\t    gaps = gaps or n_periods * [period * (1 - fill_factor)]\n", "    nslab = nslab or nwg\n\t    settings = dict(\n\t        widths=widths,\n\t        gaps=gaps,\n\t        n_periods=n_periods,\n\t        nslab=nslab,\n\t        fiber_angle_deg=fiber_angle_deg,\n\t        fiber_xposition=fiber_xposition,\n\t        fiber_core_diameter=fiber_core_diameter,\n\t        fiber_numerical_aperture=fiber_numerical_aperture,\n", "        fiber_clad_material=fiber_clad_material,\n\t        nwg=nwg,\n\t        clad_material=clad_material,\n\t        nbox=nbox,\n\t        nsubstrate=nsubstrate,\n\t        pml_thickness=pml_thickness,\n\t        substrate_thickness=substrate_thickness,\n\t        box_thickness=box_thickness,\n\t        core_thickness=core_thickness,\n\t        top_clad_thickness=top_clad_thickness,\n", "        air_gap_thickness=air_gap_thickness,\n\t        fiber_thickness=fiber_thickness,\n\t        resolution=resolution,\n\t        wavelength_start=wavelength_start,\n\t        wavelength_stop=wavelength_stop,\n\t        wavelength_points=wavelength_points,\n\t        decay_by=decay_by,\n\t        eps_averaging=eps_averaging,\n\t        fiber_port_y_offset_from_air=fiber_port_y_offset_from_air,\n\t        waveguide_port_x_offset_from_grating_start=waveguide_port_x_offset_from_grating_start,\n", "        fiber_port_x_size=fiber_port_x_size,\n\t    )\n\t    settings_string = clean_value(settings)\n\t    settings_hash = hashlib.md5(settings_string.encode()).hexdigest()[:8]\n\t    # Angle in radians\n\t    fiber_angle = np.radians(fiber_angle_deg)\n\t    # Z (Y)-domain\n\t    sz = (\n\t        +pml_thickness\n\t        + substrate_thickness\n", "        + box_thickness\n\t        + core_thickness\n\t        + top_clad_thickness\n\t        + air_gap_thickness\n\t        + fiber_thickness\n\t        + pml_thickness\n\t    )\n\t    # XY (X)-domain\n\t    # Assume fiber port dominates\n\t    fiber_port_y = (\n", "        -sz / 2\n\t        + core_thickness\n\t        + top_clad_thickness\n\t        + air_gap_thickness\n\t        + fiber_port_y_offset_from_air\n\t    )\n\t    fiber_port_x_offset_from_angle = np.abs(fiber_port_y * np.tan(fiber_angle))\n\t    length_grating = np.sum(widths) + np.sum(gaps)\n\t    sxy = (\n\t        2 * xmargin\n", "        + 2 * pml_thickness\n\t        + 2 * fiber_port_x_offset_from_angle\n\t        + length_grating\n\t    )\n\t    # Materials from indices\n\t    slab_material = mp.Medium(index=nslab)\n\t    wg_material = mp.Medium(index=nwg)\n\t    top_clad_material = mp.Medium(index=clad_material)\n\t    bottom_clad_material = mp.Medium(index=nbox)\n\t    fiber_core_material = (\n", "        fiber_numerical_aperture**2 + fiber_clad_material**2\n\t    ) ** 0.5\n\t    fiber_clad_material = mp.Medium(index=fiber_clad_material)\n\t    fiber_core_material = mp.Medium(index=fiber_core_material)\n\t    # Useful reference point\n\t    grating_start = (\n\t        -fiber_xposition\n\t    )  # Since fiber dominates, keep it centered and offset the grating\n\t    # Initialize domain x-z plane simulation\n\t    cell_size = mp.Vector3(sxy, sz)\n", "    # Ports (position, sizes, directions)\n\t    fiber_port_y = -sz / 2 + (\n\t        +pml_thickness\n\t        + substrate_thickness\n\t        + box_thickness\n\t        + core_thickness\n\t        + top_clad_thickness\n\t        + air_gap_thickness\n\t        + fiber_port_y_offset_from_air\n\t    )\n", "    fiber_port_center = mp.Vector3(fiber_port_x_offset_from_angle, fiber_port_y)\n\t    fiber_port_x_size = fiber_port_x_size or 3.5 * fiber_core_diameter\n\t    fiber_port_size = mp.Vector3(fiber_port_x_size, 0, 0)\n\t    # fiber_port_direction = mp.Vector3(y=-1).rotate(mp.Vector3(z=1), -1 * fiber_angle)\n\t    waveguide_port_y = -sz / 2 + (\n\t        +pml_thickness\n\t        + substrate_thickness\n\t        + box_thickness / 2\n\t        + core_thickness / 2\n\t        + top_clad_thickness / 2\n", "    )\n\t    waveguide_port_x = grating_start - waveguide_port_x_offset_from_grating_start\n\t    waveguide_port_center = mp.Vector3(\n\t        waveguide_port_x, waveguide_port_y\n\t    )  # grating_start - dtaper, 0)\n\t    waveguide_port_size = mp.Vector3(\n\t        0, box_thickness + core_thickness / 2 + top_clad_thickness\n\t    )\n\t    waveguide_port_direction = mp.X\n\t    # Geometry\n", "    fiber_clad = 120\n\t    hfiber_geom = 200  # Some large number to make fiber extend into PML\n\t    geometry = [\n\t        mp.Block(\n\t            material=fiber_clad_material,\n\t            center=mp.Vector3(0, waveguide_port_y - core_thickness / 2),\n\t            size=mp.Vector3(fiber_clad, hfiber_geom),\n\t            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n\t            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n\t        )\n", "    ]\n\t    geometry.append(\n\t        mp.Block(\n\t            material=fiber_core_material,\n\t            center=mp.Vector3(x=0),\n\t            size=mp.Vector3(fiber_core_diameter, hfiber_geom),\n\t            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n\t            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n\t        )\n\t    )\n", "    # Air gap\n\t    geometry.append(\n\t        mp.Block(\n\t            material=mp.air,\n\t            center=mp.Vector3(\n\t                0,\n\t                -sz / 2\n\t                + (\n\t                    +pml_thickness\n\t                    + substrate_thickness\n", "                    + box_thickness\n\t                    + core_thickness\n\t                    + top_clad_thickness\n\t                    + air_gap_thickness / 2\n\t                ),\n\t            ),\n\t            size=mp.Vector3(mp.inf, air_gap_thickness),\n\t        )\n\t    )\n\t    # Top cladding\n", "    geometry.append(\n\t        mp.Block(\n\t            material=top_clad_material,\n\t            center=mp.Vector3(\n\t                0,\n\t                -sz / 2\n\t                + (\n\t                    +pml_thickness\n\t                    + substrate_thickness\n\t                    + box_thickness\n", "                    + core_thickness / 2\n\t                    + top_clad_thickness / 2\n\t                ),\n\t            ),\n\t            size=mp.Vector3(mp.inf, core_thickness + top_clad_thickness),\n\t        )\n\t    )\n\t    # Bottom cladding\n\t    geometry.append(\n\t        mp.Block(\n", "            material=bottom_clad_material,\n\t            center=mp.Vector3(\n\t                0,\n\t                -sz / 2 + (+pml_thickness + substrate_thickness + box_thickness / 2),\n\t            ),\n\t            size=mp.Vector3(mp.inf, box_thickness),\n\t        )\n\t    )\n\t    # slab\n\t    geometry.append(\n", "        mp.Block(\n\t            material=slab_material,\n\t            center=mp.Vector3(\n\t                0,\n\t                -sz / 2\n\t                + (\n\t                    +pml_thickness\n\t                    + substrate_thickness\n\t                    + box_thickness\n\t                    + slab_thickness / 2\n", "                ),\n\t            ),\n\t            size=mp.Vector3(mp.inf, slab_thickness),\n\t        )\n\t    )\n\t    etch_depth = core_thickness - slab_thickness\n\t    x = grating_start\n\t    # grating teeth\n\t    for width, gap in zip(widths, gaps):\n\t        geometry.append(\n", "            mp.Block(\n\t                material=wg_material,\n\t                center=mp.Vector3(\n\t                    x + gap / 2,\n\t                    -sz / 2\n\t                    + (\n\t                        +pml_thickness\n\t                        + substrate_thickness\n\t                        + box_thickness\n\t                        + core_thickness\n", "                        - etch_depth / 2\n\t                    ),\n\t                ),\n\t                size=mp.Vector3(width, etch_depth),\n\t            )\n\t        )\n\t        x += width + gap\n\t    # waveguide\n\t    geometry.append(\n\t        mp.Block(\n", "            material=wg_material,\n\t            center=mp.Vector3(\n\t                -sxy / 2,\n\t                -sz / 2\n\t                + (\n\t                    +pml_thickness\n\t                    + substrate_thickness\n\t                    + box_thickness\n\t                    + core_thickness\n\t                    - etch_depth / 2\n", "                ),\n\t            ),\n\t            size=mp.Vector3(sxy, etch_depth),\n\t        )\n\t    )\n\t    # Substrate\n\t    geometry.append(\n\t        mp.Block(\n\t            material=mp.Medium(index=nsubstrate),\n\t            center=mp.Vector3(0, -sz / 2 + pml_thickness / 2 + substrate_thickness / 2),\n", "            size=mp.Vector3(mp.inf, pml_thickness + substrate_thickness),\n\t        )\n\t    )\n\t    # PMLs\n\t    boundary_layers = [mp.PML(pml_thickness)]\n\t    # mode frequency\n\t    fcen = 1 / wavelength\n\t    fwidth = 0.2 * fcen\n\t    # Waveguide source\n\t    sources_directions = [mp.X]\n", "    sources = [\n\t        mp.EigenModeSource(\n\t            src=mp.GaussianSource(frequency=fcen, fwidth=fwidth),\n\t            size=waveguide_port_size,\n\t            center=waveguide_port_center,\n\t            eig_band=1,\n\t            direction=sources_directions[0],\n\t            eig_match_freq=True,\n\t            eig_parity=mp.ODD_Z,\n\t        )\n", "    ]\n\t    # Ports\n\t    waveguide_monitor_port = mp.ModeRegion(\n\t        center=waveguide_port_center + mp.Vector3(x=0.2), size=waveguide_port_size\n\t    )\n\t    fiber_monitor_port = mp.ModeRegion(\n\t        center=fiber_port_center - mp.Vector3(y=0.2), size=fiber_port_size\n\t    )\n\t    sim = mp.Simulation(\n\t        resolution=resolution,\n", "        cell_size=cell_size,\n\t        boundary_layers=boundary_layers,\n\t        geometry=geometry,\n\t        sources=sources,\n\t        dimensions=2,\n\t        eps_averaging=eps_averaging,\n\t    )\n\t    waveguide_monitor = sim.add_mode_monitor(\n\t        freqs, waveguide_monitor_port, yee_grid=True\n\t    )\n", "    fiber_monitor = sim.add_mode_monitor(freqs, fiber_monitor_port)\n\t    field_monitor_point = (0, 0, 0)\n\t    return dict(\n\t        sim=sim,\n\t        cell_size=cell_size,\n\t        freqs=freqs,\n\t        fcen=fcen,\n\t        waveguide_monitor=waveguide_monitor,\n\t        waveguide_port_direction=waveguide_port_direction,\n\t        fiber_monitor=fiber_monitor,\n", "        fiber_angle_deg=fiber_angle_deg,\n\t        sources=sources,\n\t        field_monitor_point=field_monitor_point,\n\t        initialized=False,\n\t        settings=settings,\n\t        settings_hash=settings_hash,\n\t    )\n\tdef get_port_1D_eigenmode(\n\t    sim_dict,\n\t    band_num: int = 1,\n", "    fiber_angle_deg: float = 15.0,\n\t):\n\t    \"\"\"Args are the following.\n\t        sim_dict: simulation dict\n\t        band_num: band number to solve for\n\t    Returns:\n\t        Mode object compatible with /modes plugin\n\t    \"\"\"\n\t    # Initialize\n\t    sim = sim_dict[\"sim\"]\n", "    source = sim_dict[\"sources\"][0]\n\t    waveguide_monitor = sim_dict[\"waveguide_monitor\"]\n\t    fiber_monitor = sim_dict[\"fiber_monitor\"]\n\t    # Obtain source frequency\n\t    fsrc = source.src.frequency\n\t    # Obtain xsection\n\t    center_fiber = fiber_monitor.regions[0].center\n\t    size_fiber = fiber_monitor.regions[0].size\n\t    center_waveguide = waveguide_monitor.regions[0].center\n\t    size_waveguide = waveguide_monitor.regions[0].size\n", "    # Solve for the modes\n\t    if sim_dict[\"initialized\"] is False:\n\t        sim.init_sim()\n\t        sim_dict[\"initialized\"] = True\n\t    # Waveguide\n\t    eigenmode_waveguide = sim.get_eigenmode(\n\t        direction=mp.X,\n\t        where=mp.Volume(center=center_waveguide, size=size_waveguide),\n\t        band_num=band_num,\n\t        kpoint=mp.Vector3(\n", "            fsrc * 3.48, 0, 0\n\t        ),  # Hardcoded index for now, pull from simulation eventually\n\t        frequency=fsrc,\n\t    )\n\t    ys_waveguide = np.linspace(\n\t        center_waveguide.y - size_waveguide.y / 2,\n\t        center_waveguide.y + size_waveguide.y / 2,\n\t        int(sim.resolution * size_waveguide.y),\n\t    )\n\t    x_waveguide = center_waveguide.x\n", "    # Fiber\n\t    eigenmode_fiber = sim.get_eigenmode(\n\t        direction=mp.NO_DIRECTION,\n\t        where=mp.Volume(center=center_fiber, size=size_fiber),\n\t        band_num=band_num,\n\t        kpoint=mp.Vector3(0, fsrc * 1.45, 0).rotate(\n\t            mp.Vector3(z=1), -1 * np.radians(fiber_angle_deg)\n\t        ),  # Hardcoded index for now, pull from simulation eventually\n\t        frequency=fsrc,\n\t    )\n", "    xs_fiber = np.linspace(\n\t        center_fiber.x - size_fiber.x / 2,\n\t        center_fiber.x + size_fiber.x / 2,\n\t        int(sim.resolution * size_fiber.x),\n\t    )\n\t    y_fiber = center_fiber.y\n\t    return (\n\t        x_waveguide,\n\t        ys_waveguide,\n\t        eigenmode_waveguide,\n", "        xs_fiber,\n\t        y_fiber,\n\t        eigenmode_fiber,\n\t    )\n\tdef plot(sim, eps_parameters=None) -> None:\n\t    \"\"\"sim: simulation object.\"\"\"\n\t    sim.plot2D(eps_parameters=eps_parameters)\n\t    # plt.colorbar()\n\tif __name__ == \"__main__\":\n\t    import matplotlib.pyplot as plt\n", "    # Plotting\n\t    epsilons = [1, 1.43482, 1.44, 1.44427, 3.47]\n\t    eps_parameters = {\"contour\": True, \"levels\": np.unique(epsilons)}\n\t    fiber_na = float(np.sqrt(1.44427**2 - 1.43482**2))\n\t    sim_dict = get_simulation_grating_fiber(\n\t        # grating parameters\n\t        period=0.66,\n\t        fill_factor=0.5,\n\t        n_periods=30,\n\t        # fiber parameters,\n", "        fiber_angle_deg=20.0,\n\t        fiber_xposition=0.0,\n\t        fiber_core_diameter=9,\n\t        fiber_numerical_aperture=fiber_na,\n\t        fiber_clad_material=nSiO2,\n\t        # material parameters\n\t        nwg=3.47,\n\t        clad_material=1.44,\n\t        nbox=1.44,\n\t        nsubstrate=3.47,\n", "        # stack parameters\n\t        pml_thickness=1.0,\n\t        substrate_thickness=1.0,\n\t        box_thickness=2.0,\n\t        core_thickness=220 * nm,\n\t        top_clad_thickness=2.0,\n\t        air_gap_thickness=1.0,\n\t        fiber_thickness=2.0,\n\t        # simulation parameters\n\t        resolution=50,\n", "    )\n\t    plot(sim_dict[\"sim\"], eps_parameters=eps_parameters)\n\t    # plot(sim_dict[\"sim\"])\n\t    plt.show()\n"]}
{"filename": "kplugins/kmeep/get_port_eigenmode.py", "chunked_list": ["from __future__ import annotations\n\timport matplotlib.pyplot as plt\n\timport meep as mp\n\timport numpy as np\n\tfrom kgeneric.cells import waveguide\n\tfrom kplugins.gmeep import get_simulation\n\tfrom kplugins.modes.types import Mode\n\t'''\n\tdef get_domain_measurements(sim, output_plane, frequency, resolution=0):\n\t    \"\"\"\n", "    Modified from meep/python/visualization.py plot_eps\n\t    CURRENTLY UNUSED -- will be useful once the MEEP conda packages are updates to latest source\n\t    Could also modify the epsilon plotting of mode to be override by plot_xsection, which already works\n\t    \"\"\"\n\t    # Get domain measurements\n\t    sim_center, sim_size = get_2D_dimensions(sim, output_plane)\n\t    xmin = sim_center.x - sim_size.x / 2\n\t    xmax = sim_center.x + sim_size.x / 2\n\t    ymin = sim_center.y - sim_size.y / 2\n\t    ymax = sim_center.y + sim_size.y / 2\n", "    zmin = sim_center.z - sim_size.z / 2\n\t    zmax = sim_center.z + sim_size.z / 2\n\t    grid_resolution = resolution if resolution else sim.resolution\n\t    Nx = int((xmax - xmin) * grid_resolution + 1)\n\t    Ny = int((ymax - ymin) * grid_resolution + 1)\n\t    Nz = int((zmax - zmin) * grid_resolution + 1)\n\t    if sim_size.x == 0:\n\t        # Plot y on x axis, z on y axis (YZ plane)\n\t        xtics = np.array([sim_center.x])\n\t        ytics = np.linspace(ymin, ymax, Ny)\n", "        ztics = np.linspace(zmin, zmax, Nz)\n\t    elif sim_size.y == 0:\n\t        # Plot x on x axis, z on y axis (XZ plane)\n\t        xtics = np.linspace(xmin, xmax, Nx)\n\t        ytics = np.array([sim_center.y])\n\t        ztics = np.linspace(zmin, zmax, Nz)\n\t    elif sim_size.z == 0:\n\t        # Plot x on x axis, y on y axis (XY plane)\n\t        xtics = np.linspace(xmin, xmax, Nx)\n\t        ytics = np.linspace(ymin, ymax, Ny)\n", "        ztics = np.array([sim_center.z])\n\t    else:\n\t        raise ValueError(\"A 2D plane has not been specified...\")\n\t    eps_data = np.rot90(np.real(sim.get_epsilon_grid(xtics, ytics, ztics, frequency)))\n\t    return eps_data\n\t'''\n\tdef get_port_2Dx_eigenmode(\n\t    sim_dict,\n\t    source_index=0,\n\t    port_name=\"o1\",\n", "    band_num=1,\n\t    choose_yz=False,\n\t    y=0,\n\t    z=0,\n\t):\n\t    \"\"\"NOTE: currently only handles ports normal to x-direction.\n\t    Args:\n\t        sim_dict: simulation dict\n\t        source_index: source index (to pull from sim_dict)\n\t        port_name: port name corresponding to mode_monitor to inspect\n", "        band_num: band number to solve for\n\t        choose_yz: whether y-z samples are generated or provided\n\t        y: y array (if choose_yz is True)\n\t        z: z array (if choose_yz is True)\n\t    Returns:\n\t        Mode object compatible with /modes plugin\n\t    \"\"\"\n\t    # Initialize\n\t    sim = sim_dict[\"sim\"]\n\t    source = sim_dict[\"sources\"][source_index]\n", "    mode_monitor = sim_dict[\"monitors\"][port_name]\n\t    # Obtain source frequency\n\t    fsrc = source.src.frequency\n\t    # Obtain xsection\n\t    center = mode_monitor.regions[0].center\n\t    size = mode_monitor.regions[0].size\n\t    \"\"\"\n\t    CURRENTLY UNUSED -- will be useful once the MEEP conda packages are updates to latest source\n\t    # output_plane = mp.Volume(center=center, size=size)\n\t    # Get best guess for kvector\n", "    # eps_data = get_domain_measurements(\n\t    #     sim, output_plane, fsrc, resolution=1 / (y[1] - y[0]) if y else 0\n\t    # )\n\t    # n = np.sqrt(np.max(eps_data))\n\t    \"\"\"\n\t    # Solve for the modes\n\t    if sim_dict[\"initialized\"] is False:\n\t        sim.init_sim()\n\t        sim_dict[\"initialized\"] = True\n\t    eigenmode = sim.get_eigenmode(\n", "        direction=mp.X,\n\t        where=mp.Volume(center=center, size=size),\n\t        band_num=band_num,\n\t        kpoint=mp.Vector3(\n\t            fsrc * 3.45, 0, 0\n\t        ),  # Hardcoded index for now, pull from simulation eventually\n\t        frequency=fsrc,\n\t    )\n\t    # The output of this function is slightly different then MPB (there is no mode_solver object)\n\t    # Format like the Mode objects in kfactory/simulation/modes to reuse modes' functions\n", "    if not choose_yz:\n\t        ny = int(size.y * sim.resolution)\n\t        nz = int(size.z * sim.resolution)\n\t        y = np.linspace(\n\t            center.y - size.y / 2, center.y + size.y / 2, ny\n\t        )  # eigenmode solver and sim res are technically different\n\t        z = np.linspace(center.z - size.z / 2, center.z + size.z / 2, nz)\n\t    yy, zz = np.meshgrid(y, z, indexing=\"ij\")\n\t    E = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n\t    H = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n", "    for i in range(ny):\n\t        for j in range(nz):\n\t            E[i, j, 0, 0] = eigenmode.amplitude(\n\t                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ex\n\t            )\n\t            E[i, j, 0, 1] = eigenmode.amplitude(\n\t                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ey\n\t            )\n\t            E[i, j, 0, 2] = eigenmode.amplitude(\n\t                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ez\n", "            )\n\t            H[i, j, 0, 0] = eigenmode.amplitude(\n\t                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hx\n\t            )\n\t            H[i, j, 0, 1] = eigenmode.amplitude(\n\t                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hy\n\t            )\n\t            H[i, j, 0, 2] = eigenmode.amplitude(\n\t                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hz\n\t            )\n", "    return Mode(\n\t        mode_number=band_num,\n\t        neff=eigenmode.k.x / fsrc,\n\t        wavelength=1 / fsrc,\n\t        ng=None,  # Not currently supported\n\t        E=E,\n\t        H=H,\n\t        eps=None,  # Eventually return the index distribution for co-plotting\n\t        y=y,\n\t        z=z,\n", "    )\n\tif __name__ == \"__main__\":\n\t    c = waveguide(length=2, width=0.5, layer=0)\n\t    c.add_padding(default=0, bottom=3, top=3, layers=[(100, 0)])\n\t    sim_dict = get_simulation(\n\t        c,\n\t        is_3d=True,\n\t        res=50,\n\t        port_source_offset=-0.1,\n\t        port_field_monitor_offset=-0.1,\n", "        port_margin=2.5,\n\t    )\n\t    m1_MEEP = get_port_2Dx_eigenmode(\n\t        sim_dict=sim_dict,\n\t        source_index=0,\n\t        port_name=\"o1\",\n\t    )\n\t    print(m1_MEEP.neff)\n\t    m1_MEEP.plot_hy()\n\t    m1_MEEP.plot_hx()\n", "    m1_MEEP.plot_hz()\n\t    plt.show()\n"]}
{"filename": "kplugins/kmeep/write_sparameters_meep_batch.py", "chunked_list": ["\"\"\"Compute and write Sparameters using Meep in an MPI pool.\"\"\"\n\tfrom __future__ import annotations\n\tfrom functools import partial\n\timport multiprocessing\n\timport pathlib\n\timport shutil\n\timport time\n\tfrom pathlib import Path\n\tfrom pprint import pprint\n\tfrom typing import Dict, List, Optional\n", "import numpy as np\n\timport pydantic\n\tfrom tqdm.auto import tqdm\n\timport kfactory as gf\n\tfrom kfactory import KCell\n\tfrom kfactory.conf import logger\n\tfrom kgeneric import pdk\n\timport kgeneric as kg\n\tfrom kplugins import port_symmetries\n\tfrom kplugins.get_sparameters_path import (\n", "    get_sparameters_path_meep as get_sparameters_path,\n\t)\n\tfrom kplugins.gmeep.write_sparameters_meep import remove_simulation_kwargs\n\tfrom kplugins.gmeep.write_sparameters_meep_mpi import (\n\t    write_sparameters_meep_mpi,\n\t)\n\tfrom kfactory.technology import LayerStack\n\tcore_materials = multiprocessing.cpu_count()\n\ttemp_dir_default = Path(\"./sparameters\") / \"temp\"\n\t@pydantic.validate_arguments\n", "def write_sparameters_meep_batch(\n\t    jobs: List[Dict],\n\t    cores_per_run: int = 2,\n\t    total_cores: int = 4,\n\t    temp_dir: Path = temp_dir_default,\n\t    delete_temp_files: bool = True,\n\t    dirpath: Optional[Path] = None,\n\t    layer_stack: Optional[LayerStack] = None,\n\t    **kwargs,\n\t) -> List[Path]:\n", "    \"\"\"Write Sparameters for a batch of jobs using MPI and returns results filepaths.\n\t    Given a list of write_sparameters_meep keyword arguments `jobs` launches them in\n\t    different cores using MPI where each simulation runs with `cores_per_run` cores.\n\t    If there are more simulations than cores each batch runs sequentially.\n\t    Args\n\t        jobs: list of Dicts containing the simulation settings for each job.\n\t            for write_sparameters_meep.\n\t        cores_per_run: number of processors to assign to each component simulation.\n\t        total_cores: total number of cores to use.\n\t        temp_dir: temporary directory to hold simulation files.\n", "        delete_temp_files: deletes temp_dir when done.\n\t        dirpath: directory to store Sparameters.\n\t        layer_stack: contains layer to thickness, zmin and material.\n\t            Defaults to active pdk.layer_stack.\n\t    keyword Args:\n\t        resolution: in pixels/um (30: for coarse, 100: for fine).\n\t        port_symmetries: Dict to specify port symmetries, to save number of simulations.\n\t        dirpath: directory to store Sparameters.\n\t        port_margin: margin on each side of the port.\n\t        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n", "        port_source_offset: offset between source GDS port and source MEEP port.\n\t        filepath: to store pandas Dataframe with Sparameters in CSV format..\n\t        animate: saves a MP4 images of the simulation for inspection, and also\n\t            outputs during computation. The name of the file is the source index.\n\t        lazy_parallelism: toggles the flag \"meep.divide_parallel_processes\" to\n\t            perform the simulations with different sources in parallel.\n\t        dispersive: use dispersive models for materials (requires higher resolution).\n\t        xmargin: left and right distance from component to PML.\n\t        xmargin_left: west distance from component to PML.\n\t        xmargin_right: east distance from component to PML.\n", "        ymargin: top and bottom distance from component to PML.\n\t        ymargin_top: north distance from component to PML.\n\t        ymargin_bot: south distance from component to PML.\n\t        extend_ports_length: to extend ports beyond the PML\n\t        layer_stack: Dict of layer number (int, int) to thickness (um).\n\t        zmargin_top: thickness for cladding above core.\n\t        zmargin_bot: thickness for cladding below core.\n\t        tpml: PML thickness (um).\n\t        clad_material: material for cladding.\n\t        is_3d: if True runs in 3D.\n", "        wavelength_start: wavelength min (um).\n\t        wavelength_stop: wavelength max (um).\n\t        wavelength_points: wavelength steps.\n\t        dfcen: delta frequency.\n\t        port_source_name: input port name.\n\t        port_margin: margin on each side of the port.\n\t        distance_source_to_monitors: in (um) source goes before.\n\t        port_source_offset: offset between source GDS port and source MEEP port.\n\t        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n\t    Returns:\n", "        filepath list for sparameters numpy saved files (wavelengths, o1@0,o2@0, ...).\n\t    \"\"\"\n\t    layer_stack = layer_stack or pdk.layer_stack\n\t    # Parse jobs\n\t    jobs_to_run = []\n\t    for job in jobs:\n\t        cell = job[\"cell\"]\n\t        cell = pdk.get_cell(cell)\n\t        assert isinstance(cell, KCell)\n\t        settings = remove_simulation_kwargs(kwargs)\n", "        filepath = job.get(\n\t            \"filepath\",\n\t            get_sparameters_path(\n\t                component=cell,\n\t                dirpath=dirpath,\n\t                layer_stack=layer_stack,\n\t                **settings,\n\t            ),\n\t        )\n\t        if filepath.exists():\n", "            job.update(**kwargs)\n\t            if job.get(\"overwrite\", kwargs.get(\"overwrite\", False)):\n\t                pathlib.Path.unlink(filepath)\n\t                logger.info(\n\t                    f\"Simulation {filepath!r} found and overwrite is True. \"\n\t                    \"Deleting file and adding it to the queue.\"\n\t                )\n\t                jobs_to_run.append(job)\n\t            else:\n\t                logger.info(\n", "                    f\"Simulation {filepath!r} found exists and \"\n\t                    \"overwrite is False. Removing it from the queue.\"\n\t                )\n\t        else:\n\t            logger.info(f\"Simulation {filepath!r} not found. Adding it to the queue\")\n\t            jobs_to_run.append(job)\n\t    jobs = jobs_to_run\n\t    batches = int(np.ceil(cores_per_run * len(jobs) / total_cores))\n\t    jobs_per_batch = int(np.floor(total_cores / cores_per_run))\n\t    njobs = len(jobs)\n", "    logger.info(f\"Running {njobs} simulations\")\n\t    logger.info(f\"total_cores = {total_cores} with cores_per_run = {cores_per_run}\")\n\t    logger.info(f\"Running {batches} batches with up to {jobs_per_batch} jobs each.\")\n\t    i = 0\n\t    # For each batch in the pool\n\t    for j in tqdm(range(batches)):\n\t        filepaths = []\n\t        # For each job in the batch\n\t        for k in range(jobs_per_batch):\n\t            if i >= njobs:\n", "                continue\n\t            logger.info(f\"Task {k} of batch {j} is job {i}\")\n\t            # Obtain current job\n\t            simulations_settings = jobs[i]\n\t            pprint(simulations_settings)\n\t            filepath = write_sparameters_meep_mpi(\n\t                cores=cores_per_run,\n\t                temp_dir=temp_dir,\n\t                temp_file_str=f\"write_sparameters_meep_mpi_{i}\",\n\t                wait_to_finish=False,\n", "                **simulations_settings,\n\t            )\n\t            filepaths.append(filepath)\n\t            # Increment task number\n\t            i += 1\n\t        # Wait for batch to end\n\t        done = False\n\t        num_pool_jobs = len(filepaths)\n\t        while not done:\n\t            # Check if all jobs finished\n", "            jobs_done = sum(1 for filepath in filepaths if filepath.exists())\n\t            if jobs_done == num_pool_jobs:\n\t                done = True\n\t            else:\n\t                time.sleep(1)\n\t    temp_dir = pathlib.Path(temp_dir)\n\t    if temp_dir.exists() and delete_temp_files:\n\t        shutil.rmtree(temp_dir)\n\t    return filepaths\n\twrite_sparameters_meep_batch_1x1 = partial(\n", "    write_sparameters_meep_batch, port_symmetries=port_symmetries.port_symmetries_1x1\n\t)\n\twrite_sparameters_meep_batch_1x1_bend90 = partial(\n\t    write_sparameters_meep_batch,\n\t    port_symmetries=port_symmetries.port_symmetries_1x1,\n\t    ymargin=0,\n\t    ymargin_bot=3,\n\t    xmargin_right=3,\n\t)\n\tif __name__ == \"__main__\":\n", "    jobs = [\n\t        {\n\t            \"component\": kg.cells.waveguide(width=0.5, length=i, layer=0),\n\t            \"run\": True,\n\t            \"overwrite\": True,\n\t            \"lazy_parallelism\": False,\n\t            \"ymargin\": 3,\n\t        }\n\t        for i in range(1, 4)\n\t    ]\n", "    filepaths = write_sparameters_meep_batch(\n\t        jobs=jobs,\n\t        cores_per_run=4,\n\t        total_cores=8,\n\t    )\n"]}
{"filename": "kplugins/kmeep/test_eigenmode.py", "chunked_list": ["\"\"\"Compares the modes of a kfactory + MEEP waveguide cross-section vs a\n\tdirect MPB calculation.\"\"\"\n\tfrom __future__ import annotations\n\timport h5py\n\timport matplotlib.pyplot as plt\n\timport numpy as np\n\tfrom scipy.interpolate import griddata\n\tfrom kgeneric.cells import waveguide\n\tfrom kgeneric.config import PATH\n\tfrom kplugins.gmeep import get_simulation\n", "from kplugins.gmeep.get_port_eigenmode import get_port_2Dx_eigenmode\n\tfrom kplugins.modes import find_modes_waveguide, get_mode_solver_rib\n\tfrom kplugins.modes.types import Mode\n\tdef lumerical_parser(E_1D, H_1D, y_1D, z_1D, res=50, z_offset=0.11 * 1e-6):\n\t    \"\"\"Converts 1D arrays of fields to 2D arrays according to positions.\n\t    Lumerical data is in 1D arrays, and over a nonregular mesh\n\t    Args\n\t        E_1D: E array from Lumerical.\n\t        H_1D: H array from Lumerical.\n\t        y_1D: y array from Lumerical.\n", "        z_1D: z array from Lumerical.\n\t        res: desired resolution.\n\t        z_offset: z offset to move the fields.\n\t    \"\"\"\n\t    # Make regular grid from resolution and range of domain\n\t    y_1D = y_1D[...].flatten()\n\t    z_1D = z_1D[...].flatten()\n\t    ny = int(np.max(y_1D) - np.min(y_1D) * 1e6 * res)\n\t    nz = int(np.max(z_1D) - np.min(z_1D) * 1e6 * res)\n\t    y = np.linspace(np.min(y_1D), np.max(y_1D), ny) * 1e6\n", "    z = np.linspace(np.min(z_1D), np.max(z_1D), nz) * 1e6\n\t    yy, zz = np.meshgrid(y, z)\n\t    # Generates points parameter ((y,z) array) for griddata\n\t    points = np.zeros([len(E_1D[...][0, :]), 2])\n\t    i = 0\n\t    for j in range(len(z_1D)):\n\t        for k in range(len(y_1D)):\n\t            points[i, 0] = y_1D[k] * 1e6\n\t            points[i, 1] = z_1D[j] * 1e6\n\t            i += 1\n", "    # Get interpolated field values\n\t    E = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n\t    H = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n\t    E[:, :, 0, 0] = griddata(\n\t        points,\n\t        E_1D[...][0, :][\"real\"] + 1j * E_1D[...][0, :][\"imag\"],\n\t        (zz, yy),\n\t        method=\"cubic\",\n\t    )\n\t    E[:, :, 0, 1] = griddata(\n", "        points,\n\t        E_1D[...][1, :][\"real\"] + 1j * E_1D[...][1, :][\"imag\"],\n\t        (zz, yy),\n\t        method=\"cubic\",\n\t    )\n\t    E[:, :, 0, 2] = griddata(\n\t        points,\n\t        E_1D[...][2, :][\"real\"] + 1j * E_1D[...][2, :][\"imag\"],\n\t        (zz, yy),\n\t        method=\"cubic\",\n", "    )\n\t    H[:, :, 0, 0] = griddata(\n\t        points,\n\t        H_1D[...][0, :][\"real\"] + 1j * H_1D[...][0, :][\"imag\"],\n\t        (zz, yy),\n\t        method=\"cubic\",\n\t    )\n\t    H[:, :, 0, 1] = griddata(\n\t        points,\n\t        H_1D[...][1, :][\"real\"] + 1j * H_1D[...][1, :][\"imag\"],\n", "        (zz, yy),\n\t        method=\"cubic\",\n\t    )\n\t    H[:, :, 0, 2] = griddata(\n\t        points,\n\t        H_1D[...][2, :][\"real\"] + 1j * H_1D[...][2, :][\"imag\"],\n\t        (zz, yy),\n\t        method=\"cubic\",\n\t    )\n\t    return E, H, y, z\n", "def MPB_eigenmode():\n\t    ms = get_mode_solver_rib(wg_width=0.45, sy=6, sz=6)\n\t    modes = find_modes_waveguide(mode_solver=ms, res=50)\n\t    m1_MPB = modes[1]\n\t    m2_MPB = modes[2]\n\t    return m1_MPB, m2_MPB\n\tdef MPB_eigenmode_toDisk() -> None:\n\t    m1_MPB, m2_MPB = MPB_eigenmode()\n\t    np.save(\"test_data/stripWG_mpb/neff1.npy\", m1_MPB.neff)\n\t    np.save(\"test_data/stripWG_mpb/E1.npy\", m1_MPB.E)\n", "    np.save(\"test_data/stripWG_mpb/H1.npy\", m1_MPB.H)\n\t    np.save(\"test_data/stripWG_mpb/y1.npy\", m1_MPB.y)\n\t    np.save(\"test_data/stripWG_mpb/z1.npy\", m1_MPB.z)\n\t    np.save(\"test_data/stripWG_mpb/neff2.npy\", m2_MPB.neff)\n\t    np.save(\"test_data/stripWG_mpb/E2.npy\", m2_MPB.E)\n\t    np.save(\"test_data/stripWG_mpb/H2.npy\", m2_MPB.H)\n\t    np.save(\"test_data/stripWG_mpb/y2.npy\", m2_MPB.y)\n\t    np.save(\"test_data/stripWG_mpb/z2.npy\", m2_MPB.z)\n\tdef compare_mpb_lumerical(plot=False) -> None:\n\t    \"\"\"\n", "    WARNING: Segmentation fault occurs if both ms object above and sim object exist in memory at the same time\n\t    Instead load results from separate MPB run\n\t    Same namespace run does not work\n\t    # MPB mode\n\t    # ms = get_mode_solver_rib(wg_width=0.5)\n\t    # modes = find_modes_waveguide(mode_solver=ms, res=50)\n\t    # m1_MPB = modes[1]\n\t    separate namespace run does not work either\n\t    # m1_MPB = MPB_eigenmode()\n\t    \"\"\"\n", "    # Test data\n\t    filepath = PATH.module_path / \"simulation\" / \"gmeep\" / \"test_data\"\n\t    # MPB calculation\n\t    # Load previously-computed waveguide results\n\t    m1_MPB_neff = np.load(filepath / \"stripWG_mpb\" / \"neff1.npy\")\n\t    m1_MPB_E = np.load(filepath / \"stripWG_mpb\" / \"E1.npy\")\n\t    m1_MPB_H = np.load(filepath / \"stripWG_mpb\" / \"H1.npy\")\n\t    m1_MPB_y = np.load(filepath / \"stripWG_mpb\" / \"y1.npy\")\n\t    m1_MPB_z = np.load(filepath / \"stripWG_mpb\" / \"z1.npy\")\n\t    m2_MPB_neff = np.load(filepath / \"stripWG_mpb\" / \"neff2.npy\")\n", "    m2_MPB_E = np.load(filepath / \"stripWG_mpb\" / \"E2.npy\")\n\t    m2_MPB_H = np.load(filepath / \"stripWG_mpb\" / \"H2.npy\")\n\t    m2_MPB_y = np.load(filepath / \"stripWG_mpb\" / \"y2.npy\")\n\t    m2_MPB_z = np.load(filepath / \"stripWG_mpb\" / \"z2.npy\")\n\t    # Package into modes object\n\t    m1_MPB = Mode(\n\t        mode_number=1,\n\t        neff=m1_MPB_neff,\n\t        wavelength=None,\n\t        ng=None,\n", "        E=m1_MPB_E,\n\t        H=m1_MPB_H,\n\t        eps=None,\n\t        y=m1_MPB_y,\n\t        z=m1_MPB_z,\n\t    )\n\t    m2_MPB = Mode(\n\t        mode_number=1,\n\t        neff=m2_MPB_neff,\n\t        wavelength=None,\n", "        ng=None,\n\t        E=m2_MPB_E,\n\t        H=m2_MPB_H,\n\t        eps=None,\n\t        y=m2_MPB_y,\n\t        z=m2_MPB_z,\n\t    )\n\t    # Load Lumerical result\n\t    with h5py.File(filepath / \"stripWG_lumerical\" / \"mode1.mat\", \"r\") as f:\n\t        E, H, y, z = lumerical_parser(\n", "            f[\"E\"][\"E\"], f[\"H\"][\"H\"], f[\"E\"][\"y\"], f[\"E\"][\"z\"], res=50\n\t        )\n\t        # Package into modes object\n\t        m1_lumerical = Mode(\n\t            mode_number=1,\n\t            neff=f[\"neff\"][0][0][0],\n\t            wavelength=None,\n\t            ng=None,\n\t            E=E,\n\t            H=H,\n", "            eps=None,\n\t            y=y,\n\t            z=z,\n\t        )\n\t    with h5py.File(filepath / \"stripWG_lumerical\" / \"mode2.mat\", \"r\") as f:\n\t        E, H, y, z = lumerical_parser(\n\t            f[\"E\"][\"E\"], f[\"H\"][\"H\"], f[\"E\"][\"y\"], f[\"E\"][\"z\"], res=50\n\t        )\n\t        # Package into modes object\n\t        m2_lumerical = Mode(\n", "            mode_number=1,\n\t            neff=f[\"neff\"][0][0][0],\n\t            wavelength=None,\n\t            ng=None,\n\t            E=E,\n\t            H=H,\n\t            eps=None,\n\t            y=y,\n\t            z=z,\n\t        )\n", "    # MEEP calculation\n\t    c = waveguide(length=2, width=0.45, layer=0)\n\t    c = c\n\t    # c = c.add_padding(default=0, bottom=4, top=4, layers=[(100, 0)])\n\t    sim_dict = get_simulation(\n\t        c,\n\t        is_3d=True,\n\t        port_source_offset=-0.1,\n\t        port_monitor_offset=-0.1,\n\t        port_margin=3,\n", "        resolution=50,\n\t    )\n\t    m1_MEEP = get_port_2Dx_eigenmode(\n\t        sim_dict=sim_dict,\n\t        source_index=0,\n\t        port_name=\"o1\",\n\t    )\n\t    m2_MEEP = get_port_2Dx_eigenmode(\n\t        sim_dict=sim_dict,\n\t        source_index=0,\n", "        port_name=\"o1\",\n\t        band_num=2,\n\t    )\n\t    if plot:\n\t        # M1, E-field\n\t        plt.figure(figsize=(10, 8), dpi=100)\n\t        plt.suptitle(\n\t            \"MEEP get_eigenmode / MPB find_modes_waveguide / Lumerical (manual)\",\n\t            y=1.05,\n\t            fontsize=18,\n", "        )\n\t        plt.subplot(3, 3, 1)\n\t        m1_MEEP.plot_ex(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 2)\n\t        m1_MPB.plot_ex(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 3)\n\t        m1_lumerical.plot_ex(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 4)\n\t        m1_MEEP.plot_ey(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 5)\n", "        m1_MPB.plot_ey(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 6)\n\t        m1_lumerical.plot_ey(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 7)\n\t        m1_MEEP.plot_ez(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 8)\n\t        m1_MPB.plot_ez(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 9)\n\t        m1_lumerical.plot_ez(show=False, operation=np.abs, scale=False)\n\t        plt.tight_layout()\n", "        plt.show()\n\t        # M1, H-field\n\t        plt.figure(figsize=(10, 8), dpi=100)\n\t        plt.suptitle(\n\t            \"MEEP get_eigenmode / MPB find_modes_waveguide / Lumerical (manual)\",\n\t            y=1.05,\n\t            fontsize=18,\n\t        )\n\t        plt.subplot(3, 3, 1)\n\t        m1_MEEP.plot_hx(show=False, operation=np.abs, scale=False)\n", "        plt.subplot(3, 3, 2)\n\t        m1_MPB.plot_hx(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 3)\n\t        m1_lumerical.plot_hx(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 4)\n\t        m1_MEEP.plot_hy(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 5)\n\t        m1_MPB.plot_hy(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 6)\n\t        m1_lumerical.plot_hy(show=False, operation=np.abs, scale=False)\n", "        plt.subplot(3, 3, 7)\n\t        m1_MEEP.plot_hz(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 8)\n\t        m1_MPB.plot_hz(show=False, operation=np.abs, scale=False)\n\t        plt.subplot(3, 3, 9)\n\t        m1_lumerical.plot_hz(show=False, operation=np.abs, scale=False)\n\t        plt.tight_layout()\n\t        plt.show()\n\t        # # M2, E-field\n\t        # plt.figure(figsize=(10, 8), dpi=100)\n", "        # plt.subplot(3, 3, 1)\n\t        # m2_MEEP.plot_ex(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 2)\n\t        # m2_MPB.plot_ex(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 3)\n\t        # m2_lumerical.plot_ex(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 4)\n\t        # m2_MEEP.plot_ey(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 5)\n\t        # m2_MPB.plot_ey(show=False, operation=np.abs, scale=False)\n", "        # plt.subplot(3, 3, 6)\n\t        # m2_lumerical.plot_ey(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 7)\n\t        # m2_MEEP.plot_ez(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 8)\n\t        # m2_MPB.plot_ez(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 9)\n\t        # m2_lumerical.plot_ez(show=False, operation=np.abs, scale=False)\n\t        # plt.tight_layout()\n\t        # plt.show()\n", "        # # M2, H-field\n\t        # plt.figure(figsize=(10, 8), dpi=100)\n\t        # plt.subplot(3, 3, 1)\n\t        # m2_MEEP.plot_hx(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 2)\n\t        # m2_MPB.plot_hx(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 3)\n\t        # m2_lumerical.plot_hx(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 4)\n\t        # m2_MEEP.plot_hy(show=False, operation=np.abs, scale=False)\n", "        # plt.subplot(3, 3, 5)\n\t        # m2_MPB.plot_hy(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 6)\n\t        # m2_lumerical.plot_hy(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 7)\n\t        # m2_MEEP.plot_hz(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 8)\n\t        # m2_MPB.plot_hz(show=False, operation=np.abs, scale=False)\n\t        # plt.subplot(3, 3, 9)\n\t        # m2_lumerical.plot_hz(show=False, operation=np.abs, scale=False)\n", "        # plt.tight_layout()\n\t        # plt.show()\n\t    # Check propagation constants\n\t    # print(m1_MEEP.neff, m1_MPB.neff, m1_lumerical.neff)\n\t    # print(m2_MEEP.neff, m2_MPB.neff, m2_lumerical.neff)\n\t    # Check mode profiles\n\t    assert np.isclose(m1_MPB.neff, m1_lumerical.neff, atol=0.02)\n\t    assert np.isclose(m1_MEEP.neff, m1_MPB.neff, atol=0.02)\n\t    assert np.isclose(m2_MPB.neff, m2_lumerical.neff, atol=0.07)\n\t    assert np.isclose(m2_MEEP.neff, m2_MPB.neff, atol=0.07)\n", "    # TODO modes check\n\tif __name__ == \"__main__\":\n\t    # MPB_eigenmode_toDisk()\n\t    compare_mpb_lumerical(plot=False)\n"]}
{"filename": "kplugins/kmeep/write_sparameters_meep.py", "chunked_list": ["\"\"\"Compute and write Sparameters using Meep.\"\"\"\n\tfrom __future__ import annotations\n\tfrom functools import partial\n\timport inspect\n\timport multiprocessing\n\timport pathlib\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Any, Dict, List, Optional\n\timport meep as mp\n", "import numpy as np\n\timport pydantic\n\tfrom omegaconf import OmegaConf\n\tfrom tqdm.auto import tqdm\n\timport kfactory as gf\n\tfrom kfactory import Port\n\tfrom kfactory.kcell import KCell, clean_value\n\tfrom kfactory.conf import logger\n\timport kgeneric as kg\n\tfrom kgeneric import pdk\n", "from kplugins import port_symmetries\n\tfrom kplugins.get_sparameters_path import (\n\t    get_sparameters_path_meep as get_sparameters_path,\n\t)\n\tfrom kplugins.gmeep.get_simulation import (\n\t    get_simulation,\n\t    settings_get_simulation,\n\t)\n\tfrom kfactory.technology import LayerStack\n\tfrom kfactory.typings import CellSpec, PathType\n", "core_materials = multiprocessing.cpu_count()\n\tdef remove_simulation_kwargs(d: Dict[str, Any]) -> Dict[str, Any]:\n\t    \"\"\"Returns a copy of dict with only simulation settings.\n\t    removes all flags for the simulator itself\n\t    \"\"\"\n\t    d = d.copy()\n\t    d.pop(\"run\", None)\n\t    d.pop(\"lazy_parallelism\", None)\n\t    d.pop(\"overwrite\", None)\n\t    d.pop(\"animate\", None)\n", "    d.pop(\"wait_to_finish\", None)\n\t    d.pop(\"cores\", None)\n\t    d.pop(\"temp_dir\", None)\n\t    d.pop(\"temp_file_str\", None)\n\t    return d\n\tdef parse_port_eigenmode_coeff(port_name: str, ports: Dict[str, Port], sim_dict: Dict):\n\t    \"\"\"Returns the coefficients relative to whether the wavevector is entering or \\\n\t            exiting simulation.\n\t    Args:\n\t        port_index: index of port.\n", "        ports: component_ref.ports.\n\t        sim_dict: simulation dict.\n\t    \"\"\"\n\t    if port_name not in ports:\n\t        raise ValueError(f\"port = {port_name!r} not in {list(ports.keys())}.\")\n\t    orientation = ports[port_name].orientation\n\t    # Inputs\n\t    sim = sim_dict[\"sim\"]\n\t    monitors = sim_dict[\"monitors\"]\n\t    # get_eigenmode_coeff.alpha[:,:,idx]\n", "    # with ind being the forward or backward wave according to cell coordinates.\n\t    # Figure out if that is exiting the simulation or not\n\t    # depending on the port orientation (assuming it's near PMLs)\n\t    if orientation == 0:  # east\n\t        kpoint = mp.Vector3(x=1)\n\t        idx_in = 1\n\t        idx_out = 0\n\t    elif orientation == 90:  # north\n\t        kpoint = mp.Vector3(y=1)\n\t        idx_in = 1\n", "        idx_out = 0\n\t    elif orientation == 180:  # west\n\t        kpoint = mp.Vector3(x=1)\n\t        idx_in = 0\n\t        idx_out = 1\n\t    elif orientation == 270:  # south\n\t        kpoint = mp.Vector3(y=1)\n\t        idx_in = 0\n\t        idx_out = 1\n\t    else:\n", "        raise ValueError(\n\t            f\"Port orientation {orientation!r} not in 0, 90, 180, or 270 degrees!\"\n\t        )\n\t    # Get port coeffs\n\t    monitor_coeff = sim.get_eigenmode_coefficients(\n\t        monitors[port_name], [1], kpoint_func=lambda f, n: kpoint\n\t    )\n\t    coeff_in = monitor_coeff.alpha[\n\t        0, :, idx_in\n\t    ]  # ingoing (w.r.t. simulation cell) wave\n", "    coeff_out = monitor_coeff.alpha[\n\t        0, :, idx_out\n\t    ]  # outgoing (w.r.t. simulation cell) wave\n\t    return coeff_in, coeff_out\n\t@pydantic.validate_arguments\n\tdef write_sparameters_meep(\n\t    component: CellSpec,\n\t    port_source_names: Optional[List[str]] = None,\n\t    port_symmetries: Optional[Dict] = None,\n\t    resolution: int = 30,\n", "    wavelength_start: float = 1.5,\n\t    wavelength_stop: float = 1.6,\n\t    wavelength_points: int = 50,\n\t    dirpath: Optional[PathType] = None,\n\t    layer_stack: Optional[LayerStack] = None,\n\t    port_margin: float = 2,\n\t    port_monitor_offset: float = -0.1,\n\t    port_source_offset: float = -0.1,\n\t    filepath: Optional[Path] = None,\n\t    overwrite: bool = False,\n", "    animate: bool = False,\n\t    lazy_parallelism: bool = False,\n\t    run: bool = True,\n\t    dispersive: bool = False,\n\t    xmargin: float = 0,\n\t    ymargin: float = 3,\n\t    xmargin_left: float = 0,\n\t    xmargin_right: float = 0,\n\t    ymargin_top: float = 0,\n\t    ymargin_bot: float = 0,\n", "    decay_by: float = 1e-3,\n\t    is_3d: bool = False,\n\t    z: float = 0,\n\t    plot_args: Optional[Dict] = None,\n\t    only_return_filepath_sim_settings=False,\n\t    **settings,\n\t) -> Dict:\n\t    r\"\"\"Returns Sparameters and writes them to npz filepath.\n\t    Simulates each time using a different input port (by default, all of them)\n\t    unless you specify port_symmetries:\n", "    port_symmetries_crossing = {\n\t        \"o1@0,o1@0\": [\"o2@0,o2@0\", \"o3@0,o3@0\", \"o4@0,o4@0\"],\n\t        \"o2@0,o1@0\": [\"o1@0,o2@0\", \"o3@0,o4@0\", \"o4@0,o3@0\"],\n\t        \"o3@0,o1@0\": [\"o1@0,o3@0\", \"o2@0,o4@0\", \"o4@0,o2@0\"],\n\t        \"o4@0,o1@0\": [\"o1@0,o4@0\", \"o2@0,o3@0\", \"o3@0,o2@0\"],\n\t    }\n\t    - Only simulations using the outer key port names will be run\n\t    - The associated value is another dict whose keys are the S-parameters computed\n\t        when this source is active\n\t    - The values of this inner Dict are lists of s-parameters whose values are copied\n", "    .. code::\n\t         top view\n\t              ________________________________\n\t             |                               |\n\t             | xmargin_left                  | port_extension\n\t             |<--------->       port_margin ||<-->\n\t          o2_|___________          _________||_o3\n\t             |           \\        /          |\n\t             |            \\      /           |\n\t             |             ======            |\n", "             |            /      \\           |\n\t          o1_|___________/        \\__________|_o4\n\t             |   |                 <-------->|\n\t             |   |ymargin_bot   xmargin_right|\n\t             |   |                           |\n\t             |___|___________________________|\n\t        side view\n\t              ________________________________\n\t             |                     |         |\n\t             |                     |         |\n", "             |                   zmargin_top |\n\t             |xmargin_left         |         |\n\t             |<---> _____         _|___      |\n\t             |     |     |       |     |     |\n\t             |     |     |       |     |     |\n\t             |     |_____|       |_____|     |\n\t             |       |                       |\n\t             |       |                       |\n\t             |       |zmargin_bot            |\n\t             |       |                       |\n", "             |_______|_______________________|\n\t    Args:\n\t        component: to simulate.\n\t        resolution: in pixels/um (30: for coarse, 100: for fine).\n\t        port_source_names: list of ports to excite. Defaults to all.\n\t        port_symmetries: Dict to specify port symmetries, to save number of simulations.\n\t        dirpath: directory to store Sparameters.\n\t        layer_stack: contains layer to thickness, zmin and material.\n\t            Defaults to active pdk.layer_stack.\n\t        port_margin: margin on each side of the port.\n", "        port_monitor_offset: offset between KCell and monitor port in um.\n\t        port_source_offset: offset between KCell and source port in um.\n\t        filepath: to store pandas Dataframe with Sparameters in npz format.\n\t            Defaults to dirpath/component_.npz.\n\t        overwrite: overwrites stored Sparameter npz results.\n\t        animate: saves a MP4 images of the simulation for inspection, and also\n\t            outputs during computation. The name of the file is the source index.\n\t        lazy_parallelism: toggles the flag \"meep.divide_parallel_processes\" to\n\t            perform the simulations with different sources in parallel.\n\t            By default MPI just runs the same copy of the Python script everywhere,\n", "            with the C++ under MEEP actually being parallelized.\n\t            divide_parallel_processes allows us to logically split this one calculation\n\t            into (in this case \"cores\") subdivisions.\n\t            The only difference in the scripts is that a different integer n\n\t            is returned depending on the subdivision it is running in.\n\t            So we use that n to select different sources, and each subdivision calculates\n\t            its own Sparams independently. Afterwards, we collect all\n\t            results in one of the subdivisions (if rank == 0).\n\t        run: runs simulation, if False, only plots simulation.\n\t        dispersive: use dispersive models for materials (requires higher resolution).\n", "        xmargin: left and right distance from component to PML.\n\t        xmargin_left: west distance from component to PML.\n\t        xmargin_right: east distance from component to PML.\n\t        ymargin: top and bottom distance from component to PML.\n\t        ymargin_top: north distance from component to PML.\n\t        ymargin_bot: south distance from component to PML.\n\t        is_3d: if True runs in 3D (much slower).\n\t        z: for 2D plot.\n\t        plot_args: if animate or not run, customization keyword arguments passed to\n\t          `plot2D()` (i.e. `labels`, `eps_parameters`, `boundary_parameters`, `field_parameters`, etc.)\n", "    keyword Args:\n\t        extend_ports_length: to extend ports beyond the PML (um).\n\t        zmargin_top: thickness for cladding above core (um).\n\t        zmargin_bot: thickness for cladding below core (um).\n\t        tpml: PML thickness (um).\n\t        clad_material: material for cladding.\n\t        wavelength_start: wavelength min (um).\n\t        wavelength_stop: wavelength max (um).\n\t        wavelength_points: wavelength steps.\n\t        dfcen: delta frequency.\n", "        port_source_name: input port name.\n\t        port_margin: margin on each side of the port (um).\n\t        distance_source_to_monitors: in (um).\n\t        port_source_offset: offset between source KCell port and source MEEP port.\n\t        port_monitor_offset: offset between KCell and MEEP port monitor.\n\t        material_name_to_meep: map layer_stack names with meep material database name\n\t            or refractive index. dispersive materials have a wavelength dependent index.\n\t    Returns:\n\t        sparameters in a Dict (wavelengths, s11a, o1@0,o2@0, ...)\n\t            where `a` is the angle in radians and `m` the module.\n", "    \"\"\"\n\t    component = (\n\t        component if isinstance(component, KCell) else pdk.get_cell(component)\n\t    )\n\t    layer_stack = layer_stack or pdk.layer_stack\n\t    plot_args = plot_args or {}\n\t    for setting in settings:\n\t        if setting not in settings_get_simulation:\n\t            raise ValueError(f\"{setting!r} not in {settings_get_simulation}\")\n\t    port_symmetries = port_symmetries or {}\n", "    xmargin_left = xmargin_left or xmargin\n\t    xmargin_right = xmargin_right or xmargin\n\t    ymargin_top = ymargin_top or ymargin\n\t    ymargin_bot = ymargin_bot or ymargin\n\t    sim_settings = dict(\n\t        resolution=resolution,\n\t        port_symmetries=port_symmetries,\n\t        wavelength_start=wavelength_start,\n\t        wavelength_stop=wavelength_stop,\n\t        wavelength_points=wavelength_points,\n", "        port_margin=port_margin,\n\t        port_monitor_offset=port_monitor_offset,\n\t        port_source_offset=port_source_offset,\n\t        dispersive=dispersive,\n\t        ymargin_top=ymargin_top,\n\t        ymargin_bot=ymargin_bot,\n\t        xmargin_left=xmargin_left,\n\t        xmargin_right=xmargin_right,\n\t        is_3d=is_3d,\n\t        **settings,\n", "    )\n\t    filepath = filepath or get_sparameters_path(\n\t        component=component,\n\t        dirpath=dirpath,\n\t        layer_stack=layer_stack,\n\t        **sim_settings,\n\t    )\n\t    sim_settings = sim_settings.copy()\n\t    sim_settings[\"layer_stack\"] = layer_stack.to_dict()\n\t    sim_settings[\"component\"] = component.to_dict()\n", "    filepath = pathlib.Path(filepath)\n\t    filepath_sim_settings = filepath.with_suffix(\".yml\")\n\t    # FIXME: Ideally, we should split sim settings generation from doing the\n\t    #        simulation... this is a hack.\n\t    if only_return_filepath_sim_settings:\n\t        return filepath_sim_settings\n\t    # filepath_sim_settings.write_text(OmegaConf.to_yaml(sim_settings))\n\t    # logger.info(f\"Write simulation settings to {filepath_sim_settings!r}\")\n\t    # return filepath_sim_settings\n\t    component = gf.add_padding_container(\n", "        component,\n\t        default=0,\n\t        top=ymargin_top,\n\t        bottom=ymargin_bot,\n\t        left=xmargin_left,\n\t        right=xmargin_right,\n\t    )\n\t    if not run:\n\t        sim_dict = get_simulation(\n\t            component=component,\n", "            wavelength_start=wavelength_start,\n\t            wavelength_stop=wavelength_stop,\n\t            wavelength_points=wavelength_points,\n\t            layer_stack=layer_stack,\n\t            port_margin=port_margin,\n\t            port_monitor_offset=port_monitor_offset,\n\t            port_source_offset=port_source_offset,\n\t            dispersive=dispersive,\n\t            is_3d=is_3d,\n\t            **settings,\n", "        )\n\t        sim = sim_dict[\"sim\"]\n\t        if is_3d:\n\t            sim.plot2D(\n\t                output_plane=mp.Volume(\n\t                    size=mp.Vector3(sim.cell_size.x, sim.cell_size.y, 0),\n\t                    center=mp.Vector3(0, 0, z),\n\t                ),\n\t                **plot_args,\n\t            )\n", "        else:\n\t            sim.plot2D(plot_eps_flag=True, **plot_args)\n\t        return sim\n\t    if filepath.exists():\n\t        if not overwrite:\n\t            logger.info(f\"Simulation loaded from {filepath!r}\")\n\t            return dict(np.load(filepath))\n\t        elif overwrite:\n\t            filepath.unlink()\n\t    component_ref = component.ref()\n", "    ports = component_ref.ports\n\t    port_names = [port.name for port in list(ports.values())]\n\t    port_source_names = port_source_names or port_names\n\t    num_sims = len(port_source_names) - len(port_symmetries)\n\t    sp = {}  # Sparameters dict\n\t    start = time.time()\n\t    @pydantic.validate_arguments\n\t    def sparameter_calculation(\n\t        port_source_name: str,\n\t        component: KCell,\n", "        port_symmetries: Optional[Dict] = port_symmetries,\n\t        port_names: List[str] = port_names,\n\t        wavelength_start: float = wavelength_start,\n\t        wavelength_stop: float = wavelength_stop,\n\t        wavelength_points: int = wavelength_points,\n\t        animate: bool = animate,\n\t        plot_args: Dict = plot_args,\n\t        dispersive: bool = dispersive,\n\t        decay_by: float = decay_by,\n\t        **settings,\n", "    ) -> Dict:\n\t        \"\"\"Return Sparameter dict.\"\"\"\n\t        sim_dict = get_simulation(\n\t            component=component,\n\t            port_source_name=port_source_name,\n\t            resolution=resolution,\n\t            wavelength_start=wavelength_start,\n\t            wavelength_stop=wavelength_stop,\n\t            wavelength_points=wavelength_points,\n\t            port_margin=port_margin,\n", "            port_monitor_offset=port_monitor_offset,\n\t            port_source_offset=port_source_offset,\n\t            dispersive=dispersive,\n\t            layer_stack=layer_stack,\n\t            is_3d=is_3d,\n\t            **settings,\n\t        )\n\t        sim = sim_dict[\"sim\"]\n\t        # freqs = sim_dict[\"freqs\"]\n\t        # wavelengths = 1 / freqs\n", "        # print(sim.resolution)\n\t        # Terminate when the area in the whole area decayed\n\t        termination = [mp.stop_when_energy_decayed(dt=50, decay_by=decay_by)]\n\t        if animate:\n\t            # Defaults for animation\n\t            if \"field_parameters\" not in plot_args:\n\t                plot_args[\"field_parameters\"] = {\n\t                    \"alpha\": 0.8,\n\t                    \"cmap\": \"RdBu\",\n\t                    \"interpolation\": \"none\",\n", "                }\n\t            if \"eps_parameters\" not in plot_args:\n\t                plot_args[\"eps_parameters\"] = {\"contour\": True}\n\t            if \"fields\" not in plot_args:\n\t                plot_args[\"fields\"] = mp.Ez\n\t            if \"realtime\" not in plot_args:\n\t                plot_args[\"realtime\"] = True\n\t            if \"normalize\" not in plot_args:\n\t                plot_args[\"normalize\"] = True\n\t            sim.use_output_directory()\n", "            animate = mp.Animate2D(\n\t                sim,\n\t                **plot_args,\n\t            )\n\t            sim.run(mp.at_every(1, animate), until_after_sources=termination)\n\t            animate.to_mp4(30, f\"{component.name}_{port_source_name}.mp4\")\n\t        else:\n\t            sim.run(until_after_sources=termination)\n\t        # Calculate mode overlaps\n\t        # Get source monitor results\n", "        source_entering, _ = parse_port_eigenmode_coeff(\n\t            port_source_name, component.ports, sim_dict\n\t        )\n\t        # Get coefficients\n\t        for port_name in port_names:\n\t            _, monitor_exiting = parse_port_eigenmode_coeff(\n\t                port_name, component.ports, sim_dict\n\t            )\n\t            key = f\"{port_name}@0,{port_source_name}@0\"\n\t            sp[key] = monitor_exiting / source_entering\n", "        if bool(port_symmetries):\n\t            for key, symmetries in port_symmetries.items():\n\t                for sym in symmetries:\n\t                    if key in sp:\n\t                        sp[sym] = sp[key]\n\t        return sp\n\t    if lazy_parallelism:\n\t        from mpi4py import MPI\n\t        cores = min([num_sims, multiprocessing.cpu_count()])\n\t        n = mp.divide_parallel_processes(cores)\n", "        comm = MPI.COMM_WORLD\n\t        size = comm.Get_size()\n\t        rank = comm.Get_rank()\n\t        # Map port names to integers\n\t        port_source_dict = {}\n\t        for number, name in enumerate(port_source_names):\n\t            port_source_dict[number] = name\n\t        sp = sparameter_calculation(\n\t            port_source_name=port_source_dict[n],\n\t            component=component,\n", "            port_symmetries=port_symmetries,\n\t            wavelength_start=wavelength_start,\n\t            wavelength_stop=wavelength_stop,\n\t            wavelength_points=wavelength_points,\n\t            animate=animate,\n\t            port_names=port_names,\n\t            **settings,\n\t        )\n\t        # Synchronize dicts\n\t        if rank == 0:\n", "            for i in range(1, size):\n\t                data = comm.recv(source=i, tag=11)\n\t                sp.update(data)\n\t            sp[\"wavelengths\"] = np.linspace(\n\t                wavelength_start, wavelength_stop, wavelength_points\n\t            )\n\t            np.savez_compressed(filepath, **sp)\n\t            logger.info(f\"Write simulation results to {filepath!r}\")\n\t            filepath_sim_settings.write_text(\n\t                OmegaConf.to_yaml(clean_value(sim_settings))\n", "            )\n\t            logger.info(f\"Write simulation settings to {filepath_sim_settings!r}\")\n\t            return sp\n\t        else:\n\t            comm.send(sp, dest=0, tag=11)\n\t    else:\n\t        for port_source_name in tqdm(port_source_names):\n\t            sp.update(\n\t                sparameter_calculation(\n\t                    port_source_name,\n", "                    component=component,\n\t                    port_symmetries=port_symmetries,\n\t                    wavelength_start=wavelength_start,\n\t                    wavelength_stop=wavelength_stop,\n\t                    wavelength_points=wavelength_points,\n\t                    animate=animate,\n\t                    port_names=port_names,\n\t                    **settings,\n\t                )\n\t            )\n", "        sp[\"wavelengths\"] = np.linspace(\n\t            wavelength_start, wavelength_stop, wavelength_points\n\t        )\n\t        np.savez_compressed(filepath, **sp)\n\t        end = time.time()\n\t        sim_settings.update(compute_time_seconds=end - start)\n\t        sim_settings.update(compute_time_minutes=(end - start) / 60)\n\t        logger.info(f\"Write simulation results to {filepath!r}\")\n\t        filepath_sim_settings.write_text(OmegaConf.to_yaml(sim_settings))\n\t        logger.info(f\"Write simulation settings to {filepath_sim_settings!r}\")\n", "        return sp\n\twrite_sparameters_meep_1x1 = partial(\n\t    write_sparameters_meep, port_symmetries=port_symmetries.port_symmetries_1x1\n\t)\n\twrite_sparameters_meep_1x1_bend90 = partial(\n\t    write_sparameters_meep,\n\t    ymargin=0,\n\t    ymargin_bot=3,\n\t    xmargin_right=3,\n\t    port_symmetries=port_symmetries.port_symmetries_1x1,\n", ")\n\tsig = inspect.signature(write_sparameters_meep)\n\tsettings_write_sparameters_meep = set(sig.parameters.keys()).union(\n\t    settings_get_simulation\n\t)\n\tif __name__ == \"__main__\":\n\t    wavelength_start = 1.26\n\t    wavelength_stop = 1.36\n\t    sim_settings = dict(\n\t        wavelength_start=wavelength_start, wavelength_stop=wavelength_stop\n", "    )\n\t    # c = gf.components.mmi1x2(cross_section=gf.cross_section.strip)\n\t    c = kg.cells.waveguide(0.5, length=2, layer=0)\n\t    import matplotlib.pyplot as plt\n\t    def func(x):\n\t        result = np.where(np.abs(x) > 1e-10, np.abs(x) ** 2, -10)\n\t        return np.log10(result, out=result, where=result > 0)\n\t    sp = write_sparameters_meep(\n\t        c,\n\t        run=True,\n", "        animate=True,\n\t        is_3d=False,\n\t        plot_args={\n\t            \"eps_parameters\": {\"contour\": True},\n\t            \"field_parameters\": {\n\t                \"alpha\": 0.8,\n\t                \"cmap\": \"RdBu\",\n\t                \"interpolation\": \"none\",\n\t                \"post_process\": func,\n\t            },\n", "            \"realtime\": False,\n\t        },\n\t        overwrite=True,\n\t        **sim_settings,\n\t    )\n\t    plt.show()\n\t    # from kfactory.simulation.add_simulation_markers import add_simulation_markers\n\t    # import kfactory.simulation as sim\n\t    # c = gf.components.straight(length=2)\n\t    # c = gf.components.bend_euler(radius=3)\n", "    # c = add_simulation_markers(c)\n\t    # sp = write_sparameters_meep_1x1(c, run=True, is_3d=False)\n\t    # sim.plot.plot_sparameters(sp)\n\t    # import matplotlib.pyplot as plt\n\t    # plt.show()\n"]}
{"filename": "kplugins/kmeep/get_material.py", "chunked_list": ["from __future__ import annotations\n\tfrom functools import partial\n\tfrom typing import Dict, Optional, Union\n\timport meep as mp\n\timport meep.materials as mat\n\timport numpy as np\n\tfrom kplugins.materials import material_name_to_meep as material_name_to_meep_default\n\tMATERIALS = [m for m in dir(mat) if not m.startswith(\"_\")]\n\tdef get_material(\n\t    name: str = \"si\",\n", "    wavelength: float = 1.55,\n\t    dispersive: bool = False,\n\t    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n\t) -> mp.Medium:\n\t    \"\"\"Returns Meep Medium from database.\n\t    Args:\n\t        name: material name.\n\t        wavelength: wavelength (um).\n\t        dispersive: True for built-in Meep index model,\n\t            False for simple, non-dispersive model.\n", "        material_name_to_meep: dispersive materials have a wavelength\n\t            dependent index. Maps layer_stack names with meep material database names.\n\t    Note:\n\t        Using the built-in models can be problematic at low resolution.\n\t    \"\"\"\n\t    material_name_to_meep_new = material_name_to_meep or {}\n\t    material_name_to_meep = material_name_to_meep_default.copy()\n\t    material_name_to_meep.update(**material_name_to_meep_new)\n\t    materials = [material.lower() for material in MATERIALS]\n\t    name = name.lower()\n", "    if name not in material_name_to_meep and name not in materials:\n\t        raise KeyError(f\"material {name!r} not found in available materials\")\n\t    meep_name = material_name_to_meep[name]\n\t    if isinstance(meep_name, (int, float)):\n\t        # if material is only a number, we can return early regardless of dispersion\n\t        return mp.Medium(index=meep_name)\n\t    material = getattr(mat, meep_name)\n\t    if dispersive:\n\t        return material\n\t    # now what's left is the case of having a dispersive meep medium but a simulation\n", "    # without dispersion, so we extract the permittivity at the correct wavelength\n\t    try:\n\t        return mp.Medium(epsilon=material.epsilon(1 / wavelength)[0][0])\n\t    except ValueError as e:\n\t        print(f\"material = {name!r} not defined for wavelength={wavelength}\")\n\t        raise e\n\tdef get_index(\n\t    wavelength: float = 1.55,\n\t    name: str = \"Si\",\n\t    dispersive: bool = False,\n", ") -> float:\n\t    \"\"\"Returns refractive index from Meep's material database.\n\t    Args:\n\t        name: material name.\n\t        wavelength: wavelength (um).\n\t        dispersive: True for built-in Meep index model,\n\t            False for simple, non-dispersive model.\n\t    Note:\n\t        Using the built-in models can be problematic at low resolution.\n\t        If fields are NaN or Inf, increase resolution or use a non-dispersive model.\n", "    \"\"\"\n\t    medium = get_material(\n\t        name=name,\n\t        wavelength=wavelength,\n\t        dispersive=dispersive,\n\t    )\n\t    epsilon_matrix = medium.epsilon(1 / wavelength)\n\t    epsilon11 = epsilon_matrix[0][0]\n\t    return float(epsilon11.real**0.5)\n\tdef test_index() -> None:\n", "    n = get_index(name=\"sin\")\n\t    n_reference = 1.9962797317138816\n\t    assert np.isclose(n, n_reference), n\n\tsi = partial(get_index, name=\"Si\")\n\tsio2 = partial(get_index, name=\"SiO2\")\n\tif __name__ == \"__main__\":\n\t    test_index()\n\t    # n = get_index(name=\"Si\", wavelength=1.31)\n\t    # print(n, type(n))\n"]}
{"filename": "kplugins/kmeep/test_materials.py", "chunked_list": ["import kfactory as kf\n\tfrom kplugins.gmeep.write_sparameters_meep import write_sparameters_meep\n\tdef test_materials_override() -> None:\n\t    \"\"\"Checks that materials are properly overridden if index is provided.\"\"\"\n\t    c = kf.cells.waveguide(length=2, width=0.5, layer=0)\n\t    # Default (materials strings)\n\t    sp1 = write_sparameters_meep(\n\t        c,\n\t        run=False,\n\t        animate=False,\n", "        is_3d=False,\n\t        overwrite=True,\n\t    )\n\t    # Override\n\t    sp2 = write_sparameters_meep(\n\t        c,\n\t        run=False,\n\t        animate=False,\n\t        material_name_to_meep=dict(si=2.0),\n\t        is_3d=False,\n", "        overwrite=True,\n\t    )\n\t    assert sp1.geometry[0].material.epsilon(freq=1)[0][0] != 4.0\n\t    assert sp2.geometry[0].material.epsilon(freq=1)[0][0] == 4.0\n\tif __name__ == \"__main__\":\n\t    test_materials_override()\n"]}
{"filename": "kplugins/kmeep/write_sparameters_meep_mpi.py", "chunked_list": ["\"\"\"Compute and write Sparameters using Meep in MPI.\"\"\"\n\tfrom __future__ import annotations\n\tfrom functools import partial\n\timport multiprocessing\n\timport pathlib\n\timport shlex\n\timport subprocess\n\timport sys\n\timport time\n\tfrom pathlib import Path\n", "from typing import Optional\n\timport pydantic\n\timport kfactory as gf\n\tfrom kfactory import KCell\n\tfrom kfactory.conf import logger\n\tfrom kgeneric import pdk\n\tfrom kgeneric.config import PATH\n\timport kgeneric as kg\n\tfrom kplugins import port_symmetries\n\tfrom kplugins.get_sparameters_path import (\n", "    get_sparameters_path_meep as get_sparameters_path,\n\t)\n\tfrom kplugins.gmeep.write_sparameters_meep import (\n\t    remove_simulation_kwargs,\n\t    settings_write_sparameters_meep,\n\t)\n\tfrom kfactory.technology import LayerStack\n\tfrom kfactory.typings import CellSpec, PathType\n\timport pickle\n\tcore_materials = multiprocessing.cpu_count()\n", "temp_dir_default = Path(PATH.sparameters_path) / \"temp\"\n\tdef _python() -> str:\n\t    \"\"\"Select correct python executable from current activated environment.\"\"\"\n\t    return sys.executable\n\t@pydantic.validate_arguments\n\tdef write_sparameters_meep_mpi(\n\t    component: CellSpec,\n\t    layer_stack: Optional[LayerStack] = None,\n\t    cores: int = core_materials,\n\t    filepath: Optional[PathType] = None,\n", "    dirpath: Optional[PathType] = None,\n\t    temp_dir: Path = temp_dir_default,\n\t    temp_file_str: str = \"write_sparameters_meep_mpi\",\n\t    live_output: bool = False,\n\t    overwrite: bool = False,\n\t    wait_to_finish: bool = True,\n\t    **kwargs,\n\t) -> Path:\n\t    \"\"\"Write Sparameters using multiple cores and MPI and returns Sparameters filepath.\n\t    Simulates each time using a different input port (by default, all of them)\n", "    unless you specify port_symmetries:\n\t    checks stderror and kills MPI job if there is any stderror message\n\t    port_symmetries = {\"o1\":\n\t            {\n\t                \"s11\": [\"s22\",\"s33\",\"s44\"],\n\t                \"s21\": [\"s21\",\"s34\",\"s43\"],\n\t                \"s31\": [\"s13\",\"s24\",\"s42\"],\n\t                \"s41\": [\"s14\",\"s23\",\"s32\"],\n\t            }\n\t        }\n", "    Args:\n\t        component: kfactory Kcell.\n\t        cores: number of processors.\n\t        filepath: to store pandas Dataframe with Sparameters in CSV format.\n\t            Defaults to dirpath/component_.csv.\n\t        dirpath: directory to store sparameters in CSV.\n\t            Defaults to active Pdk.sparameters_path.\n\t        layer_stack: contains layer to thickness, zmin and material.\n\t            Defaults to active pdk.layer_stack.\n\t        temp_dir: temporary directory to hold simulation files.\n", "        temp_file_str: names of temporary files in temp_dir.\n\t        live_output: stream output of mpirun command to file and print to console\n\t            (meep verbosity still needs to be set separately).\n\t        overwrite: overwrites stored simulation results.\n\t        wait_to_finish: if True makes the function call blocking.\n\t    Keyword Args:\n\t        resolution: in pixels/um (30: for coarse, 100: for fine).\n\t        port_symmetries: Dict to specify port symmetries, to save number of simulations.\n\t        dirpath: directory to store Sparameters.\n\t        port_margin: margin on each side of the port.\n", "        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n\t        port_source_offset: offset between source GDS port and source MEEP port.\n\t        filepath: to store pandas Dataframe with Sparameters in CSV format.\n\t        animate: saves a MP4 images of the simulation for inspection, and also\n\t            outputs during computation. The name of the file is the source index.\n\t        lazy_parallelism: toggles the flag \"meep.divide_parallel_processes\" to\n\t            perform the simulations with different sources in parallel.\n\t        dispersive: use dispersive models for materials (requires higher resolution).\n\t        xmargin: left and right distance from component to PML.\n\t        xmargin_left: west distance from component to PML.\n", "        xmargin_right: east distance from component to PML.\n\t        ymargin: top and bottom distance from component to PML.\n\t        ymargin_top: north distance from component to PML.\n\t        ymargin_bot: south distance from component to PML.\n\t        extend_ports_length: to extend ports beyond the PML.\n\t        zmargin_top: thickness for cladding above core.\n\t        zmargin_bot: thickness for cladding below core.\n\t        tpml: PML thickness (um).\n\t        clad_material: material for cladding.\n\t        is_3d: if True runs in 3D.\n", "        wavelength_start: wavelength min (um).\n\t        wavelength_stop: wavelength max (um).\n\t        wavelength_points: wavelength steps.\n\t        dfcen: delta frequency.\n\t        port_source_name: input port name.\n\t        port_margin: margin on each side of the port.\n\t        distance_source_to_monitors: in (um) source goes before.\n\t        port_source_offset: offset between source GDS port and source MEEP port.\n\t        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n\t    Returns:\n", "        filepath for sparameters CSV (wavelengths, s11a, o1@0,o2@0, ...)\n\t            where `a` is the angle in radians and `m` the module.\n\t    TODO:\n\t        write stdout to file, maybe simulation logs too.\n\t    \"\"\"\n\t    for setting in kwargs:\n\t        if setting not in settings_write_sparameters_meep:\n\t            raise ValueError(f\"{setting!r} not in {settings_write_sparameters_meep}\")\n\t    component = gf.get_component(component)\n\t    assert isinstance(component, KCell)\n", "    layer_stack = layer_stack or pdk.layer_stack\n\t    settings = remove_simulation_kwargs(kwargs)\n\t    filepath = filepath or get_sparameters_path(\n\t        component=component,\n\t        dirpath=dirpath,\n\t        layer_stack=layer_stack,\n\t        **settings,\n\t    )\n\t    filepath = pathlib.Path(filepath)\n\t    if filepath.exists() and not overwrite:\n", "        logger.info(f\"Simulation {filepath!r} already exists\")\n\t        return filepath\n\t    if filepath.exists() and overwrite:\n\t        filepath.unlink()\n\t    # Save all the simulation arguments for later retrieval\n\t    temp_dir.mkdir(exist_ok=True, parents=True)\n\t    tempfile = temp_dir / temp_file_str\n\t    filepath_json = tempfile.with_suffix(\".json\")\n\t    logger.info(f\"Write {filepath_json!r}\")\n\t    layer_stack_json = layer_stack.json()\n", "    filepath_json.write_text(layer_stack_json)\n\t    parameters_file = tempfile.with_suffix(\".pkl\")\n\t    with open(parameters_file, \"wb\") as outp:\n\t        pickle.dump(settings, outp, pickle.HIGHEST_PROTOCOL)\n\t    # Save component to disk through gds for gdstk compatibility\n\t    component_file = tempfile.with_suffix(\".gds\")\n\t    component.write_gds_with_metadata(component_file)\n\t    # Write execution file\n\t    script_lines = [\n\t        \"import pathlib\\n\",\n", "        \"import pickle\\n\",\n\t        \"from kfactory.simulation.gmeep import write_sparameters_meep\\n\\n\",\n\t        \"from kfactory.read import import_gds\\n\",\n\t        \"from kfactory.technology import LayerStack\\n\\n\",\n\t        \"if __name__ == '__main__':\\n\",\n\t        f\"\\twith open(\\\"{parameters_file}\\\", 'rb') as inp:\\n\",\n\t        \"\\t\\tparameters_dict = pickle.load(inp)\\n\\n\",\n\t        f\"\\tcomponent = import_gds({str(component_file)!r}, read_metadata=True)\\n\",\n\t        f\"\\tfilepath_json = pathlib.Path({str(filepath_json)!r})\\n\",\n\t        \"\\tlayer_stack = LayerStack.parse_raw(filepath_json.read_text())\\n\",\n", "        f\"\\twrite_sparameters_meep(component=component, overwrite={overwrite}, \"\n\t        f\"layer_stack=layer_stack, filepath={str(filepath)!r},\",\n\t    ]\n\t    script_lines.extend(f'\\t\\t{key} = parameters_dict[\"{key}\"],\\n' for key in settings)\n\t    script_lines.append(\"\\t)\")\n\t    script_file = tempfile.with_suffix(\".py\")\n\t    with open(script_file, \"w\") as script_file_obj:\n\t        script_file_obj.writelines(script_lines)\n\t    command = f\"mpirun -np {cores} {_python()} {script_file}\"\n\t    logger.info(command)\n", "    logger.info(str(filepath))\n\t    if live_output:\n\t        import asyncio\n\t        from kplugins.async_utils import execute_and_stream_output\n\t        asyncio.run(\n\t            execute_and_stream_output(\n\t                command, log_file_dir=temp_dir, log_file_str=temp_file_str\n\t            )\n\t        )\n\t    else:\n", "        with subprocess.Popen(\n\t            shlex.split(command),\n\t            stdin=subprocess.PIPE,\n\t            stdout=subprocess.PIPE,\n\t            stderr=subprocess.PIPE,\n\t        ) as proc:\n\t            print(proc.stdout.read().decode())\n\t            print(proc.stderr.read().decode())\n\t            sys.stdout.flush()\n\t            sys.stderr.flush()\n", "        if wait_to_finish and not proc.stderr:\n\t            while not filepath.exists():\n\t                print(proc.stdout.read().decode())\n\t                print(proc.stderr.read().decode())\n\t                sys.stdout.flush()\n\t                sys.stderr.flush()\n\t                time.sleep(1)\n\t    return filepath\n\twrite_sparameters_meep_mpi_1x1 = partial(\n\t    write_sparameters_meep_mpi, port_symmetries=port_symmetries.port_symmetries_1x1\n", ")\n\twrite_sparameters_meep_mpi_1x1_bend90 = partial(\n\t    write_sparameters_meep_mpi,\n\t    ymargin_bot=3,\n\t    ymargin=0,\n\t    xmargin_right=3,\n\t    port_symmetries=port_symmetries.port_symmetries_1x1,\n\t)\n\tif __name__ == \"__main__\":\n\t    import numpy as np\n", "    c1 = kg.cells.waveguide(0.5, length=2.1, layer=0)\n\t    filepath = write_sparameters_meep_mpi(\n\t        component=c1,\n\t        # ymargin=3,\n\t        cores=2,\n\t        run=True,\n\t        overwrite=True,\n\t        live_output=True,\n\t        # lazy_parallelism=True,\n\t        lazy_parallelism=False,\n", "        temp_dir=\"./test/\",\n\t        filepath=\"instance_dict.csv\",\n\t        resolution=20,\n\t    )\n\t    sp = np.load(filepath)\n\t    print(list(sp.keys()))\n"]}
{"filename": "kplugins/kmeep/__init__.py", "chunked_list": ["from __future__ import annotations\n\ttry:\n\t    import meep as mp\n\texcept ModuleNotFoundError as e:\n\t    print(\"You need to 'conda install -c conda-forge pymeep=*=mpi_mpich_* nlopt -y'\")\n\t    raise e\n\tfrom kfactory.conf import logger\n\tfrom kplugins import plot, port_symmetries\n\tfrom kplugins.get_sparameters_path import get_sparameters_data_meep\n\tfrom kplugins.gmeep.get_simulation import get_simulation\n", "from kplugins.gmeep.meep_adjoint_optimization import (\n\t    get_meep_adjoint_optimizer,\n\t    run_meep_adjoint_optimizer,\n\t)\n\tfrom kplugins.gmeep.write_sparameters_grating import (\n\t    write_sparameters_grating,\n\t    write_sparameters_grating_batch,\n\t    write_sparameters_grating_mpi,\n\t)\n\tfrom kplugins.gmeep.write_sparameters_meep import (\n", "    write_sparameters_meep,\n\t    write_sparameters_meep_1x1,\n\t    write_sparameters_meep_1x1_bend90,\n\t)\n\tfrom kplugins.gmeep.write_sparameters_meep_batch import (\n\t    write_sparameters_meep_batch,\n\t    write_sparameters_meep_batch_1x1,\n\t    write_sparameters_meep_batch_1x1_bend90,\n\t)\n\tfrom kplugins.gmeep.write_sparameters_meep_mpi import (\n", "    write_sparameters_meep_mpi,\n\t    write_sparameters_meep_mpi_1x1,\n\t    write_sparameters_meep_mpi_1x1_bend90,\n\t)\n\tlogger.info(f\"Meep {mp.__version__!r} installed at {mp.__path__!r}\")\n\t__all__ = [\n\t    \"get_meep_adjoint_optimizer\",\n\t    \"get_simulation\",\n\t    \"get_sparameters_data_meep\",\n\t    \"run_meep_adjoint_optimizer\",\n", "    \"write_sparameters_meep\",\n\t    \"write_sparameters_meep_1x1\",\n\t    \"write_sparameters_meep_1x1_bend90\",\n\t    \"write_sparameters_meep_mpi\",\n\t    \"write_sparameters_meep_mpi_1x1\",\n\t    \"write_sparameters_meep_mpi_1x1_bend90\",\n\t    \"write_sparameters_meep_batch\",\n\t    \"write_sparameters_meep_batch_1x1\",\n\t    \"write_sparameters_meep_batch_1x1_bend90\",\n\t    \"write_sparameters_grating\",\n", "    \"write_sparameters_grating_mpi\",\n\t    \"write_sparameters_grating_batch\",\n\t    \"plot\",\n\t    \"port_symmetries\",\n\t]\n\t__version__ = \"0.0.3\"\n"]}
{"filename": "kplugins/kmeep/write_sparameters_grating.py", "chunked_list": ["\"\"\"SMF specs from photonics.byu.edu/FiberOpticConnectors.parts/images/smf28.pdf.\n\tMFD:\n\t- 10.4 for Cband\n\t- 9.2 for Oband\n\t\"\"\"\n\tfrom __future__ import annotations\n\timport hashlib\n\timport pathlib\n\timport shlex\n\timport shutil\n", "import subprocess\n\timport time\n\tfrom typing import Dict, Optional, Tuple\n\timport matplotlib.pyplot as plt\n\timport meep as mp\n\timport numpy as np\n\timport omegaconf\n\tfrom kfactory.conf import logger\n\tfrom kfactory.kcell import clean_value\n\tfrom kplugins.gmeep.get_simulation_grating_fiber import (\n", "    get_simulation_grating_fiber,\n\t)\n\tfrom kplugins.gmeep.write_sparameters_meep_mpi import _python\n\tfrom kfactory.typings import PathType\n\tnm = 1e-3\n\tnSi = 3.48\n\tnSiO2 = 1.44\n\tFloats = Tuple[float, ...]\n\tdef fiber_core_material(fiber_numerical_aperture, fiber_clad_material):\n\t    return (fiber_numerical_aperture**2 + fiber_clad_material**2) ** 0.5\n", "def write_sparameters_grating(\n\t    plot: bool = False,\n\t    plot_contour: bool = False,\n\t    animate: bool = False,\n\t    overwrite: bool = False,\n\t    dirpath: Optional[PathType] = \"./sparameters\",\n\t    decay_by: float = 1e-3,\n\t    verbosity: int = 0,\n\t    **settings,\n\t) -> np.ndarray:\n", "    \"\"\"Write grating coupler with fiber Sparameters.\n\t    Args:\n\t        plot: plot simulation (do not run).\n\t        plot_contour: show contours.\n\t        animate: create animation.\n\t        overwrite: overwrites simulation if found.\n\t        dirpath: directory path.\n\t        decay_by: field decay to stop simulation.\n\t        verbosity: print messages.\n\t        core_materials: number of cores.\n", "    Keyword Args:\n\t        period: fiber grating period in um.\n\t        fill_factor: fraction of the grating period filled with the grating material.\n\t        n_periods: number of periods.\n\t        widths: Optional list of widths. Overrides period, fill_factor, n_periods.\n\t        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n\t        fiber_angle_deg: fiber angle in degrees.\n\t        fiber_xposition: xposition.\n\t        fiber_core_diameter: fiber diameter.\n\t        fiber_numerical_aperture: NA.\n", "        fiber_clad_material: fiber cladding index.\n\t        nwg: waveguide index.\n\t        nslab: slab refractive index.\n\t        clad_material: top cladding index.\n\t        nbox: box index bottom.\n\t        nsubstrate: index substrate.\n\t        pml_thickness: pml_thickness (um).\n\t        substrate_thickness: substrate_thickness (um).\n\t        box_thickness: thickness for bottom cladding (um).\n\t        core_thickness: core_thickness (um).\n", "        slab_thickness: slab thickness (um). etch_depth=core_thickness-slab_thickness.\n\t        top_clad_thickness: thickness of the top cladding.\n\t        air_gap_thickness: air gap thickness.\n\t        fiber_thickness: fiber_thickness.\n\t        resolution: resolution pixels/um.\n\t        wavelength_start: min wavelength (um).\n\t        wavelength_stop: max wavelength (um).\n\t        wavelength_points: wavelength points.\n\t        eps_averaging: epsilon averaging.\n\t        fiber_port_y_offset_from_air: y_offset from fiber to air (um).\n", "        waveguide_port_x_offset_from_grating_start: in um.\n\t        fiber_port_x_size: in um.\n\t        xmargin: margin from PML to grating end in um.\n\t    .. code::\n\t                 fiber_xposition\n\t                  |\n\t             fiber_core_diameter\n\t          /     /  /     /       |\n\t         /     /  /     /        | fiber_thickness\n\t        /     /  /     /    _ _ _| _ _ _ _ _ _  _\n", "                                 |\n\t                                 | air_gap_thickness\n\t                            _ _ _| _ _ _ _ _ _  _\n\t                                 |\n\t                clad_material            | top_clad_thickness\n\t                            _ _ _| _ _ _ _ _ _  _\n\t             _|-|_|-|_|-|___     |              _| etch_depth\n\t              core_material        |     |core_thickness\n\t             ______________|_ _ _|_ _ _ _ _ _ _ _\n\t                                 |\n", "              nbox               |box_thickness\n\t             ______________ _ _ _|_ _ _ _ _ _ _ _\n\t                                 |\n\t              nsubstrate         |substrate_thickness\n\t             ______________ _ _ _|\n\t    \"\"\"\n\t    mp.verbosity(verbosity)\n\t    settings_string = clean_value(settings)\n\t    settings_hash = hashlib.md5(settings_string.encode()).hexdigest()[:8]\n\t    filename = f\"fiber_{settings_hash}.yml\"\n", "    dirpath = dirpath or pathlib.Path(__file__).parent / \"data\"\n\t    dirpath = pathlib.Path(dirpath)\n\t    dirpath.mkdir(exist_ok=True, parents=True)\n\t    filepath = dirpath / filename\n\t    filepath_npz = filepath.with_suffix(\".npz\")\n\t    filepath_mp4 = filepath.with_suffix(\".mp4\")\n\t    if filepath_npz.exists() and not overwrite and not plot:\n\t        logger.info(f\"sparameters loaded from {str(filepath_npz)!r}\")\n\t        return np.load(filepath_npz)\n\t    sim_dict = get_simulation_grating_fiber(**settings)\n", "    sim = sim_dict[\"sim\"]\n\t    freqs = sim_dict[\"freqs\"]\n\t    start = time.time()\n\t    if plot or plot_contour:\n\t        eps_parameters = dict(contour=True) if plot_contour else None\n\t        sim.plot2D(eps_parameters=eps_parameters)\n\t        plt.show()\n\t        return\n\t    termination = [mp.stop_when_energy_decayed(dt=50, decay_by=decay_by)]\n\t    if animate:\n", "        # Run while saving fields\n\t        # sim.use_output_directory()\n\t        animate = mp.Animate2D(\n\t            sim,\n\t            fields=mp.Ez,\n\t            realtime=False,\n\t            normalize=True,\n\t            eps_parameters={\"contour\": True},\n\t            field_parameters={\n\t                \"alpha\": 0.8,\n", "                \"cmap\": \"RdBu\",\n\t                \"interpolation\": \"none\",\n\t            },\n\t            boundary_parameters={\n\t                \"hatch\": \"o\",\n\t                \"linewidth\": 1.5,\n\t                \"facecolor\": \"y\",\n\t                \"edgecolor\": \"b\",\n\t                \"alpha\": 0.3,\n\t            },\n", "        )\n\t        sim.run(mp.at_every(1, animate), until_after_sources=termination)\n\t        animate.to_mp4(15, filepath_mp4)\n\t    else:\n\t        sim.run(until_after_sources=termination)\n\t    # Extract mode information\n\t    waveguide_monitor = sim_dict[\"waveguide_monitor\"]\n\t    waveguide_port_direction = sim_dict[\"waveguide_port_direction\"]\n\t    fiber_monitor = sim_dict[\"fiber_monitor\"]\n\t    fiber_angle_deg = sim_dict[\"fiber_angle_deg\"]\n", "    fcen = sim_dict[\"fcen\"]\n\t    wavelengths = 1 / freqs\n\t    waveguide_mode = sim.get_eigenmode_coefficients(\n\t        waveguide_monitor,\n\t        [1],\n\t        eig_parity=mp.ODD_Z,\n\t        direction=waveguide_port_direction,\n\t    )\n\t    fiber_mode = sim.get_eigenmode_coefficients(\n\t        fiber_monitor,\n", "        [1],\n\t        direction=mp.NO_DIRECTION,\n\t        eig_parity=mp.ODD_Z,\n\t        kpoint_func=lambda f, n: mp.Vector3(0, fcen * 1.45, 0).rotate(\n\t            mp.Vector3(z=1), -1 * np.radians(fiber_angle_deg)\n\t        ),  # Hardcoded index for now, pull from simulation eventually\n\t    )\n\t    end = time.time()\n\t    a1 = waveguide_mode.alpha[:, :, 0].flatten()  # forward wave\n\t    b1 = waveguide_mode.alpha[:, :, 1].flatten()  # backward wave\n", "    # Since waveguide port is oblique, figure out forward and backward direction\n\t    kdom_fiber = fiber_mode.kdom[0]\n\t    idx = 1 - (kdom_fiber.y > 0) * 1\n\t    a2 = fiber_mode.alpha[:, :, idx].flatten()  # forward wave\n\t    # b2 = fiber_mode.alpha[:, :, 1 - idx].flatten()  # backward wave\n\t    s11 = np.squeeze(b1 / a1)\n\t    s12 = np.squeeze(a2 / a1)\n\t    s22 = s11.copy()\n\t    s21 = s12.copy()\n\t    simulation = dict(\n", "        settings=settings,\n\t        compute_time_seconds=end - start,\n\t        compute_time_minutes=(end - start) / 60,\n\t    )\n\t    filepath.write_text(omegaconf.OmegaConf.to_yaml(simulation))\n\t    sp = {\n\t        \"o1@0,o1@0\": s11,\n\t        \"o1@0,o2@0\": s12,\n\t        \"o2@0,o1@0\": s21,\n\t        \"o2@0,o2@0\": s22,\n", "        \"wavelengths\": wavelengths,\n\t    }\n\t    np.savez_compressed(filepath_npz, **sp)\n\t    return sp\n\tdef write_sparameters_grating_mpi(\n\t    instance: Dict,\n\t    cores: int = 2,\n\t    temp_dir: Optional[str] = None,\n\t    temp_file_str: str = \"write_sparameters_meep_mpi\",\n\t    verbosity: bool = False,\n", "):\n\t    \"\"\"Write grating coupler Sparameters using multiple cores.\n\t    Given a Dict of write_sparameters_meep keyword arguments (the \"instance\"),\n\t    launches a parallel simulation on `cores` cores\n\t    Returns the subprocess Popen object\n\t    Args:\n\t        instances: keys are parameters names of write_sparameters_meep,\n\t            and entries the values.\n\t        cores (int): number of processors.\n\t        temp_dir (FilePath): temporary directory to hold simulation files.\n", "        temp_file_str (str): names of temporary files in temp_dir.\n\t        verbosity (bool): progress messages.\n\t    \"\"\"\n\t    # Save the component object to simulation for later retrieval\n\t    temp_dir = temp_dir or pathlib.Path(__file__).parent / \"temp\"\n\t    temp_dir = pathlib.Path(temp_dir)\n\t    temp_dir.mkdir(exist_ok=True, parents=True)\n\t    filepath = temp_dir / temp_file_str\n\t    # Add parallelism info\n\t    instance[\"core_materials\"] = cores\n", "    # Write execution file\n\t    script_lines = [\n\t        \"from kpugins.gmeep.write_sparameters_grating import write_sparameters_grating\\n\\n\",\n\t        'if __name__ == \"__main__\":\\n\\n',\n\t        \"\\twrite_sparameters_grating(\\n\",\n\t    ]\n\t    script_lines.extend(f\"\\t\\t{key} = {instance[key]!r},\\n\" for key in instance.keys())\n\t    script_lines.append(\"\\t)\")\n\t    script_file = filepath.with_suffix(\".py\")\n\t    with open(script_file, \"w\") as script_file_obj:\n", "        script_file_obj.writelines(script_lines)\n\t    # Exec string\n\t    command = f\"mpirun -np {cores} {_python()} {script_file}\"\n\t    # Launch simulation\n\t    if verbosity:\n\t        print(f\"Launching: {command}\")\n\t    return subprocess.Popen(\n\t        shlex.split(command),\n\t        shell=False,\n\t        stdin=None,\n", "        stdout=None,\n\t        stderr=None,\n\t    )\n\tdef write_sparameters_grating_batch(\n\t    instances,\n\t    cores_per_instance: int = 2,\n\t    total_cores: int = 4,\n\t    temp_dir: Optional[str] = None,\n\t    delete_temp_files: bool = False,\n\t    verbosity: bool = False,\n", ") -> None:\n\t    \"\"\"Write grating coupler Sparameters using multiple cores in batches of simulations.\n\t    Given a tuple of write_sparameters_meep keyword arguments (instances)\n\t    launches parallel simulations each simulation is assigned \"cores_per_instance\" cores\n\t    Assumes total of \"total_cores\" if cores_per_instance * len(instances) > total_cores\n\t    then the overflow will be performed serially\n\t    Args:\n\t        instances: list of Dicts. The keys must be parameters names of write_sparameters_meep,\n\t            and entries the values.\n\t        cores_per_instance: number of processors to assign to each instance.\n", "        total_cores: total number of cores to use.\n\t        temp_dir: temporary directory to hold simulation files.\n\t        delete_temp_file: whether to delete temp_dir when done.\n\t        verbosity: show progress messages.\n\t    \"\"\"\n\t    # Save the component object to simulation for later retrieval\n\t    temp_dir = temp_dir or pathlib.Path(__file__).parent / \"temp\"\n\t    temp_dir = pathlib.Path(temp_dir)\n\t    temp_dir.mkdir(exist_ok=True, parents=True)\n\t    # Setup pools\n", "    num_pools = int(np.ceil(cores_per_instance * len(instances) / total_cores))\n\t    instances_per_pool = int(np.floor(total_cores / cores_per_instance))\n\t    num_tasks = len(instances)\n\t    if verbosity:\n\t        print(f\"Running parallel simulations over {num_tasks} instances\")\n\t        print(\n\t            f\"Using a total of {total_cores} cores with {cores_per_instance} cores per instance\"\n\t        )\n\t        print(\n\t            f\"Tasks split amongst {num_pools} pools with up to {instances_per_pool} instances each.\"\n", "        )\n\t    i = 0\n\t    # For each pool\n\t    for j in range(num_pools):\n\t        processes = []\n\t        # For instance in the pool\n\t        for k in range(instances_per_pool):\n\t            # Flag to catch nonfull pools\n\t            if i >= num_tasks:\n\t                continue\n", "            if verbosity:\n\t                print(f\"Task {k} of pool {j} is instance {i}\")\n\t            # Obtain current instance\n\t            instance = instances[i]\n\t            process = write_sparameters_grating_batch(\n\t                instances=instance,\n\t                cores_per_instance=cores_per_instance,\n\t                temp_dir=temp_dir,\n\t                verbosity=verbosity,\n\t            )\n", "            processes.append(process)\n\t            # Increment task number\n\t            i += 1\n\t        # Wait for pool to end\n\t        for process in processes:\n\t            process.wait()\n\t    if delete_temp_files:\n\t        shutil.rmtree(temp_dir)\n\tif __name__ == \"__main__\":\n\t    # fiber_numerical_aperture = float(np.sqrt(1.44427 ** 2 - 1.43482 ** 2))\n", "    # instance1 = dict(\n\t    #     period=0.66,\n\t    #     fill_factor=0.5,\n\t    #     n_periods=50,\n\t    #     etch_depth=70 * nm,\n\t    #     fiber_angle_deg=10.0,\n\t    #     fiber_xposition=0.0,\n\t    #     fiber_core_diameter=9,\n\t    #     fiber_numerical_aperture=fiber_numerical_aperture,\n\t    #     fiber_clad_material=1.43482,\n", "    #     core_material=3.47,\n\t    #     clad_material=1.44,\n\t    #     nbox=1.44,\n\t    #     nsubstrate=3.47,\n\t    #     pml_thickness=1.0,\n\t    #     substrate_thickness=1.0,\n\t    #     box_thickness=2.0,\n\t    #     core_thickness=220 * nm,\n\t    #     top_clad_thickness=2.0,\n\t    #     air_gap_thickness=1.0,\n", "    #     fiber_thickness=2.0,\n\t    #     res=20,  # pixels/um\n\t    #     wavelength_min=1.4,\n\t    #     wavelength_max=1.7,\n\t    #     wavelength_points=150,\n\t    #     fiber_port_y_offset_from_air=1,\n\t    #     waveguide_port_x_offset_from_grating_start=10,\n\t    #     overwrite=True,\n\t    #     verbosity=0,\n\t    #     decay_by=1e-3,\n", "    # )\n\t    # instance2 = instance1.copy()\n\t    # instance2[\"period\"] = 0.5\n\t    # write_sparameters_meep_batch(\n\t    #     instances=[instance1, instance2],\n\t    #     cores_per_instance=4,\n\t    #     total_cores=8,\n\t    #     verbosity=True,\n\t    #     delete_temp_files=True,\n\t    # )\n", "    from kplugins.plot import plot_sparameters\n\t    sp = write_sparameters_grating(fiber_angle_deg=15)\n\t    plot_sparameters(sp)\n"]}
{"filename": "kplugins/kmeep/get_simulation_grating_farfield.py", "chunked_list": ["\"\"\"FIXME: needs some work.\n\t- figure out get_farfield outputs\n\t- add tutorial in docs/notebooks/plugins/meep/002_gratings.ipynb\n\t- add filecache\n\t- benchmark with lumerical and tidy3d\n\t- add tests\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom typing import Any, Dict, List, Optional\n\timport meep as mp\n", "import numpy as np\n\tnm = 1e-3\n\tnSi = 3.48\n\tnSiO2 = 1.44\n\tdef fiber_core_material(fiber_numerical_aperture, fiber_clad_material):\n\t    return (fiber_numerical_aperture**2 + fiber_clad_material**2) ** 0.5\n\tdef get_simulation_grating_farfield(\n\t    period: float = 0.66,\n\t    fill_factor: float = 0.5,\n\t    n_periods: int = 30,\n", "    widths: Optional[List[float]] = None,\n\t    gaps: Optional[List[float]] = None,\n\t    etch_depth: float = 70 * nm,\n\t    fiber_angle_deg: float = 20.0,\n\t    fiber_xposition: float = 1.0,\n\t    fiber_core_diameter: float = 10.4,\n\t    fiber_numerical_aperture: float = 0.14,\n\t    fiber_clad_material: float = nSiO2,\n\t    core_material: float = nSi,\n\t    clad_material: float = nSiO2,\n", "    nsubstrate: float = nSi,\n\t    pml_thickness: float = 1,\n\t    box_thickness: float = 2.0,\n\t    clad_thickness: float = 2.0,\n\t    core_thickness: float = 220 * nm,\n\t    resolution: int = 64,  # pixels/um\n\t    wavelength_min: float = 1.5,\n\t    wavelength_max: float = 1.6,\n\t    wavelength_points: int = 50,\n\t) -> Dict[str, Any]:\n", "    \"\"\"Returns grating coupler far field simulation.\n\t    FIXME! needs some more work.\n\t    na**2 = core_material**2 - clad_material**2\n\t    core_material = sqrt(na**2 + core_material**2)\n\t    Args:\n\t        period: fiber grating period.\n\t        fill_factor: fraction of the grating period\n\t            filled with the grating material.\n\t        n_periods: number of periods\n\t        widths: Optional list of widths.\n", "            Overrides period, fill_factor, n_periods.\n\t        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n\t        etch_depth: grating etch depth.\n\t        fiber_angle_deg: fiber angle in degrees.\n\t        fiber_xposition: xposition.\n\t        fiber_core_diameter: fiber diameter.\n\t        fiber_numerical_aperture: NA.\n\t        fiber_clad_material: fiber cladding index.\n\t        core_material: fiber index core.\n\t        clad_material: top cladding index.\n", "        nbox: box index bottom.\n\t        nsubstrate: index substrate.\n\t        pml_thickness: pml_thickness (um).\n\t        substrate_thickness: substrate_thickness (um).\n\t        box_thickness: thickness for bottom cladding (um).\n\t        core_thickness: core_thickness (um).\n\t        top_clad_thickness: thickness of the top cladding.\n\t        air_gap_thickness: air gap thickness.\n\t        resolution: resolution pixels/um.\n\t        wavelength_min: min wavelength (um).\n", "        wavelength_max: max wavelength (um).\n\t        wavelength_points: wavelength points.\n\t    Some parameters are different from get_simulation_grating_fiber\n\t        fiber_thickness: fiber_thickness.\n\t    \"\"\"\n\t    wavelengths = np.linspace(wavelength_min, wavelength_max, wavelength_points)\n\t    wavelength = np.mean(wavelengths)\n\t    freqs = 1 / wavelengths\n\t    widths = widths or n_periods * [period * fill_factor]\n\t    gaps = gaps or n_periods * [period * (1 - fill_factor)]\n", "    settings = dict(\n\t        period=period,\n\t        fill_factor=fill_factor,\n\t        fiber_angle_deg=fiber_angle_deg,\n\t        fiber_xposition=fiber_xposition,\n\t        fiber_core_diameter=fiber_core_diameter,\n\t        fiber_numerical_aperture=fiber_core_diameter,\n\t        fiber_clad_material=fiber_clad_material,\n\t        resolution=resolution,\n\t        core_material=core_material,\n", "        clad_material=clad_material,\n\t        nsubstrate=nsubstrate,\n\t        n_periods=n_periods,\n\t        box_thickness=box_thickness,\n\t        clad_thickness=clad_thickness,\n\t        etch_depth=etch_depth,\n\t        wavelength_min=wavelength_min,\n\t        wavelength_max=wavelength_max,\n\t        wavelength_points=wavelength_points,\n\t        widths=widths,\n", "        gaps=gaps,\n\t    )\n\t    length_grating = np.sum(widths) + np.sum(gaps)\n\t    substrate_thickness = 1.0\n\t    hair = 4\n\t    core_material = mp.Medium(index=core_material)\n\t    clad_material = mp.Medium(index=clad_material)\n\t    fiber_angle = np.radians(fiber_angle_deg)\n\t    y_offset = 0\n\t    x_offset = 0\n", "    # Minimally-parametrized computational cell\n\t    # Could be further optimized\n\t    # X-domain\n\t    dbufferx = 0.5\n\t    if length_grating < 3 * fiber_core_diameter:\n\t        sxy = 3 * fiber_core_diameter + 2 * dbufferx + 2 * pml_thickness\n\t    else:  # Fiber probably to the left\n\t        sxy = (\n\t            3 / 2 * fiber_core_diameter\n\t            + length_grating / 2\n", "            + 2 * dbufferx\n\t            + 2 * pml_thickness\n\t        )\n\t    # Useful reference points\n\t    cell_edge_left = -sxy / 2 + dbufferx + pml_thickness\n\t    grating_start = -fiber_xposition\n\t    # Y-domain (using z notation from 3D legacy code)\n\t    dbuffery = 0.5\n\t    sz = (\n\t        2 * dbuffery\n", "        + box_thickness\n\t        + core_thickness\n\t        + hair\n\t        + substrate_thickness\n\t        + 2 * pml_thickness\n\t    )\n\t    # Initialize domain x-z plane simulation\n\t    cell_size = mp.Vector3(sxy, sz)\n\t    # Ports (position, sizes, directions)\n\t    fiber_offset_from_angle = (clad_thickness + core_thickness) * np.tan(fiber_angle)\n", "    fiber_port_center = mp.Vector3(\n\t        (0.5 * sz - pml_thickness + y_offset - 1) * np.sin(fiber_angle)\n\t        + cell_edge_left\n\t        + 3 / 2 * fiber_core_diameter\n\t        - fiber_offset_from_angle,\n\t        0.5 * sz - pml_thickness + y_offset - 1,\n\t    )\n\t    fiber_port_size = mp.Vector3(3 * fiber_core_diameter, 0, 0)\n\t    # fiber_port_direction = mp.Vector3(y=-1).rotate(mp.Vector3(z=1), -1 * fiber_angle)\n\t    waveguide_port_center = mp.Vector3(-sxy / 4)\n", "    waveguide_port_size = mp.Vector3(0, 2 * clad_thickness - 0.2)\n\t    waveguide_port_direction = mp.X\n\t    # Geometry\n\t    fiber_clad = 120\n\t    hfiber_geom = 100  # Some large number to make fiber extend into PML\n\t    fiber_core_material = (\n\t        fiber_numerical_aperture**2 + fiber_clad_material**2\n\t    ) ** 0.5\n\t    fiber_clad_material = mp.Medium(index=fiber_clad_material)\n\t    fiber_core_material = mp.Medium(index=fiber_core_material)\n", "    geometry = [\n\t        mp.Block(\n\t            material=fiber_clad_material,\n\t            center=mp.Vector3(\n\t                x=grating_start + fiber_xposition - fiber_offset_from_angle\n\t            ),\n\t            size=mp.Vector3(fiber_clad, hfiber_geom),\n\t            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n\t            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n\t        )\n", "    ]\n\t    geometry.append(\n\t        mp.Block(\n\t            material=fiber_core_material,\n\t            center=mp.Vector3(\n\t                x=grating_start + fiber_xposition - fiber_offset_from_angle\n\t            ),\n\t            size=mp.Vector3(fiber_core_diameter, hfiber_geom),\n\t            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n\t            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n", "        )\n\t    )\n\t    # clad\n\t    geometry.append(\n\t        mp.Block(\n\t            material=clad_material,\n\t            center=mp.Vector3(0, clad_thickness / 2),\n\t            size=mp.Vector3(mp.inf, clad_thickness),\n\t        )\n\t    )\n", "    # BOX\n\t    geometry.append(\n\t        mp.Block(\n\t            material=clad_material,\n\t            center=mp.Vector3(0, -0.5 * box_thickness),\n\t            size=mp.Vector3(mp.inf, box_thickness),\n\t        )\n\t    )\n\t    # waveguide\n\t    geometry.append(\n", "        mp.Block(\n\t            material=core_material,\n\t            center=mp.Vector3(0, core_thickness / 2),\n\t            size=mp.Vector3(mp.inf, core_thickness),\n\t        )\n\t    )\n\t    # grating etch\n\t    x = grating_start\n\t    for width, gap in zip(widths, gaps):\n\t        geometry.append(\n", "            mp.Block(\n\t                material=clad_material,\n\t                center=mp.Vector3(x + gap / 2, core_thickness - etch_depth / 2),\n\t                size=mp.Vector3(gap, etch_depth),\n\t            )\n\t        )\n\t        x += width + gap\n\t    # Substrate\n\t    geometry.append(\n\t        mp.Block(\n", "            material=mp.Medium(index=nsubstrate),\n\t            center=mp.Vector3(\n\t                0,\n\t                -0.5 * (core_thickness + substrate_thickness + pml_thickness + dbuffery)\n\t                - box_thickness,\n\t            ),\n\t            size=mp.Vector3(mp.inf, substrate_thickness + pml_thickness + dbuffery),\n\t        )\n\t    )\n\t    # PMLs\n", "    boundary_layers = [mp.PML(pml_thickness)]\n\t    # mode frequency\n\t    fcen = 1 / wavelength\n\t    # Waveguide source\n\t    sources_directions = [mp.X]\n\t    sources = [\n\t        mp.EigenModeSource(\n\t            src=mp.GaussianSource(fcen, fwidth=0.1 * fcen),\n\t            size=waveguide_port_size,\n\t            center=waveguide_port_center,\n", "            eig_band=1,\n\t            direction=sources_directions[0],\n\t            eig_match_freq=True,\n\t            eig_parity=mp.ODD_Z,\n\t        )\n\t    ]\n\t    # Ports\n\t    waveguide_monitor_port = mp.ModeRegion(\n\t        center=waveguide_port_center + mp.Vector3(x=0.2), size=waveguide_port_size\n\t    )\n", "    fiber_monitor_port = mp.ModeRegion(\n\t        center=fiber_port_center - mp.Vector3(y=0.2), size=fiber_port_size\n\t    )\n\t    sim = mp.Simulation(\n\t        resolution=resolution,\n\t        cell_size=cell_size,\n\t        boundary_layers=boundary_layers,\n\t        geometry=geometry,\n\t        sources=sources,\n\t        dimensions=2,\n", "        eps_averaging=True,\n\t    )\n\t    offset_vector = mp.Vector3(x_offset, y_offset)\n\t    nearfield = sim.add_near2far(\n\t        fcen,\n\t        0,\n\t        1,\n\t        mp.Near2FarRegion(\n\t            mp.Vector3(x_offset, 0.5 * sz - pml_thickness + y_offset) - offset_vector,\n\t            size=mp.Vector3(sxy - 2 * pml_thickness, 0),\n", "        ),\n\t    )\n\t    waveguide_monitor = sim.add_mode_monitor(\n\t        freqs, waveguide_monitor_port, yee_grid=True\n\t    )\n\t    fiber_monitor = sim.add_mode_monitor(freqs, fiber_monitor_port)\n\t    field_monitor_point = (0, 0, 0)\n\t    return dict(\n\t        sim=sim,\n\t        cell_size=cell_size,\n", "        freqs=freqs,\n\t        fcen=fcen,\n\t        waveguide_monitor=waveguide_monitor,\n\t        waveguide_port_direction=waveguide_port_direction,\n\t        fiber_monitor=fiber_monitor,\n\t        fiber_angle_deg=fiber_angle_deg,\n\t        sources=sources,\n\t        field_monitor_point=field_monitor_point,\n\t        initialized=False,\n\t        settings=settings,\n", "        nearfield=nearfield,\n\t    )\n\tdef get_farfield(wavelength: float = 1.55, **kwargs):\n\t    \"\"\"FIXME: figure out outputs.\n\t    based on\n\t    http://www.simpetus.com/projects.html#meep_outcoupler\n\t    \"\"\"\n\t    sim_dict = get_simulation_grating_farfield(**kwargs)\n\t    sim = sim_dict[\"sim\"]\n\t    sim.run(until=400)\n", "    fcen = 1 / wavelength\n\t    r = 1000 / fcen  # 1000 wavelengths out from the source\n\t    npts = 1000  # number of points in [0,2*pi) range of angles\n\t    farfield_angles = []\n\t    farfield_power = []\n\t    nearfield = sim[\"nearfield\"]\n\t    for n in range(npts):\n\t        ff = sim.get_farfield(\n\t            nearfield,\n\t            mp.Vector3(r * np.cos(np.pi * (n / npts)), r * np.sin(np.pi * (n / npts))),\n", "        )\n\t        farfield_angles.append(\n\t            np.angle(np.cos(np.pi * (n / npts)) + 1j * np.sin(np.pi * (n / npts)))\n\t        )\n\t        farfield_power.append(ff)\n\t    farfield_angles = np.array(farfield_angles)\n\t    farfield_power = np.array(farfield_power)\n\t    return sim.get_eigenmode_coefficients(\n\t        sim_dict[\"waveguide_monitor\"], [1], eig_parity=mp.ODD_Z, direction=mp.X\n\t    )\n", "def get_port_1D_eigenmode(\n\t    sim_dict,\n\t    band_num: int = 1,\n\t    fiber_angle_deg: float = 15,\n\t):\n\t    \"\"\"Args are the following.\n\t        sim_dict: simulation dict\n\t        band_num: band number to solve for\n\t        fiber_angle_deg\n\t    Returns:\n", "        Mode object compatible with /modes plugin\n\t    \"\"\"\n\t    # Initialize\n\t    sim = sim_dict[\"sim\"]\n\t    source = sim_dict[\"sources\"][0]\n\t    waveguide_monitor = sim_dict[\"waveguide_monitor\"]\n\t    fiber_monitor = sim_dict[\"fiber_monitor\"]\n\t    # Obtain source frequency\n\t    fsrc = source.src.frequency\n\t    # Obtain xsection\n", "    center_fiber = fiber_monitor.regions[0].center\n\t    size_fiber = fiber_monitor.regions[0].size\n\t    center_waveguide = waveguide_monitor.regions[0].center\n\t    size_waveguide = waveguide_monitor.regions[0].size\n\t    # Solve for the modes\n\t    if sim_dict[\"initialized\"] is False:\n\t        sim.init_sim()\n\t        sim_dict[\"initialized\"] = True\n\t    # Waveguide\n\t    eigenmode_waveguide = sim.get_eigenmode(\n", "        direction=mp.X,\n\t        where=mp.Volume(center=center_waveguide, size=size_waveguide),\n\t        band_num=band_num,\n\t        kpoint=mp.Vector3(\n\t            fsrc * 3.48, 0, 0\n\t        ),  # Hardcoded index for now, pull from simulation eventually\n\t        frequency=fsrc,\n\t    )\n\t    ys_waveguide = np.linspace(\n\t        center_waveguide.y - size_waveguide.y / 2,\n", "        center_waveguide.y + size_waveguide.y / 2,\n\t        int(sim.resolution * size_waveguide.y),\n\t    )\n\t    x_waveguide = center_waveguide.x\n\t    # Fiber\n\t    eigenmode_fiber = sim.get_eigenmode(\n\t        direction=mp.NO_DIRECTION,\n\t        where=mp.Volume(center=center_fiber, size=size_fiber),\n\t        band_num=band_num,\n\t        kpoint=mp.Vector3(0, fsrc * 1.45, 0).rotate(\n", "            mp.Vector3(z=1), -1 * np.radians(fiber_angle_deg)\n\t        ),  # Hardcoded index for now, pull from simulation eventually\n\t        frequency=fsrc,\n\t    )\n\t    xs_fiber = np.linspace(\n\t        center_fiber.x - size_fiber.x / 2,\n\t        center_fiber.x + size_fiber.x / 2,\n\t        int(sim.resolution * size_fiber.x),\n\t    )\n\t    y_fiber = center_fiber.y\n", "    return (\n\t        x_waveguide,\n\t        ys_waveguide,\n\t        eigenmode_waveguide,\n\t        xs_fiber,\n\t        y_fiber,\n\t        eigenmode_fiber,\n\t    )\n\tdef plot(sim) -> None:\n\t    \"\"\"sim: simulation object.\"\"\"\n", "    sim.plot2D(eps_parameters={\"contour\": True})\n\t    # plt.colorbar()\n\tif __name__ == \"__main__\":\n\t    import matplotlib.pyplot as plt\n\t    sim_dict = get_simulation_grating_farfield(fiber_xposition=1, fiber_angle_deg=15)\n\t    # plot(sim_dict[\"sim\"])\n\t    # plt.show()\n\t    # results = {}\n\t    # for angle in [10]:\n\t    #     print(angle)\n", "    #     (\n\t    #         x_waveguide,\n\t    #         ys_waveguide,\n\t    #         eigenmode_waveguide,\n\t    #         xs_fiber,\n\t    #         y_fiber,\n\t    #         eigenmode_fiber,\n\t    #     ) = get_port_1D_eigenmode(sim_dict, band_num=1, fiber_angle_deg=angle)\n\t    #     Ez_fiber = np.zeros(len(xs_fiber), dtype=np.complex128)\n\t    #     for i in range(len(xs_fiber)):\n", "    #         Ez_fiber[i] = eigenmode_fiber.amplitude(\n\t    #             mp.Vector3(xs_fiber[i], y_fiber, 0), mp.Ez\n\t    #         )\n\t    #     plt.plot(xs_fiber, np.abs(Ez_fiber))\n\t    # plt.xlabel(\"x (um)\")\n\t    # plt.ylabel(\"Ez (a.u.)\")\n\t    # plt.savefig(\"fiber.png\")\n\t    # # M1, E-field\n\t    # plt.figure(figsize=(10, 8), dpi=100)\n\t    # plt.suptitle(\n", "    #     \"MEEP get_eigenmode / MPB find_modes / Lumerical (manual)\",\n\t    #     y=1.05,\n\t    #     fontsize=18,\n\t    # )\n\t    # plt.show()\n\t    wavelength = 1.55\n\t    settings = {}\n\t    sim_dict = get_simulation_grating_farfield(**settings)\n\t    sim = sim_dict[\"sim\"]\n\t    sim.run(until=100)\n", "    # sim.run(until=400)\n\t    fcen = 1 / wavelength\n\t    r = 1000 / fcen  # 1000 wavelengths out from the source\n\t    npts = 1000  # number of points in [0,2*pi) range of angles\n\t    farfield_angles = []\n\t    farfield_power = []\n\t    nearfield = sim[\"nearfield\"]\n\t    for n in range(npts):\n\t        ff = sim.get_farfield(\n\t            nearfield,\n", "            mp.Vector3(r * np.cos(np.pi * (n / npts)), r * np.sin(np.pi * (n / npts))),\n\t        )\n\t        farfield_angles.append(\n\t            np.angle(np.cos(np.pi * (n / npts)) + 1j * np.sin(np.pi * (n / npts)))\n\t        )\n\t        farfield_power.append(ff)\n\t    farfield_angles = np.array(farfield_angles)\n\t    farfield_power = np.array(farfield_power)\n\t    # Waveguide\n\t    res_waveguide = sim.get_eigenmode_coefficients(\n", "        sim_dict[\"waveguide_monitor\"], [1], eig_parity=mp.ODD_Z, direction=mp.X\n\t    )\n\t    print(res_waveguide)\n\t    plt.plot(farfield_power)\n\t    plt.show()\n"]}
{"filename": "kplugins/kmeep/test_write_sparameters_meep.py", "chunked_list": ["\"\"\"test meep sparameters.\"\"\"\n\tfrom __future__ import annotations\n\timport numpy as np\n\timport kfactory as gf\n\timport kplugins as kpl\n\timport kplugins.gmeep as gm\n\tfrom kgeneric import pdk as PDK\n\timport kgeneric as kg\n\timport copy\n\tPDK.activate()\n", "simulation_settings = dict(resolution=20, is_3d=False)\n\tdef test_sparameters_straight() -> None:\n\t    \"\"\"Checks Sparameters for a straight waveguide.\"\"\"\n\t    c = kg.cells.waveguide(0.5, length=2, layer=0)\n\t    p = 3\n\t    sp = gm.write_sparameters_meep(c, ymargin=0, overwrite=True, **simulation_settings)\n\t    # Check reasonable reflection/transmission\n\t    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n\t    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n\t    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n", "    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])\n\tdef test_sparameters_straight_symmetric() -> None:\n\t    \"\"\"Checks Sparameters for a straight waveguide.\"\"\"\n\t    c = kg.cells.waveguide(0.5, length=2, layer=0)\n\t    p = 3\n\t    # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n\t    # port_symmetries for straight\n\t    sp = gm.write_sparameters_meep(\n\t        c,\n\t        overwrite=True,\n", "        port_symmetries=kpl.port_symmetries.port_symmetries_1x1,\n\t        ymargin=0,\n\t        **simulation_settings,\n\t    )\n\t    # Check reasonable reflection/transmission\n\t    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n\t    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n\t    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n\t    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])\n\tdef test_sparameters_crossing_symmetric() -> None:\n", "    \"\"\"Checks Sparameters for a waveguide crossing exploiting symmetries.\"\"\"\n\t    c = gf.components.crossing()\n\t    sp = gm.write_sparameters_meep(\n\t        c,\n\t        overwrite=True,\n\t        port_symmetries=kpl.port_symmetries.port_symmetries_crossing,\n\t        ymargin=0,\n\t        **simulation_settings,\n\t    )\n\t    assert sp\n", "def test_sparameters_straight_mpi() -> None:\n\t    \"\"\"Checks Sparameters for a straight waveguide using MPI.\"\"\"\n\t    c = kg.cells.waveguide(0.5, length=2, layer=0)\n\t    p = 3\n\t    # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n\t    filepath = gm.write_sparameters_meep_mpi(\n\t        c, ymargin=0, overwrite=True, **simulation_settings\n\t    )\n\t    sp = np.load(filepath)\n\t    sp = dict(sp)\n", "    # Check reasonable reflection/transmission\n\t    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n\t    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n\t    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n\t    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])\n\t    \"\"\"Now check different parameters are properly handled.\"\"\"\n\t    modified_settings = copy.deepcopy(simulation_settings)\n\t    modified_settings[\"wavelength_points\"] = 10\n\t    filepath2 = gm.write_sparameters_meep_mpi(\n\t        c, ymargin=0, overwrite=True, **modified_settings\n", "    )\n\t    sp2 = np.load(filepath2)\n\t    sp2 = dict(sp2)\n\t    assert len(sp[\"wavelengths\"]) != len(sp2[\"wavelengths\"])\n\tdef test_sparameters_straight_batch() -> None:\n\t    \"\"\"Checks Sparameters for a straight waveguide using an MPI pool.\"\"\"\n\t    components = []\n\t    p = 3\n\t    for length in [2]:\n\t        c = kg.cells.waveguide(0.5, length=length, layer=0)\n", "        # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n\t        components.append(c)\n\t    filepaths = gm.write_sparameters_meep_batch(\n\t        [\n\t            {\"component\": c, \"overwrite\": True, **simulation_settings}\n\t            for c in components\n\t        ],\n\t    )\n\t    filepath = filepaths[0]\n\t    sp = np.load(filepath)\n", "    sp = dict(sp)\n\t    # Check reasonable reflection/transmission\n\t    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n\t    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n\t    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n\t    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])\n\t    filepath2 = kpl.get_sparameters_path_meep(\n\t        component=c, layer_stack=PDK.layer_stack, **simulation_settings\n\t    )\n\t    assert (\n", "        filepath2 == filepaths[0]\n\t    ), f\"filepath returned {filepaths[0]} differs from {filepath2}\"\n\t# def test_sparameters_grating_coupler() -> None:\n\t#     \"\"\"Checks Sparameters for a grating coupler.\"\"\"\n\t#     sp = gm.write_sparameters_grating()  # fiber_angle_deg = 20\n\t#     assert sp\n\tdef test_sparameters_lazy_parallelism() -> None:\n\t    \"\"\"Checks that the Sparameters computed using MPI and lazy_parallelism flag give the same results as the serial calculation.\"\"\"\n\t    c = kg.cells.waveguide(0.5, length=2, layer=0)\n\t    p = 3\n", "    filepath_parallel = gm.write_sparameters_meep_mpi(\n\t        c, ymargin=0, overwrite=True, lazy_parallelism=True, **simulation_settings\n\t    )\n\t    sp_parallel = np.load(filepath_parallel)\n\t    filepath_serial = gm.write_sparameters_meep_mpi(\n\t        c, ymargin=0, overwrite=True, lazy_parallelism=False, **simulation_settings\n\t    )\n\t    sp_serial = dict(np.load(filepath_serial))\n\t    # Check matching reflection/transmission\n\t    assert np.allclose(sp_parallel[\"o1@0,o1@0\"], sp_serial[\"o1@0,o1@0\"], atol=1e-2)\n", "    assert np.allclose(sp_parallel[\"o2@0,o1@0\"], sp_serial[\"o2@0,o1@0\"], atol=1e-2)\n\t    assert np.allclose(sp_parallel[\"o1@0,o2@0\"], sp_serial[\"o1@0,o2@0\"], atol=1e-2)\n\t    assert np.allclose(sp_parallel[\"o2@0,o2@0\"], sp_serial[\"o2@0,o2@0\"], atol=1e-2)\n\tif __name__ == \"__main__\":\n\t    # test_sparameters_straight()\n\t    test_sparameters_straight_mpi()\n\t    # test_sparameters_crossing_symmetric(False)\n\t    # test_sparameterslazy_parallelism()\n\t    # test_sparameters_straight_symmetric()\n\t    # test_sparameters_straight_batch()\n", "    # test_sparameters_crossing_symmetric()\n\t    # c = gf.components.straight(length=2)\n\t    # p = 3\n\t    # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n\t    # filepath = gm.write_sparameters_meep_mpi(\n\t    #     c, ymargin=0, overwrite=True, **simulation_settings\n\t    # )\n\t    # sp = dict(np.load(filepath))\n\t    # # Check reasonable reflection/transmission\n\t    # assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n"]}
{"filename": "kplugins/kmeep/get_meep_geometry.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Dict, List, Optional, Union\n\timport meep as mp\n\timport numpy as np\n\timport kgeneric as kf\n\tfrom kgeneric import pdk\n\tfrom kplugins.gmeep.get_material import get_material\n\tfrom kfactory.technology import LayerStack\n\tfrom kfactory.typings import CellSpec\n\tdef get_meep_geometry_from_component(\n", "    KCell: CellSpec,\n\t    layer_stack: Optional[LayerStack] = None,\n\t    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n\t    wavelength: float = 1.55,\n\t    is_3d: bool = False,\n\t    dispersive: bool = False,\n\t    **kwargs,\n\t) -> List[mp.GeometricObject]:\n\t    \"\"\"Returns Meep geometry from a kfactory KCell.\n\t    Args:\n", "        KCell: kfactory KCell.\n\t        layer_stack: for material layers.\n\t        material_name_to_meep: maps layer_stack name to meep material name.\n\t        wavelength: in um.\n\t        is_3d: renders in 3D.\n\t        dispersive: add dispersion.\n\t        kwargs: settings.\n\t    \"\"\"\n\t    KCell = pdk.get_cell(cell=KCell, **kwargs)\n\t    layer_stack = layer_stack or pdk.layer_stack\n", "    layer_to_thickness = layer_stack.get_layer_to_thickness()\n\t    layer_to_material = layer_stack.get_layer_to_material()\n\t    layer_to_zmin = layer_stack.get_layer_to_zmin()\n\t    layer_to_sidewall_angle = layer_stack.get_layer_to_sidewall_angle()\n\t    # component_with_booleans = layer_stack.get_component_with_derived_layers(KCell)\n\t    geometry = []\n\t    for layer in KCell.kcl.layer_indices():\n\t        for shape in KCell._kdb_cell.shapes(layer):\n\t            height = layer_to_thickness[layer] if is_3d else mp.inf\n\t            zmin_um = layer_to_zmin[layer] if is_3d else 0\n", "            # center = mp.Vector3(0, 0, (zmin_um + height) / 2)\n\t            vertices = [mp.Vector3(p.x, p.y, zmin_um) for p in shape.each_dpoint()]\n\t            material_name = layer_to_material[layer]\n\t            if material_name:\n\t                material = get_material(\n\t                    name=material_name,\n\t                    dispersive=dispersive,\n\t                    material_name_to_meep=material_name_to_meep,\n\t                    wavelength=wavelength,\n\t                )\n", "                geometry.append(\n\t                    mp.Prism(\n\t                        vertices=vertices,\n\t                        height=height,\n\t                        sidewall_angle=layer_to_sidewall_angle[layer]\n\t                        if is_3d\n\t                        else 0,\n\t                        material=material,\n\t                        # center=center\n\t                    )\n", "                )\n\t    return geometry\n\t# def get_meep_geometry_from_cross_section(\n\t#     cross_section: CrossSectionSpec,\n\t#     extension_length: Optional[float] = None,\n\t#     layer_stack: Optional[LayerStack] = None,\n\t#     material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n\t#     wavelength: float = 1.55,\n\t#     dispersive: bool = False,\n\t#     **kwargs,\n", "# ) -> List[mp.GeometricObject]:\n\t#     x = kf.get_cross_section(cross_section=cross_section, **kwargs)\n\t#     x_sections = [\n\t#         kf.Section(offset=x.offset, layer=x.layer, width=x.width),\n\t#         *x.sections,\n\t#     ]\n\t#     layer_stack = layer_stack or get_layer_stack()\n\t#     layer_to_thickness = layer_stack.get_layer_to_thickness()\n\t#     layer_to_material = layer_stack.get_layer_to_material()\n\t#     layer_to_zmin = layer_stack.get_layer_to_zmin()\n", "#     layer_to_sidewall_angle = layer_stack.get_layer_to_sidewall_angle()\n\t#     geometry = []\n\t#     for section in x_sections:\n\t#         print(f\"section: {section}\")\n\t#         layer = kf.get_layer(section.layer)\n\t#         if layer in layer_to_thickness and layer in layer_to_material:\n\t#             height = layer_to_thickness[layer]\n\t#             width = section.width\n\t#             offset = section.offset\n\t#             zmin_um = layer_to_zmin[layer] + (0 if height > 0 else -height)\n", "#             # center = mp.Vector3(0, 0, (zmin_um + height) / 2)\n\t#             material_name = layer_to_material[layer]\n\t#             material = get_material(\n\t#                 name=material_name,\n\t#                 dispersive=dispersive,\n\t#                 material_name_to_meep=material_name_to_meep,\n\t#                 wavelength=wavelength,\n\t#             )\n\t#             index = material.epsilon(1 / wavelength)[0, 0] ** 0.5\n\t#             print(f\"add {material_name!r} layer with index {index}\")\n", "#             # Don't need to use prism unless using sidewall angles\n\t#             if layer in layer_to_sidewall_angle:\n\t#                 # If using a prism, all dimensions need to be finite\n\t#                 xspan = extension_length or 1\n\t#                 p = mp.Prism(\n\t#                     vertices=[\n\t#                         mp.Vector3(x=-xspan / 2, y=-width / 2, z=zmin_um),\n\t#                         mp.Vector3(x=-xspan / 2, y=width / 2, z=zmin_um),\n\t#                         mp.Vector3(x=xspan / 2, y=width / 2, z=zmin_um),\n\t#                         mp.Vector3(x=xspan / 2, y=-width / 2, z=zmin_um),\n", "#                     ],\n\t#                     height=height,\n\t#                     center=mp.Vector3(y=offset, z=height / 2 + zmin_um),\n\t#                     sidewall_angle=np.deg2rad(layer_to_sidewall_angle[layer]),\n\t#                     material=material,\n\t#                 )\n\t#                 geometry.append(p)\n\t#             else:\n\t#                 xspan = extension_length or mp.inf\n\t#                 geometry.append(\n", "#                     mp.Block(\n\t#                         size=mp.Vector3(xspan, width, height),\n\t#                         material=material,\n\t#                         center=mp.Vector3(y=offset, z=height / 2 + zmin_um),\n\t#                     )\n\t#                 )\n\t#     return geometry\n\tif __name__ == \"__main__\":\n\t    import kplugins.gmeep as gm\n\t    import matplotlib.pyplot as plt\n", "    c = kf.components.taper_strip_to_ridge_trenches()\n\t    sp = gm.write_sparameters_meep(\n\t        c, run=False, ymargin_top=3, ymargin_bot=3, is_3d=True\n\t    )\n\t    plt.show()\n\t    # c.show(show_ports=True)\n"]}
{"filename": "kplugins/kmeep/meep_adjoint_optimization.py", "chunked_list": ["from __future__ import annotations\n\tfrom types import LambdaType\n\tfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\timport nlopt\n\timport numpy as np\n\tfrom meep import Block, EigenModeSource, MaterialGrid, Simulation, Vector3, Volume\n\tfrom meep.adjoint import DesignRegion, EigenmodeCoefficient, OptimizationProblem\n\tfrom meep.visualization import get_2D_dimensions\n\tfrom numpy import ndarray\n\timport kfactory as kf\n", "from kfactory import kdb\n\tfrom kfactory import KCell\n\tfrom kplugins.gmeep import get_simulation\n\tfrom kfactory.technology import LayerStack\n\tfrom kfactory.kcell import LayerEnum\n\timport kgeneric as kg\n\tdef get_meep_adjoint_optimizer(\n\t    cell: KCell,\n\t    objective_function: Callable,\n\t    design_regions: List[DesignRegion],\n", "    design_variables: List[MaterialGrid],\n\t    design_update: np.ndarray,\n\t    TE_mode_number: int = 1,\n\t    resolution: int = 30,\n\t    cell_size: Optional[Tuple] = None,\n\t    extend_ports_length: Optional[float] = 10.0,\n\t    layer_stack: Optional[LayerStack] = None,\n\t    zmargin_top: float = 3.0,\n\t    zmargin_bot: float = 3.0,\n\t    tpml: float = 1.5,\n", "    clad_material: str = \"SiO2\",\n\t    is_3d: bool = False,\n\t    wavelength_start: float = 1.5,\n\t    wavelength_stop: float = 1.6,\n\t    wavelength_points: int = 50,\n\t    dfcen: float = 0.2,\n\t    port_source_name: str = \"o1\",\n\t    port_margin: float = 3,\n\t    distance_source_to_monitors: float = 0.2,\n\t    port_source_offset: float = 0,\n", "    port_monitor_offset: float = 0,\n\t    dispersive: bool = False,\n\t    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n\t    **settings,\n\t):\n\t    \"\"\"Return a Meep `OptimizationProblem` object.\n\t    Args:\n\t        cell: kfactory cell.\n\t        objective_function: functions must be composed of \"field functions\" that transform the recorded fields.\n\t        design_regions: list of DesignRegion objects.\n", "        design_variables: list of MaterialGrid objects.\n\t        design_update: ndarray to initialize the optimization.\n\t        TE_mode_number: TE mode number.\n\t        resolution: in pixels/um (20: for coarse, 120: for fine).\n\t        cell_size: tuple of Simulation object dimensions in um.\n\t        extend_ports_length: to extend ports beyond the PML.\n\t        layer_stack: contains layer to thickness, zmin and material.\n\t            Defaults to active pdk.layer_stack.\n\t        zmargin_top: thickness for cladding above core.\n\t        zmargin_bot: thickness for cladding below core.\n", "        tpml: PML thickness (um).\n\t        clad_material: material for cladding.\n\t        is_3d: if True runs in 3D.\n\t        wavelength_start: wavelength min (um).\n\t        wavelength_stop: wavelength max (um).\n\t        wavelength_points: wavelength steps.\n\t        dfcen: delta frequency.\n\t        port_source_name: input port name.\n\t        port_margin: margin on each side of the port.\n\t        distance_source_to_monitors: in (um) source goes before.\n", "        port_source_offset: offset between source GDS port and source MEEP port.\n\t        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n\t        dispersive: use dispersive material models (requires higher resolution).\n\t        material_name_to_meep: map layer_stack names with meep material database name\n\t            or refractive index. dispersive materials have a wavelength dependent index.\n\t    Keyword Args:\n\t        settings: extra simulation settings (resolution, symmetries, etc.)\n\t    Returns:\n\t        opt: OptimizationProblem object\n\t    \"\"\"\n", "    sim_dict = get_simulation(\n\t        cell,\n\t        resolution=resolution,\n\t        extend_ports_length=extend_ports_length,\n\t        layer_stack=layer_stack,\n\t        zmargin_top=zmargin_top,\n\t        zmargin_bot=zmargin_bot,\n\t        tpml=tpml,\n\t        clad_material=clad_material,\n\t        is_3d=is_3d,\n", "        wavelength_start=wavelength_start,\n\t        wavelength_stop=wavelength_stop,\n\t        wavelength_points=wavelength_points,\n\t        dfcen=dfcen,\n\t        port_source_name=port_source_name,\n\t        port_margin=port_margin,\n\t        distance_source_to_monitors=distance_source_to_monitors,\n\t        port_source_offset=port_source_offset,\n\t        port_monitor_offset=port_monitor_offset,\n\t        dispersive=dispersive,\n", "        material_name_to_meep=material_name_to_meep,\n\t        **settings,\n\t    )\n\t    sim = sim_dict[\"sim\"]\n\t    design_regions_geoms = [\n\t        Block(\n\t            center=design_region.center,\n\t            size=design_region.size,\n\t            material=design_variable,\n\t        )\n", "        for design_region, design_variable in zip(design_regions, design_variables)\n\t    ]\n\t    for design_region_geom in design_regions_geoms:\n\t        sim.geometry.append(design_region_geom)\n\t    cell_thickness = sim.cell_size[2]\n\t    monitors = sim_dict[\"monitors\"]\n\t    ob_list = [\n\t        EigenmodeCoefficient(\n\t            sim,\n\t            Volume(\n", "                center=monitor.regions[0].center,\n\t                size=monitor.regions[0].size,\n\t            ),\n\t            TE_mode_number,\n\t        )\n\t        for monitor in monitors.values()\n\t    ]\n\t    for design_region, design_variable in zip(design_regions, design_variables):\n\t        sim.geometry.append(\n\t            Block(design_region.size, design_region.center, material=design_variable)\n", "        )\n\t        block = cell._kdb_cell.shapes(0).insert(kdb.DBox(\n\t                (design_region.size[0], design_region.size[1])\n\t            )\n\t        )\n\t        block = block.transformed(kdb.Trans(0, False, design_region.center[0] / cell.kcl.dbu, design_region.center[1] / cell.kcl.dbu))\n\t    sim.cell_size = (\n\t        Vector3(*cell_size)\n\t        if cell_size\n\t        else Vector3(\n", "            cell._kdb_cell.dbbox().width() + 2 * sim.boundary_layers[0].thickness,\n\t            cell._kdb_cell.dbbox().height() + 2 * sim.boundary_layers[0].thickness,\n\t            cell_thickness,\n\t        )\n\t    )\n\t    source = [\n\t        EigenModeSource(\n\t            sim.sources[0].src,\n\t            eig_band=1,\n\t            direction=sim.sources[0].direction,\n", "            eig_kpoint=Vector3(1, 0, 0),\n\t            size=sim.sources[0].size,\n\t            center=sim.sources[0].center,\n\t        )\n\t    ]\n\t    sim.sources = source\n\t    opt = OptimizationProblem(\n\t        simulation=sim,\n\t        objective_functions=[objective_function],\n\t        objective_arguments=ob_list,\n", "        design_regions=design_regions,\n\t        frequencies=sim_dict[\"freqs\"],\n\t        decay_by=settings.get(\"decay_by\", 1e-5),\n\t    )\n\t    opt.update_design([design_update])\n\t    opt.plot2D(True)\n\t    return opt\n\tdef run_meep_adjoint_optimizer(\n\t    number_of_params: int,\n\t    cost_function: LambdaType,\n", "    update_variable: np.ndarray,\n\t    maximize_cost_function: bool = True,\n\t    algorithm: int = nlopt.LD_MMA,\n\t    lower_bound: Any = 0,\n\t    upper_bound: Any = 1,\n\t    maxeval: int = 10,\n\t    get_optimized_component: bool = False,\n\t    opt: Optional[OptimizationProblem] = None,\n\t    **kwargs,\n\t) -> Union[ndarray, KCell]:\n", "    \"\"\"Run adjoint optimization using Meep.\n\t    Args:\n\t        number_of_params: number of parameters to optimize (usually resolution_in_x * resolution_in_y).\n\t        cost_function: cost function to optimize.\n\t        update_variable: variable to update the optimization with.\n\t        maximize_cost_function: if True, maximize the cost function, else minimize it.\n\t        algorithm: nlopt algorithm to use (default: nlopt.LD_MMA).\n\t        lower_bound: lower bound for the optimization.\n\t        upper_bound: upper bound for the optimization.\n\t        maxeval: maximum number of evaluations.\n", "        get_optimized_component: if True, returns the optimized kfactory KCell.\n\t            If this is True, the Optimization object used for the optimization must be passed as an argument.\n\t        opt: OptimizationProblem object used for the optimization. Used only if get_optimized_component is True.\n\t    Keyword Args:\n\t        fcen: center frequency of the source.\n\t        upscale_factor: upscale factor for the optimization's grid.\n\t        threshold_offset_from_max: threshold offset from max eps value.\n\t        layer: layer to apply to the optimized cell.\n\t    \"\"\"\n\t    solver = nlopt.opt(algorithm, number_of_params)\n", "    solver.set_lower_bounds(lower_bound)\n\t    solver.set_upper_bounds(upper_bound)\n\t    if maximize_cost_function:\n\t        solver.set_max_objective(cost_function)\n\t    else:\n\t        solver.set_min_objective(cost_function)\n\t    solver.set_maxeval(maxeval)\n\t    update_variable[:] = solver.optimize(update_variable)\n\t    if get_optimized_component:\n\t        fcen = kwargs.get(\"fcen\", 1 / 1.55)\n", "        upscale_factor = kwargs.get(\"upscale_factor\", 2)\n\t        threshold_offset_from_max = kwargs.get(\"threshold_offset_from_max\", 0.01)\n\t        layer = kwargs.get(\"layer\", (1, 0))\n\t        return get_component_from_sim(\n\t            opt.sim, fcen, upscale_factor, threshold_offset_from_max, layer\n\t        )\n\t    return update_variable\n\tdef get_component_from_sim(\n\t    sim: Simulation,\n\t    fcen: float = 1 / 1.55,\n", "    upscale_factor: int = 2,\n\t    threshold_offset_from_max: float = 2.0,\n\t    layer: LayerEnum = 0,\n\t) -> KCell:\n\t    \"\"\"Get kfactory KCell from Meep Simulation object.\n\t    Args:\n\t        sim: Meep Simulation object.\n\t        fcen: center frequency of the source.\n\t        upscale_factor: upscale factor for the optimization's grid.\n\t        threshold_offset_from_max: threshold offset from max eps value.\n", "        layer: layer to apply to the optimized cell.\n\t    Returns:\n\t        kfactory KCell.\n\t    \"\"\"\n\t    grid_resolution = upscale_factor * sim.resolution\n\t    sim_center, sim_size = get_2D_dimensions(sim, output_plane=None)\n\t    xmin = sim_center.x - sim_size.x / 2\n\t    xmax = sim_center.x + sim_size.x / 2\n\t    ymin = sim_center.y - sim_size.y / 2\n\t    ymax = sim_center.y + sim_size.y / 2\n", "    Nx = int((xmax - xmin) * grid_resolution + 1)\n\t    Ny = int((ymax - ymin) * grid_resolution + 1)\n\t    xtics = np.linspace(xmin, xmax, Nx)\n\t    ytics = np.linspace(ymin, ymax, Ny)\n\t    ztics = np.array([sim_center.z])\n\t    eps_data = np.real(sim.get_epsilon_grid(xtics, ytics, ztics, frequency=fcen))\n\t    return kg.read.from_np(\n\t        eps_data,\n\t        nm_per_pixel=1e3 / grid_resolution,\n\t        layer=layer,\n", "        threshold=np.max(eps_data) - threshold_offset_from_max,\n\t    )\n\tdef _example_optim_geometry() -> KCell:\n\t    \"\"\"Dummy example of a cell to optimize.\"\"\"\n\t    from meep import Medium\n\t    design_region_width = 5\n\t    design_region_height = 4\n\t    resolution = 20\n\t    design_region_resolution = int(5 * resolution)\n\t    Nx = int(design_region_resolution * design_region_width)\n", "    Ny = int(design_region_resolution * design_region_height)\n\t    pml_size = 1.0\n\t    waveguide_length = 0.5\n\t    Sx = 2 * pml_size + 2 * waveguide_length + design_region_width\n\t    SiO2 = Medium(index=1.44)\n\t    Si = Medium(index=3.4)\n\t    design_variables = MaterialGrid(Vector3(Nx, Ny), SiO2, Si, grid_type=\"U_MEAN\")\n\t    design_region = DesignRegion(\n\t        design_variables,\n\t        volume=Volume(\n", "            center=Vector3(),\n\t            size=Vector3(design_region_width, design_region_height, 0),\n\t        ),\n\t    )\n\t    c = KCell(\"mmi1x2\")\n\t    arm_separation = 1.0\n\t    straight1 = c << kg.cells.waveguide(0.5, Sx / 2 + 1, 0)\n\t    straight1.move(straight1.ports[\"o2\"], (-design_region_width / 2.0, 0))\n\t    straight2 = c << kg.cells.waveguide(0.5, Sx / 2 + 1, 0)\n\t    straight2.move(\n", "        straight2.ports[\"o1\"], (design_region_width / 2.0, (arm_separation + 1.0) / 2.0)\n\t    )\n\t    straight3 = c << kg.cells.waveguide(0.5, Sx / 2 + 1, 0)\n\t    straight3.move(\n\t        straight3.ports[\"o1\"],\n\t        (design_region_width / 2.0, (-arm_separation - 1.0) / 2.0),\n\t    )\n\t    c.add_port(\"o1\", port=straight1.ports[\"o1\"])\n\t    c.add_port(\"o2\", port=straight2.ports[\"o2\"])\n\t    c.add_port(\"o3\", port=straight3.ports[\"o2\"])\n", "    return design_region, design_variables, c, Nx, Ny\n\tif __name__ == \"__main__\":\n\t    import autograd.numpy as npa\n\t    eta_i = 0.5\n\t    design_region, design_variables, c, Nx, Ny = _example_optim_geometry()\n\t    seed = 240\n\t    np.random.seed(seed)\n\t    x0 = np.random.rand(\n\t        Nx * Ny,\n\t    )\n", "    def J(source, top, bottom):\n\t        power = npa.abs(top / source) ** 2 + npa.abs(bottom / source) ** 2\n\t        return npa.mean(power)\n\t    opt = get_meep_adjoint_optimizer(\n\t        c,\n\t        J,\n\t        [design_region],\n\t        [design_variables],\n\t        x0,\n\t        cell_size=(15, 8),\n", "        extend_ports_length=0,\n\t        port_margin=0.75,\n\t        port_source_offset=-3.5,\n\t        port_monitor_offset=-3.5,\n\t    )\n\t    opt.plot2D(True)\n"]}
{"filename": "kplugins/kmeep/get_simulation.py", "chunked_list": ["\"\"\"Returns simulation from kcell.\"\"\"\n\tfrom __future__ import annotations\n\timport inspect\n\timport warnings\n\tfrom typing import Any, Dict, Optional, Union\n\timport meep as mp\n\timport numpy as np\n\timport kfactory as kf\n\timport kgeneric as kg\n\tfrom kfactory import KCell\n", "from kplugins.extensions import move_polar_rad_copy\n\tfrom kgeneric import pdk\n\tfrom kplugins.gmeep.get_material import get_material\n\tfrom kplugins.gmeep.get_meep_geometry import (\n\t    get_meep_geometry_from_component,\n\t)\n\tfrom kfactory.technology import LayerStack\n\tmp.verbosity(0)\n\tsig = inspect.signature(mp.Simulation)\n\tsettings_meep = set(sig.parameters.keys())\n", "def get_simulation(\n\t    kcell: KCell,\n\t    resolution: int = 30,\n\t    extend_ports_length: Optional[float] = 10.0,\n\t    layer_stack: Optional[LayerStack] = None,\n\t    zmargin_top: float = 3.0,\n\t    zmargin_bot: float = 3.0,\n\t    tpml: float = 1.5,\n\t    clad_material: str = \"SiO2\",\n\t    is_3d: bool = False,\n", "    wavelength_start: float = 1.5,\n\t    wavelength_stop: float = 1.6,\n\t    wavelength_points: int = 50,\n\t    dfcen: float = 0.2,\n\t    port_source_name: str = \"o1\",\n\t    port_margin: float = 3,\n\t    distance_source_to_monitors: float = 0.2,\n\t    port_source_offset: float = 0,\n\t    port_monitor_offset: float = 0,\n\t    dispersive: bool = False,\n", "    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n\t    **settings,\n\t) -> Dict[str, Any]:\n\t    r\"\"\"Returns Simulation dict from kfactory KCell.\n\t    based on meep directional coupler example\n\t    https://meep.readthedocs.io/en/latest/Python_Tutorials/GDSII_Import/\n\t    https://support.lumerical.com/hc/en-us/articles/360042095873-Metamaterial-S-parameter-extraction\n\t    .. code::\n\t         top view\n\t              ________________________________\n", "             |                               |\n\t             | xmargin_left                  | port_extension\n\t             |<------>          port_margin ||<-->\n\t          ___|___________          _________||___\n\t             |           \\        /          |\n\t             |            \\      /           |\n\t             |             ======            |\n\t             |            /      \\           |\n\t          ___|___________/        \\__________|___\n\t             |   |                 <-------->|\n", "             |   |ymargin_bot   xmargin_right|\n\t             |   |                           |\n\t             |___|___________________________|\n\t        side view\n\t              ________________________________\n\t             |                     |         |\n\t             |                     |         |\n\t             |                   zmargin_top |\n\t             |ymargin              |         |\n\t             |<---> _____         _|___      |\n", "             |     |     |       |     |     |\n\t             |     |     |       |     |     |\n\t             |     |_____|       |_____|     |\n\t             |       |                       |\n\t             |       |                       |\n\t             |       |zmargin_bot            |\n\t             |       |                       |\n\t             |_______|_______________________|\n\t    Args:\n\t        kcell: kfactory KCell.\n", "        resolution: in pixels/um (20: for coarse, 120: for fine).\n\t        extend_ports_length: to extend ports beyond the PML.\n\t        layer_stack: contains layer to thickness, zmin and material.\n\t            Defaults to active pdk.layer_stack.\n\t        zmargin_top: thickness for cladding above core.\n\t        zmargin_bot: thickness for cladding below core.\n\t        tpml: PML thickness (um).\n\t        clad_material: material for cladding.\n\t        is_3d: if True runs in 3D.\n\t        wavelength_start: wavelength min (um).\n", "        wavelength_stop: wavelength max (um).\n\t        wavelength_points: wavelength steps.\n\t        dfcen: delta frequency.\n\t        port_source_name: input port name.\n\t        port_margin: margin on each side of the port.\n\t        distance_source_to_monitors: in (um) source goes before.\n\t        port_source_offset: offset between source GDS port and source MEEP port.\n\t        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n\t        dispersive: use dispersive material models (requires higher resolution).\n\t        material_name_to_meep: map layer_stack names with meep material database name\n", "            or refractive index. dispersive materials have a wavelength dependent index.\n\t    Keyword Args:\n\t        settings: extra simulation settings (resolution, symmetries, etc.)\n\t    Returns:\n\t        simulation dict: sim, monitors, sources.\n\t    Make sure you review the simulation before you simulate a kcell\n\t    .. code::\n\t        import kfactory as gf\n\t        import kfactory.simulation.meep as gm\n\t        c = gf.components.bend_circular()\n", "        gm.write_sparameters_meep(c, run=False)\n\t    \"\"\"\n\t    for setting in settings:\n\t        if setting not in settings_meep:\n\t            raise ValueError(f\"{setting!r} not in {sorted(settings_meep)}\")\n\t    layer_stack = layer_stack or pdk.layer_stack\n\t    layer_to_thickness = layer_stack.get_layer_to_thickness()\n\t    c = KCell()\n\t    component_ref = c << kcell\n\t    wavelength = (wavelength_start + wavelength_stop) / 2\n", "    wavelengths = np.linspace(wavelength_start, wavelength_stop, wavelength_points)\n\t    port_names = list(component_ref.ports.copy().get_all_named().keys())\n\t    if port_source_name not in port_names:\n\t        warnings.warn(f\"port_source_name={port_source_name!r} not in {port_names}\")\n\t        port_source = component_ref.ports[0]\n\t        port_source_name = port_source.name\n\t        warnings.warn(f\"Selecting port_source_name={port_source_name!r} instead.\")\n\t    assert isinstance(\n\t        kcell, KCell\n\t    ), f\"kcell needs to be a gf.KCell, got Type {type(kcell)}\"\n", "    if \"port_extension\" in settings:\n\t        port_extension = settings[\"port_settings\"]\n\t    else:\n\t        port_extension = 10.0\n\t    cell_extended = KCell()\n\t    for port in kcell.ports:\n\t        cell_ref = cell_extended << kcell\n\t        width = port.width * kcell.kcl.dbu if isinstance(port.width, int) else 1\n\t        extension = cell_extended.create_inst(\n\t            kf.cells.waveguide.waveguide(width, port_extension, layer=port.layer)\n", "        )\n\t        extension.align(\"o2\", cell_ref, port.name)\n\t        output_port = extension.ports[\"o1\"]\n\t        cell_extended.add_port(extension.ports[\"o1\"], name=port.name)\n\t    cell_extended.show()\n\t    cell_extended.flatten()\n\t    # geometry_center = [component_extended.x, component_extended.y]\n\t    # geometry_center = [0, 0]\n\t    # print(geometry_center)\n\t    layers_thickness = [\n", "        layer_to_thickness[layer.layer, layer.datatype]\n\t        for layer in kcell.kcl.layer_infos()\n\t        if (layer.layer, layer.datatype) in layer_to_thickness\n\t    ]\n\t    if layers_thickness is None:\n\t        raise ValueError(\n\t            f\"KCell layers {kcell.layers} not in {layer_to_thickness.keys()}. \"\n\t            \"Did you passed the correct layer_stack?\"\n\t        )\n\t    t_core = max(layers_thickness)\n", "    cell_thickness = tpml + zmargin_bot + t_core + zmargin_top + tpml if is_3d else 0\n\t    cell_size = mp.Vector3(\n\t        kcell._kdb_cell.dbbox().width() + 2 * tpml,\n\t        kcell._kdb_cell.dbbox().height() + 2 * tpml,\n\t        cell_thickness,\n\t    )\n\t    geometry = get_meep_geometry_from_component(\n\t        kcell=cell_extended,\n\t        layer_stack=layer_stack,\n\t        material_name_to_meep=material_name_to_meep,\n", "        wavelength=wavelength,\n\t        is_3d=is_3d,\n\t        dispersive=dispersive,\n\t    )\n\t    freqs = 1 / wavelengths\n\t    fcen = np.mean(freqs)\n\t    frequency_width = dfcen * fcen\n\t    # Add source\n\t    port = component_ref.ports[port_source_name]\n\t    angle_rad = np.radians(port.orientation)\n", "    width = port.d.width + 2 * port_margin\n\t    size_x = width * abs(np.sin(angle_rad))\n\t    size_y = width * abs(np.cos(angle_rad))\n\t    size_x = 0 if size_x < 0.001 else size_x\n\t    size_y = 0 if size_y < 0.001 else size_y\n\t    size_z = cell_thickness - 2 * tpml if is_3d else 20\n\t    size = [size_x, size_y, size_z]\n\t    xy_shifted = move_polar_rad_copy(\n\t        np.array(port.center), angle=angle_rad, length=port_source_offset\n\t    )\n", "    center = xy_shifted.tolist() + [0]  # (x, y, z=0)\n\t    if np.isclose(port.orientation, 0):\n\t        direction = mp.X\n\t    elif np.isclose(port.orientation, 90):\n\t        direction = mp.Y\n\t    elif np.isclose(port.orientation, 180):\n\t        direction = mp.X\n\t    elif np.isclose(port.orientation, 270):\n\t        direction = mp.Y\n\t    else:\n", "        raise ValueError(\n\t            f\"Port source {port_source_name!r} orientation {port.orientation} \"\n\t            \"not 0, 90, 180, 270 degrees\"\n\t        )\n\t    sources = [\n\t        mp.EigenModeSource(\n\t            src=mp.GaussianSource(fcen, fwidth=frequency_width),\n\t            size=size,\n\t            center=center,\n\t            eig_band=1,\n", "            eig_parity=mp.NO_PARITY if is_3d else mp.EVEN_Y + mp.ODD_Z,\n\t            eig_match_freq=True,\n\t            eig_kpoint=-1 * mp.Vector3(x=1).rotate(mp.Vector3(z=1), angle_rad),\n\t            direction=direction,\n\t        )\n\t    ]\n\t    sim = mp.Simulation(\n\t        cell_size=cell_size,\n\t        boundary_layers=[mp.PML(tpml)],\n\t        sources=sources,\n", "        geometry=geometry,\n\t        default_material=get_material(\n\t            name=clad_material,\n\t            material_name_to_meep=material_name_to_meep,\n\t            wavelength=wavelength,\n\t        ),\n\t        resolution=resolution,\n\t        **settings,\n\t    )\n\t    # Add port monitors dict\n", "    monitors = {}\n\t    for port_name in component_ref.ports.keys():\n\t        port = component_ref.ports[port_name]\n\t        angle_rad = np.radians(port.orientation)\n\t        width = port.d.width + 2 * port_margin\n\t        size_x = width * abs(np.sin(angle_rad))\n\t        size_y = width * abs(np.cos(angle_rad))\n\t        size_x = 0 if size_x < 0.001 else size_x\n\t        size_y = 0 if size_y < 0.001 else size_y\n\t        size = mp.Vector3(size_x, size_y, size_z)\n", "        size = [size_x, size_y, size_z]\n\t        # if monitor has a source move monitor inwards\n\t        length = (\n\t            -distance_source_to_monitors + port_source_offset\n\t            if port_name == port_source_name\n\t            else port_monitor_offset\n\t        )\n\t        xy_shifted = move_polar_rad_copy(\n\t            np.array(port.center), angle=angle_rad, length=length\n\t        )\n", "        center = xy_shifted.tolist() + [0]  # (x, y, z=0)\n\t        m = sim.add_mode_monitor(freqs, mp.ModeRegion(center=center, size=size))\n\t        m.z = 0\n\t        monitors[port_name] = m\n\t    return dict(\n\t        sim=sim,\n\t        cell_size=cell_size,\n\t        freqs=freqs,\n\t        monitors=monitors,\n\t        sources=sources,\n", "        port_source_name=port_source_name,\n\t        initialized=False,\n\t    )\n\tsig = inspect.signature(get_simulation)\n\tsettings_get_simulation = set(sig.parameters.keys()).union(settings_meep)\n\tif __name__ == \"__main__\":\n\t    import matplotlib.pyplot as plt\n\t    c = kg.cells.bend_circular()\n\t    sim_dict = get_simulation(\n\t        c,\n", "        is_3d=False,\n\t        # resolution=50,\n\t        # port_source_offset=-0.1,\n\t        # port_field_monitor_offset=-0.1,\n\t        # port_margin=2.5,\n\t    )\n\t    sim = sim_dict[\"sim\"]\n\t    sim.plot2D()\n\t    plt.show()\n\t    # Plot monitor cross-section (is_3D needs to be True)\n", "    # sim.init_sim()\n\t    # eps_data = sim.get_epsilon()\n\t    # from mayavi import mlab\n\t    # s = mlab.contour3d(eps_data, colormap=\"YlGnBu\")\n\t    # mlab.show()\n\t    print(settings_get_simulation)\n"]}
{"filename": "kplugins/lumerical/write_sparameters_lumerical.py", "chunked_list": ["\"\"\"Write Sparameters with Lumerical FDTD.\"\"\"\n\tfrom __future__ import annotations\n\timport itertools\n\timport shutil\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Any, Dict, List, Optional\n\timport numpy as np\n\timport omegaconf  # TODO: remove omegaconf\n\timport kfactory as kf\n", "from kfactory.typings import CellSpec\n\tfrom kfactory.conf import logger\n\tfrom kfactory.pdk import LayerStack\n\tfrom kgeneric.pdk import LAYER_STACK\n\tfrom kplugins.get_sparameters_path import (\n\t    get_sparameters_path_lumerical as get_sparameters_path,\n\t)\n\tfrom kplugins.typings import PathType\n\tfrom kplugins.lumerical.simulation_settings import (\n\t    SIMULATION_SETTINGS_LUMERICAL_FDTD,\n", "    SimulationSettingsLumericalFdtd,\n\t)\n\trun_false_warning = \"\"\"\n\tYou have passed run=False to debug the simulation\n\trun=False returns the simulation session for you to debug and make sure it is correct\n\tTo compute the Sparameters you need to pass run=True\n\t\"\"\"\n\tdef set_material(session, structure: str, material: MaterialSpec) -> None:  # type: ignore\n\t    \"\"\"Sets the material of a structure.\n\t    Args:\n", "        session: lumerical session.\n\t        structure: name of the lumerical structure.\n\t        material: material spec, can be\n\t            a string from lumerical database materials.\n\t            a float or int, representing refractive index.\n\t            a complex for n, k materials.\n\t    \"\"\"\n\t    if isinstance(material, str):\n\t        session.setnamed(structure, \"material\", material)\n\t    elif isinstance(material, (int, float)):\n", "        session.setnamed(structure, \"index\", material)\n\t    elif isinstance(material, complex):\n\t        mat = session.addmaterial(\"(n,k) Material\")\n\t        session.setmaterial(mat, \"Refractive Index\", material.real)\n\t        session.setmaterial(mat, \"Imaginary Refractive Index\", material.imag)\n\t        session.setnamed(structure, \"material\", mat)\n\t    elif isinstance(material, (tuple, list)):\n\t        if len(material) != 2:\n\t            raise ValueError(\n\t                \"Complex material requires a tuple or list of two numbers \"\n", "                f\"(real, imag). Got {material} \"\n\t            )\n\t        real, imag = material\n\t        mat = session.addmaterial(\"(n,k) Material\")\n\t        session.setmaterial(mat, \"Refractive Index\", real)\n\t        session.setmaterial(mat, \"Imaginary Refractive Index\", imag)\n\t        session.setnamed(structure, \"material\", mat)\n\t    else:\n\t        raise ValueError(\n\t            f\"{material!r} needs to be a float refractive index, a complex number or tuple \"\n", "            \"or a string from lumerical's material database\"\n\t        )\n\t    return None\n\tdef plot_sparameters_lumerical(\n\t    cell: kf.KCell,\n\t    layer_stack: LayerStack = LAYER_STACK,\n\t    session: Optional[object] = None,\n\t    run: bool = True,\n\t    overwrite: bool = False,\n\t    dirpath: Optional[PathType] = None,\n", "    simulation_settings: SimulationSettingsLumericalFdtd = SIMULATION_SETTINGS_LUMERICAL_FDTD,\n\t    material_name_to_lumerical: Optional[Dict[str, MaterialSpec]] = None,\n\t    delete_fsp_files: bool = True,\n\t    solver: str = \"FDTD\",\n\t    input_port: str = \"o1\",\n\t    output_port: str = \"o2\",\n\t    **settings: Any,\n\t) -> str:\n\t    \"\"\"Plots and returns cell s-parameters using Lumerical INTERCONNECT.\n\t    If simulation exists it returns the Sparameters directly unless overwrite=True\n", "    which forces a re-run of the simulation\n\t    Writes s-parameters in both .npz and .csv format.\n\t    In the npz format you can see `S12m` where `m` stands for magnitude\n\t    and `S12a` where `a` stands for angle in radians\n\t    Your cells need to have ports, that will extend over the PML.\n\t    For your Fab technology you can overwrite\n\t    - simulation_settings\n\t    - dirpath\n\t    - layerStack\n\t    converts kfactory units (um) to Lumerical units (m)\n", "    Disclaimer: This function tries to extract Sparameters automatically\n\t    is hard to make a function that will fit all your possible simulation settings.\n\t    You can use this function for inspiration to create your own.\n\t    Args:\n\t        cell: kfactory cell\n\t        layer_stack: kfactory layer stack\n\t        session: lumerical session\n\t        run: if True runs the simulation\n\t        overwrite: if True overwrites the simulation\n\t        dirpath: directory where to write the simulation files\n", "        simulation_settings: simulation settings\n\t        material_name_to_lumerical: dictionary with material names\n\t        delete_fsp_files: if True deletes the .fsp files\n\t        solver: FDTD or MODE\n\t        settings: simulation settings\n\t    Returns:\n\t        result file path\n\t    \"\"\"\n\t    s_params: List[np.ndarray[str, np.dtype[Any]]] = []\n\t    insts = []\n", "    trans = []\n\t    cell = kf.get_cell(cell)\n\t    def recurse_insts(comp: kf.KCell, p=None):  # type: ignore\n\t        if p:\n\t            comp.transform(p)\n\t        for inst in comp.insts:\n\t            if inst.trans in trans:\n\t                continue\n\t            if inst.cell.name == cell.name:\n\t                continue\n", "            if len(inst.cell.insts) > 0:\n\t                if \"sim\" in inst.cell.info:\n\t                    trans.append(inst.trans)\n\t                    insts.append(inst)\n\t                    continue\n\t                recurse_insts(inst.cell.dup(), inst.instance.trans)\n\t            else:\n\t                insts.append(inst)\n\t                trans.append(inst.trans)\n\t    if \"sim\" not in cell.info and \"sparameters\" not in cell.info:\n", "        recurse_insts(cell)\n\t    paths: dict[str, Path] = {}\n\t    for inst in insts:\n\t        # paths = {}\n\t        cell_ = inst.cell\n\t        if not overwrite:\n\t            if \"sparameters\" in cell_.info:\n\t                path = Path(cell_.info[\"sparameters\"])\n\t                if path.exists():\n\t                    s_params.append(path)  # type: ignore\n", "                    paths[cell_.name] = path\n\t                    continue\n\t            if \"cells\" in cell_.info:\n\t                paths = {}\n\t                for cell2 in cell_.info[\"cells\"]:\n\t                    settings_ = cell_.info[\"cells\"][cell2]\n\t                    cell_2 = kf.get_cell(settings_[\"cell\"], **settings_[\"params\"])\n\t                    path = get_sparameters_path(\n\t                        cell_2,\n\t                        dirpath=dirpath,\n", "                        layer_stack=layer_stack or LAYER_STACK,\n\t                        **settings,\n\t                    )\n\t                    if overwrite or not path.exists():\n\t                        try:\n\t                            cell_solver = cell_.info[\"cells\"][cell2][\"sim\"]\n\t                        except KeyError:\n\t                            cell_solver = solver\n\t                        s_params.append(\n\t                            write_sparameters_lumerical(\n", "                                cell=cell_2,\n\t                                layer_stack=layer_stack,\n\t                                session=session,\n\t                                run=run,\n\t                                overwrite=overwrite,\n\t                                dirpath=dirpath,\n\t                                simulation_settings=simulation_settings,\n\t                                material_name_to_lumerical=material_name_to_lumerical,\n\t                                delete_fsp_files=delete_fsp_files,\n\t                                solver=cell_solver,\n", "                                **settings,\n\t                            )\n\t                        )\n\t                    paths[cell_2.name] = path\n\t            else:\n\t                print(\"Simulation exists\", cell_.name)\n\t                path = get_sparameters_path(\n\t                    cell_,\n\t                    dirpath=dirpath,\n\t                    layer_stack=layer_stack or LAYER_STACK,\n", "                    **settings,\n\t                )\n\t                if path.exists():\n\t                    s_params.append(np.load(path))\n\t                    paths[cell_.name] = path\n\t                else:\n\t                    s_params.append(\n\t                        write_sparameters_lumerical(\n\t                            cell=cell_,\n\t                            layer_stack=layer_stack,\n", "                            session=session,\n\t                            run=run,\n\t                            overwrite=overwrite,\n\t                            dirpath=dirpath,\n\t                            simulation_settings=simulation_settings,\n\t                            material_name_to_lumerical=material_name_to_lumerical,\n\t                            delete_fsp_files=delete_fsp_files,\n\t                            solver=solver,\n\t                            **settings,\n\t                        )\n", "                    )\n\t                paths[cell_.name] = path\n\t        else:\n\t            s_params.append(\n\t                write_sparameters_lumerical(\n\t                    cell=cell_,\n\t                    layer_stack=layer_stack,\n\t                    session=session,\n\t                    run=run,\n\t                    overwrite=overwrite,\n", "                    dirpath=dirpath,\n\t                    simulation_settings=simulation_settings,\n\t                    material_name_to_lumerical=material_name_to_lumerical,\n\t                    delete_fsp_files=delete_fsp_files,\n\t                    solver=solver,\n\t                    **settings,\n\t                )\n\t            )\n\t            paths[cell_.name] = get_sparameters_path(\n\t                cell_,\n", "                dirpath=dirpath,\n\t                layer_stack=layer_stack or LAYER_STACK,\n\t                **settings,\n\t            )\n\t    if len(s_params) > 1:\n\t        try:\n\t            import sys\n\t            sys.path.append(\"C:\\\\Program Files\\\\Lumerical\\\\v231\\\\api\\\\python\\\\\")\n\t            import lumapi  # type: ignore\n\t        except ModuleNotFoundError as e:\n", "            print(\n\t                \"Cannot import lumapi (Python Lumerical API). \"\n\t                \"You can add set the PYTHONPATH variable or add it with `sys.path.append()`\"\n\t            )\n\t            raise e\n\t        except OSError as e:\n\t            raise e\n\t        s = lumapi.INTERCONNECT()\n\t        s.switchtodesign()\n\t        s.clear()\n", "        s.deleteall()\n\t        s.addelement(\"Optical Network Analyzer\")\n\t        s.set(\"name\", \"ONA\")\n\t        s.set(\"number of input ports\", len(cell.ports._ports) - 1)\n\t        s.set(\"input parameter\", 2)\n\t        s.set(\"start frequency\", 3e8 / simulation_settings.wavelength_stop / 1e-6)\n\t        s.set(\"stop frequency\", 3e8 / simulation_settings.wavelength_start / 1e-6)\n\t        s.set(\"number of points\", simulation_settings.wavelength_points)\n\t        cells: dict[tuple[float, float], Any] = {}\n\t        for instance in insts:\n", "            for port in instance.ports:\n\t                if port.d.position in cells:\n\t                    cells[port.d.position].update(\n\t                        {port: port.name, \"instance2\": instance}\n\t                    )\n\t                else:\n\t                    cells[port.d.position] = {port: port.name, \"instance1\": instance}\n\t        inputs: List[Any] = []\n\t        input = input_port\n\t        outputs: List[Any] = []\n", "        output = output_port\n\t        for value in cells.values():\n\t            inv_comp = False\n\t            instances = (\n\t                [value[\"instance1\"], value[\"instance2\"]]\n\t                if \"instance2\" in value\n\t                else [value[\"instance1\"]]\n\t            )\n\t            for i, instance in enumerate(instances):\n\t                if instance.cell.name not in paths:\n", "                    value[f\"instance{i+1}\"] = None\n\t                    for key, val in value.items():\n\t                        if key in instance.ports:\n\t                            value[key] = None\n\t                            value.pop(key)\n\t                    inv_comp = True\n\t                    instances.remove(instance)\n\t                    continue\n\t                if paths[instance.cell.name].with_suffix(\".ldf\").exists():\n\t                    s.addelement(\"MODE Waveguide\")\n", "                    s.setnamed(f\"WGD_1\", \"name\", f\"{instance.cell.name, instance.hash}\")\n\t                    s.setnamed(\n\t                        f\"{instance.cell.name, instance.hash}\", \"load from file\", True\n\t                    )\n\t                    s.setnamed(\n\t                        f\"{instance.cell.name, instance.hash}\",\n\t                        \"mode filename\",\n\t                        paths[instance.cell.name].with_suffix(\".ldf\").as_posix(),\n\t                    )\n\t                else:\n", "                    s.addelement(\"Optical N Port S-Parameter\")\n\t                    s.setnamed(\n\t                        f\"SPAR_1\", \"name\", f\"{instance.cell.name, instance.hash}\"\n\t                    )\n\t                    s.setnamed(\n\t                        f\"{instance.cell.name, instance.hash}\", \"load from file\", True\n\t                    )\n\t                    filepath_cell = get_sparameters_path(\n\t                        instance,\n\t                        dirpath=dirpath,\n", "                        simulation_settings=simulation_settings,\n\t                    )\n\t                    s.setnamed(\n\t                        f\"{instance.cell.name, instance.hash}\",\n\t                        \"s parameters filename\",\n\t                        paths[instance.cell.name].as_posix().replace(\".npz\", \".dat\"),\n\t                    )\n\t                s.setnamed(\n\t                    f\"{instance.cell.name, instance.hash}\",\n\t                    \"x position\",\n", "                    instance.instance.dbbox().center().x * 100,\n\t                )\n\t                s.setnamed(\n\t                    f\"{instance.cell.name, instance.hash}\",\n\t                    \"y position\",\n\t                    instance.instance.dbbox().center().y * 100,\n\t                )\n\t            if inv_comp:\n\t                continue\n\t            ports = [\n", "                value[port]\n\t                for port in value\n\t                if port is not None and port != \"instance1\" and port != \"instance2\"\n\t            ]\n\t            ports_ = [\n\t                port\n\t                for port in value\n\t                if port is not None and port != \"instance1\" and port != \"instance2\"\n\t            ]\n\t            # ports.remove(None) if None in ports else None\n", "            if len(ports) > 1 and ports[1] not in [p.name for p in instances[1].ports]:\n\t                ports = ports[::-1]\n\t            # if \"cells\" in cell.info:\n\t            # for cell_ in cell.info[\"cells\"]:\n\t            #     cell__ = cell.info[\"cells\"][cell_][\"cell\"]\n\t            #     settings__ = cell.info[\"cells\"][cell_][\"params\"]\n\t            #     print(kf.get_cell(cell__, **settings__).name)\n\t            if len(instances) == 2:\n\t                s.connect(\n\t                    f\"{instances[0].cell.name, instances[0].hash}\",\n", "                    ports[0],\n\t                    f\"{instances[1].cell.name, instances[1].hash}\",\n\t                    ports[1],\n\t                )\n\t            else:\n\t                print(cell.ports, value)\n\t                input_port = (\n\t                    ports[0]\n\t                    if input_port in cell.ports.get_all_named().keys()\n\t                    and ports_[0].d.position == cell.ports[input_port].d.position\n", "                    else input\n\t                )\n\t                output_port = (\n\t                    ports[0]\n\t                    if output_port in cell.ports.get_all_named().keys()\n\t                    and ports_[0].d.position == cell.ports[output_port].d.position\n\t                    else output\n\t                )\n\t                inputs = [instances[0], input_port] if input != input_port else inputs\n\t                outputs = (\n", "                    [instances[0], output_port] if output != output_port else outputs\n\t                )\n\t        s.connect(\n\t            \"ONA\",\n\t            f\"input 1\",\n\t            f\"{inputs[0].cell.name, inputs[0].hash}\",\n\t            f\"{inputs[1]}\",\n\t        )\n\t        path3 = get_sparameters_path(\n\t            cell, dirpath=dirpath, simulation_settings=simulation_settings\n", "        )\n\t        s.save(path3.as_posix().replace(\".npz\", \".ice\"))\n\t        s.connect(\n\t            \"ONA\",\n\t            \"output\",\n\t            f\"{outputs[0].cell.name, outputs[0].hash}\",\n\t            f\"{outputs[1]}\",\n\t        )\n\t        s.run()\n\t        s.save(path3.as_posix().replace(\".npz\", \".ice\"))\n", "        s.exportcsvresults(path3.as_posix().replace(\".npz\", \".csv\"))\n\t        return path3.as_posix().replace(\".npz\", \"/ONA.csv\")\n\tdef write_sparameters_lumerical(\n\t    cell: CellSpec,\n\t    layer_stack: LayerStack = LAYER_STACK,\n\t    session: Optional[object] = None,\n\t    run: bool = True,\n\t    overwrite: bool = False,\n\t    dirpath: Optional[PathType] = None,\n\t    simulation_settings: SimulationSettingsLumericalFdtd = SIMULATION_SETTINGS_LUMERICAL_FDTD,\n", "    material_name_to_lumerical: Optional[Dict[str, MaterialSpec]] = None,\n\t    delete_fsp_files: bool = True,\n\t    solver: str = \"FDTD\",\n\t    **settings: Any,\n\t) -> np.ndarray[str, np.dtype[Any]] | Any:\n\t    r\"\"\"Returns and writes cell Sparameters using Lumerical FDTD.\n\t    If simulation exists it returns the Sparameters directly unless overwrite=True\n\t    which forces a re-run of the simulation\n\t    Writes Sparameters both in .npz and .DAT (interconnect format) as well as\n\t    simulation settings in .YAML\n", "    In the npz format you can see `S12m` where `m` stands for magnitude\n\t    and `S12a` where `a` stands for angle in radians\n\t    Your cells need to have ports, that will extend over the PML.\n\t    .. image:: https://i.imgur.com/dHAzZRw.png\n\t    For your Fab technology you can overwrite\n\t    - simulation_settings\n\t    - dirpath\n\t    - layerStack\n\t    converts kfactory units (um) to Lumerical units (m)\n\t    Disclaimer: This function tries to extract Sparameters automatically\n", "    is hard to make a function that will fit all your possible simulation settings.\n\t    You can use this function for inspiration to create your own.\n\t    TODO:\n\t        mode_selection\n\t    Args:\n\t        cell: cell to simulate.\n\t        session: you can pass a session=lumapi.FDTD() or it will create one.\n\t        run: True runs Lumerical, False only draws simulation.\n\t        overwrite: run even if simulation results already exists.\n\t        dirpath: directory to store sparameters in npz.\n", "            Defaults to active Pdk.sparameters_path.\n\t        layer_stack: contains layer to thickness, zmin and material.\n\t            Defaults to active pdk.layer_stack.\n\t        simulation_settings: dataclass with all simulation_settings.\n\t        material_name_to_lumerical: alias to lumerical material's database name\n\t            or refractive index.\n\t            translate material name in LayerStack to lumerical's database name.\n\t        delete_fsp_files: deletes lumerical fsp files after simulation.\n\t    Keyword Args:\n\t        background_material: for the background.\n", "        port_margin: on both sides of the port width (um).\n\t        port_height: port height (um).\n\t        port_extension: port extension (um).\n\t        mesh_accuracy: 2 (1: coarse, 2: fine, 3: superfine).\n\t        zmargin: for the FDTD region (um).\n\t        ymargin: for the FDTD region (um).\n\t        xmargin: for the FDTD region (um).\n\t        wavelength_start: 1.2 (um).\n\t        wavelength_stop: 1.6 (um).\n\t        wavelength_points: 500.\n", "        simulation_time: (s) related to max path length 3e8/2.4*10e-12*1e6 = 1.25mm.\n\t        simulation_temperature: in kelvin (default = 300).\n\t        frequency_dependent_profile: computes mode profiles for different wavelengths.\n\t        field_profile_samples: number of wavelengths to compute field profile.\n\t    .. code::\n\t         top view\n\t              ________________________________\n\t             |                               |\n\t             | xmargin                       | port_extension\n\t             |<------>          port_margin ||<-->\n", "          o2_|___________          _________||_o3\n\t             |           \\        /          |\n\t             |            \\      /           |\n\t             |             ======            |\n\t             |            /      \\           |\n\t          o1_|___________/        \\__________|_o4\n\t             |   |                           |\n\t             |   |ymargin                    |\n\t             |   |                           |\n\t             |___|___________________________|\n", "        side view\n\t              ________________________________\n\t             |                               |\n\t             |                               |\n\t             |                               |\n\t             |ymargin                        |\n\t             |<---> _____         _____      |\n\t             |     |     |       |     |     |\n\t             |     |     |       |     |     |\n\t             |     |_____|       |_____|     |\n", "             |       |                       |\n\t             |       |                       |\n\t             |       |zmargin                |\n\t             |       |                       |\n\t             |_______|_______________________|\n\t    Return:\n\t        Sparameters np.ndarray (wavelengths, o1@0,o1@0, o1@0,o2@0 ...)\n\t            suffix `a` for angle in radians and `m` for module.\n\t    \"\"\"\n\t    s_params = []\n", "    insts = []\n\t    trans = []\n\t    # cell = kf.get_cell(cell)\n\t    def recurse_insts(comp: Any, p=None):  # type: ignore\n\t        if p:\n\t            comp.transform(p)\n\t        for inst in comp.insts:\n\t            if inst.trans in trans:\n\t                continue\n\t            if inst.cell.name == cell.name:  # type: ignore\n", "                continue\n\t            if len(inst.cell.insts) > 0:\n\t                if \"sim\" in inst.cell.info:\n\t                    trans.append(inst.trans)\n\t                    insts.append(inst)\n\t                    continue\n\t                recurse_insts(inst.cell.dup(), inst.instance.trans)\n\t            else:\n\t                insts.append(inst)\n\t                trans.append(inst.trans)\n", "    if \"sim\" not in cell.info:\n\t        recurse_insts(cell)\n\t    paths: dict[str, Path] = {}\n\t    for inst in insts:\n\t        cell_ = inst.cell\n\t        # paths = {}\n\t        if not overwrite:\n\t            if \"cells\" in cell_.info:\n\t                paths = {}\n\t                for cell2 in cell_.info[\"cells\"]:\n", "                    settings_ = cell_.info[\"cells\"][cell2]\n\t                    cell_2 = kf.get_cell(settings_[\"cell\"], **settings_[\"params\"])\n\t                    path = get_sparameters_path(\n\t                        cell_2,\n\t                        dirpath=dirpath,\n\t                        layer_stack=layer_stack or LAYER_STACK,\n\t                        **settings,\n\t                    )\n\t                    if overwrite or not path.exists():\n\t                        try:\n", "                            cell_solver = cell_.info[\"cells\"][cell2][\"sim\"]\n\t                        except KeyError:\n\t                            cell_solver = solver\n\t                        s_params.append(\n\t                            write_sparameters_lumerical(\n\t                                cell=cell_2,\n\t                                layer_stack=layer_stack,\n\t                                session=session,\n\t                                run=run,\n\t                                overwrite=overwrite,\n", "                                dirpath=dirpath,\n\t                                simulation_settings=simulation_settings,\n\t                                material_name_to_lumerical=material_name_to_lumerical,\n\t                                delete_fsp_files=delete_fsp_files,\n\t                                solver=cell_solver,\n\t                                **settings,\n\t                            )\n\t                        )\n\t                    paths[cell_2.name] = path\n\t            else:\n", "                path = get_sparameters_path(\n\t                    cell_,\n\t                    dirpath=dirpath,\n\t                    layer_stack=layer_stack or LAYER_STACK,\n\t                    **settings,\n\t                )\n\t                if path.exists():\n\t                    # s_params.append(np.ndarray(np.load(path)))\n\t                    paths[cell_.name] = path\n\t                else:\n", "                    s_params.append(\n\t                        write_sparameters_lumerical(\n\t                            cell=cell_,\n\t                            layer_stack=layer_stack,\n\t                            session=session,\n\t                            run=run,\n\t                            overwrite=overwrite,\n\t                            dirpath=dirpath,\n\t                            simulation_settings=simulation_settings,\n\t                            material_name_to_lumerical=material_name_to_lumerical,\n", "                            delete_fsp_files=delete_fsp_files,\n\t                            solver=solver,\n\t                            **settings,\n\t                        )\n\t                    )\n\t                paths[cell_.name] = path\n\t        else:\n\t            s_params.append(\n\t                write_sparameters_lumerical(\n\t                    cell=cell_,\n", "                    layer_stack=layer_stack,\n\t                    session=session,\n\t                    run=run,\n\t                    overwrite=overwrite,\n\t                    dirpath=dirpath,\n\t                    simulation_settings=simulation_settings,\n\t                    material_name_to_lumerical=material_name_to_lumerical,\n\t                    delete_fsp_files=delete_fsp_files,\n\t                    solver=solver,\n\t                    **settings,\n", "                )\n\t            )\n\t            paths[cell_.name] = get_sparameters_path(\n\t                cell_,\n\t                dirpath=dirpath,\n\t                layer_stack=layer_stack or LAYER_STACK,\n\t                **settings,\n\t            )\n\t    sim_settings = dict(simulation_settings)\n\t    layer_stack = layer_stack or LAYER_STACK\n", "    layer_to_thickness = layer_stack.get_layer_to_thickness()\n\t    layer_to_zmin = layer_stack.get_layer_to_zmin()\n\t    layer_to_material = layer_stack.get_layer_to_material()\n\t    if hasattr(cell.info, \"simulation_settings\"):\n\t        sim_settings.update(cell.info.simulation_settings)\n\t        logger.info(f\"Updating {cell.name!r} sim settings {cell.simulation_settings}\")\n\t    for setting in settings:\n\t        if setting not in sim_settings:\n\t            raise ValueError(\n\t                f\"Invalid setting {setting!r} not in ({list(sim_settings.keys())})\"\n", "            )\n\t    sim_settings.update(**settings)\n\t    ss = SimulationSettingsLumericalFdtd(**sim_settings)\n\t    cell_extended = kf.KCell()\n\t    for port in cell.ports:\n\t        cell_ref = cell_extended << cell\n\t        width = port.width * cell.kcl.dbu if isinstance(port.width, int) else 1\n\t        extension = cell_extended.create_inst(\n\t            kf.cells.waveguide.waveguide(width, ss.port_extension, layer=port.layer)\n\t        )\n", "        extension.align(\"o2\", cell_ref, port.name)\n\t        output_port = extension.ports[\"o1\"]\n\t        cell_extended.add_port(extension.ports[\"o1\"], name=port.name)\n\t    # ports = cell_extended.get_ports_list(port_type=\"optical\")\n\t    # if not ports:\n\t    #     raise ValueError(f\"{cell.name!r} does not have any optical ports\")\n\t    # cell.remove_layers(cell.layers - set(layer_to_thickness.keys()))\n\t    # cell._bb_valid = False\n\t    cell_extended.flatten()\n\t    cell_extended.name = \"top\"\n", "    # cell.flatten()\n\t    cell_extended.draw_ports()\n\t    solver = cell.info[\"sim\"] if \"sim\" in cell.info else solver\n\t    filepath_npz = get_sparameters_path(\n\t        cell=cell,\n\t        dirpath=dirpath,\n\t        layer_stack=layer_stack,\n\t        **settings,\n\t    )\n\t    cell_extended.write(filepath_npz.with_suffix(\".gds\"))\n", "    gdspath = filepath_npz.with_suffix(\".gds\")\n\t    filepath = filepath_npz.with_suffix(\".dat\")\n\t    filepath_sim_settings = filepath.with_suffix(\".yml\")\n\t    filepath_fsp = filepath.with_suffix(\".fsp\")\n\t    fspdir = filepath.parent / f\"{filepath.stem}_s-parametersweep\"\n\t    if run and filepath_npz.exists() and not overwrite:\n\t        logger.info(f\"Reading Sparameters from {filepath_npz}\")\n\t        return np.ndarray(np.load(filepath_npz))\n\t    if not run and session is None:\n\t        print(run_false_warning)\n", "    logger.info(f\"Writing Sparameters to {filepath_npz}\")\n\t    xmin = cell.dbbox().left\n\t    xmax = cell.dbbox().right\n\t    ymin = cell.dbbox().bottom\n\t    ymax = cell.dbbox().top\n\t    x_min = (xmin - ss.xmargin) * 1e-6\n\t    x_max = (xmax + ss.xmargin) * 1e-6\n\t    y_min = (ymin - ss.ymargin) * 1e-6\n\t    y_max = (ymax + ss.ymargin) * 1e-6\n\t    # layers_thickness = [\n", "    #     layer_to_thickness[layer]\n\t    #     for layer in cell.get_layers()\n\t    #     if layer in layer_to_thickness\n\t    # ]\n\t    # if not layers_thickness:\n\t    #     raise ValueError(\n\t    #         f\"no layers for cell {cell.get_layers()}\"\n\t    #         f\"in layer stack {layer_stack}\"\n\t    #     )\n\t    # layers_zmin = [\n", "    #     layer_to_zmin[layer]\n\t    #     for layer in cell.get_layers()\n\t    #     if layer in layer_to_zmin\n\t    # ]\n\t    # cell_thickness = max(layers_thickness)\n\t    # cell_zmin = min(layers_zmin)\n\t    # z = (cell_zmin + cell_thickness) / 2 * 1e-6\n\t    z = 0.0\n\t    z_span = 1e-6\n\t    x_span = x_max - x_min\n", "    y_span = y_max - y_min\n\t    # layers = cell.get_layers()\n\t    sim_settings.update(dict(layer_stack=layer_stack.to_dict()))\n\t    # sim_settings = dict(\n\t    #     simulation_settings=sim_settings,\n\t    #     cell=cell.to_dict(),\n\t    #     # version=__version__,\n\t    # )\n\t    logger.info(\n\t        f\"Simulation size = {x_span*1e6:.3f}, {y_span*1e6:.3f}, {z_span*1e6:.3f} um\"\n", "    )\n\t    # from pprint import pprint\n\t    # filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n\t    # print(filepath_sim_settings)\n\t    # pprint(sim_settings)\n\t    # return\n\t    try:\n\t        import sys\n\t        sys.path.append(\"C:\\\\Program Files\\\\Lumerical\\\\v231\\\\api\\\\python\\\\\")\n\t        import lumapi\n", "    except ModuleNotFoundError as e:\n\t        print(\n\t            \"Cannot import lumapi (Python Lumerical API). \"\n\t            \"You can add set the PYTHONPATH variable or add it with `sys.path.append()`\"\n\t        )\n\t        raise e\n\t    except OSError as e:\n\t        raise e\n\t    start = time.time()\n\t    s = (\n", "        session or lumapi.FDTD(hide=False)\n\t        if solver == \"FDTD\"\n\t        else lumapi.MODE(hide=False)\n\t    )\n\t    s.newproject()\n\t    s.selectall()\n\t    s.deleteall()\n\t    s.addrect(\n\t        x_min=x_min,\n\t        x_max=x_max,\n", "        y_min=y_min,\n\t        y_max=y_max,\n\t        z=z,\n\t        z_span=z_span,\n\t        index=1.5,\n\t        name=\"clad\",\n\t    )\n\t    material_name_to_lumerical_new = material_name_to_lumerical or {}\n\t    material_name_to_lumerical = ss.material_name_to_lumerical.copy()\n\t    material_name_to_lumerical.update(**material_name_to_lumerical_new)\n", "    material = (\n\t        material_name_to_lumerical[ss.background_material] if solver == \"FDTD\" else None\n\t    )\n\t    set_material(\n\t        session=s, structure=\"clad\", material=material\n\t    ) if solver == \"FDTD\" and material is not None else None\n\t    s.addfdtd(\n\t        dimension=\"3D\",\n\t        x_min=x_min,\n\t        x_max=x_max,\n", "        y_min=y_min,\n\t        y_max=y_max,\n\t        z=z,\n\t        z_span=z_span,\n\t        mesh_accuracy=ss.mesh_accuracy,\n\t        use_early_shutoff=True,\n\t        simulation_time=ss.simulation_time,\n\t        simulation_temperature=ss.simulation_temperature,\n\t    ) if solver == \"FDTD\" else s.addeme(\n\t        solver_type=\"2D XY plane: X prop\",\n", "        x_min=x_min,\n\t        group_spans=x_span,\n\t        y_min=y_min,\n\t        y_max=y_max,\n\t        z=z,\n\t        # z_span=z_span,\n\t        # mesh_accuracy=ss.mesh_accuracy,\n\t        # use_early_shutoff=True,\n\t        simulation_temperature=ss.simulation_temperature,\n\t    )\n", "    for layer, level in layer_stack.layers.items():\n\t        material_name = layer_to_material[level.layer]\n\t        if material_name not in material_name_to_lumerical:\n\t            continue\n\t        material = material_name_to_lumerical[material_name]\n\t        zmin = layer_to_zmin[level.layer]\n\t        thickness = layer_to_thickness[level.layer]\n\t        zmax = zmin + thickness\n\t        z = (zmax + zmin) / 2\n\t        path = gdspath\n", "        try:\n\t            s.gdsimport(str(path), \"top\", f\"{level.layer[0]}:{level.layer[1]}\")\n\t        except Exception as e:\n\t            continue\n\t        layername = f\"GDS_LAYER_{level.layer[0]}:{level.layer[1]}\"\n\t        s.setnamed(layername, \"z\", z * 1e-6)\n\t        s.setnamed(layername, \"z span\", thickness * 1e-6)\n\t        set_material(session=s, structure=layername, material=material)\n\t        logger.info(f\"adding {layer}, thickness = {thickness} um, zmin = {zmin} um \")\n\t    s.deletesweep(\"s-parameter sweep\")\n", "    if solver == \"MODE\":\n\t        for i in range(2):\n\t            s.select(\"EME::Ports::port_1\")\n\t            s.delete()\n\t    for i, port in enumerate(cell.ports):\n\t        from kgeneric import pdk\n\t        zmin = layer_to_zmin[(1, 0)]  # type: ignore\n\t        thickness = layer_to_thickness[(1, 0)]  # type: ignore\n\t        z = (zmin + thickness) / 2\n\t        zspan = 2 * ss.port_margin + thickness\n", "        if solver == \"FDTD\":\n\t            s.addport()\n\t        elif solver == \"MODE\" and i != 0:\n\t            s.addemeport()\n\t        s.setnamed(\n\t            f\"FDTD::ports\", \"monitor frequency points\", ss.wavelength_points\n\t        ) if solver == \"FDTD\" else None\n\t        p = (\n\t            f\"FDTD::ports::port {i+1}\"\n\t            if solver == \"FDTD\"\n", "            else f\"EME::Ports::port_{i+1}\"\n\t        )\n\t        s.setnamed(p, \"x\", port.x * 1e-6 / 1000)\n\t        s.setnamed(p, \"y\", port.y * 1e-6 / 1000)\n\t        s.setnamed(p, \"z\", z * 1e-6 / 1000)\n\t        s.setnamed(p, \"z span\", zspan * 1e-6)\n\t        if solver != \"MODE\":\n\t            s.setnamed(p, \"frequency dependent profile\", ss.frequency_dependent_profile)\n\t            s.setnamed(p, \"number of field profile samples\", ss.field_profile_samples)\n\t        deg = int(port.orientation)\n", "        # if port.orientation not in [0, 90, 180, 270]:\n\t        #     raise ValueError(f\"{port.orientation} needs to be [0, 90, 180, 270]\")\n\t        if -45 <= deg <= 45:\n\t            direction = \"Backward\"\n\t            injection_axis = \"x-axis\"\n\t            dxp = 0.0\n\t            dyp = 2 * ss.port_margin + port.width / 1000\n\t        elif 45 < deg < 90 + 45:\n\t            direction = \"Backward\"\n\t            injection_axis = \"y-axis\"\n", "            dxp = 2 * ss.port_margin + port.width / 1000\n\t            dyp = 0.0\n\t        elif 90 + 45 < deg < 180 + 45:\n\t            direction = \"Forward\"\n\t            injection_axis = \"x-axis\"\n\t            dxp = 0.0\n\t            dyp = 2 * ss.port_margin + port.width / 1000\n\t        elif 180 + 45 < deg < 180 + 45 + 90:\n\t            direction = \"Forward\"\n\t            injection_axis = \"y-axis\"\n", "            dxp = 2 * ss.port_margin + port.width / 1000\n\t            dyp = 0.0\n\t        else:\n\t            raise ValueError(\n\t                f\"port {port.name!r} orientation {port.orientation} is not valid\"\n\t            )\n\t        port_location = (\n\t            \"left\" if direction == \"Forward\" and injection_axis == \"x-axis\" else \"right\"\n\t        )\n\t        s.setnamed(p, \"direction\", direction) if solver == \"FDTD\" else s.setnamed(\n", "            p, \"port location\", port_location\n\t        )\n\t        s.setnamed(p, \"injection axis\", injection_axis) if solver == \"FDTD\" else None\n\t        s.setnamed(p, \"y span\", dyp * 1e-6)\n\t        s.setnamed(p, \"x span\", dxp * 1e-6) if solver == \"FDTD\" else s.setnamed(\n\t            p, \"z span\", zspan\n\t        )\n\t        # s.setnamed(p, \"theta\", deg)\n\t        s.setnamed(p, \"name\", port.name) if solver == \"FDTD\" else None\n\t        # s.setnamed(p, \"name\", f\"o{i+1}\")\n", "        logger.info(\n\t            f\"port {p} {port.name!r}: at ({port.x}, {port.y}, 0)\"\n\t            f\"size = ({dxp}, {dyp}, {zspan})\"\n\t        )\n\t    s.setglobalsource(\"wavelength start\", ss.wavelength_start * 1e-6)\n\t    s.setglobalsource(\"wavelength stop\", ss.wavelength_stop * 1e-6)\n\t    # s.setglobalsource(\"wavelength points\", ss.wavelength_points)\n\t    if run and solver == \"FDTD\":\n\t        s.addsweep(3)\n\t        s.setsweep(\"s-parameter sweep\", \"Excite all ports\", 0)\n", "        s.setsweep(\"s-parameter sweep\", \"auto symmetry\", True)\n\t        s.setglobalmonitor(\"frequency points\", ss.wavelength_points)\n\t        s.save(str(filepath_fsp))\n\t        s.runsweep(\"s-parameter sweep\")\n\t        sp = (\n\t            s.getsweepresult(\"s-parameter sweep\", \"S parameters\")\n\t            if solver == \"FDTD\"\n\t            else s.getsweepresult(\"s-parameter sweep\", \"user s matrix\")\n\t        )\n\t        s.exportsweep(\"s-parameter sweep\", str(filepath))\n", "        logger.info(f\"wrote sparameters to {filepath}\")\n\t        # sp[\"wavelengths\"] = sp.pop(\"lambda\").flatten() * 1e6\n\t        np.savez_compressed(filepath_npz, **sp)\n\t        with open(filepath, \"r+\") as fd:\n\t            data = fd.read()\n\t            diction = {180: \"LEFT\", 0: \"RIGHT\", 90: \"TOP\", 270: \"BOTTOM\"}\n\t            for p_ in cell.ports:\n\t                data = data.replace(\n\t                    f\"{p_.name}, LEFT\", f\"{p_.name}, {diction[int(p_.orientation)]}\"\n\t                )\n", "            fd.seek(0)\n\t            fd.write(data)\n\t        fd.close()\n\t        # keys = [key for key in sp.keys() if key.startswith(\"S\")]\n\t        # ra = {\n\t        #     f\"{key.lower()}a\": list(np.unwrap(np.angle(sp[key].flatten())))\n\t        #     for key in keys\n\t        # }\n\t        # rm = {f\"{key.lower()}m\": list(np.abs(sp[key].flatten())) for key in keys}\n\t        # results = {\"wavelengths\": wavelengths}\n", "        # results.update(ra)\n\t        # results.update(rm)\n\t        # df = pd.DataFrame(results, index=wavelengths)\n\t        # df.to_csv(filepath_npz, index=False)\n\t        end = time.time()\n\t        sim_settings.update(compute_time_seconds=end - start)\n\t        sim_settings.update(compute_time_minutes=(end - start) / 60)\n\t        filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n\t        if delete_fsp_files and fspdir.exists():\n\t            shutil.rmtree(fspdir)\n", "            logger.info(\n\t                f\"deleting simulation files in {fspdir}. \"\n\t                \"To keep them, use delete_fsp_files=False flag\"\n\t            )\n\t        return sp\n\t    elif run and solver == \"MODE\":\n\t        start = time.time()\n\t        s.run()\n\t        s.setemeanalysis(\"wavelength sweep\", 1)\n\t        s.setemeanalysis(\"start wavelength\", ss.wavelength_start * 1e-6)\n", "        s.setemeanalysis(\"stop wavelength\", ss.wavelength_stop * 1e-6)\n\t        s.setemeanalysis(\"number of wavelength points\", ss.wavelength_points)\n\t        s.emesweep(\"wavelength sweep\")\n\t        sp = s.getemesweep(\"S_wavelength_sweep\")\n\t        s.exportemesweep(str(filepath))\n\t        with open(filepath, \"r+\") as f:\n\t            text = f.read()\n\t            for i, val in enumerate(cell.ports):\n\t                text = text.replace(f\"port {i+1}\", val.name)\n\t            f.write(text)\n", "        f.close()\n\t        sp = np.ndarray(sp)\n\t        np.savez_compressed(filepath_npz, **sp)\n\t        end = time.time()\n\t        sim_settings.update(compute_time_seconds=end - start)\n\t        sim_settings.update(compute_time_minutes=(end - start) / 60)\n\t        filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n\t        if delete_fsp_files and fspdir.exists():\n\t            shutil.rmtree(fspdir)\n\t            logger.info(\n", "                f\"deleting simulation files in {fspdir}. \"\n\t                \"To keep them, use delete_fsp_files=False flag\"\n\t            )\n\t        return sp\n\t    filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n\t    return s\n\tif __name__ == \"__main__\":\n\t    import kgeneric\n\t    from kgeneric.pdk import LAYER\n\t    import lumapi\n", "    s = lumapi.FDTD()\n\t    cell = kgeneric.cells.waveguide(width=0.5, length=2, layer=LAYER.WG)\n\t    material_name_to_lumerical = dict(si=(3.45, 2))  # or dict(si=3.45+2j)\n\t    r = write_sparameters_lumerical(\n\t        cell=cell,\n\t        material_name_to_lumerical=material_name_to_lumerical,  # type: ignore\n\t        run=False,\n\t        session=s,\n\t    )\n"]}
{"filename": "kplugins/lumerical/simulation_settings.py", "chunked_list": ["from typing import Dict\n\tfrom pydantic import BaseModel\n\timport numpy as np\n\tfrom kplugins.typings import MaterialSpec\n\tmaterial_name_to_lumerical_default: Dict[str, MaterialSpec] = {\n\t    \"si\": \"Si (Silicon) - Palik\",\n\t    \"sio2\": \"SiO2 (Glass) - Palik\",\n\t    \"sin\": \"Si3N4 (Silicon Nitride) - Phillip\",\n\t}\n\tclass SimulationSettingsLumericalFdtd(BaseModel):\n", "    \"\"\"Lumerical FDTD simulation_settings.\n\t    Parameters:\n\t        background_material: for the background.\n\t        port_margin: on both sides of the port width (um).\n\t        port_height: port height (um).\n\t        port_extension: port extension (um).\n\t        mesh_accuracy: 2 (1: coarse, 2: fine, 3: superfine).\n\t        zmargin: for the FDTD region (um).\n\t        ymargin: for the FDTD region (um).\n\t        xmargin: for the FDTD region (um).\n", "        wavelength_start: 1.2 (um).\n\t        wavelength_stop: 1.6 (um).\n\t        wavelength_points: 500.\n\t        simulation_time: (s) related to max path length\n\t            3e8/2.4*10e-12*1e6 = 1.25mm.\n\t        simulation_temperature: in kelvin (default = 300).\n\t        frequency_dependent_profile: compute mode profiles for each wavelength.\n\t        field_profile_samples: number of wavelengths to compute field profile.\n\t    \"\"\"\n\t    background_material: str = \"sio2\"\n", "    port_margin: float = 1.5\n\t    port_extension: float = 5.0\n\t    mesh_accuracy: int = 2\n\t    zmargin: float = 1.0\n\t    ymargin: float = 3.0\n\t    xmargin: float = 3.0\n\t    wavelength_start: float = 1.2\n\t    wavelength_stop: float = 1.6\n\t    wavelength_points: int = 500\n\t    simulation_time: float = 10e-12\n", "    simulation_temperature: float = 300\n\t    frequency_dependent_profile: bool = True\n\t    field_profile_samples: int = 15\n\t    distance_source_to_monitors: float = 0.2\n\t    material_name_to_lumerical: Dict[\n\t        str, MaterialSpec\n\t    ] = material_name_to_lumerical_default\n\t    class Config:\n\t        \"\"\"pydantic basemodel config.\"\"\"\n\t        arbitrary_types_allowed = True\n", "SIMULATION_SETTINGS_LUMERICAL_FDTD = SimulationSettingsLumericalFdtd()\n\tif __name__ == \"__main__\":\n\t    d = SIMULATION_SETTINGS_LUMERICAL_FDTD\n"]}
