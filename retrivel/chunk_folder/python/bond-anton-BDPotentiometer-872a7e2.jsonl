{"filename": "tests/test_version.py", "chunked_list": ["\"\"\" Test package version is correctly set \"\"\"\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import __version__ as version\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import __version__ as version\n\tclass TestVersion(unittest.TestCase):\n\t    \"\"\"\n\t    Test _version.py has correct version number assigned to global __version__ variable.\n\t    \"\"\"\n", "    def test_check_version_numbering(self) -> None:\n\t        \"\"\"\n\t        Version must be string with three integers separated by dot.\n\t        Example: `0.1.4` or `2.0.0`.\n\t        All three digits must not negative and must not be equal to zero at the same time.\n\t        \"\"\"\n\t        # Assert version is a string.\n\t        self.assertTrue(isinstance(version, str))\n\t        # Assert no extra space present. Example: \" 0.1.1  \" is not correct, \"0.1.1\" is correct.\n\t        self.assertEqual(len(version), len(version.strip()))\n", "        # Assert all three parts are present\n\t        v_l = version.split(\".\")\n\t        self.assertEqual(len(v_l), 3)\n\t        # Assert no extra space present in each part.\n\t        # Example: \"0. 1 .1\" is not correct, \"0.1.1\" is correct\n\t        for i in range(3):\n\t            self.assertEqual(len(v_l[i]), len(v_l[i].strip()))\n\t        # Convert all parts of the version to int values\n\t        v_maj = int(v_l[0])\n\t        v_min = int(v_l[1])\n", "        v_patch = int(v_l[2])\n\t        # Assert all version numbers are not negative\n\t        self.assertTrue(v_maj >= 0)\n\t        self.assertTrue(v_min >= 0)\n\t        self.assertTrue(v_patch >= 0)\n\t        # Assert all version numbers are not equal to zero at the same time\n\t        self.assertTrue(v_maj + v_min + v_patch > 0)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_parameters_lock.py", "chunked_list": ["\"\"\" Test access to Potentiometer locked/unlocked properties. \"\"\"\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer\n\tclass TestPotentiometerLocked(unittest.TestCase):\n\t    \"\"\"\n\t    Testing Potentiometer properties `r_ab` and `r_w`.\n\t    \"\"\"\n", "    def setUp(self) -> None:\n\t        self.pot = None\n\t        self.pot_locked = None\n\t    def test_locked(self):\n\t        \"\"\"\n\t        Test locked potentiometer. Altering of `r_ab` and `r_w` properties should be ignored.\n\t        Changing of any other property is allowed.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n\t            self.pot_locked = Potentiometer(\n", "                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=True\n\t            )\n\t            # Assert the device is locked and that property is read-only.\n\t            self.assertTrue(self.pot_locked.parameters_locked)\n\t            with self.assertRaises(AttributeError):\n\t                self.pot_locked.parameters_locked = False\n\t            with self.assertRaises(AttributeError):\n\t                self.pot_locked.parameters_locked = True\n\t            # Try to change `r_ab`, check that the value was not changed.\n\t            initial_value = self.pot_locked.r_ab\n", "            new_value = 2 * initial_value\n\t            self.pot_locked.r_ab = new_value\n\t            self.assertEqual(self.pot_locked.r_ab, initial_value)\n\t            # Try to change `r_w`, check that the value was not changed.\n\t            initial_value = self.pot_locked.r_w\n\t            new_value = 2 * initial_value\n\t            self.pot_locked.r_w = new_value\n\t            self.assertEqual(self.pot_locked.r_w, initial_value)\n\t            # Check that `r_lim`, and `r_load`, and `voltage_in` are not locked.\n\t            initial_value = self.pot_locked.r_lim\n", "            new_value = 2 * initial_value\n\t            self.pot_locked.r_lim = new_value\n\t            self.assertEqual(self.pot_locked.r_lim, new_value)\n\t            initial_value = self.pot_locked.r_load\n\t            new_value = 2 * initial_value\n\t            self.pot_locked.r_load = new_value\n\t            self.assertEqual(self.pot_locked.r_load, new_value)\n\t            initial_value = self.pot_locked.voltage_in\n\t            new_value = 2 * initial_value\n\t            self.pot_locked.voltage_in = new_value\n", "            self.assertEqual(self.pot_locked.voltage_in, new_value)\n\t    def test_unlocked(self):\n\t        \"\"\"\n\t        Test unlocked potentiometer.\n\t        Changing of any property is allowed.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n\t            self.pot = Potentiometer(\n\t                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n", "            # Assert the device is not locked and that property is read-only.\n\t            self.assertFalse(self.pot.parameters_locked)\n\t            with self.assertRaises(AttributeError):\n\t                self.pot.parameters_locked = True\n\t            with self.assertRaises(AttributeError):\n\t                self.pot.parameters_locked = False\n\t            # Try to change `r_ab`, check that the value was changed.\n\t            initial_value = self.pot.r_ab\n\t            new_value = 2 * initial_value\n\t            self.pot.r_ab = new_value\n", "            self.assertEqual(self.pot.r_ab, new_value)\n\t            # Try to change `r_w`, check that the value was changed.\n\t            initial_value = self.pot.r_w\n\t            new_value = 2 * initial_value\n\t            self.pot.r_w = new_value\n\t            self.assertEqual(self.pot.r_w, new_value)\n\t            # Check that `r_lim`, and `r_load`, and `voltage_in` are not locked.\n\t            initial_value = self.pot.r_lim\n\t            new_value = 2 * initial_value\n\t            self.pot.r_lim = new_value\n", "            self.assertEqual(self.pot.r_lim, new_value)\n\t            initial_value = self.pot.r_load\n\t            new_value = 2 * initial_value\n\t            self.pot.r_load = new_value\n\t            self.assertEqual(self.pot.r_load, new_value)\n\t            initial_value = self.pot.voltage_in\n\t            new_value = 2 * initial_value\n\t            self.pot.voltage_in = new_value\n\t            self.assertEqual(self.pot.voltage_in, new_value)\n\tif __name__ == \"__main__\":\n", "    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_r_wa_r_wb.py", "chunked_list": ["\"\"\" Tests for Potentiometer `r_wa` and `r_wb` calculation. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer\n\tclass TestPotentiometerRwaRwb(unittest.TestCase):\n\t    \"\"\"\n\t    Testing Potentiometer `r_wa` and `r_wb` calculation.\n", "    \"\"\"\n\t    def test_rwa_rwb(self):\n\t        \"\"\"\n\t        Testing correctness of r_wa and r_wb calculation for\n\t        locked/unlocked potentiometer and rheostat configurations.\n\t        \"\"\"\n\t        for rheostat in (False, True):\n\t            for locked in (False, True):\n\t                pot = Potentiometer(\n\t                    r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=locked\n", "                )\n\t                for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n\t                    r_wa = pot.r_wa(pos)\n\t                    r_wb = pot.r_wb(pos)\n\t                    np.testing.assert_allclose(r_wa, pot.r_w + (1 - pos) * pot.r_ab)\n\t                    np.testing.assert_allclose(pot.r_wa_to_position(r_wa), pos)\n\t                    np.testing.assert_allclose(r_wb, pot.r_w + pos * pot.r_ab)\n\t                    np.testing.assert_allclose(pot.r_wb_to_position(r_wb), pos)\n\t                    np.testing.assert_allclose(r_wa + r_wb, 2 * pot.r_w + pot.r_ab)\n\t                # Out of range wiper position should coerce to 0\n", "                pos = -0.1\n\t                np.testing.assert_allclose(pot.r_wa(pos), pot.r_w + pot.r_ab)\n\t                np.testing.assert_allclose(pot.r_wb(pos), pot.r_w)\n\t                # Out of range wiper position should coerce to 1\n\t                pos = 1.1\n\t                np.testing.assert_allclose(pot.r_wa(pos), pot.r_w)\n\t                np.testing.assert_allclose(pot.r_wb(pos), pot.r_w + pot.r_ab)\n\t                # Out of range resistance should coerce to pot.r_ab + pot.r_w\n\t                np.testing.assert_allclose(\n\t                    pot.r_wa_to_position(pot.r_ab + 2 * pot.r_w),\n", "                    pot.r_wa_to_position(pot.r_ab + pot.r_w),\n\t                )\n\t                np.testing.assert_allclose(\n\t                    pot.r_wb_to_position(pot.r_ab + 2 * pot.r_w),\n\t                    pot.r_wb_to_position(pot.r_ab + pot.r_w),\n\t                )\n\t                # Out of range resistance should coerce to pot.r_w\n\t                np.testing.assert_allclose(\n\t                    pot.r_wa_to_position(0), pot.r_wa_to_position(pot.r_w)\n\t                )\n", "                np.testing.assert_allclose(\n\t                    pot.r_wb_to_position(0), pot.r_wb_to_position(pot.r_w)\n\t                )\n\t                # Out of range (negative) resistance should coerce to pot.r_w\n\t                np.testing.assert_allclose(\n\t                    pot.r_wa_to_position(-1), pot.r_wa_to_position(pot.r_w)\n\t                )\n\t                np.testing.assert_allclose(\n\t                    pot.r_wb_to_position(-1), pot.r_wb_to_position(pot.r_w)\n\t                )\n", "if __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_constructor.py", "chunked_list": ["\"\"\" Tests for Potentiometer constructor. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer\n\tclass TestPotentiometerConstructor(unittest.TestCase):\n\t    \"\"\"\n\t    Testing Potentiometer constructor.\n", "    \"\"\"\n\t    def test_r_ab(self) -> None:\n\t        \"\"\"\n\t        Test r_ab parameter.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n\t            for locked in [True, False]:\n\t                # Normal values\n\t                for r_ab in [1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n\t                    pot = Potentiometer(\n", "                        r_ab=r_ab, r_w=75, rheostat=rheostat, parameters_locked=locked\n\t                    )\n\t                    self.assertEqual(pot.r_ab, r_ab)\n\t                    # Test default values (zero) for r_lim, r_load, voltage_in are set.\n\t                    self.assertEqual(pot.r_lim, 0)\n\t                    self.assertEqual(pot.r_load, 0)\n\t                    self.assertEqual(pot.voltage_in, 0)\n\t                # Wrong values\n\t                for r_ab in [-1.0, 0, 0.0, -1e3, -10e3]:\n\t                    with self.assertRaises(ValueError):\n", "                        _ = Potentiometer(\n\t                            r_ab=r_ab,\n\t                            r_w=75,\n\t                            rheostat=rheostat,\n\t                            parameters_locked=locked,\n\t                        )\n\t                # Wrong type\n\t                for r_ab in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n\t                    with self.assertRaises(TypeError):\n\t                        _ = Potentiometer(\n", "                            r_ab=r_ab,\n\t                            r_w=75,\n\t                            rheostat=rheostat,\n\t                            parameters_locked=locked,\n\t                        )\n\t    def test_r_w(self) -> None:\n\t        \"\"\"\n\t        Test r_w parameter.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n", "            for locked in [True, False]:\n\t                # Normal values\n\t                for r_w in [\n\t                    0,\n\t                    0.0,\n\t                    1,\n\t                    100.134,\n\t                    1e3,\n\t                    10e3,\n\t                    np.float64(1.1e3),\n", "                    np.float32(1.1e3),\n\t                ]:\n\t                    pot = Potentiometer(\n\t                        r_ab=10e3, r_w=r_w, rheostat=rheostat, parameters_locked=locked\n\t                    )\n\t                    self.assertEqual(pot.r_w, r_w)\n\t                    # Test default values (zero) for r_lim, r_load, voltage_in are set.\n\t                    self.assertEqual(pot.r_lim, 0)\n\t                    self.assertEqual(pot.r_load, 0)\n\t                    self.assertEqual(pot.voltage_in, 0)\n", "                # Wrong values\n\t                for r_w in [-1.0, -1e3, -10e3]:\n\t                    with self.assertRaises(ValueError):\n\t                        _ = Potentiometer(\n\t                            r_ab=10e3,\n\t                            r_w=r_w,\n\t                            rheostat=rheostat,\n\t                            parameters_locked=locked,\n\t                        )\n\t                # Wrong type\n", "                for r_w in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n\t                    with self.assertRaises(TypeError):\n\t                        pot = Potentiometer(\n\t                            r_ab=10e3,\n\t                            r_w=r_w,\n\t                            rheostat=rheostat,\n\t                            parameters_locked=locked,\n\t                        )\n\t    def test_rheostat(self) -> None:\n\t        \"\"\"\n", "        Test rheostat parameter.\n\t        \"\"\"\n\t        # Normal values and strange ones. All will be converted to bool\n\t        for rheostat in [True, False, 1, 0, \"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n\t            pot = Potentiometer(\n\t                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n\t            self.assertEqual(pot.rheostat, bool(rheostat))\n\t            # Test default values (zero) for r_lim, r_load, voltage_in are set.\n\t            self.assertEqual(pot.r_lim, 0)\n", "            self.assertEqual(pot.r_load, 0)\n\t            self.assertEqual(pot.voltage_in, 0)\n\t    def test_locked(self) -> None:\n\t        \"\"\"\n\t        Test locked parameter.\n\t        \"\"\"\n\t        # Normal values and strange ones. All will be converted to bool\n\t        for rheostat in [True, False]:\n\t            for locked in [True, False, 1, 0, \"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n\t                pot = Potentiometer(\n", "                    r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=locked\n\t                )\n\t                self.assertEqual(pot.parameters_locked, bool(locked))\n\t                # Test default values (zero) for r_lim, r_load, voltage_in are set.\n\t                self.assertEqual(pot.r_lim, 0)\n\t                self.assertEqual(pot.r_load, 0)\n\t                self.assertEqual(pot.voltage_in, 0)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_fixed_resistors.py", "chunked_list": ["\"\"\" Test Potentiometer resistors properties setters and getters. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer\n\tclass TestPotentiometerFixedResistors(unittest.TestCase):\n\t    \"\"\"\n\t    Testing Potentiometer properties r_ab, r_w, r_lim, r_load.\n", "    \"\"\"\n\t    def setUp(self) -> None:\n\t        self.pot = None\n\t    def test_r_ab(self) -> None:\n\t        \"\"\"\n\t        Test r_ab property.\n\t        For unlocked potentiometer and rheostat result is the same.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n\t            self.pot = Potentiometer(\n", "                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n\t            self.assertEqual(self.pot.r_ab, 10e3)\n\t            # Normal values\n\t            for r_ab in [1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n\t                self.pot.r_ab = r_ab\n\t                self.assertEqual(self.pot.r_ab, r_ab)\n\t                self.assertIsInstance(self.pot.r_ab, float)\n\t            # Wrong values\n\t            for r_ab in [-1.0, 0, 0.0, -1e3, -10e3]:\n", "                with self.assertRaises(ValueError):\n\t                    self.pot.r_ab = r_ab\n\t            # Wrong type\n\t            for r_ab in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n\t                with self.assertRaises(TypeError):\n\t                    self.pot.r_ab = r_ab\n\t    def test_r_w(self) -> None:\n\t        \"\"\"\n\t        Test r_w property.\n\t        For unlocked potentiometer and rheostat result is the same.\n", "        \"\"\"\n\t        for rheostat in [True, False]:\n\t            self.pot = Potentiometer(\n\t                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n\t            self.assertEqual(self.pot.r_w, 75)\n\t            # Normal values\n\t            for r_w in [0, 0.0, 1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n\t                self.pot.r_w = r_w\n\t                self.assertEqual(self.pot.r_w, r_w)\n", "                self.assertIsInstance(self.pot.r_w, float)\n\t            # Wrong values\n\t            for r_w in [-1.0, -1e3, -10e3]:\n\t                with self.assertRaises(ValueError):\n\t                    self.pot.r_w = r_w\n\t            # Wrong type\n\t            for r_w in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n\t                with self.assertRaises(TypeError):\n\t                    self.pot.r_w = r_w\n\t    def test_r_lim(self) -> None:\n", "        \"\"\"\n\t        Test r_lim property.\n\t        For unlocked potentiometer and rheostat result is the same.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n\t            self.pot = Potentiometer(\n\t                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n\t            self.assertEqual(self.pot.r_lim, 0)\n\t            # Normal values\n", "            for r_lim in [0, 0.0, 1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n\t                self.pot.r_lim = r_lim\n\t                self.assertEqual(self.pot.r_lim, r_lim)\n\t                self.assertIsInstance(self.pot.r_lim, float)\n\t            # Wrong values\n\t            for r_lim in [-1.0, -1e3, -10e3]:\n\t                with self.assertRaises(ValueError):\n\t                    self.pot.r_lim = r_lim\n\t            # Wrong type\n\t            for r_lim in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n", "                with self.assertRaises(TypeError):\n\t                    self.pot.r_lim = r_lim\n\t    def test_r_load(self) -> None:\n\t        \"\"\"\n\t        Test r_load property.\n\t        For unlocked potentiometer and rheostat result is the same.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n\t            self.pot = Potentiometer(\n\t                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n", "            )\n\t            self.assertEqual(self.pot.r_load, 0)\n\t            # Normal values\n\t            for r_load in [0, 0.0, 1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n\t                self.pot.r_load = r_load\n\t                self.assertEqual(self.pot.r_load, r_load)\n\t                self.assertIsInstance(self.pot.r_load, float)\n\t            # Wrong values\n\t            for r_load in [-1.0, -1e3, -10e3]:\n\t                with self.assertRaises(ValueError):\n", "                    self.pot.r_load = r_load\n\t            # Wrong type\n\t            for r_load in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n\t                with self.assertRaises(TypeError):\n\t                    self.pot.r_load = r_load\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_voltage_in.py", "chunked_list": ["\"\"\" Tests for Potentiometer input voltage property. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer\n\tclass TestPotentiometerVoltageIn(unittest.TestCase):\n\t    \"\"\"\n\t    Testing Potentiometer input voltage property.\n", "    \"\"\"\n\t    def setUp(self) -> None:\n\t        self.pot = None\n\t    def test_voltage_in(self):\n\t        \"\"\"\n\t        Input voltage testing.\n\t        For unlocked potentiometer and rheostat result is the same.\n\t        \"\"\"\n\t        for rheostat in [True, False]:\n\t            self.pot = Potentiometer(\n", "                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n\t            self.assertEqual(self.pot.voltage_in, 0.0)  # Zero is default input voltage\n\t            for voltage in [\n\t                -5,\n\t                -4.5,\n\t                0,\n\t                0.0,\n\t                float(\"-0.0\"),\n\t                4.5,\n", "                5,\n\t                np.float32(4.2),\n\t                np.float64(5.2),\n\t            ]:\n\t                self.pot.voltage_in = voltage\n\t                self.assertEqual(self.pot.voltage_in, voltage)\n\t                self.assertIsInstance(self.pot.voltage_in, float)\n\t            for voltage in [\"5.1\", \"a\", None, [2.0], (1.1,)]:\n\t                with self.assertRaises(TypeError):\n\t                    self.pot.voltage_in = voltage\n", "            for voltage in [float(\"nan\"), float(\"-inf\"), float(\"inf\")]:\n\t                with self.assertRaises(ValueError):\n\t                    self.pot.voltage_in = voltage\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_voltage_out.py", "chunked_list": ["\"\"\" Tests for Potentiometer class. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer\n\tclass TestPotentiometerVoltageOut(unittest.TestCase):\n\t    \"\"\"\n\t    Testing Potentiometer.\n", "    \"\"\"\n\t    def test_voltage_out(self):\n\t        \"\"\"\n\t        Testing correctness of output voltage calculation for both\n\t        potentiometer and rheostat configurations.\n\t        \"\"\"\n\t        for rheostat in (False, True):\n\t            pot = Potentiometer(\n\t                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n", "            pot.r_lim = 0.0\n\t            pot.r_load = 1e6\n\t            # Zero input voltage should result in zero output voltage\n\t            pot.voltage_in = 0.0\n\t            for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n\t                self.assertEqual(pot.voltage_out(pos), 0.0)\n\t            # Zero load resistance should result in zero output voltage\n\t            pot.r_load = 0\n\t            pot.voltage_in = 5.0\n\t            for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n", "                self.assertEqual(pot.voltage_out(pos), 0.0)\n\t            # Testing range of input voltages\n\t            for voltage in np.linspace(-5, 5, num=101, endpoint=True):\n\t                pot.voltage_in = voltage\n\t                for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n\t                    if voltage == 0:\n\t                        self.assertEqual(pot.voltage_out(pos), 0.0)\n\t                        continue\n\t                    pot.r_lim = 0.0\n\t                    pot.r_load = 1e100\n", "                    if rheostat:\n\t                        r_total = pot.r_load + pot.r_lim + pot.r_wb(pos)\n\t                        result = pot.voltage_in * pot.r_load / r_total\n\t                    else:\n\t                        result = pot.voltage_in * pos\n\t                    np.testing.assert_allclose(pot.voltage_out(pos), result)\n\t                    pot.r_lim = 200.0\n\t                    pot.r_load = 1e4\n\t                    np.testing.assert_allclose(\n\t                        pot.voltage_out_to_wiper_position(pot.voltage_out(pos)),\n", "                        pos,\n\t                        atol=1e-15,\n\t                        rtol=1e-6,\n\t                    )\n\t            pot.r_lim = 200.0\n\t            pot.r_load = 1e4\n\t            # At zero input voltage wiper position is always zero (min. current)\n\t            pot.voltage_in = 0.0\n\t            for pos in np.linspace(0, 1, num=101, endpoint=True):\n\t                self.assertEqual(\n", "                    pot.voltage_out_to_wiper_position(pot.voltage_out(pos)), 0\n\t                )\n\t            # Positive v_in can not result in negative v_out and vice-versa\n\t            pot.voltage_in = 5.0\n\t            for v_out in np.linspace(-5, -1e-5, num=101, endpoint=True):\n\t                self.assertEqual(pot.voltage_out_to_wiper_position(v_out), 0)\n\t            pot.voltage_in = -5.0\n\t            for v_out in np.linspace(1e-5, 5, num=101, endpoint=True):\n\t                self.assertEqual(pot.voltage_out_to_wiper_position(v_out), 0)\n\t    def test_voltage_out_wrong_type(self):\n", "        \"\"\"\n\t        Testing TypeError is raised on wrong type voltage out input for both\n\t        potentiometer and rheostat configurations.\n\t        \"\"\"\n\t        for rheostat in (False, True):\n\t            pot = Potentiometer(\n\t                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n\t            )\n\t            pot.r_lim = 0.0\n\t            pot.r_load = 1e6\n", "            # Zero input voltage should result in zero output voltage\n\t            pot.voltage_in = 5.0\n\t            # Wrong type\n\t            for v_out in [None, \"100.2\"]:\n\t                with self.assertRaises(TypeError):\n\t                    pot.voltage_out_to_wiper_position(v_out)\n\t            # Wrong type\n\t            for pos in [None, \"0.2\"]:\n\t                with self.assertRaises(TypeError):\n\t                    pot.voltage_out(pos)\n", "if __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/mcp4xxx/test_mcp4xxx.py", "chunked_list": ["\"\"\" Tests for DigitalPotentiometerDevice class. \"\"\"\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer.mcp4xxx.mcp4xxx import (\n\t        resistance_list,\n\t        _coerce_max_value,\n\t        _coerce_r_ab,\n\t        _check_write_response,\n\t        _check_read_response,\n\t        # _check_status_response,\n", "        # _check_tcon_response,\n\t        # _parse_tcon_response,\n\t        # _tcon_to_cmd,\n\t    )\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer.mcp4xxx.mcp4xxx import (\n\t        resistance_list,\n\t        _coerce_max_value,\n\t        _coerce_r_ab,\n\t        _check_write_response,\n", "        _check_read_response,\n\t        # _check_status_response,\n\t        # _check_tcon_response,\n\t        # _parse_tcon_response,\n\t        # _tcon_to_cmd,\n\t    )\n\tclass MCP4xxxTestCase(unittest.TestCase):\n\t    \"\"\"\n\t    MCP4XXX class testing.\n\t    \"\"\"\n", "    def test_resistance_list(self):\n\t        \"\"\"Test r_ab resistance list is correct.\"\"\"\n\t        self.assertEqual(resistance_list, (5e3, 10e3, 50e3, 100e3))\n\t    def test_coerce_max_value(self):\n\t        \"\"\"test correct coercion of max_value.\"\"\"\n\t        self.assertEqual(_coerce_max_value(128), 128)\n\t        self.assertEqual(_coerce_max_value(256), 256)\n\t        with self.assertRaises(ValueError):\n\t            _coerce_max_value(512)\n\t        with self.assertRaises(ValueError):\n", "            _coerce_max_value(\"a\")\n\t    def test_coerce_r_ab(self):\n\t        \"\"\"test correct coercion of r_ab.\"\"\"\n\t        for r_ab in resistance_list:\n\t            self.assertEqual(_coerce_r_ab(r_ab), r_ab)\n\t        with self.assertRaises(ValueError):\n\t            _coerce_r_ab(20e3)\n\t        with self.assertRaises(ValueError):\n\t            _coerce_r_ab(\"a\")\n\t    def test_write_response(self):\n", "        \"\"\"Test write response checker.\"\"\"\n\t        with self.assertRaises(ValueError):\n\t            _check_write_response(None)\n\t    def test_read_response(self):\n\t        \"\"\"Test read response checker.\"\"\"\n\t        with self.assertRaises(ValueError):\n\t            _check_read_response(None)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_potentiometer/test_digital_potentiometer.py", "chunked_list": ["\"\"\" Tests for DigitalPotentiometerDevice class. \"\"\"\n\t# pylint: disable=protected-access\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import (\n\t        Potentiometer,\n\t        DigitalWiper,\n\t        DigitalPotentiometerDevice,\n\t    )\n", "except ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper, DigitalPotentiometerDevice\n\tclass TestDigitalPotentiometer(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalPotentiometerDevice.\n\t    \"\"\"\n\t    def setUp(self) -> None:\n\t        self.pot = Potentiometer(\n\t            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n\t        )\n", "        digital_wiper = DigitalWiper(\n\t            potentiometer=self.pot, max_value=128, parameters_locked=False\n\t        )\n\t        self.digital_pot = DigitalPotentiometerDevice(wiper=digital_wiper, channels=2)\n\t        self.digital_pot.set_channel_label(0, \"CH A\")\n\t        self.digital_pot.set_channel_label(1, \"CH B\")\n\t    def test_basic_properties(self):\n\t        \"\"\"\n\t        Testing basic parameters.\n\t        \"\"\"\n", "        pot = Potentiometer(r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False)\n\t        digital_wiper = DigitalWiper(\n\t            potentiometer=pot, max_value=128, parameters_locked=False\n\t        )\n\t        digital_pot = DigitalPotentiometerDevice(wiper=digital_wiper, channels=3)\n\t        self.assertEqual(digital_pot.channels_num, 3)\n\t        channels = digital_pot.channels\n\t        for channel_number, wiper in channels.items():\n\t            self.assertEqual(wiper.potentiometer.r_ab, pot.r_ab)\n\t            self.assertEqual(wiper.potentiometer.r_w, pot.r_w)\n", "            self.assertEqual(wiper.potentiometer.r_lim, pot.r_lim)\n\t            self.assertEqual(wiper.max_value, digital_wiper.max_value)\n\t            self.assertEqual(\n\t                channel_number,\n\t                digital_pot.get_channel_number_by_label(str(channel_number)),\n\t            )\n\t            self.assertEqual(\n\t                channel_number,\n\t                digital_pot._get_channel_number_by_label_or_id(str(channel_number)),\n\t            )\n", "            self.assertEqual(\n\t                channel_number,\n\t                digital_pot._get_channel_number_by_label_or_id(channel_number),\n\t            )\n\t    def test_channel_labels(self):\n\t        \"\"\"\n\t        Test channels labeling system\n\t        \"\"\"\n\t        self.digital_pot.set_channel_label(0, \"CH A\")\n\t        self.digital_pot.set_channel_label(1, \"CH B\")\n", "        self.assertEqual(0, self.digital_pot.get_channel_number_by_label(\"CH A\"))\n\t        self.assertEqual(1, self.digital_pot.get_channel_number_by_label(\"CH B\"))\n\t        self.assertEqual(0, self.digital_pot._get_channel_number_by_label_or_id(0))\n\t        self.assertEqual(1, self.digital_pot._get_channel_number_by_label_or_id(1))\n\t        self.assertEqual(1, self.digital_pot._get_channel_number_by_label_or_id(\"CH B\"))\n\t        self.assertIsNone(self.digital_pot.get_channel_number_by_label(\"CH C\"))\n\t        self.assertIsNone(self.digital_pot._get_channel_number_by_label_or_id(\"CH C\"))\n\t        self.assertIsNone(self.digital_pot._get_channel_number_by_label_or_id(3))\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot._get_channel_number_by_label_or_id(1.1)\n", "        with self.assertRaises(ValueError):\n\t            self.digital_pot._get_channel_number_by_label_or_id(-1)\n\t        self.digital_pot.set_channel_label(0, None)\n\t        self.assertEqual(0, self.digital_pot.get_channel_number_by_label(\"0\"))\n\t        self.digital_pot.set_channel_label(0, \"CH A\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_channel_label(1, \"CH A\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_channel_label(2, \"CH A\")\n\t        with self.assertRaises(ValueError):\n", "            self.digital_pot.set_channel_label(1.1, \"CH C\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_channel_label(-1, \"CH C\")\n\t    def test_value_set_and_get(self):\n\t        \"\"\"\n\t        Test `set` and `read` functions, value property\n\t        \"\"\"\n\t        self.digital_pot.set_value(0, 10)\n\t        self.assertEqual(self.digital_pot.value[0], 10)\n\t        self.assertEqual(self.digital_pot.get_value(0), 10)\n", "        self.digital_pot.set_value(\"CH A\", 20)\n\t        self.assertEqual(self.digital_pot.value[0], 20)\n\t        self.assertEqual(self.digital_pot.get_value(\"CH A\"), 20)\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_value(\"CH C\", 20)\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_value(2, 20)\n\t        self.assertEqual(self.digital_pot.get_value(0), 20)\n\t        self.assertEqual(self.digital_pot.get_value(\"CH A\"), 20)\n\t        with self.assertRaises(ValueError):\n", "            self.digital_pot.get_value(\"CH C\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.get_value(2)\n\t        self.digital_pot.value = (10, 20)\n\t        self.assertEqual(self.digital_pot.value, (10, 20))\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.value = 10\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.value = (10, 20, 30)\n\t        values = np.arange(129)\n", "        for value in values:\n\t            self.digital_pot.set_value(0, value)\n\t            self.digital_pot.set_value(1, value)\n\t            self.assertEqual(self.digital_pot.value, (value, value))\n\t    def test_rwa_rwb(self):\n\t        \"\"\"Test r_wa and r_wb control\"\"\"\n\t        self.digital_pot.set_r_wa(0, self.pot.r_ab / 2)\n\t        self.digital_pot.set_r_wa(\"CH A\", self.pot.r_ab / 2)\n\t        pos = self.digital_pot.value[0] / self.digital_pot.channels[0].max_value\n\t        self.assertEqual(self.digital_pot.r_wa[0], self.pot.r_wa(pos))\n", "        self.assertEqual(self.digital_pot.get_r_wa(0), self.pot.r_wa(pos))\n\t        self.assertEqual(self.digital_pot.get_r_wa(\"CH A\"), self.pot.r_wa(pos))\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_r_wa(2, self.pot.r_ab / 2)\n\t        self.digital_pot.set_r_wb(1, self.pot.r_ab / 3)\n\t        self.digital_pot.set_r_wb(\"CH B\", self.pot.r_ab / 3)\n\t        pos = self.digital_pot.value[1] / self.digital_pot.channels[1].max_value\n\t        self.assertEqual(self.digital_pot.r_wb[1], self.pot.r_wb(pos))\n\t        self.assertEqual(self.digital_pot.get_r_wb(1), self.pot.r_wb(pos))\n\t        self.assertEqual(self.digital_pot.get_r_wb(\"CH B\"), self.pot.r_wb(pos))\n", "        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_r_wb(2, self.pot.r_ab / 3)\n\t        self.digital_pot.r_wa = (self.pot.r_ab / 2, self.pot.r_ab / 3)\n\t        pos = self.digital_pot.value[0] / self.digital_pot.channels[0].max_value\n\t        self.assertEqual(self.digital_pot.r_wa[0], self.pot.r_wa(pos))\n\t        pos = self.digital_pot.value[1] / self.digital_pot.channels[1].max_value\n\t        self.assertEqual(self.digital_pot.r_wa[1], self.pot.r_wa(pos))\n\t        self.digital_pot.r_wb = (self.pot.r_ab / 2, self.pot.r_ab / 3)\n\t        pos = self.digital_pot.value[0] / self.digital_pot.channels[0].max_value\n\t        self.assertEqual(self.digital_pot.r_wb[0], self.pot.r_wb(pos))\n", "        pos = self.digital_pot.value[1] / self.digital_pot.channels[1].max_value\n\t        self.assertEqual(self.digital_pot.r_wb[1], self.pot.r_wb(pos))\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.r_wa = (0, 0, 0)\n\t        with self.assertRaises(TypeError):\n\t            self.digital_pot.r_wa = 0\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.r_wb = (0, 0, 0)\n\t        with self.assertRaises(TypeError):\n\t            self.digital_pot.r_wb = 0\n", "        with self.assertRaises(ValueError):\n\t            self.digital_pot.get_r_wa(\"CH ZZZ\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.get_r_wb(\"CH ZZZ\")\n\t    def test_voltage_in(self):\n\t        \"\"\"\n\t        Test voltage_in setters and getters\n\t        \"\"\"\n\t        self.assertEqual(self.digital_pot.voltage_in, (0, 0))\n\t        self.digital_pot.voltage_in = (-5, 5)\n", "        self.assertEqual(self.digital_pot.voltage_in, (-5, 5))\n\t        self.assertEqual(self.digital_pot.get_voltage_in(\"CH A\"), -5)\n\t        self.assertEqual(self.digital_pot.get_voltage_in(\"CH B\"), 5)\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.get_voltage_in(\"CH XXX\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.voltage_in = (-5, 5, 0)\n\t        with self.assertRaises(TypeError):\n\t            self.digital_pot.voltage_in = 5\n\t        self.digital_pot.set_voltage_in(0, 5)\n", "        self.digital_pot.set_voltage_in(\"CH B\", 15)\n\t        self.assertEqual(self.digital_pot.voltage_in, (5, 15))\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_voltage_in(2, 5)\n\t    def test_voltage_out(self):\n\t        \"\"\"\n\t        Test voltage_out setters and getters\n\t        \"\"\"\n\t        self.assertEqual(self.digital_pot.voltage_out, (0, 0))\n\t        self.digital_pot.voltage_in = (-5, 5)\n", "        self.digital_pot.voltage_out = (-2.5, 2.5)\n\t        self.assertEqual(\n\t            self.digital_pot.voltage_out,\n\t            (\n\t                self.digital_pot.channels[0].voltage_out,\n\t                self.digital_pot.channels[1].voltage_out,\n\t            ),\n\t        )\n\t        self.assertEqual(\n\t            self.digital_pot.get_voltage_out(\"CH A\"),\n", "            self.digital_pot.channels[0].voltage_out,\n\t        )\n\t        self.assertEqual(\n\t            self.digital_pot.get_voltage_out(\"CH B\"),\n\t            self.digital_pot.channels[1].voltage_out,\n\t        )\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.get_voltage_out(\"CH XXX\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.voltage_out = (-5, 5, 0)\n", "        with self.assertRaises(TypeError):\n\t            self.digital_pot.voltage_out = 5\n\t        self.digital_pot.set_voltage_out(0, -1)\n\t        self.digital_pot.set_voltage_out(\"CH B\", 1.5)\n\t        self.assertEqual(\n\t            self.digital_pot.voltage_out,\n\t            (\n\t                self.digital_pot.channels[0].voltage_out,\n\t                self.digital_pot.channels[1].voltage_out,\n\t            ),\n", "        )\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_voltage_out(2, 5)\n\t        min_r_step = (self.pot.r_ab + self.pot.r_w) / self.digital_pot.channels[\n\t            0\n\t        ].max_value\n\t        self.assertTrue(\n\t            abs(self.digital_pot.channels[0].voltage_out - 1) < min_r_step * 5\n\t        )\n\t    def test_r_lim(self):\n", "        \"\"\"\n\t        Test r_lim property and corresponding get_ and set_ methods.\n\t        \"\"\"\n\t        self.digital_pot.r_lim = 200\n\t        self.assertEqual(self.digital_pot.r_lim, (200, 200))\n\t        self.digital_pot.r_lim = (100, 200)\n\t        self.assertEqual(self.digital_pot.r_lim, (100, 200))\n\t        self.assertEqual(self.digital_pot.get_r_lim(\"CH A\"), 100)\n\t        self.assertEqual(self.digital_pot.get_r_lim(\"CH B\"), 200)\n\t        self.digital_pot.set_r_lim(\"CH B\", 300)\n", "        self.assertEqual(self.digital_pot.get_r_lim(\"CH B\"), 300)\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.r_lim = (100, 200, 300)\n\t        with self.assertRaises(TypeError):\n\t            self.digital_pot.r_lim = (\"A\", 200)\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.r_lim = \"A\"\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_r_lim(\"CH XXX\", 300)\n\t        with self.assertRaises(ValueError):\n", "            self.digital_pot.get_r_lim(\"CH XXX\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_r_lim(\"CH B\", -300)\n\t    def test_r_load(self):\n\t        \"\"\"\n\t        Testing r_load property and corresponding get_ and set_ methods.\n\t        \"\"\"\n\t        self.digital_pot.r_load = 1e6\n\t        self.assertEqual(self.digital_pot.r_load, (1e6, 1e6))\n\t        self.digital_pot.r_load = (1e6, 2e6)\n", "        self.assertEqual(self.digital_pot.r_load, (1e6, 2e6))\n\t        self.assertEqual(self.digital_pot.get_r_load(\"CH A\"), 1e6)\n\t        self.assertEqual(self.digital_pot.get_r_load(\"CH B\"), 2e6)\n\t        self.digital_pot.set_r_load(\"CH B\", 3e6)\n\t        self.assertEqual(self.digital_pot.get_r_load(\"CH B\"), 3e6)\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.r_load = (1e6, 2e6, 3e6)\n\t        with self.assertRaises(TypeError):\n\t            self.digital_pot.r_load = (\"A\", 2e6)\n\t        with self.assertRaises(ValueError):\n", "            self.digital_pot.r_load = \"A\"\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_r_load(\"CH XXX\", 3e6)\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.get_r_load(\"CH XXX\")\n\t        with self.assertRaises(ValueError):\n\t            self.digital_pot.set_r_load(\"CH B\", -3e6)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/helpers/test_helpers_check_number.py", "chunked_list": ["\"\"\" Testing helpers functions (check_number). \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer.__helpers import check_number\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer.__helpers import check_number\n\tclass TestHelpersCheckNumber(unittest.TestCase):\n\t    \"\"\"\n\t    Testing check_number function.\n", "    Function checks if argument is a real number (not complex).\n\t    return int or float depending on argument type or raises ValueError\n\t    if argument is not a real number.\n\t    check_number does not allow argument to be +-inf, or NaN.\n\t    Special numbers `+0` and `-0` must be converted to just 0\n\t    \"\"\"\n\t    def test_check_number_int(self):\n\t        \"\"\"Check integer arguments.\"\"\"\n\t        for input_value in [-17, -1, -0, 0, 1, 17]:\n\t            output_value = check_number(input_value)\n", "            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, int)\n\t            # Check numpy integer types.\n\t            for numpy_type in [np.int32, np.int64, np.int8]:\n\t                np_input_value = numpy_type(input_value)\n\t                output_value = check_number(np_input_value)\n\t                self.assertEqual(output_value, input_value)\n\t                self.assertIsInstance(output_value, int)\n\t    def test_check_number_float(self):\n\t        \"\"\"Check float arguments.\"\"\"\n", "        for input_value in [-17.3, -2.0, -1.1, 0.0, 1.0, 17.2]:\n\t            output_value = check_number(input_value)\n\t            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, float)\n\t            # Check numpy float types.\n\t            for numpy_type in [np.float32, np.float64]:\n\t                np_input_value = numpy_type(input_value)\n\t                output_value = check_number(np_input_value)\n\t                np.testing.assert_allclose(output_value, input_value)\n\t                self.assertIsInstance(output_value, float)\n", "        # Check +0 and -0 float numbers are converted to 0.0.\n\t        for input_value in [float(\"+0.0\"), float(\"-0.0\")]:\n\t            output_value = check_number(input_value)\n\t            self.assertEqual(output_value, 0.0)\n\t            self.assertIsInstance(output_value, float)\n\t    def test_check_number_float_inf_nan(self):\n\t        \"\"\"Check float inf and nan arguments.\"\"\"\n\t        # Check ValueError is raised for special float +-inf, NaN.\n\t        for input_value in [\n\t            float(\"+inf\"),\n", "            float(\"-inf\"),\n\t            float(\"nan\"),\n\t            np.inf,\n\t            -np.inf,\n\t        ]:\n\t            with self.assertRaises(ValueError):\n\t                check_number(input_value)\n\t    def test_check_number_wrong_type(self):\n\t        \"\"\"Check TypeError is raised for wrong argument type.\"\"\"\n\t        for input_value in [\n", "            1.1 + 3.5j,  # Complex value\n\t            1.1 + 0j,  # Complex value with zero imaginary part\n\t            \"-17.3\",\n\t            \"a\",\n\t            [0.0],\n\t            [1.0, 17.2],\n\t            (np.pi,),\n\t            (2, 2.3),\n\t            None,\n\t        ]:\n", "            with self.assertRaises(TypeError):\n\t                check_number(input_value)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/helpers/test_helpers_check_integer.py", "chunked_list": ["\"\"\" Testing helpers functions (check_integer). \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer.__helpers import check_integer\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer.__helpers import check_integer\n\tclass TestHelpersCheckInteger(unittest.TestCase):\n\t    \"\"\"\n\t    Testing check_integer function.\n", "    \"\"\"\n\t    def test_check_integer_int(self):\n\t        \"\"\"Check integers.\"\"\"\n\t        for input_value in [-100, -3, -0, 0, 2, 100]:\n\t            output_value = check_integer(input_value)\n\t            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, int)\n\t            # Check numpy integer types.\n\t            for numpy_type in [np.int32, np.int64, np.int8]:\n\t                np_input_value = numpy_type(input_value)\n", "                output_value = check_integer(np_input_value)\n\t                self.assertEqual(output_value, input_value)\n\t                self.assertIsInstance(output_value, int)\n\t    def test_check_integer_float(self):\n\t        \"\"\"Check floats.\"\"\"\n\t        for input_value in [-100.0, -3.0, float(\"-0.0\"), 0.0, 2.0, 100.0]:\n\t            output_value = check_integer(input_value)\n\t            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, int)\n\t        # Check numpy float types.\n", "        for input_value in [-17.0, -2.0, -1.0, 0.0, 1.0, 137.0]:\n\t            for numpy_type in [np.float32, np.float64]:\n\t                np_input_value = numpy_type(input_value)\n\t                output_value = check_integer(np_input_value)\n\t                np.testing.assert_allclose(output_value, input_value)\n\t                self.assertIsInstance(output_value, int)\n\t    def test_check_integer_wrong_value(self):\n\t        \"\"\"\n\t        Check ValueError is raised for not integer argument values,\n\t        including special floats.\n", "        \"\"\"\n\t        for input_value in [\n\t            float(\"inf\"),\n\t            float(\"-inf\"),\n\t            float(\"nan\"),\n\t            np.inf,\n\t            -np.inf,\n\t            -27.1,\n\t            -22.2,\n\t            np.pi,\n", "        ]:\n\t            with self.assertRaises(ValueError):\n\t                check_integer(input_value)\n\t    def test_check_integer_wrong_type(self):\n\t        \"\"\"Check TypeError is raised for wrong argument type.\"\"\"\n\t        for input_value in [\n\t            1.1 + 3.2j,  # Complex number\n\t            3.14 + 0j,  # Complex number with zero imaginary part\n\t            \"-18.7\",\n\t            \"b\",\n", "            [0.0],\n\t            [1.1, 16.4],\n\t            (np.pi,),\n\t            (4, 2.3),\n\t            None,\n\t        ]:\n\t            with self.assertRaises(TypeError):\n\t                check_integer(input_value)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/helpers/test_helpers.py", "chunked_list": ["\"\"\" Testing helpers functions. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer.__helpers import (\n\t        check_not_negative,\n\t        check_positive,\n\t        clamp,\n\t        build_tuple,\n\t        adjust_tuple,\n", "    )\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer.__helpers import (\n\t        check_not_negative,\n\t        check_positive,\n\t        clamp,\n\t        build_tuple,\n\t        adjust_tuple,\n\t    )\n\tclass TestHelpers(unittest.TestCase):\n", "    \"\"\"Test case for helpers functions\"\"\"\n\t    def test_non_negative(self):\n\t        \"\"\"\n\t        Testing check_not_negative function.\n\t        \"\"\"\n\t        # Check integers.\n\t        for input_value in [100, 3, -0, 0, 2]:\n\t            output_value = check_not_negative(input_value)\n\t            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, int)\n", "        # Check floats.\n\t        for input_value in [100.0, 3.0, float(\"-0.0\"), 0.0, 2.0]:\n\t            output_value = check_not_negative(input_value)\n\t            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, float)\n\t        # Check numpy integer types.\n\t        for input_value in [17, 1, 0, 17]:\n\t            for numpy_type in [np.int32, np.int64, np.int8]:\n\t                np_input_value = numpy_type(input_value)\n\t                output_value = check_not_negative(np_input_value)\n", "                self.assertEqual(output_value, input_value)\n\t                self.assertIsInstance(output_value, int)\n\t        # Check numpy float types.\n\t        for input_value in [17.4, 2.0, 1.234, float(\"-0.0\"), 0.0, np.pi]:\n\t            for numpy_type in [np.float32, np.float64]:\n\t                np_input_value = numpy_type(input_value)\n\t                output_value = check_not_negative(np_input_value)\n\t                np.testing.assert_allclose(output_value, input_value)\n\t                self.assertIsInstance(output_value, float)\n\t        # Check ValueError raised for negative values.\n", "        for input_value in [-100, -2, -17.1, -2.2, -np.pi]:\n\t            with self.assertRaises(ValueError):\n\t                check_not_negative(input_value)\n\t        # Check ValueError raised for special floats +-inf, NaN.\n\t        for input_value in [float(\"inf\"), float(\"-inf\"), float(\"nan\")]:\n\t            with self.assertRaises(ValueError):\n\t                check_not_negative(input_value)\n\t        # Check TypeError is raised for wrong argument type.\n\t        for input_value in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n\t            with self.assertRaises(TypeError):\n", "                check_not_negative(input_value)\n\t    def test_positive(self):\n\t        \"\"\"\n\t        Testing check_positive function.\n\t        \"\"\"\n\t        # Check integers.\n\t        for input_value in [100, 3, 2]:\n\t            output_value = check_positive(input_value)\n\t            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, int)\n", "        # Check floats.\n\t        for input_value in [100.0, 3.0, 2.0]:\n\t            output_value = check_positive(input_value)\n\t            self.assertEqual(output_value, input_value)\n\t            self.assertIsInstance(output_value, float)\n\t        # Check numpy integer types.\n\t        for input_value in [17, 1, 17]:\n\t            for numpy_type in [np.int32, np.int64, np.int8]:\n\t                np_input_value = numpy_type(input_value)\n\t                output_value = check_positive(np_input_value)\n", "                self.assertEqual(output_value, input_value)\n\t                self.assertIsInstance(output_value, int)\n\t        # Check numpy float types.\n\t        for input_value in [17.4, 2.0, 1.234, np.pi]:\n\t            for numpy_type in [np.float32, np.float64]:\n\t                np_input_value = numpy_type(input_value)\n\t                output_value = check_positive(np_input_value)\n\t                np.testing.assert_allclose(output_value, input_value)\n\t                self.assertIsInstance(output_value, float)\n\t        # Check ValueError raised for negative and zero values.\n", "        for input_value in [-100, -2, -17.1, -2.2, -np.pi, 0, 0.0, float(\"-0.0\")]:\n\t            with self.assertRaises(ValueError):\n\t                check_positive(input_value)\n\t        # Check ValueError raised for special floats +-inf, NaN.\n\t        for input_value in [float(\"inf\"), float(\"-inf\"), float(\"nan\")]:\n\t            with self.assertRaises(ValueError):\n\t                check_positive(input_value)\n\t        # Check TypeError is raised for wrong argument type.\n\t        for input_value in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n\t            with self.assertRaises(TypeError):\n", "                check_positive(input_value)\n\t    def test_clamp(self):\n\t        \"\"\"\n\t        Testing clamp function normal operation.\n\t        \"\"\"\n\t        # Check non-zero width range.\n\t        left = -0.1  # float\n\t        right = 100  # int\n\t        for input_value in [\n\t            -1,\n", "            -1.0,\n\t            -0.1,\n\t            0,\n\t            1.5,\n\t            12,\n\t            100.0,\n\t            100,\n\t            101,\n\t            101.0,\n\t        ]:\n", "            for output_value in [\n\t                clamp(input_value, left, right),\n\t                clamp(input_value, right, left),\n\t            ]:\n\t                if min(left, right) <= input_value <= max(left, right):\n\t                    self.assertEqual(output_value, input_value)\n\t                elif input_value < min(left, right):\n\t                    self.assertEqual(output_value, min(left, right))\n\t                elif input_value > max(left, right):\n\t                    self.assertEqual(output_value, max(left, right))\n", "                # If input is a float number clamp must return float\n\t                if isinstance(input_value, float):\n\t                    self.assertIsInstance(output_value, float)\n\t        # Check zero width range.\n\t        left = 100.0  # float\n\t        right = 100  # int\n\t        for input_value in [-1, -1.0, 0.0, 0, 100.0, 100, 101, 101.0]:\n\t            for output_value in [\n\t                clamp(input_value, left, right),\n\t                clamp(input_value, right, left),\n", "            ]:\n\t                if min(left, right) <= input_value <= max(left, right):\n\t                    self.assertEqual(output_value, input_value)\n\t                if input_value < min(left, right):\n\t                    self.assertEqual(output_value, min(left, right))\n\t                if input_value > max(left, right):\n\t                    self.assertEqual(output_value, max(left, right))\n\t                # If input is a float number clamp must return float\n\t                if isinstance(input_value, float):\n\t                    self.assertIsInstance(output_value, float)\n", "    def test_clamp_errors(self):\n\t        \"\"\"\n\t        Testing clamp function errors.\n\t        \"\"\"\n\t        # Check TypeError is raised for wrong argument type.\n\t        for input_value in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n\t            with self.assertRaises(TypeError):\n\t                clamp(input_value, -10.0, 10)\n\t        for left in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n\t            with self.assertRaises(TypeError):\n", "                clamp(10, left, 10.0)\n\t        for right in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n\t            with self.assertRaises(TypeError):\n\t                clamp(10, -10, right)\n\t    def test_build_tuple(self):\n\t        \"\"\"\n\t        Testing build_tuple function normal operation.\n\t        \"\"\"\n\t        # Check normal operation: build tuple from single number.\n\t        for input_value in [-1.1, -1, -1.0, 0, 0.0, 1.0, 1, 1.1]:\n", "            for num in [1, 2, 3, 20, 3.0]:\n\t                for func in [lambda x: 2 * x, None]:\n\t                    output_value = build_tuple(input_value, num, func=func)\n\t                    self.assertEqual(len(output_value), num)\n\t                    for item in output_value:\n\t                        if func is None:\n\t                            self.assertEqual(item, input_value)\n\t                        else:\n\t                            self.assertEqual(item, func(input_value))\n\t                        self.assertIsInstance(\n", "                            item, float\n\t                        )  # build_tuple returns tuple of floats\n\t        # Check normal operation: apply func to given list or tuple.\n\t        for input_value in [[-1.1, -1, 3], (-1.0, 0, 0.0, 1.0, 1, 1.1)]:\n\t            for func in [lambda x: 2 * x, None]:\n\t                output_value = build_tuple(input_value, len(input_value), func=func)\n\t                self.assertEqual(len(output_value), len(input_value))\n\t                for item_out, item_in in zip(output_value, input_value):\n\t                    if func is None:\n\t                        self.assertEqual(item_out, item_in)\n", "                    else:\n\t                        self.assertEqual(item_out, func(item_in))\n\t                    self.assertIsInstance(\n\t                        item_out, float\n\t                    )  # build_tuple returns tuple of floats\n\t    def test_build_tuple_errors(self):\n\t        \"\"\"\n\t        Testing build_tuple function errors.\n\t        \"\"\"\n\t        # Check ValueError is raised for wrong number of elements\n", "        for input_value in [[2.1, np.pi], (0, 3.14, -4, 5.2)]:\n\t            with self.assertRaises(ValueError):\n\t                build_tuple(input_value, 3, func=None)\n\t        # Check ValueError is raised for wrong num parameter value\n\t        for num in [-3, 2.1, np.pi]:\n\t            with self.assertRaises(ValueError):\n\t                build_tuple(-10, num, func=None)\n\t        # Check TypeError is raised for wrong input value\n\t        for input_value in [\"a\", \"2\", [2.2, \"1.0\"], None]:\n\t            with self.assertRaises(TypeError):\n", "                build_tuple(input_value, 2, func=None)\n\t        # Check TypeError is raised for wrong num parameter value\n\t        for num in [\"a\", [1, 2, 3], \"2\", None]:\n\t            with self.assertRaises(TypeError):\n\t                build_tuple(-10, num, func=None)\n\t        # Check TypeError is raised for wrong func parameter value\n\t        for func in [2, \"a\", [1, 2, 3]]:\n\t            with self.assertRaises(TypeError):\n\t                build_tuple(-10, 2, func=func)\n\t    def test_adjust_tuple(self):\n", "        \"\"\"\n\t        Testing adjust_tuple function\n\t        \"\"\"\n\t        # Check truncate tuple or list\n\t        value = (1, 2.0, 3.0, 4.0, 5.0)  # int values will be converted to float\n\t        self.assertEqual(adjust_tuple(value, 2, default_value=4), (1.0, 2.0))\n\t        self.assertEqual(adjust_tuple(list(value), 2, default_value=4), (1.0, 2.0))\n\t        self.assertEqual(adjust_tuple(list(value), 2.0, default_value=4), (1.0, 2.0))\n\t        # Check grow tuple or list\n\t        value = (1, 2.0)  # int values will be converted to float\n", "        self.assertEqual(adjust_tuple(value, 4, default_value=4), (1.0, 2.0, 4.0, 4.0))\n\t        self.assertEqual(\n\t            adjust_tuple(list(value), 4, default_value=4), (1.0, 2.0, 4.0, 4.0)\n\t        )\n\t        # Check leave tuple or least unchanged\n\t        value = (1.0, 2.0, 3)  # int values will be converted to float\n\t        self.assertEqual(adjust_tuple(value, 3, default_value=4), (1.0, 2.0, 3.0))\n\t        self.assertEqual(adjust_tuple(list(value), 3, default_value=4), (1.0, 2.0, 3.0))\n\t        # Check TypeError is raised for wrong input value\n\t        for input_value in [1, 2.3, [\"a\", 2], (None, 1.1), None]:\n", "            with self.assertRaises(TypeError):\n\t                adjust_tuple(input_value, 2, default_value=4)\n\t        # Check TypeError is raised for wrong num value\n\t        for num in [\"1\", [\"a\", 2], (None, 1.1), None]:\n\t            with self.assertRaises(TypeError):\n\t                adjust_tuple((1.0, 2.2), num, default_value=4)\n\t        # Check ValueError is raised for wrong num value\n\t        for num in [-3, -1.0, 2.3]:\n\t            with self.assertRaises(ValueError):\n\t                adjust_tuple((1.0, 2.2), num, default_value=4)\n", "        # Check TypeError is raised for wrong default value\n\t        for default_value in [\"1\", [\"a\", 2], (None, 1.1), None]:\n\t            with self.assertRaises(TypeError):\n\t                adjust_tuple((1.0, 2.2), 2, default_value=default_value)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_constructor.py", "chunked_list": ["\"\"\" Tests for DigitalWiper constructor. \"\"\"\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperConstructor(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper constructor.\n\t    \"\"\"\n", "    def test_constructor(self) -> None:\n\t        \"\"\"\n\t        Test DigitalWiper constructor\n\t        \"\"\"\n\t        pot = Potentiometer(r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False)\n\t        # Normal constructor parameters\n\t        for locked in [True, False]:\n\t            for max_value in [1, 10, 128, 1024]:\n\t                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n", "                )\n\t                self.assertEqual(digital_wiper.potentiometer, pot)\n\t                self.assertEqual(digital_wiper.parameters_locked, locked)\n\t                self.assertEqual(digital_wiper.max_value, max_value)\n\t        # Wrong potentiometer type\n\t        for locked in [True, False]:\n\t            for pot_ in [None, \"pot\"]:\n\t                with self.assertRaises(TypeError):\n\t                    _ = DigitalWiper(\n\t                        potentiometer=pot_, max_value=128, parameters_locked=locked\n", "                    )\n\t        # Wrong max_value type\n\t        for locked in [True, False]:\n\t            for max_value in [None, \"128\"]:\n\t                with self.assertRaises(TypeError):\n\t                    _ = DigitalWiper(\n\t                        potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                    )\n\t        # Wrong max_value value\n\t        for locked in [True, False]:\n", "            for max_value in [0, -128, 12.6]:\n\t                with self.assertRaises(ValueError):\n\t                    _ = DigitalWiper(\n\t                        potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                    )\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_fixed_resistors.py", "chunked_list": ["\"\"\" Tests for DigitalWiper fixed resistors. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperFixedResistors(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper fixed resistors.\n", "    \"\"\"\n\t    def test_r_lim(self):\n\t        \"\"\"\n\t        Tests current limiting resistor value altering.\n\t        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=200e3, r_w=375, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 14, 43]:\n", "                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n\t                # Correct values (positive float numbers)\n\t                for resistance in np.linspace(0, 104, num=101, endpoint=True):\n\t                    digital_wiper.r_lim = resistance\n\t                    self.assertEqual(digital_wiper.r_lim, resistance)\n\t                    self.assertEqual(\n\t                        digital_wiper.r_lim, digital_wiper.potentiometer.r_lim\n\t                    )\n", "                # Wrong values\n\t                for resistance in [-200.4, -1]:\n\t                    with self.assertRaises(ValueError):\n\t                        digital_wiper.r_lim = resistance\n\t                # Wrong type\n\t                for resistance in [None, \"100.2\"]:\n\t                    with self.assertRaises(TypeError):\n\t                        digital_wiper.r_lim = resistance\n\t    def test_r_load(self):\n\t        \"\"\"\n", "        Tests load resistor value altering.\n\t        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=170e3, r_w=145, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 26, 51]:\n\t                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n", "                # Correct values (positive float numbers)\n\t                for resistance in np.linspace(0, 10e4, num=101, endpoint=True):\n\t                    digital_wiper.r_load = resistance\n\t                    self.assertEqual(digital_wiper.r_load, resistance)\n\t                    self.assertEqual(\n\t                        digital_wiper.r_load, digital_wiper.potentiometer.r_load\n\t                    )\n\t                # Wrong values\n\t                for resistance in [-200.4, -1]:\n\t                    with self.assertRaises(ValueError):\n", "                        digital_wiper.r_load = resistance\n\t                # Wrong type\n\t                for resistance in [None, \"100.2\"]:\n\t                    with self.assertRaises(TypeError):\n\t                        digital_wiper.r_load = resistance\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_value.py", "chunked_list": ["\"\"\" Tests for DigitalWiper value get and set operations. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperValue(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper `value` property.\n", "    \"\"\"\n\t    def test_value_get_set(self):\n\t        \"\"\"\n\t        Testing `value` property.\n\t        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=100e3, r_w=175, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 16, 31]:\n", "                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n\t                # Correct values\n\t                for value_new in np.arange(max_value):\n\t                    digital_wiper.value = value_new\n\t                    self.assertEqual(digital_wiper.value, value_new)\n\t                # Check correct float values\n\t                for value_new in [0.0, 1.0]:\n\t                    digital_wiper.value = value_new\n", "                    self.assertEqual(digital_wiper.value, value_new)\n\t                # Values less than 0 will be clamped to zero\n\t                for value_new in [-10, -1, 0]:\n\t                    digital_wiper.value = value_new\n\t                    self.assertEqual(digital_wiper.value, 0)\n\t                # Values greater than max_value will be clamped to max_value\n\t                for value_new in [max_value, max_value + 1, max_value + 10]:\n\t                    digital_wiper.value = value_new\n\t                    self.assertEqual(digital_wiper.value, max_value)\n\t                    self.assertEqual(digital_wiper.value, digital_wiper.max_value)\n", "        # Wrong parameter value (non int number)\n\t        for value_new in [-1.1, 0.2, 12.5]:\n\t            with self.assertRaises(ValueError):\n\t                digital_wiper.value = value_new\n\t        # Wrong parameter type\n\t        for value_new in [None, \"1\"]:\n\t            with self.assertRaises(TypeError):\n\t                digital_wiper.value = value_new\n\t    def test_value_relative(self):\n\t        \"\"\"\n", "        Test relative value calculation.\n\t        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=100e3, r_w=175, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 16, 31]:\n\t                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n", "                # Correct values\n\t                for value_r_new in np.linspace(0, 1, num=51, endpoint=True):\n\t                    digital_wiper.value_relative = value_r_new\n\t                    value_int = int(round(value_r_new * digital_wiper.max_value))\n\t                    value_r_new_coerced = value_int / digital_wiper.max_value\n\t                    self.assertEqual(digital_wiper.value_relative, value_r_new_coerced)\n\t                    self.assertEqual(digital_wiper.value, value_int)\n\t                # Values less than 0 will be clamped to zero\n\t                for value_r_new in [-10.2, -3.3, -1, 0, 0.0]:\n\t                    digital_wiper.value_relative = value_r_new\n", "                    self.assertEqual(digital_wiper.value_relative, 0)\n\t                    self.assertEqual(digital_wiper.value, 0)\n\t                # Values greater than 1 will be clamped to 1\n\t                for value_r_new in [1, 1.0, 1.1, 12, 35.6]:\n\t                    digital_wiper.value_relative = value_r_new\n\t                    self.assertEqual(digital_wiper.value_relative, 1)\n\t                    self.assertEqual(digital_wiper.value, max_value)\n\t                    self.assertEqual(digital_wiper.value, digital_wiper.max_value)\n\t        # Wrong parameter type\n\t        for value_r_new in [None, \"1\"]:\n", "            with self.assertRaises(TypeError):\n\t                digital_wiper.value_relative = value_r_new\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_channel_numbering.py", "chunked_list": ["\"\"\" Tests for DigitalWiper channel numbering. \"\"\"\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperChannelNumbering(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper channel numbering.\n\t    \"\"\"\n", "    def test_channel_numbering(self):\n\t        \"\"\"\n\t        Testing channel numbering.\n\t        DigitalWiper Channel is a channel of the actual digital potentiometer device,\n\t        numbered in int numbers starting from 0.\n\t        \"\"\"\n\t        pot = Potentiometer(r_ab=20e3, r_w=50, rheostat=False, parameters_locked=False)\n\t        for locked in [True, False]:\n\t            for max_value in [1, 64, 128, 256]:\n\t                digital_wiper = DigitalWiper(\n", "                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n\t                self.assertEqual(\n\t                    digital_wiper.channel, 0\n\t                )  # default channel number is 0\n\t                # Correct channel numbers\n\t                for channel_number in [3, 4.0, 1234, 0, 17]:\n\t                    digital_wiper.channel = channel_number\n\t                    self.assertEqual(digital_wiper.channel, channel_number)\n\t                # Wrong channel number value\n", "                for channel_number_ in [-1, 1.12]:\n\t                    with self.assertRaises(ValueError):\n\t                        digital_wiper.channel = channel_number_\n\t                # Wrong channel number type\n\t                for channel_number_ in [\"1\", None]:\n\t                    with self.assertRaises(TypeError):\n\t                        digital_wiper.channel = channel_number_\n\t                self.assertEqual(\n\t                    digital_wiper.channel, channel_number\n\t                )  # Check that channel number did not_change\n", "if __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_rwa_rwb.py", "chunked_list": ["\"\"\" Tests for DigitalWiper `r_wa` and `r_wb` calculations. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperRwaRwb(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper `r_wa` and `r_wb` calculations.\n", "    \"\"\"\n\t    def test_rwa_rwb(self):\n\t        \"\"\"\n\t        Test `r_wa` and `r_wb` properties.\n\t        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=111e3, r_w=174, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 26, 41]:\n", "                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n\t                # Correct values\n\t                for resistance in np.linspace(\n\t                    pot.r_w, pot.r_ab + pot.r_w, num=101, endpoint=True\n\t                ):\n\t                    digital_wiper.r_wa = resistance\n\t                    pos = digital_wiper.value_relative\n\t                    self.assertEqual(\n", "                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos)\n\t                    )\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos)\n\t                    )\n\t                    digital_wiper.r_wb = resistance\n\t                    pos = digital_wiper.value_relative\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos)\n\t                    )\n", "                    self.assertEqual(\n\t                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos)\n\t                    )\n\t                # Values less than r_w are clamped to r_w\n\t                for resistance in [-10.2, 0, pot.r_w - 0.1, pot.r_w]:\n\t                    digital_wiper.r_wa = resistance\n\t                    pos_req = digital_wiper.value_relative\n\t                    digital_wiper.r_wa = pot.r_w\n\t                    pos_r_w = digital_wiper.value_relative\n\t                    self.assertEqual(pos_req, pos_r_w)\n", "                    self.assertEqual(\n\t                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_w)\n\t                    )\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_w)\n\t                    )\n\t                    digital_wiper.r_wb = resistance\n\t                    pos_req = digital_wiper.value_relative\n\t                    digital_wiper.r_wb = pot.r_w\n\t                    pos_r_w = digital_wiper.value_relative\n", "                    self.assertEqual(pos_req, pos_r_w)\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_w)\n\t                    )\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_w)\n\t                    )\n\t                # Values greater than r_ab + r_w are clamped to r_ab + r_w\n\t                for resistance in [\n\t                    pot.r_ab + pos_r_w * 10,\n", "                    pot.r_ab + pos_r_w + 0.1,\n\t                    pot.r_ab + pos_r_w,\n\t                ]:\n\t                    digital_wiper.r_wa = resistance\n\t                    pos_req = digital_wiper.value_relative\n\t                    digital_wiper.r_wa = pot.r_ab + pos_r_w\n\t                    pos_r_max = digital_wiper.value_relative\n\t                    self.assertEqual(pos_req, pos_r_max)\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_max)\n", "                    )\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_max)\n\t                    )\n\t                    digital_wiper.r_wb = resistance\n\t                    pos_req = digital_wiper.value_relative\n\t                    digital_wiper.r_wb = pot.r_ab + pos_r_w\n\t                    pos_r_max = digital_wiper.value_relative\n\t                    self.assertEqual(pos_req, pos_r_max)\n\t                    self.assertEqual(\n", "                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_max)\n\t                    )\n\t                    self.assertEqual(\n\t                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_max)\n\t                    )\n\t                # Wrong value type\n\t                for resistance in [None, \"5.1\"]:\n\t                    with self.assertRaises(TypeError):\n\t                        digital_wiper.r_wa = resistance\n\t                    with self.assertRaises(TypeError):\n", "                        digital_wiper.r_wb = resistance\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_constructor_spi.py", "chunked_list": ["\"\"\" Tests for SpiDigitalWiper class constructor. \"\"\"\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, SpiDigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, SpiDigitalWiper\n\tclass TestSpiDigitalWiperConstructor(unittest.TestCase):\n\t    \"\"\"\n\t    Testing SpiDigitalWiper constructor.\n\t    \"\"\"\n", "    def setUp(self) -> None:\n\t        \"\"\"\n\t        Set up Unittest\n\t        \"\"\"\n\t        self.pot = Potentiometer(\n\t            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n\t        )\n\t        self.spi_digital_wiper = SpiDigitalWiper(\n\t            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n\t        )\n", "    def test_spi_digital_wiper(self):\n\t        \"\"\"\n\t        Test SpiDigitalWiper constructor (without SPI interface).\n\t        \"\"\"\n\t        digital_wiper = SpiDigitalWiper(\n\t            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n\t        )\n\t        self.assertEqual(digital_wiper.spi, None)\n\t        digital_wiper.spi = None\n\t        self.assertEqual(digital_wiper.spi, None)\n", "if __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_voltage_out.py", "chunked_list": ["\"\"\" Tests for DigitalWiper output voltage property. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperVoltageOut(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper `voltage_out`.\n", "    \"\"\"\n\t    def test_voltage_out(self):\n\t        \"\"\"\n\t        Test output voltage property and methods.\n\t        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=101e3, r_w=185, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 15, 33]:\n", "                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n\t                digital_wiper.r_lim = 123.5\n\t                digital_wiper.r_load = 1e6\n\t                # Correct values (positive float numbers)\n\t                digital_wiper.voltage_in = 5\n\t                for voltage in np.linspace(0, 5, num=13, endpoint=True):\n\t                    digital_wiper.voltage_out = voltage\n\t                    np.testing.assert_allclose(\n", "                        digital_wiper.voltage_out,\n\t                        digital_wiper.potentiometer.voltage_out(\n\t                            digital_wiper.value_relative\n\t                        ),\n\t                    )\n\t                for voltage in np.linspace(-5, 0, num=13, endpoint=True):\n\t                    digital_wiper.voltage_out = voltage\n\t                    self.assertEqual(digital_wiper.voltage_out, 0)\n\t                digital_wiper.voltage_in = -5\n\t                for voltage in np.linspace(-5, 0, num=13, endpoint=True):\n", "                    digital_wiper.voltage_out = voltage\n\t                    np.testing.assert_allclose(\n\t                        digital_wiper.voltage_out,\n\t                        digital_wiper.potentiometer.voltage_out(\n\t                            digital_wiper.value_relative\n\t                        ),\n\t                    )\n\t                for voltage in np.linspace(0, 5, num=13, endpoint=True):\n\t                    digital_wiper.voltage_out = voltage\n\t                    self.assertEqual(digital_wiper.voltage_out, 0)\n", "                digital_wiper.voltage_in = 0\n\t                for voltage in np.linspace(-5, 5, num=13, endpoint=True):\n\t                    digital_wiper.voltage_out = voltage\n\t                    self.assertEqual(digital_wiper.voltage_out, 0)\n\t                digital_wiper.r_load = 0\n\t                digital_wiper.voltage_in = 5\n\t                for voltage in np.linspace(-5, 5, num=13, endpoint=True):\n\t                    digital_wiper.voltage_out = voltage\n\t                    self.assertEqual(digital_wiper.voltage_out, 0)\n\t                # Wrong type\n", "                for voltage in [None, \"100.2\"]:\n\t                    with self.assertRaises(TypeError):\n\t                        digital_wiper.voltage_out = voltage\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_min_max_value.py", "chunked_list": ["\"\"\" Tests for DigitalWiper min max value properties. \"\"\"\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperMinMaxValue(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper `min_value` and `max_value` properties.\n\t    \"\"\"\n", "    def test_min_value(self):\n\t        \"\"\"\n\t        Testing `min_value` property.\n\t        Should always be zero and can not be changed&\n\t        \"\"\"\n\t        pot = Potentiometer(r_ab=50e3, r_w=200, rheostat=False, parameters_locked=False)\n\t        for locked in [True, False]:\n\t            for max_value in [1, 32, 64, 256]:\n\t                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n", "                )\n\t                self.assertEqual(digital_wiper.min_value, 0)\n\t                for min_value_ in [None, -1, 1, \"1\", \"0\", 0]:\n\t                    with self.assertRaises(AttributeError):\n\t                        digital_wiper.min_value = min_value_\n\t    def test_max_value(self):\n\t        \"\"\"\n\t        Testing `max_value` property.\n\t        In contrast with `min_value`, `max_value` can be altered unless wiper is locked.\n\t        `max_value` must be positive int number.\n", "        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=100e3, r_w=175, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 16, 32, 2048]:\n\t                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n\t                self.assertEqual(digital_wiper.max_value, max_value)\n", "                # Correct values\n\t                for max_value_new in [1, 10, 128, 1024, 128.0]:\n\t                    digital_wiper.max_value = max_value_new\n\t                    # Check that parameters_locked locks the max_value\n\t                    if not digital_wiper.parameters_locked:\n\t                        self.assertEqual(digital_wiper.max_value, max_value_new)\n\t                    else:\n\t                        self.assertEqual(digital_wiper.max_value, max_value)\n\t                # Wrong value\n\t                for max_value_ in [0, -1, -10, 128.5]:\n", "                    with self.assertRaises(ValueError):\n\t                        digital_wiper.max_value = max_value_\n\t                # Wrong type\n\t                for max_value_ in [None, \"1\"]:\n\t                    with self.assertRaises(TypeError):\n\t                        digital_wiper.max_value = max_value_\n\t                # Check that value did not change\n\t                if not digital_wiper.parameters_locked:\n\t                    self.assertEqual(digital_wiper.max_value, max_value_new)\n\t                else:\n", "                    self.assertEqual(digital_wiper.max_value, max_value)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_deep_copy_spi.py", "chunked_list": ["\"\"\" Tests for DigitalWiper class deep copy. \"\"\"\n\tfrom copy import deepcopy\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, SpiDigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, SpiDigitalWiper\n\tclass TestSpiDigitalWiperDeepCopy(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper deep copy.\n", "    \"\"\"\n\t    def setUp(self) -> None:\n\t        \"\"\"\n\t        Set up Unittest\n\t        \"\"\"\n\t        self.pot = Potentiometer(\n\t            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n\t        )\n\t        self.spi_digital_wiper = SpiDigitalWiper(\n\t            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n", "        )\n\t    def test_spi_deepcopy(self):\n\t        \"\"\"\n\t        Test deepcopy for SpiDigitalWiper.\n\t        \"\"\"\n\t        self.spi_digital_wiper.r_lim = 200\n\t        self.spi_digital_wiper.r_load = 1e100\n\t        self.spi_digital_wiper.voltage_in = 5\n\t        dw_copy = deepcopy(self.spi_digital_wiper)\n\t        self.assertIsInstance(dw_copy, SpiDigitalWiper)\n", "        self.assertNotEqual(dw_copy, self.spi_digital_wiper)\n\t        self.assertNotEqual(dw_copy.potentiometer, self.spi_digital_wiper.potentiometer)\n\t        self.assertEqual(dw_copy.min_value, self.spi_digital_wiper.min_value)\n\t        self.assertEqual(dw_copy.max_value, self.spi_digital_wiper.max_value)\n\t        self.assertEqual(\n\t            dw_copy.potentiometer.r_ab, self.spi_digital_wiper.potentiometer.r_ab\n\t        )\n\t        self.assertEqual(\n\t            dw_copy.potentiometer.r_w, self.spi_digital_wiper.potentiometer.r_w\n\t        )\n", "        self.assertEqual(\n\t            dw_copy.potentiometer.r_lim, self.spi_digital_wiper.potentiometer.r_lim\n\t        )\n\t        self.assertEqual(\n\t            dw_copy.potentiometer.r_load, self.spi_digital_wiper.potentiometer.r_load\n\t        )\n\t        self.assertEqual(\n\t            dw_copy.potentiometer.voltage_in,\n\t            self.spi_digital_wiper.potentiometer.voltage_in,\n\t        )\n", "        self.assertEqual(dw_copy.spi, self.spi_digital_wiper.spi)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_voltage_in.py", "chunked_list": ["\"\"\" Tests for DigitalWiper input voltage property. \"\"\"\n\timport unittest\n\timport numpy as np\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperVoltageIn(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper `voltage_in`.\n", "    \"\"\"\n\t    def test_voltage_in(self):\n\t        \"\"\"\n\t        Test input voltage property and methods.\n\t        \"\"\"\n\t        pot = Potentiometer(\n\t            r_ab=104e3, r_w=275, rheostat=False, parameters_locked=False\n\t        )\n\t        for locked in [True, False]:\n\t            for max_value in [1, 11, 37]:\n", "                digital_wiper = DigitalWiper(\n\t                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n\t                )\n\t                # Correct values (positive float numbers)\n\t                for voltage in np.linspace(-51, 51, num=107, endpoint=True):\n\t                    digital_wiper.voltage_in = voltage\n\t                    self.assertEqual(digital_wiper.voltage_in, voltage)\n\t                    self.assertEqual(\n\t                        digital_wiper.voltage_in, digital_wiper.potentiometer.voltage_in\n\t                    )\n", "                digital_wiper.voltage_in = 0\n\t                self.assertEqual(digital_wiper.voltage_in, 0)\n\t                self.assertEqual(\n\t                    digital_wiper.voltage_in, digital_wiper.potentiometer.voltage_in\n\t                )\n\t                # Wrong type\n\t                for voltage in [None, \"100.2\"]:\n\t                    with self.assertRaises(TypeError):\n\t                        digital_wiper.voltage_in = voltage\n\tif __name__ == \"__main__\":\n", "    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_deep_copy.py", "chunked_list": ["\"\"\" Tests for DigitalWiper class deep copy. \"\"\"\n\tfrom copy import deepcopy\n\timport unittest\n\ttry:\n\t    from src.BDPotentiometer import Potentiometer, DigitalWiper\n\texcept ModuleNotFoundError:\n\t    from BDPotentiometer import Potentiometer, DigitalWiper\n\tclass TestDigitalWiperDeepCopy(unittest.TestCase):\n\t    \"\"\"\n\t    Testing DigitalWiper deep copy.\n", "    \"\"\"\n\t    def setUp(self) -> None:\n\t        \"\"\"\n\t        Set up Unittest\n\t        \"\"\"\n\t        self.pot = Potentiometer(\n\t            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n\t        )\n\t        self.digital_wiper = DigitalWiper(\n\t            potentiometer=self.pot, max_value=128, parameters_locked=False\n", "        )\n\t        self.digital_wiper_locked = DigitalWiper(\n\t            potentiometer=self.pot, max_value=128, parameters_locked=True\n\t        )\n\t    def test_deepcopy(self):\n\t        \"\"\"\n\t        Test deepcopy.\n\t        \"\"\"\n\t        self.digital_wiper.r_lim = 200\n\t        self.digital_wiper.r_load = 1e100\n", "        self.digital_wiper.voltage_in = 5\n\t        dw_copy = deepcopy(self.digital_wiper)\n\t        self.assertIsInstance(dw_copy, DigitalWiper)\n\t        self.assertNotEqual(dw_copy, self.digital_wiper)\n\t        self.assertNotEqual(dw_copy.potentiometer, self.digital_wiper.potentiometer)\n\t        self.assertEqual(dw_copy.min_value, self.digital_wiper.min_value)\n\t        self.assertEqual(dw_copy.max_value, self.digital_wiper.max_value)\n\t        self.assertEqual(\n\t            dw_copy.potentiometer.r_ab, self.digital_wiper.potentiometer.r_ab\n\t        )\n", "        self.assertEqual(\n\t            dw_copy.potentiometer.r_w, self.digital_wiper.potentiometer.r_w\n\t        )\n\t        self.assertEqual(\n\t            dw_copy.potentiometer.r_lim, self.digital_wiper.potentiometer.r_lim\n\t        )\n\t        self.assertEqual(\n\t            dw_copy.potentiometer.r_load, self.digital_wiper.potentiometer.r_load\n\t        )\n\t        self.assertEqual(\n", "            dw_copy.potentiometer.voltage_in,\n\t            self.digital_wiper.potentiometer.voltage_in,\n\t        )\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "examples/mcp4231.py", "chunked_list": ["\"\"\" Example of MCP4231 usage \"\"\"\n\tfrom BDPotentiometer.mcp4xxx import MCP4231\n\t# Create potentiometer with total resistance 10 kOhm\n\tmy_pot = MCP4231(r_ab=10e3, device=0)\n\t# Label the two available channels with meaningful names\n\tmy_pot.set_channel_label(0, \"V_CTRL\")\n\tmy_pot.set_channel_label(1, \"AMPL\")\n\t# Set current limiting resistor value for V_CTRL channel\n\tmy_pot.set_r_lim(\"V_CTRL\", 1.1e3)\n\t# The properties are also available\n", "my_pot.r_lim = (1.1e3, 0)\n\tprint(f\"Current limiting resistors: {my_pot.r_lim}\")\n\t# Set load resistor value for V_CTRL channel\n\tmy_pot.set_r_load(\"V_CTRL\", 50e3)\n\tmy_pot.r_load = (100e3, 1e3)\n\tprint(f\"Load resistors: {my_pot.r_load}\")\n\t# Set input voltage\n\tmy_pot.set_voltage_in(\"V_CTRL\", 5.0)\n\tmy_pot.voltage_in = (5.0, 0.0)\n\tprint(f\"Input voltage: {my_pot.voltage_in}\")\n", "# All Done! Now you can control the pot\n\tmy_pot.set_voltage_out(\"V_CTRL\", 3.3)\n\tmy_pot.voltage_out = (3.7, 0)\n\tprint(f\"Output voltage: {my_pot.voltage_out}\")\n\t# You can also control the resistance\n\tmy_pot.set_r_wb(\"AMPL\", 1e3)\n\t# OR\n\tmy_pot.set_r_wa(\"AMPL\", 9e3)\n\t# You can also set pot's winder position to exact value\n\tmy_pot.set_value(\"AMPL\", 64)\n", "print(f\"Winder position for AMPL channel is {my_pot.get_value('AMPL')}\")\n\tprint(f\"Winder position for all channels: {my_pot.value}\")\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t# pylint: skip-file\n\t# -- Project information\n\tproject = \"BDPotentiometer\"\n\tcopyright = \"2023, Anton Bondarenko\"\n\tauthor = \"Anton Bondarenko\"\n\trelease = \"0.0.2\"\n\tversion = \"0.0.2\"\n\t# -- General configuration\n\textensions = [\n", "    \"sphinx.ext.duration\",\n\t    \"sphinx.ext.doctest\",\n\t    \"sphinx.ext.autodoc\",\n\t    \"sphinx.ext.autosummary\",\n\t    \"sphinx.ext.intersphinx\",\n\t]\n\tintersphinx_mapping = {\n\t    \"python\": (\"https://docs.python.org/3/\", None),\n\t    \"sphinx\": (\"https://www.sphinx-doc.org/en/master/\", None),\n\t}\n", "intersphinx_disabled_domains = [\"std\"]\n\ttemplates_path = [\"_templates\"]\n\t# -- Options for HTML output\n\thtml_theme = \"sphinx_rtd_theme\"\n\t# -- Options for EPUB output\n\tepub_show_urls = \"footnote\"\n"]}
{"filename": "src/BDPotentiometer/__helpers.py", "chunked_list": ["\"\"\"This module contains internal helper functions and not supposed to be used outside.\"\"\"\n\tfrom numbers import Real, Integral\n\tfrom math import isnan\n\tfrom typing import Union, Callable\n\tdef check_number(num: Union[float, int, Real]) -> Union[float, int]:\n\t    \"\"\"\n\t    Checks if argument is a real number.\n\t    check_number does not allow argument to be `+inf` or `-inf`, or `NaN`.\n\t    Special float numbers `+0.0` and `-0.0` will be converted to just 0.0\n\t    :param num: variable to check.\n", "    :return: Unchanged `num` as float or int or raises ValueError if num is not a real number.\n\t    \"\"\"\n\t    if not isinstance(num, Real):\n\t        raise TypeError(f\"Expected integer or float number, got {type(num)}\")\n\t    if isinstance(num, Integral):\n\t        return int(num)\n\t    if num in [float(\"inf\"), float(\"-inf\")]:\n\t        raise ValueError(f\"Expected integer or float number, got {num}\")\n\t    if isnan(num):\n\t        raise ValueError(\"Expected integer or float number, not NaN\")\n", "    if num == 0:\n\t        return 0.0\n\t    return float(num)\n\tdef check_integer(num: Union[float, int, Real]) -> int:\n\t    \"\"\"\n\t    Checks if `num` is an integer and converts it to int, otherwise raises ValueError.\n\t    :param num: Number (either int or float) to be checked.\n\t    :return: int representation of `num` or rises ValueError.\n\t    \"\"\"\n\t    num = check_number(num)\n", "    if isinstance(num, float):\n\t        if not num.is_integer():\n\t            raise ValueError(\"Argument should be integer number\")\n\t    return int(num)\n\tdef check_not_negative(num: Union[float, int]) -> Union[float, int]:\n\t    \"\"\"\n\t    Checks if `num` is a not negative number, otherwise rises ValueError.\n\t    :param num: Either float or int number.\n\t    :return: `num` if it is not negative or rises ValueError.\n\t    \"\"\"\n", "    num = check_number(num)\n\t    if num < 0:\n\t        raise ValueError(\"Argument should be not negative number\")\n\t    return num\n\tdef check_positive(num: Union[float, int]) -> Union[float, int]:\n\t    \"\"\"\n\t    Checks if `num` is a positive number, otherwise rises ValueError.\n\t    :param num: Either float or int number.\n\t    :return: `num` if it is positive or rises ValueError.\n\t    \"\"\"\n", "    num = check_number(num)\n\t    if num <= 0:\n\t        raise ValueError(\"Argument should be a positive number\")\n\t    return num\n\tdef clamp(\n\t    value: Union[float, int], min_value: Union[float, int], max_value: Union[float, int]\n\t) -> Union[float, int]:\n\t    \"\"\"\n\t    Clamp `value` to given range between `min_value` and `max_value`.\n\t    :param value: Either float or int number to be coerced.\n", "    :param min_value: Lower coerce range boundary.\n\t    :param max_value: Upper coerce range boundary.\n\t    :return: Value coerced to given range.\n\t    \"\"\"\n\t    value = check_number(value)\n\t    min_value = check_number(min_value)\n\t    max_value = check_number(max_value)\n\t    if min_value > max_value:\n\t        min_value, max_value = max_value, min_value\n\t    if value < min_value:\n", "        if isinstance(value, float):\n\t            return float(min_value)\n\t        return min_value\n\t    if value > max_value:\n\t        if isinstance(value, float):\n\t            return float(max_value)\n\t        return max_value\n\t    return value\n\tdef build_tuple(\n\t    value: Union[float, int, tuple[float, ...], list[float, ...]],\n", "    num: Union[int, float],\n\t    func: Union[Callable, None] = None,\n\t) -> tuple[float, ...]:\n\t    \"\"\"\n\t    Builds tuple of floats of given length by applying a callable `func` to value.\n\t    If `value` is an iterable (either list or tuple) its length must be equal to `num`.\n\t    The `func` will be applied to each element of the iterable.\n\t    If `value` is a number the resulting tuple of length `num` will be built of same `func(value)`\n\t    elements converted to float.\n\t    If `func` is None the `value` will enter resulting tuple unchanged.\n", "    :param value: Iterable (either list or tuple) or a number.\n\t    :param num: A number of elements in a tuple.\n\t    :param func: Callable to be applied to `value` or None for identity function.\n\t    :return: A tuple of floats of length `num` produced by application of `func` to `value`.\n\t    \"\"\"\n\t    def identity(val: float) -> float:\n\t        return val\n\t    if not isinstance(value, (float, int, tuple, list)):\n\t        raise TypeError(\"Argument should be a number or list or tuple of numbers\")\n\t    num = check_integer(check_positive(num))\n", "    if func is not None:\n\t        if not callable(func):\n\t            raise TypeError(\"function must be callable or None\")\n\t    else:\n\t        func = identity\n\t    if isinstance(value, (list, tuple)):\n\t        if len(value) != num:\n\t            raise ValueError(f\"A tuple or list of length {num} expected\")\n\t        return tuple(float(func(check_number(value_i))) for value_i in value)\n\t    value = check_number(value)\n", "    return tuple(float(func(value)) for _ in range(num))\n\tdef adjust_tuple(\n\t    value: Union[tuple[float, ...], list[float, ...]], num: int, default_value: float\n\t) -> tuple[float, ...]:\n\t    \"\"\"\n\t    Adjusts tuple or list of floats to a given length `num` and returns a tuple.\n\t    if `num` is less than initial length of the tuple it will be truncated to first `num` elements,\n\t    otherwise it will be appended using `default_value` parameter.\n\t    :param value: Initial iterable (either tuple or list) of float values.\n\t    :param num: Final length of the tuple.\n", "    :param default_value: Default value to populate the tuple if it needs to be grown.\n\t    :return: A tuple of floats of length `num`.\n\t    \"\"\"\n\t    if not isinstance(value, (tuple, list)):\n\t        raise TypeError(\"Argument should be a list or a tuple of numbers\")\n\t    num = check_integer(check_positive(num))\n\t    default_value = float(check_number(default_value))\n\t    if len(value) < num:\n\t        return tuple(\n\t            [float(check_number(value_i)) for value_i in value]\n", "            + [default_value] * (num - len(value))\n\t        )\n\t    if len(value) > num:\n\t        return tuple(float(check_number(value[i])) for i in range(num))\n\t    return tuple(float(check_number(value_i)) for value_i in value)\n"]}
{"filename": "src/BDPotentiometer/digital_wiper.py", "chunked_list": ["\"\"\" Module contains basic digital wiper class implementation \"\"\"\n\tfrom copy import deepcopy\n\tfrom typing import Union\n\tfrom gpiozero import SPI\n\tfrom .potentiometer import Potentiometer\n\tfrom .__helpers import check_integer, check_positive, check_not_negative, clamp\n\tclass DigitalWiper:\n\t    \"\"\"\n\t    Generic digital wiper class.\n\t    Digital wiper change position by discrete movement between 0 and `max_value`.\n", "    Property `parameters_locked` is used to disable change of `max_value`\n\t    parameter after object is created, only wiper position change is allowed.\n\t    \"\"\"\n\t    # pylint: disable=too-many-instance-attributes\n\t    def __init__(\n\t        self,\n\t        potentiometer: Potentiometer,\n\t        max_value: int = 128,\n\t        parameters_locked: bool = False,\n\t    ) -> None:\n", "        self.__parameters_locked: bool = bool(parameters_locked)\n\t        if isinstance(potentiometer, Potentiometer):\n\t            self.__potentiometer: Potentiometer = potentiometer\n\t        else:\n\t            raise TypeError(\n\t                f\"Expected an instance of Potentiometer class, got {type(potentiometer)}\"\n\t            )\n\t        self.__channel: int = 0\n\t        self.__max_value: int = check_integer(check_positive(max_value))\n\t        self.__value: int = 0\n", "        self.read()\n\t    @property\n\t    def parameters_locked(self) -> bool:\n\t        \"\"\"\n\t        Check if parameters of the wiper are locked.\n\t        :return: True if locked and False otherwise\n\t        \"\"\"\n\t        return self.__parameters_locked\n\t    @property\n\t    def potentiometer(self) -> Potentiometer:\n", "        \"\"\"\n\t        Access Potentiometer instance.\n\t        :return: Potentiometer\n\t        \"\"\"\n\t        return self.__potentiometer\n\t    @property\n\t    def channel(self) -> int:\n\t        \"\"\"Wiper channel number\"\"\"\n\t        return self.__channel\n\t    @channel.setter\n", "    def channel(self, channel: int) -> None:\n\t        self.__channel = check_integer(check_not_negative(channel))\n\t    @property\n\t    def min_value(self) -> int:\n\t        \"\"\"\n\t        Returns minimal wiper position, which is always zero.\n\t        :return: Always return 0.\n\t        \"\"\"\n\t        return 0\n\t    @property\n", "    def max_value(self) -> int:\n\t        \"\"\"\n\t        Returns device max wiper position value.\n\t        :return: Max wiper position value as int.\n\t        \"\"\"\n\t        return self.__max_value\n\t    @max_value.setter\n\t    def max_value(self, max_value: int) -> None:\n\t        new_value = check_integer(check_positive(max_value))\n\t        if not self.parameters_locked:\n", "            self.__max_value = new_value\n\t            self.value = self.__value\n\t    def _set_value(self, value: int) -> int:\n\t        \"\"\"\n\t        Set given wiper position to `value`.\n\t        :param value: Requested value as int.\n\t        :return: Value actually set as int.\n\t        \"\"\"\n\t        value = int(round(clamp(value, 0, self.max_value)))\n\t        return value\n", "    def _read_value(self) -> int:\n\t        \"\"\"\n\t        Read value of wiper position.\n\t        :return: Wiper position value (int).\n\t        \"\"\"\n\t        return self.__value\n\t    def read(self) -> None:\n\t        \"\"\"\n\t        Read wiper position into value property.\n\t        \"\"\"\n", "        self.__value = self._read_value()\n\t    @property\n\t    def value(self) -> int:\n\t        \"\"\"\n\t        Current wiper position.\n\t        :return: Wiper position value (int).\n\t        \"\"\"\n\t        self.read()\n\t        return self.__value\n\t    @value.setter\n", "    def value(self, value: int) -> None:\n\t        value = clamp(check_integer(value), 0, self.max_value)\n\t        data = self._set_value(value)\n\t        self.__value = data\n\t    @property\n\t    def value_relative(self) -> float:\n\t        \"\"\"\n\t        Relative wiper position value in the range 0..1.\n\t        :return: Relative wiper position (float)\n\t        \"\"\"\n", "        return self.value / self.max_value\n\t    @value_relative.setter\n\t    def value_relative(self, value: float) -> None:\n\t        value = clamp(value, 0, 1)\n\t        value_int = int(round(value * self.max_value))\n\t        self.value = value_int\n\t    @property\n\t    def r_wb(self) -> float:\n\t        \"\"\"\n\t        Calculates resistance between terminals B and W.\n", "        :return: Resistance between terminals B and W (float).\n\t        \"\"\"\n\t        return self.potentiometer.r_wb(self.value_relative)\n\t    @r_wb.setter\n\t    def r_wb(self, resistance: float) -> None:\n\t        self.value = int(\n\t            round(self.potentiometer.r_wb_to_position(resistance) * self.max_value)\n\t        )\n\t    @property\n\t    def r_wa(self) -> float:\n", "        \"\"\"\n\t        Calculates resistance between terminals A and W.\n\t        :return: Resistance between terminals A and W (float).\n\t        \"\"\"\n\t        return self.potentiometer.r_wa(self.value_relative)\n\t    @r_wa.setter\n\t    def r_wa(self, resistance: float) -> None:\n\t        self.value = int(\n\t            round(self.potentiometer.r_wa_to_position(resistance) * self.max_value)\n\t        )\n", "    @property\n\t    def r_lim(self) -> float:\n\t        \"\"\"\n\t        Potentiometer current limiting resistor.\n\t        \"\"\"\n\t        return self.potentiometer.r_lim\n\t    @r_lim.setter\n\t    def r_lim(self, r_lim: float) -> None:\n\t        self.potentiometer.r_lim = r_lim\n\t    @property\n", "    def r_load(self) -> float:\n\t        \"\"\"\n\t        Potentiometer load resistor.\n\t        \"\"\"\n\t        return self.potentiometer.r_load\n\t    @r_load.setter\n\t    def r_load(self, r_load: float) -> None:\n\t        self.potentiometer.r_load = r_load\n\t    @property\n\t    def voltage_in(self) -> float:\n", "        \"\"\"\n\t        Device input Voltage.\n\t        :return: Input voltage (float).\n\t        \"\"\"\n\t        return self.potentiometer.voltage_in\n\t    @voltage_in.setter\n\t    def voltage_in(self, voltage: float) -> None:\n\t        self.potentiometer.voltage_in = voltage\n\t    @property\n\t    def voltage_out(self) -> float:\n", "        \"\"\"\n\t        Calculates output voltage for given wiper position.\n\t        :return: Output voltage (float).\n\t        \"\"\"\n\t        return self.potentiometer.voltage_out(self.value / self.max_value)\n\t    @voltage_out.setter\n\t    def voltage_out(self, voltage: float) -> None:\n\t        self.value = int(\n\t            round(\n\t                self.potentiometer.voltage_out_to_wiper_position(voltage)\n", "                * self.max_value\n\t            )\n\t        )\n\t    def __deepcopy__(self, memo):\n\t        cls = self.__class__\n\t        result = cls.__new__(cls)\n\t        memo[id(self)] = result\n\t        for key, value in self.__dict__.items():\n\t            setattr(result, key, deepcopy(value, memo))\n\t        return result\n", "class SpiDigitalWiper(DigitalWiper):\n\t    \"\"\"Digital wiper with SPI interface\"\"\"\n\t    def __init__(\n\t        self,\n\t        potentiometer: Potentiometer,\n\t        spi: Union[SPI, None] = None,\n\t        max_value: int = 128,\n\t        parameters_locked: bool = False,\n\t    ):\n\t        self.__spi = None\n", "        if isinstance(spi, SPI):\n\t            self.__spi = spi\n\t        super().__init__(\n\t            potentiometer=potentiometer,\n\t            max_value=max_value,\n\t            parameters_locked=parameters_locked,\n\t        )\n\t    @property\n\t    def spi(self) -> Union[SPI, None]:\n\t        \"\"\"\n", "        Get SPI interface\n\t        :return: SPI interface (gpiozero.SPI)\n\t        \"\"\"\n\t        return self.__spi\n\t    @spi.setter\n\t    def spi(self, spi: Union[SPI, None]) -> None:\n\t        if isinstance(spi, SPI):\n\t            self.__spi = spi\n\t        self.__spi = None\n\t    def __deepcopy__(self, memo):\n", "        cls = self.__class__\n\t        result = cls.__new__(cls)\n\t        memo[id(self)] = result\n\t        for key, value in self.__dict__.items():\n\t            if \"_spi\" in key:\n\t                setattr(result, key, value)\n\t                continue\n\t            setattr(result, key, deepcopy(value, memo))\n\t        return result\n"]}
{"filename": "src/BDPotentiometer/potentiometer.py", "chunked_list": ["\"\"\" Basic potentiometer device implementation \"\"\"\n\timport math as m\n\tfrom .__helpers import clamp, check_number, check_positive, check_not_negative\n\tclass Potentiometer:\n\t    \"\"\"\n\t    Represents a general potentiometer with 3 terminals A, B, and W.\n\t    A     ┌─────────────┐     B\n\t     o────┤Potentiometer├─────o\n\t          └──────▲──────┘\n\t           1 <── │ ──> 0\n", "                 o W\n\t    Total resistance is `r_ab`, wiper resistance is `r_w`\n\t    If device is `locked` parameters `r_ab` and `r_w` are read-only.\n\t    Wiper moves from B to A changing position from 0 to 1.\n\t    Resistance between terminals WA and WB can be calculated using `r_wa` and `r_wb` functions.\n\t    Reverse functions `r_wa_to_position` and `r_wb_to_position` for calculation of wiper position\n\t    given r_wa or r_wb are also available.\n\t    Parameter `rheostat` turns potentiometer to rheostat with terminal A floating not connected,\n\t    and two terminals B and W available\n\t    A     ┌─────────────┐     B\n", "     x────┤   Rheostat  ├─────o\n\t          └──────▲──────┘\n\t           1 <── │ ──> 0\n\t                 o W\n\t    Potentiometer can be connected like shown bin the sketch below\n\t                 ┌────────┐ A     ┌──────────┐     B\n\t      (V_in) o───┤ R_lim  ├──o────┤   POT    ├─────o────┐\n\t                 └────────┘       └─────▲────┘          │\n\t                                  1 <── │ ──> 0         │\n\t                                        o W (V_out)    ─┴─ GND\n", "                                        │\n\t                                      ┌───┐\n\t                                      │ L │\n\t                             R_load   │ o │\n\t                                      │ a │\n\t                                      │ d │\n\t                                      └───┘\n\t                                        │\n\t                                       ─┴─ GND\n\t    Rheostat possible connection circuit is shown below.\n", "      A     ┌──────────┐     B   ┌────────┐\n\t       x────┤ Rheostat ├─────o───┤ R_lim  ├──o (V_in)\n\t            └─────▲────┘         └────────┘\n\t            1 <── │ ──> 0\n\t                  o W (V_out)\n\t                  │\n\t                ┌───┐\n\t                │ L │\n\t         R_load │ o │\n\t                │ a │\n", "                │ d │\n\t                └───┘\n\t                  │\n\t                 ─┴─ GND\n\t    R_lim is current limiting resistor, and R_load is resistive load.\n\t    Parameters `r_lim` and `r_load` can be set using properties with same name.\n\t    Default value for R_lim and R_load is zero.\n\t    Input voltage (V_in) is set using property `voltage_in`.\n\t    Output voltage (V_out) can be calculated using method `voltage_out`.\n\t    Wiper position given required V_out can be calculated\n", "    using function `voltage_out_to_wiper_position`.\n\t    \"\"\"\n\t    # pylint: disable=too-many-instance-attributes\n\t    def __init__(\n\t        self,\n\t        r_ab: float,\n\t        r_w: float = 0,\n\t        rheostat: bool = False,\n\t        parameters_locked: bool = False,\n\t    ) -> None:\n", "        self.__parameters_locked: bool = bool(parameters_locked)\n\t        self.__r_ab: float = float(check_positive(r_ab))\n\t        self.__r_w: float = float(check_not_negative(r_w))\n\t        self.__rheostat: bool = bool(rheostat)\n\t        self.__r_lim: float = 0\n\t        self.__r_load: float = 0\n\t        self.__voltage_in: float = 0\n\t    @property\n\t    def r_ab(self) -> float:\n\t        \"\"\"\n", "        Total resistance of the potentiometer between A and B terminals.\n\t        :return: Total resistance as float.\n\t        \"\"\"\n\t        return self.__r_ab\n\t    @r_ab.setter\n\t    def r_ab(self, resistance: float) -> None:\n\t        if not self.parameters_locked:\n\t            self.__r_ab = float(check_positive(resistance))\n\t    @property\n\t    def r_w(self) -> float:\n", "        \"\"\"\n\t        Wiper terminal resistance.\n\t        :return: Wiper resistance as float.\n\t        \"\"\"\n\t        return self.__r_w\n\t    @r_w.setter\n\t    def r_w(self, r_w: float) -> None:\n\t        if not self.parameters_locked:\n\t            self.__r_w = float(check_not_negative(r_w))\n\t    @property\n", "    def parameters_locked(self) -> bool:\n\t        \"\"\"\n\t        Check if parameters of the potentiometer are locked.\n\t        :return: True if locked and False otherwise\n\t        \"\"\"\n\t        return self.__parameters_locked\n\t    @property\n\t    def rheostat(self) -> bool:\n\t        \"\"\"\n\t        Check if device is configured as a rheostat (terminal A is floating and not available\n", "        for connection).\n\t        :return: True if device is a rheostat, otherwise False.\n\t        \"\"\"\n\t        return self.__rheostat\n\t    @property\n\t    def r_lim(self) -> float:\n\t        \"\"\"R_lim current limiting resistor\"\"\"\n\t        return self.__r_lim\n\t    @r_lim.setter\n\t    def r_lim(self, r_lim: float) -> None:\n", "        self.__r_lim = float(check_not_negative(r_lim))\n\t    @property\n\t    def r_load(self) -> float:\n\t        \"\"\"Resistive load R_load value\"\"\"\n\t        return self.__r_load\n\t    @r_load.setter\n\t    def r_load(self, r_load: float) -> None:\n\t        self.__r_load = float(check_not_negative(r_load))\n\t    @property\n\t    def voltage_in(self) -> float:\n", "        \"\"\"\n\t        Input voltage of the device.\n\t        :return: voltage_in (float).\n\t        \"\"\"\n\t        return self.__voltage_in\n\t    @voltage_in.setter\n\t    def voltage_in(self, voltage: float) -> None:\n\t        self.__voltage_in = float(check_number(voltage))\n\t    def r_wa(self, wiper_position: float) -> float:\n\t        \"\"\"\n", "        Calculates resistance between terminals A and W given the wiper position\n\t        as a fraction of its movement in the range from 0 (terminal B) to 1 (terminal A).\n\t        :param wiper_position: Wiper position in the range [0: 1]\n\t        :return: Resistance between terminals A and W (float).\n\t        \"\"\"\n\t        wiper_position = clamp(wiper_position, 0, 1)\n\t        return self.r_w + (1 - wiper_position) * self.r_ab\n\t    def r_wb(self, wiper_position: float) -> float:\n\t        \"\"\"\n\t        Calculates resistance between terminals B and W given the wiper position\n", "        as a fraction of its movement in the range from 0 (terminal B) to 1 (terminal A).\n\t        :param wiper_position: Wiper position in the range [0: 1]\n\t        :return: Resistance between terminals B and W (float).\n\t        \"\"\"\n\t        wiper_position = clamp(wiper_position, 0, 1)\n\t        return self.r_w + wiper_position * self.r_ab\n\t    def r_wa_to_position(self, r_wa: float) -> float:\n\t        \"\"\"\n\t        Calculate wiper position as a fraction of its movement in the range from 0 (terminal B)\n\t        to 1 (terminal A) given the resistance between terminals A and W.\n", "        :param r_wa: Resistance between terminals A and W (float)\n\t        :return: Wiper position in the range [0: 1] (float).\n\t        \"\"\"\n\t        r_wa = clamp(r_wa, self.r_w, self.r_w + self.r_ab)\n\t        return 1 - (r_wa - self.r_w) / self.r_ab\n\t    def r_wb_to_position(self, r_wb: float) -> float:\n\t        \"\"\"\n\t        Calculate wiper position as a fraction of its movement in the range from 0 (terminal B)\n\t        to 1 (terminal A) given the resistance between terminals B and W.\n\t        :param r_wb: Resistance between terminals B and W (float)\n", "        :return: Wiper position in the range [0: 1] (float).\n\t        \"\"\"\n\t        r_wb = clamp(r_wb, self.r_w, self.r_w + self.r_ab)\n\t        return (r_wb - self.r_w) / self.r_ab\n\t    def voltage_out(self, wiper_position: float) -> float:\n\t        \"\"\"\n\t        Calculates output voltage for given wiper position.\n\t        :param wiper_position: Wiper position as float number between 0 and 1.\n\t        :return: Voltage (float).\n\t        \"\"\"\n", "        wiper_position = clamp(wiper_position, 0, 1)\n\t        if self.rheostat:\n\t            r_total = self.r_load + self.r_lim + self.r_wb(wiper_position)\n\t            return self.voltage_in * self.r_load / r_total\n\t        r_wb = self.r_ab * wiper_position\n\t        r_wa = self.r_ab * (1 - wiper_position)\n\t        r_bot = r_wb * (self.r_w + self.r_load) / (r_wb + self.r_w + self.r_load)\n\t        v_bot = self.voltage_in * r_bot / (r_bot + self.r_lim + r_wa)\n\t        return v_bot / (self.r_load + self.r_w) * self.r_load\n\t    def voltage_out_to_wiper_position(self, voltage_out: float) -> float:\n", "        \"\"\"\n\t        Calculates wiper position given output voltage.\n\t        :param voltage_out: Output voltage (float).\n\t        :return: Wiper position as float number between 0 and 1.\n\t        \"\"\"\n\t        voltage_out = check_number(voltage_out)\n\t        if voltage_out == 0 or self.r_load == 0 or self.voltage_in == 0:\n\t            return 0\n\t        if (self.voltage_in / voltage_out) / abs(self.voltage_in / voltage_out) < 0:\n\t            return 0\n", "        if self.rheostat:\n\t            r_total = self.voltage_in * self.r_load / voltage_out\n\t            r_wb = r_total - self.r_load - self.r_lim\n\t            return self.r_wb_to_position(r_wb)\n\t        v_bot = voltage_out * (self.r_w + self.r_load) / self.r_load\n\t        r_lim = self.r_ab + self.r_lim\n\t        r_l = self.r_w + self.r_load\n\t        quad_b = self.voltage_in / v_bot * r_l - r_lim\n\t        quad_ac = -r_lim * r_l\n\t        quad_d = quad_b**2 - 4 * quad_ac\n", "        r_wb = (-quad_b + m.sqrt(quad_d)) / 2\n\t        return r_wb / self.r_ab\n"]}
{"filename": "src/BDPotentiometer/__init__.py", "chunked_list": ["\"\"\" Module to operate SPI digital potentiometer devices \"\"\"\n\t# pylint: disable=invalid-name\n\t__version__ = \"0.0.2\"\n\tfrom .potentiometer import Potentiometer\n\tfrom .digital_wiper import DigitalWiper, SpiDigitalWiper\n\tfrom .digital_potentiometer import DigitalPotentiometerDevice\n\ttry:\n\t    from .__gpiozero_helpers import fix_gpiozero_dual_cs_spi\n\texcept ModuleNotFoundError:\n\t    from .__gpiozero_helpers import (\n", "        fix_gpiozero_dual_cs_spi_dummy as fix_gpiozero_dual_cs_spi,\n\t    )\n"]}
{"filename": "src/BDPotentiometer/digital_potentiometer.py", "chunked_list": ["\"\"\" Digital potentiometer base class \"\"\"\n\timport copy\n\tfrom typing import Union\n\tfrom .__helpers import check_not_negative, check_positive, check_integer\n\tfrom .digital_wiper import DigitalWiper\n\tclass DigitalPotentiometerDevice:\n\t    \"\"\"\n\t    Represents a digital potentiometer device connected to SPI (serial interface).\n\t    A     ┌──────────┐     B\n\t     o────┤   POT    ├─────o\n", "          └─────▲────┘\n\t                │\n\t                o W\n\t    Total resistance of the potentiometer is `r_ab`. All terminals are available for connection.\n\t    W is a programmable wiper terminal with output resistance `r_w`.\n\t    Wiper position can be set between 0 and `max_value`. Parameter `default_value` sets initial\n\t    wiper position. Use None for pots with non-volatile memory.\n\t    For easy operation as voltage source following topology is assumed.\n\t    V_in     ┌────────┐ A     ┌──────────┐     B\n\t         o───┤ R_lim  ├──o────┤   POT    ├──────────┐\n", "             └────────┘       └─────▲────┘          │\n\t                      max_value <── │ ──> 0         │\n\t                                    o W (V_out)    ─┴─ GND\n\t                                    │\n\t                                  ┌───┐\n\t                                  │ R │\n\t                                  │lo-│\n\t                                  │ad │\n\t                                  └───┘\n\t                                    │\n", "                                   ─┴─ GND\n\t    terminal A is connected to voltage supply via current limiting resistor R_lim,\n\t    terminal B is connected to ground. Voltage at W terminal may be set or calculated.\n\t    Terminal W is connected to load resistance R_load.\n\t    By default, `R_load` equals to 1 MOhm, and `R_lim` equals to zero Ohms.\n\t    Device can also be configured in Rheostat mode. In this case terminal A is left floating\n\t    and only terminals B and W are available for connection.\n\t      A     ┌──────────┐     B\n\t       x────┤   POT    ├─────o\n\t            └─────▲────┘\n", "    max_value <── │ ──> 0\n\t                  o W\n\t    Option with `R_lim` and `R_load` connection is also available\n\t      A     ┌──────────┐     B   ┌────────┐   (V_in)\n\t       x────┤   POT    ├─────o───┤ R_lim  ├──o\n\t            └─────▲────┘         └────────┘\n\t    max_value <── │ ──> 0\n\t                  o W (V_out)\n\t                  │\n\t                ┌───┐\n", "                │ R │\n\t                │lo-│\n\t                │ad │\n\t                └───┘\n\t                  │\n\t                 ─┴─ GND\n\t    \"\"\"\n\t    # pylint: disable=too-many-public-methods\n\t    # pylint: disable=too-many-instance-attributes\n\t    def __init__(self, wiper: DigitalWiper, channels: int = 1) -> None:\n", "        self.__channels: dict[int, DigitalWiper] = {}\n\t        self.__labels: dict[int, str] = {0: \"0\"}\n\t        for i in range(check_integer(check_positive(channels))):\n\t            wiper = copy.deepcopy(wiper)\n\t            wiper.channel = i\n\t            wiper.potentiometer.r_lim = 0\n\t            wiper.potentiometer.r_load = 0\n\t            wiper.potentiometer.voltage_in = 0\n\t            wiper.read()\n\t            self.__channels[i] = wiper\n", "            self.__labels[i] = str(i)\n\t    def set_channel_label(\n\t        self, channel: int = 0, label: Union[str, None] = None\n\t    ) -> None:\n\t        \"\"\"\n\t        Assigns string label to a channel.\n\t        Note that label must be unique, otherwise will rise ValueError.\n\t        :param channel: Channel number.\n\t        :param label: Label for the channel (str).\n\t        \"\"\"\n", "        channel = check_integer(check_not_negative(channel))\n\t        if channel not in self.__labels:\n\t            raise ValueError(f\"Channel {channel} does not exist.\")\n\t        if label is None:\n\t            label = str(channel)\n\t        for idx, lbl in self.__labels.items():\n\t            if lbl == label and idx != channel:\n\t                raise ValueError(\n\t                    f\"Label {label} already assigned to another channel {idx}.\"\n\t                )\n", "        self.__labels[channel] = str(label)\n\t    def get_channel_number_by_label(self, label: str) -> Union[int, None]:\n\t        \"\"\"\n\t        Look for channel number by label provided.\n\t        :param label: Channel label (str).\n\t        :return: Channel number if label found or None.\n\t        \"\"\"\n\t        try:\n\t            return list(self.__labels.values()).index(str(label))\n\t        except ValueError:\n", "            return None\n\t    def _get_channel_number_by_label_or_id(\n\t        self, channel: Union[int, str]\n\t    ) -> Union[int, None]:\n\t        \"\"\"\n\t        Look for channel number by label or number provided.\n\t        :param channel: Channel number or label (int | str).\n\t        :return: Channel number if channel found or None.\n\t        \"\"\"\n\t        if isinstance(channel, str):\n", "            return self.get_channel_number_by_label(channel)\n\t        channel = check_integer(check_not_negative(channel))\n\t        if channel in self.__channels:\n\t            return channel\n\t        return None\n\t    @property\n\t    def channels(self) -> dict[int, DigitalWiper]:\n\t        \"\"\"\n\t        Available channels of the device.\n\t        :return: dict of DigitalWiper objects\n", "        \"\"\"\n\t        return self.__channels\n\t    @property\n\t    def channels_num(self) -> int:\n\t        \"\"\"\n\t        Get the number of channels of the device.\n\t        :return: number of available channels as int.\n\t        \"\"\"\n\t        return len(self.__channels)\n\t    def set_value(self, channel: Union[int, str] = 0, value: int = 0) -> int:\n", "        \"\"\"\n\t        Method to set the value for a given channel.\n\t        :param channel: Channel number or label (int | str).\n\t        :param value: Wiper position value requested (int).\n\t        :return: Wiper position value actually set (int).\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        self.channels[channel_number].value = value\n", "        return self.channels[channel_number].value\n\t    def get_value(self, channel: Union[int, str] = 0) -> int:\n\t        \"\"\"\n\t        Read value of given channel.\n\t        :param channel: Channel number or label (int | str).\n\t        :return: Wiper position value (int).\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n", "        return self.channels[channel_number].value\n\t    @property\n\t    def value(self) -> tuple[int, ...]:\n\t        \"\"\"\n\t        Tuple of current values for all channels.\n\t        :return: Tuple of int values for all channels.\n\t        \"\"\"\n\t        return tuple(wiper.value for _, wiper in self.channels.items())\n\t    @value.setter\n\t    def value(self, value: Union[list[int], tuple[int, ...]]) -> None:\n", "        if not isinstance(value, (list, tuple)):\n\t            raise ValueError(\"A tuple or list of values is expected.\")\n\t        if len(value) != self.channels_num:\n\t            raise ValueError(\n\t                f\"A tuple or list of length {self.channels_num} is expected.\"\n\t            )\n\t        for i in range(self.channels_num):\n\t            self.channels[i].value = value[i]\n\t    def set_r_wb(self, channel: Union[int, str] = 0, resistance: float = 0) -> int:\n\t        \"\"\"\n", "        Set the resistance for given channel between B and W terminals\n\t        as close as possible to requested value.\n\t        :param channel: Channel number or label (int | str)\n\t        :param resistance: Requested resistance as float.\n\t        :return: Wiper position value as int.\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        self.channels[channel_number].r_wb = resistance\n", "        return self.channels[channel_number].value\n\t    def get_r_wb(self, channel: Union[int, str] = 0) -> float:\n\t        \"\"\"\n\t        Get the resistance for given channel between B and W terminals.\n\t        :param channel: Channel number or label (int | str)\n\t        :return: B-W resistance value as float.\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n", "        return self.channels[channel_number].r_wb\n\t    @property\n\t    def r_wb(self) -> tuple[float, ...]:\n\t        \"\"\"\n\t        Resistance between B and W terminals for all channels as a tuple of floats.\n\t        :return: B-W resistance for all channels as a tuple of floats.\n\t        \"\"\"\n\t        return tuple(wiper.r_wb for _, wiper in self.channels.items())\n\t    @r_wb.setter\n\t    def r_wb(self, resistance: Union[list[float], tuple[float, ...]]) -> None:\n", "        if len(resistance) != self.channels_num:\n\t            raise ValueError(\n\t                f\"A tuple or list of length {self.channels_num} is expected.\"\n\t            )\n\t        for channel, wiper in self.channels.items():\n\t            wiper.r_wb = resistance[channel]\n\t    def set_r_wa(self, channel: Union[int, str] = 0, resistance: float = 0) -> int:\n\t        \"\"\"\n\t        Set the resistance for given channel between A and W terminals\n\t        as close as possible to requested value.\n", "        :param channel: Channel number or label (int | str)\n\t        :param resistance: Requested resistance as float.\n\t        :return: Wiper position value as int.\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        self.channels[channel_number].r_wa = resistance\n\t        return self.channels[channel_number].value\n\t    def get_r_wa(self, channel: Union[int, str] = 0) -> float:\n", "        \"\"\"\n\t        Get the resistance for given channel between A and W terminals.\n\t        :param channel: Channel number or label (int | str)\n\t        :return: A-W resistance value as float.\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        return self.channels[channel_number].r_wa\n\t    @property\n", "    def r_wa(self) -> tuple[float, ...]:\n\t        \"\"\"\n\t        Resistance between A and W terminals for all channels as a tuple of floats.\n\t        :return: A-W resistance for all channels as a tuple of floats.\n\t        \"\"\"\n\t        return tuple(wiper.r_wa for _, wiper in self.channels.items())\n\t    @r_wa.setter\n\t    def r_wa(self, resistance: Union[list[float], tuple[float, ...]]) -> None:\n\t        if len(resistance) != self.channels_num:\n\t            raise ValueError(\n", "                f\"A tuple or list of length {self.channels_num} is expected.\"\n\t            )\n\t        for channel, wiper in self.channels.items():\n\t            wiper.r_wa = resistance[channel]\n\t    def set_r_lim(self, channel: Union[int, str] = 0, resistance: float = 0) -> None:\n\t        \"\"\"\n\t        Set the current limiting resistor value for given channel.\n\t        :param channel: Channel number or label (int | str)\n\t        :param resistance: Requested resistance as float.\n\t        \"\"\"\n", "        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        self.channels[channel_number].r_lim = resistance\n\t    def get_r_lim(self, channel: Union[int, str] = 0) -> float:\n\t        \"\"\"\n\t        Get the current limiting resistor value for given channel.\n\t        :param channel: Channel number or label (int | str)\n\t        :return: Current limiting resistor value as float.\n\t        \"\"\"\n", "        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        return self.channels[channel_number].r_lim\n\t    @property\n\t    def r_lim(self) -> tuple[float, ...]:\n\t        \"\"\"\n\t        Potentiometer current limiting resistors for all channels.\n\t        \"\"\"\n\t        return tuple(wiper.r_lim for _, wiper in self.channels.items())\n", "    @r_lim.setter\n\t    def r_lim(\n\t        self, resistance: Union[int, float, list[float], tuple[float, ...]]\n\t    ) -> None:\n\t        if isinstance(resistance, (int, float)):\n\t            resistance = [float(resistance)] * self.channels_num\n\t        if (\n\t            not isinstance(resistance, (list, tuple))\n\t            or len(resistance) != self.channels_num\n\t        ):\n", "            raise ValueError(\n\t                f\"A tuple or list of length {self.channels_num} is expected.\"\n\t            )\n\t        for channel, wiper in self.channels.items():\n\t            wiper.r_lim = resistance[channel]\n\t    def set_r_load(self, channel: Union[int, str] = 0, resistance: float = 0) -> None:\n\t        \"\"\"\n\t        Set the load resistor value for given channel.\n\t        :param channel: Channel number or label (int | str)\n\t        :param resistance: Requested resistance as float.\n", "        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        self.channels[channel_number].r_load = resistance\n\t    def get_r_load(self, channel: Union[int, str] = 0) -> float:\n\t        \"\"\"\n\t        Get the load resistor value for given channel.\n\t        :param channel: Channel number or label (int | str)\n\t        :return: Load resistor value as float.\n", "        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        return self.channels[channel_number].r_load\n\t    @property\n\t    def r_load(self) -> tuple[float, ...]:\n\t        \"\"\"\n\t        Potentiometer load resistors for all channels.\n\t        \"\"\"\n", "        return tuple(wiper.r_load for _, wiper in self.channels.items())\n\t    @r_load.setter\n\t    def r_load(\n\t        self, resistance: Union[int, float, list[float], tuple[float, ...]]\n\t    ) -> None:\n\t        if isinstance(resistance, (int, float)):\n\t            resistance = [float(resistance)] * self.channels_num\n\t        if (\n\t            not isinstance(resistance, (list, tuple))\n\t            or len(resistance) != self.channels_num\n", "        ):\n\t            raise ValueError(\n\t                f\"A tuple or list of length {self.channels_num} is expected.\"\n\t            )\n\t        for channel, wiper in self.channels.items():\n\t            wiper.r_load = resistance[channel]\n\t    def set_voltage_in(\n\t        self, channel: Union[int, str] = 0, voltage: float = 0.0\n\t    ) -> float:\n\t        \"\"\"\n", "        Set input voltage for a given channel number.\n\t        :param channel: Channel number (int).\n\t        :param voltage: Requested input voltage (float).\n\t        :return: Set input voltage (float)\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        self.channels[channel_number].voltage_in = voltage\n\t        return self.channels[channel_number].voltage_in\n", "    def get_voltage_in(self, channel: Union[int, str] = 0) -> float:\n\t        \"\"\"\n\t        Get input voltage for a given channel number.\n\t        :param channel: Channel number (int).\n\t        :return: Input voltage (float).\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        return self.channels[channel_number].voltage_in\n", "    @property\n\t    def voltage_in(self) -> tuple[float, ...]:\n\t        \"\"\"\n\t        Input voltage of the device.\n\t        :return: voltage_in tuple of floats.\n\t        \"\"\"\n\t        return tuple(wiper.voltage_in for _, wiper in self.channels.items())\n\t    @voltage_in.setter\n\t    def voltage_in(self, voltage: Union[list[float], tuple[float]]) -> None:\n\t        if len(voltage) != self.channels_num:\n", "            raise ValueError(\n\t                f\"A tuple or list of length {self.channels_num} is expected.\"\n\t            )\n\t        for channel, wiper in self.channels.items():\n\t            wiper.voltage_in = voltage[channel]\n\t    def set_voltage_out(\n\t        self, channel: Union[int, str] = 0, voltage: float = 0.0\n\t    ) -> float:\n\t        \"\"\"\n\t        Set voltage at wiper for a given channel number.\n", "        :param channel: Channel number (int).\n\t        :param voltage: Voltage requested (float).\n\t        :return: Actual output voltage closest to requested (float).\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        self.channels[channel_number].voltage_out = voltage\n\t        return self.channels[channel_number].voltage_out\n\t    def get_voltage_out(self, channel: Union[int, str] = 0) -> float:\n", "        \"\"\"\n\t        Get voltage at wiper for a given channel number.\n\t        :param channel: Channel number (int).\n\t        :return:Voltage (float).\n\t        \"\"\"\n\t        channel_number = self._get_channel_number_by_label_or_id(channel)\n\t        if channel_number is None:\n\t            raise ValueError(f\"Channel {channel} not found.\")\n\t        return self.channels[channel_number].voltage_out\n\t    @property\n", "    def voltage_out(self) -> tuple[float, ...]:\n\t        \"\"\"\n\t        Voltage at pot's wiper for all available channels as a tuple of floats.\n\t        :return: A tuple of voltages as floats.\n\t        \"\"\"\n\t        return tuple(wiper.voltage_out for _, wiper in self.channels.items())\n\t    @voltage_out.setter\n\t    def voltage_out(self, voltage: Union[list[float], tuple[float]]) -> None:\n\t        if len(voltage) != self.channels_num:\n\t            raise ValueError(\n", "                f\"A tuple or list of length {self.channels_num} is expected.\"\n\t            )\n\t        for channel, wiper in self.channels.items():\n\t            wiper.voltage_out = voltage[channel]\n"]}
{"filename": "src/BDPotentiometer/__gpiozero_helpers.py", "chunked_list": ["\"\"\"Some helpers for gpiozero.\"\"\"\n\ttry:\n\t    from gpiozero import Device\n\t    from gpiozero.pins.local import LocalPiHardwareSPI, LocalPiHardwareSPIShared\n\t    from gpiozero.pins.rpigpio import RPiGPIOFactory\n\texcept ModuleNotFoundError:\n\t    pass\n\tdef fix_gpiozero_dual_cs_spi() -> None:\n\t    \"\"\"\n\t    A workaround written by slghb GitHub user to use two spi devices with hardware spi.\n", "    Taken from https://github.com/gpiozero/gpiozero/issues/1015\n\t    :return: None.\n\t    \"\"\"\n\t    class LocalPiHardwareSPIFixed(LocalPiHardwareSPI):\n\t        \"\"\"Custom conflict checker\"\"\"\n\t        # pylint: disable=too-few-public-methods\n\t        def _conflicts_with(self, other):\n\t            # pylint: disable=protected-access\n\t            return not (\n\t                isinstance(other, LocalPiHardwareSPI)\n", "                and (self._port, self._device) != (other._port, other._device)\n\t            )\n\t        @property\n\t        def value(self):\n\t            \"\"\"\n\t            Returns a value representing the device's state. Frequently, this is a\n\t            boolean value, or a number between 0 and 1 but some devices use larger\n\t            ranges (e.g. -1 to +1) and composite devices usually use tuples to\n\t            return the states of all their subordinate components.\n\t            \"\"\"\n", "            raise NotImplementedError\n\t    class LocalPiHardwareSPISharedFixed(LocalPiHardwareSPIShared):\n\t        \"\"\"Custom Shared SPI hardware class inheriting from fixed Hardware SPI class above\"\"\"\n\t        def _conflicts_with(self, other):\n\t            # pylint: disable=protected-access\n\t            return not (\n\t                isinstance(other, LocalPiHardwareSPI)\n\t                and (self._port, self._device) != (other._port, other._device)\n\t            )\n\t        @property\n", "        def value(self):\n\t            \"\"\"\n\t            Returns a value representing the device's state. Frequently, this is a\n\t            boolean value, or a number between 0 and 1 but some devices use larger\n\t            ranges (e.g. -1 to +1) and composite devices usually use tuples to\n\t            return the states of all their subordinate components.\n\t            \"\"\"\n\t            raise NotImplementedError\n\t    class FixedRPiGPIOFactory(RPiGPIOFactory):\n\t        \"\"\"Fixed RPiGPIOFactory\"\"\"\n", "        def _get_spi_class(self, shared, hardware):\n\t            \"\"\"\n\t            Return a Fixed SPI class if shared hardware SPI port between two devices\n\t            :param shared: Flag for shared usage of SPI port.\n\t            :param hardware: Flag for hardware SPI usage.\n\t            :return:\n\t            \"\"\"\n\t            if hardware:\n\t                if shared:\n\t                    return LocalPiHardwareSPISharedFixed\n", "                return LocalPiHardwareSPIFixed\n\t            return super()._get_spi_class(shared, hardware)\n\t    Device.pin_factory = FixedRPiGPIOFactory()\n\tdef fix_gpiozero_dual_cs_spi_dummy() -> None:\n\t    \"\"\"\n\t    A stub function if there will be problems importing above function\n\t    \"\"\"\n"]}
{"filename": "src/BDPotentiometer/mcp4xxx/mcp4xx1.py", "chunked_list": ["\"\"\" MCP4XX1 series potentiometers \"\"\"\n\tfrom BDPotentiometer import DigitalPotentiometerDevice\n\tfrom .mcp4xxx import MCP4xxxPotentiometer, MCP4xxxWiper, MCP4xxx\n\tclass MCP4xx1(DigitalPotentiometerDevice, MCP4xxx):\n\t    \"\"\"MCP4XX1 is a single or dual channel digital potentiometer.\"\"\"\n\t    def __init__(\n\t        self, r_ab: float = 10e3, max_value: int = 128, channels: int = 1, **spi_args\n\t    ) -> None:\n\t        MCP4xxx.__init__(self, **spi_args)\n\t        potentiometer = MCP4xxxPotentiometer(r_ab, rheostat=False)\n", "        wiper = MCP4xxxWiper(\n\t            potentiometer=potentiometer, spi=self._spi, max_value=max_value\n\t        )\n\t        DigitalPotentiometerDevice.__init__(self, wiper=wiper, channels=channels)\n\tclass MCP4131(MCP4xx1):\n\t    \"\"\"7-bit, single channel pot with volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\tclass MCP4141(MCP4xx1):\n\t    \"\"\"7-bit, single channel pot with non-volatile wiper\"\"\"\n", "    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\tclass MCP4151(MCP4xx1):\n\t    \"\"\"8-bit, single channel pot with volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)\n\tclass MCP4161(MCP4xx1):\n\t    \"\"\"8-bit, single channel pot with non-volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)\n", "class MCP4231(MCP4xx1):\n\t    \"\"\"7-bit, dual channel pot with volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\tclass MCP4241(MCP4xx1):\n\t    \"\"\"7-bit, dual channel pot with non-volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\tclass MCP4251(MCP4xx1):\n\t    \"\"\"8-bit, dual channel pot with volatile wiper\"\"\"\n", "    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)\n\tclass MCP4261(MCP4xx1):\n\t    \"\"\"8-bit, dual channel pot with volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)\n"]}
{"filename": "src/BDPotentiometer/mcp4xxx/mcp4xx2.py", "chunked_list": ["\"\"\" MCP4XX2 series rheostats \"\"\"\n\tfrom BDPotentiometer import DigitalPotentiometerDevice\n\tfrom .mcp4xxx import MCP4xxxPotentiometer, MCP4xxxWiper, MCP4xxx\n\tclass MCP4xx2(DigitalPotentiometerDevice, MCP4xxx):\n\t    \"\"\"MCP4XX2 is a single or dual channel digital rheostat.\"\"\"\n\t    def __init__(\n\t        self, r_ab: float = 10e3, max_value: int = 128, channels: int = 1, **spi_args\n\t    ) -> None:\n\t        MCP4xxx.__init__(self, **spi_args)\n\t        potentiometer = MCP4xxxPotentiometer(r_ab, rheostat=True)\n", "        wiper = MCP4xxxWiper(\n\t            potentiometer=potentiometer, spi=self._spi, max_value=max_value\n\t        )\n\t        DigitalPotentiometerDevice.__init__(self, wiper=wiper, channels=channels)\n\tclass MCP4132(MCP4xx2):\n\t    \"\"\"7-bit, single channel rheostat with volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\tclass MCP4142(MCP4xx2):\n\t    \"\"\"7-bit, single channel rheostat with non-volatile wiper\"\"\"\n", "    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\tclass MCP4152(MCP4xx2):\n\t    \"\"\"8-bit, single channel rheostat with volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)\n\tclass MCP4162(MCP4xx2):\n\t    \"\"\"8-bit, single channel rheostat with non-volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)\n", "class MCP4232(MCP4xx2):\n\t    \"\"\"7-bit, dual channel rheostat with volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\tclass MCP4242(MCP4xx2):\n\t    \"\"\"7-bit, dual channel rheostat with non-volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\tclass MCP4252(MCP4xx2):\n\t    \"\"\"8-bit, dual channel rheostat with volatile wiper\"\"\"\n", "    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)\n\tclass MCP4262(MCP4xx2):\n\t    \"\"\"8-bit, dual channel rheostat with non-volatile wiper\"\"\"\n\t    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n\t        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)\n"]}
{"filename": "src/BDPotentiometer/mcp4xxx/__init__.py", "chunked_list": ["\"\"\" MCP4xxx series Digital potentiometers and rheostats \"\"\"\n\tfrom .mcp4xxx import resistance_list\n\tfrom .mcp4xx1 import (\n\t    MCP4131,\n\t    MCP4141,\n\t    MCP4151,\n\t    MCP4161,\n\t    MCP4231,\n\t    MCP4241,\n\t    MCP4251,\n", "    MCP4261,\n\t)\n\tfrom .mcp4xx2 import (\n\t    MCP4132,\n\t    MCP4142,\n\t    MCP4152,\n\t    MCP4162,\n\t    MCP4232,\n\t    MCP4242,\n\t    MCP4252,\n", "    MCP4262,\n\t)\n"]}
{"filename": "src/BDPotentiometer/mcp4xxx/mcp4xxx.py", "chunked_list": ["\"\"\" MCP4XXX series SPI device base class \"\"\"\n\tfrom typing import Union\n\tfrom gpiozero import SPI, SPIDevice\n\tfrom BDPotentiometer import SpiDigitalWiper, Potentiometer\n\tresistance_list: tuple[float, ...] = (5e3, 10e3, 50e3, 100e3)\n\tdef _coerce_max_value(max_value: int) -> int:\n\t    if max_value not in (128, 256):\n\t        raise ValueError(\"Max value must be equal to 128 or 256.\")\n\t    return max_value\n\tdef _coerce_r_ab(r_ab: float) -> float:\n", "    \"\"\"\n\t    Coerce resistance to the closest available for MCP4XXX devices.\n\t    :param r_ab: input resistance (float).\n\t    :return: resistance coerced to one from `resistance_list` (float).\n\t    \"\"\"\n\t    if r_ab not in resistance_list:\n\t        raise ValueError(f\"r_ab must be in {resistance_list}\")\n\t    return float(r_ab)\n\tdef _check_write_response(data: list) -> None:\n\t    \"\"\"\n", "    Checks that the write response is in correct format.\n\t    :param data: Response data (list).\n\t    \"\"\"\n\t    if data is None:\n\t        raise ValueError(f\"Wrong response {data}\")\n\tdef _check_read_response(data: list) -> None:\n\t    \"\"\"\n\t    Checks that the read response is in correct format.\n\t    :param data: Response data (list).\n\t    \"\"\"\n", "    if data is None:\n\t        raise ValueError(f\"Wrong response {data}\")\n\tdef _check_status_response(data: list) -> None:\n\t    \"\"\"\n\t    Checks that the status request response is in correct format.\n\t    :param data: Response data (list).\n\t    \"\"\"\n\t    reserved = (0b1, 0b11100000)\n\t    if not (\n\t        data[0] & reserved[0] == reserved[0] and data[1] & reserved[1] == reserved[1]\n", "    ):\n\t        raise ValueError(f\"Wrong response {data}\")\n\tdef _check_tcon_response(data: list) -> None:\n\t    \"\"\"\n\t    Checks that the TCON response is in correct format.\n\t    :param data: Response data (list).\n\t    \"\"\"\n\t    reserved = (0b1,)\n\t    if not data[0] & reserved[0] == reserved[0]:\n\t        raise ValueError(f\"Wrong response {data}\")\n", "def _parse_tcon_response(data: int) -> dict[str, bool]:\n\t    \"\"\"\n\t    Parses TCON response data.\n\t    :param data: raw TCON response data (int).\n\t    \":return: Parsed TCON state (dict).\n\t    \"\"\"\n\t    result = {\n\t        \"shdn\": not (data & 0b1000 == 0b1000),\n\t        \"A\": data & 0b0100 == 0b0100,\n\t        \"W\": data & 0b0010 == 0b0010,\n", "        \"B\": data & 0b0001 == 0b0001,\n\t    }\n\t    return result\n\tdef _tcon_to_cmd(tcon: dict[str, bool]) -> int:\n\t    \"\"\"\n\t    Convert TCON dict to TCON cmd ready for sending to device.\n\t    :param tcon: TCON requested state (dict).\n\t    :return: TCON cmd (int).\n\t    \"\"\"\n\t    shdn = 0 if tcon[\"shdn\"] else 0b1000\n", "    terminal_a = 0b0100 if tcon[\"A\"] else 0\n\t    terminal_w = 0b0010 if tcon[\"W\"] else 0\n\t    terminal_b = 0b0001 if tcon[\"B\"] else 0\n\t    return shdn | terminal_a | terminal_w | terminal_b\n\t_W_CMD = 0b00000000\n\t_R_CMD = 0b00001100\n\t_CH = (0b00000000, 0b00010000)\n\t_STATUS = 0b01010000\n\t_TCON = 0b01000000\n\t_SHDN = 0b10\n", "class MCP4xxxPotentiometer(Potentiometer):\n\t    \"\"\"Potentiometer to use with MCP4XXX\"\"\"\n\t    def __init__(self, r_ab: float, rheostat: bool = False) -> None:\n\t        r_ab = _coerce_r_ab(r_ab)\n\t        super().__init__(r_ab=r_ab, r_w=75, rheostat=rheostat, parameters_locked=True)\n\tclass MCP4xxxWiper(SpiDigitalWiper):\n\t    \"\"\"Special version of SPIDigitalWiper for MCP4XXX pots\"\"\"\n\t    def __init__(\n\t        self,\n\t        potentiometer: MCP4xxxPotentiometer,\n", "        spi: Union[SPI, None] = None,\n\t        max_value: int = 128,\n\t    ):\n\t        max_value = _coerce_max_value(max_value)\n\t        super().__init__(\n\t            potentiometer=potentiometer,\n\t            spi=spi,\n\t            max_value=max_value,\n\t            parameters_locked=True,\n\t        )\n", "    def _set_value(self, value: int) -> int:\n\t        if isinstance(self.spi, SPI):\n\t            data = self.spi.transfer([_W_CMD | _CH[self.channel], value])\n\t            _check_write_response(data)\n\t            return value\n\t        raise ConnectionError(\"SPI interface not set\")\n\t    def _read_value(self):\n\t        if isinstance(self.spi, SPI):\n\t            data = self.spi.transfer([_R_CMD | _CH[self.channel], 0])\n\t            _check_read_response(data)\n", "            return data[1]\n\t        raise ConnectionError(\"SPI interface not set\")\n\tclass MCP4xxx(SPIDevice):\n\t    \"\"\"Base class for MCP4XXX series devices\"\"\"\n\t    def __init__(self, **spi_args) -> None:\n\t        super().__init__(shared=True, **spi_args)\n\t    @property\n\t    def value(self):\n\t        raise NotImplementedError\n\t    def get_shdn_pin_status(self) -> bool:\n", "        \"\"\"\n\t        Check status of device SHDN pin.\n\t        :return: SHDN state (bool).\n\t        \"\"\"\n\t        data = self._spi.transfer([_R_CMD | _STATUS, 0])\n\t        _check_status_response(data)\n\t        if data[1] & _SHDN == _SHDN:\n\t            return True\n\t        return False\n\t    def read_tcon(self) -> tuple[dict[str, bool], dict[str, bool]]:\n", "        \"\"\"\n\t        Read terminals connection (TCON) status of the device.\n\t        :return: Tuple of TCON status dicts.\n\t        \"\"\"\n\t        data = self._spi.transfer([_R_CMD | _TCON, 0])\n\t        _check_tcon_response(data)\n\t        ch0 = data[1] & 0b1111\n\t        ch1 = (data[1] & 0b11110000) >> 4\n\t        return _parse_tcon_response(ch0), _parse_tcon_response(ch1)\n\t    def write_tcon(\n", "        self,\n\t        ch0: Union[dict[str, bool], None] = None,\n\t        ch1: Union[dict[str, bool], None] = None,\n\t    ) -> bool:\n\t        \"\"\"\n\t        MCP4XXX terminals connection (TCON) control.\n\t        :return: True if success, otherwise False.\n\t        \"\"\"\n\t        default_tcon_value = {\"shdn\": False, \"A\": True, \"W\": True, \"B\": True}\n\t        if ch0 is None:\n", "            ch0 = default_tcon_value\n\t        if ch1 is None:\n\t            ch1 = default_tcon_value\n\t        ch0_cmd = _tcon_to_cmd(ch0)\n\t        ch1_cmd = _tcon_to_cmd(ch1)\n\t        data = ch0_cmd | (ch1_cmd << 4)\n\t        _ = self._spi.transfer([_W_CMD | _TCON, data])\n\t        resp = self._spi.transfer([_R_CMD | _TCON, 0])\n\t        _check_tcon_response(resp)\n\t        if resp[1] == data:\n", "            return True\n\t        return False\n\t    def shdn(self, ch0: bool = False, ch1: bool = False) -> bool:\n\t        \"\"\"\n\t        Shutdown of device channels using TCON control.\n\t        :param ch0: Boolean True for SHDN.\n\t        :param ch1: Boolean True for SHDN.\n\t        :return: True if success, otherwise False.\n\t        \"\"\"\n\t        return self.write_tcon(\n", "            ch0={\"shdn\": ch0, \"A\": True, \"W\": True, \"B\": True},\n\t            ch1={\"shdn\": ch1, \"A\": True, \"W\": True, \"B\": True},\n\t        )\n"]}
