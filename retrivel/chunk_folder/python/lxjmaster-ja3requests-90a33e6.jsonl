{"filename": "setup.py", "chunked_list": ["import os\n\timport sys\n\tfrom setuptools import setup\n\tfrom setuptools.command.test import test as TestCommand\n\tclass PyTest(TestCommand):\n\t    user_options = [(\"pytest-args=\", \"a\", \"Arguments to pass into py.test\")]\n\t    def initialize_options(self):\n\t        TestCommand.initialize_options(self)\n\t        try:\n\t            from multiprocessing import cpu_count\n", "            self.pytest_args = [\"-n\", str(cpu_count()), \"--boxed\"]\n\t        except (ImportError, NotImplementedError):\n\t            self.pytest_args = [\"-n\", \"1\", \"--boxed\"]\n\t    def finalize_options(self):\n\t        TestCommand.finalize_options(self)\n\t        self.test_args = []\n\t        self.test_suite = True\n\t    def run_tests(self):\n\t        import pytest\n\t        errno = pytest.main(self.pytest_args)\n", "        sys.exit(errno)\n\twith open(\"requirements.txt\", \"r\", encoding=\"utf8\") as f:\n\t    requires = f.readlines()\n\twith open(\"requirements-dev.txt\", \"r\", encoding=\"utf8\") as f:\n\t    test_requirements = f.readlines()\n\tabout = {}\n\there = os.path.abspath(os.path.dirname(__file__))\n\tversion_file = os.path.join(here, \"ja3requests\", \"__version__.py\")\n\twith open(version_file, \"r\", encoding=\"utf8\") as f:\n\t    exec(f.read(), about)\n", "with open(\"README.md\", \"r\", encoding=\"utf8\") as f:\n\t    readme = f.read()\n\tsetup(\n\t    name=about[\"__title__\"],\n\t    version=about[\"__version__\"],\n\t    description=about[\"__description__\"],\n\t    long_description=readme,\n\t    long_description_content_type=\"text/markdown\",\n\t    keywords=[\"pip\", \"ja3requests\", \"ja3\", \"requests\"],\n\t    license=about[\"__license__\"],\n", "    author=about[\"__author__\"],\n\t    author_email=about[\"__author_email__\"],\n\t    url=about[\"__url__\"],\n\t    packages=[\"ja3requests\", \"ja3requests/base\", \"ja3requests/protocol\"],\n\t    package_dir={\"ja3requests\": \"ja3requests\"},\n\t    zip_safe=False,\n\t    include_package_data=True,\n\t    platforms=\"any\",\n\t    install_requires=requires,\n\t    tests_require=test_requirements,\n", "    cmdclass={\"test\": PyTest},\n\t)\n"]}
{"filename": "main.py", "chunked_list": ["from ja3requests.sessions import Session\n\theaders = {\n\t    \"connection\": \"keep-alive\",\n\t    \"Accept-Encoding\": \"deflate, br, gzip\"\n\t}\n\twith Session() as session:\n\t    # response = session.get(\"http://127.0.0.1:8080\", headers=headers)\n\t    # response = session.get(\"http://www.baidu.com\", headers=headers)\n\t    response = session.get(\"http://www.aliyun.com\")\n\t    print(response.headers)\n", "    print(response)\n\t    # print(response.status_code)\n\t    # print(response.content)\n\t    print(response.text)\n\t    # print(response.json())\n\t    # with open(\"baidu.html\", \"w+\") as f:\n\t    #     f.write(response.text)\n\t# import requests\n\t#\n\t# requests.get(\"http://127.0.0.1:8080\", headers=headers)\n", "# import socket\n\t#\n\t# # create a socket object\n\t# client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t#\n\t# # connect to the server\n\t# host = 'www.baidu.com'\n\t# port = 80\n\t# client_socket.connect((host, port))\n\t#\n", "# request = \"GET / HTTP/1.1\\r\\nHost: {}\\r\\nConnection: close\\r\\n\\r\\n\".format(host)\n\t# client_socket.send(request.encode())\n\t#\n\t# response = b''\n\t# while True:\n\t#     data = client_socket.recv(1024)\n\t#     if not data:\n\t#         break\n\t#     response += data\n\t#\n", "# # decode the response headers\n\t# response_headers = response.decode().split('\\r\\n')\n\t#\n\t# content_length = None\n\t# transfer_encoding = None\n\t#\n\t# for header in response_headers:\n\t#     if 'Content-Length' in header:\n\t#         content_length = int(header.split(': ')[1])\n\t#     elif 'Transfer-Encoding' in header:\n", "#         transfer_encoding = header.split(': ')[1]\n\t#\n\t# print(content_length, transfer_encoding)\n\t# if transfer_encoding == 'chunked':\n\t#     response_body = b''\n\t#     while True:\n\t#         chunk_size = int(response[:response.find(b'\\r\\n')], 16)\n\t#         if chunk_size == 0:\n\t#             break\n\t#         response = response[response.find(b'\\r\\n')+2:]\n", "#         response_body += response[:chunk_size]\n\t#         response = response[chunk_size+2:]\n\t# else:\n\t#     # read the response body using content length\n\t#     response_body = client_socket.recv(content_length)\n\t#\n\t# print(response[len(response)-content_length:])\n\t# client_socket.close()\n"]}
{"filename": "test/test_ready_request.py", "chunked_list": ["import unittest\n\tfrom ja3requests.request import ReadyRequest\n\tclass TestReadyRequest(unittest.TestCase):\n\t    request = ReadyRequest(\n\t        \"GET\",\n\t        \"http://www.baidu.com\"\n\t    )\n\t    def test_ready(self):\n\t        self.request.ready()\n\t        print(self.request.scheme, self.request.url)\n", "    def test_request(self):\n\t        req = self.request.request()\n\t        req.send()\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "test/test_session.py", "chunked_list": ["import unittest\n\tfrom ja3requests.sessions import Session\n\tclass TestSession(unittest.TestCase):\n\t    session = Session()\n\t    def test_get(self):\n\t        headers = {\n\t            \"connection\": \"close\"\n\t        }\n\t        self.session.get(\"http://www.baidu.com\")\n\t    def test_post_data(self):\n", "        data = {\n\t            \"username\": \"admin\",\n\t            \"password\": \"admin\"\n\t        }\n\t        response = self.session.post(\"http://127.0.0.1:8080/login\", data=data)\n\t        print(response)\n\t        print(response.status_code)\n\t        print(response.headers)\n\t        print(response.content)\n\tif __name__ == '__main__':\n", "    unittest.main()\n"]}
{"filename": "test/test_utils.py", "chunked_list": ["import unittest\n\tfrom ja3requests.utils import default_headers\n\tclass TestUtils(unittest.TestCase):\n\t    def test_default_headers(self):\n\t        result = default_headers()\n\t        print(result)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "ja3requests/response.py", "chunked_list": ["\"\"\"\n\tja3requests.response\n\t~~~~~~~~~~~~~~~~~~~~~~~\n\tThis module contains response.\n\t\"\"\"\n\timport json\n\timport gzip\n\timport zlib\n\timport brotli\n\tfrom .base import BaseResponse\n", "from .const import MAX_LINE, MAX_HEADERS\n\tfrom .exceptions import InvalidStatusLine, InvalidResponseHeaders, IssueError\n\tclass HTTPResponse(BaseResponse):\n\t    \"\"\"\n\t    An HTTP response from socket connection.\n\t    \"\"\"\n\t    def __init__(self, sock, method=None):\n\t        super().__init__()\n\t        self.fp = sock.makefile(\"rb\")\n\t        self._method = method\n", "        self._chunked = False\n\t        self._content_encoding = None\n\t        self._content_length = 0\n\t    def __repr__(self):\n\t        return (\n\t            f\"<HTTPResponse [{self.status_code.decode()}] {self.status_text.decode()}>\"\n\t        )\n\t    def _close_conn(self):\n\t        fp = self.fp\n\t        self.fp = None\n", "        fp.close()\n\t    def _read_status_line(self):\n\t        line = self.fp.readline(MAX_LINE + 1)\n\t        if len(line) > MAX_LINE:\n\t            raise InvalidStatusLine(\n\t                f\"The status line is too long, exceeding the {MAX_LINE} Max limit\"\n\t            )\n\t        if not line:\n\t            raise InvalidStatusLine(\n\t                f\"The remote servers return an invalid response status line: {line!r}\"\n", "            )\n\t        try:\n\t            protocol_version, status_code, status_text = line.split(None, 2)\n\t            self.protocol_version = protocol_version\n\t            self.status_code = status_code\n\t            self.status_text = status_text.strip()\n\t        except ValueError as err:\n\t            raise InvalidStatusLine(f\"Can't parse status line: {line!r}\") from err\n\t        if not self.protocol_version.startswith(b\"HTTP/\"):\n\t            self._close_conn()\n", "            raise InvalidStatusLine(f\"The status line version not support: {line!r}\")\n\t        return protocol_version, status_code, status_text\n\t    def _read_headers(self):\n\t        headers = []\n\t        while True:\n\t            line = self.fp.readline(MAX_LINE + 1)\n\t            if len(line) > MAX_LINE:\n\t                raise InvalidResponseHeaders(\n\t                    f\"The response headers is too long, exceeding the {MAX_LINE} Max limit\"\n\t                )\n", "            headers.append(line)\n\t            if len(headers) > MAX_HEADERS:\n\t                raise InvalidResponseHeaders(\n\t                    f\"The response headers is too long, exceeding the {MAX_LINE} Max limit\"\n\t                )\n\t            if line in (b\"\\r\\n\", b\"\\n\", b\"\"):\n\t                headers.pop()\n\t                break\n\t        return headers\n\t    def _parse_headers(self, headers_list=None):\n", "        headers = {}\n\t        headers_list = headers_list if headers_list is not None else self.headers\n\t        if headers_list is None:\n\t            raise ValueError(\"Required headers to parse.\")\n\t        self.headers = b\"\"\n\t        for header in headers_list[1:]:\n\t            self.headers += header\n\t            name, value = header.strip().split(b\": \")\n\t            headers.setdefault(name.lower(), value)\n\t        return headers\n", "    def read_body(self):\n\t        \"\"\"\n\t        Read body from remote connection.\n\t        :return:\n\t        \"\"\"\n\t        body = b\"\"\n\t        if self.fp is None:\n\t            return body\n\t        if self._method == \"HEAD\":\n\t            self._close_conn()\n", "            return body\n\t        if self._chunked:\n\t            body = self._read_chunked()\n\t        if self._content_length > 0:\n\t            body = self.fp.read(self._content_length)\n\t        if self._content_encoding is not None or self._content_encoding != b\"\":\n\t            if self._content_encoding == b\"gzip\":\n\t                body = gzip.decompress(body)\n\t            elif self._content_encoding == b\"deflate\":\n\t                try:\n", "                    body = zlib.decompress(body, -zlib.MAX_WBITS)\n\t                except zlib.error:\n\t                    body = zlib.decompress(body)\n\t            elif self._content_encoding == b\"br\":\n\t                body = brotli.decompress(body)\n\t        return body\n\t    def _read_chunked(self):\n\t        chunked_data = b\"\"\n\t        while True:\n\t            chunked_size = self.fp.readline(MAX_LINE + 1).strip()\n", "            if chunked_size == b\"\":\n\t                continue\n\t            if chunked_size == b\"0\":\n\t                break\n\t            size = int(chunked_size, 16)\n\t            chunked_data += self.fp.read(size)\n\t        return chunked_data\n\t    def begin(self):\n\t        \"\"\"\n\t        Receive data from remote connection and begin parse message.\n", "        :return:\n\t        \"\"\"\n\t        if self.headers is not None:\n\t            return\n\t        self._read_status_line()\n\t        self.headers = self._read_headers()\n\t        headers = self._parse_headers()\n\t        self._content_encoding = headers.get(b\"content-encoding\", b\"\")\n\t        transfer_encoding = headers.get(b\"transfer-encoding\", b\"\")\n\t        if transfer_encoding == b\"chunked\":\n", "            self._chunked = True\n\t        elif transfer_encoding != b\"\":\n\t            raise IssueError(\n\t                \"This situation may not be considered yet, please issue it\"\n\t            )\n\t        self._content_length = int(headers.get(b\"content-length\", 0))\n\tclass Response(BaseResponse):\n\t    \"\"\"Response\n\t    <Response [200]>\n\t    \"\"\"\n", "    def __init__(self, response=None):\n\t        super().__init__()\n\t        self.response = response\n\t    def __repr__(self):\n\t        return f\"<Response [{self.status_code}]>\"\n\t    @property\n\t    def headers(self):\n\t        \"\"\"\n\t        Response Headers.\n\t        :return:\n", "        \"\"\"\n\t        headers = []\n\t        if self.response is None:\n\t            return headers\n\t        headers_raw = self.response.headers.decode()\n\t        header_list = headers_raw.split(\"\\r\\n\")\n\t        for header_item in header_list:\n\t            if header_item == \"\":\n\t                continue\n\t            name, value = header_item.split(\": \", 1)\n", "            headers.append({name.strip(): value.strip()})\n\t        return headers\n\t    @property\n\t    def body(self):\n\t        \"\"\"\n\t        Response Body.\n\t        :return:\n\t        \"\"\"\n\t        body = b\"\"\n\t        if self.response is None:\n", "            return body\n\t        return self.response.read_body()\n\t    @property\n\t    def status_code(self):\n\t        \"\"\"\n\t        Response Status Code\n\t        :return:\n\t        \"\"\"\n\t        status_code = -1\n\t        if self.response is None:\n", "            return status_code\n\t        return int(self.response.status_code)\n\t    @property\n\t    def content(self):\n\t        \"\"\"\n\t        Response Content\n\t        :return:\n\t        \"\"\"\n\t        return self.body\n\t    @property\n", "    def text(self):\n\t        \"\"\"\n\t        Response Text\n\t        :return:\n\t        \"\"\"\n\t        return self.content.decode(\"utf8\")\n\t    def json(self):\n\t        \"\"\"\n\t        Response JSON\n\t        :return:\n", "        \"\"\"\n\t        return json.loads(self.body)\n"]}
{"filename": "ja3requests/sessions.py", "chunked_list": ["\"\"\"\n\tja3Requests.sessions\n\t~~~~~~~~~~~~~~~~~~~~\n\tThis module provides a Session object to manage and persist settings across\n\tja3Requests.\n\t\"\"\"\n\timport sys\n\timport time\n\tfrom http.cookiejar import CookieJar\n\tfrom typing import AnyStr, Any, Dict, ByteString, Union, List, Tuple\n", "from .base import BaseSession\n\tfrom .response import Response\n\tfrom .utils import default_headers\n\tfrom .const import DEFAULT_REDIRECT_LIMIT\n\tfrom .request import ReadyRequest, Request\n\t# Preferred clock, based on which one is more accurate on a given system.\n\tif sys.platform == \"win32\":\n\t    preferred_clock = time.perf_counter\n\telse:\n\t    preferred_clock = time.time\n", "class Session(BaseSession):\n\t    \"\"\"A Ja3Request session.\n\t    Provides cookie persistence, connection-pooling, and configuration.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.headers = default_headers()\n\t        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\t    def ready(self, method, url, params, data, headers, cookies, auth, json):\n\t        \"\"\"\n", "        Ready to send request.\n\t        :return:\n\t        \"\"\"\n\t        req = ReadyRequest(\n\t            method=method,\n\t            url=url,\n\t            params=params,\n\t            data=data,\n\t            headers=headers,\n\t            cookies=cookies,\n", "            auth=auth,\n\t            json=json,\n\t        )\n\t        req.ready()\n\t        return req\n\t    def request(\n\t        self,\n\t        method: AnyStr,\n\t        url: AnyStr,\n\t        params: Union[Dict[AnyStr, Any], ByteString] = None,\n", "        data: Union[Dict[AnyStr, Any], List, Tuple, ByteString] = None,\n\t        headers: Dict[AnyStr, AnyStr] = None,\n\t        cookies: Union[Dict[AnyStr, AnyStr], CookieJar] = None,\n\t        # files = None,\n\t        auth: Tuple = None,\n\t        timeout: float = None,\n\t        allow_redirects: bool = True,\n\t        proxies: Dict[AnyStr, AnyStr] = None,\n\t        json: Dict[AnyStr, AnyStr] = None,\n\t    ):\n", "        \"\"\"\n\t        Instantiating a request class<Request> and ready request<ReadyRequest> to send.\n\t        :param method:\n\t        :param url:\n\t        :param params:\n\t        :param data:\n\t        :param headers:\n\t        :param cookies:\n\t        :param auth:\n\t        :param timeout:\n", "        :param allow_redirects:\n\t        :param proxies:\n\t        :param json:\n\t        :return:\n\t        \"\"\"\n\t        ready_request = self.ready(\n\t            method=method,\n\t            url=url,\n\t            params=params,\n\t            data=data,\n", "            headers=headers,\n\t            cookies=cookies,\n\t            auth=auth,\n\t            json=json,\n\t        )\n\t        req = ready_request.request()\n\t        response = self.send(req)\n\t        return response\n\t    def get(self, url, **kwargs):\n\t        \"\"\"\n", "        Send a GET request.\n\t        :param url:\n\t        :param kwargs:\n\t        :return:\n\t        \"\"\"\n\t        return self.request(\"GET\", url, **kwargs)\n\t    def options(self, url, **kwargs):\n\t        \"\"\"\n\t        Send a OPTIONS request.\n\t        :param url:\n", "        :param kwargs:\n\t        :return:\n\t        \"\"\"\n\t        return self.request(\"OPTIONS\", url, **kwargs)\n\t    def head(self, url, **kwargs):\n\t        \"\"\"\n\t        Send a HEAD request.\n\t        :param url:\n\t        :param kwargs:\n\t        :return:\n", "        \"\"\"\n\t        kwargs.setdefault(\"allow_redirects\", False)\n\t        return self.request(\"HEAD\", url, **kwargs)\n\t    def post(self, url, data=None, json=None, **kwargs):\n\t        \"\"\"\n\t        Send a POST request.\n\t        :param url:\n\t        :param data:\n\t        :param json:\n\t        :param kwargs:\n", "        :return:\n\t        \"\"\"\n\t        return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\t    def put(self, url, data=None, **kwargs):\n\t        \"\"\"\n\t        Send a PUT request.\n\t        :param url:\n\t        :param data:\n\t        :param kwargs:\n\t        :return:\n", "        \"\"\"\n\t        return self.request(\"PUT\", url, data=data, **kwargs)\n\t    def patch(self, url, data=None, **kwargs):\n\t        \"\"\"\n\t        Send a PATCH request.\n\t        :param url:\n\t        :param data:\n\t        :param kwargs:\n\t        :return:\n\t        \"\"\"\n", "        return self.request(\"PATCH\", url, data=data, **kwargs)\n\t    def delete(self, url, data=None, **kwargs):\n\t        \"\"\"\n\t        Send a DELETE request.\n\t        :param url:\n\t        :param data:\n\t        :param kwargs:\n\t        :return:\n\t        \"\"\"\n\t        return self.request(\"DELETE\", url, **kwargs)\n", "    def send(self, request: Request):\n\t        \"\"\"\n\t        Send request.\n\t        :return:\n\t        \"\"\"\n\t        rep = request.send()\n\t        response = Response(rep)\n\t        return response\n"]}
{"filename": "ja3requests/context.py", "chunked_list": ["\"\"\"\n\tja3requests.context\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tHTTP Context and HTTPS Context\n\t\"\"\"\n\tfrom .base import BaseContext\n\tDEFAULT_HTTP_CONTEXT_PROTOCOL = 11\n\tDEFAULT_HTTP_VERSION = \"HTTP/1.1\"\n\tclass HTTPContext(BaseContext):\n\t    \"\"\"\n", "    HTTPContext\n\t    \"\"\"\n\t    def __init__(self, connection):\n\t        super().__init__()\n\t        self.protocol = DEFAULT_HTTP_CONTEXT_PROTOCOL\n\t        self.version = DEFAULT_HTTP_VERSION\n\t        self.connection = connection\n\t    @property\n\t    def message(self):\n\t        \"\"\"\n", "        HTTP Context message to send\n\t        :return:\n\t        \"\"\"\n\t        self.start_line = \" \".join([self.method, self.connection.path, self.version])\n\t        self._message = \"\\r\\n\".join([self.start_line, self.put_headers()])\n\t        self._message += \"\\r\\n\\r\\n\"\n\t        if self.body:\n\t            self._message += self.body\n\t        print(self._message)\n\t        return self._message.encode()\n", "    def set_payload(self, **kwargs):\n\t        \"\"\"\n\t        Set context payload\n\t        :param kwargs:\n\t        :return:\n\t        \"\"\"\n\t        for k, v in kwargs.items():\n\t            if hasattr(self, k):\n\t                setattr(self, k, v)\n\t    def put_headers(self):\n", "        \"\"\"\n\t        Set context headers\n\t        :return:\n\t        \"\"\"\n\t        headers = \"\"\n\t        if self.headers is not None:\n\t            if not self.headers.get(\"host\", None):\n\t                self.headers[\"host\"] = self.connection.host\n\t            headers = \"\\r\\n\".join([f\"{k}: {v}\" for k, v in self.headers.items()])\n\t        return headers\n"]}
{"filename": "ja3requests/__init__.py", "chunked_list": ["from .sessions import Session\n\tdef session():\n\t    \"\"\"\n\t    Return a Session object.\n\t    :return:\n\t    \"\"\"\n\t    return Session()\n"]}
{"filename": "ja3requests/utils.py", "chunked_list": ["\"\"\"\n\tja3requests.utils\n\t~~~~~~~~~~~~~~~~~\n\tThis module provides utility functions.\n\t\"\"\"\n\timport platform\n\tfrom base64 import b64encode\n\tfrom typing import Union, AnyStr, List\n\tfrom .__version__ import __version__\n\tACCEPT_ENCODING = \"gzip,deflate\"\n", "def b(s: AnyStr):  # pylint: disable=C\n\t    \"\"\"\n\t    String encode latin1\n\t    :param s:\n\t    :return:\n\t    \"\"\"\n\t    return s.encode(\"latin1\")\n\tdef default_user_agent(agent: AnyStr = \"Ja3Requests\"):\n\t    \"\"\"\n\t    Return a string representing the default user agent.\n", "    :param agent:\n\t    :return: str\n\t    \"\"\"\n\t    return f\"Python/{platform.python_version()} ({platform.system()}; {platform.platform()}) {agent}/{__version__}\"\n\tdef make_headers(\n\t    keep_alive: bool = None,\n\t    accept_encoding: Union[AnyStr, List[AnyStr]] = None,\n\t    user_agent: AnyStr = None,\n\t    basic_auth: AnyStr = None,\n\t    proxy_basic_auth: AnyStr = None,\n", "    disable_cache: bool = None,\n\t):\n\t    \"\"\"\n\t    Shortcuts for generating request headers.\n\t    :param keep_alive:\n\t    :param accept_encoding:\n\t    :param user_agent:\n\t    :param basic_auth: username:password\n\t    :param proxy_basic_auth: username:password\n\t    :param disable_cache:\n", "    :return: dict\n\t    \"\"\"\n\t    headers = {\"Accept\": \"*/*\"}\n\t    if accept_encoding:\n\t        if isinstance(accept_encoding, str):\n\t            pass\n\t        elif isinstance(accept_encoding, list):\n\t            accept_encoding = \",\".join(accept_encoding)\n\t        else:\n\t            accept_encoding = ACCEPT_ENCODING\n", "        headers[\"Accept-Encoding\"] = accept_encoding\n\t    if keep_alive:\n\t        headers[\"Connection\"] = \"keep-alive\"\n\t    if basic_auth:\n\t        headers[\"Authorization\"] = \"Basic \" + b64encode(b(basic_auth)).decode(\"utf-8\")\n\t    if proxy_basic_auth:\n\t        headers[\"Proxy-Authorization\"] = \"Basic \" + b64encode(\n\t            b(proxy_basic_auth)\n\t        ).decode(\"utf-8\")\n\t    if disable_cache:\n", "        headers[\"Cache-Control\"] = \"no-cache\"\n\t    headers[\"User-Agent\"] = user_agent if user_agent else default_user_agent()\n\t    return headers\n\tdef default_headers():\n\t    \"\"\"\n\t    Return default headers.\n\t    :return:\n\t    \"\"\"\n\t    return make_headers(keep_alive=True)\n"]}
{"filename": "ja3requests/connections.py", "chunked_list": ["\"\"\"\n\tja3requests.connections\n\t~~~~~~~~~~~~~~~~~~~~~~~\n\tThis module contains HTTP connection and HTTPS connection.\n\t\"\"\"\n\tfrom .response import HTTPResponse\n\tfrom .exceptions import InvalidHost\n\tfrom .base import BaseHttpConnection\n\tfrom .protocol.sockets import create_connection\n\tfrom .const import DEFAULT_HTTP_SCHEME\n", "from .const import DEFAULT_HTTP_PORT\n\tfrom .protocol.exceptions import SocketTimeout, ConnectTimeoutError\n\tclass HTTPConnection(BaseHttpConnection):\n\t    \"\"\"\n\t    HTTP connection.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.scheme = DEFAULT_HTTP_SCHEME\n\t        self.port = DEFAULT_HTTP_PORT\n", "        self.is_close = False\n\t    def __del__(self):\n\t        self.close()\n\t    def _new_conn(self):\n\t        \"\"\"\n\t        Establish a socket connection\n\t        :return: socket connection\n\t        \"\"\"\n\t        try:\n\t            conn = create_connection(\n", "                (self.destination_address, self.port),\n\t                self.timeout,\n\t                self.source_address,\n\t            )\n\t        except SocketTimeout as err:\n\t            raise ConnectTimeoutError(\n\t                f\"Connection to {self.destination_address} timeout out. timeout={self.timeout}\"\n\t            ) from err\n\t        return conn\n\t    def _ready_connect(self, **kwargs):\n", "        \"\"\"\n\t        Ready http connection.\n\t        :param kwargs:\n\t        :return:\n\t        \"\"\"\n\t        self.scheme = kwargs[\"scheme\"] if kwargs.get(\"scheme\", None) else self.scheme\n\t        self.port = kwargs[\"port\"] if kwargs.get(\"port\", None) else self.port\n\t        self.source_address = (\n\t            kwargs[\"source_address\"]\n\t            if kwargs.get(\"source_address\", None)\n", "            else self.source_address\n\t        )\n\t        self.timeout = (\n\t            kwargs[\"timeout\"] if kwargs.get(\"timeout\", None) else self.timeout\n\t        )\n\t        self.proxy = kwargs[\"proxy\"] if kwargs.get(\"proxy\", None) else self.proxy\n\t        self.proxy_username = (\n\t            kwargs[\"proxy_username\"]\n\t            if kwargs.get(\"proxy_username\", None)\n\t            else self.proxy_username\n", "        )\n\t        self.proxy_password = (\n\t            kwargs[\"proxy_password\"]\n\t            if kwargs.get(\"proxy_password\", None)\n\t            else self.proxy_password\n\t        )\n\t        if kwargs.get(\"host\", None):\n\t            host = kwargs[\"host\"].replace(\"http://\", \"\").split(\"/\")\n\t            if len(host) > 0:\n\t                self.host = host[0]\n", "                self.path = \"/\" + \"/\".join(host[1:])\n\t                if \":\" in self.host:\n\t                    self.destination_address = self.host.split(\":\")[0]\n\t                    if self.port is None:\n\t                        self.port = self.host.split(\":\")[1]\n\t                else:\n\t                    self.destination_address = self.host\n\t            else:\n\t                raise InvalidHost(\n\t                    f\"Invalid Host: {kwargs['host']!r}, can not parse destination address or path.\"\n", "                )\n\t    def connect(\n\t        self,\n\t        scheme=None,\n\t        port=None,\n\t        source_address=None,\n\t        host=None,\n\t        timeout=None,\n\t        proxy=None,\n\t        proxy_username=None,\n", "        proxy_password=None,\n\t    ):\n\t        \"\"\"\n\t        Create an http connection.\n\t        :param scheme:\n\t        :param port:\n\t        :param source_address:\n\t        :param host:\n\t        :param timeout:\n\t        :param proxy:\n", "        :param proxy_username:\n\t        :param proxy_password:\n\t        :return:\n\t        \"\"\"\n\t        self._ready_connect(\n\t            scheme=scheme,\n\t            port=port,\n\t            source_address=source_address,\n\t            host=host,\n\t            timeout=timeout,\n", "            proxy=proxy,\n\t            proxy_username=proxy_username,\n\t            proxy_password=proxy_password,\n\t        )\n\t        conn = self._new_conn()\n\t        self.connection = conn\n\t    def send(self, context):\n\t        \"\"\"\n\t        Send socket.\n\t        :return:\n", "        \"\"\"\n\t        self.connection.sendall(context.message)\n\t        response = HTTPResponse(sock=self.connection, method=context.method)\n\t        response.begin()\n\t        return response\n\t    def close(self):\n\t        \"\"\"\n\t        Close connection.\n\t        :return:\n\t        \"\"\"\n", "        if self.connection:\n\t            self.connection.close()\n"]}
{"filename": "ja3requests/const.py", "chunked_list": ["\"\"\"\n\tja3requests.const\n\t~~~~~~~~~~~~~~~~~\n\tA constant module.\n\t\"\"\"\n\timport sys\n\tclass _Const:\n\t    class ConstError(TypeError):\n\t        \"\"\"\n\t        Const Error\n", "        \"\"\"\n\t    class ConstCaseError(ConstError):\n\t        \"\"\"\n\t        Const Case Error\n\t        \"\"\"\n\t    def __setattr__(self, key, value):\n\t        if self.__dict__.get(key) is not None:\n\t            raise self.ConstError(f\"The constant {key} already exists\")\n\t        if not key.isupper():\n\t            raise self.ConstCaseError(f\"{key}-constants need to be capitalized.\")\n", "        self.__dict__[key] = value\n\tconst = _Const()\n\tconst.MAX_LINE = 65536\n\tconst.MAX_HEADERS = 100\n\tconst.DEFAULT_CHUNKED_SIZE = 2048\n\tconst.DEFAULT_HTTP_SCHEME = \"http\"\n\tconst.DEFAULT_HTTPS_SCHEME = \"https\"\n\tconst.DEFAULT_HTTP_PORT = 80\n\tconst.DEFAULT_HTTPS_PORT = 443\n\tconst.DEFAULT_REDIRECT_LIMIT = 8  # max redirect\n", "sys.modules[__name__] = const\n"]}
{"filename": "ja3requests/__version__.py", "chunked_list": ["\"\"\"\n\tja3requests.__version__\n\t~~~~~~~~~~~~~~~~~~~~~~~\n\tVersion information.\n\t\"\"\"\n\t__title__ = \"ja3requests\"\n\t__description__ = \"An http request library that can customize ja3 or h2 fingerprints.\"\n\t__url__ = \"https://github.com/lxjmaster/ja3requests\"\n\t__version__ = \"1.0.2\"\n\t__author__ = \"Mast Luo\"\n", "__author_email__ = \"379501669@qq.com\"\n\t__license__ = \"Apache-2.0 license\"\n\t__copyright__ = \"Copyright Mast Luo\"\n"]}
{"filename": "ja3requests/exceptions.py", "chunked_list": ["\"\"\"\n\tja3requests.exceptions\n\t~~~~~~~~~~~~~~~~~~~~~~\n\tThis module contains the set of Requests' exceptions.\n\t\"\"\"\n\tclass RequestException(IOError):\n\t    \"\"\"\n\t    There was an ambiguous exception that occurred while handling your request.\n\t    \"\"\"\n\t    def __init__(self, *args, **kwargs):\n", "        \"\"\"\n\t        Initialize RequestException with `request` and `response` objects.\n\t        \"\"\"\n\t        response = kwargs.pop(\"response\", None)\n\t        self.response = response\n\t        self.request = kwargs.pop(\"request\", None)\n\t        if response is not None and not self.request and hasattr(response, \"request\"):\n\t            self.request = self.response.request\n\t        super().__init__(*args, **kwargs)\n\tclass NotAllowedRequestMethod(RequestException, ValueError):\n", "    \"\"\"\n\t    If the request method not allowed and raise it.\n\t    \"\"\"\n\tclass MissingScheme(RequestException, ValueError):\n\t    \"\"\"\n\t    The URL scheme (e.g. http or https) is missing and raise it.\n\t    \"\"\"\n\tclass NotAllowedScheme(RequestException, ValueError):\n\t    \"\"\"\n\t    If the scheme not allowed and raise it.\n", "    \"\"\"\n\tclass InvalidParams(RequestException, ValueError):\n\t    \"\"\"\n\t    If request params invalid and raise it.\n\t    \"\"\"\n\tclass InvalidHost(RequestException, ValueError):\n\t    \"\"\"\n\t    Raised it while host can not parse.\n\t    \"\"\"\n\tclass InvalidStatusLine(RequestException, ValueError):\n", "    \"\"\"\n\t    Raised it when can't receive streamline.\n\t    \"\"\"\n\tclass InvalidResponseHeaders(RequestException, ValueError):\n\t    \"\"\"\n\t    Raised it when cant receive response headers.\n\t    \"\"\"\n\tclass IssueError(ValueError):\n\t    \"\"\"\n\t    This situation may not be considered yet, please issue it\n", "    \"\"\"\n"]}
{"filename": "ja3requests/request.py", "chunked_list": ["\"\"\"\n\tja3requests.request\n\t~~~~~~~~~~~~~~~~~~~\n\tThis module create a request struct and ready request object.\n\t\"\"\"\n\timport warnings\n\tfrom http.cookiejar import CookieJar\n\tfrom urllib.parse import urlparse, urlencode\n\tfrom typing import Any, AnyStr, Dict, List, Union, ByteString, Tuple\n\tfrom .base import BaseRequest\n", "from .utils import default_headers\n\tfrom .context import HTTPContext\n\tfrom .connections import HTTPConnection\n\tfrom .exceptions import (\n\t    NotAllowedRequestMethod,\n\t    MissingScheme,\n\t    NotAllowedScheme,\n\t    InvalidParams,\n\t)\n\tclass ReadyRequest(BaseRequest):\n", "    \"\"\"\n\t    Ready a request, e.g.(check url, check params)\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        method: AnyStr,\n\t        url: AnyStr,\n\t        params: Union[\n\t            Dict[Any, Any],\n\t            List[Tuple[Any, Any]],\n", "            Tuple[Tuple[Any, Any]],\n\t            ByteString,\n\t            AnyStr,\n\t        ] = None,\n\t        data: Union[Dict[AnyStr, Any], List, Tuple, ByteString] = None,\n\t        headers: Dict[AnyStr, AnyStr] = None,\n\t        cookies: Union[Dict[AnyStr, AnyStr], CookieJar] = None,\n\t        auth: Tuple = None,\n\t        json: Dict[AnyStr, AnyStr] = None,\n\t    ):\n", "        super().__init__()\n\t        self.method = method\n\t        self.url = url\n\t        self.params = params\n\t        self.data = data\n\t        self.headers = headers\n\t        self.cookies = cookies\n\t        self.auth = auth\n\t        self.json = json\n\t    def __repr__(self):\n", "        return f\"<ReadyRequest [{self.method}]>\"\n\t    def ready_method(self):\n\t        \"\"\"\n\t        Ready request method and check request method whether allow used.\n\t        :return:\n\t        \"\"\"\n\t        if self.method == \"\" or self.method not in [\n\t            \"GET\",\n\t            \"OPTIONS\",\n\t            \"HEAD\",\n", "            \"POST\",\n\t            \"PUT\",\n\t            \"PATCH\",\n\t            \"DELETE\",\n\t        ]:\n\t            raise NotAllowedRequestMethod(self.method)\n\t        self.method = self.method.upper()\n\t    def ready_url(self):\n\t        \"\"\"\n\t        Ready http url and check url whether valid.\n", "        :return:\n\t        \"\"\"\n\t        if self.url == \"\":\n\t            raise ValueError(\"The request url is required.\")\n\t        # Remove whitespaces for url\n\t        self.url.strip()\n\t        parse = urlparse(self.url)\n\t        # Check HTTP scheme\n\t        if parse.scheme == \"\":\n\t            raise MissingScheme(\n", "                f\"Invalid URL {self.url!r}: No scheme supplied. \"\n\t                f\"Perhaps you meant http://{self.url} or https://{self.url}\"\n\t            )\n\t        # Just allow http or https\n\t        if parse.scheme not in [\"http\", \"https\"]:\n\t            raise NotAllowedScheme(f\"Schema: {parse.scheme} not allowed.\")\n\t        self.scheme = parse.scheme\n\t        if self.scheme == \"https\":\n\t            self.port = 443\n\t        if parse.netloc != \"\" and \":\" in parse.netloc:\n", "            port = parse.netloc.split(\":\")[-1]\n\t            self.port = int(port)\n\t        else:\n\t            self.port = 80\n\t    def ready_params(self):\n\t        \"\"\"\n\t        Ready params.\n\t        :return:\n\t        \"\"\"\n\t        if self.params:\n", "            parse = urlparse(self.url)\n\t            if isinstance(self.params, str):\n\t                params = self.params\n\t            elif isinstance(self.params, bytes):\n\t                params = self.params.decode()\n\t            elif isinstance(self.params, (dict, list, tuple)):\n\t                params = urlencode(self.params)\n\t            else:\n\t                raise InvalidParams(f\"Invalid params: {self.params!r}\")\n\t            if params.startswith(\"?\"):\n", "                params = params.replace(\"?\", \"\")\n\t            if parse.query != \"\":\n\t                self.url = \"&\" + params\n\t            else:\n\t                self.url = \"?\" + params\n\t    def ready_data(self):\n\t        \"\"\"\n\t        Ready form data.\n\t        :return:\n\t        \"\"\"\n", "        if self.data:\n\t            if self.headers is not None:\n\t                content_type = self.headers.get(\"Content-Type\", \"\")\n\t                if content_type == \"\":\n\t                    self.headers[\"Content-Type\"] = content_type = \"application/x-www-form-urlencoded\"\n\t            else:\n\t                self.headers = default_headers()\n\t                self.headers[\"Content-Type\"] = content_type = \"application/x-www-form-urlencoded\"\n\t            if content_type == \"application/x-www-form-urlencoded\":\n\t                self.data = urlencode(self.data)\n", "                self.headers[\"Content-Length\"] = len(self.data)\n\t        print(self.data)\n\t    def ready_headers(self):\n\t        \"\"\"\n\t        Ready http headers.\n\t        :return:\n\t        \"\"\"\n\t        # Default headers\n\t        if self.headers is None:\n\t            self.headers = default_headers()\n", "        # Check duplicate default item\n\t        new_headers = {}\n\t        header_list = []\n\t        for k, v in self.headers.items():\n\t            header = k.title()\n\t            if header in header_list:\n\t                warnings.warn(\n\t                    f\"Duplicate header: {k}, you should check the request headers.\",\n\t                    RuntimeWarning,\n\t                )\n", "            header_list.append(header)\n\t            new_headers[header] = v\n\t        self.headers = new_headers\n\t        del new_headers\n\t        del header_list\n\t    def ready_cookies(self):\n\t        \"\"\"\n\t        Todo: Ready http cookies.\n\t        :return:\n\t        \"\"\"\n", "    def ready_auth(self):\n\t        \"\"\"\n\t        Todo: Ready http authenticator\n\t        :return:\n\t        \"\"\"\n\t    def ready_json(self):\n\t        \"\"\"\n\t        Todo: Ready post json.\n\t        :return:\n\t        \"\"\"\n", "    def ready(self):\n\t        \"\"\"\n\t        Make a ready request to send.\n\t        :return:\n\t        \"\"\"\n\t        self.ready_method()\n\t        self.ready_url()\n\t        self.ready_params()\n\t        self.ready_headers()\n\t        self.ready_data()\n", "        self.ready_cookies()\n\t        self.ready_auth()\n\t        self.ready_json()\n\t    def request(self):\n\t        \"\"\"\n\t        Create a Request object.\n\t        :return:\n\t        \"\"\"\n\t        req = Request()\n\t        req.clone(self)\n", "        return req\n\tclass Request(BaseRequest):\n\t    \"\"\"\n\t    Request object to send.\n\t    \"\"\"\n\t    def __repr__(self):\n\t        return f\"<Request [{self.method}]>\"\n\t    def clone(self, ready_request: ReadyRequest):\n\t        \"\"\"\n\t        Clone arguments from ReadyRequest\n", "        :param ready_request:\n\t        :return:\n\t        \"\"\"\n\t        for k, v in ready_request.__dict__.items():\n\t            setattr(self, k, v)\n\t    def send(self):\n\t        \"\"\"\n\t        Connection sending.\n\t        :return:\n\t        \"\"\"\n", "        conn = self.create_connect()\n\t        proxy, proxy_username, proxy_password = self.parse_proxies()\n\t        conn.connect(\n\t            self.scheme,\n\t            self.port,\n\t            self.source,\n\t            self.url,\n\t            self.timeout,\n\t            proxy,\n\t            proxy_username,\n", "            proxy_password,\n\t        )\n\t        context = HTTPContext(conn)\n\t        context.set_payload(\n\t            method=self.method,\n\t            headers=self.headers,\n\t            body=self.data,\n\t        )\n\t        response = conn.send(context)\n\t        return response\n", "    def create_connect(self):\n\t        \"\"\"\n\t        Create http connection or https connection by request scheme.\n\t        :return:\n\t        \"\"\"\n\t        if self.is_http():\n\t            conn = HTTPConnection()\n\t        elif self.is_https():\n\t            # TODO: HTTPS\n\t            # conn = HTTPSConnection()\n", "            raise NotImplementedError(\"HTTPS not implemented yet.\")\n\t        else:\n\t            raise MissingScheme(\n\t                f\"Scheme: {self.scheme}, parse scheme failed, can't create connection.\"\n\t            )\n\t        return conn\n\t    def parse_proxies(self):\n\t        \"\"\"\n\t        TODO\n\t        Parse proxy, proxy's username and password. if proxies is set.\n", "        :return:\n\t        \"\"\"\n\t        return None, None, None\n"]}
{"filename": "ja3requests/protocol/__init__.py", "chunked_list": []}
{"filename": "ja3requests/protocol/sockets.py", "chunked_list": ["# pylint: skip-file\n\t\"\"\"\n\tja3requests.protocol.sockets\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tThis module contains socket dependencies.\n\t\"\"\"\n\timport socket\n\tfrom .exceptions import LocationParseError\n\tdef create_connection(\n\t    address,\n", "    timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n\t    source_address=None,\n\t    socket_options=None,\n\t):\n\t    \"\"\"\n\t    Create a socket connection.\n\t    :param address:\n\t    :param timeout:\n\t    :param source_address:\n\t    :param socket_options:\n", "    :return:\n\t    \"\"\"\n\t    if socket_options is None:\n\t        socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]\n\t    err = None\n\t    host, port = address\n\t    family = allowed_gai_family()\n\t    try:\n\t        host.encode(\"idna\")\n\t    except UnicodeError:\n", "        raise LocationParseError(f\"{host!r}, label empty or too long\")\n\t    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n\t        _family, _type, _proto, _canonname, _addr = res\n\t        sock = None\n\t        try:\n\t            sock = socket.socket(_family, _type, _proto)\n\t            # If provided, set socket level options before connecting.\n\t            _set_socket_options(sock, socket_options)\n\t            if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n\t                sock.settimeout(timeout)\n", "            if source_address:\n\t                sock.bind(source_address)\n\t            sock.connect(_addr)\n\t            return sock\n\t        except socket.error as e:\n\t            err = e\n\t            if sock is not None:\n\t                sock.close()\n\t    if err is not None:\n\t        raise err\n", "    raise socket.error(\"getaddrinfo returns an empty list\")\n\tdef _set_socket_options(sock, options):\n\t    if options is None:\n\t        return\n\t    for opt in options:\n\t        sock.setsockopt(*opt)\n\tdef allowed_gai_family():\n\t    family = socket.AF_INET\n\t    if HAS_IPV6:\n\t        family = socket.AF_UNSPEC\n", "    return family\n\tdef _has_ipv6(host):\n\t    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"\n\t    sock = None\n\t    has_ipv6 = False\n\t    if socket.has_ipv6:\n\t        try:\n\t            sock = socket.socket(socket.AF_INET6)\n\t            sock.bind((host, 0))\n\t            has_ipv6 = True\n", "        except Exception:\n\t            pass\n\t    if sock:\n\t        sock.close()\n\t    return has_ipv6\n\tHAS_IPV6 = _has_ipv6(\"::1\")\n"]}
{"filename": "ja3requests/protocol/exceptions.py", "chunked_list": ["\"\"\"\n\tja3requests.protocol.exceptions\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tThis module contains socket exceptions.\n\t\"\"\"\n\tclass SocketException(Exception):\n\t    \"\"\"\n\t    Base exception used by this module.\n\t    \"\"\"\n\tclass SocketTimeout(OSError):\n", "    \"\"\"Timeout expired.\"\"\"\n\tclass LocationParseError(SocketException, ValueError):\n\t    \"\"\"\n\t    Socket host encode error.\n\t    \"\"\"\n\tclass SocketTimeoutError(SocketException):\n\t    \"\"\"\n\t    Raised when a socket timeout error occurs.\n\t    \"\"\"\n\tclass ConnectTimeoutError(SocketTimeoutError):\n", "    \"\"\"\n\t    Raised when a socket timeout occurs while connecting to a server\n\t    \"\"\"\n\tclass ReadTimeout(SocketTimeoutError):\n\t    \"\"\"\n\t    Raised when socket receive timeout.\n\t    \"\"\"\n"]}
{"filename": "ja3requests/base/_connection.py", "chunked_list": ["\"\"\"\n\tja3Requests.base._connection\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tBasic HTTP Connection\n\t\"\"\"\n\tclass BaseHttpConnection:\n\t    \"\"\"\n\t    Basic HTTP Connection\n\t    \"\"\"\n\t    def __init__(self):\n", "        self._scheme = None\n\t        self._host = None\n\t        self._port = None\n\t        self._source_address = None\n\t        self._destination_address = None\n\t        self._path = None\n\t        self._timeout = None\n\t        self._proxy = None\n\t        self._proxy_username = None\n\t        self._proxy_password = None\n", "        self._connection = None\n\t        self._is_close = None\n\t    @property\n\t    def scheme(self):\n\t        \"\"\"\n\t        Scheme\n\t        :return:\n\t        \"\"\"\n\t        return self._scheme\n\t    @scheme.setter\n", "    def scheme(self, attr):\n\t        \"\"\"\n\t        Set Scheme\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._scheme = attr\n\t    @property\n\t    def host(self):\n\t        \"\"\"\n", "        Host\n\t        :return:\n\t        \"\"\"\n\t        return self._host\n\t    @host.setter\n\t    def host(self, attr):\n\t        \"\"\"\n\t        Set Host\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._host = attr\n\t    @property\n\t    def port(self):\n\t        \"\"\"\n\t        Port\n\t        :return:\n\t        \"\"\"\n\t        return self._port\n\t    @port.setter\n", "    def port(self, attr):\n\t        \"\"\"\n\t        Set Port\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._port = attr\n\t    @property\n\t    def source_address(self):\n\t        \"\"\"\n", "        Source Address\n\t        :return:\n\t        \"\"\"\n\t        return self._source_address\n\t    @source_address.setter\n\t    def source_address(self, attr):\n\t        \"\"\"\n\t        Set Source Address\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._source_address = attr\n\t    @property\n\t    def destination_address(self):\n\t        \"\"\"\n\t        Destination Address\n\t        :return:\n\t        \"\"\"\n\t        return self._destination_address\n\t    @destination_address.setter\n", "    def destination_address(self, attr):\n\t        \"\"\"\n\t        Set Destination Address\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._destination_address = attr\n\t    @property\n\t    def path(self):\n\t        \"\"\"\n", "        Path\n\t        :return:\n\t        \"\"\"\n\t        return self._path\n\t    @path.setter\n\t    def path(self, attr):\n\t        \"\"\"\n\t        Set Path\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._path = attr\n\t    @property\n\t    def timeout(self):\n\t        \"\"\"\n\t        Timeout\n\t        :return:\n\t        \"\"\"\n\t        return self._timeout\n\t    @timeout.setter\n", "    def timeout(self, attr):\n\t        \"\"\"\n\t        Set Timeout\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._timeout = attr\n\t    @property\n\t    def proxy(self):\n\t        \"\"\"\n", "        Proxy\n\t        :return:\n\t        \"\"\"\n\t        return self._proxy\n\t    @proxy.setter\n\t    def proxy(self, attr):\n\t        \"\"\"\n\t        Set Proxy\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._proxy = attr\n\t    @property\n\t    def proxy_username(self):\n\t        \"\"\"\n\t        Proxy username\n\t        :return:\n\t        \"\"\"\n\t        return self._proxy_username\n\t    @proxy_username.setter\n", "    def proxy_username(self, attr):\n\t        \"\"\"\n\t        Set Proxy Username\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._proxy_username = attr\n\t    @property\n\t    def proxy_password(self):\n\t        \"\"\"\n", "        Proxy Password\n\t        :return:\n\t        \"\"\"\n\t        return self._proxy_password\n\t    @proxy_password.setter\n\t    def proxy_password(self, attr):\n\t        \"\"\"\n\t        Set Proxy Password\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._proxy_password = attr\n\t    @property\n\t    def connection(self):\n\t        \"\"\"\n\t        Connection\n\t        :return:\n\t        \"\"\"\n\t        return self._connection\n\t    @connection.setter\n", "    def connection(self, attr):\n\t        \"\"\"\n\t        Set Connection\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._connection = attr\n\t    @property\n\t    def is_close(self):\n\t        \"\"\"\n", "        Connection is closed\n\t        :return:\n\t        \"\"\"\n\t        return self._is_close\n\t    @is_close.setter\n\t    def is_close(self, attr):\n\t        \"\"\"\n\t        Set connection close\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._is_close = attr\n"]}
{"filename": "ja3requests/base/_response.py", "chunked_list": ["\"\"\"\n\tja3Requests.base._response\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tBasic Response\n\t\"\"\"\n\tclass BaseResponse:\n\t    \"\"\"\n\t    The basic response.\n\t    \"\"\"\n\t    def __init__(self):\n", "        self._raw = None\n\t        self._protocol_version = None\n\t        self._status_code = None\n\t        self._status_text = None\n\t        self._headers = None\n\t        self._body = None\n\t    @property\n\t    def raw(self):\n\t        \"\"\"Raw Response\n\t        Receive from remote connection.\n", "        >>> b\"HTTP/1.1 200 OK...\"\n\t        :return:\n\t        \"\"\"\n\t        return self._raw\n\t    @raw.setter\n\t    def raw(self, attr):\n\t        \"\"\"\n\t        Set raw response.\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._raw = attr\n\t    @property\n\t    def protocol_version(self):\n\t        \"\"\"\n\t        Protocol Version\n\t        >>> b\"HTTP/1.1\"\n\t        :return:\n\t        \"\"\"\n\t        return self._protocol_version\n", "    @protocol_version.setter\n\t    def protocol_version(self, attr):\n\t        \"\"\"\n\t        Set protocol version\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._protocol_version = attr\n\t    @property\n\t    def status_code(self):\n", "        \"\"\"STATUS CODE\n\t        The response status code, e.g(200, 203, 400, 404...)\n\t        >>> b\"200\"\n\t        :return:\n\t        \"\"\"\n\t        return self._status_code\n\t    @status_code.setter\n\t    def status_code(self, attr):\n\t        \"\"\"\n\t        Set response status code.\n", "        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._status_code = attr\n\t    @property\n\t    def status_text(self):\n\t        \"\"\"\n\t        Response status text. eg. HTTP/1.1 200 OK\n\t        >>> b\"OK\"\n\t        :return:\n", "        \"\"\"\n\t        return self._status_text\n\t    @status_text.setter\n\t    def status_text(self, attr):\n\t        \"\"\"\n\t        Set response status text.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._status_text = attr\n", "    @property\n\t    def headers(self):\n\t        \"\"\"Headers\n\t        Response headers\n\t        :return:\n\t        \"\"\"\n\t        return self._headers\n\t    @headers.setter\n\t    def headers(self, attr):\n\t        \"\"\"\n", "        Set response headers.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._headers = attr\n\t    @property\n\t    def body(self):\n\t        \"\"\"\n\t        Response Body\n\t        :return:\n", "        \"\"\"\n\t        return self._body\n\t    @body.setter\n\t    def body(self, attr):\n\t        \"\"\"\n\t        Set response body.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._body = attr\n"]}
{"filename": "ja3requests/base/__init__.py", "chunked_list": ["\"\"\"\n\tja3requests.base\n\t~~~~~~~~~~~~~~~~\n\tBasic module.\n\t\"\"\"\n\tfrom ._context import BaseContext\n\tfrom ._request import BaseRequest\n\tfrom ._sessions import BaseSession\n\tfrom ._response import BaseResponse\n\tfrom ._connection import BaseHttpConnection\n"]}
{"filename": "ja3requests/base/_sessions.py", "chunked_list": ["\"\"\"\n\tja3Requests.base._sessions\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tBasic Session\n\t\"\"\"\n\tclass BaseSession:\n\t    \"\"\"\n\t    The basic request session.\n\t    \"\"\"\n\t    def __init__(self):\n", "        self._headers = None\n\t        self._cookies = None\n\t        self._auth = None\n\t        self._proxies = None\n\t        self._params = None\n\t        self._max_redirects = None\n\t        self._allow_redirect = None\n\t        self._ja3_text = None\n\t        self._h2_settings = None\n\t        self._h2_window_update = None\n", "        self._h2_headers = None\n\t    @property\n\t    def headers(self):\n\t        \"\"\"Headers\n\t        Http headers.\n\t        >>> {'Accept': '*/*', 'Accept-Encoding': 'gzip,deflate'}\n\t        :return:\n\t        \"\"\"\n\t        return self._headers\n\t    @headers.setter\n", "    def headers(self, attr):\n\t        \"\"\"\n\t        Set Headers\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._headers = attr\n\t    @property\n\t    def cookies(self):\n\t        \"\"\"Cookies\n", "        Http cookies.\n\t        >>> CookieJar({})\n\t        :return:\n\t        \"\"\"\n\t        return self._cookies\n\t    @cookies.setter\n\t    def cookies(self, attr):\n\t        \"\"\"\n\t        Set Cookies\n\t        :param attr:\n", "        :return:\n\t        \"\"\"\n\t        self.cookies = attr\n\t    @property\n\t    def auth(self):\n\t        \"\"\"Auth\n\t        >>> {'user': 'xxx', 'password': 'xxx'}\n\t        :return:\n\t        \"\"\"\n\t        return self._auth\n", "    @auth.setter\n\t    def auth(self, attr):\n\t        \"\"\"\n\t        Set Auth\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._auth = attr\n\t    @property\n\t    def proxies(self):\n", "        \"\"\"Proxies\n\t        Http proxy server.\n\t        >>> {'http': 'user:password@host:port', 'https': 'user:password@host:port'}\n\t        :return:\n\t        \"\"\"\n\t        return self._cookies\n\t    @proxies.setter\n\t    def proxies(self, attr):\n\t        \"\"\"\n\t        Set Proxies\n", "        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._proxies = attr\n\t    @property\n\t    def params(self):\n\t        \"\"\"Params.\n\t        Request Params. ?page=1&per_page=10\n\t        >>> {'page': 1, 'per_page': 10}\n\t        :return:\n", "        \"\"\"\n\t        return self._params\n\t    @params.setter\n\t    def params(self, attr):\n\t        \"\"\"\n\t        Set Params\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._params = attr\n", "    @property\n\t    def max_redirects(self):\n\t        \"\"\"Max Redirects.\n\t        The max for redirect times.\n\t        >>> 5\n\t        :return:\n\t        \"\"\"\n\t        return self._max_redirects\n\t    @max_redirects.setter\n\t    def max_redirects(self, attr):\n", "        \"\"\"\n\t        Set Max Redirects\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._max_redirects = attr\n\t    @property\n\t    def allow_redirect(self):\n\t        \"\"\"Allow Redirect.\n\t        Whether allow redirect.\n", "        >>> True or False.\n\t        :return:\n\t        \"\"\"\n\t        return self._allow_redirect\n\t    @allow_redirect.setter\n\t    def allow_redirect(self, attr):\n\t        \"\"\"\n\t        Set Allow Redirect\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._allow_redirect = attr\n\t    @property\n\t    def ja3_text(self):\n\t        \"\"\"Ja3 Text.\n\t        The TLS fingerprint ja3 text.\n\t        >>> \"771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,17513-27-0-13-35-43-65281-23-51-5-45-11-16-10-18-21,29-23-24,0\"\n\t        :return:\n\t        \"\"\"\n\t        return self._ja3_text\n", "    @ja3_text.setter\n\t    def ja3_text(self, attr):\n\t        \"\"\"\n\t        Set Ja3 Text\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._ja3_text = attr\n\t    @property\n\t    def h2_settings(self):\n", "        \"\"\"H2 Settings.\n\t        The htp2 fingerprint SETTINGS.\n\t        >>> {\"1\": \"65535\", \"2\": \"0\", \"3\": \"1000\", \"4\": \"6291456\", \"6\": \"262144\"}\n\t        :return:\n\t        \"\"\"\n\t        return self._h2_settings\n\t    @h2_settings.setter\n\t    def h2_settings(self, attr):\n\t        \"\"\"\n\t        Set H2 Settings\n", "        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._h2_settings = attr\n\t    @property\n\t    def h2_window_update(self):\n\t        \"\"\"H2 Window Update.\n\t        The http2 fingerprint WINDOW_UPDATE.\n\t        >>> \"15663105\"\n\t        :return:\n", "        \"\"\"\n\t        return self._h2_window_update\n\t    @h2_window_update.setter\n\t    def h2_window_update(self, attr):\n\t        \"\"\"\n\t        Set Window Update\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._h2_window_update = attr\n", "    @property\n\t    def h2_headers(self):\n\t        \"\"\"H2 Headers.\n\t        The http2 fingerprint HEADERS.\n\t        :method\n\t        :authority\n\t        :scheme\n\t        :path\n\t        >>> \"m,a,s,p\"\n\t        :return:\n", "        \"\"\"\n\t        return self._h2_headers\n\t    @h2_headers.setter\n\t    def h2_headers(self, attr):\n\t        \"\"\"\n\t        Set H2 Headers\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._h2_headers = attr\n", "    def __enter__(self):\n\t        return self\n\t    def __exit__(self, *args, **kwargs):\n\t        self.close(*args, **kwargs)\n\t    def close(self, *args, **kwargs):\n\t        \"\"\"\n\t        Close session.\n\t        :param args:\n\t        :param kwargs:\n\t        :return:\n", "        \"\"\"\n\t    def request(self, *args, **kwargs):\n\t        \"\"\"\n\t        Request\n\t        :return:\n\t        \"\"\"\n\t    def get(self, *args, **kwargs):\n\t        \"\"\"\n\t        GET Method.\n\t        :return:\n", "        \"\"\"\n\t    def options(self, *args, **kwargs):\n\t        \"\"\"\n\t        OPTIONS Method.\n\t        :return:\n\t        \"\"\"\n\t    def head(self, *args, **kwargs):\n\t        \"\"\"\n\t        HEAD Method.\n\t        :return:\n", "        \"\"\"\n\t    def post(self, *args, **kwargs):\n\t        \"\"\"\n\t        POST Method.\n\t        :return:\n\t        \"\"\"\n\t    def put(self, *args, **kwargs):\n\t        \"\"\"\n\t        PUT Method.\n\t        :return:\n", "        \"\"\"\n\t    def patch(self, *args, **kwargs):\n\t        \"\"\"\n\t        PATCH Method.\n\t        :return:\n\t        \"\"\"\n\t    def delete(self, *args, **kwargs):\n\t        \"\"\"\n\t        DELETE Method.\n\t        :return:\n", "        \"\"\"\n\t    def send(self, *args, **kwargs):\n\t        \"\"\"\n\t        Send\n\t        :return:\n\t        \"\"\"\n"]}
{"filename": "ja3requests/base/_context.py", "chunked_list": ["\"\"\"\"\n\tja3Requests.base._context\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tBasic Context\n\t\"\"\"\n\tclass BaseContext:\n\t    \"\"\"\n\t    Basic connection context.\n\t    \"\"\"\n\t    def __init__(self):\n", "        self._protocol = None\n\t        self._version = None\n\t        self._start_line = None\n\t        self._method = None\n\t        self._headers = None\n\t        self._body = None\n\t        self._message = None\n\t    @property\n\t    def protocol(self):\n\t        \"\"\"\n", "        Protocol\n\t        :return:\n\t        \"\"\"\n\t        return self._protocol\n\t    @protocol.setter\n\t    def protocol(self, attr):\n\t        \"\"\"\n\t        Set protocol\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._protocol = attr\n\t    @property\n\t    def version(self):\n\t        \"\"\"\n\t        Version\n\t        :return:\n\t        \"\"\"\n\t        return self._version\n\t    @version.setter\n", "    def version(self, attr):\n\t        \"\"\"\n\t        Set version\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._version = attr\n\t    @property\n\t    def start_line(self):\n\t        \"\"\"\n", "        Start line\n\t        :return:\n\t        \"\"\"\n\t        return self._start_line\n\t    @start_line.setter\n\t    def start_line(self, attr):\n\t        \"\"\"\n\t        Set start line\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._start_line = attr\n\t    @property\n\t    def method(self):\n\t        \"\"\"\n\t        Method\n\t        :return:\n\t        \"\"\"\n\t        return self._method\n\t    @method.setter\n", "    def method(self, attr):\n\t        \"\"\"\n\t        Set method\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._method = attr\n\t    @property\n\t    def headers(self):\n\t        \"\"\"\n", "        Headers\n\t        :return:\n\t        \"\"\"\n\t        return self._headers\n\t    @headers.setter\n\t    def headers(self, attr):\n\t        \"\"\"\n\t        Set headers\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._headers = attr\n\t    @property\n\t    def body(self):\n\t        \"\"\"\n\t        Body\n\t        :return:\n\t        \"\"\"\n\t        return self._body\n\t    @body.setter\n", "    def body(self, attr):\n\t        \"\"\"\n\t        Set body\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._body = attr\n\t    @property\n\t    def message(self):\n\t        \"\"\"\n", "        Message\n\t        :return:\n\t        \"\"\"\n\t        return self._message\n\t    @message.setter\n\t    def message(self, attr):\n\t        \"\"\"\n\t        Set message\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._message = attr\n"]}
{"filename": "ja3requests/base/_request.py", "chunked_list": ["\"\"\"\n\tja3Requests.base._request\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tBasic Request\n\t\"\"\"\n\tclass BaseRequest:\n\t    \"\"\"\n\t    The basic request.\n\t    \"\"\"\n\t    def __init__(self):\n", "        self._method = None\n\t        self._source = None\n\t        self._url = None\n\t        self._scheme = None\n\t        self._port = None\n\t        self._headers = None\n\t        self._params = None\n\t        self._data = None\n\t        self._cookies = None\n\t        self._files = None\n", "        self._auth = None\n\t        self._json = None\n\t        self._timeout = None\n\t        self._proxies = None\n\t    @property\n\t    def method(self):\n\t        \"\"\"\n\t        Request method\n\t        >>> \"GET\"\n\t        :return:\n", "        \"\"\"\n\t        return self._method\n\t    @method.setter\n\t    def method(self, attr):\n\t        \"\"\"\n\t        Set request method.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._method = attr\n", "    @property\n\t    def source(self):\n\t        \"\"\"\n\t        Source Address.\n\t        :return:\n\t        \"\"\"\n\t        return self._source\n\t    @source.setter\n\t    def source(self, attr):\n\t        \"\"\"\n", "        Set source address.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._source = attr\n\t    @property\n\t    def url(self):\n\t        \"\"\"\n\t        Request url.\n\t        :return:\n", "        \"\"\"\n\t        return self._url\n\t    @url.setter\n\t    def url(self, attr):\n\t        \"\"\"\n\t        Set request url.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._url = attr\n", "    @property\n\t    def scheme(self):\n\t        \"\"\"\n\t        Request Scheme. eg. HTTP, HTTPS\n\t        :return:\n\t        \"\"\"\n\t        return self._scheme\n\t    @scheme.setter\n\t    def scheme(self, attr):\n\t        \"\"\"\n", "        Set scheme.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._scheme = attr\n\t    @property\n\t    def port(self):\n\t        \"\"\"\n\t        Remote address port.\n\t        :return:\n", "        \"\"\"\n\t        return self._port\n\t    @port.setter\n\t    def port(self, attr):\n\t        \"\"\"\n\t        Set port.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._port = attr\n", "    @property\n\t    def headers(self):\n\t        \"\"\"Headers\n\t        Request headers.\n\t        >>> {\"Host\": \"www.example.com\", \"Accept\": \"*/*\"}\n\t        :return:\n\t        \"\"\"\n\t        return self._headers\n\t    @headers.setter\n\t    def headers(self, attr):\n", "        \"\"\"\n\t        Set request headers.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._headers = attr\n\t    @property\n\t    def params(self):\n\t        \"\"\"\n\t        Request params. eg. ?page=1&page_size=10&desc=1\n", "        >>> [(\"page\", 1), (\"page_size\", 10),]\n\t        :return:\n\t        \"\"\"\n\t        return self._params\n\t    @params.setter\n\t    def params(self, attr):\n\t        \"\"\"\n\t        Set params.\n\t        :param attr:\n\t        :return:\n", "        \"\"\"\n\t        self._params = attr\n\t    @property\n\t    def data(self):\n\t        \"\"\"\n\t        Post request data.\n\t        >>> {\"username\": \"admin\", \"password\": \"admin\"}\n\t        :return:\n\t        \"\"\"\n\t        return self._data\n", "    @data.setter\n\t    def data(self, attr):\n\t        \"\"\"\n\t        Set post request data.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._data = attr\n\t    @property\n\t    def cookies(self):\n", "        \"\"\"\n\t        Request cookies.\n\t        >>> {\"UUID\": \"xxxxxxx\"}\n\t        :return:\n\t        \"\"\"\n\t        return self._cookies\n\t    @cookies.setter\n\t    def cookies(self, attr):\n\t        \"\"\"\n\t        Set request cookies.\n", "        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._cookies = attr\n\t    @property\n\t    def files(self):\n\t        \"\"\"\n\t        Request files.\n\t        :return:\n\t        \"\"\"\n", "        return self._files\n\t    @files.setter\n\t    def files(self, attr):\n\t        \"\"\"\n\t        Set files.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._files = attr\n\t    @property\n", "    def auth(self):\n\t        \"\"\"\n\t        Request Authorization.\n\t        >>> {\"username\": \"admin\", \"password\": \"admin\"}\n\t        :return:\n\t        \"\"\"\n\t        return self._auth\n\t    @auth.setter\n\t    def auth(self, attr):\n\t        \"\"\"\n", "        Set authorization.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._auth = attr\n\t    @property\n\t    def json(self):\n\t        \"\"\"\n\t        Post json.\n\t        :return:\n", "        \"\"\"\n\t        return self._json\n\t    @json.setter\n\t    def json(self, attr):\n\t        \"\"\"\n\t        Set json for post request.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._json = attr\n", "    @property\n\t    def timeout(self):\n\t        \"\"\"\n\t        Request timeout.\n\t        :return:\n\t        \"\"\"\n\t        return self._timeout\n\t    @timeout.setter\n\t    def timeout(self, attr):\n\t        \"\"\"\n", "        Set request timeout.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n\t        self._timeout = attr\n\t    @property\n\t    def proxies(self):\n\t        \"\"\"\n\t        Request proxies.\n\t        >>> {\"http\": \"username:password@host:port\", \"https\": \"username:password@host:port\"}\n", "        :return:\n\t        \"\"\"\n\t        return self._proxies\n\t    @proxies.setter\n\t    def proxies(self, attr):\n\t        \"\"\"\n\t        Set proxies.\n\t        :param attr:\n\t        :return:\n\t        \"\"\"\n", "        self._proxies = attr\n\t    def is_http(self):\n\t        \"\"\"\n\t        Is http request.\n\t        :return:\n\t        \"\"\"\n\t        return self._scheme == \"http\"\n\t    def is_https(self):\n\t        \"\"\"\n\t        Is https request.\n", "        :return:\n\t        \"\"\"\n\t        return self._scheme == \"https\"\n"]}
