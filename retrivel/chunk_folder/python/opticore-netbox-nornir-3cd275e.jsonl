{"filename": "tasks.py", "chunked_list": ["\"\"\"Invoke tasks.\"\"\"\n\timport os\n\tfrom distutils.util import strtobool\n\tfrom invoke import Collection, task as invoke_task\n\tNETBOX_VERSION = \"v3.4.4\"\n\tnamespace = Collection(\"netbox\")\n\tnamespace.configure(\n\t    {\n\t        \"netbox\": {\n\t            \"project_name\": \"netbox-nornir\",\n", "            \"python_ver\": \"3.9\",\n\t            \"local\": bool(strtobool(os.environ.get(\"INVOKE_NETBOX_LOCAL\", \"false\"))),\n\t            \"compose_dir\": os.path.join(os.path.dirname(__file__), \"docker/\"),\n\t            \"local_compose_files\": [\n\t                \"docker-compose.local.yml\",\n\t            ],\n\t            \"dev_compose_files\": [\n\t                \"docker-compose.yml\",\n\t                \"docker-compose.dev.yml\",\n\t            ],\n", "            \"prod_compose_files\": [\n\t                \"docker-compose.yml\",\n\t                \"docker-compose.prod.yml\",\n\t            ],\n\t        }\n\t    }\n\t)\n\tdef is_truthy(arg):\n\t    \"\"\"Convert \"truthy\" strings into Booleans.\n\t    Examples:\n", "        >>> is_truthy('yes')\n\t        True\n\t    Args:\n\t        arg (str): Truthy string (True values are y, yes, t, true, on and 1; false values are n, no,\n\t        f, false, off and 0. Raises ValueError if val is anything else.\n\t    \"\"\"\n\t    if isinstance(arg, bool):\n\t        return arg\n\t    return bool(strtobool(arg))\n\tdef task(function=None, *args, **kwargs):\n", "    \"\"\"Task decorator to override the default Invoke task decorator.\"\"\"\n\t    def task_wrapper(function=None):\n\t        \"\"\"Wrapper around invoke.task to add the task to the namespace as well.\"\"\"\n\t        if args or kwargs:\n\t            task_func = invoke_task(*args, **kwargs)(function)\n\t        else:\n\t            task_func = invoke_task(function)\n\t        namespace.add_task(task_func)\n\t        return task_func\n\t    if function:\n", "        # The decorator was called with no arguments\n\t        return task_wrapper(function)\n\t    # The decorator was called with arguments\n\t    return task_wrapper\n\tdef docker_compose(context, command, target=\"dev\", **kwargs):\n\t    \"\"\"Helper function for running a specific docker compose command with all appropriate parameters and environment.\n\t    Args:\n\t        context (obj): Used to run specific commands\n\t        command (str): Command string to append to the \"docker compose ...\" command, such as \"build\", \"up\", etc.\n\t        **kwargs: Passed through to the context.run() call.\n", "    \"\"\"\n\t    compose_command = f'docker compose --project-name {context.netbox.project_name} --project-directory \"{context.netbox.compose_dir}\"'\n\t    for compose_file in getattr(context.netbox, f\"{target}_compose_files\"):\n\t        compose_file_path = os.path.join(context.netbox.compose_dir, compose_file)\n\t        compose_command += f' -f \"{compose_file_path}\"'\n\t    compose_command += f\" {command}\"\n\t    # If `service` was passed as a kwarg, add it to the end.\n\t    service = kwargs.pop(\"service\", None)\n\t    if service is not None:\n\t        compose_command += f\" {service}\"\n", "    print(f'Running docker compose command \"{command}\"')\n\t    return context.run(\n\t        compose_command,\n\t        env={\"PYTHON_VER\": context.netbox.python_ver},\n\t        **kwargs,\n\t    )\n\tdef run_cmd(context, command, **kwargs):\n\t    \"\"\"Run a command locally or inside container.\"\"\"\n\t    if is_truthy(context.netbox.local):\n\t        context.run(command, pty=True, **kwargs)\n", "    else:\n\t        # Check if netbox is running; no need to start another netbox container to run a command\n\t        docker_compose_status = \"ps --services --filter status=running\"\n\t        results = docker_compose(context, docker_compose_status, hide=\"out\")\n\t        if \"netbox\" in results.stdout:\n\t            compose_command = f\"exec netbox {command}\"\n\t        else:\n\t            compose_command = f\"run --entrypoint '{command}' netbox\"\n\t        docker_compose(context, compose_command, pty=True)\n\t@task(help={\"container\": \"Name of the container to shell into\"})\n", "def cli(context, container=\"netbox\"):\n\t    \"\"\"Launch a bash shell inside the running netbox container.\"\"\"\n\t    docker_compose(context, f\"exec {container} bash\", pty=True)\n\t@task(\n\t    help={\n\t        \"user\": \"Name of the superuser to create. (Default: admin)\",\n\t    }\n\t)\n\tdef createsuperuser(context, user=\"admin\"):\n\t    \"\"\"Create a new netbox superuser account (default: \"admin\"), will prompt for password.\"\"\"\n", "    command = \"python manage.py createsuperuser --username admin\"\n\t    run_cmd(context, command)\n\t@task(\n\t    help={\n\t        \"force_rm\": \"Always remove intermediate containers.\",\n\t        \"cache\": \"Whether to use Docker's cache when building the image. (Default: enabled)\",\n\t    }\n\t)\n\tdef build(\n\t    context,\n", "    force_rm=False,\n\t    cache=True,\n\t    target=\"dev\",\n\t    image_name=\"netbox\",\n\t    tag=\"latest\",\n\t):\n\t    \"\"\"Build netbox docker image.\"\"\"\n\t    command = f\"build --build-arg PYTHON_VER={context.netbox.python_ver}\"\n\t    if not cache:\n\t        command += \" --no-cache\"\n", "    if force_rm:\n\t        command += \" --force-rm\"\n\t    print(f\"Building netbox with Python {context.netbox.python_ver}...\")\n\t    docker_compose(context, command, target=target)\n\t@task(\n\t    help={\n\t        \"cache\": \"Whether to use Docker's cache when building the image. (Default: enabled)\",\n\t        \"cache_dir\": \"Directory to use for caching buildx output. (Default: /home/travis/.cache/docker)\",\n\t        \"platforms\": \"Comma-separated list of strings for which to build. (Default: linux/amd64)\",\n\t        \"target\": \"Build target from the Dockerfile. (Default: dev)\",\n", "    }\n\t)\n\tdef buildx(\n\t    context,\n\t    cache=False,\n\t    cache_dir=\"\",\n\t    platforms=\"linux/amd64\",\n\t    target=\"dev\",\n\t    image_name=\"netbox\",\n\t):\n", "    \"\"\"Build netbox docker image using the experimental buildx docker functionality (multi-arch capablility).\"\"\"\n\t    print(f\"Building netbox with Python {context.netbox.python_ver} for {platforms}...\")\n\t    command = f\"docker buildx build --tag {image_name} --platform {platforms} --load -f ./docker/Dockerfile --build-arg PYTHON_VER={context.netbox.python_ver} .\"\n\t    if not cache:\n\t        command += \" --no-cache\"\n\t    else:\n\t        command += f\" --cache-to type=local,dest={cache_dir}/{context.netbox.python_ver} --cache-from type=local,src={cache_dir}/{context.netbox.python_ver}\"\n\t    context.run(command, env={\"PYTHON_VER\": context.netbox.python_ver})\n\t@task(\n\t    help={\n", "        \"cache\": \"Whether to use Docker's cache when building the image. (Default: enabled)\",\n\t        \"cache_dir\": \"Directory to use for caching buildx output. (Default: /home/travis/.cache/docker)\",\n\t        \"platforms\": \"Comma-separated list of strings for which to build. (Default: linux/amd64)\",\n\t        \"target\": \"Build target from the Dockerfile. (Default: dev)\",\n\t    }\n\t)\n\tdef docker_build(\n\t    context,\n\t    cache=False,\n\t    cache_dir=\"\",\n", "    platforms=\"linux/amd64\",\n\t    target=\"dev\",\n\t    image_name=\"netbox\",\n\t):\n\t    \"\"\"Build netbox docker image using the experimental buildx docker functionality (multi-arch capablility).\"\"\"\n\t    print(f\"Building netbox with Python {context.netbox.python_ver} for {platforms}...\")\n\t    command = f\"docker build --tag {image_name} --platform {platforms} --target {target} -f ./docker/Dockerfile --build-arg PYTHON_VER={context.netbox.python_ver} .\"\n\t    if not cache:\n\t        command += \" --no-cache\"\n\t    else:\n", "        command += f\" --cache-to type=local,dest={cache_dir}/{context.netbox.python_ver} --cache-from type=local,src={cache_dir}/{context.netbox.python_ver}\"\n\t    context.run(command, env={\"PYTHON_VER\": context.netbox.python_ver})\n\t@task(help={\"service\": \"If specified, only affect this service.\"})\n\tdef debug(context, service=None, target=\"dev\"):\n\t    \"\"\"Start netbox and its dependencies in debug mode.\"\"\"\n\t    print(\"Starting netbox in debug mode...\")\n\t    docker_compose(context, \"up\", service=service, target=target)\n\t@task(help={\"service\": \"If specified, only affect this service.\"})\n\tdef start(context, service=None, target=\"dev\"):\n\t    \"\"\"Start netbox and its dependencies in detached mode.\"\"\"\n", "    print(\"Starting netbox in detached mode...\")\n\t    docker_compose(context, \"up --detach\", service=service, target=target)\n\t@task(help={\"service\": \"If specified, only affect this service.\"})\n\tdef restart(context, service=None, target=\"dev\"):\n\t    \"\"\"Gracefully restart containers.\"\"\"\n\t    print(\"Restarting netbox...\")\n\t    docker_compose(context, \"restart\", service=service, target=target)\n\t@task(help={\"service\": \"If specified, only affect this service.\"})\n\tdef stop(context, service=None, target=\"dev\"):\n\t    \"\"\"Stop netbox and its dependencies.\"\"\"\n", "    print(\"Stopping netbox...\")\n\t    if not service:\n\t        docker_compose(context, \"down\", target=target)\n\t    else:\n\t        docker_compose(context, \"stop\", service=service, target=target)\n\t@task\n\tdef destroy(context, target=\"dev\"):\n\t    \"\"\"Destroy all containers and volumes.\"\"\"\n\t    print(\"Destroying netbox...\")\n\t    docker_compose(context, \"down --volumes\", target=target)\n", "@task\n\tdef build_local_env(context):\n\t    \"\"\"Build local environment for development.\"\"\"\n\t    print(\"Building local environment...\")\n\t    context.run(\"rm -rf netbox\")\n\t    context.run(\"mkdir netbox\")\n\t    context.run(\n\t        f\"curl -L https://codeload.github.com/netbox-community/netbox/tar.gz/refs/tags/{NETBOX_VERSION} | tar -xz --strip=1 -C ./netbox\"\n\t    )\n\t    context.run(\"pip install -r ./netbox/requirements.txt\")\n", "    context.run(\"poetry install\")\n\t    if not os.path.isfile(\"./docker/configuration/configuration.py\"):\n\t        context.run(\n\t            \"cp $(pwd)/docker/configuration/configuration.example.py $(pwd)/docker/configuration/configuration.py\"\n\t        )\n\t    if not os.path.islink(\"./netbox/netbox/netbox/configuration.py\"):\n\t        context.run(\"rm -f $(pwd)/netbox/netbox/netbox/configuration.py\")\n\t        context.run(\"ln -s $(pwd)/docker/configuration/configuration.py $(pwd)/netbox/netbox/netbox/\")\n\t    print(\"To run with containerized db use `invoke debug --target=local` before starting Django process.\")\n\t@task\n", "def manage(context, command, target=\"dev\"):\n\t    \"\"\"Run a Django management command.\"\"\"\n\t    print(f\"Running Django management command: {command}\")\n\t    docker_compose(context, f\"run --rm netbox python3 ./manage.py {command}\", target=target)\n\t@task(help={\"name\": \"Use this name for migration file(s). If unspecified, a name will be generated.\"})\n\tdef makemigrations(context, name=\"\"):\n\t    \"\"\"Perform makemigrations operation in Django.\"\"\"\n\t    command = \"python manage.py makemigrations\"\n\t    if name:\n\t        command += f\" --name {name}\"\n", "    run_cmd(context, command)\n\t@task\n\tdef migrate(context):\n\t    \"\"\"Perform migrate operation in Django.\"\"\"\n\t    command = \"python manage.py migrate\"\n\t    run_cmd(context, command)\n\t@task()\n\tdef pytest(context):\n\t    \"\"\"Launch pytest for the specified name and Python version.\n\t    Args:\n", "        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    # Install python module\n\t    exec_cmd = \"pytest -vv\"\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef black(context):\n\t    \"\"\"Launch black to check that Python files adherence to black standards.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    exec_cmd = \"black --exclude ./workspace --check --diff .\"\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef blacken(context):\n\t    \"\"\"Launch black to apply black standards to the code.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    exec_cmd = \"black .\"\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef flake8(context):\n\t    \"\"\"Launch flake8 for the specified name and Python version.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    exec_cmd = \"flake8 --exclude=./workspace,./netbox .\"\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef pylint(context):\n\t    \"\"\"Launch pylint for the specified name and Python version.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    exec_cmd = 'find . -type f -name \"*.py\" | xargs pylint'\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef yamllint(context):\n\t    \"\"\"Launch yamllint to validate formatting.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    exec_cmd = 'yamllint -d \"{ignore: ./workspace}\" .'\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef pydocstyle(context):\n\t    \"\"\"Launch pydocstyle to validate docstring.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    exec_cmd = \"pydocstyle .\"\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef bandit(context):\n\t    \"\"\"Launch bandit to validate basic static code security analysis.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    # pty is set to true to properly run the docker commands due to the invocation process of docker\n\t    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n\t    exec_cmd = \"bandit --recursive ./\"\n\t    run_cmd(context, exec_cmd)\n\t@task()\n\tdef tests(context):\n\t    \"\"\"Launch all tests for the specified name and Python version.\n", "    Args:\n\t        context (obj): Used to run specific commands\n\t    \"\"\"\n\t    print(\"Running black...\")\n\t    black(context)\n\t    print(\"Running flake8...\")\n\t    flake8(context)\n\t    # print(\"Running pylint...\")\n\t    # pylint(context)\n\t    print(\"Running yamllint...\")\n", "    yamllint(context)\n\t    # print(\"Running pydocstyle...\")\n\t    # pydocstyle(context)\n\t    # print(\"Running bandit...\")\n\t    # bandit(context)\n\t    # print(\"Running pytest...\")\n\t    # pytest(context)\n\t    print(\"All tests have passed!\")\n"]}
{"filename": "netbox_nornir/__init__.py", "chunked_list": ["\"\"\"Base NetBox plugin for interactions with AWX or Ansible Tower.\"\"\"\n\tfrom extras.plugins import PluginConfig\n\t__version__ = \"0.1.0\"\n\tclass NetboxNornirConfig(PluginConfig):\n\t    \"\"\"Plugin configuration for netbox_nornir.\"\"\"\n\t    name = \"netbox_nornir\"\n\t    verbose_name = \"Netbox Nornir\"\n\t    version = __version__\n\t    author = \"OpticoreIT\"\n\t    author_email = \"info@opticoreit.com\"\n", "    description = \"\"\n\t    base_url = \"nornir\"\n\tconfig = NetboxNornirConfig  # pylint: disable=invalid-name\n"]}
{"filename": "netbox_nornir/utils.py", "chunked_list": ["\"\"\"Utilities for plugin.\"\"\"\n\timport logging\n\tfrom typing import Any\n\tfrom netbox_nornir.plugins.tasks.dispatcher import _DEFAULT_DRIVERS_MAPPING\n\tfrom netbox_nornir.constraints import PLUGIN_CFG\n\tdef get_dispatcher():\n\t    \"\"\"Helper method to load the dispatcher from netbox nornir or config if defined.\"\"\"\n\t    if PLUGIN_CFG.get(\"dispatcher_mapping\"):\n\t        return {**_DEFAULT_DRIVERS_MAPPING, **PLUGIN_CFG[\"dispatcher_mapping\"]}\n\t    return _DEFAULT_DRIVERS_MAPPING\n", "class NornirLogger:\n\t    \"\"\"Similar to a mixin, to utilize Python logging and Jobs Result obj.\"\"\"\n\t    def __init__(self, name: str, netbox_job=None, debug: bool = False):\n\t        \"\"\"Initialize the object.\"\"\"\n\t        self.logger = logging.getLogger(name)\n\t        self.debug = debug\n\t        self.netbox_job = netbox_job\n\t    def log_debug(self, message: str, grouping: str = \"main\"):\n\t        \"\"\"Debug, does not take obj, and only logs to jobs result when in global debug mode.\"\"\"\n\t        if self.netbox_job and self.debug:\n", "            self.netbox_job.log_debug(message, grouping=grouping)\n\t        self.logger.debug(message)\n\t    def log_info(self, obj: Any, message: str, grouping: str = \"main\"):\n\t        \"\"\"Log to Python logger and jogs results for info messages.\"\"\"\n\t        if self.netbox_job:\n\t            self.netbox_job.log_info(message, grouping=grouping)\n\t        self.logger.info(\"%s | %s\", str(obj), message)\n\t    def log_success(self, obj: Any, message: str, grouping: str = \"main\"):\n\t        \"\"\"Log to Python logger and jogs results for success messages.\"\"\"\n\t        if self.netbox_job:\n", "            self.netbox_job.log_success(message, grouping=grouping)\n\t        self.logger.info(\"%s | %s\", str(obj), message)\n\t    def log_warning(self, obj: Any, message: str, grouping: str = \"main\"):\n\t        \"\"\"Log to Python logger and jogs results for warning messages.\"\"\"\n\t        if self.netbox_job:\n\t            self.netbox_job.log_warning(message, grouping=grouping)\n\t        self.logger.warning(\"%s | %s\", str(obj), message)\n\t    def log_failure(self, obj: Any, message: str, grouping: str = \"main\"):\n\t        \"\"\"Log to Python logger and jogs results for failure messages.\"\"\"\n\t        if self.netbox_job:\n", "            self.netbox_job.log_failure(message, grouping=grouping)\n\t        self.logger.error(\"%s | %s\", str(obj), message)\n"]}
{"filename": "netbox_nornir/constraints.py", "chunked_list": ["\"\"\"Constants for plugin.\"\"\"\n\tfrom django.conf import settings\n\t_NORNIR_SETTINGS = {\n\t    \"inventory\": \"netbox_nornir.plugins.inventory.netbox_orm.NetboxORMInventory\",\n\t    \"credentials\": \"netbox_nornir.plugins.credentials.env_vars.CredentialsEnvVars\",\n\t    \"runner\": {\"options\": {\"num_workers\": 20}},\n\t}\n\tPLUGIN_CFG = settings.PLUGINS_CONFIG.get(\"netbox_nornir\", {})\n\tNORNIR_SETTINGS = PLUGIN_CFG.get(\"nornir_settings\", _NORNIR_SETTINGS)\n\tCONNECTION_SECRETS_PATHS = {\n", "    \"netmiko\": \"netmiko.extras.secret\",\n\t    \"napalm\": \"napalm.extras.optional_args.secret\",\n\t    \"scrapli\": \"scrapli.extras.auth_secondary\",\n\t}\n\tCONNECTION_ENABLE_PASSWORD_PATHS = {\n\t    \"netmiko\": \"netmiko.extras.enable_password\",\n\t    \"napalm\": \"napalm.extras.optional_args.enable_password\",\n\t    \"scrapli\": \"scrapli.extras.enable_password\",\n\t}\n"]}
{"filename": "netbox_nornir/exceptions.py", "chunked_list": ["\"\"\"Exceptions for NetBox Nornir plugin.\"\"\"\n\tclass NornirNetboxException(Exception):\n\t    \"\"\"Base exception for NetBox Nornir plugin.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/inventory/netbox_orm.py", "chunked_list": ["\"\"\"NetBox ORM inventory plugin.\"\"\"\n\tfrom typing import Any, Dict\n\tfrom django.db.models import QuerySet\n\tfrom django.utils.module_loading import import_string\n\tfrom nornir.core.inventory import (\n\t    ConnectionOptions,\n\t    Defaults,\n\t    Group,\n\t    Groups,\n\t    Host,\n", "    Hosts,\n\t    Inventory,\n\t    ParentGroups,\n\t)\n\tfrom dcim.models import Device\n\tfrom netbox_nornir.constraints import CONNECTION_ENABLE_PASSWORD_PATHS, CONNECTION_SECRETS_PATHS, PLUGIN_CFG\n\tfrom netbox_nornir.exceptions import NornirNetboxException\n\tdef _set_dict_key_path(dictionary, key_path, value):\n\t    \"\"\"Set a value in a nested dictionary using a key path.\n\t    Args:\n", "        dictionary (dict): The dictionary to set the value in.\n\t        key_path (str): The key path to set the value in.\n\t    \"\"\"\n\t    *keys, last_key = key_path.split(\".\")\n\t    pointer = dictionary\n\t    for key in keys:\n\t        pointer = pointer.setdefault(key, {})\n\t    pointer[last_key] = value\n\tdef build_out_secret_paths(connection_options, device_secret):\n\t    \"\"\"Build out secret paths.\n", "    Args:\n\t        connection_options (dict): Connection options\n\t        device_secret (str): Device secret\n\t    \"\"\"\n\t    for nornir_provider, nornir_options in connection_options.items():\n\t        # Offers extensibility to nornir plugins not listed in constants.py under CONNECTION_SECRETS_PATHS.\n\t        if nornir_options.get(\"connection_secret_path\"):\n\t            secret_path = nornir_options.pop(\"connection_secret_path\")\n\t        elif CONNECTION_SECRETS_PATHS.get(nornir_provider):\n\t            secret_path = CONNECTION_SECRETS_PATHS[nornir_provider]\n", "        else:\n\t            continue\n\t        _set_dict_key_path(connection_options, secret_path, device_secret)\n\tdef build_out_enable_password_paths(connection_options, device_secret):\n\t    \"\"\"Build out enable password paths.\n\t    Args:\n\t        connection_options (dict): Connection options\n\t        device_secret (str): Device secret\n\t    \"\"\"\n\t    for nornir_provider, nornir_options in connection_options.items():\n", "        # Offers extensibility to nornir plugins not listed in constants.py under CONNECTION_SECRETS_PATHS.\n\t        if nornir_options.get(\"connection_enable_password_path\"):\n\t            secret_path = nornir_options.pop(\"connection_enable_password_path\")\n\t        elif CONNECTION_ENABLE_PASSWORD_PATHS.get(nornir_provider):\n\t            secret_path = CONNECTION_ENABLE_PASSWORD_PATHS[nornir_provider]\n\t        else:\n\t            continue\n\t        _set_dict_key_path(connection_options, secret_path, device_secret)\n\tdef set_host(data: Dict[str, Any], name: str, groups, host, defaults) -> Host:\n\t    \"\"\"Set host.\n", "    Args:\n\t        data (dict): Data\n\t        name (str): Name\n\t        groups (dict): Groups\n\t        host (dict): Host\n\t        defaults (dict): Defaults\n\t    Returns:\n\t        Host: Host\n\t    \"\"\"\n\t    connection_option = {}\n", "    for key, value in data.get(\"connection_options\", {}).items():\n\t        connection_option[key] = ConnectionOptions(\n\t            hostname=value.get(\"hostname\"),\n\t            username=value.get(\"username\"),\n\t            password=value.get(\"password\"),\n\t            port=value.get(\"port\"),\n\t            platform=value.get(\"platform\"),\n\t            extras=value.get(\"extras\"),\n\t        )\n\t    return Host(\n", "        name=name,\n\t        hostname=host[\"hostname\"],\n\t        username=host[\"username\"],\n\t        password=host[\"password\"],\n\t        platform=host[\"platform\"],\n\t        data=data,\n\t        groups=groups,\n\t        defaults=defaults,\n\t        connection_options=connection_option,\n\t    )\n", "class NetboxORMInventory:\n\t    \"\"\"Construct nornir inventory from NetBox using ORM.\"\"\"\n\t    def __init__(\n\t        self,\n\t        queryset: QuerySet = None,\n\t        filters: Dict = None,\n\t        credentials_class: str = \"netbox_nornir.plugins.credentials.env_vars.CredentialsEnvVars\",\n\t        credentials_params: Dict = None,\n\t    ) -> None:\n\t        \"\"\"Initialize inventory.\"\"\"\n", "        self.queryset = queryset\n\t        self.filters = filters\n\t        if isinstance(credentials_class, str):\n\t            self.cred_class = import_string(credentials_class)\n\t        else:\n\t            raise NornirNetboxException(\n\t                f\"A valid credentials class path (as defined by Django's import_string function) is required, but got {credentials_class} which is not importable.\"\n\t            )\n\t        self.credentials_params = credentials_params\n\t    def load(self) -> Inventory:\n", "        \"\"\"Load inventory.\"\"\"\n\t        if isinstance(self.queryset, QuerySet) and not self.queryset:\n\t            self.queryset = Device.objects.all()\n\t        if self.filters:\n\t            self.queryset = self.queryset.filter(**self.filters)\n\t        hosts = Hosts()\n\t        groups = Groups()\n\t        defaults = Defaults()\n\t        if self.credentials_params:\n\t            cred = self.cred_class(params=self.credentials_params)\n", "        else:\n\t            cred = self.cred_class()\n\t        for device in self.queryset:\n\t            host = self.create_host(device, cred, {})\n\t            hosts[device.name] = set_host(\n\t                data=host[\"data\"],\n\t                name=host[\"name\"],\n\t                groups=host[\"groups\"],\n\t                host=host,\n\t                defaults=defaults,\n", "            )\n\t            for group in hosts[device.name].groups:\n\t                if group not in groups.keys():\n\t                    groups[group] = Group(name=group, defaults=defaults)\n\t        for _host in hosts.values():\n\t            _host.groups = ParentGroups([groups[_group] for _group in _host.groups])\n\t        for _group in groups.values():\n\t            _group.groups = ParentGroups([groups[_group] for _group in _group.groups])\n\t        return Inventory(hosts=hosts, groups=groups, defaults=defaults)\n\t    def create_host(self, device, cred, params: Dict):\n", "        \"\"\"Create host.\"\"\"\n\t        host = {\"data\": {}}\n\t        if \"use_fqdn\" in params and params.get(\"use_fqdn\"):\n\t            host[\"hostname\"] = f\"{device.name}.{params.get('fqdn')}\"\n\t        else:\n\t            if device.primary_ip:\n\t                host[\"hostname\"] = str(device.primary_ip.address.ip)\n\t            else:\n\t                host[\"hostname\"] = device.name\n\t        host[\"name\"] = device.name\n", "        if not device.platform:\n\t            raise NornirNetboxException(f\"Platform missing from device {device.name}, preemptively failed.\")\n\t        host[\"platform\"] = device.platform.napalm_driver\n\t        host[\"data\"][\"id\"] = device.id\n\t        host[\"data\"][\"type\"] = device.device_type.slug\n\t        host[\"data\"][\"site\"] = device.site.slug\n\t        host[\"data\"][\"role\"] = device.device_role.slug\n\t        host[\"data\"][\"obj\"] = device\n\t        username, password, secret, key = cred.get_device_creds(device=device)\n\t        host[\"username\"] = username\n", "        host[\"password\"] = password\n\t        host[\"data\"][\"secret\"] = secret\n\t        host[\"data\"][\"enable_password\"] = secret\n\t        host[\"data\"][\"key\"] = key\n\t        global_options = PLUGIN_CFG.get(\"connection_options\", {\"netmiko\": {}, \"napalm\": {}, \"scrapli\": {}})\n\t        conn_options = global_options\n\t        build_out_secret_paths(conn_options, secret)\n\t        build_out_enable_password_paths(conn_options, secret)\n\t        host[\"data\"][\"connection_options\"] = conn_options\n\t        host[\"groups\"] = self.get_host_groups(device=device)\n", "        if device.platform.napalm_driver:\n\t            if not host[\"data\"][\"connection_options\"].get(\"napalm\"):\n\t                host[\"data\"][\"connection_options\"][\"napalm\"] = {}\n\t            host[\"data\"][\"connection_options\"][\"napalm\"][\"platform\"] = device.platform.napalm_driver\n\t        return host\n\t    @staticmethod\n\t    def get_host_groups(device):\n\t        \"\"\"Get the names of the groups a given device should be part of.\n\t        Args:\n\t            device (dcim.models.Device): Device obj\n", "        Returns:\n\t            (list): List of group names the device should be part of\n\t        \"\"\"\n\t        groups = [\n\t            \"global\",\n\t            f\"site__{device.site.slug}\",\n\t            f\"role__{device.device_role.slug}\",\n\t            f\"type__{device.device_type.slug}\",\n\t            f\"manufacturer__{device.device_type.manufacturer.slug}\",\n\t        ]\n", "        if device.platform:\n\t            groups.append(f\"platform__{device.platform.napalm_driver}\")\n\t        if device.tenant:\n\t            groups.append(f\"tenant__{device.tenant.slug}\")\n\t        return groups\n"]}
{"filename": "netbox_nornir/plugins/credentials/base.py", "chunked_list": ["\"\"\"Base credentials plugin for Netbox Nornir.\"\"\"\n\tclass BaseCredentials:\n\t    \"\"\"Base credentials plugin for Netbox Nornir.\"\"\"\n\t    username = None\n\t    password = None\n\t    secret = None\n\t    def get_device_creds(self, device):  # pylint: disable=unused-argument\n\t        \"\"\"Return the credentials for a given device.\n\t        Args:\n\t            device (dcim.models.Device): Netbox device object\n", "        Return:\n\t            username (string):\n\t            password (string):\n\t            secret (string):\n\t        \"\"\"\n\t        return (self.username, self.password, self.secret)\n"]}
{"filename": "netbox_nornir/plugins/credentials/aws_ssm.py", "chunked_list": ["\"\"\"Nornir plugin to retrieve credentials from AWS SSM Parameter Store.\"\"\"\n\timport boto3\n\tfrom botocore.client import Config\n\tfrom dcim.models import Device\n\tfrom .base import BaseCredentials\n\tclass CredentialsAwsSsm(BaseCredentials):\n\t    \"\"\"Nornir plugin to retrieve credentials from AWS SSM Parameter Store.\"\"\"\n\t    def __init__(self, params={}):  # pylint: disable=dangerous-default-value\n\t        \"\"\"Init.\"\"\"\n\t        config = Config(connect_timeout=15, retries={\"max_attempts\": 0})\n", "        self.client = boto3.client(\"ssm\", config=config)\n\t        self.params = params\n\t        self.username = None\n\t        self.password = None\n\t        self.secret = None\n\t        self.key = None\n\t    def build_parameter_names(self, device_name, manufacturer, platform):\n\t        \"\"\"Build a list of parameter names to try.\"\"\"\n\t        prefix = \"/netbox\"\n\t        # Ordered list of parameter names to try\n", "        return [\n\t            \"/\".join([prefix, device_name, \"username\"]),\n\t            \"/\".join([prefix, device_name, \"password\"]),\n\t            \"/\".join([prefix, device_name, \"secret\"]),\n\t            \"/\".join([prefix, device_name, \"key\"]),\n\t            \"/\".join(\n\t                [\n\t                    prefix,\n\t                    f\"{manufacturer.lower()}_{platform.lower()}\",\n\t                    \"username\",\n", "                ]\n\t            ),\n\t            \"/\".join(\n\t                [\n\t                    prefix,\n\t                    f\"{manufacturer.lower()}_{platform.lower()}\",\n\t                    \"password\",\n\t                ]\n\t            ),\n\t            \"/\".join(\n", "                [\n\t                    prefix,\n\t                    f\"{manufacturer.lower()}_{platform.lower()}\",\n\t                    \"secret\",\n\t                ]\n\t            ),\n\t            \"/\".join(\n\t                [\n\t                    prefix,\n\t                    f\"{manufacturer.lower()}_{platform.lower()}\",\n", "                    \"key\",\n\t                ]\n\t            ),\n\t        ]\n\t    @staticmethod\n\t    def lookup_nested_dict(param_list, key, value):\n\t        \"\"\"Lookup a value in a list of nested dicts.\"\"\"\n\t        for param in param_list:\n\t            if value in param[key]:\n\t                return param\n", "        return {}\n\t    def get_default_creds(self):\n\t        \"\"\"Get default credentials from environment variables.\n\t        Returns:\n\t            (tuple): Tuple of username, password, secret, key\n\t        \"\"\"\n\t        prefix = \"/netbox\"\n\t        parameter_names = [\n\t            \"/\".join([prefix, \"device_default\", \"username\"]),\n\t            \"/\".join([prefix, \"device_default\", \"password\"]),\n", "            \"/\".join([prefix, \"device_default\", \"secret\"]),\n\t            \"/\".join([prefix, \"device_default\", \"key\"]),\n\t        ]\n\t        return self.client.get_parameters(Names=parameter_names, WithDecryption=True)[\"Parameters\"]\n\t    def get_device_creds(self, device, **kwargs):\n\t        \"\"\"Get device credentials.\n\t        Args:\n\t            device (Device): NetBox device\n\t            **kwargs: Additional arguments\n\t        Returns:\n", "            (tuple): Tuple of username, password, secret, key\n\t        \"\"\"\n\t        if isinstance(device, Device):\n\t            device_name = device.name\n\t            manufacturer = device.device_type.manufacturer.slug\n\t            platform = device.platform.slug\n\t        else:\n\t            device_name = device[\"name\"]\n\t            manufacturer = kwargs.get(\"manufacturer\")\n\t            platform = kwargs.get(\"platform\")\n", "        parameter_names = self.build_parameter_names(device_name, manufacturer, platform)\n\t        credentials = self.client.get_parameters(Names=parameter_names, WithDecryption=True)[\"Parameters\"]\n\t        if not credentials:\n\t            credentials = self.get_default_creds()\n\t        return (\n\t            self.lookup_nested_dict(credentials, \"Name\", \"username\").get(\"Value\"),\n\t            self.lookup_nested_dict(credentials, \"Name\", \"password\").get(\"Value\"),\n\t            self.lookup_nested_dict(credentials, \"Name\", \"secret\").get(\"Value\"),\n\t            self.lookup_nested_dict(credentials, \"Name\", \"key\").get(\"Value\"),\n\t        )\n"]}
{"filename": "netbox_nornir/plugins/credentials/__init__.py", "chunked_list": []}
{"filename": "netbox_nornir/plugins/credentials/env_vars.py", "chunked_list": ["\"\"\"Credentials Class designed to work with environment variables.\"\"\"\n\timport os\n\tfrom .base import BaseCredentials\n\tUSERNAME_ENV_VAR_NAME = \"NAPALM_USERNAME\"  # nosec\n\tPASSWORD_ENV_VAR_NAME = \"NAPALM_PASSWORD\"  # nosec\n\tSECRET_ENV_VAR_NAME = \"DEVICE_SECRET\"  # nosec\n\tclass CredentialsEnvVars(BaseCredentials):\n\t    \"\"\"Credentials Class designed to work with Netbox ORM.\n\t    This class is the default class that will return the same login and password\n\t    for all devices based on the values of the environment variables\n", "    \"\"\"\n\t    def __init__(self, params={}):  # pylint: disable=dangerous-default-value\n\t        \"\"\"Initialize Credentials Class designed to work with environment variables.\n\t        Args:\n\t            params ([dict], optional): Credentials Parameters\n\t        \"\"\"\n\t        if not isinstance(params, dict):\n\t            raise TypeError(\"params must be a dictionary\")\n\t        self.username = os.getenv(params.get(\"username\", USERNAME_ENV_VAR_NAME))\n\t        self.password = os.getenv(params.get(\"password\", PASSWORD_ENV_VAR_NAME))\n", "        self.secret = os.getenv(params.get(\"secret\", SECRET_ENV_VAR_NAME))\n\t        if not self.secret:\n\t            self.secret = self.password\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_asa.py", "chunked_list": ["\"\"\"network_importer driver for cisco_asa.\"\"\"\n\tfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Driver for Cisco ASA.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_ios_xr.py", "chunked_list": ["\"\"\"network_importer driver for cisco IOS-XR.\"\"\"\n\tfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Driver for Cisco IOS-XR.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/netscaler.py", "chunked_list": ["\"\"\"default network_importer driver for Netscaler.\"\"\"\n\tfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Collection of Nornir Tasks specific to Cisco AireOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_aireos.py", "chunked_list": ["\"\"\"default network_importer driver for Cisco AireOS.\"\"\"\n\tfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Collection of Nornir Tasks specific to Cisco AireOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_wlc.py", "chunked_list": ["\"\"\"default network_importer driver for Cisco AireOS.\"\"\"\n\tfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Collection of Nornir Tasks specific to Cisco AireOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_nxos.py", "chunked_list": ["\"\"\"network_importer driver for cisco NXOS.\"\"\"\n\tfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Driver for Cisco NXOS.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/juniper_junos.py", "chunked_list": ["\"\"\"default network_importer driver for Juniper.\"\"\"\n\tfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Collection of Nornir Tasks specific to Juniper Junos devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/__init__.py", "chunked_list": ["\"\"\"Used to intialize the dispatcher.\"\"\"\n\t# pylint: disable=raise-missing-from\n\timport importlib\n\timport logging\n\tfrom nornir.core.exceptions import NornirSubTaskError\n\tfrom nornir.core.task import Result, Task\n\tfrom netbox_nornir.exceptions import NornirNetboxException\n\tLOGGER = logging.getLogger(__name__)\n\t_DEFAULT_DRIVERS_MAPPING = {\n\t    \"default\": \"netbox_nornir.plugins.tasks.dispatcher.default.NetboxNornirDriver\",\n", "    \"default_netmiko\": \"netbox_nornir.plugins.tasks.dispatcher.default.NetmikoNetboxNornirDriver\",\n\t    \"arista_eos\": \"netbox_nornir.plugins.tasks.dispatcher.arista_eos.NetboxNornirDriver\",\n\t    \"cisco_aireos\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_aireos.NetboxNornirDriver\",\n\t    \"cisco_asa\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_asa.NetboxNornirDriver\",\n\t    \"cisco_ios\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_ios.NetboxNornirDriver\",\n\t    \"cisco_ios_restconf\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_ios_restconf.NetboxNornirDriver\",\n\t    \"cisco_nxos\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_nxos.NetboxNornirDriver\",\n\t    \"cisco_wlc\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_wlc.NetboxNornirDriver\",\n\t    \"cisco_xr\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_ios_xr.NetboxNornirDriver\",\n\t    \"fortinet_fortios\": \"netbox_nornir.plugins.tasks.dispatcher.fortinet_fortios.NetboxNornirDriver\",\n", "    \"juniper_junos\": \"netbox_nornir.plugins.tasks.dispatcher.juniper_junos.NetboxNornirDriver\",\n\t    \"netscaler\": \"netbox_nornir.plugins.tasks.dispatcher.netscaler.NetboxNornirDriver\",\n\t    \"paloalto_panos\": \"netbox_nornir.plugins.tasks.dispatcher.paloalto_panos.NetboxNornirDriver\",\n\t}\n\tdef dispatcher(task: Task, method: str, logger, obj, *args, **kwargs) -> Result:\n\t    \"\"\"Helper Task to retrieve a given Nornir task for a given platform.\n\t    Args:\n\t        task (Nornir Task):  Nornir Task object.\n\t        method (str):  The string value of the method to dynamically find.\n\t    Returns:\n", "        Result: Nornir Task result.\n\t    \"\"\"\n\t    if kwargs.get(\"default_drivers_mapping\"):\n\t        default_drivers_mapping = kwargs[\"default_drivers_mapping\"]\n\t        del kwargs[\"default_drivers_mapping\"]\n\t    else:\n\t        default_drivers_mapping = _DEFAULT_DRIVERS_MAPPING\n\t    logger.log_debug(\n\t        f\"Executing dispatcher for {task.host.name} ({task.host.platform})\",\n\t        grouping=task.host.name,\n", "    )\n\t    # Get the platform specific driver, if not available, get the default driver\n\t    driver = default_drivers_mapping.get(task.host.platform, default_drivers_mapping.get(\"default\"))\n\t    logger.log_debug(f\"Found driver {driver}\", grouping=task.host.name)\n\t    if not driver:\n\t        logger.log_failure(\n\t            obj,\n\t            f\"Unable to find the driver for {method} for platform: {task.host.platform}, preemptively failed.\",\n\t            grouping=task.host.name,\n\t        )\n", "        raise NornirNetboxException(\n\t            f\"Unable to find the driver for {method} for platform: {task.host.platform}, preemptively failed.\"\n\t        )\n\t    module_name, class_name = driver.rsplit(\".\", 1)\n\t    driver_class = getattr(importlib.import_module(module_name), class_name)\n\t    if not driver_class:\n\t        logger.log_failure(\n\t            obj,\n\t            f\"Unable to locate the class {driver}, preemptively failed.\",\n\t            grouping=task.host.name,\n", "        )\n\t        raise NornirNetboxException(f\"Unable to locate the class {driver}, preemptively failed.\")\n\t    try:\n\t        driver_task = getattr(driver_class, method)\n\t    except AttributeError:\n\t        logger.log_failure(\n\t            obj,\n\t            f\"Unable to locate the method {method} for {driver}, preemptively failed.\",\n\t            grouping=task.host.name,\n\t        )\n", "        raise NornirNetboxException(f\"Unable to locate the method {method} for {driver}, preemptively failed.\")\n\t    result = None\n\t    error = None\n\t    try:\n\t        result = task.run(task=driver_task, logger=logger, obj=obj, *args, **kwargs)\n\t    except NornirSubTaskError as exc:\n\t        traceback_lines = exc.result[0].result.splitlines()\n\t        logger.log_failure(obj, f\"Subtask failed: {traceback_lines[-1]}\", grouping=task.host.name)\n\t        error = traceback_lines[-1]\n\t        for line in traceback_lines:\n", "            logger.log_debug(line, grouping=task.host.name)\n\t        raise NornirNetboxException(f\"Subtask failed: {traceback_lines[-1]}\")\n\t    return Result(\n\t        host=task.host,\n\t        result=result,\n\t        error=error,\n\t    )\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/default.py", "chunked_list": ["\"\"\"Default collection of Nornir Tasks based on Napalm.\"\"\"\n\tfrom netmiko import NetmikoAuthenticationException, NetmikoTimeoutException\n\tfrom nornir.core.exceptions import NornirSubTaskError\n\tfrom nornir.core.task import Result, Task\n\tfrom nornir_netmiko.tasks import netmiko_send_command\n\tfrom nornir_napalm.plugins.tasks import napalm_get\n\tfrom netbox_nornir.exceptions import NornirNetboxException\n\tRUN_COMMAND_MAPPING = {\n\t    \"default\": \"show run\",\n\t    \"arista_eos\": \"show run\",\n", "    \"cisco_aireos\": \"show run-config commands\",\n\t    \"cisco_nxos\": \"show run\",\n\t    \"cisco_ios\": \"show run\",\n\t    \"cisco_wlc\": \"show running-config\",\n\t    \"cisco_xr\": \"show run\",\n\t    \"juniper_junos\": \"show configuration | display set\",\n\t    \"netscaler\": \"show run\",\n\t}\n\tclass NetboxNornirDriver:\n\t    \"\"\"Default collection of Nornir Tasks based on Napalm.\"\"\"\n", "    @staticmethod\n\t    def get_config(task: Task, logger, obj) -> Result:\n\t        \"\"\"Get the latest configuration from the device.\n\t        Args:\n\t            task (Task): Nornir Task.\n\t            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n\t            obj (Device): A Netbox Device Django ORM object instance.\n\t        Returns:\n\t            Result: Nornir Result object with a dict as a result containing the running configuration\n\t                { \"config: <running configuration> }\n", "        \"\"\"\n\t        logger.log_debug(\n\t            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n\t            grouping=task.host.name,\n\t        )\n\t        # TODO: Find standard napalm exceptions and account for them\n\t        try:\n\t            result = task.run(task=napalm_get, getters=[\"config\"], retrieve=\"running\")\n\t        except NornirSubTaskError as exc:\n\t            traceback_lines = exc.result[0].result.splitlines()\n", "            logger.log_failure(\n\t                obj,\n\t                f\"`get_config` method failed with an unexpected issue: `{traceback_lines[-1]}`\",\n\t                grouping=task.host.name,\n\t            )\n\t            for traceback_line in traceback_lines:\n\t                logger.log_debug(\n\t                    traceback_line,\n\t                    grouping=task.host.name,\n\t                )\n", "            raise NornirNetboxException(\n\t                f\"`get_config` method failed with an unexpected issue: `{traceback_lines[-1]}`\"\n\t            ) from exc\n\t        if result[0].failed:\n\t            logger.log_failure(\n\t                obj,\n\t                f\"`get_config` nornir task failed with an unexpected issue: `{str(result.exception)}`\",\n\t                grouping=task.host.name,\n\t            )\n\t            return result\n", "        running_config = result[0].result.get(\"config\", {}).get(\"running\", None)\n\t        return Result(host=task.host, result={\"config\": running_config})\n\t    @staticmethod\n\t    def get_facts(task: Task, logger, obj) -> Result:\n\t        \"\"\"Get the latest facts from the device.\n\t        Args:\n\t            task (Task): Nornir Task.\n\t            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n\t            obj (Device): A Netbox Device Django ORM object instance.\n\t        Returns:\n", "            Result: Nornir Result object with a dict as a result containing the facts\n\t                { \"facts: <facts> }\n\t        \"\"\"\n\t        logger.log_debug(\n\t            f\"Executing get_facts for {task.host.name} on {task.host.platform}\",\n\t            grouping=task.host.name,\n\t        )\n\t        try:\n\t            results = task.run(task=napalm_get, getters=[\"facts\"])\n\t        except NornirSubTaskError as exc:\n", "            traceback_lines = exc.result[0].result.splitlines()\n\t            logger.log_failure(\n\t                obj,\n\t                f\"`get_facts` method failed with an unexpected issue: `{traceback_lines[-1]}`\",\n\t                grouping=task.host.name,\n\t            )\n\t            for traceback_line in traceback_lines:\n\t                logger.log_debug(\n\t                    traceback_line,\n\t                    grouping=task.host.name,\n", "                )\n\t            raise NornirNetboxException(\n\t                f\"`get_facts` method failed with an unexpected issue: `{traceback_lines[-1]}`\"\n\t            ) from exc\n\t        facts = results[0].result.get(\"facts\", None)\n\t        return Result(host=task.host, result={\"facts\": facts})\n\t    @staticmethod\n\t    def get_interfaces(task: Task, logger, obj) -> Result:\n\t        \"\"\"Get the latest interface IP addresses from the device.\n\t        Args:\n", "            task (Task): Nornir Task.\n\t            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n\t            obj (Device): A Netbox Device Django ORM object instance.\n\t        Returns:\n\t            Result: Nornir Result object with a dict as a result containing the interface IP addresses\n\t                { \"interface_ip_addresses: <interface_ip_addresses> }\n\t        \"\"\"\n\t        logger.log_debug(\n\t            f\"Executing get_interface_ip_addresses for {task.host.name} on {task.host.platform}\",\n\t            grouping=task.host.name,\n", "        )\n\t        try:\n\t            results = task.run(task=napalm_get, getters=[\"interfaces\", \"interfaces_ip\"])\n\t        except NornirSubTaskError as exc:\n\t            traceback_lines = exc.result[0].result.splitlines()\n\t            logger.log_failure(\n\t                obj,\n\t                f\"`get_interface_ip_addresses` method failed with an unexpected issue: `{traceback_lines[-1]}`\",\n\t                grouping=task.host.name,\n\t            )\n", "            for traceback_line in traceback_lines:\n\t                logger.log_debug(\n\t                    traceback_line,\n\t                    grouping=task.host.name,\n\t                )\n\t            raise NornirNetboxException(\n\t                f\"`get_interface_ip_addresses` method failed with an unexpected issue: `{traceback_lines[-1]}`\"\n\t            ) from exc\n\t        naplam_interfaces = results[0].result\n\t        combined_interfaces = {}\n", "        for interface_name, interface_details in naplam_interfaces[\"interfaces\"].items():\n\t            combined_interfaces[interface_name] = {\n\t                **interface_details,\n\t                **naplam_interfaces[\"interfaces_ip\"].get(interface_name, {}),\n\t            }\n\t        return Result(host=task.host, result={\"interfaces\": combined_interfaces})\n\tclass NetmikoNetboxNornirDriver(NetboxNornirDriver):\n\t    \"\"\"Default collection of Nornir Tasks based on Netmiko.\"\"\"\n\t    @staticmethod\n\t    def get_config(task: Task, logger, obj) -> Result:\n", "        \"\"\"Get the latest configuration from the device using Netmiko.\n\t        Args:\n\t            task (Task): Nornir Task.\n\t            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n\t            obj (Device): A Netbox Device Django ORM object instance.\n\t            remove_lines (list): A list of regex lines to remove configurations.\n\t            substitute_lines (list): A list of dictionaries with to remove and replace lines.\n\t        Returns:\n\t            Result: Nornir Result object with a dict as a result containing the running configuration\n\t                { \"config: <running configuration> }\n", "        \"\"\"\n\t        logger.log_debug(\n\t            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n\t            grouping=task.host.name,\n\t        )\n\t        command = RUN_COMMAND_MAPPING.get(task.host.platform, RUN_COMMAND_MAPPING[\"default\"])\n\t        try:\n\t            result = task.run(task=netmiko_send_command, command_string=command)\n\t        except NornirSubTaskError as exc:\n\t            if isinstance(exc.result.exception, NetmikoAuthenticationException):\n", "                logger.log_failure(\n\t                    obj,\n\t                    f\"Failed with an authentication issue: `{exc.result.exception}`\",\n\t                    grouping=task.host.name,\n\t                )\n\t                raise NornirNetboxException(f\"Failed with an authentication issue: `{exc.result.exception}`\") from exc\n\t            if isinstance(exc.result.exception, NetmikoTimeoutException):\n\t                logger.log_failure(\n\t                    obj,\n\t                    f\"Failed with a timeout issue. `{exc.result.exception}`\",\n", "                    grouping=task.host.name,\n\t                )\n\t                raise NornirNetboxException(f\"Failed with a timeout issue. `{exc.result.exception}`\") from exc\n\t            logger.log_failure(\n\t                obj,\n\t                f\"Failed with an unknown issue. `{exc.result.exception}`\",\n\t                grouping=task.host.name,\n\t            )\n\t            raise NornirNetboxException(f\"Failed with an unknown issue. `{exc.result.exception}`\") from exc\n\t        if result[0].failed:\n", "            return result\n\t        running_config = result[0].result\n\t        # Primarily seen in Cisco devices.\n\t        if \"ERROR: % Invalid input detected at\" in running_config:\n\t            logger.log_failure(\n\t                obj,\n\t                \"Discovered `ERROR: % Invalid input detected at` in the output\",\n\t                grouping=task.host.name,\n\t            )\n\t            raise NornirNetboxException(\"Discovered `ERROR: % Invalid input detected at` in the output\")\n", "        return Result(host=task.host, result={\"config\": running_config})\n\t    @staticmethod\n\t    def get_facts(task: Task, logger, obj) -> Result:\n\t        return NotImplementedError(\"get_facts is not implemented for NetmikoNetboxNornirDriver\")\n\t    @staticmethod\n\t    def get_interfaces(task: Task, logger, obj) -> Result:\n\t        return NotImplementedError(\"get_interfaces is not implemented for NetmikoNetboxNornirDriver\")\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_ios_restconf.py", "chunked_list": ["\"\"\"Cisco IOS RESTCONF driver.\"\"\"\n\timport requests\n\tfrom nornir.core.task import Result, Task\n\tfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Fortigate for configuration backup.\"\"\"\n\t    @staticmethod\n\t    def get_config(task: Task, logger, obj) -> Result:\n\t        \"\"\"Get the latest configuration from the device.\n\t        Args:\n", "            task (Task): Nornir Task.\n\t            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n\t            obj (Device): A Netbox Device Django ORM object instance.\n\t        Returns:\n\t            Result: Nornir Result object with a dict as a result containing the running configuration\n\t                { \"config: <running configuration> }\n\t        \"\"\"\n\t        session = requests.Session()\n\t        session.trust_env = False\n\t        logger.log_debug(\n", "            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n\t            grouping=task.host.name,\n\t        )\n\t        auth = (task.host.username, task.host.password)\n\t        headers = {\"Accept\": \"application/yang-data+json\"}\n\t        params = {\"content\": \"config\", \"depth\": \"65535\"}\n\t        response = session.get(\n\t            f\"https://{task.host.hostname}/restconf/data/Cisco-IOS-XE-native:native\",\n\t            auth=auth,\n\t            headers=headers,\n", "            params=params,\n\t            verify=False,\n\t            timeout=10,\n\t        )\n\t        response.raise_for_status()\n\t        return Result(host=task.host, result={\"config\": response.text})\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/fortinet_fortios.py", "chunked_list": ["\"\"\"Fortinet FortiOS Netbox Nornir Driver.\"\"\"\n\timport requests\n\tfrom nornir.core.task import Result, Task\n\tfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Fortigate for configuration backup.\"\"\"\n\t    @staticmethod\n\t    def get_config(task: Task, logger, obj) -> Result:\n\t        \"\"\"Get the latest configuration from the device.\n\t        Args:\n", "            task (Task): Nornir Task.\n\t            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n\t            obj (Device): A Netbox Device Django ORM object instance.\n\t        Returns:\n\t            Result: Nornir Result object with a dict as a result containing the running configuration\n\t                { \"config: <running configuration> }\n\t        \"\"\"\n\t        session = requests.Session()\n\t        session.trust_env = False\n\t        logger.log_debug(\n", "            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n\t            grouping=task.host.name,\n\t        )\n\t        response = session.get(\n\t            f\"https://{task.host.hostname}/api/v2/monitor/system/config/backup?scope=global&access_token={task.host.data['key']}\",\n\t            verify=False,\n\t            timeout=10,\n\t        )\n\t        response.raise_for_status()\n\t        return Result(host=task.host, result={\"config\": response.text})\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/arista_eos.py", "chunked_list": ["\"\"\"network_importer driver for arista_eos.\"\"\"\n\tfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Collection of Nornir Tasks specific to Arista EOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/paloalto_panos.py", "chunked_list": ["\"\"\"Palo Alto PANOS driver.\"\"\"\n\timport xml.dom.minidom  # nosec\n\timport requests\n\tfrom nornir.core.task import Result, Task\n\tfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Palo Alto PANOS driver for configuration backup.\"\"\"\n\t    @staticmethod\n\t    def get_config(task: Task, logger, obj) -> Result:\n\t        \"\"\"Get the latest configuration from the device.\n", "        Args:\n\t            task (Task): Nornir Task.\n\t            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n\t            obj (Device): A Netbox Device Django ORM object instance.\n\t        Returns:\n\t            Result: Nornir Result object with a dict as a result containing the running configuration\n\t                { \"config: <running configuration> }\n\t        \"\"\"\n\t        session = requests.Session()\n\t        session.trust_env = False\n", "        logger.log_debug(\n\t            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n\t            grouping=task.host.name,\n\t        )\n\t        response = session.get(\n\t            f\"https://{task.host.hostname}/api/?type=export&category=configuration&key={task.host.data['key']}\",\n\t            verify=False,\n\t            timeout=10,\n\t        )\n\t        response.raise_for_status()\n", "        xml_response = xml.dom.minidom.parseString(response.text)  # nosec\n\t        xml_pretty = xml_response.toprettyxml()\n\t        return Result(host=task.host, result={\"config\": xml_pretty})\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_ios.py", "chunked_list": ["\"\"\"network_importer driver for cisco IOS.\"\"\"\n\tfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\tclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n\t    \"\"\"Driver for Cisco IOS.\"\"\"\n"]}
{"filename": "docker/configuration/configuration.example.py", "chunked_list": ["import re\n\tfrom os import environ\n\tfrom os.path import abspath, dirname, join\n\t# For reference see https://netbox.readthedocs.io/en/stable/configuration/\n\t# Based on https://github.com/netbox-community/netbox/blob/master/netbox/netbox/configuration.example.py\n\t# Read secret from file\n\tdef _read_secret(secret_name, default=None):\n\t    try:\n\t        f = open(\"/run/secrets/\" + secret_name, \"r\", encoding=\"utf-8\")\n\t    except EnvironmentError:\n", "        return default\n\t    else:\n\t        with f:\n\t            return f.readline().strip()\n\t_BASE_DIR = dirname(dirname(abspath(__file__)))\n\t#########################\n\t#                       #\n\t#   Required settings   #\n\t#                       #\n\t#########################\n", "# This is a list of valid fully-qualified domain names (FQDNs) for the NetBox server. NetBox will not permit write\n\t# access to the server via any other hostnames. The first FQDN in the list will be treated as the preferred name.\n\t#\n\t# Example: ALLOWED_HOSTS = ['netbox.example.com', 'netbox.internal.local']\n\tALLOWED_HOSTS = environ.get(\"ALLOWED_HOSTS\", \"*\").split(\" \")\n\t# PostgreSQL database configuration. See the Django documentation for a complete list of available parameters:\n\t#   https://docs.djangoproject.com/en/stable/ref/settings/#databases\n\tDATABASE = {\n\t    \"NAME\": environ.get(\"DB_NAME\", \"netbox\"),  # Database name\n\t    \"USER\": environ.get(\"DB_USER\", \"\"),  # PostgreSQL username\n", "    \"PASSWORD\": _read_secret(\"db_password\", environ.get(\"DB_PASSWORD\", \"\")),\n\t    # PostgreSQL password\n\t    \"HOST\": environ.get(\"DB_HOST\", \"localhost\"),  # Database server\n\t    \"PORT\": environ.get(\"DB_PORT\", \"\"),  # Database port (leave blank for default)\n\t    \"OPTIONS\": {\"sslmode\": environ.get(\"DB_SSLMODE\", \"prefer\")},\n\t    # Database connection SSLMODE\n\t    \"CONN_MAX_AGE\": int(environ.get(\"DB_CONN_MAX_AGE\", \"300\")),\n\t    # Max database connection age\n\t    \"DISABLE_SERVER_SIDE_CURSORS\": environ.get(\"DB_DISABLE_SERVER_SIDE_CURSORS\", \"False\").lower() == \"true\",\n\t    # Disable the use of server-side cursors transaction pooling\n", "}\n\t# Redis database settings. Redis is used for caching and for queuing background tasks such as webhook events. A separate\n\t# configuration exists for each. Full connection details are required in both sections, and it is strongly recommended\n\t# to use two separate database IDs.\n\tREDIS = {\n\t    \"tasks\": {\n\t        \"HOST\": environ.get(\"REDIS_HOST\", \"localhost\"),\n\t        \"PORT\": int(environ.get(\"REDIS_PORT\", 6379)),\n\t        \"PASSWORD\": _read_secret(\"redis_password\", environ.get(\"REDIS_PASSWORD\", \"\")),\n\t        \"DATABASE\": int(environ.get(\"REDIS_DATABASE\", 0)),\n", "        \"SSL\": environ.get(\"REDIS_SSL\", \"False\").lower() == \"true\",\n\t        \"INSECURE_SKIP_TLS_VERIFY\": environ.get(\"REDIS_INSECURE_SKIP_TLS_VERIFY\", \"False\").lower() == \"true\",\n\t    },\n\t    \"caching\": {\n\t        \"HOST\": environ.get(\"REDIS_CACHE_HOST\", environ.get(\"REDIS_HOST\", \"localhost\")),\n\t        \"PORT\": int(environ.get(\"REDIS_CACHE_PORT\", environ.get(\"REDIS_PORT\", 6379))),\n\t        \"PASSWORD\": _read_secret(\n\t            \"redis_cache_password\",\n\t            environ.get(\"REDIS_CACHE_PASSWORD\", environ.get(\"REDIS_PASSWORD\", \"\")),\n\t        ),\n", "        \"DATABASE\": int(environ.get(\"REDIS_CACHE_DATABASE\", 1)),\n\t        \"SSL\": environ.get(\"REDIS_CACHE_SSL\", environ.get(\"REDIS_SSL\", \"False\")).lower() == \"true\",\n\t        \"INSECURE_SKIP_TLS_VERIFY\": environ.get(\n\t            \"REDIS_CACHE_INSECURE_SKIP_TLS_VERIFY\",\n\t            environ.get(\"REDIS_INSECURE_SKIP_TLS_VERIFY\", \"False\"),\n\t        ).lower()\n\t        == \"true\",\n\t    },\n\t}\n\t# This key is used for secure generation of random numbers and strings. It must never be exposed outside of this file.\n", "# For optimal security, SECRET_KEY should be at least 50 characters in length and contain a mix of letters, numbers, and\n\t# symbols. NetBox will not run without this defined. For more information, see\n\t# https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-SECRET_KEY\n\tSECRET_KEY = _read_secret(\"secret_key\", environ.get(\"SECRET_KEY\", \"\"))\n\t#########################\n\t#                       #\n\t#   Optional settings   #\n\t#                       #\n\t#########################\n\t# Specify one or more name and email address tuples representing NetBox administrators. These people will be notified of\n", "# application errors (assuming correct email settings are provided).\n\tADMINS = [\n\t    # ['John Doe', 'jdoe@example.com'],\n\t]\n\t# URL schemes that are allowed within links in NetBox\n\tALLOWED_URL_SCHEMES = (\n\t    \"file\",\n\t    \"ftp\",\n\t    \"ftps\",\n\t    \"http\",\n", "    \"https\",\n\t    \"irc\",\n\t    \"mailto\",\n\t    \"sftp\",\n\t    \"ssh\",\n\t    \"tel\",\n\t    \"telnet\",\n\t    \"tftp\",\n\t    \"vnc\",\n\t    \"xmpp\",\n", ")\n\t# Optionally display a persistent banner at the top and/or bottom of every page. HTML is allowed. To display the same\n\t# content in both banners, define BANNER_TOP and set BANNER_BOTTOM = BANNER_TOP.\n\tBANNER_TOP = environ.get(\"BANNER_TOP\", \"\")\n\tBANNER_BOTTOM = environ.get(\"BANNER_BOTTOM\", \"\")\n\t# Text to include on the login page above the login form. HTML is allowed.\n\tBANNER_LOGIN = environ.get(\"BANNER_LOGIN\", \"\")\n\t# Base URL path if accessing NetBox within a directory. For example, if installed at http://example.com/netbox/, set:\n\t# BASE_PATH = 'netbox/'\n\tBASE_PATH = environ.get(\"BASE_PATH\", \"\")\n", "# Maximum number of days to retain logged changes. Set to 0 to retain changes indefinitely. (Default: 90)\n\tCHANGELOG_RETENTION = int(environ.get(\"CHANGELOG_RETENTION\", 90))\n\t# API Cross-Origin Resource Sharing (CORS) settings. If CORS_ORIGIN_ALLOW_ALL is set to True, all origins will be\n\t# allowed. Otherwise, define a list of allowed origins using either CORS_ORIGIN_WHITELIST or\n\t# CORS_ORIGIN_REGEX_WHITELIST. For more information, see https://github.com/ottoyiu/django-cors-headers\n\tCORS_ORIGIN_ALLOW_ALL = environ.get(\"CORS_ORIGIN_ALLOW_ALL\", \"False\").lower() == \"true\"\n\tCORS_ORIGIN_WHITELIST = list(filter(None, environ.get(\"CORS_ORIGIN_WHITELIST\", \"https://localhost\").split(\" \")))\n\tCORS_ORIGIN_REGEX_WHITELIST = [\n\t    re.compile(r) for r in list(filter(None, environ.get(\"CORS_ORIGIN_REGEX_WHITELIST\", \"\").split(\" \")))\n\t]\n", "# Cross-Site-Request-Forgery-Attack settings. If Netbox is sitting behind a reverse proxy, you might need to set the CSRF_TRUSTED_ORIGINS flag.\n\t# Django 4.0 requires to specify the URL Scheme in this setting. An example environment variable could be specified like:\n\t# CSRF_TRUSTED_ORIGINS=https://demo.netbox.dev http://demo.netbox.dev\n\tCSRF_TRUSTED_ORIGINS = list(filter(None, environ.get(\"CSRF_TRUSTED_ORIGINS\", \"\").split(\" \")))\n\t# Set to True to enable server debugging. WARNING: Debugging introduces a substantial performance penalty and may reveal\n\t# sensitive information about your installation. Only enable debugging while performing testing. Never enable debugging\n\t# on a production system.\n\tDEBUG = environ.get(\"DEBUG\", \"False\").lower() == \"true\"\n\tDEVELOPER = True\n\t# Email settings\n", "EMAIL = {\n\t    \"SERVER\": environ.get(\"EMAIL_SERVER\", \"localhost\"),\n\t    \"PORT\": int(environ.get(\"EMAIL_PORT\", 25)),\n\t    \"USERNAME\": environ.get(\"EMAIL_USERNAME\", \"\"),\n\t    \"PASSWORD\": _read_secret(\"email_password\", environ.get(\"EMAIL_PASSWORD\", \"\")),\n\t    \"USE_SSL\": environ.get(\"EMAIL_USE_SSL\", \"False\").lower() == \"true\",\n\t    \"USE_TLS\": environ.get(\"EMAIL_USE_TLS\", \"False\").lower() == \"true\",\n\t    \"SSL_CERTFILE\": environ.get(\"EMAIL_SSL_CERTFILE\", \"\"),\n\t    \"SSL_KEYFILE\": environ.get(\"EMAIL_SSL_KEYFILE\", \"\"),\n\t    \"TIMEOUT\": int(environ.get(\"EMAIL_TIMEOUT\", 10)),  # seconds\n", "    \"FROM_EMAIL\": environ.get(\"EMAIL_FROM\", \"\"),\n\t}\n\t# Enforcement of unique IP space can be toggled on a per-VRF basis. To enforce unique IP space within the global table\n\t# (all prefixes and IP addresses not assigned to a VRF), set ENFORCE_GLOBAL_UNIQUE to True.\n\tENFORCE_GLOBAL_UNIQUE = environ.get(\"ENFORCE_GLOBAL_UNIQUE\", \"False\").lower() == \"true\"\n\t# Exempt certain models from the enforcement of view permissions. Models listed here will be viewable by all users and\n\t# by anonymous users. List models in the form `<app>.<model>`. Add '*' to this list to exempt all models.\n\tEXEMPT_VIEW_PERMISSIONS = list(filter(None, environ.get(\"EXEMPT_VIEW_PERMISSIONS\", \"\").split(\" \")))\n\t# Enable GraphQL API.\n\tGRAPHQL_ENABLED = environ.get(\"GRAPHQL_ENABLED\", \"True\").lower() == \"true\"\n", "# Enable custom logging. Please see the Django documentation for detailed guidance on configuring custom logs:\n\t#   https://docs.djangoproject.com/en/stable/topics/logging/\n\tLOGGING = {}\n\t# Setting this to True will permit only authenticated users to access any part of NetBox. By default, anonymous users\n\t# are permitted to access most data in NetBox (excluding secrets) but not make any changes.\n\tLOGIN_REQUIRED = environ.get(\"LOGIN_REQUIRED\", \"False\").lower() == \"true\"\n\t# The length of time (in seconds) for which a user will remain logged into the web UI before being prompted to\n\t# re-authenticate. (Default: 1209600 [14 days])\n\tLOGIN_TIMEOUT = int(environ.get(\"LOGIN_TIMEOUT\", 1209600))\n\t# Setting this to True will display a \"maintenance mode\" banner at the top of every page.\n", "MAINTENANCE_MODE = environ.get(\"MAINTENANCE_MODE\", \"False\").lower() == \"true\"\n\t# Maps provider\n\tMAPS_URL = environ.get(\"MAPS_URL\", None)\n\t# An API consumer can request an arbitrary number of objects =by appending the \"limit\" parameter to the URL (e.g.\n\t# \"?limit=1000\"). This setting defines the maximum limit. Setting it to 0 or None will allow an API consumer to request\n\t# all objects by specifying \"?limit=0\".\n\tMAX_PAGE_SIZE = int(environ.get(\"MAX_PAGE_SIZE\", 1000))\n\t# The file path where uploaded media such as image attachments are stored. A trailing slash is not needed. Note that\n\t# the default value of this setting is derived from the installed location.\n\tMEDIA_ROOT = environ.get(\"MEDIA_ROOT\", join(_BASE_DIR, \"media\"))\n", "# Expose Prometheus monitoring metrics at the HTTP endpoint '/metrics'\n\tMETRICS_ENABLED = environ.get(\"METRICS_ENABLED\", \"False\").lower() == \"true\"\n\t# Credentials that NetBox will uses to authenticate to devices when connecting via NAPALM.\n\tNAPALM_USERNAME = environ.get(\"NAPALM_USERNAME\", \"\")\n\tNAPALM_PASSWORD = _read_secret(\"napalm_password\", environ.get(\"NAPALM_PASSWORD\", \"\"))\n\t# NAPALM timeout (in seconds). (Default: 30)\n\tNAPALM_TIMEOUT = int(environ.get(\"NAPALM_TIMEOUT\", 30))\n\t# NAPALM optional arguments (see http://napalm.readthedocs.io/en/latest/support/#optional-arguments). Arguments must\n\t# be provided as a dictionary.\n\tNAPALM_ARGS = {}\n", "# Determine how many objects to display per page within a list. (Default: 50)\n\tPAGINATE_COUNT = int(environ.get(\"PAGINATE_COUNT\", 50))\n\t# Enable installed plugins. Add the name of each plugin to the list.\n\t# configuration.py\n\tPLUGINS = [\n\t    \"netbox_nornir\",\n\t]\n\t# Plugins configuration settings. These settings are used by various plugins that the user may have installed.\n\t# Each key in the dictionary is the name of an installed plugin and its value is a dictionary of settings.\n\tPLUGINS_CONFIG = {\n", "    \"netbox_config_backup\": {\n\t        \"smtp_server\": \"\",\n\t        \"smtp_port\": 587,\n\t        \"smtp_username\": \"\",\n\t        \"smtp_password\": \"\",\n\t    },\n\t}\n\t# When determining the primary IP address for a device, IPv6 is preferred over IPv4 by default. Set this to True to\n\t# prefer IPv4 instead.\n\tPREFER_IPV4 = environ.get(\"PREFER_IPV4\", \"False\").lower() == \"true\"\n", "# Rack elevation size defaults, in pixels. For best results, the ratio of width to height should be roughly 10:1.\n\tRACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(environ.get(\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", 22))\n\tRACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(environ.get(\"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\", 220))\n\t# Remote authentication support\n\tREMOTE_AUTH_ENABLED = environ.get(\"REMOTE_AUTH_ENABLED\", \"False\").lower() == \"true\"\n\tREMOTE_AUTH_BACKEND = environ.get(\"REMOTE_AUTH_BACKEND\", \"netbox.authentication.RemoteUserBackend\")\n\tREMOTE_AUTH_HEADER = environ.get(\"REMOTE_AUTH_HEADER\", \"HTTP_REMOTE_USER\")\n\tREMOTE_AUTH_AUTO_CREATE_USER = environ.get(\"REMOTE_AUTH_AUTO_CREATE_USER\", \"True\").lower() == \"true\"\n\tREMOTE_AUTH_DEFAULT_GROUPS = list(filter(None, environ.get(\"REMOTE_AUTH_DEFAULT_GROUPS\", \"\").split(\" \")))\n\t# This repository is used to check whether there is a new release of NetBox available. Set to None to disable the\n", "# version check or use the URL below to check for release in the official NetBox repository.\n\t# https://api.github.com/repos/netbox-community/netbox/releases\n\tRELEASE_CHECK_URL = environ.get(\"RELEASE_CHECK_URL\", None)\n\t# The file path where custom reports will be stored. A trailing slash is not needed. Note that the default value of\n\t# this setting is derived from the installed location.\n\tREPORTS_ROOT = environ.get(\"REPORTS_ROOT\", \"/etc/netbox/reports\")\n\t# Maximum execution time for background tasks, in seconds.\n\tRQ_DEFAULT_TIMEOUT = int(environ.get(\"RQ_DEFAULT_TIMEOUT\", 300))\n\t# The file path where custom scripts will be stored. A trailing slash is not needed. Note that the default value of\n\t# this setting is derived from the installed location.\n", "SCRIPTS_ROOT = environ.get(\"SCRIPTS_ROOT\", \"/etc/netbox/scripts\")\n\t# By default, NetBox will store session data in the database. Alternatively, a file path can be specified here to use\n\t# local file storage instead. (This can be useful for enabling authentication on a standby instance with read-only\n\t# database access.) Note that the user as which NetBox runs must have read and write permissions to this path.\n\tSESSION_FILE_PATH = environ.get(\"SESSIONS_ROOT\", None)\n\t# Time zone (default: UTC)\n\tTIME_ZONE = environ.get(\"TIME_ZONE\", \"UTC\")\n\t# Date/time formatting. See the following link for supported formats:\n\t# https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date\n\tDATE_FORMAT = environ.get(\"DATE_FORMAT\", \"N j, Y\")\n", "SHORT_DATE_FORMAT = environ.get(\"SHORT_DATE_FORMAT\", \"Y-m-d\")\n\tTIME_FORMAT = environ.get(\"TIME_FORMAT\", \"g:i a\")\n\tSHORT_TIME_FORMAT = environ.get(\"SHORT_TIME_FORMAT\", \"H:i:s\")\n\tDATETIME_FORMAT = environ.get(\"DATETIME_FORMAT\", \"N j, Y g:i a\")\n\tSHORT_DATETIME_FORMAT = environ.get(\"SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")\n"]}
