{"filename": "setup.py", "chunked_list": ["#!/usr/bin/env python\n\timport setuptools\n\tif __name__ == \"__main__\":\n\t    setuptools.setup()\n"]}
{"filename": "tests/conftest.py", "chunked_list": []}
{"filename": "tests/showcase/test_showcasing.py", "chunked_list": ["from manim import *\n\tfrom powermanim.showcase.showcasescene import QUALITY, WOWCHEMY_FOLDER, ShowcaseMeta\n\tdef test_and_gen_showcases():\n\t    for scene in ShowcaseMeta.showcase_scenes:\n\t        with tempconfig(\n\t            {\n\t                \"quality\": QUALITY,\n\t                \"disable_caching\": True,\n\t                \"custom_folders\": True,\n\t                \"media_dir\": WOWCHEMY_FOLDER,\n", "            }\n\t        ):\n\t            scene = scene()\n\t            scene.render()\n"]}
{"filename": "src/powermanim/__init__.py", "chunked_list": ["try:\n\t    from ._version import __version__ as __version__\n\texcept ImportError:\n\t    import sys\n\t    print(\n\t        \"Project not installed in the current env, activate the correct env or install it with:\\n\\tpip install -e .\",\n\t        file=sys.stderr,\n\t    )\n\t    __version__ = \"unknown\"\n"]}
{"filename": "src/powermanim/components/chartbars.py", "chunked_list": ["import itertools\n\tfrom typing import Iterable, Sequence\n\tfrom colour import Color\n\tfrom manim import *\n\tclass ChartBars(VGroup):\n\t    def __init__(\n\t        self,\n\t        axes,\n\t        values: Sequence[float | int],\n\t        xs: Sequence[float] | None = None,\n", "        width_ratio: float = 1.0,\n\t        offset: float = 0.5,\n\t        fill_color: Color = BLUE,\n\t        fill_opacity: float = 0.5,\n\t        stroke_color: Color = WHITE,\n\t        stroke_width: float = 1.0,\n\t    ):\n\t        \"\"\"Create a bar chart from values.\n\t        Args:\n\t            axes: The axes to plot the bars on.\n", "            values: The values to plot. There should be one value for each bar.\n\t            xs: The x-coordinates of the bars. If None, the bars will be centered on\n\t                each integer from 1 to the number of values.\n\t            width_ratio: The width of each bar as a fraction of the distance between x-coordinates.\n\t            offset: The distance of the bars from the x-coordinates as a fraction of the distance between x-coordinates.\n\t            fill_color: The fill color of the bars.\n\t            fill_opacity: The fill opacity of the bars.\n\t            stroke_color: The stroke color of the bars.\n\t            stroke_width: The stroke width of the bars.\n\t        \"\"\"\n", "        xs = xs if xs is not None else np.arange(*axes.x_range)\n\t        self.x_to_index = dict(zip(xs, itertools.count()))\n\t        x_step = xs[1] - xs[0]\n\t        x_unit = axes.x_axis.get_unit_size()\n\t        y_unit = axes.y_axis.get_unit_size()\n\t        width = width_ratio * x_unit * x_step\n\t        # Create a list of rectangles arranged side by side,\n\t        # one for each x value\n\t        rects = []\n\t        epsilon = 1e-8\n", "        for x, y in zip(xs, values):\n\t            rect = Rectangle(\n\t                width=width,\n\t                height=max(y * y_unit, epsilon),\n\t                fill_color=fill_color,\n\t                fill_opacity=fill_opacity,\n\t                stroke_color=stroke_color,\n\t                stroke_width=stroke_width,\n\t            )\n\t            rect.move_to(axes.c2p(x + offset * x_step, 0), DOWN)\n", "            rects.append(rect)\n\t        super().__init__(*rects)\n\t        self.axes = axes\n\t        self.xs = xs\n\t        self.set_values(values)\n\t    def set_values(self, values: Iterable[float | int]):\n\t        y_unit = self.axes.y_axis.get_unit_size()\n\t        for rect, value in zip(self, values):\n\t            new_height = value * y_unit\n\t            height = rect.get_top()[1] - rect.get_bottom()[1]\n", "            rescale = new_height / height\n\t            rect.stretch(\n\t                rescale,\n\t                dim=1,\n\t                about_edge=DOWN,\n\t            )\n"]}
{"filename": "src/powermanim/components/numberslider.py", "chunked_list": ["from manim import *\n\tclass NumberSlider(VGroup):\n\t    def __init__(\n\t        self,\n\t        x_range=[-2, 2, 0.5],\n\t        length=2,\n\t    ):\n\t        \"\"\"A class to represent a number together with an associated slider.\n\t        Args:\n\t            x_range (list): A list of 3 floats representing x_min, x_max and x_step.\n", "            length (float): Length of the line.\n\t        \"\"\"\n\t        self.tracker = ValueTracker(0)\n\t        decimal_number = DecimalNumber(self.tracker.get_value(), num_decimal_places=1)\n\t        number_line = NumberLine(\n\t            x_range=x_range,\n\t            length=length,\n\t            rotation=90 * DEGREES,\n\t        )\n\t        arrow = Arrow(RIGHT / 2, LEFT / 2, buff=0).next_to(number_line.n2p(self.tracker.get_value()), RIGHT)\n", "        arrow.add_updater(lambda obj: obj.become(obj.copy().next_to(number_line.n2p(self.tracker.get_value()), RIGHT)))\n\t        decimal_number.add_updater(\n\t            lambda obj: obj.set_value(\n\t                self.tracker.get_value(),\n\t            ).next_to(number_line, LEFT, buff=MED_LARGE_BUFF)\n\t        )\n\t        super().__init__(decimal_number, number_line, arrow)\n"]}
{"filename": "src/powermanim/components/__init__.py", "chunked_list": []}
{"filename": "src/powermanim/components/vgrouphighlight.py", "chunked_list": ["import typing as T\n\tfrom manim import *\n\tclass VGroupHighlight(VGroup):\n\t    def __init__(\n\t        self,\n\t        *args: VMobject,\n\t        anim_run_time: float = 1.0,\n\t        anim_lag_ratio: float = 0,\n\t        active_opacity: float = 1.0,\n\t        scale_active: float = 1.0,\n", "        scale_about_point=None,\n\t        scale_about_edge=None,\n\t        **kwargs: VMobject,\n\t    ) -> None:\n\t        \"\"\"Group component that can highlight a subset of its submobjects.\n\t        Args:\n\t            *args: Submobjects to be added to the VGroup.\n\t            anim_run_time (float): The run time of the animation.\n\t            anim_lag_ratio (float): The lag ratio of the animation.\n\t            active_opacity (float): The opacity of the highlighted submobjects.\n", "            scale_active (float): The scale of the highlighted submobjects.\n\t            scale_about_point (np.ndarray): The point to scale about.\n\t            scale_about_edge (np.ndarray): The edge to scale about.\n\t            **kwargs: Keyword arguments to be passed to the VGroup.\n\t        \"\"\"\n\t        super().__init__(*args, **kwargs)\n\t        self.anim_run_time = anim_run_time\n\t        self.anim_lag_ratio = anim_lag_ratio\n\t        self.active_opacity = active_opacity\n\t        self.scale_active = scale_active\n", "        self.scale_about_point = scale_about_point\n\t        self.scale_about_edge = scale_about_edge\n\t        self.previously_active_idxs = []\n\t    def highlight(self, indices: T.Union[int, T.Sequence[int]]) -> AnimationGroup:\n\t        \"\"\"Highlights the submobjects in the given indices in the scene.\n\t        Args:\n\t            scene:\n\t                The scene in which the animation is played.\n\t            indices:\n\t                The indices to highlight. If a single integer is given, only that index is highlighted.\n", "                If a sequence of integers is given, all indices in the sequence are highlighted. The\n\t                previously highlighted indices are dehighlighted smoothly.\n\t        \"\"\"\n\t        anims = []\n\t        if not isinstance(indices, T.Sequence):\n\t            indices = [indices]\n\t        for to_highlight in indices:\n\t            item = self.submobjects[to_highlight]\n\t            if not hasattr(item, \"saved_state\") or item.saved_state is None:\n\t                item.save_state()\n", "            item.target = item.saved_state.copy()\n\t            item.target.scale(\n\t                self.scale_active,\n\t                about_point=self.scale_about_point,\n\t                about_edge=self.scale_about_edge,\n\t            )\n\t            item.target.set_opacity(self.active_opacity)\n\t            anims.append(MoveToTarget(item))\n\t        if self.previously_active_idxs:\n\t            for previously_active_idx in self.previously_active_idxs:\n", "                if previously_active_idx not in indices:\n\t                    anims.append(\n\t                        self.submobjects[previously_active_idx].animate.restore(),\n\t                    )\n\t        self.previously_active_idxs = indices\n\t        return AnimationGroup(*anims, lag_ratio=self.anim_lag_ratio)\n"]}
{"filename": "src/powermanim/components/powermanim.py", "chunked_list": ["from manim import *\n\tfrom manim.constants import DOWN, LEFT, ORIGIN, RIGHT, UP\n\tfrom manim.mobject.geometry.arc import Circle\n\tfrom manim.mobject.geometry.polygram import Square, Triangle\n\tfrom manim.mobject.text.tex_mobject import MathTex, Tex\n\tfrom manim.mobject.types.vectorized_mobject import VGroup\n\tfrom manim.utils.tex_templates import TexFontTemplates\n\t# config[\"pixel_height\"] = 500  #  1080 is default\n\t# config[\"pixel_width\"] = 1500  # 1920 is default\n\tclass PowerManim(VGroup):\n", "    def build_shapes(self):\n\t        logo_green = \"#87c2a5\"\n\t        logo_blue = \"#525893\"\n\t        logo_red = \"#e07a5f\"\n\t        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)\n\t        square = Square(color=logo_blue, fill_opacity=1).shift(UP)\n\t        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)\n\t        square = Difference(square, circle, color=logo_blue, fill_opacity=1)\n\t        triangle = Difference(triangle, square, color=logo_red, fill_opacity=1)\n\t        circle.shift(DL * self.gap)\n", "        triangle.shift(DR * self.gap)\n\t        return VGroup(circle, square, triangle)\n\t    def build_text(self):\n\t        ds_m = MathTex(r\"\\mathbb{PM}\", fill_color=self.logo_black).scale(5)\n\t        ds_m.shift(4.25 * LEFT + 1.5 * UP)\n\t        return ds_m\n\t    def build_banner(self):\n\t        shapes = self.build_shapes()\n\t        ds_p = MathTex(r\"\\mathbb{P}\", fill_color=self.logo_black).scale(2)\n\t        ower = Tex(\"ower\", tex_template=TexFontTemplates.gnu_freeserif_freesans).scale(2)\n", "        ower.next_to(ds_p, RIGHT, buff=SMALL_BUFF).align_to(ds_p, DOWN).set_color(self.font_color)\n\t        power = VGroup(ds_p, ower)\n\t        ds_m = MathTex(r\"\\mathbb{M}\", fill_color=self.logo_black).scale(2)\n\t        anim = Tex(\"anim\", tex_template=TexFontTemplates.gnu_freeserif_freesans).scale(2)\n\t        anim.next_to(ds_m, RIGHT, buff=SMALL_BUFF).align_to(ds_m, DOWN).set_color(self.font_color)\n\t        tmanim = VGroup(ds_m, anim)\n\t        banner = VGroup(power, tmanim).arrange(RIGHT, buff=MED_SMALL_BUFF).move_to(ORIGIN).scale(1.5)\n\t        banner.next_to(shapes[1], LEFT)\n\t        banner.align_to(shapes[0].get_critical_point(UP) + self.gap, DOWN)\n\t        return VGroup(shapes, banner).move_to(ORIGIN)\n", "    def __init__(self, font_color=\"#343434\", logo_black=\"#343434\", gap=0.4):\n\t        self.font_color = font_color\n\t        self.logo_black = logo_black\n\t        self.gap = gap\n\t        shapes = self.build_shapes()\n\t        ds_m = self.build_text()\n\t        super().__init__(*shapes, ds_m)\n\t        self.move_to(ORIGIN)\n"]}
{"filename": "src/powermanim/layouts/arrangedbullets.py", "chunked_list": ["import typing as T\n\tfrom collections import defaultdict\n\tfrom manim import *\n\tclass MathBullet(MathTex):\n\t    def __init__(\n\t        self,\n\t        *text: str,\n\t        level: int = 0,\n\t        group: T.Optional[int] = None,\n\t        adjustment: float = 0.0,\n", "        symbol: T.Optional[str] = r\"\\bullet\",\n\t        autoplace: bool = True,\n\t        **kwargs,\n\t    ):\n\t        \"\"\"A class to represent a bullet point.\n\t        Args:\n\t            text: The text to be displayed.\n\t            level: The indent level of the bullet point.\n\t            group: The group the bullet point belongs to, controls the animations.\n\t            adjustment: The adjustment of the bullet.\n", "            symbol: The symbol to be displayed as the bullet.\n\t            autoplace: Whether to automatically place the bullet point.\n\t        \"\"\"\n\t        self.level = level\n\t        self.adjustment = adjustment\n\t        self.group = group\n\t        self.symbol = symbol\n\t        self.autoplace = autoplace\n\t        first_text, *rest_text = text\n\t        if symbol is not None:\n", "            first_text = rf\"{symbol}~{first_text}\"\n\t        super().__init__(first_text, *rest_text, **kwargs)\n\t    def indent(self, indent_buff: float = MED_LARGE_BUFF * 1.5):\n\t        \"\"\"Indent the bullet point.\n\t        Args:\n\t            indent_buff: The spacing between the bullet and the text.\n\t        \"\"\"\n\t        self.shift(RIGHT * indent_buff * self.level)\n\t    def unindent(self, indent_buff: float = MED_LARGE_BUFF * 1.5):\n\t        \"\"\"Unindent the bullet point.\n", "        Args:\n\t            indent_buff: The spacing between the bullet and the text.\n\t        \"\"\"\n\t        self.shift(LEFT * indent_buff * self.intend_level)\n\t    def adjust(self, adjustment: T.Optional[float] = None):\n\t        \"\"\"Adjust the bullet point.\n\t        Args:\n\t            adjustment: The shift of the bullet.\n\t        \"\"\"\n\t        if adjustment is None:\n", "            adjustment = self.adjustment\n\t        self.shift(self.adjustment)\n\tclass Bullet(MathBullet):\n\t    def __init__(\n\t        self,\n\t        *text: str,\n\t        level: int = 0,\n\t        group: T.Optional[int] = None,\n\t        adjustment: float = 0.0,\n\t        symbol: T.Optional[str] = r\"$\\bullet$\",\n", "        force_inline: bool = False,\n\t        arg_separator=\"\",\n\t        tex_environment=\"center\",\n\t        **kwargs,\n\t    ):\n\t        first_text, *rest_text = text\n\t        if force_inline:\n\t            first_text = r\"\\mbox{\" + first_text\n\t            rest_text = *rest_text, r\"}\"\n\t        super().__init__(\n", "            first_text,\n\t            *rest_text,\n\t            level=level,\n\t            group=group,\n\t            adjustment=adjustment,\n\t            symbol=symbol,\n\t            arg_separator=arg_separator,\n\t            tex_environment=tex_environment,\n\t            **kwargs,\n\t        )\n", "class ArrangedBullets(VGroup):\n\t    def arrage_rows(self, rows: T.Iterable[T.Union[MathBullet, Bullet, MathTex, Tex, Text]]):\n\t        bullet_rows: T.Iterable[MathBullet] = (\n\t            VGroup(*rows)\n\t            .arrange(DOWN, aligned_edge=LEFT, buff=self.line_spacing)\n\t            .to_edge(LEFT, buff=self.left_buff)\n\t            .shift(self.global_shift)\n\t        )\n\t        for row in bullet_rows:\n\t            row.indent(indent_buff=self.indent_buff)\n", "            row.adjust()\n\t    def __init__(\n\t        self,\n\t        *rows: T.Union[MathBullet, Bullet, MathTex, Tex, Text],\n\t        line_spacing: float = MED_LARGE_BUFF * 1.5,\n\t        indent_buff: float = MED_LARGE_BUFF * 1.5,\n\t        left_buff: float = MED_LARGE_BUFF * 1.5,\n\t        global_shift: float = 0.0,\n\t    ):\n\t        \"\"\"A VGroup that arranges the rows in a list of bullet points.\n", "        Args:\n\t            rows: A list of items to be displayed.\n\t            line_spacing: The spacing between the rows.\n\t            indent_buff: The spacing between the bullet and the text.\n\t            left_buff: The spacing between the left edge of the rows and the left edge of the screen.\n\t            global_shift: The global_shift of the rows.\n\t        \"\"\"\n\t        self.line_spacing = line_spacing\n\t        self.indent_buff = indent_buff\n\t        self.left_buff = left_buff\n", "        self.global_shift = global_shift\n\t        rows = [(row if isinstance(row, MathBullet) else Bullet(row)) for row in rows]\n\t        self.arrage_rows((row for row in rows if row.autoplace))\n\t        groups = [row.group for row in rows]\n\t        # If there is a None and aso something else\n\t        if (None in groups) and len(set(groups)) != 1:\n\t            raise ValueError(\"The groups must be specified for all or no bullets at all.\")\n\t        group2bullet = defaultdict(list)\n\t        for i, row in enumerate(rows):\n\t            group = row.group\n", "            if group is None:\n\t                group = i\n\t            group2bullet[group].append(row)\n\t        group_rows = []\n\t        for _, bullets in group2bullet.items():\n\t            group_rows.append(VGroup(*bullets))\n\t        super().__init__(*group_rows)\n\t        self.ngroups = len(self)\n"]}
{"filename": "src/powermanim/layouts/__init__.py", "chunked_list": []}
{"filename": "src/powermanim/templates/__init__.py", "chunked_list": []}
{"filename": "src/powermanim/templates/bulletlist.py", "chunked_list": ["import typing as T\n\tfrom manim import *\n\tfrom powermanim.components.vgrouphighlight import VGroupHighlight\n\tfrom powermanim.layouts.arrangedbullets import ArrangedBullets\n\tclass BulletList(VGroup):\n\t    def __init__(\n\t        self,\n\t        *rows: T.Union[Tex, Text],\n\t        line_spacing: float = MED_LARGE_BUFF * 1.5,\n\t        indent_buff: float = MED_LARGE_BUFF * 1.5,\n", "        left_buff: float = MED_LARGE_BUFF * 2,\n\t        global_shift: float = 0.0,\n\t        inactive_opacity: float = 0.5,\n\t        active_opacity: float = 1.0,\n\t        scale_active: float = 1.0,\n\t    ):\n\t        \"\"\"A class to represent an highlatable list of items.\n\t        Args:\n\t            rows: A list of items to be displayed.\n\t            line_spacing: The spacing between the rows.\n", "            indent_buff: The spacing between the bullet and the text.\n\t            left_buff: The spacing between the left edge of the rows and the left edge of the screen.\n\t            global_shift: The global_shift to apply to the rows.\n\t            inactive_opacity: The opacity of the inactive items.\n\t            active_opacity: The opacity of the active items.\n\t            scale_active: The scale of the active items.\n\t        \"\"\"\n\t        self.arranged_list = ArrangedBullets(\n\t            *rows,\n\t            line_spacing=line_spacing,\n", "            indent_buff=indent_buff,\n\t            left_buff=left_buff,\n\t            global_shift=global_shift,\n\t        ).set_opacity(inactive_opacity)\n\t        self.rows = VGroupHighlight(\n\t            *self.arranged_list,\n\t            active_opacity=active_opacity,\n\t            scale_active=scale_active,\n\t            scale_about_edge=LEFT,\n\t        )\n", "        super().__init__(self.rows)\n\t        self.highlighted = 0\n\t    def also_next(self) -> Animation:\n\t        \"\"\"Highlights also the next item in the list.\"\"\"\n\t        self.highlighted += 1\n\t        if self.highlighted > self.arranged_list.ngroups:\n\t            raise StopIteration(\"No more elements to highlight.\")\n\t        return self.rows.highlight(indices=list(range(self.highlighted)))\n\t    def only_next(self) -> Animation:\n\t        \"\"\"Highlights only the next item in the list.\"\"\"\n", "        if self.highlighted > self.arranged_list.ngroups:\n\t            raise StopIteration(\"No more elements to highlight.\")\n\t        anims = self.rows.highlight(indices=self.highlighted)\n\t        self.highlighted += 1\n\t        return anims\n\t    def clear(self) -> Animation:\n\t        \"\"\"Clears the list hightlighting.\"\"\"\n\t        anims = self.rows.highlight(indices=[])\n\t        self.highlighted = 0\n\t        return anims\n", "    def all(self) -> Animation:\n\t        \"\"\"Highlights all the list.\"\"\"\n\t        return self.rows.highlight(indices=list(range(len(self.rows))))\n"]}
{"filename": "src/powermanim/templates/sectiontitle.py", "chunked_list": ["from manim import *\n\tfrom manim.utils.color import Color\n\tclass SectionTitle(VGroup):\n\t    def __init__(\n\t        self,\n\t        section_title: str,\n\t        in_run_time: float = 0.75,\n\t        out_run_time: float = 0.25,\n\t        out_shift: float = UP,\n\t        border_color: Color = BLUE,\n", "        border_buff: float = MED_LARGE_BUFF,\n\t        border_lag_ratio: float = 0.5,\n\t    ):\n\t        \"\"\"Section title transition.\n\t        Args:\n\t            section_title (str): Title of the section\n\t            in_run_time (float, optional): Run time of the animation. Defaults to 0.75.\n\t            out_run_time (float, optional): Run time of the animation. Defaults to 0.25.\n\t            out_shift (float, optional): Shift of the animation. Defaults to UP.\n\t            border_color (Color, optional): Color of the border. Defaults to BLUE.\n", "            border_buff (float, optional): Buffer of the border. Defaults to MED_LARGE_BUFF.\n\t            border_lag_ratio (float, optional): Lag ratio of the border. Defaults to 0.5.\n\t        \"\"\"\n\t        self.slide_title = Tex(section_title, font_size=72)\n\t        self.border_color = border_color\n\t        self.border_buff = border_buff\n\t        self.border_lag_ratio = border_lag_ratio\n\t        self.in_run_time = in_run_time\n\t        self.out_run_time = out_run_time\n\t        self.out_shift = out_shift\n", "        super().__init__(self.slide_title)\n\t    def show(self, scene: Scene) -> None:\n\t        \"\"\"Show the section title.\n\t        Args:\n\t            scene (Scene): the scene.\n\t        \"\"\"\n\t        scene.play(\n\t            AnimationGroup(\n\t                DrawBorderThenFill(self.slide_title, run_time=self.in_run_time),\n\t                Circumscribe(\n", "                    self.slide_title,\n\t                    color=self.border_color,\n\t                    buff=self.border_buff,\n\t                ),\n\t                lag_ratio=self.border_lag_ratio,\n\t            )\n\t        )\n\t    def hide(self, scene: Scene) -> None:\n\t        \"\"\"Hide the section title.\n\t        Args:\n", "            scene (Scene): the scene.\n\t        \"\"\"\n\t        scene.play(\n\t            FadeOut(self.slide_title, shift=self.out_shift),\n\t            run_time=self.out_run_time,\n\t        )\n"]}
{"filename": "src/powermanim/showcase/showcasescene.py", "chunked_list": ["import abc\n\tfrom typing import Any, Sequence, Type\n\tfrom manim import *\n\tWOWCHEMY_FOLDER = \"docs/static/uploads/media\"\n\tQUALITY = \"medium_quality\"\n\tQUALITY2RES = {\n\t    \"high_quality\": \"1080p60\",\n\t    \"medium_quality\": \"720p30\",\n\t    \"low_quality\": \"480p15\",\n\t}\n", "class ShowcaseMeta(abc.ABCMeta):\n\t    showcase_scenes: Sequence[Type[Scene]] = []\n\t    def __new__(cls, clsname, bases, attrs):\n\t        newclass = super().__new__(cls, clsname, bases, attrs)\n\t        if clsname != \"ShowcaseScene\":\n\t            cls.showcase_scenes.append(newclass)\n\t        return newclass\n\tclass ShowcaseScene(Scene, metaclass=ShowcaseMeta):\n\t    @staticmethod\n\t    @abc.abstractmethod\n", "    def showcasing(self) -> Type[Any]:\n\t        pass\n"]}
{"filename": "src/powermanim/showcase/__init__.py", "chunked_list": ["import importlib\n\timport sys\n\tfrom pathlib import Path\n\t# Import all showcased scenes, in order for them to be registered in ShowcaseMeta\n\tall_python_files = [\n\t    f for f in Path(__file__).parent.rglob(\"*.py\") if f.is_file() and not f.name.endswith(\"__init__.py\")\n\t]\n\tfor m in all_python_files:\n\t    # TODO: fix this hack to get the module name\n\t    module_name = \".\".join(str(m.with_suffix(\"\").relative_to(Path(__file__).parent.parent)).split(\"/\"))\n", "    spec = importlib.util.spec_from_file_location(module_name, m)\n\t    foo = importlib.util.module_from_spec(spec)\n\t    sys.modules[\"module.name\"] = foo\n\t    spec.loader.exec_module(foo)\n"]}
{"filename": "src/powermanim/showcase/components/chartbars.py", "chunked_list": ["from manim import *\n\tfrom scipy.special import softmax\n\tfrom powermanim.components.chartbars import ChartBars\n\tfrom powermanim.showcase.showcasescene import ShowcaseScene\n\tclass ChartBarsShowcase(ShowcaseScene):\n\t    def showcasing():\n\t        return ChartBars\n\t    def construct(self):\n\t        axes = Axes(x_range=[0, 6], y_range=[0, 1.5], x_length=7, y_length=4)\n\t        size = 5\n", "        changes = 3\n\t        dist1 = softmax(np.random.randn(size))\n\t        bars = ChartBars(axes, dist1, xs=list(range(size)), fill_color=RED, stroke_width=0.1)\n\t        self.add(axes, bars)\n\t        for i in range(changes):\n\t            dist2 = softmax(np.random.randn(size))\n\t            self.play(bars.animate.set_values(dist2), run_time=2)\n\t        self.play(bars.animate.set_values(dist1), run_time=2)\n"]}
{"filename": "src/powermanim/showcase/components/numberslider.py", "chunked_list": ["from manim import *\n\tfrom powermanim.components.numberslider import NumberSlider\n\tfrom powermanim.showcase.showcasescene import ShowcaseScene\n\tclass NumberSliderShowcase(ShowcaseScene):\n\t    def showcasing():\n\t        return NumberSlider\n\t    def construct(self):\n\t        slider = NumberSlider()\n\t        self.add(slider)\n\t        self.play(slider.tracker.animate.set_value(2), run_time=1)\n", "        self.play(slider.tracker.animate.set_value(-1), run_time=1)\n\t        self.play(slider.animate.shift(LEFT))\n\t        self.play(slider.tracker.animate.set_value(0.5), run_time=1)\n\t        self.play(slider.tracker.animate.set_value(-1.5), run_time=1)\n\t        self.play(slider.tracker.animate.set_value(0), run_time=1)\n"]}
{"filename": "src/powermanim/showcase/components/__init__.py", "chunked_list": []}
{"filename": "src/powermanim/showcase/components/vgroupghighlight.py", "chunked_list": ["from manim import *\n\tfrom powermanim.components.vgrouphighlight import VGroupHighlight\n\tfrom powermanim.showcase.showcasescene import ShowcaseScene\n\tclass VGroupHighlightShowcase(ShowcaseScene):\n\t    def showcasing():\n\t        return VGroupHighlight\n\t    def construct(self):\n\t        dots = [\n\t            Dot(radius=0.25, color=color, fill_opacity=0.25).shift(i * RIGHT)\n\t            for i, color in zip(\n", "                range(-2, 3),\n\t                [\n\t                    RED,\n\t                    GREEN,\n\t                    BLUE,\n\t                    YELLOW,\n\t                    PINK,\n\t                ],\n\t            )\n\t        ]\n", "        group = VGroupHighlight(*dots, anim_run_time=1, anim_lag_ratio=0.1)\n\t        self.add(group)\n\t        self.play(group.highlight(0))\n\t        self.play(group.highlight(1))\n\t        self.play(group.highlight([2, 3]))\n\t        self.play(group.highlight([1, 3]))\n\t        self.play(group.highlight([]))\n\t        self.play(group.highlight([2, 4]))\n\t        self.play(group.highlight([]))\n\t        self.wait(0.5)\n"]}
{"filename": "src/powermanim/showcase/layouts/arrangedbullets.py", "chunked_list": ["from manim import *\n\tfrom powermanim.layouts.arrangedbullets import ArrangedBullets, Bullet\n\tfrom powermanim.showcase.showcasescene import ShowcaseScene\n\tclass ArrangedBulletsShowcase(ShowcaseScene):\n\t    def showcasing():\n\t        return ArrangedBullets\n\t    def construct(self):\n\t        rows = [\n\t            Bullet(\"First row\"),\n\t            Bullet(\"Second row\"),\n", "            Bullet(\"Elements:\"),\n\t            Bullet(\"First element\", level=1, symbol=\"(1)\"),\n\t            Bullet(\"Second element\", level=1, symbol=\"(2)\"),\n\t            Bullet(\"Third element\", level=1, symbol=\"(3)\"),\n\t        ]\n\t        g_rows = VGroup(*rows).set_opacity(0.25).scale(0.9)\n\t        g_rows.target = ArrangedBullets(\n\t            *g_rows.copy(),\n\t            line_spacing=MED_LARGE_BUFF * 1.25,\n\t            left_buff=MED_LARGE_BUFF * 3,\n", "        ).set_opacity(1)\n\t        self.play(\n\t            MoveToTarget(g_rows),\n\t            rate_func=there_and_back_with_pause,\n\t            run_time=3,\n\t        )\n\t        self.wait()\n"]}
{"filename": "src/powermanim/showcase/layouts/__init__.py", "chunked_list": []}
{"filename": "src/powermanim/showcase/templates/__init__.py", "chunked_list": []}
{"filename": "src/powermanim/showcase/templates/bulletlist.py", "chunked_list": ["from manim import *\n\tfrom powermanim.layouts.arrangedbullets import Bullet\n\tfrom powermanim.showcase.showcasescene import ShowcaseScene\n\tfrom powermanim.templates.bulletlist import BulletList\n\tclass BulletListShowcase(ShowcaseScene):\n\t    def showcasing():\n\t        return BulletList\n\t    def construct(self):\n\t        rows = [\n\t            Bullet(\"First row\", group=0),\n", "            Bullet(\"Second row\", group=1),\n\t            Bullet(\"Elements:\", group=2),\n\t            Bullet(\"First element\", level=1, symbol=\"(1)\", group=3),\n\t            Bullet(\"Second element\", level=1, symbol=\"(2)\", group=4),\n\t            Bullet(\"Third element\", level=1, symbol=\"(3)\", group=5),\n\t        ]\n\t        VGroup(*rows).set_opacity(0.5).scale(0.8)\n\t        bullets = BulletList(\n\t            *rows,\n\t            scale_active=1.2,\n", "        )\n\t        self.add(bullets)\n\t        self.play(bullets.also_next())\n\t        self.play(bullets.also_next())\n\t        self.play(bullets.also_next())\n\t        self.play(bullets.also_next())\n\t        self.play(bullets.also_next())\n\t        self.play(bullets.also_next())\n\t        self.play(bullets.clear())\n\t        self.play(bullets.only_next())\n", "        self.play(bullets.only_next())\n\t        self.play(bullets.only_next())\n\t        self.play(bullets.only_next())\n\t        self.play(bullets.only_next())\n\t        self.play(bullets.only_next())\n\t        self.play(bullets.clear())\n\t        self.wait()\n"]}
{"filename": "src/powermanim/showcase/templates/sectiontitle.py", "chunked_list": ["from powermanim.showcase.showcasescene import ShowcaseScene\n\tfrom powermanim.templates.sectiontitle import SectionTitle\n\tclass SectionTitleShowcase(ShowcaseScene):\n\t    def showcasing():\n\t        return SectionTitle\n\t    def construct(self):\n\t        title = SectionTitle(\"Section Title\")\n\t        title.show(self)\n\t        self.wait(1)\n\t        title.hide(self)\n", "        self.wait(1)\n"]}
