{"filename": "ascension.py", "chunked_list": ["from os import listdir, getcwd\n\tfrom os.path import isdir, isfile, exists\n\tfrom json import load, dump\n\tfrom hsr_client.utils import ImageManipulation as img\n\tfrom PIL import Image\n\tBASE_CHAR = getcwd()+\"/characters/\"\n\tBASE_MATERIALS =  getcwd()+\"/materials/\"\n\tchars = [f for f in listdir(BASE_CHAR) if isfile(BASE_CHAR+f)]\n\tmaterials = [f for f in listdir(BASE_MATERIALS) if isfile(BASE_MATERIALS+f)]\n\tfrom io import BytesIO\n", "cards_bg = {\n\t            'card_5': Image.open(f'{getcwd()}/cards/card_5.webp').convert(\"RGBA\"),\n\t            'card_3': Image.open(f'{getcwd()}/cards/card_3.webp').convert(\"RGBA\"),\n\t            'card_4': Image.open(f'{getcwd()}/cards/card_4.webp').convert(\"RGBA\"),\n\t            'card_2': Image.open(f'{getcwd()}/cards/card_2.webp').convert(\"RGBA\"),\n\t            'card_1': Image.open(f'{getcwd()}/cards/card_0.webp').convert(\"RGBA\"),\n\t            'card_0': Image.open(f'{getcwd()}/cards/card_0.webp').convert(\"RGBA\")\n\t        }\n\tfor char in chars:\n\t    name = char.replace(\".json\",\"\",1)\n", "    if not exists(f\"{getcwd()}/ascension/{name}-ascension.png\"):\n\t        with open(BASE_CHAR+char, 'r') as f:\n\t            data = load(f)\n\t        costs_dict = {'levels': {}, 'skills': {}}\n\t        items = data['itemReferences']\n\t        levels = data['levelData']\n\t        for lvl in levels:\n\t            costs = lvl['cost']\n\t            print(costs)\n\t            for c in costs:\n", "                if str(c['id']) not in costs_dict['levels']:\n\t                    costs_dict['levels'][str(c['id'])] = c['count']\n\t                else:\n\t                    costs_dict['levels'][str(c['id'])] += c['count']\n\t        skills = data['skills']\n\t        for skill in skills:\n\t            lvls = skill['levelData']\n\t            for lvl in lvls:\n\t                costs = lvl['cost']\n\t                for c in costs:\n", "                    if str(c['id']) not in costs_dict['skills']:\n\t                        costs_dict['skills'][str(c['id'])] = c['count']\n\t                    else:\n\t                        costs_dict['skills'][str(c['id'])] += c['count']\n\t        costs_dict['items'] = items\n\t        cards = {'levels': [], 'skills': []}\n\t        with open(\"test.json\", 'w') as f:\n\t            dump(costs_dict, f, indent=1)\n\t        for it in ['levels', 'skills']:\n\t            for item_id in costs_dict[it]:\n", "                if item_id in costs_dict['items']:            \n\t                        with open(f\"{getcwd()}/images/materials/{item_id}-{item_id}-iconpath.png\", 'rb') as f:\n\t                            bytes_obj = BytesIO(f.read())\n\t                        print(cards_bg[f\"card_{costs_dict['items'][str(item_id)]['rarity']}\"])                \n\t                        cards[it].append({\n\t                            'card_bg': cards_bg[f\"card_{costs_dict['items'][str(item_id)]['rarity']}\"],\n\t                            'txt': costs_dict[it][str(item_id)],\n\t                            'img' : bytes_obj,\n\t                            'title': costs_dict['items'][str(item_id)]['name']\n\t                        })\n", "        with open(f\"{getcwd()}/images/characters/{name}-{name}-splashiconpath.png\", \"rb\") as f:\n\t            bytes_ = BytesIO(f.read())\n\t        bg_img = Image.open(f\"{getcwd()}/images/characters/{name}-{name}-bgpath.png\", 'r').convert(\"RGBA\")\n\t        img_ = img.create_image_card(name.title(),bytes_, False ,'Ascension',  0, 0, bg_img)\n\t        max_item = 5\n\t        start_x = img_.size[0] // 2 - 250\n\t        start_y = 250   \n\t        end_x = start_x + (112*5)\n\t        cards_list = cards['levels'] + cards['skills']\n\t        rows = 1\n", "        for c, card in enumerate(cards_list,1):\n\t            count_fix = c\n\t            if c > (rows * max_item):\n\t                rows += 1\n\t                count_fix = (c - ((rows-1) * max_item))\n\t            else:\n\t                if rows > 1:\n\t                    count_fix = c - ((rows-1) * max_item)\n\t                else:\n\t                    count_fix = c \n", "            c_img = img.create_card_image(card)\n\t            x = start_x + (122 * (count_fix - 1)) + 30\n\t            y = start_y + (145 * (rows - 1))+ 30\n\t            img_.paste(c_img, (x,y), c_img)\n\t        img_ = img_.crop((0,0, 1600, img_.size[1]))\n\t        img_ = img.add_corners(img_,45)\n\t        img_.show()\n\t        img_.save(f\"{getcwd()}/ascension/{name}-ascension.png\")\n"]}
{"filename": "raw_data.py", "chunked_list": ["from main import SRSClient\n\tfrom hsr_client.constants import Item, Language\n\tfrom hsr_client.routes import *\n\tfrom os import getcwd, mkdir\n\tfrom os.path import exists\n\tfrom json import dump\n\tfrom time import sleep\n\tfrom pathlib import Path\n\tfrom datetime import datetime\n\tsave_path = f\"{getcwd()}/raw_data\"\n", "client = SRSClient()\n\troutes = {\n\t    Item.CHARACTER.name : CHARACTERS,\n\t    Item.PLAYERCARD.name : PLAYERCARDS,\n\t    Item.FOOD.name : CONSUMABLES,\n\t    Item.RELIC.name : RELICS,\n\t    Item.LIGHTCONE.name : LIGHTCONES,\n\t    Item.BOOK.name : BOOKS,\n\t    Item.MATERIAL.name : MATERIALS\n\t    }\n", "folders = {\n\t    Item.CHARACTER.name : 'characters/',\n\t    Item.PLAYERCARD.name : 'playercards/',\n\t    Item.FOOD.name : 'foods/',\n\t    Item.RELIC.name : 'relics/',\n\t    Item.LIGHTCONE.name : 'lightcones/',\n\t    Item.BOOK.name : 'books/',\n\t    Item.MATERIAL.name : 'materials/'\n\t     }\n\tdef create_path(path :str):\n", "    path_ = Path(f'{save_path}/{path}')\n\t    if not exists(f'{save_path}/{path}'):\n\t        path_.mkdir(parents=True)\n\tdef correct_route(url : str):\n\t   return url.replace('/','s/',1)\n\tdef convert(seconds: int | float):\n\t    seconds = seconds % (24 * 3600)\n\t    hour = seconds // 3600\n\t    seconds %= 3600\n\t    minutes = seconds // 60\n", "    seconds %= 60\n\t    return \"%d:%02d:%02d\" % (hour, minutes, seconds)\n\tSTART_TIME = datetime.now()\n\tlanguage = Language.EN\n\t'''\n\titerate over all languages to get data in all languages\n\t'''\n\t#for language in Languages:  \n\t'''\n\titerate over all languages to get data in all languages\n", "'''\n\tentries = client.get_all_items(None, language) # this gets all items that exist in search database of starrailstation.com\n\tfor entry in entries:\n\t    create_path(f'{language}/{folders[entry.type.name]}')\n\t    if not exists(f'{save_path}/{language}/{folders[entry.type.name]}/{entry.id}.json'):\n\t        '''\n\t        fetches data\n\t        '''\n\t        data = client.fetch(language, routes[entry.type.name], True, entry.id)              \n\t        print(f'[downloading] [Language: {language}]', Item(entry.type).name, entry.name)\n", "        with open(f'{save_path}/{language}/{folders[entry.type.name]}/{entry.id}.json', 'w') as f:\n\t            dump(data, f, indent=1)\n\tprint(f'[downloading] [Language: {language}]', 'ACHIEVEMENTS')   \n\tdata = client.fetch(language, ACHIEVEMENTS, False)\n\twith open(f'{save_path}/{language}/achievements.json', 'w') as f:\n\t    dump(data, f, indent=1)\n\tprint(f'[downloading] [Language: {language}]', 'SIMULATED UNIVERSE', 'Date', ROUGE_DATE)     \n\tdata = client.fetch(language, ROUGES, False)\n\twith open(f'{save_path}/{language}/simulatedUniverse.json', 'w') as f:\n\t    dump(data, f, indent=1)\n", "gachaConfig = Routes(file='gachaConfig.json', path='')\n\tdata = client.fetch(language, gachaConfig, False)\n\twith open(f'{save_path}/{language}/gachaConfig.json', 'w') as f:\n\t    dump(data, f, indent=1)\n\tEND_TIME = datetime.now()\n\tprint(f' [HSR-DATA] download completed in {convert((END_TIME - START_TIME).total_seconds())}')"]}
{"filename": "main.py", "chunked_list": ["from requests_cache import CachedSession\n\tfrom hsr_client.datamodels.searchItem import *\n\tfrom hsr_client.datamodels.character import Character\n\tfrom hsr_client.routes import *\n\tfrom typing import Union, List, LiteralString\n\tfrom hsr_client.utils import generate_t, base36encode\n\tfrom hsr_client.constants import *\n\tfrom hsr_client.errors import *\n\tfrom json import dump\n\tclass SRSClient:\n", "    '''\n\t    StarRailStation Website Client\n\t    : initializes the client\n\t    '''\n\t    def __init__(self) -> None:\n\t        self.__session = CachedSession(cache_name='srs.cache', backend='sqlite', expire_after=3600)\n\t        self.__session.headers.update(\n\t            {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36 Edg/112.0.1722.68',\n\t             'referer': 'https://starrailstation.com/'}\n\t        )\n", "    def generate_hash_route(self, language: Language, route: Routes, goto: bool = False, item_id : Union[int, str]=''):\n\t        '''\n\t        :generates hashed route for fetching data\n\t        --\n\t        params\n\t        --\n\t        - language: Languages Enum\n\t             Languages.EN, Languages.RU etc\n\t        - route: a Routes object\n\t        - goto: if you want to search in a specific route [True] \n", "             defaults to False\n\t        - item_id : id of the item you want to search in a route\n\t        '''\n\t        if not isinstance(language, Language):\n\t            raise InvalidLanguage\n\t        url = route.generate_main_lang_path(language)\n\t        if goto:\n\t            if route.path is not None:\n\t                url = f\"{route.generate_goto_lang_path(language)}{item_id}.json\"            \n\t        hashed_path = base36encode(generate_t(url))\n", "        return  f\"{MAIN_ROUTE}{hashed_path}\"\n\t    def fetch(self, language: Language , route: Routes, goto: bool = False, item_id : Union[int, str] = '') -> List[dict] | dict | None:\n\t        '''\n\t        :fetches data from the api route\n\t        --\n\t        params\n\t        --\n\t        - language: Languages Enum\n\t             Languages.EN, Languages.RU etc\n\t        - route: a Routes object\n", "        - goto: if you want to search in a specific route [True] \n\t             defaults to False\n\t        - item_id : id of the item you want to search in a route\n\t        '''\n\t        if not isinstance(language, Language):\n\t            raise InvalidLanguage\n\t        response = self.__session.get(self.generate_hash_route(language, route, goto, item_id))\n\t        if response.status_code  < 300:\n\t            data = response.json()\n\t            if 'entries' in data:\n", "                return data['entries']\n\t            else:\n\t                return data\n\t    def get_all_items(self,  type: Optional[Item], language: Language = Language.EN) -> list[SearchItem]:\n\t        '''\n\t        :fetches all items from api route\n\t        --\n\t        params\n\t        --\n\t        - language: Languages Enum\n", "             Languages.EN, Languages.RU etc\n\t        - type : a type object \n\t             Item.MATERIALS, Item.PLAYERCARDS, Item.CHARACTERS etc\n\t        '''\n\t        if not isinstance(language, Language):\n\t            raise InvalidLanguage\n\t        response = self.fetch(language, SEARCH, False)\n\t        if response is not None:\n\t            all_items = [SearchItem(**{ **d, **{'id': d['url'].split(\"/\")[1]}}) for d in response]\n\t            if type is not None:\n", "                return list(filter(lambda x: x.type == type, all_items))\n\t            return all_items\n\t        raise Exception('Not enough arguments provided, or nothing is returned from api call!')\n"]}
{"filename": "hsr_client/hsr_types.py", "chunked_list": ["Level = int\n\tCount = int\n\tSuperimposition = int"]}
{"filename": "hsr_client/errors.py", "chunked_list": ["# define Python user-defined exceptions\n\tclass InvalidLanguage(Exception):\n\t    \"Raised when the language is not of type Languages\"\n\t    pass\n\tclass InvalidSearchItem(Exception):\n\t    \"\"\"raised when incorrect searchitem is used.\"\"\"\n\t    pass\n\tclass InvalidFilter(Exception):\n\t    def __init__(self, filters) -> None:\n\t        super().__init__()\n", "        self.filters = filters\n\t    def __str__(self) -> str:\n\t        return f\"Provided parameter doesnot exist in search item, available paramaters for filter [{' ,'.join(self.filters)}]\"\n\tclass EmptyResponse(Exception):\n\t    \"\"\"Raised when returned data is empty, 404 response is got\"\"\"\n\tclass BackendError(Exception):\n\t    \"\"\"\n\t    Raised when a problem is detected with backend, mostly happens when\n\t    backend changes , please report such errors\n\t    \"\"\""]}
{"filename": "hsr_client/__init__.py", "chunked_list": ["from typing import List\n\tfrom hsr_client.constants import Language, Item\n\tfrom hsr_client.backend import BackendAdapter\n\tfrom hsr_client import datamodels as models\n\tfrom hsr_client.datamodels.chara import Character\n\tfrom hsr_client.datamodels.lightcone import Lightcone\n\tfrom hsr_client.datamodels.searchItem import SearchItem\n\t# Public facing api client.\n\tclass HsrClient:\n\t    def __init__(self):\n", "        # abstract away multiple backends. with a single backend adapter.\n\t        # i guess this is too much.\n\t        # just using SRSBackend here would have been enough.\n\t        self.adapter = BackendAdapter()\n\t    # # our own api related logic goes here\n\t    # # in this case, looping and searching.\n\t    # # here we have the convinience of working with our own data models. (ex: Trace)\n\t    # def find_trace(self, trace_name) -> models.trace.Trace:\n\t    #     # for trace in self.adapter().fetch_traces():\n\t    #     #     if trace.name  == trace_name:\n", "    #     #         return\n\t    #     ...\n\t    # def get_character(self, chara_name) -> models.chara.Character:\n\t    #     # nothing else to do here.\n\t    #     return self.adapter().get_character(chara_name)\n\t    def get_lightcone(self, name=None, searchItem=None) -> Lightcone:\n\t        \"\"\"\n\t        get lightcone by name or with SearchItem\n\t        \"\"\"\n\t        if name is not None:\n", "            return self.adapter().get_lightcone_by_name(name)\n\t        elif searchItem is not None:\n\t            return self.adapter().resolve_lightcone(searchItem)\n\t        else:\n\t            raise Exception(\"either name or searchItem is necessary\")\n\t    def get_character(self, name=None, searchItem=None) -> Character:\n\t        \"\"\"\n\t        Get Character by name or `SearchItem`\n\t        \"\"\"\n\t        if name is not None:\n", "            return self.adapter().get_character_by_name(name)\n\t        elif searchItem is not None:\n\t            return self.adapter().resolve_character(searchItem)\n\t        else:\n\t            raise Exception(\"either name or searchItem is necessary\")\n\t    def search_item(\n\t        self,\n\t        item_type: Item,\n\t        filter=None\n\t    ) -> List[SearchItem]:\n", "        return self.adapter().search_item(item_type)\n\tif __name__ == \"__main__\":\n\t    client = HsrClient()\n\t    print(client.get_lightcone(name=\"Arrows\"))\n\t    print(\"--\" * 50)\n\t    print(client.search_item(Item.CHARACTER))\n\t    print(\"--\" * 50)\n\t    chara = client.get_character(name=\"March 7th\")\n\t    print(chara)\n\t    print(\"--\" * 50)\n", "    print(chara.stats(level=72))\n\t    print(\"--\" * 50)\n\t    print(chara.ascension_mats())\n\t    print(\"--\" * 50)\n\t    print(chara.skills()[0].scaling[1].description)"]}
{"filename": "hsr_client/utils.py", "chunked_list": ["from __future__ import annotations\n\tfrom hsr_client.errors import InvalidFilter\n\tfrom typing import Any, Union\n\timport inspect\n\tfrom datetime import date, timedelta, datetime\n\timport calendar\n\tdef generate_t(input):\n\t    t = 0\n\t    for n in range(len(input)):\n\t        t = (t << 5) -t + list(bytes(input, encoding=\"utf8\"))[n]\n", "        t = t & t\n\t    t = t % (2**32) \n\t    return t\n\tdef base36encode(number):\n\t    if not isinstance(number, int):\n\t        raise TypeError('number must be an integer')\n\t    is_negative = number < 0\n\t    number = abs(number)\n\t    alphabet, base36 = ['0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', '']\n\t    while number:\n", "        number, i = divmod(number, 36)\n\t        base36 = alphabet[i] + base36\n\t    if is_negative:\n\t        base36 = '-' + base36\n\t    return base36.lower() or alphabet[0].lower()\n\tdef check(model, attribute : str, value : Union[str, bool, int]):\n\t    \"\"\"checks in a model for attribute and returns it if attributes matches the value given\n\t    to be used for \n\t    Args:\n\t        model (SearchItem): SearchItem model\n", "        attribute (str): attribute of searchItem\n\t        value (Union[str, bool, int]): value to match\n\t    Raises:\n\t        InvalidFilter: raised when provided attribute [filter] doesnot exist in search item\n\t    Returns:\n\t        SearchItem: \n\t    \"\"\"    \n\t    from hsr_client.datamodels.searchItem import SearchItem\n\t    model : SearchItem\n\t    if hasattr(model, attribute):\n", "        if isinstance(model.__getattribute__(attribute), str):\n\t            if value.lower() in model.__getattribute__(attribute).lower():\n\t                return model\n\t        if value == model.__getattribute__(attribute):\n\t            return model\n\t    raise InvalidFilter(model.available_filters())\n\tdef get_weekday(date : date):\n\t    return calendar.weekday(date.year, date.month, date.day)\n\tdef get_monday(date : date):\n\t    return date - timedelta(days=get_weekday(date))\n", "def logc(*msg):\n\t    stack = inspect.stack()\n\t    class_name = stack[1][0].f_locals[\"self\"].__class__.__name__\n\t    print(f\"[{class_name}] at [{datetime.now().strftime('%c')}] - \", *msg)\n"]}
{"filename": "hsr_client/constants.py", "chunked_list": ["from enum import Enum, IntEnum\n\tO_VALUE = \"831f36f73549d1d18a12937d98be4c56\"\n\tclass Item(IntEnum):\n\t    \"\"\"\n\t    Search Item types\n\t    \"\"\"\n\t    CHARACTER = 0\n\t    LIGHTCONE = 1\n\t    RELIC = 2\n\t    BOOK = 3\n", "    MATERIAL = 4\n\t    PLAYERCARD = 5\n\t    FOOD = 6\n\t    def __str__(self) -> int:\n\t        return self.value\n\tclass Language(str, Enum):\n\t    \"\"\"\n\t    Allowed languages\n\t    \"\"\"\n\t    EN = \"en\"\n", "    CN = \"cn\"\n\t    DE = \"de\"\n\t    ES = \"es\"\n\t    FR = \"fr\"\n\t    ID = \"id\"\n\t    JP = \"jp\"\n\t    KR = \"kr\"\n\t    PT = \"pt\"\n\t    RU = \"ru\"\n\t    TH = \"th\"\n", "    def __str__(self) -> str:\n\t        return str(self.value)\n\tclass _RelicTypes(str, Enum):\n\t    \"\"\"\n\t    Relic Types\n\t    \"\"\"\n\t    BODY = \"Body\"\n\t    FEET = \"Feet\"\n\t    PLANAR_SPHERE = \"Planar Sphere\"\n\t    LINK_ROPE = \"Link Rope\"\n", "    HANDS = \"Hands\"\n\t    def __str__(self) -> str:\n\t        return str(self.value)\n\tclass MaterialTypes(int, Enum):\n\t    \"\"\"\n\t    Material Types   \n\t    \"\"\"\n\t    CHARACTER_EXP_MATERIALS = 1\n\t    CHARACTER_ASCENSION_MATERIALS = 2\n\t    TRACE_MATERIAL_LIGHTCONE_ASCENSION_MATERIALS = 3    \n", "    TRACE_MATERIALS = 4\n\t    LIGHTCONE_EXP_MATERIALS = 5\n\t    RELIC_EXP_MATERIALS = 6\n\t    TRACE_MATERIAL_CHARACTER_ASCENSION_MATERIALS = 7\n\t    WARP_ITEM = 8\n\t    LIMITED_WARP_ITEM = 9\n\t    CONSUMABLES = 10\n\t    COMMON_CURRENCY = 11\n\t    RARE_CURRENCY = 12\n\t    WORLD_CURRECNY = 13\n", "    VALUABE_OBJECT = 14\n\t    RELIC_COFFRET = 15\n\t    SYNTHESIS_MATERIAL = 17\n\t    RECIPE = 17\n"]}
{"filename": "hsr_client/paths.py", "chunked_list": ["from enum import Enum\n\tclass Path(Enum):\n\t    HARMONY = \"Applies buffs to allies to improve team's combat capabilities\"\n\t    DESTRUCTION = \"Deals outstanding amounts of damage and possesses great survivability. Suitable for various combat scenarios\"\n\t    HUNT = \"Deals extraordinary amounts of single-target damage The main damage dealer against Elite Enemies\"\n\t    ERUDITION = \"Deals remarkable amounts of multi-target damage. The main damage dealer against group of enemies\"\n\t    NIHILITY = \"Applies debuffs to enemies to reduce their combat capabilities\"\n\t    PRESERVATION = \"Possesses powerful defensive abilities to protect allies in various ways\"\n\t    ABUNDANCE = \"Heals allies and restores HP to them.\"\n\t    def describe(self):\n", "        return self.value\n\tif __name__ == \"__main__\":\n\t    path = Path.HARMONY\n\t    print(path.describe())"]}
{"filename": "hsr_client/routes.py", "chunked_list": ["from hsr_client.constants import O_VALUE\n\tfrom datetime import datetime, date\n\tfrom hsr_client.utils import get_monday\n\tMAIN_ROUTE = f'https://starrailstation.com/api/v1/data/{O_VALUE}/'\n\tIMAGE_ROUTE = 'https://starrailstation.com/assets/{assetId}.webp'\n\tAUDIO_ROUTE = 'https://starrailstation.com/assets/{assetId}.mp3'\n\tclass Routes:\n\t    '''\n\t    This class is meant to convert json files\n\t    to routes for navigating or going to specific Item\n", "    ---\n\t    example:\n\t    ---\n\t    - main path is en/characters.json\n\t    - goto path is en/characters/id.json\n\t    '''\n\t    def __init__(self, file: str, path: str = '') -> None:\n\t        self.file = file\n\t        self.path = path\n\t        if self.path == '':\n", "            self.path = f\"{file.replace('.json','/',1)}\"    \n\t    def generate_goto_lang_path(self, lang: str):\n\t        return f'{lang}/{self.path}'\n\t    def generate_main_lang_path(self, lang: str):\n\t        return f\"{lang}/{self.file}\"\n\tSEARCH = Routes(file='searchItems.json', path='materials/')\n\tCHARACTERS = Routes(file='characters.json')\n\tEQUIPMENT = Routes(file='equipment.json', path='materials/')\n\tRELICS = Routes(file='relics.json')\n\tMATERIALS = Routes(file='materials.json')\n", "BOOKS = Routes('books.json')\n\tCONSUMABLES = Routes('foods.json', path='materials/')\n\tPLAYERCARDS = Routes('playercards.json', path='materials/')\n\tLIGHTCONES = Routes('lightcones.json')\n\tACHIEVEMENTS = Routes(file='achievements.json', path=None)\n\t'''\n\tnot month safe calculation for now\n\t'''\n\tCURRENT_DATE  = datetime.now().date()\n\tROUGE_DATE =  get_monday(CURRENT_DATE)\n", "ROUGES = Routes(file=f'rogue/{str(ROUGE_DATE)}.json', path=f'rogue/{str(ROUGE_DATE)}.json') #idk site has rogue spelling\n"]}
{"filename": "hsr_client/backend/__init__.py", "chunked_list": ["from typing import Union\n\tfrom hsr_client.backend.hoyo_backend import HoyoBackend\n\tfrom .util import Backend\n\tfrom .srs_backend import SRSBackend\n\tfrom requests_cache import CachedSession\n\tclass BackendAdapter():\n\t    def __init__(self):\n\t        self.backends = {\n\t            SRSBackend: SRSBackend(),\n\t        }\n", "    def __call__(self, adapter_name=SRSBackend) -> Union[SRSBackend, HoyoBackend]:\n\t        \"\"\"allows us to  access backend directly via `client.adapter().backend_method()`\n\t        instead of `client.adapter.backends[SRSBackend].backend_method()` or\n\t        something like `client.adapter.default_backend.backend_method()` or \"\"\"\n\t        return self.backends[adapter_name]\n"]}
{"filename": "hsr_client/backend/util.py", "chunked_list": ["# for VS Code intellisense only.\n\tfrom typing import List\n\timport hsr_client.datamodels as models\n\tfrom requests_cache import CachedSession\n\tclass Backend():\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        self.session = CachedSession(\n\t                                    cache_name='hsr.cache',\n\t                                    backend='sqlite',\n", "                                    expire_after=3600)\n\t        self.session.headers.update(\n\t            {\n\t            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/113.0\"\n\t            }\n\t        )\n"]}
{"filename": "hsr_client/backend/srs_backend/__init__.py", "chunked_list": ["import json\n\tfrom typing import List, Union, Optional, Literal\n\tfrom requests_cache import CachedSession\n\tfrom hsr_client.backend.srs_backend.parsers.material import parse_material\n\tfrom hsr_client.constants import Language, Item\n\tfrom hsr_client.datamodels import chara\n\tfrom hsr_client.datamodels.chara import Character\n\tfrom hsr_client.datamodels.lightcone import Lightcone\n\tfrom hsr_client.datamodels.searchItem import SearchItem\n\tfrom hsr_client.datamodels.material import Material\n", "from hsr_client.errors import InvalidLanguage, InvalidSearchItem, EmptyResponse\n\tfrom hsr_client import routes\n\tfrom hsr_client.utils import base36encode, generate_t, check\n\tfrom hsr_client.backend.util import Backend\n\timport hsr_client.datamodels as models\n\troute_mapping = {\n\t    Item.CHARACTER: routes.CHARACTERS,\n\t    Item.PLAYERCARD: routes.PLAYERCARDS,\n\t    Item.FOOD: routes.CONSUMABLES,\n\t    Item.RELIC: routes.RELICS,\n", "    Item.LIGHTCONE: routes.LIGHTCONES,\n\t    Item.BOOK: routes.BOOKS,\n\t    Item.MATERIAL: routes.MATERIALS,\n\t}\n\t# backend for starrail station.\n\tclass SRSBackend(Backend):\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        # self.session = CachedSession(cache_name='srs.cache', backend='sqlite', expire_after=3600)\n\t    def generate_hash_route(\n", "        self,\n\t        language: Language,\n\t        route: routes.Routes,\n\t        goto: bool = False,\n\t        item_id: Union[int, str] = \"\",\n\t    ):\n\t        \"\"\"\n\t        :generates hashed route for fetching data\n\t        --\n\t        params\n", "        --\n\t        - language: Languages Enum\n\t             Languages.ENG, Languages.RU etc\n\t        - route: a Routes object\n\t        - goto: if you want to search in a specific route [True]\n\t             defaults to False\n\t        - item_id : id of the item you want to search in a route\n\t        \"\"\"\n\t        if not isinstance(language, Language):\n\t            raise InvalidLanguage\n", "        url = route.generate_main_lang_path(language)\n\t        if goto:\n\t            if route.path is not None:\n\t                url = f\"{route.generate_goto_lang_path(language)}{item_id}.json\"\n\t        hashed_path = base36encode(generate_t(url))\n\t        return f\"{routes.MAIN_ROUTE}{hashed_path}\"\n\t    def __fetch(\n\t        self,\n\t        language: Language,\n\t        route: routes.Routes,\n", "        goto: bool = False,\n\t        item_id: Union[int, str] = \"\",\n\t    ) -> List[dict] | dict | None:\n\t        \"\"\"\n\t        :fetches data from the api route\n\t        --\n\t        params\n\t        --\n\t        - language: Languages Enum\n\t             Languages.EN, Languages.RU etc\n", "        - route: a Routes object\n\t        - goto: if you want to search in a specific route [True]\n\t             defaults to False\n\t        - item_id : id of the item you want to search in a route\n\t        \"\"\"\n\t        if not isinstance(language, Language):\n\t            raise InvalidLanguage\n\t        self.session.headers.update({\"referer\": \"https://starrailstation.com/\"})\n\t        response = self.session.get(\n\t            self.generate_hash_route(language, route, goto, item_id)\n", "        )\n\t        if response.status_code < 300:\n\t            data = response.json()\n\t            if \"entries\" in data:\n\t                return data[\"entries\"]\n\t            else:\n\t                return data\n\t    def search_item(\n\t        self, item_type: Optional[Item] = None, \n\t        language: Language = Language.EN\n", "        ) -> list[SearchItem]:\n\t        \"\"\"\n\t        :fetches all items from api route\n\t        --\n\t        params\n\t        --\n\t        - language: Languages Enum\n\t            Languages.EN, Languages.RU etc\n\t        - type : a type object\n\t            Item.MATERIALS, Item.PLAYERCARDS, Item.CHARACTERS etc\n", "        \"\"\"\n\t        if not isinstance(language, Language):\n\t            raise InvalidLanguage\n\t        response = self.__fetch(language, routes.SEARCH, False)\n\t        if response is not None:\n\t            all_items = [\n\t                SearchItem(\n\t                    **{\n\t                        **d,\n\t                        **{\"id\": d[\"url\"].split(\"/\")[1]},\n", "                        \"iconPath\": routes.IMAGE_ROUTE.format(assetId=d[\"iconPath\"]),\n\t                    }\n\t                )\n\t                for d in response\n\t            ]\n\t            if item_type is not None:\n\t                return list(filter(lambda x: x.type == item_type, all_items))\n\t            return all_items\n\t        else:\n\t            raise EmptyResponse\n", "    # TODO: fix this: what if searchitem was result of a search with different language\n\t    # thatn the language passed to this function. maybe language can be a part of\n\t    # the class itself. and fetch would simply use that language.\n\t    # also jsut to prevent backend changing language in the middle of a function with\n\t    # multi api calls. data structures involved in these cross api calls should also\n\t    # have the language attribute as part of them. (stuff liek SearchItem)\n\t    # or maybe even models?\n\t    def resolve_lightcone(\n\t        self, search_item: SearchItem, \n\t        language: Language = Language.EN\n", "        ) -> Lightcone:\n\t        \"\"\"get details of a light cone\n\t        Args:\n\t            item (SearchItem): SearchItem of Lightcone type.\n\t            language (Languages, optional):  Defaults to Languages.EN.\n\t        Raises:\n\t            InvalidItemType: if SearchItem is not of Lightcone Type\n\t            InvalidSearchItem: if item is not a SearchItem\n\t        Returns:\n\t            Lightcone: Lightcone object\n", "        \"\"\"\n\t        from hsr_client.backend.srs_backend.parsers.lightcone import parse_lightcone\n\t        if isinstance(search_item, SearchItem):\n\t            if search_item.type != Item.LIGHTCONE:\n\t                raise InvalidSearchItem(\n\t                    \"Expected Type.LIGHTCONES, found: \" + str(search_item.type)\n\t                )\n\t            response = self.__fetch(language, routes.LIGHTCONES, True, search_item.id)\n\t            if response is not None:\n\t                return parse_lightcone(response, self)\n", "            else:\n\t                raise EmptyResponse\n\t        else:\n\t            raise TypeError(\"provided argument is not a `SearchItem`\")\n\t    def resolve_character(\n\t        self, search_item: SearchItem, \n\t        language: Language = Language.EN\n\t        ) :\n\t        # unimplemented\n\t        pass\n", "    def get_lightcone_by_name(\n\t        self, name: str,\n\t        language: Language = Language.EN\n\t        ) -> Lightcone:\n\t        \"\"\"Gets lightcone by name\n\t        Args:\n\t            name (str): name of the lightcone\n\t            language (Languages, optional): Defaults to Languages.EN.\n\t        Returns:\n\t            Lightcone:\n", "        \"\"\"\n\t        lightcones = self.search_item(Item.LIGHTCONE)\n\t        for lightcone in lightcones:\n\t            # use check to filter search item\n\t            item = check(lightcone, \"name\", name)\n\t            if item is not None:\n\t                return self.resolve_lightcone(item)\n\t        '''\n\t        Function with declared type of \"Lightcone\" must return value on all code paths\n\t        Type \"None\" cannot be assigned to type \"Lightcone\"\n", "        '''\n\t        #TODO: fix this typing issue \n\t        raise EmptyResponse\n\t    def get_character_by_name(\n\t        self, name: str, \n\t        language: Language = Language.EN\n\t        ) -> Character:\n\t        \"\"\"Gets lightcone by name\n\t        Args:\n\t            name (str): name of the lightcone\n", "            language (Language, optional): Defaults to Language.EN.\n\t        Returns:\n\t            Character:\n\t        \"\"\"\n\t        with open(\"tests/data/character.json\") as f:\n\t            character_raw = json.load(f)\n\t        from .parsers.character import parse_character\n\t        character = parse_character(character_raw, self)\n\t        return character\n\t    def resolve_material(\n", "            self, search_item : SearchItem,\n\t            language : Language = Language.EN\n\t        ) -> Material:\n\t        \"\"\"get details of a Material\n\t        Args:\n\t            item (SearchItem): SearchItem of Material type.\n\t            language (Languages, optional):  Defaults to Languages.EN.\n\t        Raises:\n\t            InvalidItemType: if SearchItem is not of Material Type\n\t            InvalidSearchItem: if item is not a SearchItem\n", "        Returns:\n\t            Material : Material object\n\t        \"\"\"\n\t        if isinstance(search_item, SearchItem):\n\t            if search_item.type != Item.MATERIAL:\n\t                raise InvalidSearchItem(\n\t                    \"Expected Item.MATERIAL, found: \" + str(search_item.type)\n\t                )\n\t            response = self.__fetch(language, routes.MATERIALS, True, search_item.id)\n\t            if response is not None:\n", "                return parse_material(response, self)\n\t            else:\n\t                raise EmptyResponse\n\t        else:\n\t            raise TypeError(\"provided argument is not a `SearchItem`\")\n"]}
{"filename": "hsr_client/backend/srs_backend/parsers/lightcone.py", "chunked_list": ["from hsr_client.datamodels.lightcone import MaterialCount, Lightcone\n\tfrom hsr_client.datamodels.material import Material\n\tfrom hsr_client.datamodels.searchItem import SearchItem\n\tfrom hsr_client.constants import Item\n\tfrom hsr_client.paths import Path\n\tfrom hsr_client.constants import MaterialTypes\n\tfrom hsr_client.backend.srs_backend import SRSBackend\n\tfrom bs4 import BeautifulSoup\n\tdef parse_lightcone(raw_data, be: SRSBackend) -> Lightcone:\n\t    # name\n", "    lc_name = raw_data[\"name\"]\n\t    # rarity\n\t    lc_rarity = raw_data[\"rarity\"]\n\t    # description\n\t    lc_description = BeautifulSoup(raw_data[\"descHash\"], features=\"lxml\").get_text()\n\t    # path\n\t    lc_path = None\n\t    raw_path = raw_data[\"baseType\"][\"name\"]\n\t    if raw_path == \"The Hunt\":\n\t        lc_path = Path.HUNT\n", "    elif raw_path == \"Harmony\":\n\t        lc_path = Path.HARMONY\n\t    elif raw_path == \"Destruction\":\n\t        lc_path = Path.DESTRUCTION\n\t    elif raw_path == \"Erudition\":\n\t        lc_path = Path.ERUDITION\n\t    elif raw_path == \"Nihility\":\n\t        lc_path = Path.NIHILITY\n\t    elif raw_path == \"Preservation\":\n\t        lc_path = Path.PRESERVATION\n", "    elif raw_path == \"Abundance\":\n\t        lc_path = Path.ABUNDANCE\n\t    else:\n\t        raise Exception(f\"failed to parse lightcone, raw_path unknown: ${raw_path}\")\n\t    # ability\n\t    lc_ability = {}\n\t    ability_desc_template = BeautifulSoup(\n\t        raw_data[\"skill\"][\"descHash\"], features=\"lxml\"\n\t    ).get_text()\n\t    simp_template_params = map(lambda si: si[\"params\"], raw_data[\"skill\"][\"levelData\"])\n", "    for simp_no, template_params_per_simp in enumerate(simp_template_params, start=1):\n\t        ability_desc = ability_desc_template\n\t        for slot_no, template_param in enumerate(template_params_per_simp, start=1):\n\t            replace_text = f\"#{slot_no}[i]\"\n\t            # print(\"replacing: \" + replace_text + \" with \" + str(template_param) + \" in \" + ability_desc)\n\t            ability_desc = ability_desc.replace(replace_text, str(template_param))\n\t        lc_ability[simp_no] = ability_desc\n\t    # ascension mats\n\t    ascension_mats = []\n\t    for lvl in raw_data['levelData']:\n", "        __lvl = lvl['maxLevel']\n\t        __mtrls = list()\n\t        if 'cost' in lvl:\n\t            for mtrl in lvl['cost']:\n\t                '''\n\t                create an dummy SearchItem just for fetching with ID param and Type            \n\t                '''\n\t                __mtrlobj = be.resolve_material(SearchItem(id=int(mtrl['id']), type=Item.MATERIAL, url='', iconPath='', rarity=0, name=''))\n\t                __mtrls.append(MaterialCount(material=__mtrlobj, count=mtrl['count']))\n\t        ascension_mats.append((__lvl, __mtrls))\n", "    # prepare actual lightcone.\n\t    lightcone = Lightcone(\n\t        name=lc_name,\n\t        rarity=lc_rarity,\n\t        description=lc_description,\n\t        path=lc_path,\n\t        ability=lc_ability,\n\t        ascension_mats=dict(ascension_mats),\n\t    )\n\t    # _stats (has to be done after object creation)\n", "    setattr(lightcone, \"_stats\", raw_data[\"levelData\"])\n\t    return lightcone\n"]}
{"filename": "hsr_client/backend/srs_backend/parsers/character.py", "chunked_list": ["from typing import Dict\n\tfrom hsr_client.backend.srs_backend import SRSBackend\n\tfrom hsr_client.backend.srs_backend.parsers.eidolon import parse_eidolon\n\tfrom hsr_client.backend.srs_backend.parsers.material import parse_material\n\tfrom hsr_client.backend.srs_backend.parsers.trace import parse_non_skill_traces\n\tfrom hsr_client.datamodels.chara import Character\n\tfrom hsr_client.datamodels.element import Element\n\tfrom hsr_client.datamodels.lightcone import MaterialCount, Lightcone\n\tfrom hsr_client.datamodels.material import Material\n\tfrom hsr_client.paths import Path\n", "from bs4 import BeautifulSoup\n\tdef parse_character(character_raw, srs_be: SRSBackend) -> Character:\n\t    # name\n\t    c_name = character_raw[\"name\"]\n\t    # rarity\n\t    c_rarity = character_raw[\"rarity\"]\n\t    # description\n\t    c_description = BeautifulSoup(character_raw[\"descHash\"], features=\"lxml\").get_text()\n\t    # element\n\t    c_element = None\n", "    raw_element = character_raw[\"damageType\"][\"name\"]\n\t    if raw_element == \"Ice\":\n\t        c_element = Element.ICE\n\t    else:\n\t        raise Exception(f\"failed to parse lightcone, raw_path unknown: ${raw_path}\")\n\t    # path\n\t    c_path = None\n\t    raw_path = character_raw[\"baseType\"][\"name\"]\n\t    if raw_path == \"The Hunt\":\n\t        c_path = Path.HUNT\n", "    elif raw_path == \"Harmony\":\n\t        c_path = Path.HARMONY\n\t    elif raw_path == \"Destruction\":\n\t        c_path = Path.DESTRUCTION\n\t    elif raw_path == \"Erudition\":\n\t        c_path = Path.ERUDITION\n\t    elif raw_path == \"Nihility\":\n\t        c_path = Path.NIHILITY\n\t    elif raw_path == \"Preservation\":\n\t        c_path = Path.PRESERVATION\n", "    elif raw_path == \"Abundance\":\n\t        c_path = Path.ABUNDANCE\n\t    else:\n\t        raise Exception(f\"failed to parse lightcone, raw_path unknown: ${raw_path}\")\n\t    # eidolons\n\t    c_eidolons = []\n\t    # resonance aka rank. aka eidolon number\n\t    for resonance_data in character_raw[\"ranks\"]:\n\t        c_eidolons.append(parse_eidolon(resonance_data))\n\t    # traces.\n", "    c_traces = []\n\t    parse_non_skill_traces(character_raw['skillTreePoints'], c_traces)\n\t    # ascension_mats\n\t    # ascension_mats={\n\t    #     20: [\n\t    #         MaterialCount(\n\t    #             material=Material(name=\"foo1\", description=\"bar1\"), count=1\n\t    #         ),\n\t    #         MaterialCount(\n\t    #             material=Material(name=\"foo2\", description=\"bar2\"), count=2\n", "    #         ),\n\t    #     ],\n\t    #     30: [\n\t    #         MaterialCount(\n\t    #             material=Material(name=\"foo3\", description=\"bar3\"), count=3\n\t    #         ),\n\t    #     ],\n\t    # },\n\t    character = Character(\n\t        name=c_name,\n", "        rarity=c_rarity,\n\t        description=c_description,\n\t        path=c_path,\n\t        eidolons=c_eidolons,\n\t        traces=c_traces,\n\t        element=c_element,\n\t    )\n\t    # _stats (has to be done after object creation)\n\t    setattr(character, \"_chara_levelData\", character_raw[\"levelData\"])\n\t    setattr(character, '_chara_skills', character_raw['skills'])\n", "    setattr(character, '_backend', srs_be)\n\t    return character"]}
{"filename": "hsr_client/backend/srs_backend/parsers/trace.py", "chunked_list": ["from typing import List\n\tfrom bs4 import BeautifulSoup\n\tfrom hsr_client.backend.srs_backend import SRSBackend\n\timport hsr_client.datamodels as models\n\tfrom hsr_client.datamodels.material import MaterialCount\n\tfrom  hsr_client.datamodels import trace\n\tfrom hsr_client.errors import BackendError\n\tdef additional_info(trace_node):\n\t    container =  trace_node.get(\"embedBuff\") or trace_node.get(\"embedBonusSkill\")\n\t    if container is None:\n", "        # TODO: log this, this might hint that the backend response structure has changed.\n\t        raise ValueError(\"trace data doesn't have a additional info, TODO: fix this error message\")\n\t    return container\n\tdef parse_non_skill_traces(trace_nodes, traces=[], parent=None) -> List[trace.Trace]:\n\t    for trace_node in trace_nodes:\n\t        info = additional_info(trace_node)\n\t        # extract name\n\t        name = info[\"name\"]\n\t        # prepare description\n\t        t_description =  info.get(\"descHash\")\n", "        if t_description is not None:\n\t            t_description = BeautifulSoup(t_description, features='lxml').get_text()\n\t            template_params = info['levelData'][0]['params']\n\t            for slot_no, template_param in enumerate(template_params, start=1):\n\t                replace_text = f\"#{slot_no}[i]\"\n\t                t_description = t_description.replace(replace_text, str(template_param))\n\t        else:\n\t            desc_name = BeautifulSoup(info['statusList'][0][\"key\"], features='lxml').get_text()\n\t            desc_value = str(info['statusList'][0][\"value\"] * 100)\n\t            t_description = f\"{desc_name}: {desc_value}\"\n", "        # prepare unlock preprequisite\n\t        unlock_prerequisite = trace.UnlockPrerequisite(\n\t                trace=parent,\n\t                level=info[\"levelReq\"],\n\t                ascension=additional_info(trace_node)[\"promotionReq\"]\n\t        )\n\t        # prepare tht trace itself.\n\t        if trace_node[\"type\"] == 1:\n\t            _trace = trace.BonusAbility(\n\t                name=name,\n", "                description=t_description,\n\t                activation_mats=[],\n\t                unlock_prerequisite=unlock_prerequisite\n\t            )\n\t        elif trace_node[\"type\"] == 2:\n\t            _trace = trace.StatBonus(\n\t                name=name,\n\t                description=t_description,\n\t                activation_mats=[],\n\t                unlock_prerequisite=unlock_prerequisite\n", "            )\n\t        else:\n\t            raise BackendError(\"Invalid trace type(int) found: \", trace_node[\"type\"])\n\t        traces.append(_trace)\n\t        # parse child traces\n\t        children = trace_node.get(\"children\")\n\t        if children is not None or children != []:\n\t            parse_non_skill_traces(children, traces, parent=_trace)\n\t    return []\n\t# def parse_skill_traces(raw_skills, srs_be: SRSBackend):\n", "#     for raw_skill in raw_skills:\n\t#         # name\n\t#         skill_name = raw_skill['name']\n\t#         # scaling: LevelScaling\n\t#         desc_template = BeautifulSoup(\n\t#             raw_skills[\"descHash\"], features=\"lxml\"\n\t#         ).get_text()\n\t#         template_params_all_levels = map(\n\t#             lambda d: d['params'],\n\t#             raw_skills[\"levelData\"]\n", "#         )\n\t#         for level, level_data in raw_skills['levelData']:\n\t#             template_params = level_data['params']\n\t#             skill_desc = desc_template\n\t#             for slot_no, template_param in enumerate(template_params, start=1):\n\t#                 replace_text = f\"#{slot_no}[i]\"\n\t#                 # print(\"replacing: \" + replace_text + \" with \" + str(template_param) + \" in \" + ability_desc)\n\t#                 skill_desc = skill_desc.replace(replace_text, str(template_param))\n\t#             raw_matcounts =level_data['cost']\n\t#             ascension_mats_per_level = []\n", "#             for raw_matcount in raw_matcounts:\n\t#                 mat_id = raw_matcount['id']\n\t#                 from hsr_client.backend.srs_backend.parsers.material import parse_material\n\t#                 mat = parse_material(mat_id, srs_be)\n\t#                 mat_count = raw_matcount['count']\n\t#                 ascension_mats_per_level.append(\n\t#                     MaterialCount(\n\t#                     material=mat,\n\t#                     count = mat_count,\n\t#                     )\n", "#                 )\n\t# def parse_traces(raw_character_data, srs_be: SRSBackend)  -> List[models.trace.Trace]:\n\t#     non_skill_traces = []\n\t#     parse_non_skill_traces(raw_character_data['skillTreePoints'], non_skill_traces)\n\t#     skill_traces = parse_skill_traces(raw_character_data['skills'])\n\t#     return [*non_skill_traces, *skill_traces]"]}
{"filename": "hsr_client/backend/srs_backend/parsers/material.py", "chunked_list": ["from bs4 import BeautifulSoup\n\tfrom ....constants import MaterialTypes\n\tfrom hsr_client.datamodels.material import Material\n\tdef parse_material(raw_data, be) -> Material:\n\t    print(raw_data)\n\t    mtrl_name = raw_data['embeddedItem']['name']\n\t    mtrl_desc = BeautifulSoup(raw_data['embeddedItem']['desc'], features='lxml').get_text()\n\t    mtrl_lore = BeautifulSoup(raw_data['embeddedItem']['lore'], features='lxml').get_text()\n\t    mrtl_source= raw_data['embeddedItem']['comeFrom']\n\t    mtrl_type = MaterialTypes(raw_data['embeddedItem']['purposeId'])\n", "    mtrl_rarity = raw_data['embeddedItem']['rarity']\n\t    # TODO: create the actual material with ID.\n\t    # actually , can just move backend fetch this out of here and put it in srs_backend\n\t    # just let this function parse materail nothing else.\n\t    material = Material(\n\t        name=mtrl_name,\n\t        rarity=mtrl_rarity,\n\t        description=mtrl_desc,\n\t        lore = mtrl_lore,\n\t        type=mtrl_type,\n", "        source=mrtl_source\n\t    )\n\t    return material\n"]}
{"filename": "hsr_client/backend/srs_backend/parsers/eidolon.py", "chunked_list": ["from hsr_client.datamodels.chara import Character\n\tfrom hsr_client.datamodels.eidolon import Eidolon\n\tfrom bs4 import BeautifulSoup\n\tdef parse_eidolon(raw_data) -> Character:\n\t    # name\n\t    e_name = raw_data[\"name\"]\n\t    # resonance\n\t    e_resonance = raw_data[\"id\"]\n\t    # description\n\t    description_template = BeautifulSoup(\n", "        raw_data[\"descHash\"], features=\"lxml\"\n\t    ).get_text()\n\t    template_params = raw_data[\"params\"]\n\t    for slot_no, template_param in enumerate(template_params, start=1):\n\t        replace_text = f\"#{slot_no}[i]\"\n\t        description_template = description_template.replace(replace_text, str(template_param))\n\t    e_description = description_template\n\t    eidolon = Eidolon(\n\t        name=e_name,\n\t        resonance=e_resonance,\n", "        description=e_description\n\t    )\n\t    return eidolon\n"]}
{"filename": "hsr_client/backend/hoyo_backend/__init__.py", "chunked_list": ["from typing import List, Union\n\tfrom hsr_client.datamodels.searchItem import SearchItem\n\tfrom hsr_client.errors import  InvalidLanguage\n\tfrom ..util import Backend\n\timport hsr_client.datamodels as models\n\tfrom .constants import Item\n\tfrom .routes import *\n\tfrom .parsers import searchItem\n\tclass HoyoBackend(Backend):\n\t    def __init__(self) -> None:\n", "        super().__init__()\n\t        self.custom_headers =  {\"x-rpc-language\": \"en-us\",\n\t                                \"x-rpc-wiki_app\": \"hsr\",\n\t                                \"Origin\": \"https://wiki.hoyolab.com\",    \n\t                                \"Referer\": \"https://wiki.hoyolab.com/\"}\n\t    def __get_response(self, method: str, route, **params) -> None | dict | list[dict]:  \n\t        \"\"\"Fetches response data from the api route\n\t        Args:\n\t            method (str): GET, POST\n\t            route (str): api route\n", "            params (kwargs) : request payload \n\t        Returns:\n\t            None | dict | list[dict]: returns the response\n\t        \"\"\"        \n\t        self.session.headers.update(self.custom_headers)\n\t        payload = {'json' : params} if method == 'POST' else {'params': params}\n\t        response = self.session.request(method, route,force_refresh=True, **payload)   \n\t        if response.status_code < 300:\n\t            data = response.json()\n\t            if data['message'] == 'OK' and data['retcode'] == 0:\n", "                return data['data'].get('list', data['data'].get('entries', data['data'].get('page', None)))\n\t    def __entries(self, item : Item, **params) -> list[SearchItem]:\n\t        \"\"\"gets all entries from api route of given type\n\t        Args:\n\t            item (Item): Item enum. Item.CHARACTERS, Item.MATERIALS\n\t            ---\n\t            allowed kwargs\n\t            ---\n\t            page_num : int [1..... 99]\n\t            page_size : int [number of items in one page]\n", "        Returns:\n\t            list[SearchItem]: returns a list of SearchItem\n\t        \"\"\"       \n\t        params.update({'use_es': True})\n\t        response = self.__get_response('POST', ENTRY_LIST, filters=[], menu_id=item, **params)\n\t        if response is not None:            \n\t            return [SearchItem(**searchItem.make_model_compatible(item, item)) for item in response]\n\t    def __entry_detail(self, item : Union[SearchItem, int]) -> dict:\n\t        \"\"\"gets the detail of a search item\n\t        item passed should be either a SearchItem, or the id of the entry\n", "        Args:\n\t            item (SearchItem, int): SearchItem [from __entries] or ID of the entry.\n\t        Returns:\n\t            dict: returns the data fetched\n\t        \"\"\"        \n\t        entry_page_id = item\n\t        if isinstance(entry_page_id, SearchItem):\n\t            entry_page_id = entry_page_id.id\n\t        response = self.__get_response('GET', ENTRY_PAGE, entry_page_id=entry_page_id)\n\t        if response is not None:            \n", "            return response # type: ignore\n\t    def get_trace_description(self) -> str:\n\t        \"\"\"if you'd like to get the trace's description later.\"\"\"\n\t        pass"]}
{"filename": "hsr_client/backend/hoyo_backend/constants.py", "chunked_list": ["from enum import Enum, IntEnum\n\tclass Item(IntEnum):\n\t    '''\n\t    HoYoLab Wiki Entries\n\t    Item | Codes\n\t    - PATHS : 102\n\t    - CHARACTERS : 104\n\t    - NPCS : 105\n\t    - LIGHTCONES : 107\n\t    - RELICS : 108\n", "    - MATERIALS : 110\n\t    - MUSIC_DISKS : 117\n\t    - ENEMIES : 112\n\t    '''\n\t    PATHS = 102\n\t    CHARACTERS = 104\n\t    NPCS = 105\n\t    LIGHTCONES = 107\n\t    RELICS = 108\n\t    MATERIALS = 110\n", "    MUSIC_DISKS = 117\n\t    ENEMIES = 112\n\t    def __str__(self) -> str:\n\t        return str(self.value)"]}
{"filename": "hsr_client/backend/hoyo_backend/routes.py", "chunked_list": ["'''\n\tHoYoLab Wiki routes\n\t'''\n\tENTRY_LIST = 'https://sg-wiki-api.hoyolab.com/hoyowiki/hsr/wapi/get_entry_page_list'\n\tENTRY_URL_ROUTE = 'https://wiki.hoyolab.com/pc/hsr/entry/{entry_id}'\n\tENTRY_PAGE = 'https://sg-wiki-api.hoyolab.com/hoyowiki/hsr/wapi/entry_page'\n"]}
{"filename": "hsr_client/backend/hoyo_backend/parsers/searchItem.py", "chunked_list": ["from ..constants import Item\n\tfrom ..routes import ENTRY_URL_ROUTE\n\tdef make_model_compatible(raw_data : dict, item: Item):\n\t    __compatibledict = {\n\t    }\n\t    __compatibledict['url'] = ENTRY_URL_ROUTE.format(entry_id = raw_data.get('entry_page_id', 0))\n\t    __compatibledict['name'] = raw_data['name']\n\t    __compatibledict['iconPath'] = raw_data['icon_url']\n\t    __compatibledict['id'] = raw_data['entry_page_id']\n\t    __compatibledict['type'] = int(item)\n", "    exclude = {'name', 'icon_url', 'id'}\n\t    ## add extra keys for filtering \n\t    extra_keys = list(set(raw_data['filter_values'].keys()) - exclude)\n\t    for k in extra_keys:\n\t        if 'values' in raw_data['filter_values'][k]:             \n\t            if 'rarity' in k:\n\t                __compatibledict['rarity'] = int(raw_data['filter_values'][k]['values'][0][0])\n\t            else:                \n\t                __compatibledict[k] = raw_data['filter_values'][k]['values'][0] \n\t    return __compatibledict\n"]}
{"filename": "hsr_client/datamodels/lightcone.py", "chunked_list": ["from typing import Dict, List, NewType, Tuple, Iterable\n\tfrom pydantic import BaseModel, PrivateAttr\n\tfrom hsr_client.datamodels.material import Material, MaterialCount\n\tfrom hsr_client.errors import BackendError\n\tfrom hsr_client.hsr_types import  Superimposition, Level\n\tfrom hsr_client.paths import Path\n\tclass Stats(BaseModel):\n\t    \"\"\"\n\t    Lightcone's base stats\n\t    \"\"\"\n", "    ATK: int\n\t    \"\"\"Lightcone base ATK\"\"\"\n\t    HP: int\n\t    \"\"\"Lightcone base HP\"\"\"\n\t    DEF: int\n\t    \"\"\"Lightcone DEF\"\"\"\n\tclass Lightcone(BaseModel):\n\t    \"\"\"\n\t    Model to represent a Lightcone\n\t    Attributes:\n", "        - name: name of the lightcone\n\t        - description: description of the lightcone\n\t        - path: Path association of the Lightcone\n\t        - ability: lightcone ability description for given superimposition (int)\n\t        - ascension_mats: ascension materials required to level up beyond given `Level` (int)\n\t    \"\"\"\n\t    name: str\n\t    \"name of the lightcone\"\n\t    rarity: int\n\t    \"\"\"rarity of the lightcone\"\"\"\n", "    description: str\n\t    \"\"\"short description of the lightcone\"\"\"\n\t    path: Path\n\t    \"\"\"Path association of the lightcone\"\"\"\n\t    # directly using starrail station's `levelData` structure here. since `Stats`\n\t    # going to be accessed only via a function anyway.\n\t    # offering it via an instance variable like `stats` would be unncessarily big\n\t    # listing. of `Stats` for level 1 through 80\n\t    # offering a function instead will also feature proof the model\n\t    # since no public attribute is exposed now, that will change later.\n", "    # only downside I can think of is, if the user wants to save the \n\t    # model via json() etc., the stats wont be a part of it.\n\t    # but i feel limitation is better than making breaking change.\n\t    _stats = PrivateAttr()\n\t    # # lightcone stats scaling by `Level` (int)\n\t    # stats: Dict[Level, Stats]\n\t    ability: Dict[Superimposition, str]\n\t    \"\"\"lightcone ability description for given `Superimposition (int)`\"\"\"\n\t    # ascension materials required to level up beyond given `Level` (int)\n\t    ascension_mats: Dict[Level, List[MaterialCount]]\n", "    \"\"\"ascension mats required to level up beyond the given `Level (int)` \"\"\"\n\t    def stats(self, level: Level, ascended=False) -> Stats:\n\t        \"\"\"\n\t        Get Ligthcone's Stats for the given level. when ascended=True is used\n\t        on levels where ascension is possible, gives `Stats` for ascended levels\n\t        instead.\n\t        \"\"\"\n\t        if level < 1 or level > 80:\n\t            raise ValueError(\" 1 <= level <= 80 criteria not satisfied.\")\n\t        for ascension_entry in self._stats:\n", "            if level <= ascension_entry[\"maxLevel\"]:\n\t                if ascension_entry[\"maxLevel\"] == level and ascended == True:\n\t                    continue\n\t                return Stats(\n\t                    ATK=ascension_entry[\"attackBase\"] + ascension_entry[\"attackAdd\"] * (level - 1),\n\t                    HP=ascension_entry[\"hpBase\"] + ascension_entry[\"hpAdd\"] * (level - 1),\n\t                    DEF=ascension_entry[\"defenseBase\"] + ascension_entry[\"defenseAdd\"] * (level - 1),\n\t                )\n\t        raise BackendError(\"levelData for Stats appears to be emtpy, this most\"\n\t                           \"likely hints Library out of date with backend sources\"\n", "                           \"please report this bug.\")\n\tif __name__ == \"__main__\":\n\t    lightcone = Lightcone(\n\t        name=\"light cone\",\n\t        rarity=4,\n\t        description=\"this is a light cone , and this is its history\",\n\t        path = Path.HARMONY,\n\t        ability={\n\t            1: \"at superimposition level damage bonus is 30%\"\n\t        },\n", "        ascension_mats={\n\t        20: [\n\t            MaterialCount(material=Material(name=\"foo1\", description=\"bar1\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=1),\n\t            MaterialCount(material=Material(name=\"foo2\", description=\"bar2\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=2),\n\t        ],\n\t        30: [\n\t            MaterialCount(material=Material(name=\"foo3\", description=\"bar3\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=3),\n\t        ]\n\t    })\n\t    import json\n", "    setattr(lightcone, \"_stats\", json.loads(\"\"\"\n\t    [\n\t    {\n\t        \"promotion\": 0,\n\t        \"maxLevel\": 20,\n\t        \"cost\": [\n\t            {\n\t                \"id\": 29328,\n\t                \"count\": 3000\n\t            },\n", "            {\n\t                \"id\": 549437,\n\t                \"count\": 4\n\t            }\n\t        ],\n\t        \"attackBase\": 14.4,\n\t        \"attackAdd\": 2.16,\n\t        \"hpBase\": 38.4,\n\t        \"hpAdd\": 5.76,\n\t        \"defenseBase\": 12,\n", "        \"defenseAdd\": 1.8\n\t    },\n\t    {\n\t        \"promotion\": 1,\n\t        \"maxLevel\": 30,\n\t        \"cost\": [\n\t            {\n\t                \"id\": 29328,\n\t                \"count\": 6000\n\t            },\n", "            {\n\t                \"id\": 635674,\n\t                \"count\": 2\n\t            },\n\t            {\n\t                \"id\": 549437,\n\t                \"count\": 8\n\t            }\n\t        ],\n\t        \"attackBase\": 31.68,\n", "        \"attackAdd\": 2.16,\n\t        \"hpBase\": 84.48,\n\t        \"hpAdd\": 5.76,\n\t        \"defenseBase\": 26.4,\n\t        \"defenseAdd\": 1.8\n\t    },\n\t    {\n\t        \"promotion\": 2,\n\t        \"maxLevel\": 40,\n\t        \"cost\": [\n", "            {\n\t                \"id\": 29328,\n\t                \"count\": 12000\n\t            },\n\t            {\n\t                \"id\": 920201,\n\t                \"count\": 2\n\t            },\n\t            {\n\t                \"id\": 633378,\n", "                \"count\": 4\n\t            }\n\t        ],\n\t        \"attackBase\": 54.72,\n\t        \"attackAdd\": 2.16,\n\t        \"hpBase\": 145.92,\n\t        \"hpAdd\": 5.76,\n\t        \"defenseBase\": 45.6,\n\t        \"defenseAdd\": 1.8\n\t    },\n", "    {\n\t        \"promotion\": 3,\n\t        \"maxLevel\": 50,\n\t        \"cost\": [\n\t            {\n\t                \"id\": 29328,\n\t                \"count\": 30000\n\t            },\n\t            {\n\t                \"id\": 920201,\n", "                \"count\": 4\n\t            },\n\t            {\n\t                \"id\": 633378,\n\t                \"count\": 6\n\t            }\n\t        ],\n\t        \"attackBase\": 77.76,\n\t        \"attackAdd\": 2.16,\n\t        \"hpBase\": 207.36,\n", "        \"hpAdd\": 5.76,\n\t        \"defenseBase\": 64.8,\n\t        \"defenseAdd\": 1.8\n\t    },\n\t    {\n\t        \"promotion\": 4,\n\t        \"maxLevel\": 60,\n\t        \"cost\": [\n\t            {\n\t                \"id\": 29328,\n", "                \"count\": 60000\n\t            },\n\t            {\n\t                \"id\": 836260,\n\t                \"count\": 3\n\t            },\n\t            {\n\t                \"id\": 717319,\n\t                \"count\": 3\n\t            }\n", "        ],\n\t        \"attackBase\": 100.8,\n\t        \"attackAdd\": 2.16,\n\t        \"hpBase\": 268.8,\n\t        \"hpAdd\": 5.76,\n\t        \"defenseBase\": 84,\n\t        \"defenseAdd\": 1.8\n\t    },\n\t    {\n\t        \"promotion\": 5,\n", "        \"maxLevel\": 70,\n\t        \"cost\": [\n\t            {\n\t                \"id\": 29328,\n\t                \"count\": 120000\n\t            },\n\t            {\n\t                \"id\": 836260,\n\t                \"count\": 6\n\t            },\n", "            {\n\t                \"id\": 717319,\n\t                \"count\": 5\n\t            }\n\t        ],\n\t        \"attackBase\": 123.84,\n\t        \"attackAdd\": 2.16,\n\t        \"hpBase\": 330.24,\n\t        \"hpAdd\": 5.76,\n\t        \"defenseBase\": 103.2,\n", "        \"defenseAdd\": 1.8\n\t    },\n\t    {\n\t        \"promotion\": 6,\n\t        \"maxLevel\": 80,\n\t        \"cost\": [],\n\t        \"attackBase\": 146.88,\n\t        \"attackAdd\": 2.16,\n\t        \"hpBase\": 391.68,\n\t        \"hpAdd\": 5.76,\n", "        \"defenseBase\": 122.4,\n\t        \"defenseAdd\": 1.8\n\t    }\n\t]\n\t    \"\"\"))\n\t    lvl_20_ascension_mats = lightcone.ascension_mats[20] # TODO: this doesn't read well. what does ascension_mats[20] mean, unless u look at the type.\n\t    print(lightcone.stats(20, ascended=True))\n"]}
{"filename": "hsr_client/datamodels/element.py", "chunked_list": ["from typing import Optional, Union, List, NewType\n\tfrom enum import Enum\n\tclass Element(Enum):\n\t    QUANTUM = \"Using Quantum attacks to inflict Weakness Break will deal Quantum DMG and cause Entanglement, delaying the enemy's action and dealing Additional Quantum DMG to the affected enemy at the start of the next turn. When the enemy is hit, this extra DMG will increase.\"\n\t    PHYSICAL = \"Using Physical attacks to trigger Weakness Break will deal Physical DMG and apply Bleed effect, dealing Physical DoT.\"\n\t    FIRE = \"Using Fire attacks to trigger Weakness Break will deal Fire DMG and apply the Burn effect, dealing Fire DoT.\"\n\t    ICE = \"Using Ice Aattacks to trigger Weakness Break will deal Ice DMG and Freeze the target, immobilizing the enmy and dealing Additional Ice DMG.\"\n\t    LIGHTNING = \"Using Lightning attacks to trigger Weakness Break will deal Lightning DMG and apply the Shock effect, dealing Lightning DoT.\"\n\t    WIND = \"Using Wind attacks to trigger Weakness Break will deal Wind DMG and apply the Wind Shear effect, dealing Wind DoT.\"\n\t    IMAGINARY = \"When using an Imaginary attack to inflict Weakness Break on target enemy, the attack will deal Imaginary DMG and additionaly inflicts Imprisonment. Imprisoned enemies suffer from delayed actions and SPD Reduction.\"\n", "    def describe(self):\n\t        return self.value\n\tif __name__ == \"__main__\":\n\t    elem = Element.WIND\n\t    print(elem.describe())"]}
{"filename": "hsr_client/datamodels/character.py", "chunked_list": ["from pydantic import BaseModel, validator, Field, Extra\n\tfrom typing import Optional\n\tfrom hsr_client.routes import IMAGE_ROUTE, AUDIO_ROUTE\n\tfrom hsr_client.constants import Item, _RelicTypes\n\tfrom hsr_client.datamodels.searchItem import SearchItem\n\tclass DamageType(BaseModel):\n\t    id : int\n\t    iconPath : Optional[str] \n\t    color : Optional[str] \n\t    name : Optional[str]\n", "    rarity: Optional[int] \n\t    @validator('iconPath', pre=True)\n\t    def get_icon_path(cls, v):\n\t        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t        return ''\n\tclass BaseType(BaseModel):\n\t    id : int\n\t    iconPath : Optional[str] \n\t    altIconPath : Optional[str]\n", "    color : Optional[str] \n\t    rarity: Optional[int] \n\t    name : Optional[str]\n\t    @validator('iconPath', pre=True)\n\t    def get_icon_path(cls, v):\n\t        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t        return ''\n\tclass LevelData(BaseModel):\n\t    promotion : int\n", "    max : int  = Field(alias='maxLevel')\n\t    base_atk : float = Field(alias='attackBase')\n\t    add_atk : float = Field(alias='attackAdd')\n\t    base_hp : float = Field(alias='hpBase')\n\t    add_hp : float = Field(alias='hpAdd')\n\t    base_def : float = Field(alias='defenseBase')\n\t    add_def : float = Field(alias='defenseAdd')\n\t    crit_rate : float = Field(alias='crate')\n\t    crit_damage : float = Field(alias='cdmg')\n\t    aggro : int \n", "    base_speed : int = Field(alias='speedBase')\n\t    add_speed : int = Field(alias='speedAdd')\n\t    cost : list[SearchItem]\n\t    @validator('cost', pre=True)\n\t    def get_materials(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                list_.append(SearchItem(**item))\n\t        return list_\n", "class Rank(BaseModel):\n\t    id : int\n\t    iconPath : str\n\t    artPath : str\n\t    description : str = Field(alias='descHash')\n\t    params : list[int]\n\t    @validator('iconPath', pre=True)\n\t    def get_icon_path(cls, v):\n\t        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n", "        return ''\n\t    @validator('artPath', pre=True)\n\t    def get_art_path(cls, v):\n\t        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t        return ''\n\tclass SkillLevel(BaseModel):\n\t    level : int\n\t    params : list[int]\n\t    req_level : int = Field(alias='levelReq')\n", "    req_promotion : int = Field(alias='promotionReq')\n\t    cost : list[SearchItem]\n\t    @validator('cost', pre=True)\n\t    def get_materials(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                list_.append(SearchItem(**item))\n\t        return list_\n\tclass Skill(BaseModel):\n", "    id : int\n\t    name : str\n\t    target: str = Field(alias='tagHash')\n\t    type : str = Field(alias='typeDescHash')\n\t    iconPath : Optional[str]\n\t    req_level : int = Field(alias='levelReq')\n\t    req_promotion : int = Field(alias='promotionReq')\n\t    levels : list[SkillLevel] = Field(alias='levelData')\n\t    @validator('iconPath', pre=True)\n\t    def get_icon_path(cls, v):\n", "        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t    @validator('levels', pre=True)\n\t    def get_skill_levels(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for lvl in v:\n\t                list_.append(SkillLevel(**lvl))\n\t        return v\n\tclass BuffStatus(BaseModel):\n", "    value : float\n\t    key : str\n\tclass Buff(BaseModel):\n\t    id : int\n\t    name: str\n\t    req_level : int = Field(alias='levelReq')\n\t    iconPath : str\n\t    status : list[BuffStatus] = Field(alias='statusList')\n\t    cost: list[SearchItem]\n\t    @validator('status', pre=True)\n", "    def get_buff_status(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                list_.append(BuffStatus(**item))\n\t        return list_\n\t    @validator('cost', pre=True)\n\t    def get_materials(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n", "            for item in v:\n\t                list_.append(SearchItem(**item))\n\t        return list_\n\tclass BonusSkill(BaseModel):\n\t    id : int\n\t    name : str\n\t    description : str = Field(alias='descHash')\n\t    iconPath : str\n\t    req_level : int = Field(alias='levelReq')\n\t    req_promotion : int = Field(alias='promotionReq')\n", "    levels: list[SkillLevel] = Field(alias='levelData')\n\t    @validator('iconPath', pre=True)\n\t    def get_icon_path(cls, v):\n\t        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t    @validator('levels', pre=True)\n\t    def get_skill_levels(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for lvl in v:\n", "                list_.append(SkillLevel(**lvl))\n\t        return v\n\tclass SubSkill(BaseModel):\n\t    id : int\n\t    type : int\n\t    sub_skills : list = Field(alias='children')\n\t    buff : Optional[Buff] = Field(alias='embedBuff')\n\t    cost: Optional[list[SearchItem]]\n\t    bonus_skill : Optional[BonusSkill] = Field(alias='embedBonusSkill')\n\t    @validator(\"sub_skills\", pre=True)\n", "    def get_sub_skills(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                checker = {}                \n\t                checker['has_subskills'] = 'children' in item\n\t                checker['has_buff'] = 'buff' in item or 'embedBuff' in item\n\t                checker['has_bonus'] = 'embedBonusSkill' in item\n\t                list_.append(SubSkill(**{**item, **checker}))\n\t        return list_\n", "    @validator(\"buff\", pre=True)\n\t    def get_buff(cls, v):\n\t        if len(v) != 0:\n\t            return Buff(**v)\n\t        return v\n\t    @validator('cost', pre=True)\n\t    def get_materials(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n", "                list_.append(SearchItem(**item))\n\t        return list_\n\tclass SkillTreePoints(BaseModel):\n\t    id : int\n\t    type : int\n\t    sub_skills : list = Field(alias='children')\n\t    buff : Optional[Buff]\n\t    bonus_skill : Optional[BonusSkill] = Field(alias='embedBonusSkill')\n\t    has_bonus : Optional[bool]\n\t    has_buff : Optional[bool]\n", "    has_subskills : Optional[bool]\n\t    @validator(\"sub_skills\", pre=True)\n\t    def get_sub_skills(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                checker = {}                \n\t                checker['has_subskills'] = 'children' in item\n\t                checker['has_buff'] = 'buff' in item or 'embedBuff' in item\n\t                checker['has_bonus'] = 'embedBonusSkill' in item\n", "                list_.append(SubSkill(**{**item, **checker}))\n\t        return list_\n\t    @validator(\"buff\", pre=True)\n\t    def get_buff(cls, v):  \n\t        if len(v) != 0:\n\t            return Buff(**v)\n\t        return ''\n\t    @validator(\"bonus_skill\", pre=True)\n\t    def get_bonus_skill(cls, v):\n\t        if len(v) != 0:\n", "            return BonusSkill(**v)\n\t        return ''\n\tclass RelicProps(BaseModel):\n\t    type : _RelicTypes = Field(alias='relicTypeHash')\n\t    type_icon : str = Field(alias='relicTypeIcon')\n\t    prop : str = Field(alias='propertyName')    \n\t    prop_icon : str = Field(alias='propertyIconPath')\n\t    @validator('type', pre=True)\n\t    def get_relic_type(cls, v):\n\t        return _RelicTypes(v)\n", "    @validator('type_icon', pre=True)\n\t    def get_relic_type_icon(cls, v):\n\t        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t    @validator('prop_icon', pre=True)\n\t    def get_relic_prop_icon(cls, v):\n\t        if v != \"\":\n\t            return IMAGE_ROUTE.format(assetId=v)\n\tclass RecommendedRelics(BaseModel):\n\t    two_piece : list = Field(alias='twoPcSets')\n", "    four_piece  : list = Field(alias='fourPcSets')\n\t    recommended_props : list[RelicProps] = Field(alias='props')\n\t    @validator(\"recommended_props\", pre=True)\n\t    def get_rec_props(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                list_.append(RelicProps(**item))\n\t        return list_\n\tclass VoiceNote(BaseModel):\n", "    id : int\n\t    title : str\n\t    text : str\n\t    unlock: str = Field(alias='unlockRequirement')\n\t    cn : str = Field(alias='cnUrl')\n\t    en : str = Field(alias='enUrl')\n\t    kr : str = Field(alias='krUrl')\n\t    jp : str = Field(alias='jpUrl')\n\t    @validator('cn', pre=True)\n\t    def get_cn_url(cls, v):\n", "        if v != '':\n\t            return AUDIO_ROUTE.format(assetId=v)\n\t    @validator('jp', pre=True)\n\t    def get_jp_url(cls, v):\n\t        if v != '':\n\t            return AUDIO_ROUTE.format(assetId=v)\n\t    @validator('kr', pre=True)\n\t    def get_kr_url(cls, v):\n\t        if v != '':\n\t            return AUDIO_ROUTE.format(assetId=v)\n", "    @validator('en', pre=True)\n\t    def get_en_url(cls, v):\n\t        if v != '':\n\t            return AUDIO_ROUTE.format(assetId=v)\n\tclass Character(BaseModel):\n\t    name: str\n\t    spRequirement : int\n\t    rarity: int\n\t    description : str = Field(alias='descHash')\n\t    iconPath : Optional[str] \n", "    figPath : Optional[str] \n\t    fgPath : Optional[str] \n\t    bgPath : Optional[str] \n\t    artPath :Optional[str] \n\t    miniIconPath : Optional[str] \n\t    splashIconPath : Optional[str] \n\t    element : DamageType = Field(alias='damageType')\n\t    baseType : BaseType = Field(alias='baseType')\n\t    levels : list[LevelData] = Field(alias='levelData')\n\t    ranks : list[Rank]\n", "    skills : list[Skill]\n\t    skill_points : list[SkillTreePoints] = Field(alias='skillTreePoints')\n\t    relics : RecommendedRelics = Field(alias='relicRecommend')\n\t    voice_lines : list[VoiceNote] = Field(alias='voiceItems')\n\t    class Config:\n\t        extra = Extra.ignore\n\t    @validator('iconPath', pre=True)\n\t    def get_icon_path(cls, v):\n\t        if v != '':\n\t            return IMAGE_ROUTE.format(assetId=v)\n", "        return v\n\t    @validator('figPath', pre=True)\n\t    def get_fig_path(cls, v):\n\t        if v != '':\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t        return v\n\t    @validator('fgPath', pre=True)\n\t    def get_fg_path(cls, v):\n\t        if v != '':\n\t            return IMAGE_ROUTE.format(assetId=v)\n", "        return v\n\t    @validator('bgPath', pre=True)\n\t    def get_bg_path(cls, v):\n\t        if v != '':\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t        return v\n\t    @validator('miniIconPath', pre=True)\n\t    def get_miniIcon_path(cls, v):\n\t        if v != '':\n\t            return IMAGE_ROUTE.format(assetId=v)\n", "        return v\n\t    @validator('splashIconPath', pre=True)\n\t    def get_splashIcon_path(cls, v):\n\t        if v != '':\n\t            return IMAGE_ROUTE.format(assetId=v)\n\t        return v\n\t    @validator('artPath', pre=True)\n\t    def get_art_path(cls, v):\n\t        if v != '':\n\t            return IMAGE_ROUTE.format(assetId=v)\n", "        return v\n\t    @validator('element', pre=True)\n\t    def get_damage_type(cls, v):\n\t        return DamageType(**v)\n\t    @validator('baseType', pre=True)\n\t    def get_base_type(cls, v):\n\t        return BaseType(**v)\n\t    @validator('levels', pre=True)\n\t    def get_levels(cls, v):\n\t        list_ = []\n", "        if len(v) != 0:\n\t            for item in v:\n\t                list_.append(LevelData(**item))\n\t        return list_\n\t    @validator('ranks', pre=True)\n\t    def get_ranks(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                list_.append(Rank(**item))\n", "        return list_\n\t    @validator('skills', pre=True)\n\t    def get_skills(cls ,v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                list_.append(Skill(**item))\n\t        return list_\n\t    @validator('skill_points', pre=True)\n\t    def get_skill_points(cls ,v):\n", "        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t                checker = {}                \n\t                checker['has_subskills'] = 'children' in item\n\t                checker['has_buff'] = 'buff' in item or 'embedBuff' in item\n\t                checker['has_bonus'] = 'embedBonusSkill' in item\n\t                list_.append(SkillTreePoints(**{**item, **checker}))\n\t        return list_\n\t    @validator('relics', pre=True)\n", "    def get_relics(cls, v):\n\t        if len(v) != 0:\n\t            return RecommendedRelics(**v)\n\t        return ''\n\t    @validator('voice_lines', pre=True)\n\t    def get_vl(cls, v):\n\t        list_ = []\n\t        if len(v) != 0:\n\t            for item in v:\n\t               list_.append(VoiceNote(**item))\n", "        return list_\n"]}
{"filename": "hsr_client/datamodels/__init__.py", "chunked_list": ["# from . import chara, trace, material, eidolon"]}
{"filename": "hsr_client/datamodels/trace.py", "chunked_list": ["from typing import Dict, Optional, Union, List, NewType, Tuple\n\tfrom pydantic import BaseModel, validator, Field, Extra, ValidationError\n\tfrom enum import Enum\n\tfrom hsr_client.datamodels.lightcone import MaterialCount\n\tfrom hsr_client.datamodels.material import Material\n\tfrom hsr_client.hsr_types import Level\n\tclass UnlockPrerequisite(BaseModel):\n\t    \"\"\"criteria to satisfy before this trace can be unlocked.\"\"\"\n\t    # character ascension required.\n\t    ascension: Optional[int]\n", "    # character level required\n\t    level: Optional[int]\n\t    # trace to be unlocked before.\n\t    trace: Optional['Trace']\n\tclass BonusAbility(BaseModel):\n\t    # name of the trace.\n\t    name : str\n\t    # description of the trace.\n\t    description: Optional[str]\n\t    # list of materials required to activate the trace.\n", "    activation_mats: List[MaterialCount]\n\t    # criteria to satisfy before this trace can be unlocked.\n\t    unlock_prerequisite: Optional[UnlockPrerequisite]\n\t    # @validator\n\t    # def ensure_level_one(cls, level):\n\t    #     if level is not 1:\n\t    #         raise ValidationError(\"Bonus Ability's level can only be equal to 1\")\n\t# StatBonus = NewType('StatBonus', BonusAbility)\n\tclass StatBonus(BonusAbility):\n\t    pass\n", "class LevelScaling(BaseModel):\n\t    upgrade_mats: List[MaterialCount]\n\t    description: str\n\t# TODO: decide all the parameters\n\tclass Skill(BaseModel):\n\t    \"\"\"Traces possessed by the `Character`\"\"\"\n\t    # name of the trace.\n\t    name : str\n\t    # how the trace scales with level\n\t    scaling: Dict[Level, LevelScaling]\n", "Trace = Union[Skill, StatBonus, BonusAbility]\n\tUnlockPrerequisite.update_forward_refs()\n"]}
{"filename": "hsr_client/datamodels/searchItem.py", "chunked_list": ["from pydantic import BaseModel, validator, Field, Extra\n\tfrom typing import Optional, Union, Literal\n\tfrom hsr_client.routes import IMAGE_ROUTE\n\tfrom hsr_client.constants import Item\n\tfrom hsr_client.backend.hoyo_backend.constants import Item as HoyoItems\n\tclass SearchItem(BaseModel):\n\t    \"\"\"SearchItem\n\t    Attributes:\n\t    url : site url for item\n\t    iconPath : icon url of the  item\n", "    type: type of item - lightcones, materials, characters\n\t    rarity: rarity of the item\n\t    id : ID of the item\n\t    Filters:\n\t        - available_filters()\n\t            to see the attributes you can filter item on\n\t    \"\"\"\n\t    url: Optional[str]\n\t    iconPath: Optional[str]\n\t    type: Union[HoyoItems, Item]\n", "    name: Optional[str]\n\t    rarity: Optional[int]\n\t    id: Union[int, str]\n\t    class Config:\n\t        extra = Extra.allow\n\t    def available_filters(self):\n\t        \"\"\"TODO: add documentation here\"\"\"\n\t        return [f for f in self.__dict__.keys() if f not in [\"url\", \"iconPath\", \"id\"]]\n\t    @validator('type', pre=True)\n\t    def get_correct_type(cls, v):\n", "        if isinstance(v, str):\n\t            v = int(v)        \n\t        if v > 100:\n\t            return HoyoItems(v)\n\t        else:\n\t            return Item(v)\n\t    def __str__(self):\n\t        if self.type > 50:\n\t            return str(\n\t                f\"<{HoyoItems(str(self.type)).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n", "            )\n\t        return str(\n\t            f\"<{Item(self.type).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n\t        )\n\t    def __repr__(self):\n\t        if self.type > 50:\n\t            return str(\n\t                f\"<{HoyoItems(str(self.type)).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n\t            )\n\t        return str(\n", "            f\"<{Item(self.type).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n\t        )\n"]}
{"filename": "hsr_client/datamodels/material.py", "chunked_list": ["from pydantic import BaseModel, PrivateAttr\n\tfrom typing import Optional, Dict, List\n\tfrom ..constants import MaterialTypes\n\t#     MODIFICATION NOTES: obtain will be replaced by source. which can be a type of its own.\n\t#            iconPath is starrail specific. need something more general that fits with hoyolab aswell\n\t#            id has no place as a visible attribute, maybe it can be an internal attribute for reference purpose\n\t#            but the api doesn't flow backwards, most of the time, so need to think if ID is even necessary.\n\t#            Ofcourse it might still be needed, just shouldn't be a part of public api.\n\tclass Material(BaseModel):\n\t    \"\"\"Material Model\n", "    Attributes:\n\t        name: name of the material.\n\t        type: type of material, character exp, playercard, consumable etc.\n\t        rarity: rarity of the material.\n\t        description : description of the material.\n\t        lore : lore of the material, if it has any attached to it.\n\t        obtain: list of locations , route, shops where you can get the material from.\n\t        usage: material consumed or used by equipment or character in ascension, boost or upgrade. {'character': [], 'equipment' : []}\n\t    \"\"\"       \n\t    name : str\n", "    # type: int\n\t    rarity : int\n\t    \"\"\"Rarity of the Material\"\"\"\n\t    description : str\n\t    \"\"\"Description of the Material\"\"\"\n\t    lore : Optional[str]\n\t    \"\"\"Lore/Notes/Comments on the Material\"\"\"      \n\t    # TODO: determine icon stratergy\n\t    # is it image, or url or what?\n\t    type : MaterialTypes\n", "    # This will be a string for now. maybe own type later? \n\t    # i don't find any use for now.\n\t    source: List[str]\n\t    \"\"\"Where to obtain the Material\"\"\"\n\t    _meta = PrivateAttr()\n\tclass MaterialCount(BaseModel):\n\t    material: Material\n\t    count: int\n"]}
{"filename": "hsr_client/datamodels/eidolon.py", "chunked_list": ["from typing import Optional, Union, List, NewType\n\tfrom pydantic import BaseModel\n\tclass Eidolon(BaseModel):\n\t    \"\"\"Character's Eidolon\"\"\"\n\t    # eidolon name\n\t    name : str\n\t    \"\"\"Eidolon's Name\"\"\"\n\t    resonance: int\n\t    \"\"\"Eidolon Number/Resonance/Rank\"\"\"\n\t    description: Optional[str]\n", "    \"\"\"Eidolon short description.\"\"\"\n\t    # TODO: add eidolon icon property."]}
{"filename": "hsr_client/datamodels/chara.py", "chunked_list": ["from typing import Dict, List\n\tfrom bs4 import BeautifulSoup\n\tfrom pydantic import BaseModel, PrivateAttr\n\tfrom hsr_client.datamodels.trace import Skill\n\tfrom hsr_client.datamodels.eidolon import Eidolon\n\tfrom hsr_client.datamodels.element import Element\n\tfrom hsr_client.datamodels.lightcone import MaterialCount\n\tfrom hsr_client.hsr_types import Level\n\tfrom . import trace\n\tfrom hsr_client.paths import Path\n", "from enum import Enum\n\tclass Stats(BaseModel):\n\t    ATK: float\n\t    HP: float\n\t    DEF: float\n\t    CRIT: float\n\t    CDMG: float\n\t    SPD: float\n\t    TAUNT: float\n\t# TODO: decide all the parameters\n", "class Character(BaseModel):\n\t    \"\"\"Traces possessed by the `Character`\"\"\"\n\t    name: str\n\t    \"\"\"Name of the Character\"\"\"\n\t    rarity: int\n\t    \"\"\"Rarity of the Character\"\"\"\n\t    element: Element\n\t    \"\"\"Element of the Character\"\"\"\n\t    description: str\n\t    \"\"\"short description about the character.\"\"\"\n", "    path: Path\n\t    \"\"\"Path followed by the Character`\"\"\"\n\t    eidolons: List[Eidolon]\n\t    \"\"\"Character's Eidolons\"\"\"\n\t    traces: list[trace.Trace]\n\t    \"\"\"Character's Traces, does not include Skills, use `skills()` instead.\"\"\"\n\t    # srs backend levelData contains stats and ascension mats data.\n\t    _chara_levelData = PrivateAttr()\n\t    # srs backend skills; contains skill data and its ascension data\n\t    _chara_skills = PrivateAttr()\n", "    _backend = PrivateAttr()\n\t    def stats(self, level, ascended=False) -> Stats:\n\t        \"\"\"\n\t        Get Character's Stats for the given level. when `ascended=True` is used\n\t        on levels where ascension is possible, gives `Stats` for ascended levels\n\t        instead.\n\t        \"\"\"\n\t        if level < 1 or level > 80: # TODO: or is this 90?\n\t            raise ValueError(\" 1 <= level <= 80 criteria not satisfied.\")\n\t        for ascension_entry in self._chara_levelData:\n", "            if level <= ascension_entry[\"maxLevel\"]:\n\t                if ascension_entry[\"maxLevel\"] == level and ascended == True:\n\t                    continue\n\t                return Stats(\n\t                    ATK=ascension_entry[\"attackBase\"] + ascension_entry[\"attackAdd\"] * (level - 1),\n\t                    HP=ascension_entry[\"hpBase\"] + ascension_entry[\"hpAdd\"] * (level - 1),\n\t                    DEF=ascension_entry[\"defenseBase\"] + ascension_entry[\"defenseAdd\"] * (level - 1),\n\t                    SPD=ascension_entry[\"speedBase\"] + ascension_entry[\"speedAdd\"] * (level - 1),\n\t                    CRIT=ascension_entry[\"crate\"] * 100,\n\t                    CDMG=ascension_entry[\"cdmg\"] * 100,\n", "                    TAUNT=ascension_entry[\"aggro\"],\n\t                )\n\t    def ascension_mats(self) -> Dict[Level, List[MaterialCount]]:\n\t        \"\"\"\n\t        Returns the ascension materails grouped by ascension level.\n\t        ```\n\t        # example\n\t        mats_to_ascend_beyond_level_20 = chara.ascension_mats[20]\n\t        for ascension_mat in mats_to_ascend_beyond_level_20:\n\t            print(ascension_mat.material.name)\n", "            print(ascension_mat.material.description)\n\t            print(ascension_mat.count)\n\t        ```\n\t        \"\"\"\n\t        ascension_mats = {}\n\t        for per_ascension_data in self._chara_levelData:\n\t            level = per_ascension_data['maxLevel']\n\t            raw_matcounts =per_ascension_data['cost']\n\t            ascension_mats_per_level = []\n\t            for raw_matcount in raw_matcounts:\n", "                mat_id = raw_matcount['id']\n\t                from hsr_client.backend.srs_backend.parsers.material import parse_material\n\t                mat = parse_material(mat_id, self._backend)\n\t                mat_count = raw_matcount['count']\n\t                ascension_mats_per_level.append(\n\t                    MaterialCount(\n\t                    material=mat,\n\t                    count = mat_count,\n\t                    )\n\t                )\n", "            ascension_mats[level] = ascension_mats_per_level\n\t        return ascension_mats\n\t    def skills(self) -> List[Skill]:\n\t        \"\"\"Returns a List of `Skill`s that the character posseses\"\"\"\n\t        # skills\n\t        skills = []\n\t        raw_skills = self._chara_skills\n\t        for raw_skill in raw_skills:\n\t            # name\n\t            skill_name = raw_skill['name']\n", "            # scaling: LevelScaling\n\t            scaling = {}\n\t            for level, level_data in enumerate(raw_skill['levelData'], start=1):\n\t                desc_template = BeautifulSoup(\n\t                    raw_skill[\"descHash\"], features=\"lxml\"\n\t                ).get_text()\n\t                template_params = level_data['params']\n\t                skill_desc = desc_template\n\t                for slot_no, template_param in enumerate(template_params, start=1):\n\t                    replace_text = f\"#{slot_no}[i]\"\n", "                    # print(\"replacing: \" + replace_text + \" with \" + str(template_param) + \" in \" + ability_desc)\n\t                    skill_desc = skill_desc.replace(replace_text, str(template_param))\n\t                raw_matcounts =level_data['cost']\n\t                upgrade_mats_per_level = []\n\t                for raw_matcount in raw_matcounts:\n\t                    mat_id = raw_matcount['id']\n\t                    from hsr_client.backend.srs_backend.parsers.material import parse_material\n\t                    mat = parse_material(mat_id, self._backend)\n\t                    mat_count = raw_matcount['count']\n\t                    upgrade_mats_per_level.append(\n", "                        MaterialCount(\n\t                        material=mat,\n\t                        count = mat_count,\n\t                        )\n\t                    )\n\t                scaling[level] = trace.LevelScaling(\n\t                    upgrade_mats=upgrade_mats_per_level,\n\t                    description=skill_desc\n\t                )\n\t            skills.append(\n", "                Skill(\n\t                    name=skill_name,\n\t                    scaling=scaling,\n\t                )\n\t            )\n\t        return skills\n"]}
{"filename": "tests/srs_backend_test.py", "chunked_list": ["import unittest\n\tfrom hsr_client.backend.srs_backend import SRSBackend\n\tfrom hsr_client.backend.srs_backend.parsers.trace import parse_trace_data\n\tfrom hsr_client.datamodels.searchItem import SearchItem\n\tfrom hsr_client.constants import Item\n\tclass Test_backend(unittest.TestCase):\n\t    def test_traces(self):\n\t        import json\n\t        with open(\"tests/data/traces.json\") as f:\n\t            trace_node= json.load(f)\n", "            print(trace_data)\n\t            traces = []\n\t            parse_trace_data(trace_node, traces)\n\t            for trace in traces:\n\t                ...\n\t    def test_chara(self):\n\t        srs = SRSBackend()\n\t        chara = srs.get_character(target_name=\"march\")\n\t        print(chara.name)\n\t    def test_mtrl(self):\n", "        srs = SRSBackend()\n\t        mtrl = srs.resolve_material(search_item=SearchItem(url='', iconPath='', type=Item.MATERIAL, name='', rarity=4, id=24001))\n\t        print(mtrl)\n\tif __name__ == \"__main__\":\n\t    unittest.main()"]}
