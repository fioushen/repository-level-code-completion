{"filename": "exp_preprocess.py", "chunked_list": ["import os, argparse, logging\n\tfrom datetime import datetime\n\timport numpy as np\n\timport preprocess.depthneus_data  as depthneus_data\n\timport evaluation.EvalScanNet as EvalScanNet\n\tfrom evaluation.renderer import render_depthmaps_pyrender\n\timport utils.utils_geometry as GeoUtils\n\timport utils.utils_image  as ImageUtils\n\timport utils.utils_io as IOUtils\n\timport utils.utils_normal as NormalUtils\n", "from confs.path import lis_name_scenes\n\tif __name__ == '__main__':\n\t    np.set_printoptions(precision=3)\n\t    np.set_printoptions(suppress=True)\n\t    FORMAT = \"[%(filename)s:%(lineno)s] %(message)s\"\n\t    logging.basicConfig(level=logging.INFO, format=FORMAT)\n\t    parser = argparse.ArgumentParser()\n\t    parser.add_argument('--data_type', type=str, default='data type')\n\t    args = parser.parse_args()\n\t    dataset_type = args.data_type\n", "    if dataset_type == 'scannet':\n\t        dir_root_scannet = '/media/hp/HKUCS2/Dataset/ScanNet'\n\t        dir_root_neus = f'{dir_root_scannet}/sample_neus'\n\t        for scene_name in lis_name_scenes:\n\t            dir_scan = f'{dir_root_scannet}/{scene_name}'\n\t            dir_neus = f'{dir_root_neus}/{scene_name}'\n\t            depthneus_data.prepare_depthneus_data_from_scannet(dir_scan, dir_neus, sample_interval=6, \n\t                                                b_sample = True, \n\t                                                b_generate_neus_data = True,\n\t                                                b_pred_normal = True, \n", "                                                b_detect_planes = False,\n\t                                                b_unify_labels = False) \n\t    if dataset_type == 'private':\n\t        # example of processing iPhone video\n\t        # put a video under folder tmp_sfm_mvs or put your images under tmp_sfm_mvs/images\n\t        dir_depthneus = '/home/ethan/Desktop/test_sfm'\n\t        dir_depthneus = os.path.abspath(dir_depthneus)\n\t        dir_sfm_mvs = os.path.abspath(f'{dir_depthneus}/tmp_sfm_mvs')\n\t        crop_image = True\n\t        original_size_img = (1920, 1080)\n", "        cropped_size_img = (1360, 1020) # cropped images for normal estimation\n\t        reso_level = 1          \n\t        # split video into frames and sample images\n\t        b_split_images = True\n\t        path_video = f'{dir_sfm_mvs}/video.MOV'\n\t        dir_split = f'{dir_sfm_mvs}/images_split'\n\t        dir_mvs_sample = f'{dir_sfm_mvs}/images' # for mvs reconstruction\n\t        dir_depthneus_sample = f'{dir_sfm_mvs}/images_calibrated' # remove uncalbrated images\n\t        dir_depthneus_sample_cropped = f'{dir_depthneus}/image'\n\t        if b_split_images:\n", "            ImageUtils.split_video_to_frames(path_video, dir_split)     \n\t        # sample images\n\t        b_sample = True\n\t        sample_interval = 10\n\t        if b_sample:\n\t            rename_mode = 'order_04d'\n\t            ext_source = '.png' \n\t            ext_target = '.png'\n\t            ImageUtils.convert_images_type(dir_split, dir_mvs_sample, rename_mode, \n\t                                            target_img_size = None, ext_source = ext_source, ext_target =ext_target, \n", "                                            sample_interval = sample_interval)\n\t        # SfM camera calibration\n\t        b_sfm = True\n\t        if b_sfm:\n\t            os.system(f'python ./preprocess/sfm_mvs.py --dir_mvs {dir_sfm_mvs} --image_width {original_size_img[0]} --image_height {original_size_img[1]} --reso_level {reso_level}')\n\t        b_crop_image = True\n\t        if crop_image:\n\t            depthneus_data.crop_images_depthneus(dir_imgs = dir_depthneus_sample, \n\t                                dir_imgs_crop = dir_depthneus_sample_cropped, \n\t                                path_intrin = f'{dir_sfm_mvs}/intrinsics.txt', \n", "                                path_intrin_crop = f'{dir_depthneus}/intrinsics.txt', \n\t                                crop_size = cropped_size_img)\n\t            # crop depth\n\t            if IOUtils.checkExistence(f'{dir_sfm_mvs}/depth_calibrated'):\n\t                ImageUtils.crop_images(dir_images_origin = f'{dir_sfm_mvs}/depth_calibrated',\n\t                                            dir_images_crop = f'{dir_depthneus}/depth', \n\t                                            crop_size = cropped_size_img, \n\t                                            img_ext = '.npy')\n\t        b_prepare_neus = True\n\t        if b_prepare_neus:\n", "            depthneus_data.prepare_depthneus_data_from_private_data(dir_depthneus, cropped_size_img, \n\t                                                            b_generate_neus_data = True,\n\t                                                                b_pred_normal = True, \n\t                                                                b_detect_planes = False)\n\t    print('Done')\n"]}
{"filename": "exp_runner.py", "chunked_list": ["import cv2 as cv\n\timport numpy as np\n\timport os, logging, argparse, trimesh, copy\n\timport torch\n\timport torch.nn.functional as F\n\tfrom torch.utils.tensorboard import SummaryWriter\n\tfrom models.dataset import Dataset\n\tfrom models.fields import SDFNetwork, RenderingNetwork, SingleVarianceNetwork, NeRF\n\tfrom models.renderer import NeuSRenderer, extract_fields\n\tfrom models.nerf_renderer import NeRFRenderer\n", "from models.loss import NeuSLoss\n\timport models.patch_match_cuda as PatchMatch\n\tfrom shutil import copyfile\n\tfrom tqdm import tqdm\n\tfrom icecream import ic\n\tfrom datetime import datetime\n\tfrom pyhocon import ConfigFactory, HOCONConverter\n\timport utils.utils_io as IOUtils\n\timport utils.utils_geometry as GeoUtils\n\timport utils.utils_image as ImageUtils\n", "import utils.utils_training as TrainingUtils\n\tclass Runner:\n\t    def __init__(self, conf_path, scene_name = '', mode='train', model_type='', is_continue=False, checkpoint_id = -1):\n\t        # Initial setting: Genreal\n\t        self.device = torch.device('cuda')\n\t        self.conf_path = conf_path\n\t        self.conf = ConfigFactory.parse_file(conf_path)\n\t        self.dataset_type = self.conf['general.dataset_type']\n\t        self.scan_name = self.conf['general.scan_name']\n\t        if len(scene_name)>0:\n", "            self.scan_name = scene_name\n\t            print(f\"**********************Scan name: {self.scan_name}\\n********************** \\n\\n\\n\")\n\t        self.exp_name = self.conf['general.exp_name']\n\t        # parse cmd args\n\t        self.is_continue = is_continue\n\t        self.checkpoint_id = checkpoint_id\n\t        self.mode = mode\n\t        self.model_type = self.conf['general.model_type']\n\t        if model_type != '':  # overwrite\n\t            self.model_type = model_type\n", "        self.model_list = []\n\t        self.writer = None\n\t        self.curr_img_idx = -1\n\t        self.parse_parameters()\n\t        self.build_dataset()\n\t        self.build_model()\n\t        if self.is_continue:\n\t            self.load_pretrained_model()\n\t        # recording\n\t        if self.mode[:5] == 'train':\n", "            self.file_backup()\n\t            with open(f'{self.base_exp_dir}/recording/config_modified.conf', 'w') as configfile:\n\t                configfile.write(HOCONConverter.to_hocon(self.conf))\n\t    def load_pretrained_model(self):\n\t        # Load checkpoint\n\t        latest_model_name = None\n\t        model_list_raw = os.listdir(os.path.join(self.base_exp_dir, 'checkpoints'))\n\t        model_list = []\n\t        for model_name in model_list_raw:\n\t            if 'pretrained_sdf' in model_name:\n", "                continue\n\t            if model_name[-3:] == 'pth' and int(model_name[5:-4]) <= self.end_iter:\n\t                model_list.append(model_name)\n\t        model_list.sort()\n\t        if self.checkpoint_id == -1: \n\t            latest_model_name = model_list[-1]\n\t        else:\n\t            if f'ckpt_{self.checkpoint_id:06d}.pth' in model_list:\n\t                latest_model_name = f'ckpt_{self.checkpoint_id:06d}.pth'\n\t            else:\n", "                logging.error(f\"path_ckpt is not exist. (f'ckpt_{self.checkpoint_id:06d}.pth')\")\n\t                exit()\n\t        if latest_model_name is not None:\n\t            logging.info('Find checkpoint: {}'.format(latest_model_name))\n\t            self.load_checkpoint(latest_model_name)\n\t    def parse_parameters(self):\n\t        # patch-match\n\t        self.thres_robust_ncc = self.conf['dataset.patchmatch_thres_ncc_robust']\n\t        logging.info(f'Robust ncc threshold: {self.thres_robust_ncc}')\n\t        self.patchmatch_start = self.conf['dataset.patchmatch_start']\n", "        self.patchmatch_mode =  self.conf['dataset.patchmatch_mode']\n\t        self.nvs = self.conf.get_bool('train.nvs', default=False)\n\t        self.save_normamap_npz = self.conf['train.save_normamap_npz']\n\t        self.base_exp_dir = os.path.join(self.conf['general.exp_dir'], self.dataset_type, self.model_type, self.scan_name, str(self.exp_name))\n\t        os.makedirs(self.base_exp_dir, exist_ok=True)\n\t        logging.info(f'Exp dir: {self.base_exp_dir}')\n\t        self.iter_step = 0\n\t        self.radius_norm = 1.0\n\t        # trainning parameters\n\t        self.end_iter = self.conf.get_int('train.end_iter')\n", "        self.batch_size = self.conf.get_int('train.batch_size')\n\t        self.validate_resolution_level = self.conf.get_int('train.validate_resolution_level')\n\t        self.learning_rate = self.conf.get_float('train.learning_rate')\n\t        self.learning_rate_milestone = self.conf.get_list('train.learning_rate_milestone')\n\t        self.learning_rate_factor = self.conf.get_float('train.learning_rate_factor')\n\t        self.warm_up_end = self.conf.get_float('train.warm_up_end', default=0.0)\n\t        self.learning_rate_alpha = self.conf.get_float('train.learning_rate_alpha')\n\t        logging.info(f'Warm up end: {self.warm_up_end}; learning_rate_alpha: {self.learning_rate_alpha}')\n\t        self.use_white_bkgd = self.conf.get_bool('train.use_white_bkgd')\n\t        self.anneal_start = self.conf.get_float('train.anneal_start', default=0.0)\n", "        self.anneal_end = self.conf.get_float('train.anneal_end', default=0.0)\n\t        self.n_samples = self.conf.get_int('model.neus_renderer.n_samples')\n\t        # validate parameters\n\t        for attr in ['save_freq','report_freq', 'val_image_freq', 'val_mesh_freq', 'val_fields_freq', \n\t                        'freq_valid_points', 'freq_valid_weights',\n\t                        'freq_save_confidence' ]:\n\t            setattr(self, attr,  self.conf.get_int(f'train.{attr}'))\n\t    def build_dataset(self):\n\t        # dataset and directories\n\t        if self.dataset_type == 'indoor':\n", "            self.sample_range_indoor =  self.conf['dataset']['sample_range_indoor']\n\t            self.conf['dataset']['use_normal'] = True if self.conf['model.loss.normal_weight'] > 0 else False\n\t            self.use_indoor_data = True\n\t            logging.info(f\"Ray sample range: {self.sample_range_indoor}\")\n\t        elif self.dataset_type == 'dtu':\n\t            self.use_indoor_data = False\n\t            self.conf['model.sdf_network']['reverse_geoinit'] = False\n\t            self.conf['dataset']['use_normal'] = True if self.conf['model.loss.normal_weight'] > 0 else False\n\t            self.scan_id = int(self.scan_name[4:])\n\t            logging.info(f\"DTU scan ID: {self.scan_id}\")\n", "        else:\n\t            raise NotImplementedError\n\t        logging.info(f\"Use normal: {self.conf['dataset']['use_normal']}\")\n\t        self.conf['dataset']['use_planes'] = True if self.conf['model.loss.normal_consistency_weight'] > 0 else False\n\t        self.conf['dataset']['use_plane_offset_loss'] = True if self.conf['model.loss.plane_offset_weight'] > 0 else False\n\t        self.conf['dataset']['data_dir']  = os.path.join(self.conf['general.data_dir'] , self.dataset_type, self.scan_name)\n\t        self.dataset = Dataset(self.conf['dataset'])\n\t    def build_model(self):\n\t        # Networks\n\t        params_to_train = []\n", "        if self.model_type == 'neus':\n\t            self.nerf_outside = NeRF(**self.conf['model.tiny_nerf']).to(self.device)\n\t            self.sdf_network_fine = SDFNetwork(**self.conf['model.sdf_network']).to(self.device)\n\t            self.variance_network_fine = SingleVarianceNetwork(**self.conf['model.variance_network']).to(self.device)\n\t            self.color_network_fine = RenderingNetwork(**self.conf['model.rendering_network']).to(self.device)\n\t            params_to_train += list(self.nerf_outside.parameters())\n\t            params_to_train += list(self.sdf_network_fine.parameters())\n\t            params_to_train += list(self.variance_network_fine.parameters())\n\t            params_to_train += list(self.color_network_fine.parameters())\n\t            self.renderer = NeuSRenderer(self.nerf_outside,\n", "                                self.sdf_network_fine,\n\t                                self.variance_network_fine,\n\t                                self.color_network_fine,\n\t                                **self.conf['model.neus_renderer'])\n\t        elif self.model_type == 'nerf':  # NeRF\n\t            self.nerf_coarse = NeRF(**self.conf['model.nerf']).to(self.device)\n\t            self.nerf_fine = NeRF(**self.conf['model.nerf']).to(self.device)\n\t            self.nerf_outside = NeRF(**self.conf['model.tiny_nerf']).to(self.device)\n\t            params_to_train += list(self.nerf_coarse.parameters())\n\t            params_to_train += list(self.nerf_fine.parameters())\n", "            params_to_train += list(self.nerf_outside.parameters())\n\t            self.renderer = NeRFRenderer(self.nerf_coarse,\n\t                                self.nerf_fine,\n\t                                self.nerf_outside,\n\t                                **self.conf['model.nerf_renderer'])\n\t        else:\n\t            NotImplementedError\n\t        self.optimizer = torch.optim.Adam(params_to_train, lr=self.learning_rate)\n\t        self.loss_neus = NeuSLoss(self.conf['model.loss'])\n\t    def train(self):\n", "        if self.model_type == 'neus':\n\t            self.train_neus()\n\t        elif self.model_type == 'nerf':\n\t            self.train_nerf()\n\t        else:\n\t            NotImplementedError\n\t    def get_near_far(self, rays_o, rays_d,  image_perm = None, iter_i= None, pixels_x = None, pixels_y= None):\n\t        log_vox = {}\n\t        log_vox.clear()\n\t        batch_size = len(rays_o)\n", "        if  self.dataset_type == 'dtu':\n\t            near, far = self.dataset.near_far_from_sphere(rays_o, rays_d)\n\t        elif self.dataset_type == 'indoor':\n\t            near, far = torch.zeros(batch_size, 1), self.sample_range_indoor * torch.ones(batch_size, 1)\n\t        else:\n\t            NotImplementedError\n\t        logging.debug(f\"[{self.iter_step}] Sample range: max, {torch.max(far -near)}; min, {torch.min(far -near)}\")\n\t        return near, far, log_vox\n\t    def get_model_input(self, image_perm, iter_i):\n\t        input_model = {}\n", "        idx_img = image_perm[self.iter_step % self.dataset.n_images]\n\t        self.curr_img_idx = idx_img\n\t        data, pixels_x, pixels_y,  normal_sample, planes_sample, subplanes_sample, = self.dataset.random_get_rays_at(idx_img, self.batch_size)\n\t        rays_o, rays_d, true_rgb, true_mask, pts_target = data[:, :3], data[:, 3: 6], data[:, 6: 9], data[:, 9: 10],data[:,10:13]\n\t        true_mask =  (true_mask > 0.5).float()\n\t        mask = true_mask\n\t        if self.conf['model.loss.normal_weight'] > 0:\n\t            input_model['normals_gt'] = normal_sample\n\t        if self.conf['model.loss.normal_consistency_weight'] > 0:\n\t            input_model['planes_gt'] = planes_sample\n", "        if self.conf['model.loss.plane_offset_weight'] > 0:\n\t            input_model['subplanes_gt'] = subplanes_sample\n\t        near, far, logs_input = self.get_near_far(rays_o, rays_d,  image_perm, iter_i, pixels_x, pixels_y)\n\t        background_rgb = None\n\t        if self.use_white_bkgd:\n\t            background_rgb = torch.ones([1, 3])\n\t        if self.conf['model.loss.mask_weight'] > 0.0:\n\t            mask = (mask > 0.5).float()\n\t        else:\n\t            mask = torch.ones_like(mask)\n", "        mask_sum = mask.sum() + 1e-5\n\t        pixels_uv = torch.stack([pixels_x, pixels_y], dim=-1)\n\t        pixels_vu = torch.stack([pixels_y, pixels_x], dim=-1)\n\t        input_model.update({\n\t            'rays_o': rays_o,\n\t            'rays_d': rays_d,\n\t            'near': near,\n\t            'far': far,\n\t            'depth_gt': pts_target,\n\t            'mask': mask,\n", "            'mask_sum': mask_sum,\n\t            'true_rgb': true_rgb,\n\t            'background_rgb': background_rgb,\n\t            'pixels_x': pixels_x,  # u\n\t            'pixels_y': pixels_y,   # v,\n\t            'pixels_uv': pixels_uv,\n\t            'pixels_vu': pixels_vu\n\t        })\n\t        return input_model, logs_input\n\t    def train_neus(self):\n", "        self.writer = SummaryWriter(log_dir=os.path.join(self.base_exp_dir, 'logs'))\n\t        self.update_learning_rate()\n\t        self.update_iter_step()\n\t        res_step = self.end_iter - self.iter_step\n\t        if self.dataset.cache_all_data:\n\t            self.dataset.shuffle()\n\t        # self.validate_mesh() # save mesh at iter 0\n\t        logs_summary = {}\n\t        image_perm = torch.randperm(self.dataset.n_images)\n\t        for iter_i in tqdm(range(res_step)):  \n", "            logs_summary.clear()\n\t            input_model, logs_input = self.get_model_input(image_perm, iter_i)\n\t            logs_summary.update(logs_input)\n\t            render_out, logs_render = self.renderer.render(input_model['rays_o'], input_model['rays_d'], \n\t                                            input_model['near'], input_model['far'],\n\t                                            background_rgb=input_model['background_rgb'],\n\t                                            alpha_inter_ratio=self.get_alpha_inter_ratio())\n\t            logs_summary.update(logs_render)\n\t            patchmatch_out, logs_patchmatch = self.patch_match(input_model, render_out)\n\t            logs_summary.update(logs_patchmatch)\n", "            loss, logs_loss, mask_keep_gt_normal = self.loss_neus(input_model, render_out, self.sdf_network_fine, patchmatch_out)\n\t            logs_summary.update(logs_loss)\n\t            self.optimizer.zero_grad()\n\t            loss.backward()\n\t            self.optimizer.step()\n\t            self.iter_step += 1\n\t            logs_val = self.validate(input_model, logs_loss, render_out)\n\t            logs_summary.update(logs_val)\n\t            logs_summary.update({'Log/lr': self.optimizer.param_groups[0]['lr']})\n\t            self.write_summary(logs_summary)\n", "            self.update_learning_rate()\n\t            self.update_iter_step()\n\t            self.accumulate_rendered_results(input_model, render_out, patchmatch_out,\n\t                                                    b_accum_render_difference = False,\n\t                                                    b_accum_ncc = False,\n\t                                                    b_accum_normal_pts = False)\n\t            if self.iter_step % self.dataset.n_images == 0:\n\t                image_perm = torch.randperm(self.dataset.n_images)\n\t            if self.iter_step % 1000 == 0:\n\t                torch.cuda.empty_cache()\n", "        logging.info(f'Done. [{self.base_exp_dir}]')\n\t    def calculate_ncc_samples(self, input_model, render_out, \n\t                                    use_peak_value = True, \n\t                                    use_normal_prior = False):\n\t        pixels_coords_vu =input_model['pixels_vu'] \n\t        if use_peak_value:\n\t            pts_render = render_out['point_peak']\n\t            normals_render = render_out['normal_peak']\n\t        else:\n\t            raise NotImplementedError\n", "        if use_normal_prior:\n\t            normals_render = input_model['normals_gt']\n\t        pts_all = pts_render[:, None, :]\n\t        normals_all = normals_render[:, None, :]\n\t        coords_all = pixels_coords_vu[:, None, :]\n\t        with torch.no_grad():\n\t            scores_ncc_all, diff_patch_all, mask_valid_all = self.dataset.score_pixels_ncc(self.curr_img_idx, pts_all.reshape(-1, 3), \n\t                                                                                                normals_all.reshape(-1, 3), \n\t                                                                                                coords_all.reshape(-1, 2))\n\t            num_valid = mask_valid_all.sum()\n", "            scores_ncc_all = scores_ncc_all.reshape(self.batch_size, -1)\n\t            mask_valid_all = mask_valid_all.reshape(self.batch_size, -1)\n\t        return scores_ncc_all, diff_patch_all, mask_valid_all\n\t    def patch_match(self, input_model, render_out):\n\t        patchmatch_out, logs_summary = None, {}\n\t        if self.iter_step > self.patchmatch_start:\n\t            # ensure initialization of confidence_map, depth_map and points_map\n\t            if self.dataset.confidence_accum is None:\n\t                self.initialize_accumulated_results(mode=self.conf['dataset.mode_init_accum'], \n\t                                                    iter_step_npz=self.conf['dataset.init_accum_step_npz'],\n", "                                                    resolution_level=self.conf['dataset.init_accum_reso_level'])\n\t            if self.patchmatch_mode == 'use_geocheck':\n\t                scores_ncc, diffs_patch, mask_valid = self.calculate_ncc_samples(input_model, render_out)\n\t                # (1) mask of pixels with high confidence\n\t                mask_high_confidence_curr = scores_ncc < self.thres_robust_ncc\n\t                # (2) check previous ncc confidence\n\t                pixels_u, pixels_v = input_model['pixels_x'].cpu().numpy(), input_model['pixels_y'].cpu().numpy()\n\t                ncc_prev = self.dataset.confidence_accum[self.curr_img_idx][pixels_v, pixels_u]\n\t                mask_high_confidence_prev = ncc_prev < self.thres_robust_ncc\n\t                # (3) remove normals with large difference between rendered normal and gt normal\n", "                # large difference means large inconsistency of normal between differenct views\n\t                normal_render = render_out['normal_peak']\n\t                angles_diff = TrainingUtils.get_angles(normal_render, input_model['normals_gt'])\n\t                MAX_ANGLE_DIFF = 30.0 / 180.0 * 3.1415926\n\t                mask_small_normal_diffence = angles_diff < MAX_ANGLE_DIFF\n\t                # (4) merge masks\n\t                mask_use_gt = mask_high_confidence_curr & torch.from_numpy(mask_high_confidence_prev[:,None]).cuda() & mask_small_normal_diffence\n\t                # (5) update confidence, discard the normals\n\t                mask_not_use_gt = (mask_use_gt==False)\n\t                scores_ncc_all2 = copy.deepcopy(scores_ncc)\n", "                scores_ncc_all2[mask_not_use_gt] = 1.0\n\t                self.dataset.confidence_accum[self.curr_img_idx][pixels_v, pixels_u] = scores_ncc_all2.squeeze().cpu().numpy()\n\t                idx_scores_min = mask_use_gt.long()  # 1 use gt, 0 not\n\t                patchmatch_out = {\n\t                    'patchmatch_mode': self.patchmatch_mode,\n\t                    'scores_ncc_all': scores_ncc,\n\t                    'idx_scores_min': idx_scores_min,\n\t                }\n\t                logs_summary.update({\n\t                    'Log/pixels_use_volume_rendering_only': (idx_scores_min==0).sum(),\n", "                    'Log/pixels_use_prior': (idx_scores_min==1).sum(),\n\t                })\n\t            else:\n\t                raise NotImplementedError\n\t        return patchmatch_out, logs_summary\n\t    def accumulate_rendered_results(self, input_model, render_out, patchmatch_out,\n\t                                        b_accum_render_difference = False,\n\t                                        b_accum_ncc = False,\n\t                                        b_accum_normal_pts = False):\n\t        '''Cache rendererd depth, normal and confidence (if avaliable) in the training process\n", "        Args:\n\t            scores: (N,)\n\t        '''\n\t        pixels_u, pixels_v = input_model['pixels_x'], input_model['pixels_y']\n\t        pixels_u_np, pixels_v_np = pixels_u.cpu().numpy(), pixels_v.cpu().numpy()\n\t        if b_accum_render_difference:\n\t            color_gt = self.dataset.images_denoise_np[self.curr_img_idx.item()][pixels_v_np, pixels_u_np]\n\t            color_render = render_out['color_fine'].detach().cpu.numpy()\n\t            diff = np.abs(color_render - color_gt).sum(axis=-1)\n\t            self.dataset.render_difference_accum[self.curr_img_idx.item()][pixels_v_np, pixels_u_np] = diff\n", "        if b_accum_ncc:\n\t            scores_vr = patchmatch_out['scores_samples'] \n\t            self.dataset.confidence_accum[self.curr_img_idx.item()][pixels_v_np, pixels_u_np] = scores_vr.cpu().numpy()\n\t        if b_accum_normal_pts:\n\t            point_peak = render_out['point_peak']\n\t            self.dataset.points_accum[self.curr_img_idx][pixels_v, pixels_u]  = point_peak.detach().cpu()\n\t            normal_peak = render_out['normal_peak']\n\t            self.dataset.normals_accum[self.curr_img_idx][pixels_v, pixels_u] = normal_peak.detach().cpu()\n\t        b_accum_all_data = False\n\t        if b_accum_all_data:\n", "            self.dataset.depths_accum[self.curr_img_idx][pixels_v, pixels_u]  = render_out['depth_peak'].squeeze()\n\t            self.dataset.colors_accum[self.curr_img_idx][pixels_v, pixels_u]  = render_out['color_peak']\n\t    def write_summary(self, logs_summary):\n\t        for key in logs_summary:\n\t            self.writer.add_scalar(key, logs_summary[key], self.iter_step )\n\t    def update_iter_step(self):\n\t        self.sdf_network_fine.iter_step = self.iter_step\n\t        self.sdf_network_fine.end_iter = self.end_iter\n\t        self.loss_neus.iter_step = self.iter_step\n\t        self.loss_neus.iter_end = self.end_iter\n", "        self.dataset.iter_step = self.iter_step\n\t    def get_alpha_inter_ratio(self):\n\t        if self.anneal_end == 0.0:\n\t            return 1.0\n\t        elif self.iter_step < self.anneal_start:\n\t            return 0.0\n\t        else:\n\t            return np.min([1.0, (self.iter_step - self.anneal_start) / (self.anneal_end - self.anneal_start)])\n\t    def get_alpha_inter_ratio_decrease(self):\n\t        anneal_end = 5e4\n", "        anneal_start = 0\n\t        if anneal_end == 0.0:\n\t            return 0.0\n\t        elif self.iter_step < anneal_start:\n\t            return 1.0\n\t        else:\n\t            return 1.0 - np.min([1.0, (self.iter_step - anneal_start) / (anneal_end - anneal_start)])\n\t    def update_learning_rate(self):\n\t        if self.iter_step < self.warm_up_end:\n\t            learning_factor = self.iter_step / self.warm_up_end\n", "        else:\n\t            alpha = self.learning_rate_alpha\n\t            progress = (self.iter_step - self.warm_up_end) / (self.end_iter - self.warm_up_end)\n\t            learning_factor = (np.cos(np.pi * progress) + 1.0) * 0.5 * (1 - alpha) + alpha\n\t        for g in self.optimizer.param_groups:\n\t            g['lr'] = self.learning_rate * learning_factor\n\t    def train_nerf(self):\n\t        self.writer = SummaryWriter(log_dir=os.path.join(self.base_exp_dir, 'logs'))\n\t        self.update_learning_rate()\n\t        res_step = self.end_iter - self.iter_step\n", "        image_perm = self.get_image_perm()\n\t        for iter_i in tqdm(range(res_step)):\n\t            data, _, _, normal_sample, planes_sample, subplanes_sample, mask_normal_certain_sample = self.dataset.random_get_rays_at(image_perm[self.iter_step % len(image_perm)], self.batch_size)\n\t            rays_o, rays_d, true_rgb, mask = data[:, :3], data[:, 3: 6], data[:, 6: 9], data[:, 9: 10]\n\t            if self.dataset_type == 'dtu':\n\t                near, far = self.dataset.near_far_from_sphere(rays_o, rays_d)\n\t            elif self.dataset_type == 'indoor':\n\t                near, far = torch.zeros(len(rays_o), 1), self.sample_range_indoor * torch.ones(len(rays_o), 1)\n\t            else:\n\t                NotImplementedError\n", "            background_rgb = None\n\t            if self.use_white_bkgd:\n\t                background_rgb = torch.ones([1, 3])\n\t            if self.conf['model.loss.mask_weight'] > 0.0:\n\t                mask = (mask > 0.5).float()\n\t            else:\n\t                mask = torch.ones_like(mask)\n\t            mask_sum = mask.sum() + 1e-5\n\t            render_out = self.renderer.render(rays_o, rays_d, near, far,\n\t                                              background_rgb=background_rgb)\n", "            color_coarse = render_out['color_coarse']\n\t            color_fine = render_out['color_fine']\n\t            weight_sum = render_out['weight_sum']\n\t            # Color loss\n\t            color_coarse_error = (color_coarse - true_rgb) * mask\n\t            color_coarse_loss = F.mse_loss(color_coarse_error, torch.zeros_like(color_coarse_error), reduction='sum') / mask_sum\n\t            color_fine_error = (color_fine - true_rgb) * mask\n\t            color_fine_loss = F.mse_loss(color_fine_error, torch.zeros_like(color_fine_error), reduction='sum') / mask_sum\n\t            psnr = 20.0 * torch.log10(1.0 / (((color_fine - true_rgb)**2 * mask).sum() / (mask_sum * 3.0)).sqrt())\n\t            # Mask loss, optional\n", "            mask_loss = F.binary_cross_entropy(weight_sum.clip(1e-3, 1.0 - 1e-3), mask)\n\t            loss = color_coarse_loss + color_fine_loss\n\t            self.optimizer.zero_grad()\n\t            loss.backward()\n\t            self.optimizer.step()\n\t            self.iter_step += 1\n\t            self.writer.add_scalar('Loss/loss', loss, self.iter_step)\n\t            self.writer.add_scalar('Loss/color_loss', color_fine_loss, self.iter_step)\n\t            self.writer.add_scalar('Loss/color_coarse_loss', color_coarse_loss, self.iter_step)\n\t            self.writer.add_scalar('Log/psnr', psnr, self.iter_step)\n", "            self.writer.add_scalar('Log/lr', self.optimizer.param_groups[0]['lr'], self.iter_step)\n\t            if self.iter_step % self.report_freq == 0:\n\t                print(self.base_exp_dir)\n\t                logging.info('iter:{:8>d} loss = {} lr={}'.format(self.iter_step, loss, self.optimizer.param_groups[0]['lr']))\n\t            if self.iter_step % self.save_freq == 0:\n\t                self.save_checkpoint()\n\t            if self.iter_step % self.val_image_freq == 0:\n\t                self.validate_image_nerf()\n\t            if self.iter_step % self.val_mesh_freq == 0:\n\t                self.validate_mesh_nerf()\n", "            if self.iter_step % self.freq_eval_mesh == 0:\n\t                self.validate_mesh_nerf(world_space=False, resolution=512, threshold=25)\n\t            self.update_learning_rate()\n\t            self.dataset.iter_step = self.iter_step\n\t            if self.iter_step % len(image_perm) == 0:\n\t                image_perm = self.get_image_perm()\n\t    def get_image_perm(self):\n\t        if not self.nvs:\n\t            return torch.randperm(self.dataset.n_images)\n\t        else:\n", "            lis = [i for i in range(self.dataset.n_images) if not i in [8, 13, 16, 21, 26, 31, 34, 56]]\n\t            lis = torch.tensor(lis, dtype=torch.long)\n\t            return lis[torch.randperm(len(lis))]\n\t    def file_backup(self):\n\t        # copy python file\n\t        dir_lis = self.conf['general.recording']\n\t        os.makedirs(os.path.join(self.base_exp_dir, 'recording'), exist_ok=True)\n\t        for dir_name in dir_lis:\n\t            cur_dir = os.path.join(self.base_exp_dir, 'recording', dir_name)\n\t            os.makedirs(cur_dir, exist_ok=True)\n", "            files = os.listdir(dir_name)\n\t            for f_name in files:\n\t                if f_name[-3:] == '.py':\n\t                    copyfile(os.path.join(dir_name, f_name), os.path.join(cur_dir, f_name))\n\t        # copy configs\n\t        copyfile(self.conf_path, os.path.join(self.base_exp_dir, 'recording', 'config.conf'))\n\t    def load_checkpoint(self, checkpoint_name):\n\t        checkpoint = torch.load(os.path.join(self.base_exp_dir, 'checkpoints', checkpoint_name), map_location=self.device)\n\t        if self.model_type == 'neus':\n\t            self.nerf_outside.load_state_dict(checkpoint['nerf'])\n", "            self.sdf_network_fine.load_state_dict(checkpoint['sdf_network_fine'])\n\t            self.variance_network_fine.load_state_dict(checkpoint['variance_network_fine'])\n\t            self.color_network_fine.load_state_dict(checkpoint['color_network_fine'])\n\t            self.optimizer.load_state_dict(checkpoint['optimizer'])\n\t            self.iter_step = checkpoint['iter_step']\n\t        elif self.model_type == 'nerf':\n\t            self.nerf_coarse.load_state_dict(checkpoint['nerf_coarse'])\n\t            self.nerf_fine.load_state_dict(checkpoint['nerf_fine'])\n\t            self.nerf_outside.load_state_dict(checkpoint['nerf_outside'])\n\t            self.optimizer.load_state_dict(checkpoint['optimizer'])\n", "            self.iter_step = checkpoint['iter_step']\n\t        else:\n\t            NotImplementedError\n\t    def save_checkpoint(self):\n\t        checkpoint = None\n\t        if self.model_type == 'neus':\n\t            checkpoint = {\n\t                'nerf': self.nerf_outside.state_dict(),\n\t                'sdf_network_fine': self.sdf_network_fine.state_dict(),\n\t                'variance_network_fine': self.variance_network_fine.state_dict(),\n", "                'color_network_fine': self.color_network_fine.state_dict(),\n\t                'optimizer': self.optimizer.state_dict(),\n\t                'iter_step': self.iter_step,\n\t            }\n\t        elif self.model_type == 'nerf':\n\t            checkpoint = {\n\t                'nerf_coarse': self.nerf_coarse.state_dict(),\n\t                'nerf_fine': self.nerf_fine.state_dict(),\n\t                'nerf_outside': self.nerf_outside.state_dict(),\n\t                'optimizer': self.optimizer.state_dict(),\n", "                'iter_step': self.iter_step,\n\t            }\n\t        else:\n\t            NotImplementedError\n\t        os.makedirs(os.path.join(self.base_exp_dir, 'checkpoints'), exist_ok=True)\n\t        torch.save(checkpoint, os.path.join(self.base_exp_dir, 'checkpoints', 'ckpt_{:0>6d}.pth'.format(self.iter_step)))\n\t    def validate(self, input_model, loss_out, render_out):\n\t        mask, rays_o, rays_d, near, far = input_model['mask'], input_model['rays_o'], input_model['rays_d'],  \\\n\t                                                    input_model['near'], input_model['far']\n\t        mask_sum = mask.sum() + 1e-5\n", "        loss, psnr = loss_out['Loss/loss'], loss_out['Log/psnr']\n\t        log_val = {}\n\t        if self.iter_step % self.report_freq == 0:\n\t            print('\\n', self.base_exp_dir)\n\t            logging.info('iter:{:8>d} loss={:.03f} lr={:.06f} var={:.04f}'.format(self.iter_step, loss, self.optimizer.param_groups[0]['lr'], render_out['variance'].mean()))\n\t            ic((render_out['weight_sum'] * mask).sum() / mask_sum)\n\t            ic(self.get_alpha_inter_ratio())\n\t            ic(psnr)\n\t        if self.iter_step % self.save_freq == 0:\n\t            self.save_checkpoint()\n", "        if self.iter_step % self.val_mesh_freq == 0 or self.iter_step == 1:\n\t            self.validate_mesh()\n\t        if self.iter_step % self.val_image_freq == 0:\n\t            self.validate_image(save_normalmap_npz=self.save_normamap_npz)\n\t        if self.iter_step % self.val_fields_freq == 0:\n\t            self.validate_fields()\n\t        if self.iter_step % self.freq_valid_points == 0:\n\t            self.validate_points(rays_o, rays_d, near, far)\n\t        if self.iter_step % self.freq_save_confidence == 0:\n\t            self.save_accumulated_results()\n", "            self.save_accumulated_results(idx=self.dataset.n_images//2)\n\t        return log_val\n\t    def validate_image(self, idx=-1, resolution_level=-1, \n\t                                save_normalmap_npz = False, \n\t                                save_peak_value = False, \n\t                                validate_confidence = True,\n\t                                save_image_render = False):\n\t        # validate image\n\t        ic(self.iter_step, idx)\n\t        logging.info(f'Validate begin: idx {idx}...')\n", "        if idx < 0:\n\t            idx = np.random.randint(self.dataset.n_images)\n\t        if resolution_level < 0:\n\t            resolution_level = self.validate_resolution_level\n\t        imgs_render = {}\n\t        for key in ['color_fine', 'confidence', 'normal', 'depth', 'variance_surface', 'confidence_mask']:\n\t            imgs_render[key] = []\n\t        if save_peak_value:\n\t            imgs_render.update({\n\t                'color_peak': [], \n", "                'normal_peak': [], \n\t                'depth_peak':[]\n\t            })\n\t            pts_peak_all = []\n\t        # (1) render images\n\t        rays_o, rays_d = self.dataset.gen_rays_at(idx, resolution_level=resolution_level)\n\t        H, W, _ = rays_o.shape\n\t        rays_o = rays_o.reshape(-1, 3).split(self.batch_size)\n\t        rays_d = rays_d.reshape(-1, 3).split(self.batch_size)\n\t        idx_pixels_vu = torch.tensor([[i, j] for i in range(0, H) for j in range(0, W)]).split(self.batch_size)\n", "        for rays_o_batch, rays_d_batch, idx_pixels_vu_batch in zip(rays_o, rays_d, idx_pixels_vu):\n\t            near, far, _ = self.get_near_far(rays_o = rays_o_batch, rays_d = rays_d_batch)\n\t            background_rgb = torch.ones([1, 3]) if self.use_white_bkgd else None\n\t            render_out, _ = self.renderer.render(rays_o_batch, rays_d_batch, near, far, alpha_inter_ratio=self.get_alpha_inter_ratio(), background_rgb=background_rgb)\n\t            feasible = lambda key: ((key in render_out) and (render_out[key] is not None))\n\t            for key in imgs_render:\n\t                if feasible(key):\n\t                    imgs_render[key].append(render_out[key].detach().cpu().numpy())\n\t            if validate_confidence:\n\t                pts_peak = rays_o_batch + rays_d_batch * render_out['depth_peak']\n", "                scores_all_mean, diff_patch_all, mask_valid_all = self.dataset.score_pixels_ncc(idx, pts_peak, render_out['normal_peak'], idx_pixels_vu_batch, reso_level=resolution_level)\n\t                imgs_render['confidence'].append(scores_all_mean.detach().cpu().numpy()[:,None])\n\t                imgs_render['confidence_mask'].append(mask_valid_all.detach().cpu().numpy()[:,None])\n\t                if save_peak_value:\n\t                    pts_peak_all.append(pts_peak.detach().cpu().numpy())\n\t            del render_out\n\t        # (2) reshape rendered images\n\t        for key in imgs_render:\n\t            if len(imgs_render[key]) > 0:\n\t                imgs_render[key] = np.concatenate(imgs_render[key], axis=0)\n", "                if imgs_render[key].shape[1] == 3: # for color and normal\n\t                    imgs_render[key] = imgs_render[key].reshape([H, W, 3])\n\t                elif imgs_render[key].shape[1] == 1:  \n\t                    imgs_render[key] = imgs_render[key].reshape([H, W])\n\t        # confidence map\n\t        if save_normalmap_npz:\n\t            # For each view, save point(.npz), depthmap(.png) point cloud(.ply), normalmap(.png), normal(.npz)\n\t            # rendered depth in volume rednering and projected depth of points in world are different\n\t            shape_depthmap = imgs_render['depth'].shape[:2]\n\t            pts_world = torch.vstack(rays_o).cpu().numpy() +  torch.vstack(rays_d).cpu().numpy() * imgs_render['depth'].reshape(-1,1)\n", "            os.makedirs(os.path.join(self.base_exp_dir, 'depth'), exist_ok=True)\n\t            GeoUtils.save_points(os.path.join(self.base_exp_dir, 'depth', f'{self.iter_step:0>8d}_{idx}_reso{resolution_level}.ply'),\n\t                                    pts_world.reshape(-1,3),\n\t                                    colors = imgs_render['color_fine'].squeeze().reshape(-1,3),\n\t                                    normals= imgs_render['normal'].squeeze().reshape(-1,3),\n\t                                    BRG2RGB=True)\n\t            # save peak depth and normal\n\t            if save_peak_value:\n\t                pts_world_peak = torch.vstack(rays_o).cpu().numpy() +  torch.vstack(rays_d).cpu().numpy() * imgs_render['depth_peak'].reshape(-1,1)\n\t                os.makedirs(os.path.join(self.base_exp_dir, 'depth'), exist_ok=True)\n", "                GeoUtils.save_points(os.path.join(self.base_exp_dir, 'depth', f'{self.iter_step:0>8d}_{idx}_reso{resolution_level}_peak.ply'),\n\t                                        pts_world_peak.reshape(-1,3),\n\t                                        colors = imgs_render['color_peak'].squeeze().reshape(-1,3),\n\t                                        normals= imgs_render['normal_peak'].squeeze().reshape(-1,3),\n\t                                        BRG2RGB=True)\n\t                os.makedirs(os.path.join(self.base_exp_dir, 'normal_peak'), exist_ok=True)\n\t                np.savez(os.path.join(self.base_exp_dir, 'normal_peak', f'{self.iter_step:08d}_{self.dataset.vec_stem_files[idx]}_reso{resolution_level}.npz'), \n\t                            imgs_render['normal_peak'].squeeze())\n\t                os.makedirs(os.path.join(self.base_exp_dir, 'normal_render'), exist_ok=True)\n\t                np.savez(os.path.join(self.base_exp_dir, 'normal_render', f'{self.iter_step:08d}_{self.dataset.vec_stem_files[idx]}_reso{resolution_level}.npz'), \n", "                            imgs_render['normal'].squeeze())\n\t                pts_world2 = pts_world_peak.reshape([H, W, 3])\n\t                np.savez(os.path.join(self.base_exp_dir, 'depth', f'{self.iter_step:08d}_{idx}_reso{resolution_level}_peak.npz'),\n\t                            pts_world2)\n\t        if save_image_render:\n\t            os.makedirs(os.path.join(self.base_exp_dir, 'image_render'), exist_ok=True)\n\t            ImageUtils.write_image(os.path.join(self.base_exp_dir, 'image_render', f'{self.iter_step:08d}_{self.dataset.vec_stem_files[idx]}_reso{resolution_level}.png'), \n\t                        imgs_render['color_fine']*255)\n\t            psnr_render = 20.0 * torch.log10(1.0 / (((self.dataset.images[idx] - torch.from_numpy(imgs_render['color_fine']))**2).sum() / (imgs_render['color_fine'].size * 3.0)).sqrt())\n\t            os.makedirs(os.path.join(self.base_exp_dir, 'image_peak'), exist_ok=True)\n", "            ImageUtils.write_image(os.path.join(self.base_exp_dir, 'image_peak', f'{self.iter_step:08d}_{self.dataset.vec_stem_files[idx]}_reso{resolution_level}.png'), \n\t                        imgs_render['color_peak']*255)    \n\t            psnr_peak = 20.0 * torch.log10(1.0 / (((self.dataset.images[idx] - torch.from_numpy(imgs_render['color_peak']))**2).sum() / (imgs_render['color_peak'].size * 3.0)).sqrt())\n\t            print(f'PSNR (rener, peak): {psnr_render}  {psnr_peak}')\n\t        # (3) save images\n\t        lis_imgs = []\n\t        img_sample = np.zeros_like(imgs_render['color_fine'])\n\t        img_sample[:,:,1] = 255\n\t        for key in imgs_render:\n\t            if len(imgs_render[key]) == 0 or key =='confidence_mask':\n", "                continue\n\t            img_temp = imgs_render[key]\n\t            if key in ['normal', 'normal_peak']:\n\t                img_temp = (((img_temp + 1) * 0.5).clip(0,1) * 255).astype(np.uint8)\n\t            if key in ['depth', 'depth_peak', 'variance']:\n\t                img_temp = img_temp / (np.max(img_temp)+1e-6) * 255\n\t            if key == 'confidence':\n\t                img_temp2 = ImageUtils.convert_gray_to_cmap(img_temp)\n\t                img_temp2 = img_temp2 * imgs_render['confidence_mask'][:,:,None]\n\t                lis_imgs.append(img_temp2)\n", "                img_temp3_mask_use_prior = (img_temp<self.thres_robust_ncc)\n\t                lis_imgs.append(img_temp3_mask_use_prior*255)\n\t                img_sample[img_temp==1.0] = (255,0,0)\n\t                logging.info(f'Pixels: {img_temp3_mask_use_prior.size}; Use prior: {img_temp3_mask_use_prior.sum()}; Invalid patchmatch: {(img_temp==1.0).sum()}')\n\t                logging.info(f'Ratio: Use prior: {img_temp3_mask_use_prior.sum()/img_temp3_mask_use_prior.size}; Invalid patchmatch: {(img_temp==1.0).sum()/img_temp3_mask_use_prior.size}')\n\t                img_temp = img_temp.clip(0,1) * 255\n\t            if key in ['color_fine', 'color_peak', 'confidence_mask']:\n\t                img_temp *= 255\n\t            cv.putText(img_temp, key,  (img_temp.shape[1]-100, img_temp.shape[0]-20), \n\t                fontFace= cv.FONT_HERSHEY_SIMPLEX, \n", "                fontScale = 0.5, \n\t                color = (0, 0, 255), \n\t                thickness = 2)\n\t            lis_imgs.append(img_temp)\n\t        dir_images = os.path.join(self.base_exp_dir, 'images')\n\t        os.makedirs(dir_images, exist_ok=True)\n\t        img_gt = ImageUtils.resize_image(self.dataset.images[idx].cpu().numpy(), \n\t                                            (lis_imgs[0].shape[1], lis_imgs[0].shape[0]))\n\t        img_sample[img_temp3_mask_use_prior] = img_gt[img_temp3_mask_use_prior]*255\n\t        ImageUtils.write_image_lis(f'{dir_images}/{self.iter_step:08d}_reso{resolution_level}_{idx:08d}.png',\n", "                                        [img_gt, img_sample] + lis_imgs)\n\t        if save_peak_value:\n\t            pts_peak_all = np.concatenate(pts_peak_all, axis=0)\n\t            pts_peak_all = pts_peak_all.reshape([H, W, 3])\n\t            return imgs_render['confidence'], imgs_render['color_peak'], imgs_render['normal_peak'], imgs_render['depth_peak'], pts_peak_all, imgs_render['confidence_mask']\n\t    def compare_ncc_confidence(self, idx=-1, resolution_level=-1):\n\t        # validate image\n\t        ic(self.iter_step, idx)\n\t        logging.info(f'Validate begin: idx {idx}...')\n\t        if idx < 0:\n", "            idx = np.random.randint(self.dataset.n_images)\n\t        if resolution_level < 0:\n\t            resolution_level = self.validate_resolution_level\n\t        # (1) render images\n\t        rays_o, rays_d = self.dataset.gen_rays_at(idx, resolution_level=resolution_level)\n\t        H, W, _ = rays_o.shape\n\t        rays_o = rays_o.reshape(-1, 3).split(self.batch_size)\n\t        rays_d = rays_d.reshape(-1, 3).split(self.batch_size)\n\t        normals_gt = self.dataset.normals[idx].cuda()\n\t        normals_gt = normals_gt.reshape(-1, 3).split(self.batch_size)\n", "        scores_render_all, scores_gt_all = [], []\n\t        idx_pixels_vu = torch.tensor([[i, j] for i in range(0, H) for j in range(0, W)]).split(self.batch_size)\n\t        for rays_o_batch, rays_d_batch, idx_pixels_vu_batch, normals_gt_batch in zip(rays_o, rays_d, idx_pixels_vu, normals_gt):\n\t            near, far, _ = self.get_near_far(rays_o = rays_o_batch, rays_d = rays_d_batch)\n\t            background_rgb = torch.ones([1, 3]) if self.use_white_bkgd else None\n\t            render_out, _ = self.renderer.render(rays_o_batch, rays_d_batch, near, far, alpha_inter_ratio=self.get_alpha_inter_ratio(), background_rgb=background_rgb)\n\t            pts_peak = rays_o_batch + rays_d_batch * render_out['depth_peak']\n\t            scores_render, diff_patch_all, mask_valid_all = self.dataset.score_pixels_ncc(idx, pts_peak, render_out['normal_peak'], idx_pixels_vu_batch, reso_level=resolution_level)\n\t            scores_gt, diff_patch_all_gt, mask_valid_all_gt = self.dataset.score_pixels_ncc(idx, pts_peak, normals_gt_batch, idx_pixels_vu_batch, reso_level=resolution_level)\n\t            scores_render_all.append(scores_render.cpu().numpy())\n", "            scores_gt_all.append(scores_gt.cpu().numpy())\n\t        scores_render_all = np.concatenate(scores_render_all, axis=0).reshape([H, W])\n\t        scores_gt_all = np.concatenate(scores_gt_all, axis=0).reshape([H, W])\n\t        mask_filter =( (scores_gt_all -0.01) < scores_render_all)\n\t        img_gr=np.zeros((H, W, 3), dtype=np.uint8)\n\t        img_gr[:,:, 0] = 255 \n\t        img_gr[mask_filter==False] = (0,0,255)\n\t        img_rgb =np.zeros((H, W, 3), dtype=np.uint8) \n\t        img_rgb[mask_filter==False] = self.dataset.images_np[idx][mask_filter==False]*255\n\t        ImageUtils.write_image_lis(f'./test/sampling/rgb_{idx:04d}.png', [self.dataset.images_np[idx]*256, mask_filter*255, img_gr, img_rgb])\n", "    def validate_mesh(self, world_space=False, resolution=128, threshold=0.0):\n\t        bound_min = torch.tensor(self.dataset.bbox_min, dtype=torch.float32) #/ self.sdf_network_fine.scale\n\t        bound_max = torch.tensor(self.dataset.bbox_max, dtype=torch.float32) # / self.sdf_network_fine.scale\n\t        vertices, triangles, sdf = self.renderer.extract_geometry(bound_min, bound_max, resolution=resolution, threshold=threshold)\n\t        os.makedirs(os.path.join(self.base_exp_dir, 'meshes'), exist_ok=True)\n\t        path_mesh = os.path.join(self.base_exp_dir, 'meshes', f'{self.iter_step:0>8d}_reso{resolution}_{self.scan_name}.ply')\n\t        path_mesh_gt = IOUtils.find_target_file(self.dataset.data_dir, '_vh_clean_2_trans.ply')\n\t        if world_space:\n\t            path_trans_n2w = f\"{self.conf['dataset']['data_dir']}/trans_n2w.txt\"\n\t            scale_mat = self.dataset.scale_mats_np[0]\n", "            if IOUtils.checkExistence(path_trans_n2w):\n\t                scale_mat = np.loadtxt(path_trans_n2w)\n\t            vertices = vertices * scale_mat[0, 0] + scale_mat[:3, 3][None]\n\t            path_mesh = os.path.join(self.base_exp_dir, 'meshes', f'{self.iter_step:0>8d}_reso{resolution}_{self.scan_name}_world.ply')\n\t            path_mesh_gt = IOUtils.find_target_file(self.dataset.data_dir, '_vh_clean_2.ply')\n\t        mesh = trimesh.Trimesh(vertices, triangles)\n\t        mesh.export(path_mesh)\n\t        if path_mesh_gt:\n\t            GeoUtils.clean_mesh_points_outside_bbox(path_mesh, path_mesh, path_mesh_gt, scale_bbox = 1.1, check_existence=False)\n\t        return path_mesh\n", "    def validate_fields(self, iter_step=-1):\n\t        if iter_step < 0:\n\t            iter_step = self.iter_step\n\t        bound_min = torch.tensor(self.dataset.bbox_min, dtype=torch.float32)\n\t        bound_max = torch.tensor(self.dataset.bbox_max, dtype=torch.float32)\n\t        sdf = extract_fields(bound_min, bound_max, 128, lambda pts: self.sdf_network_fine.sdf(pts)[:, 0])\n\t        os.makedirs(os.path.join(self.base_exp_dir, 'fields'), exist_ok=True)\n\t        np.save(os.path.join(self.base_exp_dir, 'fields', '{:0>8d}_sdf.npy'.format(iter_step)), sdf)\n\t    def validate_points(self, rays_o, rays_d, near, far):\n\t        logging.info(f\"[{self.iter_step}]: validate sampled points...\")\n", "        sample_dist = self.radius_norm / self.n_samples\n\t        z_vals = torch.linspace(0.0, 1.0, self.n_samples)\n\t        z_vals = near + (far - near) * z_vals[None, :]\n\t        dists = z_vals[..., 1:] - z_vals[..., :-1]\n\t        dists = torch.cat([dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        mid_z_vals = z_vals + dists * 0.5\n\t        mid_dists = mid_z_vals[..., 1:] - mid_z_vals[..., :-1]\n\t        pts = rays_o[:, None, :] + rays_d[:, None, :] * mid_z_vals[..., :, None]  # n_rays, n_samples, 3\n\t        dir_pts = f\"{self.base_exp_dir}/points\"\n\t        os.makedirs(dir_pts, exist_ok=True)\n", "        path_pts = f\"{dir_pts}/{self.iter_step:08d}_{self.curr_img_idx}.ply\"\n\t        pts = pts.reshape(-1, 3)\n\t        GeoUtils.save_points(path_pts, pts.detach().cpu().numpy())\n\t    def validate_weights(self, weight):\n\t        dir_weights = os.path.join(self.base_exp_dir, \"weights\")\n\t        os.makedirs(dir_weights, exist_ok=True)\n\t    def validate_image_nerf(self, idx=-1, resolution_level=-1, save_render = False):\n\t        print('Validate:')\n\t        ic(self.iter_step, idx)\n\t        if idx < 0:\n", "            idx = np.random.randint(self.dataset.n_images)\n\t        if resolution_level < 0:\n\t            resolution_level = self.validate_resolution_level\n\t        rays_o, rays_d = self.dataset.gen_rays_at(idx, resolution_level=resolution_level)\n\t        H, W, _ = rays_o.shape\n\t        rays_o = rays_o.reshape(-1, 3).split(self.batch_size)\n\t        rays_d = rays_d.reshape(-1, 3).split(self.batch_size)\n\t        out_rgb_fine = []\n\t        for rays_o_batch, rays_d_batch in zip(rays_o, rays_d):\n\t            near, far = torch.zeros(len(rays_o_batch), 1), 1 * torch.ones(len(rays_o_batch), 1)\n", "            if self.dataset_type == 'dtu':\n\t                near, far = self.dataset.near_far_from_sphere(rays_o_batch, rays_d_batch)\n\t            elif self.dataset_type == 'indoor':\n\t                near, far = torch.zeros(len(rays_o_batch), 1), 1 * torch.ones(len(rays_o_batch), 1)\n\t            else:\n\t                NotImplementedError\n\t            background_rgb = torch.ones([1, 3]) if self.use_white_bkgd else None\n\t            render_out = self.renderer.render(rays_o_batch,\n\t                                              rays_d_batch,\n\t                                              near,\n", "                                              far,\n\t                                              background_rgb=background_rgb)\n\t            def feasible(key): return ((key in render_out) and (render_out[key] is not None))\n\t            if feasible('color_fine'):\n\t                out_rgb_fine.append(render_out['color_fine'].detach().cpu().numpy())\n\t            del render_out\n\t        img_fine = None\n\t        if len(out_rgb_fine) > 0:\n\t            img_fine = (np.concatenate(out_rgb_fine, axis=0).reshape([H, W, 3, -1]) * 256).clip(0, 255)\n\t        os.makedirs(os.path.join(self.base_exp_dir, 'validations_fine'), exist_ok=True)\n", "        os.makedirs(os.path.join(self.base_exp_dir, 'image_render'), exist_ok=True)\n\t        for i in range(img_fine.shape[-1]):\n\t            if len(out_rgb_fine) > 0:\n\t                cv.imwrite(os.path.join(self.base_exp_dir,\n\t                                        'validations_fine',\n\t                                        f'{self.iter_step:08d}_{self.dataset.vec_stem_files[idx]}_reso{resolution_level}.png'), # '{:0>8d}_{}_{}.png'.format(self.iter_step, i, self.dataset.vec_stem_files[idx])),\n\t                           np.concatenate([img_fine[..., i],\n\t                                           self.dataset.image_at(idx, resolution_level=resolution_level)]))\n\t                if save_render:\n\t                    cv.imwrite(os.path.join(self.base_exp_dir,\n", "                                            'image_render',\n\t                                            f'{self.iter_step:08d}_{self.dataset.vec_stem_files[idx]}_reso{resolution_level}.png'), # '{:0>8d}_{}_{}.png'.format(self.iter_step, i, self.dataset.vec_stem_files[idx])),\n\t                            img_fine[..., i])\n\t    def validate_mesh_nerf(self, world_space=False, resolution=128, threshold=25.0):\n\t        logging.info(f'Validate mesh (Resolution:{resolution} Threhold: {threshold})....')\n\t        bound_min = torch.tensor(self.dataset.bbox_min, dtype=torch.float32) #/ self.sdf_network_fine.scale\n\t        bound_max = torch.tensor(self.dataset.bbox_max, dtype=torch.float32) # / self.sdf_network_fine.scale\n\t        vertices, triangles, sdf =\\\n\t            self.renderer.extract_geometry(bound_min, bound_max, resolution=resolution, threshold=threshold)\n\t        os.makedirs(os.path.join(self.base_exp_dir, 'meshes'), exist_ok=True)\n", "        os.makedirs(os.path.join(self.base_exp_dir, 'contour'), exist_ok=True)\n\t        for ax in ['x', 'y', 'z']:\n\t            path_contour_img = os.path.join(self.base_exp_dir, 'contour', f'{ax}_{self.iter_step:0>8d}_reso{resolution}.png')\n\t            if ax == 'x':\n\t                GeoUtils.visualize_sdf_contour(path_contour_img, -sdf[int(sdf.shape[0]/2), :,:], levels=[i-50 for i in range(0, 100, 10)])\n\t            if ax == 'y':\n\t                GeoUtils.visualize_sdf_contour(path_contour_img, -sdf[:, int(sdf.shape[1]/2),:], levels=[i-50 for i in range(0, 100, 10)])\n\t            if ax == 'z':\n\t                GeoUtils.visualize_sdf_contour(path_contour_img, -sdf[:,:, int(sdf.shape[2]/2)], levels=[i-50 for i in range(0, 100, 10)])\n\t        path_mesh_gt = IOUtils.find_target_file(self.dataset.data_dir, '_vh_clean_2_trans.ply')\n", "        if world_space:\n\t            path_trans_n2w = f\"{self.conf['dataset']['data_dir']}/trans_n2w.txt\"\n\t            print(f'LOad normalization matrix: {path_trans_n2w}')\n\t            scale_mat = self.dataset.scale_mats_np[0]\n\t            if IOUtils.checkExistence(path_trans_n2w):\n\t                scale_mat = np.loadtxt(path_trans_n2w)\n\t            vertices = vertices * scale_mat[0, 0] + scale_mat[:3, 3][None]\n\t            path_mesh = os.path.join(self.base_exp_dir, 'meshes', f'{self.iter_step:0>8d}_reso{resolution}_thres{int(threshold):03d}_{self.scan_name}_world.ply')\n\t            path_mesh_gt = IOUtils.find_target_file(self.dataset.data_dir, '_vh_clean_2.ply')\n\t        mesh = trimesh.Trimesh(vertices, triangles)\n", "        mesh.export(path_mesh)\n\t        path_mesh_clean = IOUtils.add_file_name_suffix(path_mesh, '_clean')\n\t        if path_mesh_gt:\n\t            print(f'Clena points outside bbox')\n\t            GeoUtils.clean_mesh_points_outside_bbox(path_mesh_clean, path_mesh, path_mesh_gt, scale_bbox = 1.1, check_existence=False)\n\t        mesh = trimesh.Trimesh(vertices, triangles)\n\t        mesh.export(path_mesh_clean)\n\t    def save_accumulated_results(self, idx=-1):\n\t        if idx < 0:\n\t            idx = np.random.randint(self.dataset.n_images)\n", "        logging.info(f'Save confidence: idx {idx}...')\n\t        accum_results = {}\n\t        accum_results['confidence'] = self.dataset.confidence_accum[idx]\n\t        b_accum_all_data = False\n\t        if b_accum_all_data:\n\t            accum_results['color'] = self.dataset.colors_accum[idx].cpu().numpy() * 255\n\t            # accum_results['normal'] = self.dataset.normals_accum[idx].cpu().numpy()\n\t            accum_results['depth'] = self.dataset.depths_accum[idx].cpu().numpy()\n\t        img_gt = self.dataset.images[idx].cpu().numpy()\n\t        lis_imgs = []\n", "        for key in accum_results:\n\t            if len(accum_results[key]) == 0:\n\t                continue\n\t            img_temp = accum_results[key].squeeze()\n\t            if key == 'normal':\n\t                img_temp = (((img_temp + 1) * 0.5).clip(0,1) * 255).astype(np.uint8)\n\t            if key in ['depth']:\n\t                img_temp = img_temp / (np.max(img_temp)+1e-6) * 255\n\t            if key in ['confidence', 'samples']:\n\t                if key == 'confidence':\n", "                    img_temp2 = ImageUtils.convert_gray_to_cmap(img_temp.clip(0,1), vmax=1.0)\n\t                    lis_imgs.append(img_temp2)\n\t                    img_temp = img_temp.clip(0,1) * 255\n\t                if key == 'samples':\n\t                    img_temp = ImageUtils.convert_gray_to_cmap(img_temp)\n\t            cv.putText(img_temp, key,  (img_temp.shape[1]-100, img_temp.shape[0]-20), \n\t                fontFace= cv.FONT_HERSHEY_SIMPLEX, \n\t                fontScale = 0.5, \n\t                color = (0, 0, 255), \n\t                thickness = 2)\n", "            accum_results[key] = img_temp\n\t            lis_imgs.append(img_temp)\n\t        # save images\n\t        dir_accum = os.path.join(self.base_exp_dir, 'images_accum')\n\t        os.makedirs(dir_accum, exist_ok=True)\n\t        ImageUtils.write_image_lis(f'{dir_accum}/{self.iter_step:0>8d}_{idx}.png', \n\t                                        [img_gt] + lis_imgs)\n\t        if self.iter_step ==  self.end_iter:\n\t            dir_accum_npz = f'{self.base_exp_dir}/checkpoints/npz'\n\t            os.makedirs(dir_accum_npz, exist_ok=True)\n", "            np.savez(f'{dir_accum_npz}/confidence_accum_{self.iter_step:08d}.npz', self.dataset.confidence_accum)\n\t            np.savez(f'{dir_accum_npz}/samples_accum_{self.iter_step:08d}.npz', self.dataset.samples_accum.cpu().numpy())\n\t            b_accum_all_data = False\n\t            if b_accum_all_data:\n\t                np.savez(f'{dir_accum_npz}/colors_accum_{self.iter_step:08d}.npz', self.dataset.colors_accum.cpu().numpy())\n\t                np.savez(f'{dir_accum_npz}/depths_accum_{self.iter_step:08d}.npz', self.dataset.depths_accum.cpu().numpy())\n\t    def initialize_accumulated_results(self, mode = 'MODEL', iter_step_npz = None, resolution_level = 2):\n\t        # For cache rendered depths and normals\n\t        self.dataset.confidence_accum = np.ones_like(self.dataset.masks_np, dtype=np.float32)\n\t        b_accum_all_data = False\n", "        if b_accum_all_data:\n\t            self.dataset.colors_accum = torch.zeros_like(self.dataset.images, dtype=torch.float32).cuda()\n\t            self.depths_accum = torch.zeros_like(self.masks, dtype=torch.float32).cpu()\n\t        self.dataset.normals_accum = torch.zeros_like(self.dataset.images, dtype=torch.float32).cpu()  # save gpu memory\n\t        self.dataset.points_accum = torch.zeros_like(self.dataset.images, dtype=torch.float32).cpu()  # world coordinates\n\t        if mode == 'model':\n\t            # compute accumulated results from pretrained model\n\t            logging.info(f'Start initializeing accumulated results....[mode: {mode}; Reso: {resolution_level}]')\n\t            self.dataset.render_difference_accum = np.ones_like(self.dataset.masks_np, dtype=np.float32)\n\t            t1 = datetime.now()\n", "            num_neighbors_half = 0\n\t            for idx in tqdm(range(num_neighbors_half, self.dataset.n_images-num_neighbors_half)):\n\t                confidence, color_peak, normal_peak, depth_peak, points_peak, _ = self.validate_image(idx, resolution_level=resolution_level, save_peak_value=True)\n\t                H, W = confidence.shape\n\t                resize_arr = lambda in_arr : cv.resize(in_arr, (W*resolution_level, H*resolution_level), interpolation=cv.INTER_NEAREST) if resolution_level > 1 else in_arr\n\t                self.dataset.confidence_accum[idx] = resize_arr(confidence)\n\t                b_accum_all_data = False\n\t                if b_accum_all_data:\n\t                    self.dataset.colors_accum[idx]     = torch.from_numpy(resize_arr(color_peak)).cuda()\n\t            logging.info(f'Consumed time: {IOUtils.get_consumed_time(t1)/60:.02f} min.') \n", "            dir_accum_npz = f'{self.base_exp_dir}/checkpoints/npz'\n\t            os.makedirs(dir_accum_npz, exist_ok=True)\n\t            np.savez(f'{dir_accum_npz}/confidence_accum_{self.iter_step:08d}.npz', self.dataset.confidence_accum)\n\t        elif mode == 'npz':\n\t            # load accumulated results from files\n\t            logging.info(f'Start initializeing accumulated results....[mode: {mode}; Reso: {resolution_level}]')\n\t            iter_step_npz = int(iter_step_npz)\n\t            assert iter_step_npz is not None\n\t            dir_accum_npz = f'{self.base_exp_dir}/checkpoints/npz'\n\t            self.dataset.confidence_accum = np.load(f'{dir_accum_npz}/confidence_accum_{int(iter_step_npz):08d}.npz')['arr_0']\n", "            b_accum_all_data = False\n\t            if b_accum_all_data:\n\t                self.dataset.colors_accum =     torch.from_numpy(np.load(f'{dir_accum_npz}/colors_accum_{iter_step_npz:08d}.npz')['arr_0']).cuda()\n\t                self.dataset.depths_accum =     torch.from_numpy(np.load(f'{dir_accum_npz}/depths_accum_{iter_step_npz:08d}.npz')['arr_0']).cuda()\n\t        else:\n\t            logging.info('Initialize all accum data to ones.')\n\tif __name__ == '__main__':\n\t    torch.set_default_tensor_type('torch.cuda.FloatTensor')\n\t    FORMAT = \"[%(filename)s:%(lineno)s] %(message)s\"\n\t    logging.basicConfig(level=logging.INFO, format=FORMAT)\n", "    parser = argparse.ArgumentParser()\n\t    parser.add_argument('--conf', type=str, default='./confs/base.conf')\n\t    parser.add_argument('--mode', type=str, default='train')\n\t    parser.add_argument('--model_type', type=str, default='')\n\t    parser.add_argument('--threshold', type=float, default=0.0)\n\t    parser.add_argument('--is_continue', default=False, action=\"store_true\")\n\t    parser.add_argument('--gpu', type=int, default=0)\n\t    parser.add_argument('--checkpoint_id', type=int, default=-1)\n\t    parser.add_argument('--mc_reso', type=int, default=512, help='Marching cube resolution')\n\t    parser.add_argument('--reset_var', action= 'store_true', help='Reset variance for validate_iamge()' )\n", "    parser.add_argument('--nvs', action= 'store_true', help='Novel view synthesis' )\n\t    parser.add_argument('--save_render_peak', action= 'store_true', help='Novel view synthesis' )\n\t    parser.add_argument('--scene_name', type=str, default='', help='Scene or scan name')\n\t    args = parser.parse_args()\n\t    torch.cuda.set_device(args.gpu)\n\t    runner = Runner(args.conf, args.scene_name, args.mode, args.model_type, args.is_continue, args.checkpoint_id)\n\t    if args.mode == 'train':\n\t        runner.train()\n\t    elif args.mode == 'validate_mesh':\n\t        if runner.model_type == 'neus':\n", "            t1= datetime.now()\n\t            runner.validate_mesh(world_space=True, resolution=args.mc_reso, threshold=args.threshold)\n\t            logging.info(f\"[Validate mesh] Consumed time (Step: {runner.iter_step}; MC resolution: {args.mc_reso}): {IOUtils.get_consumed_time(t1):.02f}(s)\")\n\t        elif runner.model_type == 'nerf':\n\t            thres = args.threshold\n\t            t1= datetime.now()\n\t            runner.validate_mesh_nerf(world_space=True, resolution=args.mc_reso, threshold=thres)\n\t            logging.info(f\"[Validate mesh] Consumed time (MC resolution: {args.mc_reso} Threshold: {thres}): {IOUtils.get_consumed_time(t1):.02f}(s)\")\n\t    elif args.mode.startswith('validate_image'):\n\t        if runner.model_type == 'neus':\n", "            for i in range(0, runner.dataset.n_images, 2):\n\t                t1 = datetime.now()\n\t                runner.validate_image(i, resolution_level=1, \n\t                                            save_normalmap_npz=args.save_render_peak, \n\t                                            save_peak_value=True,\n\t                                            save_image_render=args.nvs)\n\t                logging.info(f\"validating image time is : {(datetime.now()-t1).total_seconds()}\")\n\t        elif runner.model_type == 'nerf':\n\t            for i in range(0, runner.dataset.n_images, 2):\n\t                t1 = datetime.now()\n", "                runner.validate_image_nerf(i, resolution_level=1, save_render=True)\n\t                logging.info(f\"validating image time is : {(datetime.now()-t1).total_seconds()}\")\n\t    elif args.mode == 'validate_fields':\n\t        runner.validate_fields()"]}
{"filename": "exp_evaluation.py", "chunked_list": ["import os, argparse, logging\n\tfrom datetime import datetime\n\timport numpy as np\n\t# import preprocess.depthneus_data  as depthneus_data\n\timport evaluation.EvalScanNet as EvalScanNet\n\tfrom evaluation.renderer import render_depthmaps_pyrender\n\timport utils.utils_geometry as GeoUtils\n\timport utils.utils_image  as ImageUtils\n\timport utils.utils_io as IOUtils\n\timport utils.utils_normal as NormalUtils\n", "from confs.path import lis_name_scenes\n\tif __name__ == '__main__':\n\t    np.set_printoptions(precision=3)\n\t    np.set_printoptions(suppress=True)\n\t    FORMAT = \"[%(filename)s:%(lineno)s] %(message)s\"\n\t    logging.basicConfig(level=logging.INFO, format=FORMAT)\n\t    parser = argparse.ArgumentParser()\n\t    parser.add_argument('--mode', type=str, default='eval_3D_mesh_metrics')\n\t    args = parser.parse_args()\n\t    if args.mode == 'eval_3D_mesh_metrics':\n", "        dir_dataset = './dataset/indoor'\n\t        path_intrin = f'{dir_dataset}/intrinsic_depth.txt'\n\t        name_baseline = 'neus' # manhattansdf depthneus\n\t        exp_name = name_baseline\n\t        eval_threshold = 0.05\n\t        check_existence = True\n\t        dir_results_baseline = f'./exps/indoor'\n\t        metrics_eval_all = []\n\t        for scene_name in lis_name_scenes:\n\t            logging.info(f'\\n\\nProcess: {scene_name}')\n", "            path_mesh_pred = f'{dir_results_baseline}/{name_baseline}/{scene_name}.ply'\n\t            metrics_eval =  EvalScanNet.evaluate_3D_mesh(path_mesh_pred, scene_name, dir_dataset = './dataset/indoor',\n\t                                                                eval_threshold = 0.05, reso_level = 2, \n\t                                                                check_existence = check_existence)\n\t            metrics_eval_all.append(metrics_eval)\n\t        metrics_eval_all = np.array(metrics_eval_all)\n\t        str_date = datetime.now().strftime(\"%Y-%m-%d_%H-%M\")\n\t        path_log = f'{dir_results_baseline}/eval_{name_baseline}_thres{eval_threshold}_{str_date}.txt'\n\t        EvalScanNet.save_evaluation_results_to_latex(path_log, \n\t                                                        header = f'{exp_name}\\n                     Accu.      Comp.      Prec.     Recall     F-score \\n', \n", "                                                        results = metrics_eval_all, \n\t                                                        names_item = lis_name_scenes, \n\t                                                        save_mean = True, \n\t                                                        mode = 'w')\n\t    if args.mode == 'eval_mesh_2D_metrices':\n\t        dir_dataset = 'dataset/indoor'\n\t        path_intrin = f'{dir_dataset}/intrinsic_depth.txt'\n\t        name_baseline = 'neus'\n\t        eval_type_baseline = 'mesh'\n\t        scale_depth = False\n", "        dir_results_baseline = f'./exps/evaluation/results_baselines/{name_baseline}'\n\t        results_all =  []\n\t        for scene_name in lis_name_scenes:\n\t            # scene_name += '_corner'\n\t            print(f'Processing {scene_name}...')\n\t            dir_scan = f'{dir_dataset}/{scene_name}'\n\t            if eval_type_baseline == 'mesh':\n\t                # use rendered depth map\n\t                path_mesh_baseline =  f'{dir_results_baseline}/{scene_name}.ply'\n\t                pred_depths = render_depthmaps_pyrender(path_mesh_baseline, path_intrin, \n", "                                                            dir_poses=f'{dir_scan}/pose')\n\t                img_names = IOUtils.get_files_stem(f'{dir_scan}/depth', '.png')\n\t            elif eval_type_baseline == 'depth':\n\t                dir_depth_baseline =  f'{dir_results_baseline}/{scene_name}'\n\t                pred_depths = GeoUtils.read_depth_maps_np(dir_depth_baseline)\n\t                img_names = IOUtils.get_files_stem(dir_depth_baseline, '.npy')\n\t            # evaluation\n\t            dir_gt_depth = f'{dir_scan}/depth'\n\t            gt_depths, _ = EvalScanNet.load_gt_depths(img_names, dir_gt_depth)\n\t            err_gt_depth_scale = EvalScanNet.depth_evaluation(gt_depths, pred_depths, dir_results_baseline, scale_depth=scale_depth)\n", "            results_all.append(err_gt_depth_scale)\n\t        results_all = np.array(results_all)\n\t        print('All results: ', results_all)\n\t        count = 0\n\t        str_date = datetime.now().strftime(\"%Y-%m-%d_%H-%M\")\n\t        path_log_all = f'./exps/evaluation/results_{name_baseline}-scale_{scale_depth}_{eval_type_baseline}_{str_date}.txt'\n\t        EvalScanNet.save_evaluation_results_to_latex(path_log_all, header = f'{str_date}\\n\\n',  mode = 'a')\n\t        precision = 3\n\t        results_all = np.round(results_all, decimals=precision)\n\t        EvalScanNet.save_evaluation_results_to_latex(path_log_all, \n", "                                                        header = f'{name_baseline}', \n\t                                                        results = results_all, \n\t                                                        names_item = lis_name_scenes, \n\t                                                        save_mean = True, \n\t                                                        mode = 'a',\n\t                                                        precision = precision)\n\t    if args.mode == 'evaluate_normal':\n\t        # compute normal errors\n\t        exp_name = 'exp_depthneus'\n\t        name_normal_folder = 'normal_render'\n", "        dir_root_dataset = './dataset/indoor'\n\t        dir_root_normal_gt = '../TiltedImageSurfaceNormal/datasets/scannet-frames'\n\t        err_neus_all, err_pred_all = [], []\n\t        num_imgs_eval_all = 0\n\t        for scene_name in lis_name_scenes:\n\t            # scene_name = 'scene0085_00'\n\t            print(f'Process: {scene_name}')\n\t            dir_normal_neus = f'./exps/indoor/neus/{scene_name}/{exp_name}/{name_normal_folder}'\n\t            dir_normal_pred = f'{dir_root_dataset}/{scene_name}/pred_normal' \n\t            dir_poses = f'{dir_root_dataset}/{scene_name}/pose' \n", "            dir_normal_gt = f'{dir_root_normal_gt}/{scene_name}'\n\t            error_neus, error_pred, num_imgs_eval = NormalUtils.evauate_normal(dir_normal_neus, dir_normal_pred, dir_normal_gt, dir_poses)\n\t            err_neus_all.append(error_neus)\n\t            err_pred_all.append(error_pred)\n\t            num_imgs_eval_all += num_imgs_eval\n\t        error_neus_all = np.concatenate(err_neus_all).reshape(-1)\n\t        err_pred_all = np.concatenate(err_pred_all).reshape(-1)\n\t        metrics_neus = NormalUtils.compute_normal_errors_metrics(error_neus_all)\n\t        metrics_pred = NormalUtils.compute_normal_errors_metrics(err_pred_all)\n\t        NormalUtils.log_normal_errors(metrics_neus, first_line='metrics_neus fianl')\n", "        NormalUtils.log_normal_errors(metrics_pred, first_line='metrics_pred final')\n\t        print(f'Total evaluation images: {num_imgs_eval_all}')\n\t    if args.mode == 'evaluate_nvs':\n\t           # compute normal errors\n\t        name_img_folder = 'image_render'\n\t        sample_interval = 1\n\t        exp_name_nerf = 'exp_nerf'\n\t        exp_name_depthneus = 'exp_depthneus'\n\t        exp_name_neus  = 'exp_neus'\n\t        evals_nvs_all ={\n", "            'nerf': exp_name_nerf,\n\t            'neus': exp_name_neus,\n\t            'depthneus': exp_name_depthneus\n\t        }\n\t        psnr_all_methods = {}\n\t        psnr_imgs = []\n\t        psnr_imgs_stem = []\n\t        np.set_printoptions(precision=3)\n\t        for key in evals_nvs_all:\n\t            exp_name = evals_nvs_all[key]\n", "            model_type = 'nerf' if key == 'nerf' else 'neus'\n\t            print(f\"Start to eval: {key}. {exp_name}\")\n\t            err_neus_all, err_pred_all = [], []\n\t            num_imgs_eval_all = 0\n\t            psnr_scenes_all = []\n\t            psnr_mean_all = []\n\t            for scene_name in lis_name_scenes:\n\t                # scene_name = 'scene0085_00'\n\t                scene_name = scene_name + '_nvs'\n\t                print(f'Process: {scene_name}')\n", "                dir_img_gt = f'./dataset/indoor/{scene_name}/image'\n\t                dir_img_neus = f'./exps/indoor/{model_type}/{scene_name}/{exp_name}/{name_img_folder}'\n\t                psnr_scene, vec_stem_eval = ImageUtils.eval_imgs_psnr(dir_img_neus, dir_img_gt, sample_interval)\n\t                print(f'PSNR: {scene_name} {psnr_scene.mean()}  {psnr_scene.shape}')\n\t                psnr_scenes_all.append(psnr_scene)\n\t                psnr_imgs.append(psnr_scene)\n\t                psnr_imgs_stem.append(vec_stem_eval)\n\t                psnr_mean_all.append(psnr_scene.mean())\n\t                # input(\"anything to continue\")\n\t            psnr_scenes_all = np.concatenate(psnr_scenes_all)\n", "            psnr_mean_all = np.array(psnr_mean_all)\n\t            print(f'\\n\\n Mean of scnes: {psnr_mean_all.mean()}. PSNR of all scenes: {psnr_mean_all} \\n mean of images:{psnr_scenes_all.mean()} image numbers: {len(psnr_scenes_all)} ')\n\t            psnr_all_methods[key] = (psnr_scenes_all.mean(), psnr_mean_all.mean(),  psnr_mean_all)\n\t        # psnr_imgs = vec_stem_eval + psnr_imgs\n\t        path_log_temp = f'./exps/indoor/evaluation/nvs/evaluation_temp_{lis_name_scenes[0]}.txt'\n\t        flog_temp = open(path_log_temp, 'w')\n\t        for i in range(len(vec_stem_eval)):\n\t            try:\n\t                flog_temp.write(f'{psnr_imgs_stem[0][i][9:13]}  {psnr_imgs_stem[1][i][9:13]}  {psnr_imgs_stem[2][i][9:13]}: {psnr_imgs[0][i]:.1f}:  {psnr_imgs[1][i]:.1f}  {psnr_imgs[2][i]:.1f}\\n')\n\t            except Exception:\n", "                print(f'Error: skip {vec_stem_eval[i]}')\n\t                continue\n\t        flog_temp.close()\n\t        input('Continue?')\n\t        print(f'Finish NVS evaluation')\n\t        # print eval information\n\t        path_log = f'./exps/indoor/evaluation/nvs/evaluation.txt'\n\t        flog_nvs = open(path_log, 'a')\n\t        flog_nvs.write(f'sample interval: {sample_interval}. Scenes number: {len(lis_name_scenes)}. Scene names: {lis_name_scenes}\\n\\n')\n\t        flog_nvs.write(f'Mean_img  mean_scenes  scenes-> \\n')\n", "        for key in psnr_all_methods:\n\t            print(f'[{key}] Mean of all images: {psnr_all_methods[key][0]}. Mean of scenes: {psnr_all_methods[key][1]} \\n Scenes: {psnr_all_methods[key][2]}\\n')\n\t            flog_nvs.write(f'{key:10s} {psnr_all_methods[key][0]:.03f} {psnr_all_methods[key][1]:.03f}. {psnr_all_methods[key][2]}.\\n')\n\t        flog_nvs.write(f'Images number: {len(psnr_scenes_all)}\\n')\n\t        flog_nvs.close()\n\t    print('Done')\n"]}
{"filename": "evaluation/EvalScanNet.py", "chunked_list": ["# borrowed from nerfingmvs and neuralreon\n\timport os, cv2,logging\n\timport numpy as np\n\timport open3d as o3d\n\timport utils.utils_geometry as GeoUtils\n\timport utils.utils_io as IOUtils\n\tdef load_gt_depths(image_list, datadir, H=None, W=None):\n\t    depths = []\n\t    masks = []\n\t    for image_name in image_list:\n", "        frame_id = image_name.split('.')[0]\n\t        depth_path = os.path.join(datadir, '{:04d}.png'.format(int(frame_id)))\n\t        depth = cv2.imread(depth_path, cv2.IMREAD_UNCHANGED)\n\t        depth = depth.astype(np.float32) / 1000\n\t        if H is not None:\n\t            mask = (depth > 0).astype(np.uint8)\n\t            depth_resize = cv2.resize(depth, (W, H), interpolation=cv2.INTER_NEAREST)\n\t            mask_resize = cv2.resize(mask, (W, H), interpolation=cv2.INTER_NEAREST)\n\t            depths.append(depth_resize)\n\t            masks.append(mask_resize > 0.5)\n", "        else:\n\t            depths.append(depth)\n\t            masks.append(depth > 0)\n\t    return np.stack(depths), np.stack(masks)\n\tdef load_depths_npy(image_list, datadir, H=None, W=None):\n\t    depths = []\n\t    for image_name in image_list:\n\t        frame_id = image_name.split('.')[0]\n\t        depth_path = os.path.join(datadir, '{}_depth.npy'.format(frame_id))\n\t        if not os.path.exists(depth_path):\n", "            depth_path = os.path.join(datadir, '{}.npy'.format(frame_id))\n\t        depth = np.load(depth_path)\n\t        if H is not None:\n\t            depth_resize = cv2.resize(depth, (W, H))\n\t            depths.append(depth_resize)\n\t        else:\n\t            depths.append(depth)\n\t    return np.stack(depths)\n\tdef compute_errors(gt, pred):\n\t    \"\"\"Computation of error metrics between predicted and ground truth depths\n", "    \"\"\"\n\t    thresh = np.maximum((gt / pred), (pred / gt))\n\t    a1 = (thresh < 1.25     ).mean()\n\t    a2 = (thresh < 1.25 ** 2).mean()\n\t    a3 = (thresh < 1.25 ** 3).mean()\n\t    rmse = (gt - pred) ** 2\n\t    rmse = np.sqrt(rmse.mean())\n\t    rmse_log = (np.log(gt) - np.log(pred)) ** 2\n\t    rmse_log = np.sqrt(rmse_log.mean())\n\t    abs_rel = np.mean(np.abs(gt - pred) / gt)\n", "    sq_rel = np.mean(((gt - pred) ** 2) / gt)\n\t    return abs_rel, sq_rel, rmse, rmse_log, a1, a2, a3\n\tdef depth_evaluation(gt_depths, pred_depths, savedir=None, pred_masks=None, min_depth=0.1, max_depth=20, scale_depth = False):\n\t    assert gt_depths.shape[0] == pred_depths.shape[0]\n\t    gt_depths_valid = []\n\t    pred_depths_valid = []\n\t    errors = []\n\t    num = gt_depths.shape[0]\n\t    for i in range(num):\n\t        gt_depth = gt_depths[i]\n", "        mask = (gt_depth > min_depth) * (gt_depth < max_depth)\n\t        gt_height, gt_width = gt_depth.shape[:2]\n\t        pred_depth = cv2.resize(pred_depths[i], (gt_width, gt_height))\n\t        if pred_masks is not None:\n\t            pred_mask = pred_masks[i]\n\t            pred_mask = cv2.resize(pred_mask.astype(np.uint8), (gt_width, gt_height)) > 0.5\n\t            mask = mask * pred_mask\n\t        if mask.sum() == 0:\n\t            continue\n\t        pred_depth = pred_depth[mask]\n", "        gt_depth = gt_depth[mask]\n\t        pred_depths_valid.append(pred_depth)\n\t        gt_depths_valid.append(gt_depth)\n\t    ratio = 1.0\n\t    if scale_depth:\n\t        ratio = np.median(np.concatenate(gt_depths_valid)) / \\\n\t                    np.median(np.concatenate(pred_depths_valid))\n\t    for i in range(len(pred_depths_valid)):\n\t        gt_depth = gt_depths_valid[i]\n\t        pred_depth = pred_depths_valid[i]\n", "        pred_depth *= ratio\n\t        pred_depth[pred_depth < min_depth] = min_depth\n\t        pred_depth[pred_depth > max_depth] = max_depth\n\t        errors.append(compute_errors(gt_depth, pred_depth))\n\t    mean_errors = np.array(errors).mean(0)\n\t    # print(\"\\n  \" + (\"{:>8} | \" * 7).format(\"abs_rel\", \"sq_rel\", \"rmse\", \"rmse_log\", \"a1\", \"a2\", \"a3\"))\n\t    print((\"&{: 8.3f}  \" * 7).format(*mean_errors.tolist()))\n\t    # print(\"\\n-> Done!\")\n\t    if savedir is not None:\n\t        with open(os.path.join(savedir, 'depth_evaluation.txt'), 'a+') as f:\n", "            if len(f.readlines()) == 0:\n\t                f.writelines((\"{:>8} | \" * 7).format(\"abs_rel\", \"sq_rel\", \"rmse\", \"rmse_log\", \"a1\", \"a2\", \"a3\") + '    scale_depth\\n')\n\t            f.writelines((\"&{: 8.3f}  \" * 7).format(*mean_errors.tolist()) + f\"    {scale_depth}   \\\\\\\\\")\n\t    return mean_errors\n\tdef save_evaluation_results(dir_log_eval, errors_mesh, name_exps, step_evaluation):\n\t    # save evaluation results to latex format\n\t    mean_errors_mesh = errors_mesh.mean(axis=0)     # 4*7\n\t    names_log = ['err_gt_mesh', 'err_gt_mesh_scale', 'err_gt_depth', 'err_gt_depth_scale']\n\t    dir_log_eval = f'{dir_log_eval}/{step_evaluation:08d}'\n\t    IOUtils.ensure_dir_existence(dir_log_eval)\n", "    for idx_errror_type in range(4):\n\t        with open(f'{dir_log_eval}/{names_log[idx_errror_type]}.txt', 'w') as f_log:\n\t            len_name = len(name_exps[0][0])\n\t            f_log.writelines(('No.' + ' '*np.max([0, len_name-len('   scene id')]) + '     scene id     ' + \"{:>8} | \" * 7).format(\"abs_rel\", \"sq_rel\", \"rmse\", \"rmse_log\", \"a1\", \"a2\", \"a3\") + '\\n')\n\t            for idx_scan in range(errors_mesh.shape[0]):\n\t                f_log.writelines((f'[{idx_scan}] {name_exps[idx_scan][0]} ' + (\"&{: 8.3f}  \" * 7).format(*errors_mesh[idx_scan, idx_errror_type, :].tolist())) + f\" \\\\\\ {name_exps[idx_scan][1]}\\n\")\n\t            f_log.writelines((' '*len_name + 'Mean' + \" &{: 8.3f} \" * 7).format(*mean_errors_mesh[idx_errror_type, :].tolist()) + \" \\\\\\ \\n\")\n\tdef evaluate_geometry_neucon(file_pred, file_trgt, threshold=.05, down_sample=.02):\n\t    \"\"\" Borrowed from NeuralRecon\n\t    Compute Mesh metrics between prediction and target.\n", "    Opens the Meshs and runs the metrics\n\t    Args:\n\t        file_pred: file path of prediction\n\t        file_trgt: file path of target\n\t        threshold: distance threshold used to compute precision/recal\n\t        down_sample: use voxel_downsample to uniformly sample mesh points\n\t    Returns:\n\t        Dict of mesh metrics\n\t    \"\"\"\n\t    def nn_correspondance(verts1, verts2):\n", "        \"\"\" for each vertex in verts2 find the nearest vertex in verts1\n\t        Args:\n\t            nx3 np.array's\n\t        Returns:\n\t            ([indices], [distances])\n\t        \"\"\"\n\t        indices = []\n\t        distances = []\n\t        if len(verts1) == 0 or len(verts2) == 0:\n\t            return indices, distances\n", "        pcd = o3d.geometry.PointCloud()\n\t        pcd.points = o3d.utility.Vector3dVector(verts1)\n\t        kdtree = o3d.geometry.KDTreeFlann(pcd)\n\t        for vert in verts2:\n\t            _, inds, dist = kdtree.search_knn_vector_3d(vert, 1)\n\t            indices.append(inds[0])\n\t            distances.append(np.sqrt(dist[0]))\n\t        return indices, distances\n\t    pcd_pred = GeoUtils.read_point_cloud(file_pred)\n\t    pcd_trgt = GeoUtils.read_point_cloud(file_trgt)\n", "    if down_sample:\n\t        pcd_pred = pcd_pred.voxel_down_sample(down_sample)\n\t        pcd_trgt = pcd_trgt.voxel_down_sample(down_sample)\n\t    verts_pred = np.asarray(pcd_pred.points)\n\t    verts_trgt = np.asarray(pcd_trgt.points)\n\t    _, dist1 = nn_correspondance(verts_pred, verts_trgt)  # para2->para1: dist1 is gt->pred\n\t    _, dist2 = nn_correspondance(verts_trgt, verts_pred)\n\t    dist1 = np.array(dist1)\n\t    dist2 = np.array(dist2)\n\t    precision = np.mean((dist2 < threshold).astype('float'))\n", "    recal = np.mean((dist1 < threshold).astype('float'))\n\t    fscore = 2 * precision * recal / (precision + recal)\n\t    metrics = {'dist1': np.mean(dist2),  # pred->gt\n\t               'dist2': np.mean(dist1),  # gt -> pred\n\t               'prec': precision,\n\t               'recal': recal,\n\t               'fscore': fscore,\n\t               }\n\t    # plot graph\n\t    # if path_fscore_curve:\n", "    #     EvalUtils.draw_figure_fscore(path_fscore_curve, threshold, dist2, dist1, plot_stretch=5)\n\t    metrics = np.array([np.mean(dist2), np.mean(dist1), precision, recal, fscore])\n\t    logging.info(f'{file_pred.split(\"/\")[-1]}: {metrics}')\n\t    return metrics\n\tdef evaluate_3D_mesh(path_mesh_pred, scene_name, dir_dataset = './dataset/indoor',\n\t                            eval_threshold = 0.05, reso_level = 2.0, \n\t                            check_existence = True):\n\t    '''Evaluate geometry quality of neus using Precison, Recall and F-score.\n\t    '''\n\t    path_intrin = f'{dir_dataset}/intrinsic_depth.txt'\n", "    target_img_size = (640, 480)\n\t    dir_scan = f'{dir_dataset}/{scene_name}'\n\t    dir_poses = f'{dir_scan}/pose'\n\t    # dir_images = f'{dir_scan}/image'\n\t    path_mesh_gt = f'{dir_dataset}/{scene_name}/{scene_name}_vh_clean_2.ply'\n\t    path_mesh_gt_clean = IOUtils.add_file_name_suffix(path_mesh_gt, '_clean')\n\t    path_mesh_gt_2dmask = f'{dir_dataset}/{scene_name}/{scene_name}_vh_clean_2_2dmask.npz'\n\t    # (1) clean GT mesh\n\t    GeoUtils.clean_mesh_faces_outside_frustum(path_mesh_gt_clean, path_mesh_gt, \n\t                                                path_intrin, dir_poses, \n", "                                                target_img_size, reso_level=reso_level,\n\t                                                check_existence = check_existence)\n\t    GeoUtils.generate_mesh_2dmask(path_mesh_gt_2dmask, path_mesh_gt_clean, \n\t                                                path_intrin, dir_poses, \n\t                                                target_img_size, reso_level=reso_level,\n\t                                                check_existence = check_existence)\n\t    # for fair comparison\n\t    GeoUtils.clean_mesh_faces_outside_frustum(path_mesh_gt_clean, path_mesh_gt, \n\t                                                path_intrin, dir_poses, \n\t                                                target_img_size, reso_level=reso_level,\n", "                                                path_mask_npz=path_mesh_gt_2dmask,\n\t                                                check_existence = check_existence)\n\t    # (2) clean predicted mesh\n\t    path_mesh_pred_clean_bbox = IOUtils.add_file_name_suffix(path_mesh_pred, '_clean_bbox')\n\t    path_mesh_pred_clean_bbox_faces = IOUtils.add_file_name_suffix(path_mesh_pred, '_clean_bbox_faces')\n\t    path_mesh_pred_clean_bbox_faces_mask = IOUtils.add_file_name_suffix(path_mesh_pred, '_clean_bbox_faces_mask')\n\t    GeoUtils.clean_mesh_points_outside_bbox(path_mesh_pred_clean_bbox, path_mesh_pred, path_mesh_gt,\n\t                                                scale_bbox=1.1,\n\t                                                check_existence = check_existence)\n\t    GeoUtils.clean_mesh_faces_outside_frustum(path_mesh_pred_clean_bbox_faces, path_mesh_pred_clean_bbox, \n", "                                                    path_intrin, dir_poses, \n\t                                                    target_img_size, reso_level=reso_level,\n\t                                                    check_existence = check_existence)\n\t    GeoUtils.clean_mesh_points_outside_frustum(path_mesh_pred_clean_bbox_faces_mask, path_mesh_pred_clean_bbox_faces, \n\t                                                    path_intrin, dir_poses, \n\t                                                    target_img_size, reso_level=reso_level,\n\t                                                    path_mask_npz=path_mesh_gt_2dmask,\n\t                                                    check_existence = check_existence)\n\t    path_eval = path_mesh_pred_clean_bbox_faces_mask \n\t    metrices_eval = evaluate_geometry_neucon(path_eval, path_mesh_gt_clean, \n", "                                                        threshold=eval_threshold, down_sample=.02) #f'{dir_eval_fig}/{scene_name}_step{iter_step:06d}_thres{eval_threshold}.png')\n\t    return metrices_eval\n\tdef save_evaluation_results_to_latex(path_log, \n\t                                        header = '                     Accu.      Comp.      Prec.     Recall     F-score \\n', \n\t                                        results = None, \n\t                                        names_item = None, \n\t                                        save_mean = None, \n\t                                        mode = 'w',\n\t                                        precision = 3):\n\t    '''Save evaluation results to txt in latex mode\n", "    Args:\n\t        header:\n\t            for F-score: '                     Accu.      Comp.      Prec.     Recall     F-score \\n'\n\t        results:\n\t            narray, N*M, N lines with M metrics\n\t        names_item:\n\t            N*1, item name for each line\n\t        save_mean: \n\t            whether calculate the mean value for each metric\n\t        mode:\n", "            write mode, default 'w'\n\t    '''\n\t    # save evaluation results to latex format\n\t    with open(path_log, mode) as f_log:\n\t        if header:\n\t            f_log.writelines(header)\n\t        if results is not None:\n\t            num_lines, num_metrices = results.shape\n\t            if names_item is None:\n\t                names_item = np.arange(results.shape[0])\n", "            for idx in range(num_lines):\n\t                f_log.writelines((f'{names_item[idx]}    ' + (\"&{: 8.3f}  \" * num_metrices).format(*results[idx, :].tolist())) + \" \\\\\\ \\n\")\n\t        if save_mean:\n\t            mean_results = results.mean(axis=0)     # 4*7\n\t            mean_results = np.round(mean_results, decimals=precision)\n\t            f_log.writelines(( '       Mean    ' + \" &{: 8.3f} \" * num_metrices).format(*mean_results[:].tolist()) + \" \\\\\\ \\n\")\n"]}
{"filename": "evaluation/renderer.py", "chunked_list": ["# Copyright 2020 Magic Leap, Inc.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n", "#  Originating Author: Zak Murez (zak.murez.com)\n\t# Borrowed from Atlas\n\timport numpy as np\n\timport trimesh, pyrender\n\tfrom tqdm import tqdm\n\tfrom skimage import measure\n\tfrom matplotlib.cm import get_cmap as colormap\n\timport utils.utils_geometry as GeoUtils\n\tclass Renderer():\n\t    \"\"\"Borrowed from Atlas\n", "    OpenGL mesh renderer \n\t    Used to render depthmaps from a mesh for 2d evaluation\n\t    \"\"\"\n\t    def __init__(self, height=480, width=640):\n\t        self.renderer = pyrender.OffscreenRenderer(width, height)\n\t        self.scene = pyrender.Scene()\n\t        #self.render_flags = pyrender.RenderFlags.SKIP_CULL_FACES\n\t    def __call__(self, height, width, intrinsics, pose, mesh):\n\t        self.renderer.viewport_height = height\n\t        self.renderer.viewport_width = width\n", "        self.scene.clear()\n\t        self.scene.add(mesh)\n\t        cam = pyrender.IntrinsicsCamera(cx=intrinsics[0, 2], cy=intrinsics[1, 2],\n\t                                        fx=intrinsics[0, 0], fy=intrinsics[1, 1])\n\t        self.scene.add(cam, pose=self.fix_pose(pose))\n\t        return self.renderer.render(self.scene)#, self.render_flags) \n\t    def fix_pose(self, pose):\n\t        # 3D Rotation about the x-axis.\n\t        t = np.pi\n\t        c = np.cos(t)\n", "        s = np.sin(t)\n\t        R =  np.array([[1, 0, 0],\n\t                       [0, c, -s],\n\t                       [0, s, c]])\n\t        axis_transform = np.eye(4)\n\t        axis_transform[:3, :3] = R\n\t        return pose@axis_transform\n\t    def mesh_opengl(self, mesh):\n\t        return pyrender.Mesh.from_trimesh(mesh)\n\t    def delete(self):\n", "        self.renderer.delete()\n\tdef render_depthmaps_pyrender(path_mesh, path_intrin, dir_poses,\n\t                path_mask_npz = None):\n\t    # gt depth data loader\n\t    width, height = 640, 480\n\t    # mesh renderer\n\t    renderer = Renderer()\n\t    mesh = trimesh.load(path_mesh, process=False)\n\t    mesh_opengl = renderer.mesh_opengl(mesh)\n\t    intrin = GeoUtils.read_cam_matrix(path_intrin)\n", "    poses = GeoUtils.read_poses(dir_poses)\n\t    num_images = len(poses)\n\t    depths_all = []\n\t    for i in tqdm(range(num_images)):\n\t        pose_curr = poses[i]\n\t        _, depth_pred = renderer(height, width, intrin, pose_curr, mesh_opengl)\n\t        depths_all.append(depth_pred)\n\t    depths_all = np.array(depths_all)\n\t    return depths_all"]}
{"filename": "utils/utils_training.py", "chunked_list": ["import torch\n\timport torch.nn.functional as F\n\tdef get_angles(normals_source, normals_target):\n\t    '''Get angular error betwee predicted normals and ground truth normals\n\t    Args:\n\t        normals_source, normals_target: N*3\n\t        mask: N*1 (optional, default: None)\n\t    Return:\n\t        angular_error: float\n\t    '''\n", "    inner = (normals_source * normals_target).sum(dim=-1,keepdim=True)\n\t    norm_source =  torch.linalg.norm(normals_source, dim=-1, ord=2,keepdim=True)\n\t    norm_target = torch.linalg.norm(normals_target, dim=-1, ord=2,keepdim=True)\n\t    angles = torch.arccos(inner/((norm_source*norm_target) + 1e-6)) #.clip(-np.pi, np.pi)\n\t    assert not torch.isnan(angles).any()\n\t    return angles\n\tdef get_angular_error(normals_source, normals_target, mask = None, clip_angle_error = -1):\n\t    '''Get angular error betwee predicted normals and ground truth normals\n\t    Args:\n\t        normals_source, normals_target: N*3\n", "        mask: N*1 (optional, default: None)\n\t    Return:\n\t        angular_error: float\n\t    '''\n\t    inner = (normals_source * normals_target).sum(dim=-1,keepdim=True)\n\t    norm_source =  torch.linalg.norm(normals_source, dim=-1, ord=2,keepdim=True)\n\t    norm_target = torch.linalg.norm(normals_target, dim=-1, ord=2,keepdim=True)\n\t    angles = torch.arccos(inner/((norm_source*norm_target) + 1e-6)) #.clip(-np.pi, np.pi)\n\t    assert not torch.isnan(angles).any()\n\t    if mask is None:\n", "        mask = torch.ones_like(angles)\n\t    if mask.ndim == 1:\n\t        mask =  mask.unsqueeze(-1)\n\t    assert angles.ndim == mask.ndim\n\t    mask_keep_gt_normal = torch.ones_like(angles).bool()\n\t    if clip_angle_error>0:\n\t        mask_keep_gt_normal = angles < clip_angle_error\n\t        # num_clip = mask_keep_gt_normal.sum()\n\t    angular_error = F.l1_loss(angles*mask*mask_keep_gt_normal, torch.zeros_like(angles), reduction='sum') / (mask*mask_keep_gt_normal+1e-6).sum()\n\t    return angular_error, mask_keep_gt_normal\n", "# evaluation\n\tdef calculate_psnr(img_pred, img_gt, mask=None):\n\t    psnr = 20.0 * torch.log10(1.0 / (((img_pred - img_gt)**2).mean()).sqrt())\n\t    return psnr\n\tdef convert_to_homo(pts):\n\t    pts_homo = torch.cat([pts, torch.ones(pts.shape[:-1] + tuple([1])) ], axis=-1)\n\t    return pts_homo"]}
{"filename": "utils/utils_geometry.py", "chunked_list": ["import cv2, glob, trimesh, logging\n\timport pandas as pd\n\timport open3d as o3d\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\timport torch\n\tfrom torch.nn import functional as F\n\tfrom scipy.spatial.transform import Rotation as R\n\tfrom datetime import datetime\n\timport copy, os\n", "from tqdm import tqdm\n\timport utils.utils_image as ImageUtils\n\timport utils.utils_io as IOUtils\n\tdef modify_intrinsics_of_cropped_images(path_intrin, path_intrin_save, crop_width_half, crop_height_half):\n\t    intrin = np.loadtxt(path_intrin)\n\t    intrin[0, 2] = intrin[0, 2] - crop_width_half\n\t    intrin[1, 2] = intrin[1, 2] - crop_height_half\n\t    np.savetxt(path_intrin_save, intrin, fmt='%f')\n\t    return intrin\n\tdef read_point_cloud(path):\n", "    cloud = o3d.io.read_point_cloud(path)\n\t    return cloud\n\tdef read_triangle_mesh(path):\n\t    mesh = o3d.io.read_triangle_mesh(path)\n\t    return mesh\n\tdef write_triangle_mesh(path_save, mesh):\n\t    # assert IOUtils.ensure_dir_existence(os.path.dirname(path_save))\n\t    o3d.io.write_triangle_mesh(path_save, mesh)\n\tdef rot_to_quat(R):\n\t    batch_size, _,_ = R.shape\n", "    q = torch.ones((batch_size, 4)).cuda()\n\t    R00 = R[:, 0,0]\n\t    R01 = R[:, 0, 1]\n\t    R02 = R[:, 0, 2]\n\t    R10 = R[:, 1, 0]\n\t    R11 = R[:, 1, 1]\n\t    R12 = R[:, 1, 2]\n\t    R20 = R[:, 2, 0]\n\t    R21 = R[:, 2, 1]\n\t    R22 = R[:, 2, 2]\n", "    q[:,0]=torch.sqrt(1.0+R00+R11+R22)/2\n\t    q[:, 1]=(R21-R12)/(4*q[:,0])\n\t    q[:, 2] = (R02 - R20) / (4 * q[:, 0])\n\t    q[:, 3] = (R10 - R01) / (4 * q[:, 0])\n\t    return q\n\tdef quat_to_rot(q):\n\t    batch_size, _ = q.shape\n\t    q = F.normalize(q, dim=1)\n\t    R = torch.ones((batch_size, 3,3)).cuda()\n\t    qr=q[:,0]\n", "    qi = q[:, 1]\n\t    qj = q[:, 2]\n\t    qk = q[:, 3]\n\t    R[:, 0, 0]=1-2 * (qj**2 + qk**2)\n\t    R[:, 0, 1] = 2 * (qj *qi -qk*qr)\n\t    R[:, 0, 2] = 2 * (qi * qk + qr * qj)\n\t    R[:, 1, 0] = 2 * (qj * qi + qk * qr)\n\t    R[:, 1, 1] = 1-2 * (qi**2 + qk**2)\n\t    R[:, 1, 2] = 2*(qj*qk - qi*qr)\n\t    R[:, 2, 0] = 2 * (qk * qi-qj * qr)\n", "    R[:, 2, 1] = 2 * (qj*qk + qi*qr)\n\t    R[:, 2, 2] = 1-2 * (qi**2 + qj**2)\n\t    return R\n\t# camera intrin\n\tdef resize_cam_intrin(intrin, resolution_level):\n\t    if resolution_level != 1.0:\n\t        logging.info(f'Resize instrinsics, resolution_level: {resolution_level}')\n\t        intrin[:2,:3] /= resolution_level\n\t    return intrin\n\tdef read_cam_matrix(path, data = ''):\n", "    '''load camera intrinsics or extrinsics\n\t    '''\n\t    if path is not None:\n\t        data = open(path)\n\t    lines = [[float(w) for w in line.strip().split()] for line in data]\n\t    assert len(lines) == 4\n\t    return np.array(lines).astype(np.float32)\n\t# camera pose related functions\n\tdef save_poses(dir_pose, poses, stems = None):\n\t    IOUtils.ensure_dir_existence(dir_pose)\n", "    num_poses = poses.shape[0]\n\t    for i in range(num_poses):\n\t        stem_curr = f'{i:04d}'\n\t        if stems is not None:\n\t            stem_curr = stems[i]\n\t        path_pose = f\"{dir_pose}/{stem_curr}.txt\"\n\t        np.savetxt(path_pose, poses[i])\n\tdef get_pose_inv(pose):\n\t    # R = pose[:3, :3]\n\t    # T = pose[:3, 3]\n", "    # R_inv = R.transpose()\n\t    # T_inv = -R_inv @ T\n\t    # pose_inv = np.identity(4)\n\t    # pose_inv[:3, :3] = R_inv\n\t    # pose_inv[:3, 3] = T_inv\n\t    return np.linalg.inv(pose)\n\tdef get_poses_inverse(poses):   \n\t    if poses.ndim == 3:\n\t        poses_inv = []\n\t        for i in range(poses.shape[0]):\n", "            pose_i_inv = get_pose_inv(poses[i])\n\t            poses_inv.append(pose_i_inv)\n\t        return np.array(poses_inv)\n\t    elif poses.ndim == 2:\n\t        return get_pose_inv(poses)\n\t    else:\n\t        NotImplementedError\n\tdef get_camera_origins(poses_homo):\n\t    '''\n\t    Args:\n", "        poses_homo: world to camera poses\n\t    '''\n\t    if not isinstance(poses_homo, np.ndarray):\n\t        poses_homo = np.array(poses_homo)\n\t    cam_centers = []\n\t    poses_homo = np.array(poses_homo)\n\t    num_cams = poses_homo.shape[0]\n\t    for i in range(num_cams):\n\t        rot = poses_homo[i, :3,:3]\n\t        trans = poses_homo[i, :3,3]\n", "        trans = trans.reshape(3,1)\n\t        cam_center = - np.linalg.inv(rot) @ trans\n\t        cam_centers.append(cam_center)\n\t    cam_centers = np.array(cam_centers).squeeze(axis=-1)\n\t    return cam_centers\n\tdef get_world_points(depth, intrinsics, extrinsics):\n\t    '''\n\t    Args:\n\t        depthmap: H*W\n\t        intrinsics: 3*3 or 4*4\n", "        extrinsics: 4*4, world to camera\n\t    Return:\n\t        points: N*3, in world space \n\t    '''\n\t    if intrinsics.shape[0] ==4:\n\t        intrinsics = intrinsics[:3,:3]\n\t    height, width = depth.shape\n\t    x, y = np.meshgrid(np.arange(0, width), np.arange(0, height))\n\t    # valid_points = np.ma.masked_greater(depth, 0.0).mask\n\t    # x, y, depth = x[valid_points], y[valid_points], depth[valid_points]\n", "    x = x.reshape((1, height*width))\n\t    y = y.reshape((1, height*width))\n\t    depth = depth.reshape((1, height*width))\n\t    xyz_ref = np.matmul(np.linalg.inv(intrinsics),\n\t                        np.vstack((x, y, np.ones_like(x))) * depth)\n\t    xyz_world = np.matmul(np.linalg.inv(extrinsics),\n\t                            np.vstack((xyz_ref, np.ones_like(x))))[:3]\n\t    xyz_world = xyz_world.transpose((1, 0))\n\t    return xyz_world\n\tdef get_world_normal(normal, extrin):\n", "    '''\n\t    Args:\n\t        normal: N*3\n\t        extrinsics: 4*4, world to camera\n\t    Return:\n\t        normal: N*3, in world space \n\t    '''\n\t    extrinsics = copy.deepcopy(extrin)\n\t    if torch.is_tensor(extrinsics):\n\t        extrinsics = extrinsics.cpu().numpy()\n", "    assert extrinsics.shape[0] ==4\n\t    normal = normal.transpose()\n\t    extrinsics[:3, 3] = np.zeros(3)  # only rotation, no translation\n\t    normal_world = np.matmul(np.linalg.inv(extrinsics),\n\t                            np.vstack((normal, np.ones((1, normal.shape[1])))))[:3]\n\t    normal_world = normal_world.transpose((1, 0))\n\t    return normal_world\n\tdef get_aabb(points, scale=1.0):\n\t    '''\n\t    Args:\n", "        points; 1) numpy array (converted to '2)'; or \n\t                2) open3d cloud\n\t    Return:\n\t        min_bound\n\t        max_bound\n\t        center: bary center of geometry coordinates\n\t    '''\n\t    if isinstance(points, np.ndarray):\n\t        point_cloud = o3d.geometry.PointCloud()\n\t        point_cloud.points = o3d.utility.Vector3dVector(points)\n", "        points = point_cloud\n\t    min_max_bounds = o3d.geometry.AxisAlignedBoundingBox.get_axis_aligned_bounding_box(points)\n\t    min_bound, max_bound = min_max_bounds.min_bound, min_max_bounds.max_bound\n\t    center = (min_bound+max_bound)/2\n\t    # center = points.get_center()\n\t    if scale != 1.0:\n\t        min_bound = center + scale * (min_bound-center)\n\t        max_bound = center + scale * (max_bound-center)\n\t    # logging.info(f\"min_bound, max_bound, center: {min_bound, max_bound, center}\")\n\t    return min_bound, max_bound, center\n", "def read_poses(dir, lis_stem = None, ext = '.txt'):\n\t    '''Read camera poses\n\t    '''\n\t    vec_path = sorted(glob.glob(f\"{dir}/**{ext}\"))\n\t    if lis_stem is not None:\n\t        vec_path = []\n\t        for stem_curr in lis_stem:\n\t            vec_path.append(f'{dir}/{stem_curr}{ext}')\n\t        vec_path = sorted(vec_path)\n\t    poses = []\n", "    stems_all =  []\n\t    for i in range(len(vec_path)):\n\t        pose_i = read_cam_matrix(vec_path[i])\n\t        poses.append(pose_i)\n\t        _, stem_, _ = IOUtils.get_path_components(vec_path[i])\n\t        stems_all.append(stem_)\n\t    if lis_stem is not None:\n\t        return np.array(poses), stems_all\n\t    else:\n\t        return np.array(poses)\n", "def generate_transform_noise(sigma_rot_angle = 1.0, sigma_trans = 0.01):\n\t    '''Generate tranform noise matrix\n\t    Args:\n\t        sigma_rot_axis: no influence, because of normalization\n\t        sigma_rot_angle: degrees\n\t    '''\n\t    noise_rot_axis = np.random.normal(0, 1.0, 3)\n\t    noise_rot_axis = noise_rot_axis / (np.linalg.norm(noise_rot_axis, ord=2) + 1e-6)\n\t    noise_rot_angle = np.random.normal(0, sigma_rot_angle, 1)\n\t    noise_rot_mat = R.from_rotvec(noise_rot_angle * noise_rot_axis, degrees=True).as_matrix()\n", "    noise_trans = np.random.normal(0, sigma_trans, 3)\n\t    logging.debug(f'Noise of rotation axis, {noise_rot_axis}; \\n    rotation angle: {noise_rot_angle}; tranlation: {noise_trans}')\n\t    noise_transform_homo = np.identity(4)\n\t    noise_transform_homo[:3,:3] = noise_rot_mat\n\t    noise_transform_homo[:3,3] = noise_trans\n\t    return noise_transform_homo\n\t# depthmap related functions\n\tdef read_depth_maps_np(dir):\n\t    '''Read depthmaps in dir with .npy format\n\t    Return:\n", "        arr_depths: N*W*H\n\t    '''\n\t    vec_path_depths = sorted(glob.glob(f\"{dir}/**.npy\"))\n\t    arr_depth_maps = []\n\t    for i in range(len(vec_path_depths)):\n\t        depth_map_curr = np.load(vec_path_depths[i])\n\t        arr_depth_maps.append(depth_map_curr)\n\t    arr_depth_maps = np.array(arr_depth_maps)\n\t    return arr_depth_maps\n\tdef fuse_depthmaps(depthmaps, intrinsics, extrinsics,b_normalize = False):\n", "    '''\n\t    args:\n\t        extrinsics: world to camera\n\t    return:\n\t        merged depth map points\n\t    '''\n\t    points_fuse = None\n\t    for i in range(depthmaps.shape[0]):\n\t        cam_ext, depth =  extrinsics[i], depthmaps[i]\n\t        cam_int = intrinsics if intrinsics.ndim == 2 else intrinsics[i]\n", "        # if b_normalize:\n\t        #     depth = scale * depth\n\t        points = get_world_points(depth, cam_int, cam_ext)\n\t        if points_fuse is None:\n\t            points_fuse = points\n\t        else:\n\t            points_fuse = np.concatenate((points_fuse, points), axis = 0)\n\t    return points_fuse\n\tdef calculate_normalmap_from_depthmap(depthmap, intrin, extrin, num_nearest_neighbors=100):\n\t    '''\n", "    Args:\n\t        depthmap: H*W. depth in image plane\n\t        extrin: word to cam\n\t    Return:\n\t        normalmap: H*W*3\n\t    '''\n\t    pts = get_world_points(depthmap, intrin, extrin)\n\t    cam_center = get_camera_origins([extrin])[0]\n\t    H, W = depthmap.shape\n\t    pcd = o3d.geometry.PointCloud()\n", "    pcd.points = o3d.utility.Vector3dVector(pts)\n\t    pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamKNN(knn=num_nearest_neighbors))\n\t    normals = np.array(pcd.normals)\n\t    # check normal direction: if ray dir and normal angle is smaller than 90, reverse normal\n\t    ray_dir = pts-cam_center.reshape(1,3)\n\t    normal_dir_not_correct = (ray_dir*normals).sum(axis=-1) > 0\n\t    logging.info(f'Normals with wrong direction: {normal_dir_not_correct.sum()}')\n\t    normals[normal_dir_not_correct] = -normals[normal_dir_not_correct]\n\t    return pts, normals.reshape(H,W,3)\n\tdef save_points(path_save, pts, colors = None, normals = None, BRG2RGB=False):\n", "    '''save points to point cloud using open3d\n\t    '''\n\t    assert len(pts) > 0\n\t    if colors is not None:\n\t        assert colors.shape[1] == 3\n\t    assert pts.shape[1] == 3\n\t    cloud = o3d.geometry.PointCloud()\n\t    cloud.points = o3d.utility.Vector3dVector(pts)\n\t    if colors is not None:\n\t        # Open3D assumes the color values are of float type and in range [0, 1]\n", "        if np.max(colors) > 1:\n\t            colors = colors / np.max(colors)\n\t        if BRG2RGB:\n\t            colors = np.stack([colors[:, 2], colors[:, 1], colors[:, 0]], axis=-1)\n\t        cloud.colors = o3d.utility.Vector3dVector(colors) \n\t    if normals is not None:\n\t        cloud.normals = o3d.utility.Vector3dVector(normals) \n\t    o3d.io.write_point_cloud(path_save, cloud)\n\tdef write_point_cloud(path_save, cloud):\n\t    o3d.io.write_point_cloud(path_save, cloud)\n", "def read_point_cloud(path_cloud):\n\t    assert IOUtils.checkExistence(path_cloud)\n\t    cloud = o3d.io.read_point_cloud(path_cloud)\n\t    # o3d.visualization.draw_geometries([cloud])\n\t    return cloud\n\tdef get_norm_matrix_from_cam_centers(dir_scan, exts, cam_sphere_radius):\n\t    '''NOrmalize camera centers into a sphere\n\t    Args:\n\t        exts: camera poses, from world to camera\n\t    '''\n", "    cam_centers = get_camera_origins(exts)\n\t    save_points(f\"{dir_scan}/cam_centers_origin.ply\", cam_centers)\n\t    min_bound, max_bound, center = get_aabb(cam_centers)\n\t    scale = (max_bound-min_bound).max() / cam_sphere_radius # normalize camera centers to a 0.3 bounding box\n\t    scale_n2w = np.diag([scale, scale, scale, 1.0])\n\t    translate_n2w = np.identity(4)\n\t    translate_n2w[:3,3] = center\n\t    trans_n2w = translate_n2w @ scale_n2w \n\t    return trans_n2w \n\tdef get_norm_matrix_from_point_cloud(pcd, radius_normalize_sphere = 1.0):\n", "    '''Normalize point cloud into a sphere\n\t    '''\n\t    # if not checkExistence(path_cloud):\n\t    #     logging.error(f\"Path is not existent. [{path_cloud}]\")\n\t    #     exit()\n\t    # pcd = read_point_cloud(path_cloud)\n\t    min_bound, max_bound, pcd_center = get_aabb(pcd)\n\t    logging.debug(f\"Point cloud center: {pcd_center}\")\n\t    edges_half =  np.linalg.norm(max_bound-min_bound, ord=2) / 2  #np.concatenate((max_bound -pcd_center, pcd_center -min_bound))\n\t    max_edge_half = np.max(edges_half)\n", "    scale = max_edge_half / radius_normalize_sphere\n\t    scale_n2w = np.diag([scale, scale, scale, 1.0])\n\t    translate_n2w = np.identity(4)\n\t    translate_n2w[:3,3] = pcd_center\n\t    trans_n2w = translate_n2w @ scale_n2w #@ rx_homo @ rx_homo_2\n\t    return trans_n2w\n\tdef get_projection_matrix(dir_scan, intrin, poses, trans_n2w):\n\t    '''\n\t    Args:\n\t        poses: world to camera\n", "    '''\n\t    num_poses = poses.shape[0]\n\t    projs = []\n\t    poses_norm = []\n\t    dir_pose_norm = dir_scan + \"/pose_norm\"\n\t    IOUtils.ensure_dir_existenceirExistence(dir_pose_norm)\n\t    for i in range(num_poses):\n\t        # pose_norm_i = poses[i] @ trans_n2w\n\t        # Method 2\n\t        pose = np.copy(poses[i])\n", "        rot = pose[:3,:3]\n\t        trans = pose[:3,3]\n\t        cam_origin_world = - np.linalg.inv(rot) @ trans.reshape(3,1)\n\t        cam_origin_world_homo = np.concatenate([cam_origin_world,[[1]]], axis=0)\n\t        cam_origin_norm = np.linalg.inv(trans_n2w) @ cam_origin_world_homo\n\t        trans_norm = -rot @ cam_origin_norm[:3]\n\t        pose[:3,3] = np.squeeze(trans_norm)\n\t        poses_norm.append(pose)\n\t        proj_norm = intrin @ pose\n\t        projs.append(proj_norm)\n", "        np.savetxt(f'{dir_pose_norm}/{i:04d}.txt', pose)   # camera to world\n\t        np.savetxt(f'{dir_pose_norm}/{i:04d}_inv.txt', get_pose_inv(pose) )  # world to world\n\t    return np.array(projs), np.array(poses_norm)\n\tdef generate_rays(img_size, intrin, pose = None, normalize_dir = True):\n\t    '''Generate rays with specified size, intrin and pose.\n\t    Args:\n\t        intrin: 4*4\n\t        pose: 4*4, (default: None, identity), camera to world\n\t    Return:\n\t        rays_o, rays_d: H*W*3, numpy array\n", "    '''\n\t    if pose is None:\n\t        pose = np.identity(4)\n\t    pose = torch.tensor(pose)\n\t    intrin = torch.tensor(intrin)\n\t    W,H = img_size\n\t    tu = torch.linspace(0, W - 1, W)\n\t    tv = torch.linspace(0, H - 1, H)\n\t    pixels_v, pixels_u = torch.meshgrid(tv, tu)\n\t    p = torch.stack([pixels_u, pixels_v, torch.ones_like(pixels_v )], dim=-1) # W, H, 3\n", "    p = torch.matmul(torch.linalg.inv(intrin)[None, None, :3, :3], p[:, :, :, None]).squeeze()  # W, H, 3\n\t    if normalize_dir:\n\t        # for volume rendering, depth along ray\n\t        rays_v = p  / torch.linalg.norm(p, ord=2, dim=-1, keepdim=True)\n\t    else:\n\t        # for reprojection of depthmap, depth along z axis\n\t        rays_v = p\n\t    rays_v = torch.matmul(pose[None, None, :3, :3], rays_v[:, :, :, None]).squeeze()\n\t    rays_o = pose[None, None, :3, 3].expand(rays_v.shape) \n\t    return rays_o.cpu().numpy(), rays_v.cpu().numpy()\n", "def clean_mesh_faces_outside_frustum(path_save_clean, path_mesh, \n\t                                        path_intrin,  dir_poses,  \n\t                                        target_img_size,  reso_level = 1.0,\n\t                                        path_mask_npz = None,\n\t                                        check_existence = True):\n\t    '''Remove faces of mesh which cannot be orserved by all cameras\n\t    '''\n\t    # if path_mask_npz:\n\t    #     path_save_clean = IOUtils.add_file_name_suffix(path_save_clean, '_mask')\n\t    if check_existence and IOUtils.checkExistence(path_save_clean):\n", "        logging.info(f'The source mesh is already cleaned. [{path_save_clean.split(\"/\")[-1]}]')\n\t        return path_save_clean\n\t    if path_mask_npz:\n\t        target_2dmask_mesh = np.load(path_mask_npz)['arr_0']\n\t    mesh = trimesh.load(path_mesh)\n\t    intersector = trimesh.ray.ray_pyembree.RayMeshIntersector(mesh)\n\t    intrin = read_cam_matrix(path_intrin)\n\t    intrin = resize_cam_intrin(intrin, resolution_level=reso_level)\n\t    if reso_level > 1.0:\n\t        W = target_img_size[0] // reso_level\n", "        H = target_img_size[1] // reso_level\n\t        target_img_size = (W,H)\n\t    vec_path_poses = IOUtils.get_files_path(dir_poses, '.txt')\n\t    all_indices = []\n\t    for i in tqdm(range(len(vec_path_poses))):\n\t        path_pose = vec_path_poses[i]\n\t        ppath, stem, ext = IOUtils.get_path_components(path_pose)\n\t        pose = read_cam_matrix(path_pose)\n\t        rays_o, rays_d = generate_rays(target_img_size, intrin, pose)\n\t        rays_o = rays_o.reshape(-1,3)\n", "        rays_d = rays_d.reshape(-1,3)\n\t        idx_faces_hits = intersector.intersects_first(rays_o, rays_d)\n\t        if path_mask_npz:\n\t            mask_mesh_i = target_2dmask_mesh[i].reshape(-1)\n\t            idx_faces_hits[mask_mesh_i==False] = -1\n\t        all_indices.append(idx_faces_hits)\n\t    values = np.unique(np.array(all_indices)) \n\t    mask_faces = np.ones(len(mesh.faces))\n\t    mask_faces[values[1:]] = 0\n\t    logging.info(f'Surfaces/Kept: {len(mesh.faces)}/{len(values)}')\n", "    mesh_o3d = read_triangle_mesh(path_mesh)\n\t    mesh_o3d.remove_triangles_by_mask(mask_faces)\n\t    print(f'Before cleaning: {len(mesh_o3d.vertices)}')\n\t    # mesh_o3d.remove_triangles_by_mask(mask_faces)\n\t    mesh_o3d.remove_unreferenced_vertices()\n\t    print(f'After cleaning: {len(mesh_o3d.vertices)}')\n\t    write_triangle_mesh(path_save_clean, mesh_o3d)\n\tdef get_camera_view_direction(intrin, extrin, size_frustum):\n\t    '''\n\t    Return:\n", "        cam_center: in world coordinates\n\t        view_dir: in world coordinates\n\t    '''\n\t    cam_center = get_camera_origins(np.array([extrin]))[0]\n\t    ixx_center_image = np.array([size_frustum[0]//2, size_frustum[1]//2, 1, 1])\n\t    view_dir_image = np.linalg.inv(intrin) @ ixx_center_image\n\t    extrin2 = copy.deepcopy(extrin)\n\t    extrin2[:3,3] = 0  # waring: remove translation\n\t    view_dir_world = np.linalg.inv(extrin2) @ view_dir_image\n\t    return cam_center, view_dir_world\n", "def clean_mesh_points_outside_frustum(path_save_clean, path_mesh, \n\t                                        path_intrin,  dir_poses,\n\t                                        target_img_size, reso_level = 1, enlarge_frustum = 0.,\n\t                                        path_mask_npz = None,\n\t                                        check_existence = True):\n\t    '''Remove points of mesh which cannot be orserved by all cameras\n\t    Args:\n\t        enlarge_frustum: pixels\n\t    '''\n\t    if check_existence and IOUtils.checkExistence(path_save_clean):\n", "        logging.info(f'The source mesh is already cleaned. [{path_save_clean.split(\"/\")[-1]}]')\n\t        return path_save_clean\n\t    if path_mask_npz:\n\t        target_2dmask_mesh = np.load(path_mask_npz)['arr_0']\n\t    mesh_o3d = read_triangle_mesh(path_mesh)\n\t    points = np.array(mesh_o3d.vertices)\n\t    points_homo = np.concatenate( (points, np.ones((len(points), 1))), axis=-1 )\n\t    mask_inside_all = np.zeros(len(points)).astype(bool)\n\t    mesh_mask_outside_all = np.zeros(len(points)).astype(bool)\n\t    intrin = read_cam_matrix(path_intrin)    \n", "    if reso_level > 1:\n\t        intrin = resize_cam_intrin(intrin, reso_level)\n\t        target_img_size = (target_img_size[0]//reso_level, target_img_size[1]//reso_level)\n\t    vec_path_poses = IOUtils.get_files_path(dir_poses, '.txt')\n\t    for i in tqdm(range(len(vec_path_poses))):\n\t        path_pose = vec_path_poses[i]\n\t        pose = read_cam_matrix(path_pose)\n\t        extrin = np.linalg.inv(pose)\n\t        # remove backside points\n\t        cam_center, view_dir_cam = get_camera_view_direction(intrin, extrin, target_img_size)\n", "        view_dirs = points - cam_center\n\t        angles = calculate_normal_angle(view_dirs, view_dir_cam[:3])\n\t        mask_front_side =( angles <= np.pi/2.0)\n\t        # reproject points to camera coordinates\n\t        points_homo_cam = extrin@points_homo.transpose((1, 0))\n\t        points_homo_image = intrin @ points_homo_cam\n\t        points_homo_image = (points_homo_image / points_homo_image[2])[:2] # x,y: u,v\n\t        mask_inside_frustum = (points_homo_image[0] < target_img_size[0]+enlarge_frustum) & (points_homo_image[0] >= -enlarge_frustum) &\\\n\t                    (points_homo_image[1] < target_img_size[1]+enlarge_frustum) & (points_homo_image[1] >= -enlarge_frustum)\n\t        mask_inside_curr = mask_inside_frustum & mask_front_side\n", "        if path_mask_npz:\n\t            points_homo_image_curr = points_homo_image.transpose()[mask_inside_curr]\n\t            idx_uv = np.floor(points_homo_image_curr).astype(int)\n\t            mask_mesh_i = target_2dmask_mesh[i]\n\t            inside_gt_mask = mask_mesh_i[idx_uv[:, 1], idx_uv[:, 0]]\n\t            num = inside_gt_mask.sum()\n\t            # mask_inside_curr[mask_inside_curr] = inside_gt_mask\n\t            mesh_mask_outside_all[mask_inside_curr] =  mesh_mask_outside_all[mask_inside_curr] | (inside_gt_mask==False)\n\t            # mask_inside_curr = mask_inside_curr & mask_mesh_i & \n\t        mask_inside_all = mask_inside_all | mask_inside_curr\n", "        # print(mask_inside_all.sum())\n\t    mesh_o3d.remove_vertices_by_mask((mask_inside_all==False) | mesh_mask_outside_all )\n\t    write_triangle_mesh(path_save_clean, mesh_o3d)\n\tdef clean_mesh_points_outside_bbox(path_clean, path_mesh, path_mesh_gt, scale_bbox = 1.0, check_existence = True):\n\t    if check_existence and IOUtils.checkExistence(path_clean):\n\t        logging.info(f'The source mesh is already cleaned. [{path_clean.split(\"/\")[-1]}]')\n\t        return\n\t    mesh_o3d = read_triangle_mesh(path_mesh)\n\t    points = np.array(mesh_o3d.vertices)\n\t    mask_inside_all = np.zeros(len(points)).astype(bool)\n", "    mesh_gt = read_triangle_mesh(path_mesh_gt)\n\t    min_bound, max_bound, center = get_aabb(mesh_gt, scale_bbox)\n\t    mask_low = (points - min_bound) >= 0\n\t    mask_high = (points - max_bound) <= 0\n\t    mask_inside_all = (mask_low.sum(axis=-1) == 3) & (mask_high.sum(axis=-1) == 3)\n\t    mesh_o3d.remove_vertices_by_mask(mask_inside_all==False)\n\t    write_triangle_mesh(path_clean, mesh_o3d)\n\tdef calculate_normal_angle(normal1, normal2, use_degree = False):\n\t    '''Get angle to two vectors\n\t    Args:\n", "        normal1: N*3\n\t        normal2: N*3\n\t    Return:\n\t        angles: N*1\n\t    '''\n\t    check_dim = lambda normal : np.expand_dims(normal, axis=0) if normal.ndim == 1 else normal\n\t    normal1 = check_dim(normal1)\n\t    normal2 = check_dim(normal2)\n\t    inner = (normal1*normal2).sum(axis=-1)\n\t    norm1 = np.linalg.norm(normal1, axis=1, ord=2)\n", "    norm2 = np.linalg.norm(normal2, axis=1, ord=2)\n\t    angles_cos = inner / (norm1*norm2+1e-6)\n\t    angles = np.arccos(angles_cos)\n\t    if use_degree:\n\t        angles = angles/np.pi * 180\n\t    assert not np.isnan(angles).any()\n\t    return angles\n\tdef generate_mesh_2dmask(path_save_npz, path_mesh, path_intrin, dir_poses, mask_size, reso_level=1, check_existence = True):\n\t    '''Generate 2D masks of a mesh, given intrinsics, poses and mask size\n\t    '''\n", "    '''Remove faces of mesh which cannot be orserved by all cameras\n\t    '''\n\t    # if reso_level > 1.0:\n\t    #     path_save_npz = IOUtils.add_file_name_suffix(path_save_npz, f'_reso{reso_level}')\n\t    if check_existence and IOUtils.checkExistence(path_save_npz):\n\t        logging.info(f'The 2D mask of mesh is already generated. [{path_save_npz.split(\"/\")[-1]}]')\n\t        return path_save_npz\n\t    mesh = trimesh.load(path_mesh)\n\t    intersector = trimesh.ray.ray_pyembree.RayMeshIntersector(mesh)\n\t    intrin = read_cam_matrix(path_intrin)\n", "    intrin = resize_cam_intrin(intrin, resolution_level=reso_level)\n\t    if reso_level > 1.0:\n\t        W = mask_size[0] // reso_level\n\t        H = mask_size[1] // reso_level\n\t        mask_size = (W,H)\n\t    vec_path_poses = IOUtils.get_files_path(dir_poses, '.txt')\n\t    vec_path_imgs = IOUtils.get_files_path(dir_poses + '/../image', '.png')\n\t    all_hits = []\n\t    for i in tqdm(range(len(vec_path_poses))):\n\t        path_pose = vec_path_poses[i]\n", "        ppath, stem, ext = IOUtils.get_path_components(path_pose)\n\t        pose = read_cam_matrix(path_pose)\n\t        rays_o, rays_d = generate_rays(mask_size, intrin, pose)\n\t        rays_o = rays_o.reshape(-1,3)\n\t        rays_d = rays_d.reshape(-1,3)\n\t        hit_faces_ = intersector.intersects_any(rays_o, rays_d)\n\t        all_hits.append(hit_faces_)\n\t        # img = ImageUtils.read_image(vec_path_imgs[i], target_img_size=mask_size)\n\t        # img[hit_faces_.reshape(mask_size[::-1])==False] = (0,0,255)\n\t        # cv2.imwrite(f'./test/{i:04d}.png', img)\n", "    all_hits = np.array(all_hits)\n\t    mask_2d_mesh = np.array(all_hits).reshape(tuple([len(vec_path_poses)]) + mask_size[::-1])\n\t    np.savez(path_save_npz, mask_2d_mesh)\n\t    logging.info(f'Rays, hits, ratio: {mask_2d_mesh.size, mask_2d_mesh.sum(), mask_2d_mesh.sum()/mask_2d_mesh.size}')\n\t    return path_save_npz\n\t# transformation\n\tdef transform_mesh(path_mesh, trans, path_save = None):\n\t    '''Transfrom mesh using the transformation matrix\n\t    Args:\n\t        path_mesh\n", "        trans: 4*4\n\t    Return:\n\t        mesh_trans\n\t    '''\n\t    mesh = read_triangle_mesh(path_mesh)\n\t    mesh_trans = copy.deepcopy(mesh)\n\t    mesh_trans.transform(trans)\n\t    if path_save is not None:\n\t        write_triangle_mesh(path_save, mesh_trans)\n\t    return mesh, mesh_trans\n"]}
{"filename": "utils/utils_normal.py", "chunked_list": ["# some snippets are borrowed from https://github.com/baegwangbin/surface_normal_uncertainty\n\timport numpy as np\n\timport torch\n\tfrom pathlib import Path\n\timport glob\n\tfrom tqdm import tqdm\n\tfrom PIL import Image\n\timport cv2\n\timport utils.utils_geometry as GeoUtils\n\timport utils.utils_image as ImageUtils\n", "import utils.utils_io as IOUtils\n\tdef compute_normal_errors_metrics(total_normal_errors):\n\t    metrics = {\n\t        'mean': np.average(total_normal_errors),\n\t        'median': np.median(total_normal_errors),\n\t        'rmse': np.sqrt(np.sum(total_normal_errors * total_normal_errors) / total_normal_errors.shape),\n\t        'a1': 100.0 * (np.sum(total_normal_errors < 5) / total_normal_errors.shape[0]),\n\t        'a2': 100.0 * (np.sum(total_normal_errors < 7.5) / total_normal_errors.shape[0]),\n\t        'a3': 100.0 * (np.sum(total_normal_errors < 11.25) / total_normal_errors.shape[0]),\n\t        'a4': 100.0 * (np.sum(total_normal_errors < 22.5) / total_normal_errors.shape[0]),\n", "        'a5': 100.0 * (np.sum(total_normal_errors < 30) / total_normal_errors.shape[0])\n\t    }\n\t    return metrics\n\t# log normal errors\n\tdef log_normal_errors(metrics, where_to_write = None, first_line = ''):\n\t    print(first_line)\n\t    print(\"mean   median   rmse   5    7.5   11.25   22.5    30\")\n\t    print(\"%.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f \\n\" % (\n\t        metrics['mean'], metrics['median'], metrics['rmse'],\n\t        metrics['a1'], metrics['a2'], metrics['a3'], metrics['a4'], metrics['a5']))\n", "    if where_to_write is not None:\n\t        with open(where_to_write, 'a') as f:\n\t            f.write('%s\\n' % first_line)\n\t            f.write(\"mean median rmse 5 7.5 11.25 22.5 30\\n\")\n\t            f.write(\"%.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f\\n\\n\" % (\n\t                metrics['mean'], metrics['median'], metrics['rmse'],\n\t                metrics['a1'], metrics['a2'], metrics['a3'], metrics['a4'], metrics['a5']))\n\tdef calculate_normal_error(pred_norm, gt_norm, mask = None):\n\t    if not torch.is_tensor(pred_norm):\n\t        pred_norm = torch.from_numpy(pred_norm)\n", "    if not torch.is_tensor(gt_norm):\n\t        gt_norm = torch.from_numpy(gt_norm)\n\t    prediction_error = torch.cosine_similarity(pred_norm, gt_norm, dim=1)\n\t    prediction_error = torch.clamp(prediction_error, min=-1.0, max=1.0)\n\t    E = torch.acos(prediction_error) * 180.0 / np.pi\n\t    # mask = None\n\t    if mask is not None:\n\t        return E[mask]\n\t    else:\n\t        return E\n", "def visualiza_normal(path, normal, extrin = None):\n\t    if extrin is not None:\n\t        shape = normal.shape\n\t        normal = GeoUtils.get_world_normal(normal.reshape(-1,3), extrin).reshape(shape)\n\t    pred_norm_rgb = ((normal + 1) * 0.5) * 255\n\t    pred_norm_rgb = np.clip(pred_norm_rgb, a_min=0, a_max=255)\n\t    if path is not None:\n\t        ImageUtils.write_image(path, pred_norm_rgb, color_space='RGB')\n\t    return pred_norm_rgb\n\tdef evauate_normal(dir_normal_neus, dir_normal_pred, dir_normal_gt, dir_poses, interval = 1):\n", "    vec_path_normal_neus = sorted(glob.glob(f'{dir_normal_neus}/*.npz'))\n\t    vec_path_normal_pred = sorted(glob.glob(f'{dir_normal_pred}/*.npz'))\n\t    #assert len(vec_path_normal_neus) == len(vec_path_normal_pred)\n\t    target_img_size = (640, 480)\n\t    input_width, input_height = target_img_size\n\t    num_normals = len(vec_path_normal_neus)\n\t    num_imgs_eval_gt = 0\n\t    dir_normal_neus_eval = dir_normal_neus + '_eval'\n\t    IOUtils.ensure_dir_existence(dir_normal_neus_eval)\n\t    error_neus_all, error_pred_all, ratio_all = [], [], []\n", "    for i in tqdm(range(0, num_normals, interval)):\n\t        stem = Path(vec_path_normal_neus[i]).stem[9:13]\n\t        idx_img = int(stem)\n\t        # 2. load GT normal       \n\t        path_normal_gt = f'{dir_normal_gt}/frame-{idx_img:06d}-normal.png'\n\t        path_normal_mask_gt = f'{dir_normal_gt}/frame-{idx_img:06d}-orient.png'\n\t        if not IOUtils.checkExistence(path_normal_gt) or stem in ['0300', '0330']:\n\t            continue\n\t        # print(path_normal_neus)\n\t        normal_gt_cam = Image.open(path_normal_gt).convert(\"RGB\").resize(size=(input_width, input_height), \n", "                                                                resample=Image.NEAREST)\n\t        normal_gt_cam = ((np.array(normal_gt_cam).astype(np.float32) / 255.0) * 2.0) - 1.0\n\t        # 1. load neus and predicted normal\n\t        path_normal_neus =vec_path_normal_neus[i] # f'{dir_normal_neus}/00160000_{i:04d}_reso1.npz'\n\t        normal_neus_world =  np.load(path_normal_neus)['arr_0']\n\t        path_normal_pred  = f'{dir_normal_pred}/{stem}.npz'\n\t        normal_pred_camera = -np.load(path_normal_pred)['arr_0']  # flip predicted camera\n\t        if normal_pred_camera.shape[0] != input_height:\n\t            normal_pred_camera = cv2.resize(normal_pred_camera, target_img_size, interpolation=cv2.INTER_NEAREST)\n\t        # 2. normalize neus_world\n", "        normal_neus_world_norm = np.linalg.norm(normal_neus_world, axis=-1, keepdims=True)\n\t        # print(f'normal_neus_world_norm shape: {normal_neus_world_norm.shape}  {normal_neus_world.shape}')\n\t        normal_neus_world = normal_neus_world/normal_neus_world_norm\n\t        # print(f'Normalized shape: {normal_neus_world.shape}')\n\t        # input('Continue?')\n\t        # load_GT image\n\t        path_img_gt  = f'{dir_normal_pred}/../image/{stem}.png'\n\t        img_rgb  = ImageUtils.read_image(path_img_gt, color_space='RGB')\n\t        # 3. transform normal\n\t        pose = np.loadtxt(f'{dir_poses}/{idx_img:04d}.txt')\n", "        normal_pred_world = GeoUtils.get_world_normal(normal_pred_camera.reshape(-1,3), np.linalg.inv(pose))\n\t        normal_gt_world = GeoUtils.get_world_normal(normal_gt_cam.reshape(-1,3), np.linalg.inv(pose))\n\t        shape_img = normal_neus_world.shape\n\t        img_visual_neus = visualiza_normal(None, -normal_neus_world, pose)\n\t        img_visual_pred = visualiza_normal(None,  -normal_pred_world.reshape(shape_img), pose)\n\t        img_visual_gt = visualiza_normal(None, -normal_gt_world.reshape(shape_img), pose)\n\t        ImageUtils.write_image_lis(f'{dir_eval}/{stem}.png', [img_rgb, img_visual_pred, img_visual_neus, img_visual_gt], color_space='RGB')\n\t        mask_gt = Image.open(path_normal_mask_gt).convert(\"RGB\").resize(size=(input_width, input_height),  resample=Image.NEAREST)           \n\t        mask_gt = np.array(mask_gt) \n\t        mask_gt = np.logical_not(\n", "                np.logical_and(\n\t                    np.logical_and(\n\t                        mask_gt[:, :, 0] == 127, mask_gt[:, :, 1] == 127),\n\t                    mask_gt[:, :, 2] == 127))\n\t        norm_valid_mask = mask_gt[:, :, np.newaxis]\n\t        ratio = norm_valid_mask.sum() /norm_valid_mask.size\n\t        # cv2.imwrite('./test.png',norm_valid_mask.astype(np.float)*255 )\n\t        ratio_all.append(ratio)\n\t        error_neus = calculate_normal_error(normal_neus_world.reshape(-1,3), normal_gt_world, norm_valid_mask.reshape(-1))\n\t        error_pred = calculate_normal_error(normal_pred_world, normal_gt_world, norm_valid_mask.reshape(-1))\n", "        error_neus_all.append(error_neus)\n\t        error_pred_all.append(error_pred)\n\t        num_imgs_eval_gt += 1\n\t    error_neus_all = torch.cat(error_neus_all).numpy()\n\t    error_pred_all = torch.cat(error_pred_all).numpy()\n\t    # error_neus_all = total_normal_errors.data.cpu().numpy()\n\t    metrics_neus = compute_normal_errors_metrics(error_neus_all)\n\t    metrics_pred = compute_normal_errors_metrics(error_pred_all)\n\t    # print(f'Neus error: \\n{metrics_neus}\\nPred error: \\n{metrics_pred}')\n\t    print(f'Num imgs for evaluation: {num_imgs_eval_gt}')\n", "    log_normal_errors(metrics_neus, first_line='metrics_neus')\n\t    log_normal_errors(metrics_pred, first_line='metrics_pred')\n\t    return error_neus_all, error_pred_all, num_imgs_eval_gt"]}
{"filename": "utils/utils_io.py", "chunked_list": ["from datetime import datetime\n\timport os, sys, logging\n\timport shutil\n\timport subprocess\n\tfrom pathlib import Path\n\timport glob\n\t# Path\n\tdef checkExistence(path):\n\t    if not os.path.exists(path):\n\t        return False\n", "    else:\n\t        return True\n\tdef ensure_dir_existence(dir):\n\t    try:\n\t        if not os.path.exists(dir):\n\t            os.makedirs(dir)\n\t        else:\n\t            logging.info(f\"Dir is already existent: {dir}\")\n\t    except Exception:\n\t        logging.error(f\"Fail to create dir: {dir}\")\n", "        exit()\n\tdef get_path_components(path):\n\t    path = Path(path)\n\t    ppath = str(path.parent)\n\t    stem = str(path.stem)\n\t    ext = str(path.suffix)\n\t    return ppath, stem, ext\n\tdef add_file_name_suffix(path_file, suffix):\n\t    ppath, stem, ext = get_path_components(path_file)\n\t    path_name_new = ppath + \"/\" + stem + str(suffix) + ext\n", "    return path_name_new\n\tdef add_file_name_prefix(path_file, prefix, check_exist = True):\n\t    '''Add prefix before file name\n\t    '''\n\t    ppath, stem, ext = get_path_components(path_file)\n\t    path_name_new = ppath + \"/\" + str(prefix) + stem  + ext\n\t    if check_exist:\n\t        ensure_dir_existence(ppath + \"/\" + str(prefix))\n\t    return path_name_new\n\tdef add_file_name_prefix_and_suffix(path_file, prefix, suffix, check_exist = True):\n", "    path_file_p = add_file_name_prefix(path_file, prefix, check_exist = True)\n\t    path_file_p_s = add_file_name_suffix(path_file_p, suffix)\n\t    return path_file_p_s\n\tdef get_files_stem(dir, ext_file):\n\t    '''Get stems of all files in directory with target extension\n\t    Return:\n\t        vec_stem\n\t    '''\n\t    vec_path = sorted(glob.glob(f'{dir}/**{ext_file}'))\n\t    vec_stem = []\n", "    for i in range(len(vec_path)):\n\t        pparent, stem, ext = get_path_components(vec_path[i])\n\t        vec_stem.append(stem)\n\t    return vec_stem\n\tdef get_files_path(dir, ext_file):\n\t    return sorted(glob.glob(f'{dir}/**{ext_file}'))\n\t# IO\n\tdef readLines(path_txt):\n\t    fTxt = open(path_txt, \"r\")\n\t    lines = fTxt.readlines()\n", "    return lines\n\tdef copy_file(source_path, target_dir):\n\t    try: \n\t        ppath, stem, ext = get_path_components(target_dir)\n\t        ensure_dir_existence(ppath)\n\t        shutil.copy(source_path, target_dir)\n\t    except Exception:\n\t        logging.error(f\"Fail to copy file: {source_path}\")\n\t        exit(-1)\n\tdef remove_dir(dir):\n", "    try:\n\t        shutil.rmtree(dir)\n\t    except Exception as ERROR_MSG:\n\t        logging.error(f\"{ERROR_MSG}.\\nFail to remove dir: {dir}\")\n\t        exit(-1)\n\tdef copy_dir(source_dir, target_dir):\n\t    try:\n\t        if not os.path.exists(source_dir):\n\t            logging.error(f\"source_dir {source_dir} is not exist. Fail to copy directory.\")\n\t            exit(-1)\n", "        shutil.copytree(source_dir, target_dir)\n\t    except Exception as ERROR_MSG:\n\t        logging.error(f\"{ERROR_MSG}.\\nFail to copy file: {source_dir}\")\n\t        exit(-1)\n\tdef INFO_MSG(msg):\n\t    print(msg)\n\t    sys.stdout.flush()\n\tdef changeWorkingDir(working_dir):\n\t    try:\n\t        os.chdir(working_dir)\n", "        print(f\"Current working directory is { os.getcwd()}.\")\n\t    except OSError:\n\t        print(\"Cann't change current working directory.\")\n\t        sys.stdout.flush()\n\t        exit(-1)\n\tdef run_subprocess(process_args):\n\t    pProcess = subprocess.Popen(process_args)\n\t    pProcess.wait()\n\tdef find_target_file(dir, file_name):\n\t    all_files_recur = glob.glob(f'{dir}/**{file_name}*', recursive=True)\n", "    path_target = None\n\t    if len(all_files_recur) == 1:\n\t        path_target = all_files_recur[0]\n\t    assert not len(all_files_recur) > 1\n\t    return path_target\n\tdef copy_files_in_dir(dir_src, dir_target, ext_file, rename_mode = 'stem'):\n\t    '''Copy files in dir and rename it if needed\n\t    '''\n\t    ensure_dir_existence(dir_target)\n\t    vec_path_files = sorted(glob.glob(f'{dir_src}/*{ext_file}'))\n", "    for i in range(len(vec_path_files)):\n\t        path_src = vec_path_files[i]\n\t        if rename_mode == 'stem':\n\t            pp, stem, _ = get_path_components(path_src)\n\t            path_target = f'{dir_target}/{stem}{ext_file}'\n\t        elif rename_mode == 'order':\n\t            path_target = f'{dir_target}/{i}{ext_file}'\n\t        elif rename_mode == 'order_04d':\n\t            path_target = f'{dir_target}/{i:04d}{ext_file}'\n\t        else:\n", "            NotImplementedError\n\t        copy_file(path_src, path_target)\n\t    return len(vec_path_files)\n\t# time-related funcs\n\tdef get_consumed_time(t_start):\n\t    '''\n\t    Return:\n\t        time: seconds\n\t    '''\n\t    t_end = datetime.now()\n", "    return (t_end-t_start).total_seconds()\n\tdef get_time_str(fmt='HMSM'):\n\t    if fmt == 'YMD-HMS':\n\t        str_time = datetime.now().strftime(\"%m/%d/%Y, %H:%M:%S\")\n\t    elif fmt == 'HMS':\n\t        str_time = datetime.now().strftime(\"%m/%d/%Y, %H:%M:%S\")\n\t    elif fmt == 'HMSM':\n\t        str_time = datetime.now().strftime(\"%H_%M_%S_%f\")\n\t    return str_time\n\tdef write_list_to_txt(path_list, data_list):\n", "    num_lines = len(data_list)\n\t    with open(path_list, 'w') as flis:\n\t        for i in range(len(data_list)):\n\t            flis.write(f'{data_list[i]}\\n')\n\tif __name__ == \"__main__\":\n\t    logging.basicConfig(\n\t        format='%(asctime)s | %(levelname)s | %(name)s | %(message)s',\n\t        datefmt='%Y-%m-%d %H:%M:%S',\n\t        level=logging.INFO,\n\t        stream=sys.stdout,\n", "        filename='example.log'\n\t    )"]}
{"filename": "utils/utils_image.py", "chunked_list": ["import matplotlib.pyplot as plt\n\timport torch\n\timport glob, os\n\timport cv2\n\timport logging\n\tfrom tqdm import tqdm\n\timport numpy as np\n\tfrom sklearn.cluster import KMeans\n\timport copy\n\tfrom skimage.color import rgb2gray\n", "from skimage.filters import sobel\n\tfrom skimage.segmentation import felzenszwalb\n\tfrom skimage.util import img_as_float\n\tfrom tqdm import tqdm\n\timport utils.utils_io as IOUtils\n\tDIR_FILE = os.path.abspath(os.path.dirname(__file__))\n\tdef calculate_normal_angle(normal1, normal2, use_degree = False):\n\t    '''Get angle to two vectors\n\t    Args:\n\t        normal1: N*3\n", "        normal2: N*3\n\t    Return:\n\t        angles: N*1\n\t    '''\n\t    check_dim = lambda normal : np.expand_dims(normal, axis=0) if normal.ndim == 1 else normal\n\t    normal1 = check_dim(normal1)\n\t    normal2 = check_dim(normal2)\n\t    inner = (normal1*normal2).sum(axis=-1)\n\t    norm1 = np.linalg.norm(normal1, axis=1, ord=2)\n\t    norm2 = np.linalg.norm(normal2, axis=1, ord=2)\n", "    angles_cos = inner / (norm1*norm2 + 1e-6)\n\t    angles = np.arccos(angles_cos)\n\t    if use_degree:\n\t        angles = angles/np.pi * 180\n\t    assert not np.isnan(angles).any()\n\t    return angles\n\tdef read_image(path, target_img_size = None, interpolation=cv2.INTER_LINEAR, color_space = 'BGR'):\n\t    img = cv2.imread(path, cv2.IMREAD_UNCHANGED)\n\t    if target_img_size is not None:\n\t        img= resize_image(img, target_img_size, interpolation=interpolation)\n", "    if color_space == 'RGB':\n\t        img = cv2.cvtColor(img.astype(np.uint8), cv2.COLOR_BGR2RGB)\n\t    return img\n\tdef write_image(path, img, color_space = None, \n\t                    target_img_size = None, interpolation = cv2.INTER_LINEAR):\n\t    '''If color space is defined, convert colors to RGB mode\n\t    Args:\n\t        target_img_size: resize image if defined\n\t    '''\n\t    if color_space == 'RGB':\n", "        img = cv2.cvtColor(img.astype(np.uint8), cv2.COLOR_BGR2RGB)\n\t    if target_img_size is not None:\n\t        img = resize_image(img, target_size=target_img_size, interpolation=interpolation)\n\t    cv2.imwrite(path, img)\n\tdef write_images(dir, imgs, stems = None, ext_img = '.png', color_space = None):\n\t    IOUtils.ensure_dir_existence(dir)\n\t    for i in range(len(imgs)):\n\t        if stems is None:\n\t            path = f'{dir}/{i:04d}{ext_img}'\n\t        else:\n", "            path = f'{dir}/{stems[i]}{ext_img}'\n\t        write_image(path, imgs[i], color_space)\n\tdef read_images(dir, target_img_size = None, interpolation=cv2.INTER_LINEAR, img_ext = '.png', use_rgb_mode = False, vec_stems = None):\n\t    f'''Read images in directory with extrension {img_ext}\n\t    Args:\n\t        dir: directory of images\n\t        target_img_size: if not none, resize read images to target size\n\t        img_ext: defaut {img_ext}\n\t        use_rgb_mode: convert brg to rgb if true\n\t    Return:\n", "        imgs: N*W*H\n\t        img_stems\n\t    '''\n\t    if img_ext == '.npy':\n\t        read_img = lambda path : np.load(path)\n\t    elif img_ext == '.npz':\n\t        read_img = lambda path : np.load(path)['arr_0']\n\t    elif img_ext in ['.png', '.jpg']:\n\t        read_img = lambda path : read_image(path)\n\t    else:\n", "        raise NotImplementedError\n\t    vec_path = sorted(glob.glob(f\"{dir}/**{img_ext}\"))\n\t    if vec_stems is not None:\n\t        vec_path = []\n\t        for stem_curr in vec_stems:\n\t            vec_path.append(f'{dir}/{stem_curr}{img_ext}')\n\t        vec_path = sorted(vec_path)\n\t    rgbs = []\n\t    img_stems = []\n\t    for i in range(len(vec_path)):\n", "        img = read_img(vec_path[i])\n\t        if (target_img_size != None) and (target_img_size[0] != img.shape[1]):\n\t            img= cv2.resize(img, target_img_size, interpolation=cv2.INTER_LINEAR)\n\t        if use_rgb_mode:\n\t            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\t        rgbs.append(img)\n\t        _, stem, _ = IOUtils.get_path_components(vec_path[i])\n\t        img_stems.append(stem)\n\t    return np.array(rgbs), img_stems\n\tdef get_planes_from_normalmap(dir_pred, thres_uncertain = 0):\n", "    '''Get normals from normal map for indoor dataset (ScanNet), which was got by the following paper:\n\t    Surface normal estimation with uncertainty\n\t    '''\n\t    dir_normals = os.path.join(dir_pred, 'pred_normal')\n\t    vec_path_imgs = sorted(glob.glob(f'{dir_normals}/**.png'))\n\t    num_images = len(vec_path_imgs)\n\t    assert num_images > 0\n\t    logging.info(f'Found images: {num_images}')\n\t    dir_mask_labels = os.path.join(dir_normals, '../pred_normal_planes')\n\t    dir_mask_labels_rgb = os.path.join(dir_normals, '../pred_normal_planes_rgb')\n", "    os.makedirs(dir_mask_labels, exist_ok=True)\n\t    os.makedirs(dir_mask_labels_rgb, exist_ok=True)\n\t    vec_path_kappa =  sorted(glob.glob(f'{dir_normals}/../pred_kappa/**.png'))\n\t    dir_normals_certain = f'{dir_normals}/../pred_normal_certain'\n\t    os.makedirs(dir_normals_certain, exist_ok=True)\n\t    channel_threshold = 200\n\t    channel_threshold_curr = channel_threshold\n\t    for j in tqdm(range(num_images)):\n\t        path = vec_path_imgs[j]\n\t        _, stem, ext = IOUtils.get_path_components(path)\n", "        img = read_image(path)\n\t        if thres_uncertain > 0:\n\t            img_kappa = read_image(vec_path_kappa[j])\n\t            mask_uncertain = img_kappa < thres_uncertain\n\t            img[mask_uncertain] = 0\n\t            write_image(f'{dir_normals_certain}/{stem}{ext}', img)\n\t        img_masks = []\n\t        imgs_lables = np.zeros((img.shape[0], img.shape[1]))\n\t        for i in range(3):\n\t            ch = img[:,:, i]\n", "            ch_mask = ch > channel_threshold\n\t            test = ch_mask.sum()\n\t            while ch_mask.sum() == 0:\n\t                channel_threshold_curr -= 10\n\t                ch_mask = ch > channel_threshold_curr\n\t            channel_threshold_curr = channel_threshold\n\t            if i==2:\n\t                ch_mask = img[:,:, 0] > 0\n\t                if ch_mask.sum() ==0:\n\t                    ch_mask = img[:,:, 1] > 0\n", "            ch_arr = ch[ch_mask]\n\t            count_arr = np.bincount(ch[ch_mask])\n\t            ch_value_most = np.argmax(count_arr)\n\t            logging.info(f\"[{j}-{i}] Channel value most: {ch_value_most}\")\n\t            # ch_value_most = np.max(ch)\n\t            sample_range_half = 5\n\t            range_min = ch_value_most - sample_range_half if ch_value_most > sample_range_half else 0\n\t            range_max = ch_value_most + sample_range_half if ch_value_most < (255-sample_range_half) else 255\n\t            logging.debug(f'Sample range: [{range_min}, {range_max}]')\n\t            # ToDO: check other channels\n", "            ch_mask = (ch > range_min) & (ch < range_max)\n\t            ch = ch * ch_mask\n\t            img_masks.append(ch_mask)\n\t            imgs_lables[ch_mask] = i + 1\n\t            img[ch_mask] = 0\n\t        img = np.stack(img_masks, axis=-1).astype(np.float) * 255\n\t        write_image(f'{dir_mask_labels_rgb}/{stem}{ext}', img) \n\t        write_image(f'{dir_mask_labels}/{stem}{ext}', imgs_lables) \n\tdef cluster_normals_kmeans(path_normal, n_clusters=12, thres_uncertain = -1, folder_name_planes = 'pred_normal_planes'):\n\t    '''Use k-means to cluster normals of images.\n", "    Extract the maximum 6 planes, where the second largest 3 planes will remove the uncertain pixels by thres_uncertain\n\t    '''\n\t    PROP_PLANE = 0.03\n\t    PROP_DOMINANT_PLANE = 0.05\n\t    ANGLE_DIFF_DOMINANT_PLANE_MIN = 75\n\t    ANGLE_DIFF_DOMINANT_PLANE_MAX = 105\n\t    MAGNITUDE_PLANES_MASK = 1\n\t    path_img_normal = path_normal[:-4]+'.png'\n\t    img = np.load(path_normal)['arr_0']\n\t    shape = img.shape\n", "    num_pixels_img = shape[0] * shape [1]\n\t    MIN_SIZE_PIXELS_PLANE_AREA = num_pixels_img*0.02\n\t    if thres_uncertain > 0:\n\t        path_alpha = IOUtils.add_file_name_prefix(path_normal, '../pred_alpha/')\n\t        img_alpha = np.load(path_alpha)['arr_0']\n\t        mask_uncertain = img_alpha > thres_uncertain\n\t    path_rgb = IOUtils.add_file_name_prefix(path_img_normal, '../image/')\n\t    img_rgb = read_image(path_rgb)[:,:,:3]\n\t    img_rgb = resize_image(img_rgb, target_size=(shape[1], shape[0], 3))\n\t        # img[mask_uncertain] = 0\n", "        # path_uncertain = os.path.abspath( IOUtils.add_file_name_prefix(path_img_normal, '../pred_uncertain/') )\n\t        # os.makedirs(os.path.dirname(path_uncertain),exist_ok=True)\n\t        # write_image(path_uncertain, img)\n\t    kmeans = KMeans(n_clusters=n_clusters, random_state=0).fit(img.reshape(-1, 3))\n\t    pred = kmeans.labels_\n\t    centers = kmeans.cluster_centers_\n\t    num_max_planes = 7\n\t    count_values = np.bincount(pred)\n\t    max5 = np.argpartition(count_values,-num_max_planes)[-num_max_planes:]\n\t    prop_planes = np.sort(count_values[max5] / num_pixels_img)[::-1]\n", "    # logging.info(f'Proportion of planes: {prop_planes}; Proportion of the 3 largest planes: {np.sum(prop_planes[:3]):.04f}; Image name: {path_img_normal.split(\"/\")[-1]}')\n\t    centers_max5 = centers[max5]\n\t    sorted_idx_max5 = np.argsort(count_values[max5] / num_pixels_img)\n\t    sorted_max5 = max5[sorted_idx_max5][::-1]\n\t    sorted_centers_max5  = centers_max5[sorted_idx_max5][::-1]\n\t    # idx_center_uncertain_area = -1\n\t    # for i in range(len(sorted_centers_max5)):\n\t    #     # print(sorted_centers_max5[i].sum())\n\t    #     if sorted_centers_max5[i].sum() < 1e-6:\n\t    #         idx_center_uncertain_area = i\n", "    # if idx_center_uncertain_area >= 0:\n\t    #     sorted_max5 = np.delete(sorted_max5, idx_center_uncertain_area)\n\t    colors_planes =[(255,0,0), (0,255,0), (0,0,255), (255,255,0), (0,255,255), (255,0,255)]  # r,g,b, yellow, Cyan, Magenta\n\t    planes_rgb = np.zeros(shape).reshape(-1,3)\n\t    img_labels = np.zeros([*shape[:2]]).reshape(-1,1)\n\t    count_planes = 0\n\t    angles_diff = np.zeros(3)\n\t    for i in range(6):\n\t        curr_plane = (pred==sorted_max5[count_planes])\n\t        # remove small isolated areas\n", "        mask_clean = remove_small_isolated_areas((curr_plane>0).reshape(*shape[:2])*255, min_size=MIN_SIZE_PIXELS_PLANE_AREA).reshape(-1)\n\t        curr_plane[mask_clean==0] = 0\n\t        ratio_curr_plane = curr_plane.sum() / num_pixels_img\n\t        check_sim = True\n\t        if check_sim:\n\t            # (1) check plane size\n\t            if ratio_curr_plane < PROP_PLANE: # small planes: ratio > 2%\n\t                continue\n\t            if i < 3 and ratio_curr_plane < PROP_DOMINANT_PLANE: # dominant planes: ratio > 10%\n\t                continue\n", "            # (2) check normal similarity\n\t            eval_metric = 'angle'\n\t            if eval_metric == 'distance':\n\t                curr_normal = sorted_centers_max5[count_planes]\n\t                thres_diff = ANGLE_DIFF_DOMINANT_PLANE\n\t                if i ==1: \n\t                    dist1 = np.linalg.norm(sorted_centers_max5[i-1]-curr_normal).sum()\n\t                    angles_diff[0] = dist1\n\t                    if dist1 < thres_diff:\n\t                        continue\n", "                if i == 2:\n\t                    dist1 = np.linalg.norm(sorted_centers_max5[count_planes-1]-curr_normal).sum()\n\t                    dist2 = np.linalg.norm(sorted_centers_max5[0]-curr_normal).sum()\n\t                    angles_diff[1] = dist1\n\t                    angles_diff[2] = dist2\n\t                    if dist1 < thres_diff or dist2 < thres_diff:\n\t                        continue\n\t                        print(f'Dist1, dist2: {dist1, dist2}')\n\t            if eval_metric == 'angle':\n\t                curr_normal = sorted_centers_max5[count_planes]\n", "                thres_diff_min = ANGLE_DIFF_DOMINANT_PLANE_MIN\n\t                thres_diff_max = ANGLE_DIFF_DOMINANT_PLANE_MAX\n\t                if i ==1: \n\t                    angle1 = calculate_normal_angle(sorted_centers_max5[i-1], curr_normal, use_degree=True)\n\t                    angles_diff[0] = angle1\n\t                    if angle1 < thres_diff_min or angle1 > thres_diff_max:\n\t                        continue\n\t                if i == 2:\n\t                    angle1 = calculate_normal_angle(sorted_centers_max5[count_planes-1], curr_normal, use_degree=True)\n\t                    angle2 = calculate_normal_angle(sorted_centers_max5[0], curr_normal, use_degree=True)\n", "                    angles_diff[1] = angle1\n\t                    angles_diff[2] = angle2\n\t                    if angle1 < thres_diff_min or angle2 < thres_diff_min or \\\n\t                        angle1 >  thres_diff_max or angle2 >  thres_diff_max :\n\t                        continue\n\t                        print(f'Dist1, dist2: {dist1, dist2}')                \n\t        count_planes += 1\n\t        img_labels[curr_plane] = (i+1)*MAGNITUDE_PLANES_MASK\n\t        if thres_uncertain > -1:\n\t            # remove the influence of uncertainty pixels on small planes\n", "            curr_plane[mask_uncertain.reshape(-1)] = 0\n\t        planes_rgb[curr_plane] = colors_planes[i]\n\t        # save current plane\n\t        if img_rgb is not None:\n\t            path_planes_visual_compose = IOUtils.add_file_name_prefix(path_img_normal, f\"../{folder_name_planes}_visual_compose/{i+1}/\",check_exist=True)\n\t            mask_non_plane = (curr_plane < 1).reshape(shape[:2])\n\t            img_compose = copy.deepcopy(img_rgb)\n\t            img_compose[mask_non_plane] = 0\n\t            write_image(path_planes_visual_compose, img_compose)\n\t        # else:\n", "        #     center0, center1, center2, center3 = centers[sorted_max5[0]], centers[sorted_max5[1]],centers[sorted_max5[2]], centers[sorted_max5[3]]\n\t        #     diff = center1 - center2\n\t        #     dist12 = np.linalg.norm(diff)\n\t        #     if dist12 < 50:\n\t        #         img_labels[pred==sorted_max5[3]]= i+1\n\t        #         curr_channel = (pred==sorted_max5[3])\n\t        #     else:\n\t        #         img_labels[pred==sorted_max5[2]]= i+1\n\t        #         curr_channel = (pred==sorted_max5[2])\n\t    img_labels = img_labels.reshape(*shape[:2])\n", "    path_labels = IOUtils.add_file_name_prefix(path_img_normal, f\"../{folder_name_planes}/\")\n\t    write_image(path_labels, img_labels)\n\t    msg_log = f'{path_img_normal.split(\"/\")[-1]}: {prop_planes} {np.sum(prop_planes[:3]):.04f} {1.0 - (img_labels==0).sum() / num_pixels_img : .04f}. Angle differences (degrees): {angles_diff}'\n\t    logging.info(msg_log)\n\t    # planes_rgb = np.stack(planes_rgb, axis=-1).astype(np.float32)*255\n\t    # visualization\n\t    planes_rgb = planes_rgb.reshape(shape)\n\t    path_planes_visual = IOUtils.add_file_name_prefix(path_img_normal, f\"../{folder_name_planes}_visual/\", check_exist=True)\n\t    planes_rgb = cv2.cvtColor(planes_rgb.astype(np.uint8), cv2.COLOR_BGR2RGB)\n\t    mask_planes = planes_rgb.sum(axis=-1)>0\n", "    # mask_planes = np.stack([mask_planes]*3, axis=-1)\n\t    curre_img_ = copy.deepcopy(img_rgb)\n\t    curre_img_[mask_planes==False] = (255,255,255)\n\t    # planes_rgb_cat = np.concatenate((planes_rgb, curre_img_, img_rgb))\n\t    # write_image(path_planes_visual, planes_rgb_cat)\n\t    # visualize plane error\n\t    img_normal_error = np.zeros(img.shape[:2])\n\t    MAX_ANGLE_ERROR = 15\n\t    for i in range(int(np.max(img_labels))):\n\t        id_label = i+1\n", "        mask_plane_curr = (img_labels==id_label)\n\t        if mask_plane_curr.sum() ==0:\n\t            continue\n\t        normal_curr_plane = img[mask_plane_curr]\n\t        mean_normal_curr = normal_curr_plane.mean(axis=0)\n\t        angle_error = calculate_normal_angle(normal_curr_plane, mean_normal_curr, use_degree=True)\n\t        img_normal_error[mask_plane_curr] = np.abs(angle_error)\n\t    if thres_uncertain > -1:\n\t        # remove the influence of uncertainty pixels on small planes\n\t        img_normal_error[mask_uncertain] = 0\n", "    path_planes_visual_error = IOUtils.add_file_name_prefix(path_img_normal, f\"../{folder_name_planes}_visual_error/\", check_exist=True)\n\t    path_planes_visual_error2 = IOUtils.add_file_name_suffix(path_planes_visual_error, \"_jet\")\n\t    img_normal_error_cmap =  convert_gray_to_cmap(img_normal_error.clip(0, MAX_ANGLE_ERROR))\n\t    # img_normal_error_cmap = convert_color_BRG2RGB(img_normal_error_cmap)\n\t    img_normal_error_cmap[mask_planes==False] = (255,255,255)\n\t    img_normal_error_stack = np.stack([img_normal_error.clip(0, MAX_ANGLE_ERROR)]*3, axis=-1)/MAX_ANGLE_ERROR*255\n\t    img_normal_error_stack[mask_planes==False] = (255,255,255)\n\t    # img_gap = 255 * np.ones((img_normal_error.shape[0], 20, 3)).astype('uint8')\n\t    # write_image(path_planes_visual_error, np.concatenate([img_rgb, img_gap, planes_rgb, img_gap, img_normal_error_cmap, img_gap, img_normal_error_stack], axis=1))\n\t    write_image_lis(path_planes_visual, [img_rgb, planes_rgb, curre_img_, img_normal_error_cmap, img_normal_error_stack])\n", "    # plt.imsave(path_planes_visual_error2, img_normal_error, vmin=0, vmax=MAX_ANGLE_ERROR, cmap = 'jet')\n\t    # plt.imsave(path_planes_visual_error, img_normal_error, vmin=0, vmax=MAX_ANGLE_ERROR, cmap = 'gray')\n\t    # img_normal_error = img_normal_error/np.max(img_normal_error) * 255\n\t    # write_image(path_planes_visual_error, img_normal_error)  \n\t    # if planes_rgb.shape[2] > 3:\n\t    #     path_planes_visual2 = IOUtils.add_file_name_suffix(path_planes_visual, '_2')\n\t    #     write_image(path_planes_visual2, planes_rgb[:,:, 3:])\n\t    # img2 = copy.deepcopy((img_rgb))\n\t    # mask_planes2_reverse = (planes_rgb[:,:, 3:].sum(axis=-1) == 0)\n\t    # img2[mask_planes2_reverse] = 0\n", "    # path_planes2_color = IOUtils.add_file_name_suffix(path_planes_visual, f\"_color2\")\n\t    # write_image(path_planes2_color, img2)\n\t    # img3 = copy.deepcopy((img_rgb))\n\t    # img3[planes_rgb[:,:, 3:].sum(axis=-1) > 0] = 255\n\t    # path_color2_reverse = IOUtils.add_file_name_suffix(path_planes_visual, '_color2_reverse')\n\t    # write_image(path_color2_reverse, img3)\n\t    # path_default = IOUtils.add_file_name_suffix(path_planes_visual, '_default')\n\t    # write_image(path_default, img_rgb)\n\t    return msg_log\n\tdef remove_image_background(path_png, path_mask, path_merge = None, reso_level=0):\n", "    '''Remove image background using mask and resize image if reso_level > 0\n\t    Args:\n\t        path_png: path of source image\n\t    Return:\n\t        img_with_mask: image without background\n\t    '''\n\t    img = cv2.imread(path_png)\n\t    mask = cv2.imread(path_mask)[:,:,-1]\n\t    res = cv2.bitwise_and(img, img, mask=mask)\n\t    mask = np.expand_dims(mask, -1)\n", "    img_with_mask = np.concatenate((res, mask), axis=2)\n\t    if reso_level > 0:\n\t        shape_target = img_with_mask.shape[:2] // np.power(2, reso_level)\n\t        shape_target = (shape_target[1], shape_target[0])\n\t        img_with_mask = cv2.resize(img_with_mask, shape_target, interpolation=cv2.INTER_LINEAR)\n\t    if path_merge != None:\n\t        cv2.imwrite(path_merge, img_with_mask)\n\t    logging.debug(f\"Remove background of img: {path_png}\")\n\t    return img_with_mask\n\tdef resize_image(img, target_size, interpolation=cv2.INTER_LINEAR):\n", "    '''Resize image to target size\n\t    Args:\n\t        target_size: (W,H)\n\t    Return img_resize\n\t    '''\n\t    W,H = target_size[0], target_size[1]\n\t    if img.shape[0] != H or img.shape[1] != W:\n\t        img_resize = cv2.resize(img, (W,H), interpolation=interpolation)\n\t        return img_resize\n\t    else:\n", "        return img\n\tdef convert_images_type(dir_imgs, dir_target, \n\t                        rename_mode = 'stem',\n\t                        target_img_size = None, ext_source = '.png', ext_target = '.png', \n\t                        sample_interval = -1):\n\t    '''Convert image type in directory from ext_imgs to ext_target\n\t    '''\n\t    IOUtils.ensure_dir_existence(dir_target)\n\t    vec_path_files = sorted(glob.glob(f'{dir_imgs}/**{ext_source}'))\n\t    stems = []\n", "    for i in range(len(vec_path_files)):\n\t        pp, stem, ext = IOUtils.get_path_components(vec_path_files[i])\n\t        # id_img = int(stem)\n\t        id_img = i\n\t        if sample_interval > 1:\n\t            # sample images\n\t            if id_img % sample_interval !=0:\n\t                continue\n\t        if rename_mode == 'stem':\n\t            path_target = f'{dir_target}/{stem}{ext_target}'\n", "        elif rename_mode == 'order':\n\t            path_target = f'{dir_target}/{i}{ext_target}'\n\t        elif rename_mode == 'order_04d':\n\t            path_target = f'{dir_target}/{i:04d}{ext_target}'\n\t        else:\n\t            NotImplementedError\n\t        if ext_source[-4:] == ext_target:\n\t            IOUtils.copy_file(vec_path_files[i], path_target)\n\t        else:\n\t            img = read_image(vec_path_files[i])\n", "            write_image(path_target, img, target_img_size=target_img_size)\n\t        stems.append(stem)\n\t    return len(vec_path_files), stems\n\t# image noise\n\tdef add_image_noise(image, noise_type='gauss', noise_std = 10):\n\t    '''Parameters\n\t    ----------\n\t    image : ndarray\n\t        Input image data. Will be converted to float.\n\t    mode : str\n", "        One of the following strings, selecting the type of noise to add:\n\t        'gauss'     Gaussian-distributed additive noise.\n\t        'poisson'   Poisson-distributed noise generated from the data.\n\t        's&p'       Replaces random pixels with 0 or 1.\n\t        'speckle'   Multiplicative noise using out = image + n*image,where\n\t                    n is uniform noise with specified mean & variance.\n\t    Ref: https://stackoverflow.com/questions/22937589/how-to-add-noise-gaussian-salt-and-pepper-etc-to-image-in-python-with-opencv\n\t    '''\n\t    if noise_type == \"gauss\":\n\t        row,col,ch= image.shape\n", "        mean = 0\n\t        sigma = noise_std\n\t        logging.debug(f'Gauss noise (mean, sigma): {mean,sigma}')\n\t        gauss = np.random.normal(mean,sigma,(row,col, ch))\n\t        gauss = gauss.reshape(row,col, ch)\n\t        noisy = image + gauss\n\t        return noisy\n\t    elif noise_type == \"s&p\":\n\t        row,col,ch = image.shape\n\t        s_vs_p = 0.5\n", "        amount = 0.004\n\t        out = np.copy(image)\n\t        # Salt mode\n\t        num_salt = np.ceil(amount * image.size * s_vs_p)\n\t        coords = [np.random.randint(0, i - 1, int(num_salt))\n\t                for i in image.shape]\n\t        out[coords] = 1\n\t        # Pepper mode\n\t        num_pepper = np.ceil(amount* image.size * (1. - s_vs_p))\n\t        coords = [np.random.randint(0, i - 1, int(num_pepper))\n", "                for i in image.shape]\n\t        out[coords] = 0\n\t        return out\n\t    elif noise_type == \"poisson\":\n\t        vals = len(np.unique(image))\n\t        vals = 2 ** np.ceil(np.log2(vals))\n\t        noisy = np.random.poisson(image * vals) / float(vals)\n\t        return noisy\n\t    elif noise_type ==\"speckle\":\n\t        row,col,ch = image.shape\n", "        gauss = np.random.randn(row,col,ch)\n\t        gauss = gauss.reshape(row,col,ch)        \n\t        noisy = image + image * gauss\n\t        return noisy\n\t# lines\n\tdef extract_lines(dir_image, img_size, focal, ext_img = '.png'):\n\t    dir_lines = dir_image + '_lines'\n\t    IOUtils.ensure_dir_existence(dir_lines)\n\t    dir_only_lines = dir_image + '_only_lines'\n\t    IOUtils.ensure_dir_existence(dir_only_lines)\n", "    vec_path_imgs = glob.glob(f'{dir_image}/**{ext_img}')\n\t    for i in tqdm(range(len(vec_path_imgs))):\n\t        path = vec_path_imgs[i]\n\t        _, stem, ext = IOUtils.get_path_components(path)\n\t        path_lines_img = f'{dir_lines}/{stem}.png'\n\t        path_lines_txt = f'{dir_lines}/{stem}.txt'\n\t        path_log =  f'{dir_lines}/num_lines.log'\n\t        width = img_size[0]\n\t        height = img_size[1]\n\t        path_only_lines =  f'{dir_only_lines}/{stem}.png'\n", "        os.system(f'{DIR_FILE}/VanishingPoint {path} {path_lines_img} {path_lines_txt} {width} {height} {focal} {path_log} {path_only_lines}')\n\t# image segmentation\n\tdef extract_superpixel(path_img, CROP = 16):\n\t    scales, markers = [1], [400]\n\t    img = cv2.imread(path_img)\n\t    image = copy.deepcopy(img)\n\t    image = image[CROP:-CROP, CROP:-CROP, :]\n\t    segments = []\n\t    for s, m in zip(scales, markers):\n\t        image = cv2.resize(image, (384//s, 288//s), interpolation=cv2.INTER_LINEAR)\n", "        image = img_as_float(image)\n\t        gradient = sobel(rgb2gray(image))\n\t        # segment = watershed(gradient, markers=m, compactness=0.001)\n\t        segment = felzenszwalb(image, scale=100, sigma=0.5, min_size=50)\n\t        segments.append(segment)\n\t    img_seg = segments[0].astype(np.int16)\n\t    img_seg = resize_image(img_seg, target_size=img.shape[:2][::-1], interpolation=cv2.INTER_NEAREST)\n\t    return img, img_seg\n\tdef find_labels_max_clusters(pred, num_max_clusters):\n\t    '''Find labels of the maximum n clusters with descending order\n", "    Args:\n\t        pred: N*1\n\t        num_max_clusters: how many clusters to find\n\t    '''\n\t    count_values = np.bincount(pred)\n\t    num_max_clusters = np.min([len(count_values), num_max_clusters])\n\t    max_planes = np.argpartition(count_values,-num_max_clusters)[-num_max_clusters:]\n\t    sorted_idx_max_planes = np.argsort(count_values[max_planes] / len(pred))\n\t    sorted_max_planes = max_planes[sorted_idx_max_planes][::-1]\n\t    prop_planes = np.sort(count_values[sorted_max_planes] / len(pred))[::-1]\n", "    return sorted_max_planes, prop_planes, num_max_clusters\n\tdef visualize_semantic_label():\n\t    # scannet\n\t    img = read_image('/media/hp/HKUCS2/Dataset/ScanNet/scannet_whole/scene0079_00/label-filt/1.png')\n\t    img_mask = np.zeros(img.shape + tuple([3]))\n\t    for i in range(int(img.max()+1)):\n\t        mask_curr = (img == i)\n\t        img_mask[mask_curr] = np.random.randint(0, 255, 3)\n\t    write_image('./test.png', img_mask)\n\tdef remove_small_isolated_areas(img, min_size = 3000):\n", "    f'''Remove the small isolated areas with size smaller than defined {min_size}\n\t    '''\n\t    if img.ndim ==3:\n\t        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\t    else:\n\t        gray = copy.deepcopy(img).astype(np.uint8)\n\t    ret, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\n\t    nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(binary, connectivity=8)\n\t    sizes = stats[1:, -1]; nb_components = nb_components - 1\n\t    img_clean = np.zeros((output.shape))\n", "    for i in range(0, nb_components):\n\t        if sizes[i] >= min_size:\n\t            img_clean[output == i + 1] = 255\n\t    return img_clean\n\tdef convert_gray_to_cmap(img_gray, map_mode = 'jet', revert = True, vmax = None):\n\t    '''Visualize point distances with 'hot_r' color map\n\t    Args:\n\t        cloud_source\n\t        dists_to_target\n\t    Return:\n", "        cloud_visual: use color map, max\n\t    '''\n\t    img_gray = copy.deepcopy(img_gray)\n\t    shape = img_gray.shape\n\t    cmap = plt.get_cmap(map_mode)\n\t    if vmax is not None:\n\t        img_gray = img_gray / vmax\n\t    else:\n\t        img_gray = img_gray / (np.max(img_gray)+1e-6)\n\t    if revert:\n", "        img_gray = 1- img_gray      \n\t    colors = cmap(img_gray.reshape(-1))[:, :3]\n\t    # visualization\n\t    colors = colors.reshape(shape+tuple([3]))*255\n\t    return colors\n\t#image editting\n\tdef crop_images(dir_images_origin, dir_images_crop, crop_size, img_ext = '.png'):\n\t    IOUtils.ensure_dir_existence(dir_images_crop)\n\t    imgs, stems_img = read_images(dir_images_origin, img_ext = img_ext)\n\t    W_target, H_target = crop_size\n", "    for i in range(len(imgs)):\n\t        img_curr = imgs[i]\n\t        H_origin, W_origin = img_curr.shape[:2]\n\t        crop_width_half = (W_origin-W_target)//2\n\t        crop_height_half = (H_origin-H_target) //2\n\t        assert (W_origin-W_target)%2 ==0 and (H_origin- H_target) %2 == 0\n\t        img_crop = img_curr[crop_height_half:H_origin-crop_height_half, crop_width_half:W_origin-crop_width_half]\n\t        if img_ext == '.png':\n\t            write_image(f'{dir_images_crop}/{stems_img[i]}.png', img_crop)\n\t        elif img_ext == '.npy':\n", "            np.save(f'{dir_images_crop}/{stems_img[i]}.npy', img_crop)\n\t        else:\n\t            raise NotImplementedError\n\t    return crop_width_half, crop_height_half\n\tdef split_video_to_frames(path_video, dir_images):\n\t    IOUtils.ensure_dir_existence(dir_images)\n\t    vidcap = cv2.VideoCapture(path_video)\n\t    success,image = vidcap.read()\n\t    count = 0\n\t    while success:\n", "        cv2.imwrite(f'{dir_images}/{count:04d}.png', image)     # save frame as JPEG file      \n\t        success,image = vidcap.read()\n\t        logging.info(f'Read a new frame: {count}, {success}.')\n\t        count += 1\n\t    logging.info(f'End. Frames: {count}')\n\t# concatenate images\n\tdef write_image_lis(path_img_cat, lis_imgs, use_cmap = False, interval_img = 20, cat_mode = 'horizontal', color_space = 'BGR'):\n\t    '''Concatenate an image list to a single image and save it to the target path\n\t    Args:\n\t        cat_mode: horizonal/vertical\n", "    '''\n\t    img_cat = []\n\t    for i in range(len(lis_imgs)):\n\t        img = lis_imgs[i]\n\t        H, W = img.shape[:2]\n\t        if use_cmap:\n\t            img = convert_gray_to_cmap(img) if img.ndim==2 else img\n\t        else:\n\t            img = np.stack([img]*3, axis=-1) if img.ndim==2 else img\n\t        if img.max() <= 1.0:\n", "            img *= 255\n\t        img_cat.append(img)\n\t        if cat_mode == 'horizontal':\n\t            img_cat.append(255 * np.ones((H, interval_img, 3)).astype('uint8'))\n\t        elif cat_mode == 'vertical':\n\t            img_cat.append(255 * np.ones((interval_img, W, 3)).astype('uint8'))\n\t    if cat_mode == 'horizontal':\n\t        img_cat = np.concatenate(img_cat[:-1], axis=1)\n\t    elif cat_mode == 'vertical':\n\t        img_cat = np.concatenate(img_cat[:-1], axis=0)\n", "    else:\n\t        raise NotImplementedError\n\t    if color_space == 'RGB':\n\t        img_cat = cv2.cvtColor(img_cat.astype(np.uint8), cv2.COLOR_BGR2RGB)\n\t    cv2.imwrite(path_img_cat, img_cat)\n\tdef calculate_psnr_nerf(path_img_src, path_img_gt, mask = None):\n\t    img_src = read_image(path_img_src) / 255.0 #[:480]\n\t    img_gt = read_image(path_img_gt) / 255.0\n\t    # print(img_gt.shape)\n\t    img_src = torch.from_numpy(img_src)\n", "    img_gt = torch.from_numpy(img_gt)\n\t    img2mse = lambda x, y : torch.mean((x - y) ** 2)\n\t    mse2psnr = lambda x : -10. * torch.log(x) / torch.log(torch.Tensor([10.]))\n\t    err = img2mse(img_src, img_gt)\n\t    # print(f'Error shape: {err.shape} {err}')\n\t    psnr = mse2psnr(err)\n\t    return float(psnr)\n\tdef eval_imgs_psnr(dir_img_src, dir_img_gt, sample_interval):\n\t    vec_stems_imgs = IOUtils.get_files_stem(dir_img_src, '.png')   \n\t    psnr_all = []\n", "    for i in tqdm(range(0, len(vec_stems_imgs), sample_interval)):\n\t        stem_img = vec_stems_imgs[i]\n\t        path_img_src = f'{dir_img_src}/{stem_img}.png'  \n\t        path_img_gt   = f'{dir_img_gt}/{stem_img[9:13]}.png' \n\t        # print(path_img_src, path_img_gt)\n\t        psnr = calculate_psnr_nerf(path_img_src, path_img_gt)\n\t        # print(f'PSNR: {psnr} {stem_img}')\n\t        psnr_all.append(psnr)\n\t    return np.array(psnr_all), vec_stems_imgs\n"]}
{"filename": "preprocess/depthneus_data.py", "chunked_list": ["import os, glob\n\timport logging, copy, pickle\n\timport numpy as np\n\tfrom cv2 import  cv2\n\tfrom tqdm import tqdm\n\tfrom preprocess.scannet_data import ScannetData\n\tfrom utils.utils_geometry import read_cam_matrix, resize_cam_intrin\n\tfrom utils.utils_image import cluster_normals_kmeans, find_labels_max_clusters, remove_small_isolated_areas\n\tfrom utils.utils_io import add_file_name_suffix, checkExistence\n\tfrom utils.utils_image import extract_superpixel, read_image, read_images, write_image, \\\n", "                                find_labels_max_clusters, read_image, read_images, write_image\n\timport utils.utils_geometry as GeoUtils\n\timport utils.utils_image  as ImageUtils\n\timport utils.utils_io as IOUtils\n\tfrom confs.path import path_tiltedsn_pth_pfpn, path_tiltedsn_pth_sr, dir_tiltedsn_code, \\\n\t                            path_snu_pth, dir_snu_code, \\\n\t                            lis_name_scenes_remove\n\tdef crop_images_depthneus(dir_imgs, dir_imgs_crop, path_intrin, path_intrin_crop, crop_size):\n\t    assert checkExistence(dir_imgs)\n\t    crop_width_half, crop_height_half = ImageUtils.crop_images(dir_imgs, dir_imgs_crop, crop_size)\n", "    GeoUtils.modify_intrinsics_of_cropped_images(path_intrin, path_intrin_crop,  crop_width_half, crop_height_half)\n\tdef extract_planes_from_normals(dir_normal, thres_uncertain = 70, folder_name_planes = 'pred_normal_planes', n_clusters = 12):\n\t    vec_path_files = sorted(glob.glob(f'{dir_normal}/**.npz'))\n\t    path_log = f'{dir_normal}/../log_extract_planes.txt'\n\t    f_log = open(path_log, 'w')\n\t    for i in tqdm(range(len(vec_path_files))):\n\t        path = vec_path_files[i]\n\t        msg_log = cluster_normals_kmeans(path, n_clusters= n_clusters, thres_uncertain = thres_uncertain, folder_name_planes = folder_name_planes)\n\t        f_log.write(msg_log + '\\n')\n\t    f_log.close()\n", "def segment_one_image_superpixels(path_img, folder_visual):\n\t    # refer to: https://github.com/SJTU-ViSYS/StructDepth for more details\n\t    MAGNITUDE_PLANE_LABEL = 1\n\t    image, pred = extract_superpixel(path_img)\n\t    shape = image.shape\n\t    num_max_clusters= 12\n\t    pred = pred.reshape(-1)\n\t    sorted_max5, prop_planes, num_max_clusters = find_labels_max_clusters(pred, num_max_clusters=num_max_clusters)\n\t    # visulize labels\n\t    colors_planes =[(255,0,0), (0,255,0), (0,0,255), (255,255,0), (0,255,255), (255,0,255)]  # r,g,b, yellow, Cyan, Magenta\n", "    planes_rgb = np.zeros(shape).reshape(-1,3)\n\t    img_labels = np.zeros([*shape[:2]]).reshape(-1,1)\n\t    for i in range(num_max_clusters):\n\t        curr_plane = (pred==sorted_max5[i])\n\t        ratio = curr_plane.sum() / shape[0]*shape[1]\n\t        if ratio < 0.05:\n\t            continue\n\t        img_labels[curr_plane] = (i+1) * MAGNITUDE_PLANE_LABEL\n\t        if i < 6:\n\t            planes_rgb[curr_plane] = colors_planes[i]\n", "        else:\n\t            planes_rgb[curr_plane] = np.random.randint(low=0, high=255, size=3)\n\t    img_labels = img_labels.reshape(*shape[:2])\n\t    write_image(IOUtils.add_file_name_prefix(path_img, f'../{folder_visual}/'), img_labels)\n\t    planes_rgb = planes_rgb.reshape(shape)\n\t    mask_planes = planes_rgb.sum(axis=-1 )>0\n\t    mask_planes = np.stack([mask_planes]*3, axis=-1)\n\t    curre_img_compose = copy.deepcopy(image )\n\t    curre_img_compose[mask_planes==False] = 0\n\t    planes_rgb_cat = np.concatenate([planes_rgb, curre_img_compose, image], axis=0)\n", "    write_image(IOUtils.add_file_name_prefix(path_img, f'../{folder_visual}_visual/'), planes_rgb_cat)\n\t    msg_log = f'{prop_planes} {np.sum(prop_planes[:6]):.04f} {path_img.split(\"/\")[-1]}'\n\t    return msg_log\n\tdef segment_images_superpixels(dir_images):\n\t    '''Segment images in directory and save segmented images in the same parent folder\n\t    Args:\n\t        dir_images\n\t    Return:\n\t        None\n\t    '''\n", "    vec_path_imgs = IOUtils.get_files_path(dir_images, '.png')\n\t    path_log = f'{dir_images}/log_seg_images.txt'\n\t    f_log = open(path_log, 'w')\n\t    for i in tqdm(range(len(vec_path_imgs))):\n\t        path = vec_path_imgs[i]\n\t        msg_log = segment_one_image_superpixels(path, folder_visual='image_planes')\n\t        f_log.write(msg_log + '\\n')\n\t    f_log.close()\n\tdef compose_normal_img_planes(dir):\n\t    MAGNITUDE_COMPOSED_PLANER_LABEL = 1\n", "    PROPORTION_PLANES = 0.03  # 5%\n\t    dir_img_planes = f'{dir}/image_planes'\n\t    dir_normal_planes = f'{dir}/pred_normal_planes'\n\t    dir_planes_compose = f'{dir}/pred_normal_subplanes'\n\t    dir_planes_compose_visual = f'{dir}/pred_normal_subplanes_visual'\n\t    IOUtils.ensure_dir_existence(dir_planes_compose)\n\t    IOUtils.ensure_dir_existence(dir_planes_compose_visual)\n\t    planes_normal_all, stem_normals = read_images(f'{dir}/pred_normal_planes')\n\t    planes_color_all, stem_imgs = read_images( f'{dir}/image_planes', target_img_size=planes_normal_all[0].shape[::-1], interpolation=cv2.INTER_NEAREST)\n\t    imgs_rgb,_ = read_images(f'{dir}/image', target_img_size=planes_normal_all[0].shape[::-1])\n", "    # 0. all planes\n\t    planes_compose_all = []\n\t    planes_compose_rgb_all = []\n\t    f_log = open(f'{dir}/log_num_subplanes.txt', 'w')\n\t    for i in tqdm(range(len(planes_color_all))):\n\t        curr_planes_normal = planes_normal_all[i]\n\t        curr_planes_color = planes_color_all[i]\n\t        # 1. nornal planes\n\t        curr_planes_compose = np.zeros_like(curr_planes_normal)\n\t        curr_planes_compose_rgb = np.zeros((curr_planes_normal.shape[0], curr_planes_normal.shape[1], 3))\n", "        count_planes = 0\n\t        for j in range(int(curr_planes_normal.max())):\n\t            mask_curr_plane_normal = (curr_planes_normal==j+1)\n\t            # make other planes' label be zero\n\t            curr_planes_color_2 = copy.deepcopy(curr_planes_color)\n\t            curr_planes_color_2[mask_curr_plane_normal==False] = 0\n\t            sorted_max_planes, prop_planes, num_max_clusters2 = find_labels_max_clusters(curr_planes_color_2.reshape(-1), num_max_clusters=6)\n\t            # 2. image planes\n\t            ratios = np.zeros(6)\n\t            for k in range(len(sorted_max_planes)):\n", "                # check proportion and remove background\n\t                if sorted_max_planes[k] == 0:\n\t                    continue\n\t                if prop_planes[k] < PROPORTION_PLANES:\n\t                    continue\n\t                ratios[k] = prop_planes[k]\n\t                mask_curr_plane_img = (curr_planes_color_2 == sorted_max_planes[k])\n\t                mask_curr_plane_img = remove_small_isolated_areas(mask_curr_plane_img, min_size=3000) > 0\n\t                curr_planes_compose_rgb[mask_curr_plane_img] = np.random.randint(low=0, high=255, size=3).astype(np.uint8)\n\t                # curr_planes_compose_rgb = curr_planes_compose_rgb.astype(np.uint8)\n", "                count_planes += 1\n\t                curr_planes_compose[mask_curr_plane_img] = count_planes * MAGNITUDE_COMPOSED_PLANER_LABEL\n\t        assert count_planes < 255 // MAGNITUDE_COMPOSED_PLANER_LABEL\n\t        f_log.write(f'{stem_imgs[i]}: {count_planes} \\n')\n\t        write_image(f'{dir_planes_compose}/{stem_imgs[i]}.png', curr_planes_compose)\n\t        mask_planes = curr_planes_compose_rgb.sum(axis=-1 )>0\n\t        mask_planes = np.stack([mask_planes]*3, axis=-1)\n\t        curre_img = copy.deepcopy(imgs_rgb[i])\n\t        curre_img[mask_planes==False] = 0\n\t        curr_planes_compose_rgb2 = np.concatenate([curr_planes_compose_rgb, curre_img, imgs_rgb[i]], axis=0)\n", "        write_image(f'{dir_planes_compose_visual}/{stem_imgs[i]}.png', curr_planes_compose_rgb2)\n\t        planes_compose_rgb_all.append(curr_planes_compose_rgb)\n\t    f_log.close()\n\t# scannet     \n\tdef prepare_depthneus_data_from_scannet(dir_scan, dir_neus, sample_interval=6, \n\t                                    b_sample = True, \n\t                                    b_crop_images = True,\n\t                                    b_generate_neus_data = True,\n\t                                    b_pred_normal = True, normal_method = 'snu',\n\t                                    b_detect_planes = False):\n", "    '''Sample iamges (1296,968)\n\t    '''   \n\t    H,W, _ = read_image(f'{dir_scan}/rgb/0.jpg').shape\n\t    path_intrin_color = f'{dir_scan}/../intrinsic_color.txt'\n\t    if W == 1296: \n\t        path_intrin_color_crop_resize = f'{dir_scan}/../intrinsic_color_crop1248_resize640.txt'\n\t        origin_size = (1296, 968)\n\t        cropped_size = (1248, 936)\n\t        reso_level = 1.95\n\t    elif W == 640:\n", "        path_intrin_color_640 = add_file_name_suffix(path_intrin_color, '_640')\n\t        if not checkExistence(path_intrin_color_640):\n\t            intrin_temp = read_cam_matrix(path_intrin_color)\n\t            intrin_640 = resize_cam_intrin(intrin_temp, resolution_level=1296/640)\n\t            np.savetxt(path_intrin_color_640, intrin_640, fmt='%f')\n\t        path_intrin_color = path_intrin_color_640\n\t        path_intrin_color_crop_resize = f'{dir_scan}/../intrinsic_color_crop640_resize640.txt'\n\t        origin_size = (640, 480)\n\t        cropped_size = (624, 468)\n\t        reso_level = 0.975   \n", "    else:\n\t        raise NotImplementedError\n\t    if not IOUtils.checkExistence(path_intrin_color_crop_resize):\n\t        crop_width_half = (origin_size[0]-cropped_size[0])//2\n\t        crop_height_half =(origin_size[1]-cropped_size[1]) //2\n\t        intrin = np.loadtxt(path_intrin_color)\n\t        intrin[0,2] -= crop_width_half\n\t        intrin[1,2] -= crop_height_half\n\t        intrin_resize = resize_cam_intrin(intrin, reso_level)\n\t        np.savetxt(path_intrin_color_crop_resize, intrin_resize, fmt = '%f')\n", "    if b_sample:\n\t        start_id = 0\n\t        num_images = len(glob.glob(f\"{dir_scan}/rgb/**.jpg\"))\n\t        end_id = num_images*2\n\t        ScannetData.select_data_by_range(dir_scan, dir_neus, start_id, end_id, sample_interval, \n\t                                            b_crop_images, cropped_size)\n\t    # prepare neus data\n\t    if b_generate_neus_data:\n\t        dir_neus = dir_neus\n\t        height, width =  480, 640\n", "        msg = input('Remove pose (nan)...[y/n]') # observe pose file size\n\t        if msg != 'y':\n\t            exit()\n\t        path_intrin_color = f'{dir_scan}/../../intrinsic_color.txt'\n\t        if b_crop_images:\n\t            path_intrin_color = path_intrin_color_crop_resize\n\t        path_intrin_depth = f'{dir_scan}/../../intrinsic_depth.txt'\n\t        dataset = ScannetData(dir_neus, height, width, \n\t                                    use_normal = False,\n\t                                    path_intrin_color = path_intrin_color,\n", "                                    path_intrin_depth = path_intrin_depth)\n\t        dataset.generate_neus_data()\n\t        if b_pred_normal:\n\t            predict_normal(dir_neus, normal_method)\n\t        # detect planes\n\t        if b_detect_planes == True:\n\t            extract_planes_from_normals(dir_neus + '/pred_normal', thres_uncertain=-1)\n\t            segment_images_superpixels(dir_neus + '/image')\n\t            compose_normal_img_planes(dir_neus)\n\t# privivate data\n", "def prepare_depthneus_data_from_private_data(dir_neus, size_img = (6016, 4016),\n\t                                            b_generate_neus_data = True,\n\t                                            b_pred_normal = True, normal_method = 'snu',\n\t                                            b_detect_planes = False):   \n\t    '''Run sfm and prepare neus data\n\t    '''\n\t    W, H = size_img\n\t    path_intrin_color = f'{dir_neus}/intrinsics.txt'\n\t    if b_generate_neus_data:\n\t        dataset = ScannetData(dir_neus, H, W, use_normal=False,\n", "                                    path_intrin_color = path_intrin_color,\n\t                                    path_intrin_depth = path_intrin_color, \n\t                                    path_cloud_sfm=f'{dir_neus}/point_cloud_openMVS.ply')\n\t        dataset.generate_neus_data()\n\t    if b_pred_normal:\n\t        predict_normal(dir_neus, normal_method)\n\t    # detect planes\n\t    if b_detect_planes == True:\n\t        extract_planes_from_normals(dir_neus + '/pred_normal', thres_uncertain=-1)\n\t        segment_images_superpixels(dir_neus + '/image')\n", "        compose_normal_img_planes(dir_neus)\n\tdef predict_normal(dir_neus, normal_method = 'snu'):\n\t    # For scannet data, retraining of normal network is required to guarantee the test scenes are in the test set of normal network.\n\t    # For your own data, the officially provided pretrained model of the normal network can be utilized directly.\n\t    if normal_method == 'snu':\n\t        # ICCV2021, https://github.com/baegwangbin/surface_normal_uncertainty\n\t        logging.info('Predict normal')\n\t        IOUtils.changeWorkingDir(dir_snu_code)\n\t        os.system(f'python test.py --pretrained scannet --path_ckpt {path_snu_pth} --architecture BN --imgs_dir {dir_neus}/image/')\n\t    # Tilted-SN\n", "    if normal_method == 'tiltedsn':\n\t        # ECCV2020, https://github.com/MARSLab-UMN/TiltedImageSurfaceNormal\n\t        IOUtils.changeWorkingDir(dir_tiltedsn_code)\n\t        os.system(f'python inference_surface_normal.py --checkpoint_path {path_tiltedsn_pth_pfpn} \\\n\t                                --sr_checkpoint_path {path_tiltedsn_pth_sr} \\\n\t                                --log_folder {dir_neus} \\\n\t                                --operation inference \\\n\t                                --batch_size 8 \\\n\t                                --net_architecture sr_dfpn \\\n\t                                --test_dataset {dir_neus}/image')\n", "# normal prior\n\tdef update_pickle_TiltedSN_rectified_2dofa(path_pickle, path_update, scenes_remove):\n\t    '''Remove part of training data\n\t    '''\n\t    data_split = pickle.load(open(path_pickle, 'rb'))\n\t    keys_splits = ['train'] #, 'test'\n\t    keys_subsplicts = ['e2', '-e2']\n\t    masks_all = []\n\t    remove_all = {}\n\t    for key_split in keys_splits:\n", "        for key_subsplit in keys_subsplicts:\n\t            data_curr = data_split[key_split][key_subsplit]\n\t            len_data_curr = len(data_curr)\n\t            mask_curr = np.ones(len_data_curr).astype(bool)\n\t            remove_all[key_split+'_'+key_subsplit] =  []\n\t            for i in range(len_data_curr):\n\t                path_i = data_curr[i].split('/')\n\t                scene_i = path_i[0]\n\t                if scene_i[:-3] in scenes_remove:\n\t                    mask_curr[i] = False\n", "                    if scene_i not in remove_all[key_split+'_'+key_subsplit]:\n\t                        remove_all[key_split+'_'+key_subsplit].append(scene_i)\n\t            remove_all[key_split+'_'+key_subsplit] = sorted(remove_all[key_split+'_'+key_subsplit])\n\t            logging.info(f'{key_split} {key_subsplit}: {int(mask_curr.sum())}/{len_data_curr}. Ratio: {int(mask_curr.sum())/len_data_curr:.03f}')\n\t            masks_all.append(mask_curr)\n\t            # remove_all.append(remove_curr)\n\t            # update original data\n\t            data_split[key_split][key_subsplit] = np.array(data_split[key_split][key_subsplit])[mask_curr].tolist()\n\t            len_update = len(data_split[key_split][key_subsplit])\n\t            logging.info(f'[{key_split} {key_subsplit}]:{len_data_curr}->{len_update}')\n", "    # save data\n\t    with open(path_update, 'wb') as handle:\n\t        pickle.dump(data_split, handle, protocol=pickle.HIGHEST_PROTOCOL)\n\t    # debug\n\t    # data_split2 = pickle.load(open(path_update, 'rb'))\n\t    # print('done')\n\tdef update_pickle_TiltedSN_full_2dofa(path_pickle, path_update, scenes_remove):\n\t    '''Remove part of training data\n\t    '''\n\t    data_split = pickle.load(open(path_pickle, 'rb'))\n", "    keys_splits = ['train']\n\t    keys_subsplicts_l1 = ['with_ga', 'no_ga']\n\t    keys_subsplicts_l2 = ['e2', '-e2']\n\t    masks_all = []\n\t    remove_all = {}\n\t    for key_split in keys_splits:\n\t        for key_l1 in keys_subsplicts_l1:   \n\t            for key_l2 in keys_subsplicts_l2:\n\t                if key_l1 == 'with_ga':\n\t                    data_curr = data_split[key_split][key_l1][key_l2]\n", "                elif key_l1 == 'no_ga':\n\t                    data_curr = data_split[key_split][key_l1]\n\t                else:\n\t                    raise NotImplementedError\n\t                len_data_curr = len(data_curr)\n\t                mask_curr = np.ones(len_data_curr).astype(bool)\n\t                remove_all[key_split + '_'+ key_l1 + '_'  + key_l2] =  []\n\t                for i in range(len_data_curr):\n\t                    path_i = data_curr[i].split('/')\n\t                    scene_i = path_i[0]\n", "                    if scene_i[:-3] in scenes_remove:\n\t                        mask_curr[i] = False\n\t                        if scene_i not in remove_all[key_split + '_'+ key_l1 + '_'  + key_l2]:\n\t                            remove_all[key_split + '_'+ key_l1 + '_'  + key_l2].append(scene_i)\n\t                logging.info(f'[{key_split} {key_l1} {key_l2}]: {int(mask_curr.sum())}/{len_data_curr}. Ratio: {int(mask_curr.sum())/len_data_curr:.03f}')\n\t                masks_all.append(mask_curr)\n\t                remove_all[key_split + '_'+ key_l1 + '_'  + key_l2] = sorted(remove_all[key_split + '_'+ key_l1 + '_'  + key_l2])\n\t                # remove_all.append(remove_curr)\n\t                # update original data\n\t                if key_l1 == 'with_ga':\n", "                    data_split[key_split][key_l1][key_l2] = np.array(data_split[key_split][key_l1][key_l2])[mask_curr].tolist()\n\t                    len_update = len(data_split[key_split][key_l1][key_l2])\n\t                elif key_l1 == 'no_ga':\n\t                    data_split[key_split][key_l1] = np.array(data_split[key_split][key_l1])[mask_curr].tolist()\n\t                    len_update = len(data_split[key_split][key_l1])\n\t                else:\n\t                    raise NotImplementedError\n\t                logging.info(f'[{key_split} {key_l1} {key_l2}]:{len_data_curr}->{len_update}')\n\t    # save data\n\t    with open(path_update, 'wb') as handle:\n", "        pickle.dump(data_split, handle, protocol=pickle.HIGHEST_PROTOCOL)\n\t    # # debug\n\t    # data_split2 = pickle.load(open(path_update, 'rb'))\n\t    # print('done')\n\tdef update_pickle_file_TiltedSN():\n\t    '''Remove part of training data\n\t    '''\n\t    path_pkl = '../TiltedImageSurfaceNormal/data/rectified_2dofa_framenet.pkl' \n\t    path_update = IOUtils.add_file_name_suffix(path_pkl, \"_update\")\n\t    update_pickle_TiltedSN_rectified_2dofa(path_pkl, path_update, lis_name_scenes_remove)\n", "    path_pkl = '../TiltedImageSurfaceNormal/data/full_2dofa_framenet.pkl'  \n\t    path_update = IOUtils.add_file_name_suffix(path_pkl, \"_update\")\n\t    update_pickle_TiltedSN_full_2dofa(path_pkl, path_update, lis_name_scenes_remove)\n\tdef update_pickle_framenet(path_pickle, path_update):\n\t    '''Remove part of training data\n\t    '''\n\t    scenes_remove = lis_name_scenes_remove\n\t    data_split = pickle.load(open(path_pickle, 'rb'))\n\t    keys_splits = ['train'] #, 'test'\n\t    keys_subsplicts = [0, 1, 2]\n", "    masks_all = []\n\t    remove_all = {}\n\t    data_split_update = {'train':[],\n\t                         'test':[]}\n\t    scenes_all_used = []\n\t    scenes_all = {}                     \n\t    for key_split in keys_splits:\n\t        for key_subsplit in keys_subsplicts:\n\t            data_curr = data_split[key_split][key_subsplit]  \n\t            key_subsplit2 = str(key_subsplit)          \n", "            len_data_curr = len(data_curr)\n\t            mask_curr = np.ones(len_data_curr).astype(bool)\n\t            remove_all[key_split+'_'+key_subsplit2] =  []\n\t            scenes_all[key_split]  = []\n\t            for i in range(len_data_curr):\n\t                path_i = data_curr[i].split('/')\n\t                scene_i = path_i[4]\n\t                if scene_i[:-3] in scenes_remove:\n\t                    mask_curr[i] = False\n\t                    if scene_i not in remove_all[key_split+'_'+key_subsplit2]:\n", "                        remove_all[key_split+'_'+key_subsplit2].append(scene_i)\n\t                # if scene_i[:-3] not in scenes_all[key_split]:\n\t                scenes_all[key_split].append(scene_i)\n\t            remove_all[key_split+'_'+key_subsplit2] = sorted(remove_all[key_split+'_'+key_subsplit2])\n\t            logging.info(f'{key_split} {key_subsplit}: {int(mask_curr.sum())}/{len_data_curr}. Ratio: {int(mask_curr.sum())/len_data_curr:.03f}')\n\t            masks_all.append(mask_curr)\n\t            # remove_all.append(remove_curr)\n\t            scenes_all[key_split] = np.unique(np.array(scenes_all[key_split]))\n\t            # update original data\n\t            data_update_ = np.array(data_split[key_split][key_subsplit])[mask_curr].tolist()\n", "            data_split_update[key_split].append(data_update_)\n\t            len_update = len(data_update_)\n\t            logging.info(f'[{key_split} {key_subsplit}]:{len_data_curr}->{len_update}')\n\t            num_remove = len(remove_all[key_split+'_'+key_subsplit2])\n\t            logging.info(f'[{key_split}] scenes_all: {len(scenes_all[key_split])}, scenes-remove: {num_remove}')\n\t            scenes_all_used.append(scenes_all) \n\t    # save data\n\t    data_split['train'] = ( data_split_update['train'][0],data_split_update['train'][1], data_split_update['train'][2])\n\t    with open(path_update, 'wb') as handle:\n\t        pickle.dump(data_split, handle, protocol=pickle.HIGHEST_PROTOCOL)\n", "    # # debug\n\t    # data_split2 = pickle.load(open(path_update, 'rb'))\n\t    # print('done')"]}
{"filename": "preprocess/sfm_pipeline.py", "chunked_list": ["#!/usr/bin/python\n\t#! -*- encoding: utf-8 -*-\n\t# This file is part of OpenMVG (Open Multiple View Geometry) C++ library.\n\t# Python implementation of the bash script written by Romuald Perrot\n\t# Created by @vins31\n\t# Modified by Pierre Moulon\n\t#\n\t# this script is for easy use of OpenMVG\n\t#\n\t# usage : python openmvg.py image_dir output_dir\n", "#\n\t# image_dir is the input directory where images are located\n\t# output_dir is where the project must be saved\n\t#\n\t# if output_dir is not present script will create it\n\t# borrowd from openMVG\n\timport os\n\timport subprocess\n\timport sys\n\tif len(sys.argv) < 6:\n", "    print (\"Please input sufficient paras!\")\n\t    sys.exit(1)\n\tinput_dir = sys.argv[1]\n\toutput_dir = sys.argv[2]\n\tfocal_length = sys.argv[3]\n\tnThreads = sys.argv[4]\n\tdir_root_mvg = sys.argv[5]\n\t# Indicate the openMVG binary directory\n\tOPENMVG_SFM_BIN = f\"{dir_root_mvg}/Linux-x86_64-RELEASE\"\n\t# Indicate the openMVG camera sensor width directory\n", "CAMERA_SENSOR_WIDTH_DIRECTORY = f\"{dir_root_mvg}/../openMVG/src/software/SfM\" + \"/../../openMVG/exif/sensor_width_database\"\n\tmatches_dir = os.path.join(output_dir, \"matches\")\n\treconstruction_dir = os.path.join(output_dir, \"reconstruction_sequential\")\n\tcamera_file_params = os.path.join(CAMERA_SENSOR_WIDTH_DIRECTORY, \"sensor_width_camera_database.txt\")\n\tprint (\"Using input dir  : \", input_dir)\n\tprint (\"      output_dir : \", output_dir)\n\tprint (\"    focal_length : \", focal_length)\n\t# Create the ouput/matches folder if not present\n\tif not os.path.exists(output_dir):\n\t  os.mkdir(output_dir)\n", "if not os.path.exists(matches_dir):\n\t  os.mkdir(matches_dir)\n\tprint (\"1. Intrinsics analysis\")\n\tpIntrisics = subprocess.Popen( [os.path.join(OPENMVG_SFM_BIN, \"openMVG_main_SfMInit_ImageListing\"),  \"-i\", input_dir, \"-o\", matches_dir, \"-d\", camera_file_params, \"-f\", focal_length] )\n\tpIntrisics.wait()\n\tprint (\"2. Compute features\")\n\tpFeatures = subprocess.Popen( [os.path.join(OPENMVG_SFM_BIN, \"openMVG_main_ComputeFeatures\"), \"-p\", \"HIGH\",  \"-f\", \"1\", \"-i\", matches_dir+\"/sfm_data.json\", \"-o\", matches_dir, \"-m\", \"SIFT\",\"-n\",nThreads] )\n\tpFeatures.wait()\n\tprint (\"3. Compute matches\")\n\tpMatches = subprocess.Popen( [os.path.join(OPENMVG_SFM_BIN, \"openMVG_main_ComputeMatches\"),  \"-f\", \"1\", \"-i\", matches_dir+\"/sfm_data.json\", \"-o\", matches_dir] )\n", "pMatches.wait()\n\t# Create the reconstruction if not present\n\tif not os.path.exists(reconstruction_dir):\n\t    os.mkdir(reconstruction_dir)\n\tprint (\"4. Do Sequential/Incremental reconstruction\")\n\tpRecons = subprocess.Popen( [os.path.join(OPENMVG_SFM_BIN, \"openMVG_main_IncrementalSfM\"),  \"-i\", matches_dir+\"/sfm_data.json\", \"-m\", matches_dir, \"-o\", reconstruction_dir] )\n\tpRecons.wait()\n\tprint (\"5. Colorize Structure\")\n\tpRecons = subprocess.Popen( [os.path.join(OPENMVG_SFM_BIN, \"openMVG_main_ComputeSfM_DataColor\"),  \"-i\", reconstruction_dir+\"/sfm_data.bin\", \"-o\", os.path.join(reconstruction_dir,\"colorized.ply\")] )\n\tpRecons.wait()\n", "# optional, compute final valid structure from the known camera poses\n\tprint (\"6. Structure from Known Poses (robust triangulation)\")\n\tpRecons = subprocess.Popen( [os.path.join(OPENMVG_SFM_BIN, \"openMVG_main_ComputeStructureFromKnownPoses\"),  \"-i\", reconstruction_dir+\"/sfm_data.bin\", \"-m\", matches_dir, \"-f\", os.path.join(matches_dir, \"matches.f.bin\"), \"-o\", os.path.join(reconstruction_dir,\"robust.bin\")] )\n\tpRecons.wait()\n\tpRecons = subprocess.Popen( [os.path.join(OPENMVG_SFM_BIN, \"openMVG_main_ComputeSfM_DataColor\"),  \"-i\", reconstruction_dir+\"/robust.bin\", \"-o\", os.path.join(reconstruction_dir,\"robust_colorized.ply\")] )\n\tpRecons.wait()\n"]}
{"filename": "preprocess/scannet_data.py", "chunked_list": ["import os, sys\n\timport utils.utils_io as IOUtils\n\timport utils.utils_geometry as GeometryUtils\n\timport utils.utils_image as Imageutils\n\timport shutil, glob, os\n\timport cv2\n\timport numpy as np\n\timport logging, glob\n\timport open3d as o3d\n\tfrom datetime import datetime\n", "class ScannetData:\n\t    def __init__(self, dir_scan, height, width, use_normal = False, \n\t                        cam_sphere_radius=-1,\n\t                        dir_extrinsics = None, \n\t                        path_intrin_color = None,\n\t                        path_intrin_depth = None,\n\t                        path_cloud_sfm = None):\n\t        '''\n\t        ScanNet Dataset:\n\t            default pose: camera to world\n", "        Args:\n\t            use_normal: if true, use scanned depth to calculate world normals\n\t                            and upsample(resize) depth map to image shape\n\t        '''\n\t        self.dir_scan = dir_scan\n\t        self.use_normal = use_normal\n\t        self.height = height\n\t        self.width = width\n\t        self.cam_sphere_radius = cam_sphere_radius\n\t        logging.info(f'cam_sphere_radius: {self.cam_sphere_radius}. Image height: {self.height}. width: {self.width}')\n", "        # intrinsics_rgb = '''1169.621094 0.000000 646.295044 0.000000\n\t        #     0.000000 1167.105103 489.927032 0.000000\n\t        #     0.000000 0.000000 1.000000 0.000000\n\t        #     0.000000 0.000000 0.000000 1.000000'''\n\t        # intrinsics_depth = '''577.590698 0.000000 318.905426 0.000000\n\t        #     0.000000 578.729797 242.683609 0.000000\n\t        #     0.000000 0.000000 1.000000 0.000000\n\t        #     0.000000 0.000000 0.000000 1.000000'''\n\t        self.intrinsics = GeometryUtils.read_cam_matrix(path_intrin_color)\n\t        self.intrinsics_depth = GeometryUtils.read_cam_matrix(path_intrin_depth)\n", "        self.dir_depthmap = os.path.join(self.dir_scan, 'depth')\n\t        self.dir_image = os.path.join(self.dir_scan, 'image')\n\t        if dir_extrinsics is not None: \n\t            self.poses_w2c = GeometryUtils.read_poses(dir_extrinsics)   # default pose: camera to world\n\t            self.poses_c2w = np.linalg.inv(self.poses_w2c)\n\t            # print( self.poses_w2c @ self.poses_c2w )\n\t        else:\n\t            self.dir_pose = os.path.join(self.dir_scan, 'pose')\n\t            self.poses_c2w = GeometryUtils.read_poses(self.dir_pose)   # default pose: camera to world\n\t            self.poses_w2c = GeometryUtils.get_poses_inverse(self.poses_c2w)  # extrinsics: world to camera\n", "        self.dir_normal = os.path.join(self.dir_scan, 'normal')\n\t        self.path_cloud_sfm = path_cloud_sfm if path_cloud_sfm is not None else None\n\t    @staticmethod\n\t    def select_data_by_range(dir_scan, dir_scan_select, start_id, end_id, interval, b_crop_images, cropped_size = (1248, 936)):  \n\t        '''\n\t        Args:\n\t            b_crop_images: crop images to cropped size if true, and resize cropped images to (640,480)\n\t            cropped_size: (640,480)*1.95\n\t        '''    \n\t        IOUtils.ensure_dir_existence(dir_scan_select)\n", "        for i in ['image', 'depth', 'pose']:\n\t            IOUtils.ensure_dir_existence(f\"{dir_scan_select}/{i}/\")\n\t        crop_height_half, crop_width_half = 0, 0\n\t        for idx in range(start_id, end_id, interval):\n\t            # rgb\n\t            path_src = f\"{dir_scan}/rgb/{idx}.jpg\"\n\t            img = cv2.imread(path_src, cv2.IMREAD_UNCHANGED)\n\t            height, width, _ = img.shape\n\t            if b_crop_images:\n\t                W_target, H_target = cropped_size\n", "                # if width == 640:\n\t                #     raise NotImplementedError\n\t                # crop\n\t                crop_width_half = (width-W_target)//2\n\t                crop_height_half = (height-H_target) //2\n\t                assert (width-W_target)%2 ==0 and (height- H_target) %2 == 0\n\t                # resize\n\t                img_crop = img[crop_height_half:height-crop_height_half, crop_width_half:width-crop_width_half, :]\n\t                assert img_crop.shape[0] == cropped_size[1]\n\t                img = cv2.resize(img_crop, (640, 480), interpolation=cv2.INTER_LINEAR)\n", "            path_target = f\"{dir_scan_select}/image/{idx:04d}.png\"\n\t            cv2.imwrite(path_target, img)\n\t            # pose\n\t            path_src = f\"{dir_scan}/pose/{idx}.txt\"\n\t            path_target = f\"{dir_scan_select}/pose/{idx:04d}.txt\"\n\t            shutil.copyfile(path_src, path_target)\n\t            # depth map\n\t            path_src = f\"{dir_scan}/depth/{idx}.png\"\n\t            path_target = f\"{dir_scan_select}/depth/{idx:04d}.png\"\n\t            shutil.copyfile(path_src, path_target)\n", "        # GT mesh\n\t        path_gt_mesh = IOUtils.find_target_file(dir_scan, '_vh_clean_2.ply')\n\t        assert path_gt_mesh\n\t        _, _stem, _ext = IOUtils.get_path_components(path_gt_mesh)\n\t        path_target = f\"{dir_scan_select}/{_stem}{_ext}\"\n\t        shutil.copyfile(path_gt_mesh, path_target)\n\t        return crop_height_half, crop_width_half\n\t    def load_and_merge_depth_maps(self):\n\t        self.depthmaps = self.read_depthmaps(self.dir_depthmap)\n\t        self.num_images = len(glob.glob(f\"{self.dir_image}/**.png\"))\n", "        if self.depthmaps.shape[0]> 200:\n\t            logging.info(\"Sample 200 depth maps to get merged points...\")\n\t            idx_imgs = np.random.randint(low=0, high=self.depthmaps.shape[0], size=200)\n\t            depthmaps_fuse = self.depthmaps[idx_imgs]\n\t            points = GeometryUtils.fuse_depthmaps(depthmaps_fuse, self.intrinsics_depth, self.poses_w2c[idx_imgs])\n\t            self.arr_imgs = (self.read_rgbs(self.dir_image, (640,480))[idx_imgs])\n\t            arr_imgs = self.arr_imgs.reshape(-1,3)\n\t        else:\n\t            points = GeometryUtils.fuse_depthmaps(self.depthmaps, self.intrinsics_depth, self.poses_w2c)\n\t            self.arr_imgs = self.read_rgbs(self.dir_image, (640,480))\n", "            arr_imgs = self.arr_imgs.reshape(-1,3)\n\t        idx_pts = np.random.randint(low=0, high=points.shape[0], size=int(1e6))\n\t        self.pts_sample = points[idx_pts]\n\t        self.colors_sample = arr_imgs[idx_pts]\n\t    def read_one_img(self, path):\n\t        img = cv2.imread(path, cv2.IMREAD_UNCHANGED)\n\t        return img\n\t    def read_depthmaps(self, dir):\n\t        vec_path = sorted(glob.glob(f\"{dir}/**.png\"))\n\t        depth_maps = []\n", "        for i in range(len(vec_path)):\n\t            img = self.read_one_img(vec_path[i]).astype(np.int32) / 1000  # unit: m\n\t            depth_maps.append(img)\n\t        return np.array(depth_maps)\n\t    def read_normals(self, dir):\n\t        vec_path = sorted(glob.glob(f\"{dir}/**.png\"))\n\t        normals = []\n\t        for i in range(len(vec_path)):\n\t            img = self.read_one_img(vec_path[i])\n\t            normals.append(img)\n", "        return np.array(normals)\n\t    def read_rgbs(self, dir, target_img_size = None):\n\t        vec_path = sorted(glob.glob(f\"{dir}/**.png\"))\n\t        rgbs = []\n\t        for i in range(len(vec_path)):\n\t            img = self.read_one_img(vec_path[i])\n\t            if target_img_size != None:\n\t                img = cv2.resize(img, target_img_size, interpolation=cv2.INTER_LINEAR)\n\t                img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\t            rgbs.append(img)\n", "        return np.array(rgbs)\n\t    def read_poses(self, dir):\n\t        vec_path = sorted(glob.glob(f\"{dir}/**.txt\"))\n\t        poses = []\n\t        for i in range(len(vec_path)):\n\t            img = GeometryUtils.read_cam_matrix(vec_path[i])\n\t            poses.append(img)\n\t        return np.array(poses)\n\t    def get_projection_matrix(self, intrin, poses, trans_n2w):\n\t        '''\n", "        Args:\n\t            poses: world to camera\n\t        '''\n\t        num_poses = poses.shape[0]\n\t        projs = []\n\t        poses_norm = []\n\t        dir_pose_norm = self.dir_scan + \"/extrin_norm\"\n\t        IOUtils.ensure_dir_existence(dir_pose_norm)\n\t        for i in range(num_poses):\n\t            # pose_norm_i = poses[i] @ trans_n2w\n", "            # Method 2\n\t            pose = poses[i]\n\t            rot = pose[:3,:3]\n\t            trans = pose[:3,3]\n\t            cam_origin_world = - np.linalg.inv(rot) @ trans.reshape(3,1)\n\t            cam_origin_world_homo = np.concatenate([cam_origin_world,[[1]]], axis=0)\n\t            cam_origin_norm = np.linalg.inv(trans_n2w) @ cam_origin_world_homo\n\t            trans_norm = -rot @ cam_origin_norm[:3]\n\t            pose[:3,3] = np.squeeze(trans_norm)\n\t            poses_norm.append(pose)\n", "            proj_norm = intrin @ pose\n\t            projs.append(proj_norm)\n\t            np.savetxt(f'{dir_pose_norm}/{i:04d}.txt', pose, fmt='%f') # world to camera\n\t            np.savetxt(f'{dir_pose_norm}/{i:04d}_inv.txt', GeometryUtils.get_pose_inv(pose) , fmt='%f') # inv: camera to world\n\t        return np.array(projs), np.array(poses_norm)\n\t    def calculate_normals(self):\n\t        # visualize normal\n\t        IOUtils.ensure_dir_existence(self.dir_normal)\n\t        for i in range(self.num_images):\n\t            logging.info(f\"Caluclate normal of image: {i}/{self.num_images}\")\n", "            pts_i, normal_map_i = GeometryUtils.calculate_normalmap_from_depthmap(self.depthmaps[i], self.intrinsics_depth, self.poses_w2c[i])\n\t            if self.height != 480:\n\t                logging.info(f\"{i} Upsample normal map to size: (1296, 968).\")\n\t                normal_map_i = cv2.resize(normal_map_i, (1296, 968), interpolation=cv2.INTER_LINEAR)\n\t            np.savez(f\"{self.dir_normal}/{i:04d}.npz\", normal=normal_map_i)\n\t            cv2.imwrite(f\"{self.dir_normal}/{i:04d}.png\", normal_map_i*255)\n\t    def generate_neus_data(self, radius_normalize_sphere=1.0):\n\t        if self.path_cloud_sfm:\n\t            msg = input('Check bounding box of openMVS point cloud (Manually remove floating outliers)...[y/n]')\n\t            if msg != 'y':\n", "                exit()\n\t            cloud_clean = GeometryUtils.read_point_cloud(self.path_cloud_sfm)\n\t        else:\n\t            self.load_and_merge_depth_maps()\n\t            path_point_cloud_scan = f'{self.dir_scan}/point_cloud_scan.ply'\n\t            GeometryUtils.save_points(path_point_cloud_scan,  self.pts_sample, self.colors_sample)\n\t            msg = input('Check bounding box of merged point cloud (Manually remove floating outliers)...[y/n]')\n\t            if msg != 'y':\n\t                exit()\n\t            if self.use_normal:\n", "                t1 = datetime.now()\n\t                self.calculate_normals()\n\t                logging.info(f\"Calculate normal: {(datetime.now()-t1).total_seconds():.0f} seconds\")\n\t            cloud_clean = GeometryUtils.read_point_cloud(path_point_cloud_scan)\n\t        trans_n2w = GeometryUtils.get_norm_matrix_from_point_cloud(cloud_clean, radius_normalize_sphere=radius_normalize_sphere)\n\t        projs, poses_norm = self.get_projection_matrix(self.intrinsics, self.poses_w2c, trans_n2w)\n\t        path_trans_n2w = f'{self.dir_scan}/trans_n2w.txt'\n\t        np.savetxt(path_trans_n2w, trans_n2w, fmt = '%.04f')\n\t        cloud_clean_trans = cloud_clean.transform(np.linalg.inv(trans_n2w))\n\t        o3d.io.write_point_cloud(f'{self.dir_scan}/point_cloud_scan_norm.ply', cloud_clean_trans)\n", "        pts_cam_norm = GeometryUtils.get_camera_origins(poses_norm)\n\t        GeometryUtils.save_points(f'{self.dir_scan}/cam_norm.ply', pts_cam_norm)\n\t        pts_cam = (trans_n2w[None, :3,:3] @ pts_cam_norm[:, :, None]).squeeze()  + trans_n2w[None, :3, 3]\n\t        GeometryUtils.save_points(f'{self.dir_scan}/cam_origin.ply', pts_cam)\n\t        scale_mat = np.identity(4)\n\t        num_cams = projs.shape[0]\n\t        cams_neus = {}\n\t        for i in range(num_cams):\n\t            cams_neus[f\"scale_mat_{i}\"] = scale_mat\n\t            cams_neus[f'world_mat_{i}'] = projs[i]\n", "        np.savez(f'{self.dir_scan}/cameras_sphere.npz', **cams_neus)\n\t        # transform gt mesh\n\t        path_gt_mesh = IOUtils.find_target_file(self.dir_scan, '_vh_clean_2.ply')\n\t        if path_gt_mesh is None:\n\t            return\n\t        path_save = IOUtils.add_file_name_suffix(path_gt_mesh, \"_trans\")\n\t        trans = np.linalg.inv(np.loadtxt(path_trans_n2w))\n\t        GeometryUtils.transform_mesh(path_gt_mesh, trans, path_save) \n\tif __name__ == \"__main__\":\n\t    print(\"Nothing\")\n"]}
{"filename": "preprocess/sfm_mvs.py", "chunked_list": ["import sys, os\n\timport argparse\n\tDIR_FILE = os.path.abspath(os.path.dirname(__file__))\n\tsys.path.append(os.path.join(DIR_FILE, '..'))\n\timport utils.utils_io as IOUtils\n\timport os, sys, glob, subprocess\n\tfrom pathlib import Path\n\timport numpy as np\n\timport cv2\n\timport re\n", "# SfM and MVS paras\n\tnNumThreads = 6 \n\tnNumViews = 5\n\tnMaxResolution = 7000\n\tfDepthDiffThreshold = 0.005\n\tfNormalDiffThreshold = 25\n\tbRemoveDepthMaps = True\n\tverbosity = 2\n\tnRamdomIters = 4\n\tnEstiIters = 2\n", "from confs.path import DIR_MVS_BUILD, DIR_MVG_BUILD\n\tdef perform_sfm(dir_images, dir_output, nImageWidth):\n\t    IOUtils.ensure_dir_existence(dir_output)\n\t    dir_undistorted_images = dir_output + \"/undistorted_images\" \n\t    IOUtils.changeWorkingDir(dir_output) \n\t    fFocalLength_pixel = 1.2 * nImageWidth\n\t    IOUtils.INFO_MSG(\"Use sequential pipeline\")\n\t    args_sfm = [\"python3\",  DIR_FILE + \"/sfm_pipeline.py\", \\\n\t                            dir_images, dir_output, str(fFocalLength_pixel), str(nNumThreads), DIR_MVG_BUILD] \n\t    IOUtils.run_subprocess(args_sfm)\n", "    dir_input_sfm2mvs = dir_output + \"/reconstruction_sequential/sfm_data.bin\"\n\t    args_sfm2mvs = [DIR_MVG_BUILD +\"/Linux-x86_64-RELEASE/openMVG_main_openMVG2openMVS\", \n\t                        \"-i\", dir_input_sfm2mvs, \n\t                        \"-o\", dir_output + \"/scene.mvs\",\n\t                        \"-d\", dir_undistorted_images]\n\t    IOUtils.run_subprocess(args_sfm2mvs)\n\tdef removeFiles(path_files, file_ext):\n\t    \"\"\"\n\t    Remove files in \"path_files\" with extension \"file_ext\"\n\t    \"\"\"\n", "    paths = Path(path_files).glob(\"**/*\" + file_ext)\n\t    for path in paths:\n\t        path_str = str(path)  # because path is object not string\n\t        if os.path.exists(path_str):\t# Remove file\n\t            print(f\"Remove file {path_str}.\")\n\t            os.remove(path_str)\n\t        # else:\n\t        #     print(f\"File {path_str} doesn't exist.\"\n\tdef perform_mvs(dir_output, nResolutionLevel, bRemoveDepthMaps=True):\n\t    os.chdir(dir_output)\n", "    if bRemoveDepthMaps:\n\t        removeFiles(os.getcwd(), \".dmap\")\n\t    DENSE_RECONSTRUCTION = DIR_MVS_BUILD + \"/bin/DensifyPointCloud\"\n\t    args_dense_reconstruction = [DENSE_RECONSTRUCTION, \"scene.mvs\",  \n\t                                    \"--resolution-level\", str(nResolutionLevel), \n\t                                    \"--max-resolution\", str(nMaxResolution),\n\t                                    \"--depth-diff-threshold\", str(fDepthDiffThreshold),\n\t                                    \"--normal-diff-threshold\", str(fNormalDiffThreshold),\n\t                                    \"--random-iters\", str(nRamdomIters),\n\t                                    \"--estimation-iters\",str(nEstiIters),\n", "                                    \"--verbosity\", str(verbosity),\n\t                                    \"--number-views\", str(nNumViews)\n\t                                    ]\n\t    # reconstruction\n\t    IOUtils.run_subprocess(args_dense_reconstruction)\n\t    # remove depth maps\n\t    if bRemoveDepthMaps:\n\t        removeFiles(os.getcwd(), \".dmap\")\n\tdef extract_intrinsics_from_KRC(path_KRC, path_intrin, path_imgs_cal):\n\t    fKRC = open(path_KRC, 'r').readlines()\n", "    lines_K = fKRC[3:6]\n\t    intrin = np.identity(4)\n\t    idx_row = 0\n\t    # get calibrated images\n\t    stems_img_cal = []\n\t    count_lines = 0\n\t    for line in fKRC:\n\t        line = re.split('/|\\n', line)\n\t        # print(line)   \n\t        if count_lines%13==1:\n", "            stems_img_cal.append(Path(line[-2]).stem)    \n\t        count_lines+=1\n\t    IOUtils.write_list_to_txt(path_imgs_cal, stems_img_cal)\n\t    # get camera instrisics\n\t    for line in lines_K:\n\t        line = re.split('[ \\] \\[ , ; \\n]', line)\n\t        idx_col = 0\n\t        for elem in line:\n\t            if len(elem) > 0:\n\t                intrin[idx_row, idx_col] = float(elem)\n", "                idx_col +=1\n\t        idx_row +=1\n\t    np.savetxt(path_intrin, intrin, fmt='%f')         \n\t    return intrin, stems_img_cal\n\tdef export_cameras(dir_mvs_output):\n\t    BIN_EXPORT_DATA = DIR_MVS_BUILD + \"/bin/ExportData\"\n\t    IOUtils.changeWorkingDir(dir_mvs_output)\n\t    # export cameras\n\t    dir_export_cameras = dir_mvs_output + \"/cameras\"\n\t    IOUtils.ensure_dir_existence(dir_export_cameras)\n", "    pExportData = subprocess.Popen([BIN_EXPORT_DATA, \"scene.mvs\", \"--export-path\", dir_export_cameras])\n\t    pExportData.wait()\n\tdef select_extrin_to_poses(dir_source, dir_target, lis_stem_sample,\n\t                        target_img_size = None, \n\t                        ext_source = '.txt', ext_target = '.txt'):\n\t    '''Convert image type in directory from ext_imgs to ext_target\n\t    '''\n\t    IOUtils.ensure_dir_existence(dir_target)\n\t    stems = []\n\t    for i in range(len(lis_stem_sample)):\n", "        # id_img = int(stem)\n\t        stem_curr = lis_stem_sample[i]        \n\t        path_source = f'{dir_source}/{stem_curr}{ext_source}'       \n\t        path_target = f'{dir_target}/{stem_curr}{ext_target}'       \n\t        extrin = np.loadtxt(path_source)\n\t        pose = np.linalg.inv(extrin)\n\t        np.savetxt(path_target, pose)\n\tdef select_images(dir_source, dir_target, lis_stem_sample,\n\t                        target_img_size = None, \n\t                        ext_source = '.png', ext_target = '.png'):\n", "    '''Convert image type in directory from ext_imgs to ext_target\n\t    '''\n\t    IOUtils.ensure_dir_existence(dir_target)\n\t    stems = []\n\t    for i in range(len(lis_stem_sample)):\n\t        # id_img = int(stem)\n\t        stem_curr = lis_stem_sample[i]        \n\t        path_source = f'{dir_source}/{stem_curr}{ext_source}'       \n\t        path_target = f'{dir_target}/{stem_curr}{ext_target}'       \n\t        if ext_source[-4:] == ext_target and (target_img_size is not None):\n", "            IOUtils.copy_file(path_source, path_target)\n\t        else:\n\t            img = cv2.imread(path_source, cv2.IMREAD_UNCHANGED)\n\t            if target_img_size is not None:\n\t                img = cv2.resize(img, target_img_size)\n\t            cv2.imwrite(path_target, img)\n\tdef select_depths(dir_source, dir_target, lis_stem_sample, size_image, \n\t                        target_img_size = None, \n\t                        ext_source = '.npy', ext_target = '.npy',\n\t                        stem_prefix_src = 'depth'):\n", "    '''Convert image type in directory from ext_imgs to ext_target\n\t    '''\n\t    IOUtils.ensure_dir_existence(dir_target)\n\t    path_depth0 = f'{dir_source}/{stem_prefix_src}{lis_stem_sample[0]}{ext_source}'  \n\t    depth0 = np.load(path_depth0).reshape(size_image[1], size_image[0])\n\t    for i in range(len(lis_stem_sample)):\n\t        # id_img = int(stem)\n\t        stem_curr = lis_stem_sample[i] \n\t        path_source = f'{dir_source}/{stem_curr}{ext_source}'       \n\t        if stem_prefix_src is not None:       \n", "            path_source = f'{dir_source}/{stem_prefix_src}{stem_curr}{ext_source}'       \n\t        path_target = f'{dir_target}/{stem_curr}{ext_target}'\n\t        if not IOUtils.checkExistence(path_source):\n\t            print(f'Depth not existed. Create one with all zeros... {path_target}')\n\t            depth_tmp = np.zeros_like(depth0)\n\t            np.save(path_target, depth_tmp)  \n\t            continue\n\t        if ext_source[-4:] == ext_target and (target_img_size is None):\n\t            depth_curr = np.load(path_source).reshape(size_image[1], size_image[0])\n\t            np.save(path_target, depth_curr)\n", "            # IOUtils.copy_file(path_source, path_target)\n\t        else:\n\t            raise NotImplementedError\n\tdef prepare_neus_data(dir_sfm_output, dir_neus, imgs_cal_stem, args):\n\t    IOUtils.ensure_dir_existence(dir_neus)\n\t    # images\n\t    dir_src = f'{dir_sfm_output}/undistorted_images'\n\t    dir_target = f'{dir_sfm_output}/images_calibrated'\n\t    select_images(dir_src, dir_target, imgs_cal_stem)\n\t    dir_src = f'{dir_sfm_output}'\n", "    dir_target = f'{dir_sfm_output}/depth_calibrated'\n\t    assert args.reso_level == 1\n\t    select_depths(dir_src, dir_target, imgs_cal_stem, (args.image_width, args.image_height))\n\t    # cameras\n\t    dir_src = f'{dir_sfm_output}/cameras/extrinsics'\n\t    dir_target = f'{dir_neus}/pose'\n\t    select_extrin_to_poses(dir_src, dir_target, imgs_cal_stem)\n\t    # intrinsics\n\t    path_src = f'{dir_sfm_output}/cameras/intrinsics.txt'\n\t    path_target = f'{dir_sfm_output}/intrinsics.txt'\n", "    IOUtils.copy_file(path_src, path_target)\n\t    # point cloud\n\t    path_src = f'{dir_sfm_output}/scene_dense.ply'\n\t    scene_name = path_src.split('/')[-3]\n\t    path_target = f'{dir_neus}/point_cloud_openMVS.ply'\n\t    IOUtils.copy_file(path_src, path_target)\n\t    # neighbors\n\t    path_src = f'{dir_sfm_output}/neighbors.txt'\n\t    path_target = f'{dir_neus}/neighbors.txt'\n\t    IOUtils.copy_file(path_src, path_target)\n", "def perform_sfm_mvs_pipeline(dir_mvs, args):\n\t    dir_images = os.path.join(dir_mvs, 'images')\n\t    dir_output = dir_mvs\n\t    dir_neus = f'{dir_output}/..'\n\t    # reconstruction\n\t    perform_sfm(dir_images, dir_output, args.image_width)\n\t    perform_mvs(dir_output, nResolutionLevel = args.reso_level)\n\t    export_cameras(dir_output)\n\t    # Prepare neus data: image, intrin, extrins\n\t    dir_KRC = f'{dir_output}/cameras/KRC.txt'\n", "    path_intrin = f'{dir_output}/cameras/intrinsics.txt'\n\t    path_imgs_cal = f'{dir_output}/cameras/stems_calibrated_images.txt'\n\t    intrin, stems_img_cal = extract_intrinsics_from_KRC(dir_KRC, path_intrin, path_imgs_cal)\n\t    prepare_neus_data(dir_output, dir_neus, stems_img_cal, args)\n\tdef parse_args():\n\t    parser = argparse.ArgumentParser()\n\t    parser.add_argument('--dir_mvs', type=str, default='/home/ethan/Desktop/test_sfm/tmp_sfm_mvs' )\n\t    parser.add_argument('--image_width', type=int, default = 1024)\n\t    parser.add_argument('--image_height', type=int, default = 768)\n\t    parser.add_argument('--reso_level', type=int, default = 1)\n", "    args = parser.parse_args()\n\t    return args\n\tif __name__ == \"__main__\":\n\t    args = parse_args()    \n\t    perform_sfm_mvs_pipeline(args.dir_mvs, args)\n"]}
{"filename": "models/embedder.py", "chunked_list": ["import torch\n\timport torch.nn as nn\n\timport numpy as np\n\t\"\"\" Positional encoding embedding. Code was taken from https://github.com/bmild/nerf. \"\"\"\n\tclass Embedder:\n\t    def __init__(self, **kwargs):\n\t        self.kwargs = kwargs\n\t        self.create_embedding_fn()\n\t    def create_embedding_fn(self):\n\t        embed_fns = []\n", "        d = self.kwargs['input_dims']\n\t        out_dim = 0\n\t        if self.kwargs['include_input']:\n\t            embed_fns.append(lambda x: x)\n\t            out_dim += d\n\t        max_freq = self.kwargs['max_freq_log2']\n\t        N_freqs = self.kwargs['num_freqs']\n\t        if self.kwargs['log_sampling']:\n\t            freq_bands = 2. ** torch.linspace(0., max_freq, N_freqs)\n\t        else:\n", "            freq_bands = torch.linspace(2.**0., 2.**max_freq, N_freqs)\n\t        for freq in freq_bands:\n\t            for p_fn in self.kwargs['periodic_fns']:\n\t                if self.kwargs['normalize']:\n\t                    embed_fns.append(lambda x, p_fn=p_fn,\n\t                                     freq=freq: p_fn(x * freq) / freq)\n\t                else:\n\t                    embed_fns.append(lambda x, p_fn=p_fn,\n\t                                            freq=freq: p_fn(x * freq))\n\t                out_dim += d\n", "        self.embed_fns = embed_fns\n\t        self.out_dim = out_dim\n\t    def embed(self, inputs):\n\t        return torch.cat([fn(inputs) for fn in self.embed_fns], -1)\n\tdef get_embedder(multires, normalize=False, input_dims=3):\n\t    embed_kwargs = {\n\t        'include_input': True,\n\t        'input_dims': input_dims,\n\t        'max_freq_log2': multires-1,\n\t        'num_freqs': multires,\n", "        'normalize': normalize,\n\t        'log_sampling': True,\n\t        'periodic_fns': [torch.sin, torch.cos],\n\t    }\n\t    embedder_obj = Embedder(**embed_kwargs)\n\t    def embed(x, eo=embedder_obj): return eo.embed(x)\n\t    return embed, embedder_obj.out_dim\n\tdef positional_encoding(input,L): # [B,...,N]\n\t    shape = input.shape\n\t    freq = 2**torch.arange(L,dtype=torch.float32)*np.pi # [L]\n", "    spectrum = input[...,None]*freq # [B,...,N,L]\n\t    sin,cos = spectrum.sin(),spectrum.cos() # [B,...,N,L]\n\t    input_enc = torch.stack([sin,cos],dim=-2) # [B,...,N,2,L]\n\t    input_enc = input_enc.view(*shape[:-1],-1) # [B,...,2NL]\n\t    return input_enc\n\tdef positional_encoding_c2f(input,L, emb_c2f, alpha_ratio = -1): # [B,...,N]\n\t    input_enc = positional_encoding(input,L=L) # [B,...,2NL]\n\t    # coarse-to-fine: smoothly mask positional encoding for BARF\n\t    weight = None\n\t    if emb_c2f is not None:\n", "        # set weights for different frequency bands\n\t        start,end = emb_c2f\n\t        alpha = (alpha_ratio-start)/(end-start)*L\n\t        k = torch.arange(L,dtype=torch.float32) + 1\n\t        weight = (1-(alpha-k).clamp_(min=0,max=1).mul_(np.pi).cos_())/2\n\t        # apply weights\n\t        shape = input_enc.shape\n\t        input_enc = (input_enc.view(-1,L)*weight).view(*shape)\n\t    # input_enc = torch.zeros_like(input_enc)\n\t    input_enc = torch.cat([input,input_enc],dim=-1) # [B,...,6L+3]\n", "    return input_enc, weight"]}
{"filename": "models/loss.py", "chunked_list": ["import torch\n\timport torch.nn as nn\n\timport torch.nn.functional as F\n\timport numpy as np\n\timport copy\n\tfrom itertools import combinations\n\timport utils.utils_training as TrainingUtils\n\tMIN_PIXELS_PLANE = 20\n\tdef get_normal_consistency_loss(normals, mask_curr_plane, error_mode = 'angle_error'):\n\t    '''Return normal loss of pixels on the same plane\n", "    Return:\n\t        normal_consistency_loss: float, on each pixels\n\t        num_pixels_curr_plane: int\n\t        normal_mean_curr, 3*1\n\t    '''\n\t    num_pixels_curr_plane = mask_curr_plane.sum()\n\t    if num_pixels_curr_plane < MIN_PIXELS_PLANE:\n\t        return 0.0,  num_pixels_curr_plane, torch.zeros(3)\n\t    normals_fine_curr_plane = normals * mask_curr_plane\n\t    normal_mean_curr = normals_fine_curr_plane.sum(dim=0) / num_pixels_curr_plane\n", "    if error_mode == 'angle_error':\n\t        inner = (normals * normal_mean_curr).sum(dim=-1,keepdim=True)\n\t        norm_all =  torch.linalg.norm(normals, dim=-1, ord=2,keepdim=True)\n\t        norm_mean_curr = torch.linalg.norm(normal_mean_curr, dim=-1, ord=2,keepdim=True)\n\t        angles = torch.arccos(inner/((norm_all*norm_mean_curr) + 1e-6)) #.clip(-np.pi, np.pi)\n\t        angles = angles*mask_curr_plane\n\t        normal_consistency_loss = F.l1_loss(angles, torch.zeros_like(angles), reduction='sum')\n\t    return normal_consistency_loss, num_pixels_curr_plane, normal_mean_curr\n\tdef get_plane_offset_loss(pts, ave_normal, mask_curr_plane, mask_subplanes):\n\t    '''\n", "    Args:\n\t        pts: pts in world coordinates\n\t        normals: normals of pts in world coordinates\n\t        mask_plane: mask of pts which belong to the same plane\n\t    '''\n\t    mask_subplanes_curr = copy.deepcopy(mask_subplanes)\n\t    mask_subplanes_curr[mask_curr_plane == False] = 0 # only keep subplanes of current plane\n\t    loss_offset_subplanes = []\n\t    num_subplanes = int(mask_subplanes_curr.max().item())\n\t    if num_subplanes < 1:\n", "        return 0, 0\n\t    num_pixels_valid_subplanes = 0\n\t    loss_offset_subplanes = torch.zeros(num_subplanes)\n\t    for i in range(num_subplanes):\n\t        curr_subplane = (mask_subplanes_curr == (i+1))\n\t        num_pixels = curr_subplane.sum()\n\t        if num_pixels < MIN_PIXELS_PLANE:\n\t            continue\n\t        offsets = (pts*ave_normal).sum(dim=-1,keepdim=True)\n\t        ave_offset = ((offsets * curr_subplane).sum() / num_pixels) #.detach()  # detach?\n", "        diff_offsset = (offsets-ave_offset)*curr_subplane\n\t        loss_tmp = F.mse_loss(diff_offsset, torch.zeros_like(diff_offsset), reduction='sum') #/ num_pixels\n\t        loss_offset_subplanes[i] = loss_tmp\n\t        num_pixels_valid_subplanes += num_pixels\n\t    return loss_offset_subplanes.sum(), num_pixels_valid_subplanes\n\tdef get_manhattan_normal_loss(normal_planes):\n\t    '''The major planes should be vertical to each other\n\t    '''\n\t    normal_planes = torch.stack(normal_planes, dim=0)\n\t    num_planes = len(normal_planes)\n", "    assert num_planes < 4\n\t    if num_planes < 2:\n\t        return 0\n\t    all_perms = np.array( list(combinations(np.arange(num_planes),2)) ).transpose().astype(int) # 2*N\n\t    normal1, normal2 = normal_planes[all_perms[0]], normal_planes[all_perms[1]]\n\t    inner = (normal1 * normal2).sum(-1)\n\t    manhattan_normal_loss = F.l1_loss(inner, torch.zeros_like(inner), reduction='mean')\n\t    return manhattan_normal_loss\n\tclass NeuSLoss(nn.Module):\n\t    def __init__(self, conf):\n", "        super().__init__()\n\t        self.color_weight = conf['color_weight']\n\t        self.igr_weight = conf['igr_weight']\n\t        self.smooth_weight = conf['smooth_weight']\n\t        self.mask_weight = conf['mask_weight']\n\t        self.depth_weight = conf['depth_weight']\n\t        self.normal_weight = conf['normal_weight']\n\t        self.normal_consistency_weight = conf['normal_consistency_weight']\n\t        self.plane_offset_weight = conf['plane_offset_weight']\n\t        self.manhattan_constrain_weight = conf['manhattan_constrain_weight']\n", "        self.plane_loss_milestone = conf['plane_loss_milestone']\n\t        self.warm_up_start = conf['warm_up_start']\n\t        self.warm_up_end = conf['warm_up_end']\n\t        self.iter_step = 0\n\t        self.iter_end = -1\n\t    def get_warm_up_ratio(self):\n\t        if self.warm_up_end == 0.0:\n\t            return 1.0\n\t        elif self.iter_step < self.warm_up_start:\n\t            return 0.0\n", "        else:\n\t            return np.min([1.0, (self.iter_step - self.warm_up_start) / (self.warm_up_end - self.warm_up_start)])\n\t    def forward(self, input_model, render_out, sdf_network_fine, patchmatch_out = None):\n\t        true_rgb = input_model['true_rgb']\n\t        mask, rays_o, rays_d, near, far = input_model['mask'], input_model['rays_o'], input_model['rays_d'],  \\\n\t                                                    input_model['near'], input_model['far']\n\t        mask_sum = mask.sum() + 1e-5\n\t        batch_size = len(rays_o)\n\t        color_fine = render_out['color_fine']\n\t        variance = render_out['variance']\n", "        cdf_fine = render_out['cdf_fine']\n\t        gradient_error_fine = render_out['gradient_error_fine']\n\t        weight_max = render_out['weight_max']\n\t        weight_sum = render_out['weight_sum']\n\t        weights = render_out['weights']\n\t        depth = render_out['depth']\n\t        planes_gt = None\n\t        if 'planes_gt' in input_model:\n\t            planes_gt = input_model['planes_gt']\n\t        if 'subplanes_gt' in input_model:\n", "            subplanes_gt = input_model['subplanes_gt']\n\t        logs_summary = {}\n\t        # patchmatch loss\n\t        normals_target, mask_use_normals_target = None, None\n\t        pts_target, mask_use_pts_target = None, None\n\t        if patchmatch_out is not None:\n\t            if patchmatch_out['patchmatch_mode'] == 'use_geocheck':\n\t                mask_use_normals_target = (patchmatch_out['idx_scores_min'] > 0).float()\n\t                normals_target = input_model['normals_gt']\n\t            else:\n", "                raise NotImplementedError\n\t        else:\n\t            if self.normal_weight>0:\n\t                normals_target = input_model['normals_gt']\n\t                mask_use_normals_target = torch.ones(batch_size, 1).bool()\n\t        # Color loss\n\t        color_fine_loss, background_loss, psnr = 0, 0, 0\n\t        if True:\n\t            color_error = (color_fine - true_rgb) * mask\n\t            color_fine_loss = F.l1_loss(color_error, torch.zeros_like(color_error), reduction='sum') / mask_sum\n", "            psnr = 20.0 * torch.log10(1.0 / (((color_fine - true_rgb)**2 * mask).sum() / (mask_sum * 3.0)).sqrt())\n\t            # Mask loss, optional\n\t            background_loss = F.binary_cross_entropy(weight_sum.clip(1e-3, 1.0 - 1e-3), mask)\n\t            logs_summary.update({           \n\t                'Loss/loss_color':  color_fine_loss.detach().cpu(),\n\t                'Loss/loss_bg':     background_loss\n\t            })\n\t        # Eikonal loss\n\t        gradient_error_loss = 0\n\t        if self.igr_weight > 0:\n", "            gradient_error_loss = gradient_error_fine\n\t            logs_summary.update({           \n\t                'Loss/loss_eik':    gradient_error_loss.detach().cpu(),\n\t            })            \n\t        # Smooth loss, optional\n\t        surf_reg_loss = 0.0\n\t        if self.smooth_weight > 0:\n\t            depth = render_out['depth'].detach()\n\t            pts = rays_o + depth * rays_d\n\t            n_pts = pts + torch.randn_like(pts) * 1e-3  # WARN: Hard coding here\n", "            surf_normal = sdf_network_fine.gradient(torch.cat([pts, n_pts], dim=0)).squeeze()\n\t            surf_normal = surf_normal / torch.linalg.norm(surf_normal, dim=-1, ord=2, keepdim=True)\n\t            surf_reg_loss_pts = (torch.linalg.norm(surf_normal[:batch_size, :] - surf_normal[batch_size:, :], ord=2, dim=-1, keepdim=True))\n\t            # surf_reg_loss = (surf_reg_loss_pts*pixel_weight).mean()\n\t            surf_reg_loss = surf_reg_loss_pts.mean()\n\t        # normal loss\n\t        normals_fine_loss, mask_keep_gt_normal = 0.0, torch.ones(batch_size)\n\t        if self.normal_weight > 0 and normals_target is not None:\n\t            normals_gt = normals_target # input_model['normals_gt'] #\n\t            normals_fine = render_out['normal']\n", "            normal_certain_weight = torch.ones(batch_size, 1).bool()\n\t            if 'normal_certain_weight' in input_model:\n\t                normal_certain_weight = input_model['normal_certain_weight']\n\t            thres_clip_angle = -1 #\n\t            normal_certain_weight = normal_certain_weight*mask_use_normals_target\n\t            angular_error, mask_keep_gt_normal = TrainingUtils.get_angular_error(normals_fine, normals_gt, normal_certain_weight, thres_clip_angle)\n\t            normals_fine_loss = angular_error\n\t            logs_summary.update({\n\t                'Loss/loss_normal_gt': normals_fine_loss\n\t            })\n", "        # depth loss, optional\n\t        depths_fine_loss = 0.0\n\t        pts_target = input_model['depth_gt']\n\t        mask_use_pts_target = torch.ones(batch_size, 1).bool()\n\t        if self.depth_weight > 0 and (pts_target is not None):\n\t            pts = rays_o + depth * rays_d\n\t            pts_error = (pts_target - pts) * mask_use_pts_target\n\t            pts_error = torch.linalg.norm(pts_error, dim=-1, keepdims=True)\n\t            depths_fine_loss = F.l1_loss(pts_error, torch.zeros_like(pts_error), reduction='mean') / (mask_use_pts_target.sum()+1e-6)\n\t            logs_summary.update({\n", "                'Loss/loss_depth': depths_fine_loss,\n\t                'Log/num_depth_target_use': mask_use_pts_target.sum().detach().cpu()\n\t            })\n\t        plane_loss_all = 0\n\t        if self.normal_consistency_weight > 0 and self.iter_step > self.plane_loss_milestone:\n\t            num_planes = int(planes_gt.max().item())\n\t            depth = render_out['depth']   # detach?\n\t            pts = rays_o + depth * rays_d\n\t            normals_fine = render_out['normal']\n\t            # (1) normal consistency loss\n", "            num_pixels_on_planes = 0\n\t            num_pixels_on_subplanes = 0\n\t            dominant_normal_planes = []\n\t            normal_consistency_loss = torch.zeros(num_planes)\n\t            loss_plane_offset = torch.zeros(num_planes)\n\t            for i in range(int(num_planes)):\n\t                idx_plane = i + 1\n\t                mask_curr_plane = planes_gt.eq(idx_plane)\n\t                if mask_curr_plane.float().max() < 1.0:\n\t                    # this plane is not existent\n", "                    continue\n\t                consistency_loss_tmp, num_pixels_tmp, normal_mean_curr = get_normal_consistency_loss(normals_fine, mask_curr_plane)\n\t                normal_consistency_loss[i] = consistency_loss_tmp\n\t                num_pixels_on_planes += num_pixels_tmp\n\t                # for Manhattan loss\n\t                if i < 3:\n\t                    # only use the 3 dominant planes\n\t                    dominant_normal_planes.append(normal_mean_curr)\n\t                # (2) plane-to-origin offset loss\n\t                if self.plane_offset_weight > 0:\n", "                    # normal_mean_curr_no_grad =  normal_mean_curr.detach()\n\t                    plane_offset_loss_curr, num_pixels_subplanes_valid_curr = get_plane_offset_loss(pts, normal_mean_curr, mask_curr_plane, subplanes_gt)\n\t                    loss_plane_offset[i] = plane_offset_loss_curr\n\t                    num_pixels_on_subplanes += num_pixels_subplanes_valid_curr\n\t            assert num_pixels_on_planes >= MIN_PIXELS_PLANE                   \n\t            normal_consistency_loss = normal_consistency_loss.sum() / (num_pixels_on_planes+1e-6)\n\t            loss_plane_offset = loss_plane_offset.sum() / (num_pixels_on_subplanes+1e-6)\n\t            # (3) normal manhattan loss\n\t            loss_normal_manhattan = 0\n\t            if self.manhattan_constrain_weight > 0:\n", "                loss_normal_manhattan = get_manhattan_normal_loss(dominant_normal_planes)\n\t            plane_loss_all = normal_consistency_loss * self.normal_consistency_weight  + \\\n\t                                    loss_normal_manhattan * self.manhattan_constrain_weight + \\\n\t                                    loss_plane_offset * self.plane_offset_weight\n\t        loss = color_fine_loss * self.color_weight +\\\n\t                gradient_error_loss * self.igr_weight +\\\n\t                surf_reg_loss * self.smooth_weight +\\\n\t                plane_loss_all +\\\n\t                background_loss * self.mask_weight +\\\n\t                normals_fine_loss * self.normal_weight * self.get_warm_up_ratio()  + \\\n", "                depths_fine_loss * self.depth_weight  #+ \\\n\t        logs_summary.update({\n\t            'Loss/loss': loss.detach().cpu(),\n\t            'Loss/loss_smooth': surf_reg_loss,\n\t            'Loss/variance':    variance.mean().detach(),\n\t            'Log/psnr':         psnr,\n\t            'Log/ratio_warmup_loss':  self.get_warm_up_ratio()\n\t        })\n\t        return loss, logs_summary, mask_keep_gt_normal"]}
{"filename": "models/dataset.py", "chunked_list": ["import torch\n\timport torch.nn as nn\n\tfrom torch.nn import functional as F\n\tfrom tqdm import tqdm\n\timport cv2 as cv\n\timport numpy as np\n\timport os, copy, logging\n\tfrom glob import glob\n\tfrom icecream import ic\n\tfrom scipy.spatial.transform import Rotation as Rot\n", "from scipy.spatial.transform import Slerp\n\tfrom utils.utils_image import read_images, write_image, write_images\n\tfrom utils.utils_io import checkExistence, ensure_dir_existence, get_path_components, get_files_stem\n\tfrom utils.utils_geometry import get_pose_inv, get_world_normal, quat_to_rot, save_points\n\timport utils.utils_geometry as GeoUtils\n\timport utils.utils_io as IOUtils\n\timport models.patch_match_cuda as PatchMatch\n\timport utils.utils_training as TrainingUtils\n\timport utils.utils_image as ImageUtils\n\tdef load_K_Rt_from_P(filename, P=None):\n", "    if P is None:\n\t        lines = open(filename).read().splitlines()\n\t        if len(lines) == 4:\n\t            lines = lines[1:]\n\t        lines = [[x[0], x[1], x[2], x[3]] for x in (x.split(\" \") for x in lines)]\n\t        P = np.asarray(lines).astype(np.float32).squeeze()\n\t    out = cv.decomposeProjectionMatrix(P)\n\t    K = out[0]\n\t    R = out[1]\n\t    t = out[2]\n", "    K = K / K[2, 2]\n\t    intrinsics = np.eye(4)\n\t    intrinsics[:3, :3] = K\n\t    pose = np.eye(4, dtype=np.float32)\n\t    pose[:3, :3] = R.transpose()\n\t    pose[:3, 3] = (t[:3] / t[3])[:, 0]\n\t    return intrinsics, pose\n\tclass Dataset:\n\t    '''Check normal and depth in folder depth_cloud\n\t    '''\n", "    def __init__(self, conf):\n\t        super(Dataset, self).__init__()\n\t        # logging.info('Load data: Begin')\n\t        self.device = torch.device('cuda')\n\t        self.conf = conf\n\t        self.data_dir = conf['data_dir']\n\t        self.cache_all_data = conf['cache_all_data']\n\t        assert self.cache_all_data == False\n\t        self.mask_out_image = conf['mask_out_image']\n\t        self.estimate_scale_mat = conf['estimate_scale_mat']\n", "        self.piece_size = 2**20\n\t        self.bbox_size_half = conf['bbox_size_half']\n\t        self.use_normal = conf['use_normal']\n\t        self.resolution_level = conf['resolution_level']\n\t        self.denoise_gray_image = self.conf['denoise_gray_image']\n\t        self.denoise_paras = self.conf['denoise_paras']\n\t        self.use_planes = conf['use_planes']\n\t        self.use_plane_offset_loss = conf['use_plane_offset_loss']\n\t        path_cam = os.path.join(self.data_dir, './cameras_sphere.npz')  # cameras_sphere, cameras_linear_init\n\t        camera_dict = np.load(path_cam)\n", "        logging.info(f'Load camera dict: {path_cam.split(\"/\")[-1]}')\n\t        images_lis = None\n\t        for ext in ['.png', '.JPG']:\n\t            images_lis = sorted(glob(os.path.join(self.data_dir, f'image/*{ext}')))\n\t            self.vec_stem_files = get_files_stem(f'{self.data_dir}/image', ext_file=ext)\n\t            if len(images_lis) > 0:\n\t                break\n\t        assert len(images_lis) > 0\n\t        self.n_images = len(images_lis)\n\t        logging.info(f\"Read {self.n_images} images.\")\n", "        self.images_lis = images_lis\n\t        self.images_np = np.stack([self.read_img(im_name, self.resolution_level) for im_name in images_lis]) / 256.0\n\t        masks_lis = sorted(glob(os.path.join(self.data_dir, 'mask/*.png')))\n\t        if len(masks_lis) ==0:\n\t            self.masks_np = np.ones(self.images_np.shape[:-1])\n\t            logging.info(f\"self.masks_np.shape: {self.masks_np.shape}\")\n\t        else:\n\t            self.masks_np = np.stack([self.read_img(im_name, self.resolution_level) for im_name in masks_lis])[:,:,:,0] / 256.0\n\t        if self.mask_out_image:\n\t            self.images_np[np.where(self.masks_np < 0.5)] = 0.0\n", "        # world_mat: projection matrix: world to image\n\t        self.world_mats_np = [camera_dict['world_mat_%d' % idx].astype(np.float32) for idx in range(self.n_images)]\n\t        self.scale_mats_np = []\n\t        # scale_mat: used for coordinate normalization, we assume the object is inside the unit sphere at origin.\n\t        if self.estimate_scale_mat:\n\t            self.scale_mats_np = self.estimated_scale_mat()\n\t        else:\n\t            self.scale_mats_np = [camera_dict['scale_mat_%d' % idx].astype(np.float32) for idx in range(self.n_images)]\n\t        self.intrinsics_all = []\n\t        self.pose_all = []\n", "        # i = 0\n\t        for scale_mat, world_mat in zip(self.scale_mats_np, self.world_mats_np):\n\t            P = world_mat @ scale_mat\n\t            P = P[:3, :4]\n\t            intrinsics, pose = load_K_Rt_from_P(None, P)\n\t            if self.resolution_level > 1.0:\n\t                intrinsics[:2,:3] /= self.resolution_level\n\t            self.intrinsics_all.append(torch.from_numpy(intrinsics).float())\n\t            self.pose_all.append(torch.from_numpy(pose).float())\n\t        self.images = torch.from_numpy(self.images_np.astype(np.float32)).cpu()  # n_images, H, W, 3   # Save GPU memory\n", "        self.masks  = torch.from_numpy(self.masks_np.astype(np.float32)).cpu()   # n_images, H, W, 3   # Save GPU memory\n\t        h_img, w_img, _ = self.images[0].shape\n\t        logging.info(f\"Resolution level: {self.resolution_level}. Image size: ({w_img}, {h_img})\")\n\t        if self.use_normal:\n\t            logging.info(f'[Use normal] Loading estimated normals...')\n\t            normals_np = []\n\t            normals_npz, stems_normal = read_images(f'{self.data_dir}/pred_normal', target_img_size=(w_img, h_img), img_ext='.npz')\n\t            assert len(normals_npz) == self.n_images\n\t            for i in tqdm(range(self.n_images)):\n\t                normal_img_curr = normals_npz[i]\n", "                # transform to world coordinates\n\t                ex_i = torch.linalg.inv(self.pose_all[i])\n\t                img_normal_w = get_world_normal(normal_img_curr.reshape(-1, 3), ex_i).reshape(h_img, w_img,3)\n\t                normals_np.append(img_normal_w)\n\t            self.normals_np = -np.stack(normals_np)   # reverse normal\n\t            self.normals = torch.from_numpy(self.normals_np.astype(np.float32)).cpu()\n\t            debug_ = True\n\t            if debug_ and IOUtils.checkExistence(f'{self.data_dir}/depth'):\n\t                self.depths_np, stems_depth = read_images(f'{self.data_dir}/depth', target_img_size=(w_img, h_img), img_ext='.png')\n\t                dir_depths_cloud = f'{self.data_dir}/depth_cloud'\n", "                ensure_dir_existence(dir_depths_cloud)\n\t                for i in range(len(self.images)):\n\t                    ext_curr = get_pose_inv(self.pose_all[i].detach().cpu().numpy())\n\t                    pts = GeoUtils.get_world_points( self.depths_np[i], self.intrinsics_all[i], ext_curr)\n\t                    normals_curr = self.normals_np[i].reshape(-1,3)\n\t                    colors = self.images_np[i].reshape(-1,3)\n\t                    save_points(f'{dir_depths_cloud}/{stems_depth[i]}.ply', pts, colors, normals_curr)\n\t                    pts2 = torch.from_numpy(pts.astype(np.float32)).cpu()\n\t                    self.pts = pts2.unsqueeze(0).expand(self.images.shape[0], -1, -1)\n\t        if self.use_planes:\n", "            logging.info(f'Use planes: Loading planes...')  \n\t            planes_np = []\n\t            planes_lis = sorted(glob(f'{self.data_dir}/pred_normal_planes/*.png'))\n\t            assert len(planes_lis) == self.n_images\n\t            for i in range(self.n_images):\n\t                path = planes_lis[i]\n\t                img_plane = cv.imread(path, cv.IMREAD_UNCHANGED)\n\t                if img_plane.shape[0] != h_img:\n\t                    img_plane = cv.resize(img_plane, (w_img, h_img), interpolation=cv.INTER_NEAREST)\n\t                planes_np.append(img_plane)\n", "            self.planes_np = np.stack(planes_np)\n\t            # if self.planes_np.max() > 40:\n\t            #     self.planes_np = self.planes_np // 40\n\t            assert self.planes_np.max() <= 20 \n\t            self.planes = torch.from_numpy(self.planes_np.astype(np.float32)).cpu()\n\t        if self.use_plane_offset_loss:\n\t            logging.info(f'Use planes: Loading subplanes...')  \n\t            subplanes_np, stem_subplanes = read_images(f'{self.data_dir}/pred_normal_subplanes', \n\t                                                            target_img_size=(w_img, h_img), \n\t                                                            interpolation=cv.INTER_NEAREST, \n", "                                                            img_ext='.png')\n\t            # subplanes_np = subplanes_np // 40\n\t            assert subplanes_np.max() <= 20 \n\t            self.subplanes = torch.from_numpy(subplanes_np.astype(np.uint8)).cpu()\n\t        self.intrinsics_all = torch.stack(self.intrinsics_all).to(self.device)  # n, 4, 4\n\t        self.intrinsics_all_inv = torch.inverse(self.intrinsics_all) # n, 4, 4\n\t        self.focal = self.intrinsics_all[0][0, 0]\n\t        self.pose_all = torch.stack(self.pose_all).to(self.device)  # n_images, 4, 4\n\t        self.H, self.W = self.images.shape[1], self.images.shape[2]\n\t        self.image_pixels = self.H * self.W\n", "        # for patch match\n\t        self.min_neighbors_ncc = 3\n\t        if IOUtils.checkExistence(self.data_dir + '/neighbors.txt'):\n\t            self.min_neighbors_ncc = 1  # images are relatively sparse\n\t            path_neighbors = self.data_dir + '/neighbors.txt'\n\t            logging.info(f'Use openMVS neighbors.')\n\t            self.dict_neighbors = {}\n\t            with open(path_neighbors, 'r') as fneighbor:\n\t                lines = fneighbor.readlines()\n\t                for line in lines:\n", "                    line = line.split(' ')\n\t                    line = np.array(line).astype(np.int32)\n\t                    if len(line) > 1:\n\t                        self.dict_neighbors[line[0]] = line[1:]\n\t                    else:\n\t                        logging.info(f'[{line[0]}] No neighbors, use adjacent views')\n\t                        self.dict_neighbors[line[0]] = [np.min([line[0] + 1, self.n_images - 1]), np.min([line[0] - 1, 0]) ]\n\t                for i in range(self.n_images):\n\t                    if i not in self.dict_neighbors:\n\t                        print(f'[View {i}] error: No nerighbors. Using {i-1, i+1}')\n", "                        self.dict_neighbors[i] = [i-1,i+1]\n\t                        msg = input('Check neighbor view...[y/n]')\n\t                        if msg == 'n':\n\t                            exit()\n\t                assert len(self.dict_neighbors) == self.n_images       \n\t        else:\n\t            logging.info(f'Use adjacent views as neighbors.')\n\t        self.initialize_patchmatch()\n\t        # Gen train_data\n\t        self.train_data = None\n", "        if self.cache_all_data:\n\t            train_data = []\n\t            # Calc rays\n\t            rays_o, rays_d = self.gen_rays()\n\t            self.train_idx = []\n\t            for i in range(len(self.images)):\n\t                cur_data = torch.cat([rays_o[i], rays_d[i], self.images[i].to(self.device), self.masks[i, :, :, :1].to(self.device)], dim=-1).detach()\n\t                # cur_data: [H, W, 10]\n\t                cur_data = cur_data[torch.randperm(len(cur_data))]\n\t                train_data.append(cur_data.reshape(-1, 10).detach().cpu())\n", "            # train_data.append(cur_data.reshape(-1, 10))\n\t            self.train_data = torch.stack(train_data).reshape(-1, 10).detach().cpu()\n\t            self.train_piece = None\n\t            self.train_piece_np = None\n\t            self.large_counter = 0\n\t            self.small_counter = 0\n\t            del self.images\n\t            del self.masks\n\t        self.sphere_radius =  conf['sphere_radius']\n\t        if checkExistence(f'{self.data_dir}/bbox.txt'):\n", "            logging.info(f\"Loading bbox.txt\")\n\t            bbox = np.loadtxt(f'{self.data_dir}/bbox.txt')\n\t            self.bbox_min = bbox[:3]\n\t            self.bbox_max = bbox[3:6]\n\t        else:\n\t            self.bbox_min = np.array([-1.01*self.bbox_size_half, -1.01*self.bbox_size_half, -1.01*self.bbox_size_half])\n\t            self.bbox_max = np.array([ 1.01*self.bbox_size_half,  1.01*self.bbox_size_half,  1.01*self.bbox_size_half])\n\t        self.iter_step = 0\n\t    def initialize_patchmatch(self):\n\t        self.check_occlusion = self.conf['check_occlusion']\n", "        logging.info(f'Prepare gray images...')\n\t        self.extrinsics_all = torch.linalg.inv(self.pose_all)\n\t        self.images_gray = []\n\t        self.images_denoise_np = []\n\t        if self.denoise_gray_image:\n\t            dir_denoise = f'{self.data_dir}/image_denoised_cv{self.denoise_paras[0]:02d}{self.denoise_paras[1]:02d}{self.denoise_paras[2]:02d}{self.denoise_paras[3]:02d}'\n\t            if not checkExistence(dir_denoise) and len(get_files_stem(dir_denoise, '.png'))==0:\n\t                logging.info(f'Use opencv structural denoise...')\n\t                for i in tqdm(range(self.n_images)):\n\t                    img_idx = (self.images_np[i]*256)\n", "                    img_idx = cv.fastNlMeansDenoisingColored(img_idx.astype(np.uint8), None, h = self.denoise_paras[2], \n\t                                                                                            hColor = self.denoise_paras[3], \n\t                                                                                            templateWindowSize = self.denoise_paras[0], \n\t                                                                                            searchWindowSize = self.denoise_paras[1])\n\t                    self.images_denoise_np.append(img_idx)\n\t                self.images_denoise_np = np.array(self.images_denoise_np)\n\t                # save denoised images\n\t                stems_imgs = get_files_stem(f'{self.data_dir}/image', '.png')\n\t                write_images(dir_denoise, self.images_denoise_np, stems_imgs)\n\t            else:\n", "                logging.info(f'Load predenoised images by openCV structural denoise: {dir_denoise}')\n\t                images_denoised_lis = sorted(glob(f'{dir_denoise}/*.png'))\n\t                self.images_denoise_np = np.stack([self.read_img(im_name, self.resolution_level) for im_name in images_denoised_lis])\n\t        else:\n\t            logging.info(f'Use original image to generate gray image...')\n\t            self.images_denoise_np = self.images_np * 255\n\t        for i in tqdm(range(self.n_images)):\n\t            img_gray = cv.cvtColor(self.images_denoise_np[i].astype(np.uint8), cv.COLOR_BGR2GRAY)\n\t            self.images_gray.append(img_gray)\n\t        # range: (0,255)\n", "        self.images_gray_np = np.array(self.images_gray).astype(np.float32)\n\t        self.images_gray = torch.from_numpy(self.images_gray_np).cuda()\n\t        # For cache rendered depths and normals\n\t        self.confidence_accum = None\n\t        self.samples_accum = None\n\t        self.normals_accum = None\n\t        self.depths_accum = None\n\t        self.points_accum = None\n\t        self.render_difference_accum = None\n\t        self.samples_accum = torch.zeros_like(self.masks, dtype=torch.int32).cuda()\n", "        b_accum_all_data = False\n\t        if b_accum_all_data:\n\t            self.colors_accum = torch.zeros_like(self.images, dtype=torch.float32).cuda()\n\t    def read_img(self, path, resolution_level):\n\t        img = cv.imread(path)\n\t        H, W = img.shape[0], img.shape[1]\n\t        if resolution_level > 1.0:\n\t            img = cv.resize(img, (int(W/resolution_level), int(H/resolution_level)), interpolation=cv.INTER_LINEAR)\n\t            # save resized iamge for visulization\n\t            ppath, stem, ext = get_path_components(path)\n", "            dir_resize = ppath+f'_reso{int(resolution_level)}'\n\t            logging.debug(f'Resize dir: {dir_resize}')\n\t            os.makedirs(dir_resize, exist_ok=True)\n\t            write_image(os.path.join(dir_resize, stem+ext), img)\n\t        return img\n\t    def estimated_scale_mat(self):\n\t        assert len(self.world_mats_np) > 0\n\t        rays_o = []\n\t        rays_v = []\n\t        for world_mat in self.world_mats_np:\n", "            P = world_mat[:3, :4]\n\t            intrinsics, c2w = load_K_Rt_from_P(None, P)\n\t            rays_o.append(c2w[:3, 3])\n\t            rays_v.append(c2w[:3, 0])\n\t            rays_o.append(c2w[:3, 3])\n\t            rays_v.append(c2w[:3, 1])\n\t        rays_o = np.stack(rays_o, axis=0)   # N * 3\n\t        rays_v = np.stack(rays_v, axis=0)   # N * 3\n\t        dot_val = np.sum(rays_o * rays_v, axis=-1, keepdims=True)  # N * 1\n\t        center, _, _, _ = np.linalg.lstsq(rays_v, dot_val)\n", "        center = center.squeeze()\n\t        radius = np.max(np.sqrt(np.sum((rays_o - center[None, :])**2, axis=-1)))\n\t        scale_mat = np.diag([radius, radius, radius, 1.0])\n\t        scale_mat[:3, 3] = center\n\t        scale_mat = scale_mat.astype(np.float32)\n\t        scale_mats = [scale_mat for _ in self.world_mats_np]\n\t        return scale_mats\n\t    def gen_rays(self):\n\t        tx = torch.linspace(0, self.W - 1, self.W)\n\t        ty = torch.linspace(0, self.H - 1, self.H)\n", "        pixels_x, pixels_y = torch.meshgrid(tx, ty)\n\t        p = torch.stack([pixels_x, pixels_y, torch.ones_like(pixels_y)], dim=-1)  # W, H, 3\n\t        p = torch.matmul(self.intrinsics_all_inv[:, None, None, :3, :3], p[None, :, :, :, None]).squeeze() # n, W, H, 3\n\t        rays_v = p / torch.linalg.norm(p, ord=2, dim=-1, keepdim=True)  # n, W, H, 3\n\t        rays_v = torch.matmul(self.pose_all[:, None, None, :3, :3],  rays_v[:, :, :, :, None]).squeeze()  # n, W, H, 3\n\t        rays_o = self.pose_all[:, None, None, :3, 3].expand(rays_v.shape)  # n, W, H, 3\n\t        return rays_o.transpose(1, 2), rays_v.transpose(1, 2)\n\t    def get_pose(self, img_idx, pose):\n\t        pose_cur = None\n\t        if pose == None:\n", "            pose_cur = self.pose_all[img_idx]\n\t        elif pose is not None:\n\t            if pose.dim() == 1:\n\t                pose = pose.unsqueeze(0)\n\t            assert pose.dim() == 2\n\t            if pose.shape[1] == 7: #In case of quaternion vector representation\n\t                cam_loc = pose[:, 4:]\n\t                R = quat_to_rot(pose[:,:4])\n\t                p = torch.eye(4).repeat(pose.shape[0],1,1).cuda().float()\n\t                p[:, :3, :3] = R\n", "                p[:, :3, 3] = cam_loc\n\t            else: # In case of pose matrix representation\n\t                cam_loc = pose[:, :3, 3]\n\t                p = pose\n\t            pose_cur = p\n\t        else:\n\t            NotImplementedError \n\t        return pose_cur.squeeze()\n\t    def gen_rays_at(self, img_idx, pose = None, resolution_level=1):\n\t        pose_cur = self.get_pose(img_idx, pose)\n", "        l = resolution_level\n\t        tx = torch.linspace(0, self.W - 1, self.W // l)\n\t        ty = torch.linspace(0, self.H - 1, self.H // l)\n\t        pixels_x, pixels_y = torch.meshgrid(tx, ty)\n\t        p = torch.stack([pixels_x, pixels_y, torch.ones_like(pixels_y)], dim=-1) # W, H, 3\n\t        p = torch.matmul(self.intrinsics_all_inv[img_idx, None, None, :3, :3], p[:, :, :, None]).squeeze()  # W, H, 3\n\t        rays_v = p / torch.linalg.norm(p, ord=2, dim=-1, keepdim=True)  # W, H, 3\n\t        rays_v = torch.matmul(pose_cur[None, None, :3, :3], rays_v[:, :, :, None]).squeeze()  # W, H, 3\n\t        rays_o = pose_cur[None, None, :3, 3].expand(rays_v.shape)  # W, H, 3\n\t        return rays_o.transpose(0, 1), rays_v.transpose(0, 1)\n", "    def gen_rays_between(self, idx_0, idx_1, ratio, resolution_level=1):\n\t        l = resolution_level\n\t        tx = torch.linspace(0, self.W - 1, self.W // l)\n\t        ty = torch.linspace(0, self.H - 1, self.H // l)\n\t        pixels_x, pixels_y = torch.meshgrid(tx, ty)\n\t        p = torch.stack([pixels_x, pixels_y, torch.ones_like(pixels_y)], dim=-1)  # W, H, 3\n\t        p = torch.matmul(self.intrinsics_all_inv[0, None, None, :3, :3], p[:, :, :, None]).squeeze()  # W, H, 3\n\t        rays_v = p / torch.linalg.norm(p, ord=2, dim=-1, keepdim=True)  # W, H, 3\n\t        trans = self.pose_all[idx_0, :3, 3] * (1.0 - ratio) + self.pose_all[idx_1, :3, 3] * ratio\n\t        pose_0 = self.pose_all[idx_0].detach().cpu().numpy()\n", "        pose_1 = self.pose_all[idx_1].detach().cpu().numpy()\n\t        pose_0 = np.linalg.inv(pose_0)\n\t        pose_1 = np.linalg.inv(pose_1)\n\t        rot_0 = pose_0[:3, :3]\n\t        rot_1 = pose_1[:3, :3]\n\t        rots = Rot.from_matrix(np.stack([rot_0, rot_1]))\n\t        key_times = [0, 1]\n\t        key_rots = [rot_0, rot_1]\n\t        slerp = Slerp(key_times, rots)\n\t        rot = slerp(ratio)\n", "        pose = np.diag([1.0, 1.0, 1.0, 1.0])\n\t        pose = pose.astype(np.float32)\n\t        pose[:3, :3] = rot.as_matrix()\n\t        pose[:3, 3] = ((1.0 - ratio) * pose_0 + ratio * pose_1)[:3, 3]\n\t        pose = np.linalg.inv(pose)\n\t        rot = torch.from_numpy(pose[:3, :3]).cuda()\n\t        trans = torch.from_numpy(pose[:3, 3]).cuda()\n\t        rays_v = torch.matmul(rot[None, None, :3, :3], rays_v[:, :, :, None]).squeeze()  # W, H, 3\n\t        rays_o = trans[None, None, :3].expand(rays_v.shape)  # W, H, 3\n\t        return rays_o.transpose(0, 1), rays_v.transpose(0, 1)\n", "    def gen_random_rays_at(self, img_idx, batch_size):\n\t        \"\"\"\n\t        Generate random rays at world space from one camera.\n\t        \"\"\"\n\t        pixels_x = torch.randint(low=0, high=self.W, size=[batch_size])\n\t        pixels_y = torch.randint(low=0, high=self.H, size=[batch_size])\n\t        color = self.images[img_idx][(pixels_y, pixels_x)]    # batch_size, 3\n\t        mask = self.masks[img_idx][(pixels_y, pixels_x)]      # batch_size, 3\n\t        p = torch.stack([pixels_x, pixels_y, torch.ones_like(pixels_y)], dim=-1).float()  # batch_size, 3\n\t        p = torch.matmul(self.intrinsics_all_inv[img_idx, None, :3, :3], p[:, :, None]).squeeze() # batch_size, 3\n", "        rays_v = p / torch.linalg.norm(p, ord=2, dim=-1, keepdim=True)    # batch_size, 3\n\t        rays_v = torch.matmul(self.pose_all[img_idx, None, :3, :3], rays_v[:, :, None]).squeeze()  # batch_size, 3\n\t        rays_o = self.pose_all[img_idx, None, :3, 3].expand(rays_v.shape) # batch_size, 3\n\t        return torch.cat([rays_o.cpu(), rays_v.cpu(), color, mask[:, :1]], dim=-1).cuda()    # batch_size, 10\n\t    def random_get_rays_at(self, img_idx, batch_size, pose = None):\n\t        pose_cur = self.get_pose(img_idx, pose)\n\t        pixels_x = torch.randint(low=0, high=self.W, size=[batch_size]).cpu()\n\t        pixels_y = torch.randint(low=0, high=self.H, size=[batch_size]).cpu()\n\t        color = self.images[img_idx][(pixels_y, pixels_x)]    # batch_size, 3\n\t        mask = self.masks[img_idx][(pixels_y, pixels_x)][:,None]     # batch_size, 3\n", "        pts_target = self.pts[img_idx][(pixels_y*pixels_x)]\n\t        p = torch.stack([pixels_x, pixels_y, torch.ones_like(pixels_y)], dim=-1).float()  # batch_size, 3\n\t        p = p.to(self.intrinsics_all_inv.device) \n\t        self.intrinsics_all_inv = self.intrinsics_all_inv.to(p.device)\n\t        p = torch.matmul(self.intrinsics_all_inv[img_idx, None, :3, :3], p[:, :, None]).squeeze() # batch_size, 3\n\t        rays_v = p / torch.linalg.norm(p, ord=2, dim=-1, keepdim=True)    # batch_size, 3\n\t        rays_v = torch.matmul(pose_cur[None, :3, :3], rays_v[:, :, None]).squeeze()  # batch_size, 3\n\t        rays_o = pose_cur[None, :3, 3].expand(rays_v.shape) # batch_size, 3\n\t        normal_sample = None\n\t        if self.use_normal:\n", "            normal_sample = self.normals[img_idx][(pixels_y, pixels_x)].cuda()\n\t        planes_sample = None\n\t        if self.use_planes:\n\t            planes_sample = self.planes[img_idx][(pixels_y, pixels_x)].unsqueeze(-1).cuda()\n\t        subplanes_sample = None\n\t        if self.use_plane_offset_loss:\n\t            subplanes_sample = self.subplanes[img_idx][(pixels_y, pixels_x)].unsqueeze(-1).cuda()\n\t        return torch.cat([rays_o.cpu(), rays_v.cpu(), color, mask, pts_target], dim=-1).cuda(), pixels_x, pixels_y, normal_sample, planes_sample, subplanes_sample    # batch_size, 10\n\t    def near_far_from_sphere(self, rays_o, rays_d):\n\t        # torch\n", "        assert self.sphere_radius is not None\n\t        a = torch.sum(rays_d**2, dim=-1, keepdim=True)\n\t        b = 2.0 * torch.sum(rays_o * rays_d, dim=-1, keepdim=True)\n\t        c = torch.sum(rays_o ** 2, dim=-1, keepdim=True) - self.sphere_radius**2\n\t        mid = 0.5 * (-b) / a\n\t        near = mid - self.sphere_radius\n\t        far = mid + self.sphere_radius\n\t        return near, far\n\t    def image_at(self, idx, resolution_level):\n\t        img = cv.imread(self.images_lis[idx])\n", "        return (cv.resize(img, (self.W // resolution_level, self.H // resolution_level))).clip(0, 255)\n\t    def shuffle(self):\n\t        r = torch.randperm(len(self.train_data))\n\t        self.train_data = self.train_data[r]\n\t        self.large_counter = 0\n\t        self.small_counter = 0\n\t    def next_train_batch(self, batch_size):\n\t        if self.train_piece == None or self.small_counter + batch_size >= len(self.train_piece):\n\t            if self.train_piece == None or self.large_counter + self.piece_size >= len(self.train_data):\n\t                self.shuffle()\n", "            self.train_piece_np = self.train_data[self.large_counter: self.large_counter + self.piece_size]\n\t            self.train_piece = self.train_piece_np.cuda()\n\t            self.small_counter = 0\n\t            self.large_counter += self.piece_size\n\t        curr_train_data = self.train_piece[self.small_counter: self.small_counter + batch_size]\n\t        curr_train_data_np = self.train_piece_np[self.small_counter: self.small_counter + batch_size]\n\t        self.small_counter += batch_size\n\t        return curr_train_data, curr_train_data_np\n\t    def score_pixels_ncc(self, idx, pts_world, normals_world, pixels_coords_vu, reso_level = 1.0, _debug = False):\n\t        '''Use patch-match to evaluate the geometry: Smaller, better\n", "        Return:\n\t            scores_all_mean: N*1\n\t            diff_patch_all: N*1\n\t            mask_valid_all: N*1\n\t        '''\n\t        K = copy.deepcopy(self.intrinsics_all[0][:3,:3])\n\t        img_ref = self.images_gray[idx]\n\t        H, W = img_ref.shape\n\t        window_size, window_step= 11, 2\n\t        if reso_level > 1:\n", "            K[:2,:3] /= reso_level\n\t            img_ref = self.images_gray_np[idx]\n\t            img_ref = cv.resize(img_ref, (int(W/reso_level), int(H/reso_level)), interpolation=cv.INTER_LINEAR)\n\t            img_ref = torch.from_numpy(img_ref).cuda()\n\t            window_size, window_step= (5, 1) if reso_level== 2 else (3, 1)\n\t        if hasattr(self, 'dict_neighbors'):\n\t            idx_neighbors = self.dict_neighbors[int(idx)]\n\t            if len(idx_neighbors) < self.min_neighbors_ncc:\n\t                return torch.ones(pts_world.shape[0]), torch.zeros(pts_world.shape[0]), torch.zeros(pts_world.shape[0]).bool()\n\t        else:\n", "            idx_neighbors = [idx-3, idx-2, idx-1, idx+1, idx+2, idx+3]\n\t            if idx < 3:\n\t                idx_neighbors = [idx+1, idx+2, idx+3]\n\t            if idx > self.n_images-4:\n\t                idx_neighbors = [idx-3, idx-2, idx-1]\n\t        assert pixels_coords_vu.ndim == 2\n\t        num_patches = pixels_coords_vu.shape[0]\n\t        extrin_ref = self.extrinsics_all[idx]\n\t        pts_ref = (extrin_ref[None,...] @ TrainingUtils.convert_to_homo(pts_world)[..., None]).squeeze()[:,:3]\n\t        normals_ref = (extrin_ref[:3,:3][None,...] @ normals_world[..., None]).squeeze()\n", "        patches_ref, idx_patch_pixels_ref, mask_idx_inside = PatchMatch.prepare_patches_src(img_ref, pixels_coords_vu, window_size, window_step)\n\t        scores_all_mean, diff_patch_all, count_valid_all = torch.zeros(num_patches, dtype=torch.float32), torch.zeros(num_patches, dtype=torch.float32), torch.zeros(num_patches, dtype=torch.uint8)\n\t        for idx_src in idx_neighbors:\n\t            img_src = self.images_gray[idx_src]\n\t            if reso_level > 1:\n\t                img_src = cv.resize(self.images_gray_np[idx_src], (int(W/reso_level), int(H/reso_level)), interpolation=cv.INTER_LINEAR)\n\t                img_src = torch.from_numpy(img_src).cuda()\n\t            extrin_src = self.extrinsics_all[idx_src]\n\t            homography = PatchMatch.compute_homography(pts_ref, normals_ref, K, extrin_ref, extrin_src)\n\t            idx_patch_pixels_src = PatchMatch.warp_patches(idx_patch_pixels_ref, homography)\n", "            patches_src = PatchMatch.sample_patches(img_src, idx_patch_pixels_src, sampling_mode = 'grid_sample')\n\t            scores_curr, diff_patch_mean_curr, mask_patches_valid_curr = PatchMatch.compute_NCC_score(patches_ref, patches_src)\n\t            # check occlusion\n\t            if self.check_occlusion:\n\t                mask_no_occlusion = scores_curr < 0.66\n\t                mask_patches_valid_curr = mask_patches_valid_curr & mask_no_occlusion\n\t                scores_curr[mask_no_occlusion==False] = 0.0\n\t                diff_patch_mean_curr[mask_no_occlusion==False] = 0.0\n\t            scores_all_mean += scores_curr\n\t            diff_patch_all += diff_patch_mean_curr\n", "            count_valid_all += mask_patches_valid_curr\n\t            if _debug:\n\t                corords_src = idx_patch_pixels_src[:,3,3].cpu().numpy().astype(int)\n\t                img_sample_ref = PatchMatch.visualize_sampled_pixels(self.images[idx].numpy()*255, pixels_coords_vu.cpu().numpy())\n\t                img_sample_src = PatchMatch.visualize_sampled_pixels(self.images[idx_src].numpy()*255, corords_src)\n\t                ImageUtils.write_image_lis(f'./test/ncc/{idx}_{idx_src}.png', [img_sample_ref, img_sample_src])\n\t                # save patches\n\t                ImageUtils.write_image_lis(f'./test/ncc/patches_{idx}.png',[ patches_ref[i].cpu().numpy() for i in range(len(patches_ref))], interval_img = 5 )\n\t                ImageUtils.write_image_lis(f'./test/ncc/patches_{idx_src}.png',[ patches_ref[i].cpu().numpy() for i in range(len(patches_src))], interval_img = 5 )\n\t        # get the average scores of all neighbor views\n", "        mask_valid_all = count_valid_all>=self.min_neighbors_ncc\n\t        scores_all_mean[mask_valid_all] /= count_valid_all[mask_valid_all]\n\t        diff_patch_all[mask_valid_all]  /= count_valid_all[mask_valid_all]\n\t        # set unvalid scores and diffs to zero\n\t        scores_all_mean = scores_all_mean*mask_valid_all\n\t        diff_patch_all  = diff_patch_all*mask_valid_all\n\t        scores_all_mean[mask_valid_all==False] = 1.0 # average scores for pixels without patch.\n\t        return scores_all_mean, diff_patch_all, mask_valid_all\n"]}
{"filename": "models/nerf_renderer.py", "chunked_list": ["import torch\n\timport torch.nn as nn\n\timport torch.nn.functional as F\n\timport numpy as np\n\timport logging\n\timport mcubes\n\timport trimesh\n\tfrom icecream import ic\n\tdef extract_fields(bound_min, bound_max, resolution, query_func):\n\t    N = 64\n", "    X = torch.linspace(bound_min[0], bound_max[0], resolution).split(N)\n\t    Y = torch.linspace(bound_min[1], bound_max[1], resolution).split(N)\n\t    Z = torch.linspace(bound_min[2], bound_max[2], resolution).split(N)\n\t    u = np.zeros([resolution, resolution, resolution], dtype=np.float32)\n\t    with torch.no_grad():\n\t        for xi, xs in enumerate(X):\n\t            for yi, ys in enumerate(Y):\n\t                for zi, zs in enumerate(Z):\n\t                    xx, yy, zz = torch.meshgrid(xs, ys, zs)\n\t                    pts = torch.cat([xx.reshape(-1, 1), yy.reshape(-1, 1), zz.reshape(-1, 1)], dim=-1)\n", "                    val = query_func(pts).reshape(len(xs), len(ys), len(zs)).detach().cpu().numpy()\n\t                    u[xi * N: xi * N + len(xs), yi * N: yi * N + len(ys), zi * N: zi * N + len(zs)] = val\n\t    return u\n\tdef extract_geometry(bound_min, bound_max, resolution, threshold, query_func):\n\t    logging.info('threshold: {}'.format(threshold))\n\t    u = extract_fields(bound_min, bound_max, resolution, query_func)\n\t    vertices, triangles = mcubes.marching_cubes(u, threshold)\n\t    b_max_np = bound_max.detach().cpu().numpy()\n\t    b_min_np = bound_min.detach().cpu().numpy()\n\t    vertices = vertices / (resolution - 1.0) * (b_max_np - b_min_np)[None, :] + b_min_np[None, :]\n", "    return vertices, triangles, u\n\tdef sample_pdf(bins, weights, n_samples, det=False):\n\t    # This implementation is from NeRF\n\t    # Get pdf\n\t    weights = weights + 1e-5  # prevent nans\n\t    pdf = weights / torch.sum(weights, -1, keepdim=True)\n\t    cdf = torch.cumsum(pdf, -1)\n\t    cdf = torch.cat([torch.zeros_like(cdf[..., :1]), cdf], -1)\n\t    # Take uniform samples\n\t    if det:\n", "        u = torch.linspace(0. + 0.5 / n_samples, 1. - 0.5 / n_samples, steps=n_samples)\n\t        u = u.expand(list(cdf.shape[:-1]) + [n_samples])\n\t    else:\n\t        u = torch.rand(list(cdf.shape[:-1]) + [n_samples])\n\t    # Invert CDF\n\t    u = u.contiguous()\n\t    # inds = searchsorted(cdf, u, side='right')\n\t    inds = torch.searchsorted(cdf, u, right=True)\n\t    below = torch.max(torch.zeros_like(inds - 1), inds - 1)\n\t    above = torch.min((cdf.shape[-1] - 1) * torch.ones_like(inds), inds)\n", "    inds_g = torch.stack([below, above], -1)  # (batch, N_samples, 2)\n\t    matched_shape = [inds_g.shape[0], inds_g.shape[1], cdf.shape[-1]]\n\t    cdf_g = torch.gather(cdf.unsqueeze(1).expand(matched_shape), 2, inds_g)\n\t    bins_g = torch.gather(bins.unsqueeze(1).expand(matched_shape), 2, inds_g)\n\t    denom = (cdf_g[..., 1] - cdf_g[..., 0])\n\t    denom = torch.where(denom < 1e-5, torch.ones_like(denom), denom)\n\t    t = (u - cdf_g[..., 0]) / denom\n\t    samples = bins_g[..., 0] + t * (bins_g[..., 1] - bins_g[..., 0])\n\t    return samples\n\tclass NeRFRenderer:\n", "    def __init__(self,\n\t                 nerf_coarse,\n\t                 nerf_fine,\n\t                 nerf_outside,\n\t                 n_samples,\n\t                 n_importance,\n\t                 n_outside,\n\t                 perturb):\n\t        self.nerf_coarse = nerf_coarse\n\t        self.nerf_fine = nerf_fine\n", "        self.nerf_outside = nerf_outside\n\t        self.n_samples = n_samples\n\t        self.n_importance = n_importance\n\t        self.n_outside = n_outside\n\t        self.perturb = perturb\n\t    def render_core_outside(self, rays_o, rays_d, z_vals, sample_dist, nerf, background_rgb=None):\n\t        \"\"\"\n\t        Render background\n\t        \"\"\"\n\t        batch_size, n_samples = z_vals.shape\n", "        # Section length\n\t        dists = z_vals[..., 1:] - z_vals[..., :-1]\n\t        dists = torch.cat([dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        mid_z_vals = z_vals + dists * 0.5\n\t        # Section midpoints\n\t        pts = rays_o[:, None, :] + rays_d[:, None, :] * mid_z_vals[..., :, None]  # batch_size, n_samples, 3\n\t        dis_to_center = torch.linalg.norm(pts, ord=2, dim=-1, keepdim=True).clip(1.0, 1e10)\n\t        pts = torch.cat([pts / dis_to_center, 1.0 / dis_to_center], dim=-1)       # batch_size, n_samples, 4\n\t        dirs = rays_d[:, None, :].expand(batch_size, n_samples, 3)\n\t        pts = pts.reshape(-1, 3 + int(self.n_outside > 0))\n", "        dirs = dirs.reshape(-1, 3)\n\t        density, sampled_color = nerf(pts, dirs)\n\t        alpha = 1.0 - torch.exp(-F.softplus(density.reshape(batch_size, n_samples)) * dists)\n\t        alpha = alpha.reshape(batch_size, n_samples)\n\t        weights = alpha * torch.cumprod(torch.cat([torch.ones([batch_size, 1]), 1. - alpha + 1e-7], -1), -1)[:, :-1]\n\t        sampled_color = sampled_color.reshape(batch_size, n_samples, 3)\n\t        color = (weights[:, :, None] * sampled_color).sum(dim=1)\n\t        if background_rgb is not None:\n\t            color = color + background_rgb * (1.0 - weights.sum(dim=-1, keepdim=True))\n\t        return {\n", "            'color': color,\n\t            'sampled_color': sampled_color,\n\t            'alpha': alpha,\n\t            'weights': weights,\n\t        }\n\t    def render_core(self,\n\t                    rays_o,\n\t                    rays_d,\n\t                    z_vals,\n\t                    sample_dist,\n", "                    nerf,\n\t                    background_alpha=None,\n\t                    background_sampled_color=None,\n\t                    background_rgb=None):\n\t        batch_size, n_samples = z_vals.shape\n\t        # Section length\n\t        dists = z_vals[..., 1:] - z_vals[..., :-1]\n\t        dists = torch.cat([dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        mid_z_vals = z_vals + dists * 0.5\n\t        # Section midpoints\n", "        pts = rays_o[:, None, :] + rays_d[:, None, :] * mid_z_vals[..., :, None]  # n_rays, n_samples, 3\n\t        dirs = rays_d[:, None, :].expand(pts.shape)\n\t        pts = pts.reshape(-1, 3)\n\t        dirs = dirs.reshape(-1, 3)\n\t        density, sampled_color = nerf(pts, dirs)\n\t        alpha = 1.0 - torch.exp(-F.relu(density.reshape(batch_size, n_samples) + 1.0) * dists)   # plus 1.0 for better convergence\n\t        alpha = alpha.reshape(batch_size, n_samples)\n\t        sampled_color = sampled_color.reshape(batch_size, n_samples, 3)\n\t        pts_norm = torch.linalg.norm(pts, ord=2, dim=-1, keepdim=True).reshape(batch_size, n_samples)\n\t        inside_sphere = (pts_norm < 1.0).float().detach()\n", "        # Render with background\n\t        if background_alpha is not None:\n\t            alpha = alpha * inside_sphere + background_alpha[:, :n_samples] * (1.0 - inside_sphere)\n\t            alpha = torch.cat([alpha, background_alpha[:, n_samples:]], dim=-1)\n\t            sampled_color = sampled_color * inside_sphere[:, :, None] +\\\n\t                            background_sampled_color[:, :n_samples] * (1.0 - inside_sphere)[:, :, None]\n\t            sampled_color = torch.cat([sampled_color, background_sampled_color[:, n_samples:]], dim=1)\n\t        weights = alpha * torch.cumprod(torch.cat([torch.ones([batch_size, 1]), 1. - alpha + 1e-7], -1), -1)[:, :-1]\n\t        weights_sum = weights.sum(dim=-1, keepdim=True)\n\t        color = (sampled_color * weights[:, :, None]).sum(dim=1)\n", "        if background_rgb is not None:    # Fixed background, usually black\n\t            color = color + background_rgb * (1.0 - weights_sum)\n\t        return {\n\t            'color': color,\n\t            'dists': dists,\n\t            'mid_z_vals': mid_z_vals,\n\t            'weights': weights,\n\t            'inside_sphere': inside_sphere\n\t        }\n\t    def render(self, rays_o, rays_d, near, far, perturb_overwrite=-1, background_rgb=None):\n", "        batch_size = len(rays_o)\n\t        sample_dist = 2.0 / self.n_samples   # Assuming the region of interest is a unit sphere\n\t        z_vals = torch.linspace(0.0, 1.0, self.n_samples)\n\t        z_vals = near + (far - near) * z_vals[None, :]\n\t        z_vals_outside = None\n\t        if self.n_outside > 0:\n\t            z_vals_outside = torch.linspace(1e-3, 1.0 - 1.0 / (self.n_outside + 1.0), self.n_outside)\n\t        n_samples = self.n_samples\n\t        perturb = self.perturb\n\t        if perturb_overwrite >= 0:\n", "            perturb = perturb_overwrite\n\t        if perturb > 0:\n\t            t_rand = (torch.rand([batch_size, 1]) - 0.5)\n\t            z_vals = z_vals + t_rand * 2.0 / self.n_samples\n\t            if self.n_outside > 0:\n\t                mids = .5 * (z_vals_outside[..., 1:] + z_vals_outside[..., :-1])\n\t                upper = torch.cat([mids, z_vals_outside[..., -1:]], -1)\n\t                lower = torch.cat([z_vals_outside[..., :1], mids], -1)\n\t                # stratified samples in those intervals\n\t                t_rand = torch.rand([batch_size, z_vals_outside.shape[-1]])\n", "                z_vals_outside = lower[None, :] + (upper - lower)[None, :] * t_rand\n\t        if self.n_outside > 0:\n\t            z_vals_outside = far / torch.flip(z_vals_outside, dims=[-1]) + 1.0 / self.n_samples\n\t        background_alpha = None\n\t        background_sampled_color = None\n\t        # Background model\n\t        if self.n_outside > 0:\n\t            z_vals_feed = torch.cat([z_vals, z_vals_outside], dim=-1)\n\t            z_vals_feed, _ = torch.sort(z_vals_feed, dim=-1)\n\t            ret_outside = self.render_core_outside(rays_o, rays_d, z_vals_feed, sample_dist, self.nerf_outside)\n", "            background_sampled_color = ret_outside['sampled_color']\n\t            background_alpha = ret_outside['alpha']\n\t        # Up sample\n\t        ret_coarse = self.render_core(rays_o,\n\t                                      rays_d,\n\t                                      z_vals,\n\t                                      sample_dist,\n\t                                      self.nerf_coarse,\n\t                                      background_rgb=background_rgb,\n\t                                      background_alpha=background_alpha,\n", "                                      background_sampled_color=background_sampled_color)\n\t        weights_coarse = ret_coarse['weights']\n\t        z_vals_up_sample = sample_pdf(z_vals,\n\t                                      weights_coarse[:, :self.n_samples - 1] * ret_coarse['inside_sphere'][:, :self.n_samples - 1],\n\t                                      self.n_importance, det=True)\n\t        z_vals_up_sample = z_vals_up_sample.detach()\n\t        z_vals_fine = torch.cat([z_vals, z_vals_up_sample], dim=-1)\n\t        z_vals_fine, _ = torch.sort(z_vals_fine, dim=-1)\n\t        # Background model\n\t        if self.n_outside > 0:\n", "            z_vals_feed_fine = torch.cat([z_vals_fine, z_vals_outside], dim=-1)\n\t            z_vals_feed_fine, _ = torch.sort(z_vals_feed_fine, dim=-1)\n\t            ret_outside = self.render_core_outside(rays_o, rays_d, z_vals_feed_fine, sample_dist, self.nerf_outside)\n\t            background_sampled_color = ret_outside['sampled_color']\n\t            background_alpha = ret_outside['alpha']\n\t        # Render core\n\t        ret_fine = self.render_core(rays_o,\n\t                                    rays_d,\n\t                                    z_vals_fine,\n\t                                    sample_dist,\n", "                                    self.nerf_fine,\n\t                                    background_rgb=background_rgb,\n\t                                    background_alpha=background_alpha,\n\t                                    background_sampled_color=background_sampled_color)\n\t        color_coarse = ret_coarse['color']\n\t        color_fine = ret_fine['color']\n\t        weights = ret_fine['weights']\n\t        weights_sum = weights.sum(dim=-1, keepdim=True)\n\t        return {\n\t            'color_coarse': color_coarse,\n", "            'color_fine': color_fine,\n\t            'weight_sum': weights_sum,\n\t            'weight_max': torch.max(weights, dim=-1, keepdim=True)[0],\n\t            'weights': weights,\n\t        }\n\t    def extract_geometry(self, bound_min, bound_max, resolution, threshold=50.0):\n\t        ret = extract_geometry(bound_min, bound_max, resolution, threshold, lambda pts: self.nerf_fine(pts, torch.zeros_like(pts))[0])\n\t        return ret\n"]}
{"filename": "models/fields.py", "chunked_list": ["import logging\n\timport torch\n\timport torch.nn as nn\n\timport torch.nn.functional as F\n\timport numpy as np\n\tfrom models.embedder import get_embedder, positional_encoding_c2f\n\tclass SDFNetwork(nn.Module):\n\t    def __init__(self,\n\t                 d_in,\n\t                 d_out,\n", "                 d_hidden,\n\t                 n_layers,\n\t                 skip_in=(4,),\n\t                 multires=0,\n\t                 bias=0.5,\n\t                 scale=1,\n\t                 geometric_init=True,\n\t                 weight_norm=True,\n\t                 activation='softplus',\n\t                 reverse_geoinit = False,\n", "                 use_emb_c2f = False,\n\t                 emb_c2f_start = 0.1,\n\t                 emb_c2f_end = 0.5):\n\t        super(SDFNetwork, self).__init__()\n\t        dims = [d_in] + [d_hidden for _ in range(n_layers)] + [d_out]\n\t        self.embed_fn_fine = None\n\t        self.multires = multires\n\t        if multires > 0:\n\t            embed_fn, input_ch = get_embedder(multires, input_dims=d_in, normalize=False)\n\t            self.embed_fn_fine = embed_fn\n", "            dims[0] = input_ch\n\t        logging.info(f'SDF input dimension: {dims[0]}')\n\t        self.num_layers = len(dims)\n\t        self.skip_in = skip_in\n\t        self.scale = scale\n\t        self.use_emb_c2f = use_emb_c2f\n\t        if self.use_emb_c2f:\n\t            self.emb_c2f_start = emb_c2f_start\n\t            self.emb_c2f_end = emb_c2f_end\n\t            logging.info(f\"Use coarse-to-fine embedding (Level: {self.multires}): [{self.emb_c2f_start}, {self.emb_c2f_end}]\")\n", "        self.alpha_ratio = 0.0\n\t        for l in range(0, self.num_layers - 1):\n\t            if l + 1 in self.skip_in:\n\t                out_dim = dims[l + 1] - dims[0]\n\t            else:\n\t                out_dim = dims[l + 1]\n\t            lin = nn.Linear(dims[l], out_dim)\n\t            if geometric_init:\n\t                if l == self.num_layers - 2:\n\t                    if reverse_geoinit:\n", "                        logging.info(f\"Geometry init: Indoor scene (reverse geometric init).\")\n\t                        torch.nn.init.normal_(lin.weight, mean=-np.sqrt(np.pi) / np.sqrt(dims[l]), std=0.0001)\n\t                        torch.nn.init.constant_(lin.bias, bias)\n\t                    else:\n\t                        logging.info(f\"Geometry init: DTU scene (not reverse geometric init).\")\n\t                        torch.nn.init.normal_(lin.weight, mean=np.sqrt(np.pi) / np.sqrt(dims[l]), std=0.0001)\n\t                        torch.nn.init.constant_(lin.bias, -bias)\n\t                elif multires > 0 and l == 0:\n\t                    torch.nn.init.constant_(lin.bias, 0.0)\n\t                    torch.nn.init.constant_(lin.weight[:, 3:], 0.0)\n", "                    torch.nn.init.normal_(lin.weight[:, :3], 0.0, np.sqrt(2) / np.sqrt(out_dim))\n\t                elif multires > 0 and l in self.skip_in:\n\t                    torch.nn.init.constant_(lin.bias, 0.0)\n\t                    torch.nn.init.normal_(lin.weight, 0.0, np.sqrt(2) / np.sqrt(out_dim))\n\t                    torch.nn.init.constant_(lin.weight[:, -(dims[0] - 3):], 0.0)\n\t                else:\n\t                    torch.nn.init.constant_(lin.bias, 0.0)\n\t                    torch.nn.init.normal_(lin.weight, 0.0, np.sqrt(2) / np.sqrt(out_dim))\n\t            if weight_norm:\n\t                lin = nn.utils.weight_norm(lin)\n", "            setattr(self, \"lin\" + str(l), lin)\n\t        if activation == 'softplus':\n\t            self.activation = nn.Softplus(beta=100)\n\t        else:\n\t            assert activation == 'relu'\n\t            self.activation = nn.ReLU()\n\t        self.weigth_emb_c2f = None\n\t        self.iter_step = 0\n\t        self.end_iter = 3e5\n\t    def forward(self, inputs):\n", "        inputs = inputs * self.scale\n\t        if self.use_emb_c2f and self.multires > 0:\n\t            inputs, weigth_emb_c2f = positional_encoding_c2f(inputs, self.multires, emb_c2f=[self.emb_c2f_start, self.emb_c2f_end], alpha_ratio = (self.iter_step / self.end_iter))\n\t            self.weigth_emb_c2f = weigth_emb_c2f\n\t        elif self.embed_fn_fine is not None:\n\t            inputs = self.embed_fn_fine(inputs)\n\t        else:\n\t            NotImplementedError\n\t        x = inputs\n\t        for l in range(0, self.num_layers - 1):\n", "            lin = getattr(self, \"lin\" + str(l))\n\t            if l in self.skip_in:\n\t                x = torch.cat([x, inputs], 1) / np.sqrt(2)\n\t            x = lin(x)\n\t            if l < self.num_layers - 2:\n\t                x = self.activation(x)\n\t        return torch.cat([x[:, :1] / self.scale, x[:, 1:]], dim=-1)\n\t    def sdf(self, x):\n\t        return self.forward(x)[:, :1]\n\t    def sdf_hidden_appearance(self, x):\n", "        return self.forward(x)\n\t    def gradient(self, x):\n\t        x.requires_grad_(True)\n\t        y = self.sdf(x)\n\t        d_output = torch.ones_like(y, requires_grad=False, device=y.device)\n\t        gradients = torch.autograd.grad(\n\t            outputs=y,\n\t            inputs=x,\n\t            grad_outputs=d_output,\n\t            create_graph=True,\n", "            retain_graph=True,\n\t            only_inputs=True)[0]\n\t        return gradients.unsqueeze(1)\n\tclass FixVarianceNetwork(nn.Module):\n\t    def __init__(self, base):\n\t        super(FixVarianceNetwork, self).__init__()\n\t        self.base = base\n\t        self.iter_step = 0\n\t    def set_iter_step(self, iter_step):\n\t        self.iter_step = iter_step\n", "    def forward(self, x):\n\t        return torch.ones([len(x), 1]) * np.exp(-self.iter_step / self.base)\n\tclass SingleVarianceNetwork(nn.Module):\n\t    def __init__(self, init_val=1.0, use_fixed_variance = False):\n\t        super(SingleVarianceNetwork, self).__init__()\n\t        if use_fixed_variance:\n\t            logging.info(f'Use fixed variance: {init_val}')\n\t            self.variance = torch.tensor([init_val])\n\t        else:\n\t            self.register_parameter('variance', nn.Parameter(torch.tensor(init_val)))\n", "    def forward(self, x):\n\t        return torch.ones([len(x), 1]) * torch.exp(self.variance * 10.0)\n\tclass RenderingNetwork(nn.Module):\n\t    def __init__(\n\t            self,\n\t            d_feature,\n\t            mode,\n\t            d_in,\n\t            d_out,\n\t            d_hidden,\n", "            n_layers,\n\t            weight_norm=True,\n\t            multires_view=0,\n\t            squeeze_out=True,\n\t    ):\n\t        super().__init__()\n\t        self.mode = mode\n\t        self.squeeze_out = squeeze_out\n\t        dims = [d_in + d_feature] + [d_hidden for _ in range(n_layers)] + [d_out]\n\t        self.embedview_fn = None\n", "        if multires_view > 0:\n\t            embedview_fn, input_ch = get_embedder(multires_view)\n\t            self.embedview_fn = embedview_fn\n\t            dims[0] += (input_ch - 3)\n\t        self.num_layers = len(dims)\n\t        for l in range(0, self.num_layers - 1):\n\t            out_dim = dims[l + 1]\n\t            lin = nn.Linear(dims[l], out_dim)\n\t            if weight_norm:\n\t                lin = nn.utils.weight_norm(lin)\n", "            setattr(self, \"lin\" + str(l), lin)\n\t        self.relu = nn.ReLU()\n\t    def forward(self, points, normals, view_dirs, feature_vectors):\n\t        if self.embedview_fn is not None:\n\t            view_dirs = self.embedview_fn(view_dirs)\n\t        rendering_input = None\n\t        if self.mode == 'idr':\n\t            rendering_input = torch.cat([points, view_dirs, normals, feature_vectors], dim=-1)\n\t        elif self.mode == 'no_view_dir':\n\t            rendering_input = torch.cat([points, normals, feature_vectors], dim=-1)\n", "        elif self.mode == 'no_normal':\n\t            rendering_input = torch.cat([points, view_dirs, feature_vectors], dim=-1)\n\t        x = rendering_input\n\t        for l in range(0, self.num_layers - 1):\n\t            lin = getattr(self, \"lin\" + str(l))\n\t            x = lin(x)\n\t            if l < self.num_layers - 2:\n\t                x = self.relu(x)\n\t        if self.squeeze_out:\n\t            x = torch.sigmoid(x)\n", "        return x\n\t# Code from nerf-pytorch\n\tclass NeRF(nn.Module):\n\t    def __init__(self, D=8, W=256, d_in=3, d_in_view=3, multires=0, multires_view=0, output_ch=4, skips=[4], use_viewdirs=False):\n\t        \"\"\"\n\t        \"\"\"\n\t        super(NeRF, self).__init__()\n\t        self.D = D\n\t        self.W = W\n\t        self.d_in = d_in\n", "        self.d_in_view = d_in_view\n\t        self.input_ch = 3\n\t        self.input_ch_view = 3\n\t        self.embed_fn = None\n\t        self.embed_fn_view = None\n\t        if multires > 0:\n\t            embed_fn, input_ch = get_embedder(multires, input_dims=d_in, normalize=False)\n\t            self.embed_fn = embed_fn\n\t            self.input_ch = input_ch\n\t        if multires_view > 0:\n", "            embed_fn_view, input_ch_view = get_embedder(multires_view, input_dims=d_in_view, normalize=False)\n\t            self.embed_fn_view = embed_fn_view\n\t            self.input_ch_view = input_ch_view\n\t        self.skips = skips\n\t        self.use_viewdirs = use_viewdirs\n\t        self.pts_linears = nn.ModuleList(\n\t            [nn.Linear(self.input_ch, W)] + [nn.Linear(W, W) if i not in self.skips else nn.Linear(W + self.input_ch, W) for i in\n\t                                        range(D - 1)])\n\t        ### Implementation according to the official code release (https://github.com/bmild/nerf/blob/master/run_nerf_helpers.py#L104-L105)\n\t        self.views_linears = nn.ModuleList([nn.Linear(self.input_ch_view + W, W // 2)])\n", "        ### Implementation according to the paper\n\t        # self.views_linears = nn.ModuleList(\n\t        #     [nn.Linear(input_ch_views + W, W//2)] + [nn.Linear(W//2, W//2) for i in range(D//2)])\n\t        if use_viewdirs:\n\t            self.feature_linear = nn.Linear(W, W)\n\t            self.alpha_linear = nn.Linear(W, 1)\n\t            self.rgb_linear = nn.Linear(W // 2, 3)\n\t        else:\n\t            self.output_linear = nn.Linear(W, output_ch)\n\t    def forward(self, input_pts, input_views):\n", "        if self.embed_fn is not None:\n\t            input_pts = self.embed_fn(input_pts)\n\t        if self.embed_fn_view is not None:\n\t            input_views = self.embed_fn_view(input_views)\n\t        h = input_pts\n\t        for i, l in enumerate(self.pts_linears):\n\t            h = self.pts_linears[i](h)\n\t            h = F.relu(h)\n\t            if i in self.skips:\n\t                h = torch.cat([input_pts, h], -1)\n", "        if self.use_viewdirs:\n\t            alpha = self.alpha_linear(h)\n\t            feature = self.feature_linear(h)\n\t            h = torch.cat([feature, input_views], -1)\n\t            for i, l in enumerate(self.views_linears):\n\t                h = self.views_linears[i](h)\n\t                h = F.relu(h)\n\t            rgb = self.rgb_linear(h)\n\t            return alpha + 1.0, rgb\n\t        else:\n", "            assert False\n"]}
{"filename": "models/patch_match_cuda.py", "chunked_list": ["import cv2, logging, copy, os\n\timport numpy as np\n\timport matplotlib.pyplot as plt\n\tfrom tqdm import tqdm\n\timport torch\n\timport utils.utils_io as IOUtils\n\timport torch.nn.functional as F\n\tdef prepare_patches_src(img_gray, indices_pixel, window_size=11, window_step=2):\n\t    '''\n\t    Args:\n", "        img: H*W, gray image\n\t        indices_pixel: N*2\n\t        size_window: int, patch size\n\t        size_step: int, interval sampling\n\t    Return:\n\t        rgb_pathes: N*M*M, gray values of images\n\t    '''\n\t    assert img_gray.dtype == torch.float32\n\t    size_img = img_gray.shape[:2][::-1]\n\t    # get kernel indices of a patch\n", "    window_size+=1\n\t    x = torch.arange(-(window_size//2), window_size//2 + 1, window_step) # weired -1//2=-1\n\t    xv, yv = torch.meshgrid(x,x)\n\t    kernel_patch = torch.stack([xv,yv], axis=-1) # M*M*2 \n\t    # print(kernel_patch)\n\t    num_pixels = len(indices_pixel)\n\t    indices_pixel = indices_pixel.to(kernel_patch.device)\n\t    kernel_patch = kernel_patch.to(indices_pixel.device)\n\t    indices_patch = indices_pixel.reshape(num_pixels,1,1,2) + kernel_patch\n\t    # sample img\n", "    mask_indices_inside = is_inside_border(indices_patch.reshape(-1,2), size_img).reshape(indices_patch.shape[:3]) # N*M*M\n\t    indices_patch_inside = (indices_patch * mask_indices_inside[...,None]).reshape(-1,2)   # N*2. let the indices of outside pixels be zero\n\t    if img_gray.ndim ==2:\n\t        rgb_patches = img_gray[indices_patch_inside[:, 0], indices_patch_inside[:, 1]].reshape(indices_patch.shape[:3]) # N*M*M\n\t    elif img_gray.ndim ==3:\n\t        rgb_patches = img_gray[indices_patch_inside[:, 0], indices_patch_inside[:, 1]].reshape(indices_patch.shape[:3] + tuple([3])) # N*M*M\n\t    else:\n\t        raise NotImplementedError\n\t    rgb_patches[mask_indices_inside==False] = -1\n\t    return rgb_patches.cuda(), indices_patch, mask_indices_inside\n", "def normalize_coords_vu(idx_vu, shape_img):\n\t    '''Normalize coords to interval [-1, 1]\n\t    Args:\n\t        idx_vu: shape [..., 2]\n\t    '''\n\t    assert idx_vu.dtype == torch.float32\n\t    H, W = shape_img\n\t    idx_vu_norm = idx_vu.clone().detach()\n\t    temp = 2 * idx_vu[...,0]  / (H - 1) - 1\n\t    # convert vu to xy\n", "    idx_vu_norm[..., 1] = 2 * idx_vu[...,0]  / (H - 1) - 1\n\t    idx_vu_norm[..., 0] = 2 * idx_vu[...,1]  / (W - 1) - 1\n\t    return idx_vu_norm\n\tdef sample_patches(img, idx_patches_input, sampling_mode = 'nearest'): \n\t    '''\n\t    Args:\n\t        img: W*H or W*H*3\n\t        idx_patches_warp: N*M*M*2, warped indices\n\t    Return:\n\t        rgb_patches: N*M*M, sampled pixels\n", "    '''\n\t    # sample img\n\t    size_img = img.shape[:2][::-1]\n\t    shape_patches = idx_patches_input.shape\n\t    # TODO: Add inter-linear interploation of sampling\n\t    if idx_patches_input.dtype not in [torch.int, torch.int16, torch.int32, torch.int64]:\n\t        idx_patches_input_round = torch.round(idx_patches_input).long()\n\t        idx_patches = idx_patches_input_round\n\t    else:\n\t        # logging.info(f'Grid sampling')\n", "        idx_patches = idx_patches_input\n\t        sampling_mode = 'nearest'\n\t    mask_indices_inside = is_inside_border(idx_patches.reshape(-1,2), size_img).reshape(idx_patches.shape[:-1]) # N*M*M\n\t    indices_patch_inside = (idx_patches * mask_indices_inside[...,None]).reshape(-1,2)   # N*2. let the indices of outside pixels be zero\n\t    # grid sampling\n\t    if sampling_mode == 'grid_sample':\n\t        assert img.ndim == 2  # 1*1*H*W\n\t        idx_patches_input_norm = normalize_coords_vu(idx_patches_input, img.shape).clip(-1,1)\n\t        rgb_patches = F.grid_sample(img[None, None,:,:], idx_patches_input_norm.reshape(1,1,-1,2), align_corners=False).squeeze()\n\t        rgb_patches = rgb_patches.reshape(shape_patches[:3])\n", "    elif sampling_mode == 'nearest':\n\t        if img.ndim ==2:\n\t            rgb_patches = img[indices_patch_inside[:, 0], indices_patch_inside[:, 1]].reshape(idx_patches.shape[:-1]) # N*M*M\n\t        elif img.ndim ==3:\n\t            rgb_patches = img[indices_patch_inside[:, 0], indices_patch_inside[:, 1]].reshape(idx_patches.shape[:-1] + tuple([3])) # N*M*M\n\t        else:\n\t            raise NotImplementedError\n\t    rgb_patches[mask_indices_inside==False] = -1\n\t    return rgb_patches\n\tdef is_inside_border(ind_pixels, size_img):\n", "    '''\n\t    Args:\n\t        ind_pixel: N*2\n\t        size_img: (W,H)\n\t    Return:\n\t        mask: N*1, bool\n\t    '''\n\t    assert (ind_pixels.ndim ==2 & ind_pixels.shape[1] ==2)\n\t    W, H = size_img\n\t    return (ind_pixels[:, 0] >= 0) & (ind_pixels[:,0] < H) & \\\n", "           (ind_pixels[:, 1] >= 0) & (ind_pixels[:,1] < W)\n\tdef compute_NCC_score(patches_ref, patches_src):\n\t    '''\n\t    Args:\n\t        pathces_ref: N*M*M\n\t        patches_src: N*M*M\n\t    Return:\n\t        score: float\n\t    '''\n\t    num_patches = patches_ref.shape[0]\n", "    size_patch = (patches_ref.shape[1] * patches_ref.shape[2])\n\t    # ensure pixels inside border\n\t    mask_inside_ref, mask_inside_src = patches_ref >= 0, patches_src >= 0\n\t    mask_inside = mask_inside_ref & mask_inside_src # different for diffenert neighbors\n\t    # ensure half patch inside border\n\t    mask_patches_valid = (mask_inside.reshape(num_patches, -1).sum(axis=-1) == size_patch)[...,None,None]\n\t    mask_inside = mask_inside & mask_patches_valid\n\t    # logging.info(f'Pixels inside ref and src: {mask_inside.sum()}/{mask_inside.size}; Ref: {mask_inside_ref.sum()}/{mask_inside_ref.size}; Src: {mask_inside_src.sum()}/{mask_inside_src.size}')\n\t    calculate_patches_mean = lambda patches, mask: (patches*mask).reshape(patches.shape[0], -1).sum(axis=1) / (mask.reshape(patches.shape[0], -1).sum(axis=1)+1e-6)\n\t    mean_patches_ref = calculate_patches_mean(patches_ref, mask_inside).reshape(-1,1,1)\n", "    mean_patches_src = calculate_patches_mean(patches_src, mask_inside).reshape(-1,1,1)\n\t    normalized_patches_ref = patches_ref - mean_patches_ref\n\t    normalized_patches_src = patches_src - mean_patches_src\n\t    norm = ((normalized_patches_ref * normalized_patches_src)*mask_inside).reshape(num_patches,-1).sum(axis=-1)\n\t    denom = torch.sqrt( \n\t                (torch.square(normalized_patches_ref)*mask_inside).reshape(num_patches,-1).sum(axis=-1) * \\\n\t                (torch.square(normalized_patches_src)*mask_inside).reshape(num_patches,-1).sum(axis=-1)\n\t            )\n\t    norm = norm.clip(10, 1e6)\n\t    ncc = (norm + 20) / (denom+1e-3)\n", "    if (denom == 0).sum() > 0:\n\t        # check quadratic moments to avoid degeneration.\n\t        # pathes with same values \n\t        # [Nonlinear systems], https://en.wikipedia.org/wiki/Cross-correlation\n\t        mask_degenerade = ( denom == 0)\n\t        ncc[denom == 0] = 1.0\n\t        # logging.info(f'Deneraded patches: {mask_degenerade.sum()}/{mask_degenerade.size}.')  # pixels with invalid patchmatch\n\t    score = 1-ncc.clip(-1.0,1.0) # 0->2: smaller, better\n\t    diff_mean = torch.abs(mean_patches_ref - mean_patches_src).squeeze()\n\t    return score, diff_mean, mask_patches_valid.squeeze()\n", "def update_confmap(confmap, idx_pixels, ncc_score, idx_patches = None):\n\t    '''\n\t    Args:\n\t        confmap: H*W\n\t        idx_pixels: N*2, numpy array index\n\t        ncc_score: N*1,\n\t        idx_patches: None. (optional: N*M*M*2) \n\t    Return:\n\t        updated_confmap: H*W\n\t    '''\n", "    # ncc_score = ncc_score[...,None, None]* np.ones_like(mask_inside_ref)\n\t    # indices_inside = indices_patch[mask_inside]\n\t    # score_inside = ncc_score[mask_inside]\n\t    confmap = copy.deepcopy(confmap)\n\t    prev_conf = confmap[idx_pixels[:,0], idx_pixels[:,1]]\n\t    confmap[idx_pixels[:,0], idx_pixels[:,1]] = ncc_score  # TODO: check duplicated values here\n\t    return confmap\n\tdef prepare_neigbor_pixels(img, indices_pixel):\n\t    '''Get 4 neighbor indices of given pixels\n\t    Args:\n", "        img: H*W, ndarray\n\t        indices_pixel: N*2\n\t    Return:\n\t        indices_neighbors: N*4*2\n\t    '''\n\t    raise NotImplementedError\n\tdef sample_pixels_by_probability(prob_pixels_all, batch_size, clip_range = (0.22, 0.66), shuffle = True):\n\t    '''Sample pixels based on NCC confidence. Sample more pixels on low confidence areas\n\t    Args:\n\t        scores_ncc: W*H, narray\n", "    Return:\n\t        uv_sample: 2*N\n\t    '''\n\t    # Guarantee that every pixels can be sampled\n\t    prob = prob_pixels_all.clip(*clip_range) \n\t    H,W = prob.shape\n\t    sample_range = W * H\n\t    prob = prob / prob.sum()\n\t    samples_indices = np.random.choice(sample_range, batch_size, p=prob.reshape(-1))\n\t    pixels_v = samples_indices // W\n", "    pixels_u = samples_indices % W\n\t    uv_sample = np.stack((pixels_u, pixels_v), axis=-1) #.transpose()\n\t    if shuffle:\n\t        # uv_sample = np.copy(uv_sample)\n\t        np.random.shuffle(uv_sample)\n\t    uv_sample = uv_sample.transpose()\n\t    return uv_sample\n\tdef visualize_sampled_pixels(img_input, indices_pixel, path = None):\n\t    '''\n\t    Two different format of coordinates:\n", "        (1) indices_pixel: in vu format\n\t        (2) uvs_pixel: in opencv format\n\t    Args:\n\t        indices_pixel: N*2\n\t    '''\n\t    img = copy.deepcopy(img_input)\n\t    for i in range(indices_pixel.shape[0]):\n\t        cv2.circle(img, (indices_pixel[i, 1], indices_pixel[i,0]), \n\t                        radius = 2, \n\t                        color = (255,0,0), # BGR\n", "                        thickness=2)  \n\t        cv2.putText(img, f'{i}',  (indices_pixel[i, 1] + 2 if indices_pixel[i, 1] + 2 < img.shape[1] else img.shape[1]-1, indices_pixel[i,0]), \n\t                        fontFace= cv2.FONT_HERSHEY_SIMPLEX, \n\t                        fontScale = 0.75, \n\t                        color = (0, 0, 255), \n\t                        thickness = 1) # int\n\t    if path is not None:\n\t        cv2.imwrite(path, img)\n\t    return img\n\tdef visualize_samples_lis(img_input, lis_samples_uv, path = None):\n", "    '''\n\t    Two different format of coordinates:\n\t        (1) indices_pixel: in numpy format\n\t        (2) uvs_pixel: in opencv format\n\t    Args:\n\t        lis_samples: M*N*2\n\t    '''\n\t    img = copy.deepcopy(img_input)\n\t    lis_colors = [(0,0,255), (255,0,0),(0,255,0)] # R, G, B, in cv color mode\n\t    assert len(lis_samples_uv) <= len(lis_colors)\n", "    for idx_samples in range(len(lis_samples_uv)):\n\t        samples_curr = lis_samples_uv[idx_samples]\n\t        for i in range(samples_curr.shape[0]):\n\t            cv2.circle(img, (samples_curr[i, 0], samples_curr[i,1]), \n\t                            radius = 2, \n\t                            color = lis_colors[idx_samples], # BGR\n\t                            thickness=2)  \n\t        #     cv2.putText(img, f'{i}',  (indices_pixel[i, 1] + 2 if indices_pixel[i, 1] + 2 < img.shape[1] else img.shape[1]-1, indices_pixel[i,0]), \n\t        #                     fontFace= cv2.FONT_HERSHEY_SIMPLEX, \n\t        #                     fontScale = 0.75, \n", "        #                     color = (0, 0, 255), \n\t        #                     thickness = 2) # int\n\t    if path is not None:\n\t        dir, _, _ = IOUtils.get_path_components(path)\n\t        IOUtils.ensure_dir_existence(dir)\n\t        cv2.imwrite(path, img)\n\t    return img\n\tdef save_patches(path, patches, interval = 2, color_mode = 'GRAY'):\n\t    num_patches, w_p, h_p = patches.shape[:3]\n\t    w_img = int( np.ceil(np.sqrt(num_patches)) * (w_p+interval) )\n", "    h_img = int( np.ceil(np.sqrt(num_patches)) * (h_p+ interval) )\n\t    img = np.zeros((h_img, w_img))\n\t    if patches.shape[-1] ==3:\n\t        img = np.zeros((h_img, w_img, 3))\n\t    patch_num_row = int(np.ceil(np.sqrt(num_patches)))\n\t    for i in range(patch_num_row):\n\t        for j in range(patch_num_row):\n\t            idx_patch = i*patch_num_row+j\n\t            if idx_patch >= num_patches:\n\t                continue\n", "            img[i*(w_p+interval):(i+1)*(w_p+interval)-interval,j*(h_p+interval):(j+1)*(h_p+interval)-interval] = patches[idx_patch]\n\t    cv2.imwrite(path, img)    \n\t    return img\n\tdef concatenate_images(img1, img2, path = None):\n\t    check_channel = lambda img : np.stack([img]*3, axis=-1) if img.ndim ==2 else img\n\t    img1 = check_channel(img1)\n\t    img2 = check_channel(img2)\n\t    img_cat = np.concatenate([img1, img2], axis=0)\n\t    if path is not None:\n\t        cv2.imwrite(path, img_cat)\n", "    return img_cat\n\tdef compute_homography(pt_ref, n_ref, K, extrin_ref, extrin_src):\n\t    '''Compute homography from reference view to source view.\n\t    Tranform from world to reference view coordinates.\n\t    Args:\n\t        n: N*3*1, reference view normal\n\t        pt: N*3*1, reference view coordinates of a point\n\t        K: 3*3, intrinsics\n\t        extrin_ref: N*4*4\n\t        extrin_src: N*4*4\n", "    Return:\n\t        mat_homography: N*3*3 \n\t    '''\n\t    # TODO: check this method later\n\t    if False:\n\t        def decompose_extrin(extrin):\n\t            rot = extrin[:3,:3]\n\t            trans = extrin[:3,3].reshape(3,1)\n\t            cam_center = - np.linalg.inv(rot) @ trans\n\t            return rot, cam_center\n", "        R_ref, C_ref = decompose_extrin(extrin_ref)\n\t        R_src, C_src = decompose_extrin(extrin_src)\n\t        # rt = R_ref.transpose()\n\t        Hl = K @ R_src @ R_ref.transpose()\n\t        Hm = K @ R_src @ (C_ref - C_src)\n\t        Hr = np.linalg.inv(K)\n\t        num_pts = len(pt)\n\t        denom = (n * pt).sum(axis=-1, keepdims=True)[0].reshape(1, 1,1)\n\t        mat_homography = ( Hl[None, ...] + Hm[None, ...] @ (n.reshape(num_pts, 1,3) / denom) ) *Hr[None, ...];\n\t    ref_pose = torch.linalg.inv(extrin_ref)\n", "    inv_src_pose = extrin_src\n\t    inv_ref_pose = extrin_ref\n\t    relative_proj = inv_src_pose @ ref_pose\n\t    R_rel = relative_proj[:3, :3]\n\t    t_rel = relative_proj[:3, 3:]\n\t    R_ref = inv_ref_pose[:3, :3]\n\t    t_ref = inv_ref_pose[:3, 3:]\n\t    num_pts = len(pt_ref)\n\t    d = (n_ref * pt_ref).sum(axis=-1, keepdims=True).reshape(num_pts, 1,1)\n\t    mat_homography = (K[None, ...] @ (R_rel[None, ...] + t_rel[None,...] @ n_ref.reshape(num_pts,1,3) / d))@torch.linalg.inv(K)\n", "    return mat_homography\n\tdef warp_patches(idx_patches_xy, homography):\n\t    '''Warp patches from reference image to source images\n\t    Args:\n\t        idx_patches: N*M*M*2, xy index coordinates (numpy array)\n\t        homography: N*3*3, from reference to source\n\t    Return:\n\t        idx_patches_warp: N*M*M*2, xy index coordinates (numpy array)\n\t    '''\n\t    shape = idx_patches_xy.shape\n", "    idx_patches = convert_xy_to_uv(idx_patches_xy)\n\t    idx_patches_homo = convert_to_homo(idx_patches)\n\t    num_patches, H_patch, W_patch = homography.shape\n\t    if idx_patches_xy.ndim == 2:    #N*2\n\t        idx_patches_warp = (homography @ idx_patches_homo[...,None]).squeeze() # N*3*1\n\t    elif idx_patches_xy.ndim == 4:  #N*M*M*2\n\t        idx_patches_warp = (homography.reshape(num_patches, 1, 1, H_patch, W_patch) @ idx_patches_homo[...,None]).squeeze() # N*M*M*3*1\n\t    else:\n\t        raise NotImplementedError\n\t    idx_patches_warp = (idx_patches_warp / idx_patches_warp[..., 2][...,None])[...,:2]\n", "    # TODO: update later fpr faster calculation. Refer to NeuralWarp\n\t    # einsum is 30 times faster\n\t    # tmp = (H.view(Nsrc, N, -1, 1, 3, 3) @ hom_uv.view(1, N, 1, -1, 3, 1)).squeeze(-1).view(Nsrc, -1, 3)\n\t    # tmp = torch.einsum(\"vprik,pok->vproi\", H, hom_uv).reshape(Nsrc, -1, 3)\n\t    # patches_warp = patches_warp / patches_warp[..., 2:].clip(min=1e-8)\n\t    # TODO: use the stragety of openMVS to simplify calculatoin. O(N*h^2)->O(H+h^2)\n\t    # homography_step = homography*window_step\n\t    # kernel_homography = \n\t    idx_patches_warp_xy = convert_uv_to_xy(idx_patches_warp)\n\t    return idx_patches_warp_xy\n", "def denoise_image(img):\n\t    b,g,r = cv2.split(img)           # get b,g,r\n\t    rgb_img = cv2.merge([r,g,b])     # switch it to rgb\n\t    # img = cv2.fastNlMeansDenoisingColored(img.astype(np.uint8),None,10,10,7,21)\n\t    # b,g,r = cv2.split(dst)           # get b,g,r\n\t    # rgb_dst = cv2.merge([r,g,b])     # switch it to rgb\n\t    return img\n\tdef convert_uv_to_xy(coord_uv):\n\t    '''\n\t    Args:\n", "        coord: N*2\n\t    '''\n\t    coord_xy = torch.stack([coord_uv[...,1], coord_uv[...,0]], axis=-1)\n\t    return coord_xy\n\tdef convert_xy_to_uv(coord_xy):\n\t    '''\n\t    Args:\n\t        coord: N*2\n\t    '''\n\t    coord_uv = torch.stack([coord_xy[...,1], coord_xy[...,0]], axis=-1)\n", "    return coord_uv\n\tdef convert_to_homo(pts):\n\t    device = torch.device(\"cuda:0\")\n\t    pts = pts.to(device)\n\t    pts_homo = torch.cat([pts, torch.ones(pts.shape[:-1] + tuple([1])) ], dim=-1)\n\t    return pts_homo\n"]}
{"filename": "models/renderer.py", "chunked_list": ["import torch\n\timport torch.nn.functional as F\n\timport numpy as np\n\timport mcubes\n\tdef extract_fields(bound_min, bound_max, resolution, query_func):\n\t    N = 64\n\t    X = torch.linspace(bound_min[0], bound_max[0], resolution).split(N)\n\t    Y = torch.linspace(bound_min[1], bound_max[1], resolution).split(N)\n\t    Z = torch.linspace(bound_min[2], bound_max[2], resolution).split(N)\n\t    u = np.zeros([resolution, resolution, resolution], dtype=np.float32)\n", "    with torch.no_grad():\n\t        for xi, xs in enumerate(X):\n\t            for yi, ys in enumerate(Y):\n\t                for zi, zs in enumerate(Z):\n\t                    xx, yy, zz = torch.meshgrid(xs, ys, zs)\n\t                    pts = torch.cat([xx.reshape(-1, 1), yy.reshape(-1, 1), zz.reshape(-1, 1)], dim=-1)\n\t                    val = query_func(pts).reshape(len(xs), len(ys), len(zs)).detach().cpu().numpy()\n\t                    u[xi * N: xi * N + len(xs), yi * N: yi * N + len(ys), zi * N: zi * N + len(zs)] = val\n\t    return u\n\tdef extract_geometry(bound_min, bound_max, resolution, threshold, query_func):\n", "    u = extract_fields(bound_min, bound_max, resolution, query_func)\n\t    vertices, triangles = mcubes.marching_cubes(u, threshold)\n\t    b_max_np = bound_max.detach().cpu().numpy()\n\t    b_min_np = bound_min.detach().cpu().numpy()\n\t    vertices = vertices / (resolution - 1.0) * (b_max_np - b_min_np)[None, :] + b_min_np[None, :]\n\t    return vertices, triangles, u\n\tdef sample_pdf(bins, weights, n_samples, det=False):\n\t    # This implementation is from NeRF\n\t    # Get pdf\n\t    weights = weights + 1e-5  # prevent nans\n", "    pdf = weights / torch.sum(weights, -1, keepdim=True)\n\t    cdf = torch.cumsum(pdf, -1)\n\t    cdf = torch.cat([torch.zeros_like(cdf[..., :1]), cdf], -1)\n\t    # Take uniform samples\n\t    if det:\n\t        u = torch.linspace(0. + 0.5 / n_samples, 1. - 0.5 / n_samples, steps=n_samples)\n\t        u = u.expand(list(cdf.shape[:-1]) + [n_samples])\n\t    else:\n\t        u = torch.rand(list(cdf.shape[:-1]) + [n_samples])\n\t    # Invert CDF\n", "    u = u.contiguous()\n\t    inds = torch.searchsorted(cdf, u, right=True)\n\t    below = torch.max(torch.zeros_like(inds - 1), inds - 1)\n\t    above = torch.min((cdf.shape[-1] - 1) * torch.ones_like(inds), inds)\n\t    inds_g = torch.stack([below, above], -1)  # (batch, N_samples, 2)\n\t    matched_shape = [inds_g.shape[0], inds_g.shape[1], cdf.shape[-1]]\n\t    cdf_g = torch.gather(cdf.unsqueeze(1).expand(matched_shape), 2, inds_g)\n\t    bins_g = torch.gather(bins.unsqueeze(1).expand(matched_shape), 2, inds_g)\n\t    denom = (cdf_g[..., 1] - cdf_g[..., 0])\n\t    denom = torch.where(denom < 1e-5, torch.ones_like(denom), denom)\n", "    t = (u - cdf_g[..., 0]) / denom\n\t    samples = bins_g[..., 0] + t * (bins_g[..., 1] - bins_g[..., 0])\n\t    return samples\n\tclass NeuSRenderer:\n\t    def __init__(self,\n\t                 nerf,\n\t                 sdf_network_fine,\n\t                 variance_network_fine,\n\t                 color_network_fine,\n\t                 n_samples,\n", "                 n_importance,\n\t                 n_outside,\n\t                 perturb,\n\t                 alpha_type='div'):\n\t        self.nerf = nerf\n\t        self.sdf_network_fine = sdf_network_fine\n\t        self.variance_network_fine = variance_network_fine\n\t        self.color_network_fine = color_network_fine\n\t        self.n_samples = n_samples\n\t        self.n_importance = n_importance\n", "        self.n_outside = n_outside\n\t        self.perturb = perturb\n\t        self.alpha_type = alpha_type\n\t        self.radius = 1.0\n\t    def render_core_outside(self, rays_o, rays_d, z_vals, sample_dist, nerf, background_rgb=None):\n\t        batch_size, n_samples = z_vals.shape\n\t        dists = z_vals[..., 1:] - z_vals[..., :-1]\n\t        dists = torch.cat([dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        mid_z_vals = z_vals + dists * 0.5\n\t        mid_dists = mid_z_vals[..., 1:] - mid_z_vals[..., :-1]\n", "        mid_dists = torch.cat([mid_dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        pts = rays_o[:, None, :] + rays_d[:, None, :] * mid_z_vals[..., :, None]  # batch_size, n_samples, 3\n\t        if self.n_outside > 0:\n\t            dis_to_center = torch.linalg.norm(pts, ord=2, dim=-1, keepdim=True).clip(1.0, 1e10)\n\t            pts = torch.cat([pts / dis_to_center, 1.0 / dis_to_center], dim=-1)       # batch_size, n_samples, 4\n\t        dirs = rays_d[:, None, :].expand(batch_size, n_samples, 3)\n\t        pts = pts.reshape(-1, 3 + int(self.n_outside > 0))\n\t        dirs = dirs.reshape(-1, 3)\n\t        density, sampled_color = nerf(pts, dirs)\n\t        alpha = 1.0 - torch.exp(-F.softplus(density.reshape(batch_size, n_samples)) * dists)\n", "        alpha = alpha.reshape(batch_size, n_samples)\n\t        weights = alpha * torch.cumprod(torch.cat([torch.ones([batch_size, 1]), 1. - alpha + 1e-7], -1), -1)[:, :-1]  # n_rays, n_samples\n\t        sampled_color = sampled_color.reshape(batch_size, n_samples, 3)\n\t        color = (weights[:, :, None] * sampled_color).sum(dim=1)\n\t        if background_rgb is not None:\n\t            color = color + background_rgb * (1.0 - weights.sum(dim=-1, keepdim=True))\n\t        return {\n\t            'color': color,\n\t            'sampled_color': sampled_color,\n\t            'alpha': alpha,\n", "            'weights': weights,\n\t        }\n\t    def up_sample(self, rays_o, rays_d, z_vals, sdf, n_importance, inv_variance):\n\t        batch_size, n_samples = z_vals.shape\n\t        pts = rays_o[:, None, :] + rays_d[:, None, :] * z_vals[..., :, None]  # n_rays, n_samples, 3\n\t        radius = torch.linalg.norm(pts, ord=2, dim=-1, keepdim=False)\n\t        inside_sphere = (radius[:, :-1] < 1.0) | (radius[:, 1:] < 1.0)\n\t        sdf = sdf.reshape(batch_size, n_samples)\n\t        prev_sdf, next_sdf = sdf[:, :-1], sdf[:, 1:]\n\t        prev_z_vals, next_z_vals = z_vals[:, :-1], z_vals[:, 1:]\n", "        mid_sdf = (prev_sdf + next_sdf) * 0.5\n\t        dot_val = None\n\t        if self.alpha_type == 'uniform':\n\t            dot_val = torch.ones([batch_size, n_samples - 1]) * -1.0\n\t        else:\n\t            dot_val = (next_sdf - prev_sdf) / (next_z_vals - prev_z_vals + 1e-5)\n\t            prev_dot_val = torch.cat([torch.zeros([batch_size, 1]), dot_val[:, :-1]], dim=-1)\n\t            dot_val = torch.stack([prev_dot_val, dot_val], dim=-1)\n\t            dot_val, _ = torch.min(dot_val, dim=-1, keepdim=False)\n\t            dot_val = dot_val.clip(-10.0, 0.0) * inside_sphere\n", "        dist = (next_z_vals - prev_z_vals)\n\t        prev_esti_sdf = mid_sdf - dot_val * dist * 0.5\n\t        next_esti_sdf = mid_sdf + dot_val * dist * 0.5\n\t        prev_cdf = torch.sigmoid(prev_esti_sdf * inv_variance)\n\t        next_cdf = torch.sigmoid(next_esti_sdf * inv_variance)\n\t        alpha = (prev_cdf - next_cdf + 1e-5) / (prev_cdf + 1e-5)\n\t        weights = alpha * torch.cumprod(\n\t            torch.cat([torch.ones([batch_size, 1]), 1. - alpha + 1e-7], -1), -1)[:, :-1]\n\t        z_samples = sample_pdf(z_vals, weights, n_importance, det=True).detach()\n\t        return z_samples\n", "    def cat_z_vals(self, rays_o, rays_d, z_vals, new_z_vals, sdf):\n\t        batch_size, n_samples = z_vals.shape\n\t        _, n_importance = new_z_vals.shape\n\t        pts = rays_o[:, None, :] + rays_d[:, None, :] * new_z_vals[..., :, None]\n\t        new_sdf = self.sdf_network_fine.sdf(pts.reshape(-1, 3)).reshape(batch_size, n_importance)\n\t        z_vals = torch.cat([z_vals, new_z_vals], dim=-1)\n\t        sdf = torch.cat([sdf, new_sdf], dim=-1)\n\t        z_vals, index = torch.sort(z_vals, dim=-1)\n\t        xx = torch.arange(batch_size)[:, None].expand(batch_size, n_samples + n_importance).reshape(-1)\n\t        index = index.reshape(-1)\n", "        sdf = sdf[(xx, index)].reshape(batch_size, n_samples + n_importance)\n\t        return z_vals, sdf\n\t    def render_core(self,\n\t                    rays_o,\n\t                    rays_d,\n\t                    z_vals,\n\t                    sample_dist,\n\t                    sdf_network,\n\t                    variance_network,\n\t                    color_network,\n", "                    background_alpha=None,\n\t                    background_sampled_color=None,\n\t                    background_rgb=None,\n\t                    alpha_inter_ratio=0.0):\n\t        logs_summary = {}\n\t        batch_size, n_samples = z_vals.shape\n\t        dists = z_vals[..., 1:] - z_vals[..., :-1]\n\t        dists = torch.cat([dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        mid_z_vals = z_vals + dists * 0.5\n\t        mid_dists = mid_z_vals[..., 1:] - mid_z_vals[..., :-1]\n", "        pts = rays_o[:, None, :] + rays_d[:, None, :] * mid_z_vals[..., :, None]  # n_rays, n_samples, 3\n\t        dirs = rays_d[:, None, :].expand(pts.shape)\n\t        pts = pts.reshape(-1, 3)\n\t        dirs = dirs.reshape(-1, 3)\n\t        sdf_nn_output = sdf_network(pts)\n\t        sdf = sdf_nn_output[:, :1]\n\t        feature_vector = sdf_nn_output[:, 1:]\n\t        gradients = sdf_network.gradient(pts).squeeze()\n\t        sampled_color = color_network(pts, gradients, dirs, feature_vector).reshape(batch_size, n_samples, 3)\n\t        inv_variance = variance_network(torch.zeros([1, 3]))[:, :1].clip(1e-6, 1e6)\n", "        inv_variance = inv_variance.expand(batch_size * n_samples, 1)\n\t        true_dot_val = (dirs * gradients).sum(-1, keepdim=True)\n\t        iter_cos = -(F.relu(-true_dot_val * 0.5 + 0.5) * (1.0 - alpha_inter_ratio) + F.relu(-true_dot_val) * alpha_inter_ratio) # always non-positive\n\t        true_estimate_sdf_half_next = sdf + iter_cos.clip(-10.0, 10.0) * dists.reshape(-1, 1) * 0.5\n\t        true_estimate_sdf_half_prev = sdf - iter_cos.clip(-10.0, 10.0) * dists.reshape(-1, 1) * 0.5\n\t        prev_cdf = torch.sigmoid(true_estimate_sdf_half_prev * inv_variance)\n\t        next_cdf = torch.sigmoid(true_estimate_sdf_half_next * inv_variance)\n\t        p = prev_cdf - next_cdf\n\t        c = prev_cdf\n\t        if self.alpha_type == 'div':\n", "            alpha = ((p + 1e-5) / (c + 1e-5)).reshape(batch_size, n_samples).clip(0.0, 1.0)\n\t        elif self.alpha_type == 'uniform':\n\t            uniform_estimate_sdf_half_next = sdf - dists.reshape(-1, 1) * 0.5\n\t            uniform_estimate_sdf_half_prev = sdf + dists.reshape(-1, 1) * 0.5\n\t            uniform_prev_cdf = torch.sigmoid(uniform_estimate_sdf_half_prev * inv_variance)\n\t            uniform_next_cdf = torch.sigmoid(uniform_estimate_sdf_half_next * inv_variance)\n\t            uniform_alpha = F.relu(\n\t                (uniform_prev_cdf - uniform_next_cdf + 1e-5) / (uniform_prev_cdf + 1e-5)).reshape(\n\t                batch_size, n_samples).clip(0.0, 1.0)\n\t            alpha = uniform_alpha\n", "        else:\n\t            assert False\n\t        pts_radius = torch.linalg.norm(pts, ord=2, dim=-1, keepdim=True).reshape(batch_size, n_samples)\n\t        inside_sphere = (pts_radius < 1.0*self.radius).float().detach()\n\t        relax_inside_sphere = (pts_radius < 1.2*self.radius).float().detach()\n\t        if background_alpha is not None:   # render with background\n\t            alpha = alpha * inside_sphere + background_alpha[:, :n_samples] * (1.0 - inside_sphere)\n\t            alpha = torch.cat([alpha, background_alpha[:, n_samples:]], dim=-1)\n\t            sampled_color = sampled_color * inside_sphere[:, :, None] + background_sampled_color[:, :n_samples] * (1.0 - inside_sphere)[:, :, None]\n\t            sampled_color = torch.cat([sampled_color, background_sampled_color[:, n_samples:]], dim=1)\n", "        weights = alpha * torch.cumprod(torch.cat([torch.ones([batch_size, 1]), 1. - alpha + 1e-7], -1), -1)[:, :-1]  # n_rays, n_samples\n\t        weights_sum = weights.sum(dim=-1, keepdim=True)\n\t        color = (sampled_color * weights[:, :, None]).sum(dim=1)\n\t        if background_rgb is not None:\n\t            color = color + background_rgb * (1.0 - weights_sum)\n\t        gradient_error = (torch.linalg.norm(gradients.reshape(batch_size, n_samples, 3), ord=2,\n\t                                            dim=-1) - 1.0) ** 2\n\t        gradient_error = (relax_inside_sphere * gradient_error).sum() / (relax_inside_sphere.sum() + 1e-5)\n\t        variance = (1.0 /inv_variance).mean(dim=-1, keepdim=True)\n\t        assert (torch.isinf(variance).any() == False)\n", "        assert (torch.isnan(variance).any() == False)\n\t        depth = (mid_z_vals * weights[:, :n_samples]).sum(dim=1, keepdim=True)\n\t        depth_varaince = ((mid_z_vals - depth) ** 2 * weights[:, :n_samples]).sum(dim=-1, keepdim=True)\n\t        normal = (gradients.reshape(batch_size, n_samples, 3) * weights[:, :n_samples].reshape(batch_size, n_samples, 1)).sum(dim=1)\n\t        # visualize embedding weights\n\t        if sdf_network.weigth_emb_c2f != None:\n\t            # print(sdf_network.weigth_emb_c2f)\n\t            for id_w in range(len(sdf_network.weigth_emb_c2f)):\n\t                logs_summary[f'weigth_emb_c2f/level{id_w+1}'] = sdf_network.weigth_emb_c2f[id_w].detach()\n\t        with torch.no_grad():\n", "            if inv_variance[0, 0] > 800:\n\t                # logging.info(f\"Use default inv-variance to calculate peak value\")\n\t                depth_peak = depth.clone()\n\t                normal_peak = normal.clone()\n\t                color_peak = color.clone()\n\t                point_peak = rays_o + rays_d*depth\n\t            else:\n\t                # Reset a large inv-variance to get better peak value\n\t                inv_variance2 = torch.tensor([800])\n\t                inv_variance2 = inv_variance2.expand(batch_size * n_samples, 1)\n", "                prev_cdf2 = torch.sigmoid(true_estimate_sdf_half_prev * inv_variance2)\n\t                next_cdf2 = torch.sigmoid(true_estimate_sdf_half_next * inv_variance2)\n\t                p2 = prev_cdf2 - next_cdf2\n\t                c2 = prev_cdf2\n\t                alpha2 = ((p2 + 1e-5) / (c2 + 1e-5)).reshape(batch_size, n_samples).clip(0.0, 1.0)\n\t                weights2 = alpha2 * torch.cumprod(torch.cat([torch.ones([batch_size, 1]), 1. - alpha2 + 1e-7], -1), -1)[:, :-1]  # n_rays, n_samples\n\t                depth_peak = (mid_z_vals * weights2[:, :n_samples]).sum(dim=1, keepdim=True)\n\t                normal_peak = (gradients.reshape(batch_size, n_samples, 3) * weights2[:, :n_samples].reshape(batch_size, n_samples, 1)).sum(dim=1)\n\t                color_peak = (sampled_color[:, :n_samples] * weights2[:, :n_samples, None]).sum(dim=1)\n\t                point_peak = rays_o + rays_d*depth_peak\n", "        return {\n\t            'variance': variance,\n\t            'variance_inv_pts': inv_variance.reshape(batch_size, n_samples),\n\t            'depth': depth,\n\t            'depth_variance': depth_varaince,\n\t            'normal': normal,\n\t            'color_fine': color,\n\t            'cdf_fine': c.reshape(batch_size, n_samples),\n\t            'sdf': sdf,\n\t            'dists': dists,\n", "            'mid_z_vals': mid_z_vals,\n\t            'gradients': gradients.reshape(batch_size, n_samples, 3),\n\t            'gradient_error_fine': gradient_error,\n\t            'weights': weights,\n\t            'weight_sum': weights.sum(dim=-1, keepdim=True),\n\t            'weight_max': torch.max(weights, dim=-1, keepdim=True)[0],\n\t            'inside_sphere': inside_sphere,\n\t            'depth_peak': depth_peak,\n\t            'normal_peak': normal_peak,\n\t            'color_peak': color_peak,\n", "            'point_peak': point_peak\n\t        }, logs_summary\n\t    def render(self, rays_o, rays_d, near, far, perturb_overwrite=-1, background_rgb=None, alpha_inter_ratio=0.0):\n\t        batch_size = len(rays_o)\n\t        sphere_diameter = torch.abs(far-near).mean()\n\t        sample_dist = sphere_diameter / self.n_samples\n\t        z_vals = torch.linspace(0.0, 1.0, self.n_samples)\n\t        z_vals = near + (far - near) * z_vals[None, :]\n\t        z_vals_outside = None\n\t        if self.n_outside > 0:\n", "            z_vals_outside = torch.linspace(1e-3, 1.0 - 1.0 / (self.n_outside + 1.0), self.n_outside)\n\t        n_samples = self.n_samples\n\t        perturb = self.perturb\n\t        if perturb_overwrite >= 0:\n\t            perturb = perturb_overwrite\n\t        if perturb > 0:\n\t            # get intervals between samples\n\t            t_rand = (torch.rand([batch_size, 1]) - 0.5)\n\t            z_vals = z_vals + t_rand * 2.0 / self.n_samples\n\t            if self.n_outside > 0:\n", "                mids = .5 * (z_vals_outside[..., 1:] + z_vals_outside[..., :-1])\n\t                upper = torch.cat([mids, z_vals_outside[..., -1:]], -1)\n\t                lower = torch.cat([z_vals_outside[..., :1], mids], -1)\n\t                # stratified samples in those intervals\n\t                t_rand = torch.rand([batch_size, z_vals_outside.shape[-1]])\n\t                z_vals_outside = lower[None, :] + (upper - lower)[None, :] * t_rand\n\t        if self.n_outside > 0:\n\t            z_vals_outside = far / torch.flip(z_vals_outside, dims=[-1]) + 1.0 / self.n_samples\n\t        background_alpha = None\n\t        background_sampled_color = None\n", "        # Up sample\n\t        if self.n_importance > 0:\n\t            with torch.no_grad():\n\t                pts = rays_o[:, None, :] + rays_d[:, None, :] * z_vals[..., :, None]\n\t                sdf = self.sdf_network_fine.sdf(pts.reshape(-1, 3)).reshape(batch_size, self.n_samples)\n\t                n_steps = 4\n\t                for i in range(n_steps):\n\t                    new_z_vals = self.up_sample(rays_o, rays_d, z_vals, sdf, self.n_importance // n_steps, 64 * 2**i)\n\t                    z_vals, sdf = self.cat_z_vals(rays_o, rays_d, z_vals, new_z_vals, sdf)\n\t            n_samples = self.n_samples + self.n_importance\n", "        # Background\n\t        if self.n_outside > 0:\n\t            z_vals_feed = torch.cat([z_vals, z_vals_outside], dim=-1)\n\t            z_vals_feed, _ = torch.sort(z_vals_feed, dim=-1)\n\t            ret_outside = self.render_core_outside(rays_o, rays_d, z_vals_feed, sample_dist, self.nerf)\n\t            background_sampled_color = ret_outside['sampled_color']\n\t            background_alpha = ret_outside['alpha']\n\t        # Render\n\t        ret_fine, logs_summary = self.render_core(rays_o,\n\t                                    rays_d,\n", "                                    z_vals,\n\t                                    sample_dist,\n\t                                    self.sdf_network_fine,\n\t                                    self.variance_network_fine,\n\t                                    self.color_network_fine,\n\t                                    background_rgb=background_rgb,\n\t                                    background_alpha=background_alpha,\n\t                                    background_sampled_color=background_sampled_color,\n\t                                    alpha_inter_ratio=alpha_inter_ratio)\n\t        return ret_fine, logs_summary\n", "    def extract_geometry(self, bound_min, bound_max, resolution, threshold=0.0):\n\t        ret = extract_geometry(bound_min, bound_max, resolution, threshold, lambda pts: -self.sdf_network_fine.sdf(pts))\n\t        return ret\n\tclass NeRFRenderer:\n\t    def __init__(self,\n\t                 nerf_coarse,\n\t                 nerf_fine,\n\t                 nerf_outside,\n\t                 n_samples,\n\t                 n_importance,\n", "                 n_outside,\n\t                 perturb):\n\t        self.nerf_coarse = nerf_coarse\n\t        self.nerf_fine = nerf_fine\n\t        self.nerf_outside = nerf_outside\n\t        self.n_samples = n_samples\n\t        self.n_importance = n_importance\n\t        self.n_outside = n_outside\n\t        self.perturb = perturb\n\t    def render_core_coarse(self, rays_o, rays_d, z_vals, sample_dist, nerf, background_rgb=None):\n", "        batch_size, n_samples = z_vals.shape\n\t        dists = z_vals[..., 1:] - z_vals[..., :-1]\n\t        dists = torch.cat([dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        mid_z_vals = z_vals + dists * 0.5\n\t        pts = rays_o[:, None, :] + rays_d[:, None, :] * mid_z_vals[..., :, None]  # batch_size, n_samples, 3\n\t        if self.n_outside > 0:\n\t            dis_to_center = torch.linalg.norm(pts, ord=2, dim=-1, keepdim=True).clip(1.0, 1e10)\n\t            pts = torch.cat([pts / dis_to_center, 1.0 / dis_to_center], dim=-1)       # batch_size, n_samples, 4\n\t        dirs = rays_d[:, None, :].expand(batch_size, n_samples, 3)\n\t        pts = pts.reshape(-1, 3 + int(self.n_outside > 0))\n", "        dirs = dirs.reshape(-1, 3)\n\t        density, sampled_color = nerf(pts, dirs)\n\t        alpha = 1.0 - torch.exp(-F.relu(density.reshape(batch_size, n_samples)) * dists)\n\t        alpha = alpha.reshape(batch_size, n_samples)\n\t        weights = alpha * torch.cumprod(torch.cat([torch.ones([batch_size, 1]), 1. - alpha + 1e-7], -1), -1)[:, :-1]  # n_rays, n_samples\n\t        sampled_color = sampled_color.reshape(batch_size, n_samples, 3)\n\t        color = (weights[:, :, None] * sampled_color).sum(dim=1)\n\t        if background_rgb is not None:\n\t            color = color + background_rgb * (1.0 - weights.sum(dim=-1, keepdim=True))\n\t        return {\n", "            'color': color,\n\t            'sampled_color': sampled_color,\n\t            'alpha': alpha,\n\t            'weights': weights,\n\t        }\n\t    def render_core(self,\n\t                    rays_o,\n\t                    rays_d,\n\t                    z_vals,\n\t                    sample_dist,\n", "                    nerf,\n\t                    fine=False,\n\t                    background_rgb=None,\n\t                    background_alpha=None,\n\t                    background_sampled_color=None):\n\t        batch_size, n_samples = z_vals.shape\n\t        dists = z_vals[..., 1:] - z_vals[..., :-1]\n\t        dists = torch.cat([dists, torch.Tensor([sample_dist]).expand(dists[..., :1].shape)], -1)\n\t        mid_z_vals = z_vals + dists * 0.5\n\t        pts = rays_o[:, None, :] + rays_d[:, None, :] * mid_z_vals[..., :, None]  # n_rays, n_samples, 3\n", "        dirs = rays_d[:, None, :].expand(pts.shape)\n\t        pts = pts.reshape(-1, 3)\n\t        dirs = dirs.reshape(-1, 3)\n\t        density, sampled_color = nerf(pts, dirs)\n\t        sampled_color = sampled_color.reshape(batch_size, n_samples, 3)\n\t        alpha = 1.0 - torch.exp(-F.relu(density.reshape(batch_size, n_samples)) * dists)\n\t        alpha = alpha.reshape(batch_size, n_samples)\n\t        inside_sphere = None\n\t        if background_alpha is not None:  # render without mask\n\t            pts_radius = torch.linalg.norm(pts, ord=2, dim=-1, keepdim=True).reshape(batch_size, n_samples)\n", "            inside_sphere = (torch.linalg.norm(pts, ord=2, dim=-1).reshape(batch_size, n_samples) < 1.0).float()\n\t            # alpha = alpha * inside_sphere\n\t            alpha = torch.cat([alpha, background_alpha], dim=-1)\n\t            sampled_color = torch.cat([sampled_color, background_sampled_color], dim=1)\n\t        weights = alpha * torch.cumprod(torch.cat([torch.ones([batch_size, 1]), 1. - alpha + 1e-7], -1), -1)[:, :-1]  # n_rays, n_samples\n\t        color = (weights[:, :, None] * sampled_color.reshape(batch_size, n_samples + self.n_outside, 3)).sum(dim=1)\n\t        return {\n\t            'color': color,\n\t            'weights': weights,\n\t            'depth': (mid_z_vals * weights[:, :n_samples]).sum(dim=-1, keepdim=True)\n", "        }\n\t    def render(self, rays_o, rays_d, near, far, perturb_overwrite=-1, background_rgb=None):\n\t        sample_dist = ((far - near) / self.n_samples).mean().item()\n\t        z_vals = torch.linspace(0.0, 1.0, self.n_samples)\n\t        z_vals = near + (far - near) * z_vals[None, :]\n\t        z_vals_outside = None\n\t        if self.n_outside > 0:\n\t            z_vals_outside = torch.linspace(1e-3, 1.0 - 1.0 / (self.n_outside + 1.0), self.n_outside)\n\t        n_samples = self.n_samples\n\t        perturb = self.perturb\n", "        if perturb_overwrite >= 0:\n\t            perturb = perturb_overwrite\n\t        if perturb > 0:\n\t            # get intervals between samples\n\t            mids = .5 * (z_vals[..., 1:] + z_vals[..., :-1])\n\t            upper = torch.cat([mids, z_vals[..., -1:]], -1)\n\t            lower = torch.cat([z_vals[..., :1], mids], -1)\n\t            # stratified samples in those intervals\n\t            t_rand = torch.rand(z_vals.shape)\n\t            z_vals = lower + (upper - lower) * t_rand\n", "            if self.n_outside > 0:\n\t                mids = .5 * (z_vals_outside[..., 1:] + z_vals_outside[..., :-1])\n\t                upper = torch.cat([mids, z_vals_outside[..., -1:]], -1)\n\t                lower = torch.cat([z_vals_outside[..., :1], mids], -1)\n\t                # stratified samples in those intervals\n\t                t_rand = torch.rand(z_vals_outside.shape)\n\t                z_vals_outside = lower + (upper - lower) * t_rand\n\t        if self.n_outside > 0:\n\t            z_vals_outside = far / torch.flip(z_vals_outside, dims=[-1]) + 1.0 / self.n_samples\n\t        color_coarse = None\n", "        background_alpha = None\n\t        background_sampled_color = None\n\t        background_color = torch.zeros([1, 3])\n\t        ret_coarse = {\n\t            'color': None,\n\t            'weights': None,\n\t        }\n\t        # NeRF++\n\t        if self.n_outside > 0:\n\t            # z_vals_feed = torch.cat([z_vals, z_vals_outside], dim=-1)\n", "            # z_vals_feed, _ = torch.sort(z_vals_feed, dim=-1)\n\t            z_vals_feed = z_vals_outside\n\t            ret_outside = self.render_core_coarse(rays_o, rays_d, z_vals_feed, sample_dist, self.nerf_outside,\n\t                                                  background_rgb=None)\n\t            background_sampled_color = ret_outside['sampled_color']\n\t            background_alpha = ret_outside['alpha']\n\t        if self.n_importance > 0:\n\t            ret_coarse = self.render_core(rays_o,\n\t                                          rays_d,\n\t                                          z_vals,\n", "                                          sample_dist,\n\t                                          self.nerf_coarse,\n\t                                          fine=False,\n\t                                          background_rgb=background_rgb,\n\t                                          background_alpha=background_alpha,\n\t                                          background_sampled_color=background_sampled_color)\n\t            weights = ret_coarse['weights']\n\t            # importance sampling\n\t            z_samples = sample_pdf(z_vals, weights[..., :-1 + self.n_samples],\n\t                                   self.n_importance, det=True).detach()\n", "            z_vals = torch.cat([z_vals, z_samples], dim=-1)\n\t            z_vals, _ = torch.sort(z_vals, dim=-1)\n\t            z_vals = z_vals.detach()\n\t            n_samples = self.n_samples + self.n_importance\n\t        # ----------------------------------- fine --------------------------------------------\n\t        # render again\n\t        ret_fine = self.render_core(rays_o,\n\t                                    rays_d,\n\t                                    z_vals,\n\t                                    sample_dist,\n", "                                    self.nerf_fine,\n\t                                    fine=True,\n\t                                    background_rgb=background_rgb,\n\t                                    background_alpha=background_alpha,\n\t                                    background_sampled_color=background_sampled_color)\n\t        return {\n\t            'color_coarse': ret_coarse['color'],\n\t            'color_fine': ret_fine['color'],\n\t            'weight_sum': ret_fine['weights'].sum(dim=-1, keepdim=True),\n\t            'depth': ret_fine['depth']\n", "        }\n\t    def extract_geometry(self, bound_min, bound_max, resolution, threshold=25):\n\t        ret = extract_geometry(bound_min, bound_max, resolution, threshold, lambda pts: self.nerf_fine(pts, torch.zeros_like(pts))[0])\n\t        return ret"]}
{"filename": "confs/path.py", "chunked_list": ["import os\n\t# BIN_DIR = \"/home/depthneus\"\n\t# DIR_MVG_BUILD = BIN_DIR + \"/openMVG_Build\"\n\t# DIR_MVS_BUILD = BIN_DIR + \"/openMVS_build\"\n\t# # normal path\n\t# dir_snu_code = '/path/snucode' # directory of code\n\t# path_snu_pth = 'path/scannet.pt'\n\t# assert os.path.exists(path_snu_pth)\n\t# dir_tiltedsn_code = '/path/tiltedsn_code'\n\t# dir_tiltedsn_ckpt = '/path/tiltedsn_ckpt' # directory of pretrained model\n", "# path_tiltedsn_pth_pfpn = f\"{dir_tiltedsn_ckpt}/PFPN_SR_full/model-best.ckpt\"\n\t# path_tiltedsn_pth_sr = f\"{dir_tiltedsn_ckpt}/SR_only/model-latest.ckpt\"\n\t# assert os.path.exists(path_tiltedsn_pth_sr)\n\t# # used scenes\n\t# names_scenes_depthneus = ['scene0009_01', 'scene0085_00', 'scene0114_02',\n\t#                         'scene0603_00', 'scene0617_00', 'scene0625_00',\n\t#                         'scene0721_00', 'scene0771_00']\n\t# names_scenes_manhattansdf = ['scene0050_00', 'scene0084_00', \n\t#                                 'scene0580_00', 'scene0616_00']\n\t# lis_name_scenes = names_scenes_depthneus + names_scenes_manhattansdf\n", "# # update training/test split\n\t# names_scenes_depthneus_remove = ['scene0009', 'scene0085', 'scene0114',\n\t#                         'scene0603', 'scene0617', 'scene0625',\n\t#                         'scene0721', 'scene0771']\n\t# names_scenes_manhattansdf_remove = ['scene0050', 'scene0084', \n\t#                                 'scene0580', 'scene0616']\n\t# lis_name_scenes_remove = names_scenes_depthneus_remove + names_scenes_manhattansdf_remove\n\tnames_scenes_depthneus = ['scene0625_00']\n\tlis_name_scenes = names_scenes_depthneus"]}
