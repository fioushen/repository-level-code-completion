{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/fixtures/__init__.py", "chunked_list": []}
{"filename": "tests/fixtures/pynetbox/devices.py", "chunked_list": ["from unittest.mock import Mock\n\tfrom pynetbox.core.response import Record\n\tfrom pynetbox.models.dcim import Devices\n\tapi = Mock(base_url='http://netbox')\n\t_common = {\n\t    'airflow': None,\n\t    'asset_tag': None,\n\t    'cluster': None,\n\t    'comments': '',\n\t    'config_context': {},\n", "    'created': '2023-01-01T12:00:00.000000Z',\n\t    'custom_fields': {},\n\t    'device_role': Record({'display': 'Unknown'}, api, None),\n\t    'device_type': Record({'display': 'Unknown'}, api, None),\n\t    'face': None,\n\t    'has_details': False,\n\t    'last_updated': '2023-01-01T12:00:00.000000Z',\n\t    'local_context_data': None,\n\t    'location': None,\n\t    'parent_device': None,\n", "    'platform': None,\n\t    'position': None,\n\t    'primary_ip6': None,\n\t    'rack': None,\n\t    'serial': '',\n\t    'site': None,\n\t    'status': Record({'label': 'Active', 'value': 'active'}, api, None),\n\t    'tags': [],\n\t    'tenant': None,\n\t    'vc_position': None,\n", "    'vc_priority': None,\n\t    'virtual_chassis': None}\n\t_dev_400 = _common.copy()\n\t_dev_400.update({\n\t    'display': 'pc',\n\t    'id': 400,\n\t    'name': 'pc',\n\t    # Primary IP addresse associations are postponed into ip_addresses module\n\t    # to avoid circular import failures.\n\t    # 'primary_ip':  ip_addresses.ip_address_200,\n", "    # 'primary_ip4': ip_addresses.ip_address_200,\n\t    'url': 'http://netbox/api/dcim/devices/400/'})\n\tdevice_400 = Devices(_dev_400, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/prefixes.py", "chunked_list": ["from unittest.mock import Mock\n\tfrom pynetbox.core.response import Record\n\tfrom pynetbox.models.ipam import Prefixes\n\tapi = Mock(base_url='http://netbox')\n\t_common = {\n\t    'children': 0,\n\t    'comments': '',\n\t    'created': '2023-01-01T12:00:00.000000Z',\n\t    'custom_fields': {'dhcp_enable': True,\n\t                      'dhcp_option_data_domain_search': 'local, lan',\n", "                      'dhcp_option_data_routers': '192.168.0.254'},\n\t    'description': '',\n\t    'family': Record({'label': 'IPv4', 'value': 4}, api, None),\n\t    'has_details': False,\n\t    'is_pool': False,\n\t    'last_updated': '2023-01-01T12:00:00.000000Z',\n\t    'mark_utilized': False,\n\t    'role': None,\n\t    'site': None,\n\t    'status': Record({'label': 'Active', 'value': 'active'}, api, None),\n", "    'tags': [],\n\t    'tenant': None,\n\t    'url': 'http://netbox/api/ipam/prefixes/100/',\n\t    'vlan': None,\n\t    'vrf': None}\n\t_pref_100 = _common.copy()\n\t_pref_100.update({\n\t    'display': '192.168.0.0/24',\n\t    'id': 100,\n\t    'prefix': '192.168.0.0/24'})\n", "prefix_100 = Prefixes(_pref_100, api, None)\n\t_pref_101 = _common.copy()\n\t_pref_101.update({\n\t    'custom_fields': {'dhcp_enable': True,\n\t                      'dhcp_option_data_domain_search': 'local, lan10',\n\t                      'dhcp_option_data_routers': '10.254.254.254'},\n\t    'display': '10.0.0.0/8',\n\t    'id': 101,\n\t    'prefix': '10.0.0.0/8'})\n\tprefix_101 = Prefixes(_pref_101, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/virtual_machines.py", "chunked_list": ["from unittest.mock import Mock\n\tfrom pynetbox.core.response import Record\n\tfrom pynetbox.models.virtualization import VirtualMachines\n\tapi = Mock(base_url='http://netbox')\n\t_common = {\n\t    'cluster': Record({'display': 'My cluster'}, api, None),\n\t    'comments': '',\n\t    'config_context': {},\n\t    'created': '2023-01-01T12:00:00.000000Z',\n\t    'custom_fields': {},\n", "    'device': None,\n\t    'disk': None,\n\t    'has_details': False,\n\t    'last_updated': '2023-01-01T12:00:00.000000Z',\n\t    'local_context_data': None,\n\t    'memory': None,\n\t    'platform': None,\n\t    'primary_ip6': None,\n\t    'role': None,\n\t    'site': None,\n", "    'status': Record({'label': 'Active', 'value': 'active'}, api, None),\n\t    'tags': [],\n\t    'tenant': None,\n\t    'vcpus': None}\n\t_vm_450 = _common.copy()\n\t_vm_450.update({\n\t    'display': 'vm',\n\t    'id': 450,\n\t    'name': 'vm',\n\t    # Primary IP addresse associations are postponed into ip_addresses module\n", "    # to avoid circular import failures.\n\t    # 'primary_ip': ip_addresse.ip_address_300,\n\t    # 'primary_ip4': ip_addresses.ip_address_300,\n\t    'url': 'http://netbox/api/virtualization/virtual-machines/450/'})\n\tvirtual_machine_450 = VirtualMachines(_vm_450, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/__init__.py", "chunked_list": []}
{"filename": "tests/fixtures/pynetbox/vminterfaces.py", "chunked_list": ["from unittest.mock import Mock\n\tfrom pynetbox.core.response import Record\n\tfrom . import virtual_machines\n\tapi = Mock(base_url='http://netbox')\n\t# Note: record method \"full_detail()\" was called\n\t_common = {\n\t    'bridge': None,\n\t    'count_fhrp_groups': 0,\n\t    'created': '2023-01-01T12:00:00.000000Z',\n\t    'custom_fields': {},\n", "    'description': '',\n\t    'enabled': True,\n\t    'has_details': True,\n\t    'l2vpn_termination': None,\n\t    'last_updated': '2023-03-28T08:15:56.256950Z',\n\t    'mac_address': '55:55:55:55:55:55',\n\t    'mode': None,\n\t    'mtu': None,\n\t    'parent': None,\n\t    'tagged_vlans': [],\n", "    'tags': [],\n\t    'untagged_vlan': None,\n\t    'vrf': None}\n\t_vif_350 = _common.copy()\n\t_vif_350.update({\n\t    'count_ipaddresses': 1,\n\t    'display': 'vm001-if0',\n\t    'id': 350,\n\t    'name': 'vm001-if0',\n\t    'virtual_machine': virtual_machines.virtual_machine_450,\n", "    'url': 'http://netbox:8000/api/virtualization/interfaces/350/'})\n\tvminterface_350 = Record(_vif_350, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/ip_addresses.py", "chunked_list": ["from unittest.mock import Mock\n\tfrom pynetbox.core.response import Record\n\tfrom pynetbox.models.ipam import IpAddresses\n\tfrom . import devices, interfaces, virtual_machines, vminterfaces\n\tALL_IP = []\n\tdef get(id_):\n\t    \"\"\" Emulate pynetbox.[…].Record.get()\"\"\"\n\t    for ip in ALL_IP:\n\t        if ip.id == id_:\n\t            return ip\n", "def filter_(interface_id=None, device_id=None, vminterface_id=None,\n\t            virtual_machine_id=None, **kwargs):\n\t    \"\"\" Emulate pynetbox.[…].Record.filter()\"\"\"\n\t    intf_id = vminterface_id if vminterface_id else interface_id\n\t    if intf_id:\n\t        return iter([ip for ip in ALL_IP if ip.assigned_object and\n\t                     ip.assigned_object.id == intf_id])\n\t    elif device_id:\n\t        return iter([ip for ip in ALL_IP if\n\t                     ip.assigned_object_type == 'dcim.interface'\n", "                     and ip.assigned_object.device.id == device_id])\n\t    elif virtual_machine_id:\n\t        return iter([ip for ip in ALL_IP if\n\t                     ip.assigned_object_type == 'virtualization.vminterface'\n\t                     and ip.assigned_object.virtual_machine.id ==\n\t                     virtual_machine_id])\n\t    else:\n\t        return iter(ALL_IP)\n\tapi = Mock(base_url='http://netbox')\n\t_common = {\n", "    'assigned_object': None,\n\t    'assigned_object_id': None,\n\t    'assigned_object_type': None,\n\t    'comments': '',\n\t    'created': '2023-01-01T12:00:00.000000Z',\n\t    'custom_fields': {},\n\t    'description': '',\n\t    'family': Record({'label': 'IPv4', 'value': 4}, api, None),\n\t    'has_details': False,\n\t    'last_updated': '2023-01-01T12:00:00.000000Z',\n", "    'nat_inside': None,\n\t    'nat_outside': [],\n\t    'role': None,\n\t    'tags': [],\n\t    'tenant': None,\n\t    'vrf': None}\n\t_ip_200 = _common.copy()\n\t_ip_200.update({\n\t    'address': '192.168.0.1/24',\n\t    'assigned_object': interfaces.interface_300,\n", "    'assigned_object_id': 300,\n\t    'assigned_object_type': 'dcim.interface',\n\t    'display': '192.168.0.1/24',\n\t    'dns_name': 'pc.lan',\n\t    'id': 200,\n\t    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n\t    'url': 'https://netbox/api/ipam/ip-addresses/200/'})\n\tip_address_200 = IpAddresses(_ip_200, api, None)\n\tALL_IP.append(ip_address_200)\n\t# Associate here IP address with device to avoid circular import failure\n", "devices.device_400.primary_ip = ip_address_200\n\tdevices.device_400.primary_ip4 = ip_address_200\n\t_ip_201 = _common.copy()\n\t_ip_201.update({\n\t    'address': '192.168.0.2/24',\n\t    'custom_fields': {'dhcp_resa_hw_address': '22:22:22:22:22:22'},\n\t    'display': '192.168.0.2/24',\n\t    'dns_name': 'pc2.lan',\n\t    'id': 201,\n\t    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n", "    'url': 'https://netbox/api/ipam/ip-addresses/201/'})\n\tip_address_201 = IpAddresses(_ip_201, api, None)\n\tALL_IP.append(ip_address_201)\n\t_ip_202 = _common.copy()\n\t_ip_202.update({\n\t    'address': '192.168.0.3/24',\n\t    'assigned_object': interfaces.interface_300,\n\t    'assigned_object_id': 300,\n\t    'assigned_object_type': 'dcim.interface',\n\t    'custom_fields': {'dhcp_resa_hw_address': '33:33:33:33:33:33'},\n", "    'display': '192.168.0.3/24',\n\t    'dns_name': 'pc3.lan',\n\t    'id': 202,\n\t    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n\t    'url': 'https://netbox/api/ipam/ip-addresses/202/'})\n\tip_address_202 = IpAddresses(_ip_202, api, None)\n\tALL_IP.append(ip_address_202)\n\t_ip_250 = _common.copy()\n\t_ip_250.update({\n\t    'address': '10.0.0.50/8',\n", "    'assigned_object': vminterfaces.vminterface_350,\n\t    'assigned_object_id': 350,\n\t    'assigned_object_type': 'virtualization.vminterface',\n\t    'display': '10.0.0.50/8',\n\t    'dns_name': 'vm.lan10',\n\t    'id': 250,\n\t    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n\t    'url': 'https://netbox/api/ipam/ip-addresses/250/'})\n\tip_address_250 = IpAddresses(_ip_250, api, None)\n\tALL_IP.append(ip_address_250)\n", "# Associate here IP address with device to avoid circular import failure\n\tvirtual_machines.virtual_machine_450.primary_ip = ip_address_250\n\tvirtual_machines.virtual_machine_450.primary_ip4 = ip_address_250\n"]}
{"filename": "tests/fixtures/pynetbox/ip_ranges.py", "chunked_list": ["from unittest.mock import Mock\n\tfrom pynetbox.core.response import Record\n\tfrom pynetbox.models.ipam import IpRanges\n\tapi = Mock(base_url='http://netbox')\n\t_common = {\n\t    'comments': '',\n\t    'created': '2023-01-01T12:00:00.000000Z',\n\t    'custom_fields': {},\n\t    'description': '',\n\t    'family': Record({'label': 'IPv4', 'value': 4}, api, None),\n", "    'has_details': False,\n\t    'last_updated': '2023-01-01T12:00:00.000000Z',\n\t    'role': None,\n\t    'size': 100,\n\t    'tags': [],\n\t    'tenant': None,\n\t    'vrf': None}\n\t_r_250 = _common.copy()\n\t_r_250.update({\n\t    'display': '192.168.0.100-200/24',\n", "    'end_address': '192.168.0.199/24',\n\t    'id': 250,\n\t    'start_address': '192.168.0.100/24',\n\t    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n\t    'url': 'http://netbox/api/ipam/ip-ranges/250/'})\n\tip_range_250 = IpRanges(_r_250, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/interfaces.py", "chunked_list": ["from unittest.mock import Mock\n\tfrom pynetbox.core.response import Record\n\tfrom pynetbox.models.dcim import Interfaces\n\tfrom . import devices\n\tapi = Mock(base_url='http://netbox')\n\t_common = {\n\t    '_occupied': False,\n\t    'bridge': None,\n\t    'cable': None,\n\t    'cable_end': '',\n", "    'created': '2023-01-01T12:00:00.000000Z',\n\t    'connected_endpoints': None,\n\t    'connected_endpoints_reachable': None,\n\t    'connected_endpoints_type': None,\n\t    'count_fhrp_groups': 0,\n\t    'custom_fields': {},\n\t    'description': '',\n\t    'duplex': None,\n\t    'enabled': True,\n\t    'has_details': False,\n", "    'l2vpn_termination': None,\n\t    'label': '',\n\t    'lag': None,\n\t    'last_updated': '2023-01-01T12:00:00.000000Z',\n\t    'link_peers': [],\n\t    'link_peers_type': None,\n\t    'mark_connected': False,\n\t    'mgmt_only': False,\n\t    'mode': None,\n\t    'module': None,\n", "    'mtu': None,\n\t    'parent': None,\n\t    'poe_mode': None,\n\t    'poe_type': None,\n\t    'rf_channel': None,\n\t    'rf_channel_frequency': None,\n\t    'rf_channel_width': None,\n\t    'rf_role': None,\n\t    'speed': None,\n\t    'tagged_vlans': [],\n", "    'tags': [],\n\t    'tx_power': None,\n\t    'type': Record(\n\t        {'label': '1000BASE-T (1GE)', 'value': '1000base-t'}, api, None),\n\t    'untagged_vlan': None,\n\t    'vdcs': [],\n\t    'vrf': None,\n\t    'wireless_lans': [],\n\t    'wireless_link': None,\n\t    'wwn': None}\n", "# pynetbox record __dict__ attribute\n\t_if_300 = _common.copy()\n\t_if_300.update({\n\t    'count_ipaddresses': 1,\n\t    #'device': tests.fixtures.pynetbox.devices.device_400,\n\t    'device': devices.device_400,\n\t    'display': 'pc-if0',\n\t    'id': 300,\n\t    'mac_address': '11:11:11:11:11:11',\n\t    'name': 'pc-if0',\n", "    'url': 'http://netbox/api/dcim/interfaces/300/',\n\t    })\n\tinterface_300 = Interfaces(_if_300, api, None)\n"]}
{"filename": "tests/unit/test_connector.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import Mock, call\n\tfrom netboxkea.connector import _get_nested, _set_dhcp_attr, Connector\n\tfrom netboxkea.kea.exceptions import SubnetNotFound\n\tfrom ..fixtures.pynetbox import ip_addresses as fixtip\n\tfrom ..fixtures.pynetbox import ip_ranges as fixtr\n\tfrom ..fixtures.pynetbox import prefixes as fixtp\n\tclass TestConnectorFunctions(unittest.TestCase):\n\t    def test_01_get_nested_attr(self):\n\t        obj = {'assigned': {'device': {'name': 'pc.lan'}}}\n", "        hostname = _get_nested(obj, 'assigned.device.name')\n\t        self.assertEqual(hostname, 'pc.lan')\n\t    def test_02_set_dhcp_attr(self):\n\t        dhcp_item = {}\n\t        _set_dhcp_attr(dhcp_item, 'next-server', '10.0.0.1')\n\t        _set_dhcp_attr(dhcp_item, 'option-data.routers', '192.168.0.254')\n\t        _set_dhcp_attr(dhcp_item, 'option-data.domain-search', 'lan')\n\t        _set_dhcp_attr(dhcp_item, 'user-context.desc', 'Test')\n\t        _set_dhcp_attr(dhcp_item, 'user-context.note', 'Hello')\n\t        self.assertEqual(dhcp_item, {\n", "            'next-server': '10.0.0.1',\n\t            'option-data': [\n\t                {'name': 'routers', 'data': '192.168.0.254'},\n\t                {'name': 'domain-search', 'data': 'lan'}],\n\t            'user-context': {'desc': 'Test', 'note': 'Hello'}})\n\tclass TestConnector(unittest.TestCase):\n\t    def setUp(self):\n\t        self.nb = Mock()\n\t        self.kea = Mock()\n\t        # Set up connector\n", "        resa_ip_map = {\n\t            'hw-address': ['custom_fields.dhcp_resa_hw_address',\n\t                           'assigned_object.mac_address'],\n\t            'hostname': ['dns_name', 'assigned_object.device.name',\n\t                         'assigned_object.virtual_machine.name']}\n\t        self.conn = Connector(self.nb, self.kea, {}, {}, resa_ip_map)\n\t        # Set up netbox mock\n\t        self.nb.prefix.return_value = fixtp.prefix_100\n\t        self.nb.prefixes.return_value = iter([fixtp.prefix_100])\n\t        self.nb.all_prefixes.return_value = iter([fixtp.prefix_100])\n", "        self.nb.ip_range.return_value = fixtr.ip_range_250\n\t        self.nb.ip_ranges.return_value = iter([fixtr.ip_range_250])\n\t        self.nb.ip_address.side_effect = fixtip.get\n\t        self.nb.ip_addresses.side_effect = fixtip.filter_\n\t        # Define kea calls\n\t        self.call_subnet100 = call(100, {'subnet': '192.168.0.0/24'})\n\t        self.call_subnet101 = call(101, {'subnet': '10.0.0.0/8'})\n\t        self.call_resa200 = call(100, 200, {\n\t            'ip-address': '192.168.0.1', 'hw-address': '11:11:11:11:11:11',\n\t            'hostname': 'pc.lan'})\n", "        self.call_resa201 = call(100, 201, {\n\t            'ip-address': '192.168.0.2', 'hw-address': '22:22:22:22:22:22',\n\t            'hostname': 'pc2.lan'})\n\t        self.call_resa202 = call(100, 202, {\n\t            'ip-address': '192.168.0.3', 'hw-address': '33:33:33:33:33:33',\n\t            'hostname': 'pc3.lan'})\n\t        self.call_resa250 = call(100, 250, {\n\t            'ip-address': '10.0.0.50', 'hw-address': '55:55:55:55:55:55',\n\t            'hostname': 'vm.lan10'})\n\t        self.call_pool250 = call(100, 250, {\n", "            'pool': '192.168.0.100-192.168.0.199'})\n\t    def test_01_sync_ip_address_with_assigned_interface(self):\n\t        self.conn.sync_ipaddress(200)\n\t        self.nb.ip_address.assert_called_once_with(200)\n\t        self.nb.prefixes.assert_called_once_with(contains='192.168.0.1/24')\n\t        self.kea.set_reservation.assert_has_calls([self.call_resa200])\n\t    def test_02_sync_ip_address_with_custom_field(self):\n\t        self.conn.sync_ipaddress(201)\n\t        self.nb.ip_address.assert_called_once_with(201)\n\t        self.nb.prefixes.assert_called_once_with(contains='192.168.0.2/24')\n", "        self.kea.set_reservation.assert_has_calls([self.call_resa201])\n\t    def test_03_sync_ip_address_with_assigned_and_custom_field(self):\n\t        self.conn.sync_ipaddress(202)\n\t        self.nb.ip_address.assert_called_once_with(202)\n\t        self.nb.prefixes.assert_called_once_with(contains='192.168.0.3/24')\n\t        self.kea.set_reservation.assert_has_calls([self.call_resa202])\n\t    def test_05_sync_ip_address_vm(self):\n\t        self.conn.sync_ipaddress(250)\n\t        self.nb.ip_address.assert_called_once_with(250)\n\t        self.nb.prefixes.assert_called_once_with(contains='10.0.0.50/8')\n", "        self.kea.set_reservation.assert_has_calls([self.call_resa250])\n\t    def test_09_sync_ip_address_del(self):\n\t        self.conn.sync_ipaddress(249)\n\t        self.nb.ip_address.assert_called_once_with(249)\n\t        self.kea.del_resa.assert_called_once_with(249)\n\t    def test_10_sync_interface(self):\n\t        self.conn.sync_interface(300)\n\t        self.nb.ip_addresses.assert_called_once_with(interface_id=300)\n\t        self.kea.set_reservation.assert_has_calls([self.call_resa200])\n\t    def test_11_sync_device(self):\n", "        self.conn.sync_device(400)\n\t        self.nb.ip_addresses.assert_called_once_with(device_id=400)\n\t        self.kea.set_reservation.assert_has_calls([self.call_resa200])\n\t    def test_15_sync_vminterface(self):\n\t        self.conn.sync_vminterface(350)\n\t        self.nb.ip_addresses.assert_called_once_with(vminterface_id=350)\n\t        self.kea.set_reservation.assert_has_calls([self.call_resa250])\n\t    def test_16_sync_virtualmachine(self):\n\t        self.conn.sync_virtualmachine(450)\n\t        self.nb.ip_addresses.assert_called_once_with(virtual_machine_id=450)\n", "        self.kea.set_reservation.assert_has_calls([self.call_resa250])\n\t    def test_20_sync_ip_range(self):\n\t        self.conn.sync_iprange(250)\n\t        self.kea.set_pool.assert_has_calls([self.call_pool250])\n\t    def test_21_sync_ip_range_del(self):\n\t        self.nb.ip_range.return_value = None\n\t        self.conn.sync_iprange(299)\n\t        self.kea.del_pool.assert_called_once_with(299)\n\t    def test_30_sync_prefix_update(self):\n\t        self.conn.sync_prefix(100)\n", "        self.kea.update_subnet.assert_called_once_with(100, {\n\t            'subnet': '192.168.0.0/24'})\n\t    def test_31_sync_prefix_fullsync(self):\n\t        self.kea.update_subnet.side_effect = SubnetNotFound()\n\t        self.conn.sync_prefix(100)\n\t        self.nb.ip_addresses.assert_called_once_with(parent='192.168.0.0/24')\n\t        self.nb.ip_ranges.assert_called_once_with(parent='192.168.0.0/24')\n\t        self.kea.set_subnet.assert_has_calls([self.call_subnet100])\n\t        self.kea.set_reservation.assert_has_calls(\n\t            [self.call_resa200, self.call_resa201, self.call_resa202])\n", "        self.kea.set_pool.assert_has_calls([self.call_pool250])\n\t    def test_39_sync_prefix_del(self):\n\t        self.nb.prefix.return_value = None\n\t        self.conn.sync_prefix(199)\n\t        self.kea.del_subnet.assert_called_once_with(199)\n\t    def test_99_sync_all(self):\n\t        self.conn.sync_all()\n\t        self.kea.set_subnet.assert_has_calls([self.call_subnet100])\n\t        self.kea.set_reservation.assert_has_calls(\n\t            [self.call_resa200, self.call_resa201, self.call_resa202,\n", "             self.call_resa250])\n\t        self.kea.set_pool.assert_has_calls([self.call_pool250])\n\t        self.kea.commit.assert_called()\n\t        self.kea.push.assert_called()\n"]}
{"filename": "tests/unit/__init__.py", "chunked_list": []}
{"filename": "tests/unit/test_kea.py", "chunked_list": ["import unittest\n\tfrom copy import deepcopy\n\tfrom unittest.mock import MagicMock, call\n\tfrom netboxkea.kea.app import DHCP4App\n\tfrom netboxkea.kea.exceptions import KeaClientError, SubnetNotFound\n\tclass TestKea(unittest.TestCase):\n\t    def _set_std_subnet(self):\n\t        self.kea.set_subnet(100, {'subnet': '192.168.0.0/24'})\n\t    def _set_std_resa(self):\n\t        self.kea.set_reservation(100, 200, {\n", "            'ip-address': '192.168.0.1', 'hw-address': '11:22:33:44:55:66',\n\t            'hostname': 'pc.lan'})\n\t    def _set_std_pool(self):\n\t        self.kea.set_pool(100, 250, {'pool': '192.168.0.100-192.168.0.199'})\n\t    def setUp(self):\n\t        self.kea = DHCP4App('http://keasrv/api')\n\t        self.req = MagicMock()\n\t        self.kea.api._request_kea = self.req\n\t        self.srv_conf = {'Dhcp4': {}}\n\t        self.srv_check_res = True\n", "        def req_result(cmd, params=None):\n\t            match cmd:\n\t                case 'config-get':\n\t                    return deepcopy(self.srv_conf)\n\t                case 'config-set':\n\t                    self.srv_conf = deepcopy(params)\n\t                case 'config-test':\n\t                    return self.srv_check_res\n\t                case 'config-write':\n\t                    pass\n", "                case _:\n\t                    raise ValueError(cmd)\n\t        self.req.side_effect = req_result\n\t        self.kea.pull()\n\t        self.req.reset_mock()\n\t    def test_01_pull(self):\n\t        self.assertEqual(self.kea.conf, {'subnet4': []})\n\t        self.assertEqual(self.kea.commit_conf, self.kea.conf)\n\t    def test_02_commit(self):\n\t        newconf = {'subnet4': [{'garbage': True}]}\n", "        self.kea.conf = deepcopy(newconf)\n\t        self.kea.commit()\n\t        self.req.assert_called_once_with('config-test', {'Dhcp4': newconf})\n\t        self.assertEqual(self.kea.conf, self.kea.commit_conf)\n\t    def test_03_push_wo_commit(self):\n\t        self.kea.push()\n\t        self.req.assert_not_called()\n\t    def test_04_push_w_commit(self):\n\t        newconf = {'subnet4': [{'garbage': True}]}\n\t        self.kea.conf = deepcopy(newconf)\n", "        self.kea.commit()\n\t        self.kea.push()\n\t        calls = [call('config-test', {'Dhcp4': newconf}),\n\t                 call('config-set', {'Dhcp4': newconf}),\n\t                 call('config-write', {'Dhcp4': newconf})]\n\t        self.req.has_calls(calls)\n\t        self.assertEqual(self.srv_conf['Dhcp4'], newconf)\n\t        self.assertEqual(self.kea.conf, self.kea.commit_conf)\n\t    def test_10_set_subnet(self):\n\t        expected = {'subnet4': [\n", "            {'id': 100, 'subnet': '192.168.0.0/24', 'pools': [],\n\t             'reservations': []}]}\n\t        self._set_std_subnet()\n\t        self.kea.push()\n\t        self.assertEqual(self.srv_conf['Dhcp4'], expected)\n\t    def test_11_set_subnet_replace(self):\n\t        self.kea.set_subnet(100, {'subnet': '10.0.0.0/8'})\n\t        self._set_std_subnet()\n\t        self.kea.push()\n\t        self.assertEqual(\n", "            self.srv_conf['Dhcp4']['subnet4'][0]['subnet'], '192.168.0.0/24')\n\t        self.assertEqual(len(self.srv_conf['Dhcp4']['subnet4']), 1)\n\t    def test_12_set_subnet_conflict(self):\n\t        self._set_std_subnet()\n\t        with self.assertRaises(KeaClientError):\n\t            self.kea.set_subnet(101, {'subnet': '192.168.0.0/24'})\n\t    def test_13_update_subnet_notfound(self):\n\t        with self.assertRaises(SubnetNotFound):\n\t            self.kea.update_subnet(100, {'subnet': '10.0.0.0/8', 'opt': 1})\n\t    def test_14_update_subnet_ok(self):\n", "        self._set_std_subnet()\n\t        self.kea.update_subnet(100, {'subnet': '192.168.0.0/24', 'opt': 1})\n\t        self.kea.push()\n\t        self.assertEqual(self.srv_conf['Dhcp4']['subnet4'][0]['opt'], 1)\n\t    def test_15_del_subnet(self):\n\t        self._set_std_subnet()\n\t        self.kea.del_subnet(100)\n\t        self.kea.push()\n\t        self.assertEqual(len(self.srv_conf['Dhcp4']['subnet4']), 0)\n\t    def test_16_del_all_subnets(self):\n", "        self._set_std_subnet()\n\t        self.kea.del_all_subnets()\n\t        self.kea.push()\n\t        self.assertEqual(len(self.srv_conf['Dhcp4']['subnet4']), 0)\n\t    def test_20_set_reservation(self):\n\t        expected = {'subnet4': [\n\t            {'id': 100, 'subnet': '192.168.0.0/24', 'pools': [],\n\t             'reservations': [{\n\t                'ip-address': '192.168.0.1', 'hw-address': '11:22:33:44:55:66',\n\t                'hostname': 'pc.lan', 'user-context': {\n", "                    'netbox_ip_address_id': 200}}]\n\t             }]}\n\t        self._set_std_subnet()\n\t        self._set_std_resa()\n\t        self.kea.push()\n\t        self.assertEqual(self.srv_conf['Dhcp4'], expected)\n\t    def test_21_set_reservation_replace(self):\n\t        self._set_std_subnet()\n\t        self._set_std_resa()\n\t        self.kea.set_reservation(100, 200, {\n", "            'ip-address': '192.168.0.9', 'hw-address': '11:22:33:44:55:66',\n\t            'hostname': 'pc.lan'})\n\t        self.kea.push()\n\t        self.assertEqual(\n\t            self.srv_conf['Dhcp4']['subnet4'][0]['reservations'][0]\n\t            ['ip-address'], '192.168.0.9')\n\t        self.assertEqual(len(\n\t            self.srv_conf['Dhcp4']['subnet4'][0]['reservations']), 1)\n\t    def test_22_set_reservation_subnet_not_found(self):\n\t        with self.assertRaises(SubnetNotFound):\n", "            self._set_std_resa()\n\t    def test_23_set_reservation_conflict_hw(self):\n\t        self._set_std_subnet()\n\t        self._set_std_resa()\n\t        with self.assertRaises(KeaClientError):\n\t            self.kea.set_reservation(100, 201, {\n\t                'ip-address': '192.168.0.2', 'hw-address': '11:22:33:44:55:66',\n\t                'hostname': 'pc2.lan'})\n\t    def test_24_set_reservation_conflict_ip(self):\n\t        self._set_std_subnet()\n", "        self._set_std_resa()\n\t        with self.assertRaises(KeaClientError):\n\t            self.kea.set_reservation(100, 201, {\n\t                'ip-address': '192.168.0.1', 'hw-address': '11:22:33:33:22:11',\n\t                'hostname': 'pc2.lan'})\n\t    def test_25_set_reservation_no_conflict_ip(self):\n\t        self.srv_conf['Dhcp4']['ip-reservations-unique'] = False\n\t        self.kea.pull()\n\t        self._set_std_subnet()\n\t        self._set_std_resa()\n", "        self.kea.set_reservation(100, 201, {\n\t            'ip-address': '192.168.0.1', 'hw-address': '11:22:33:33:22:11',\n\t            'hostname': 'pc2.lan'})\n\t        self.assertEqual(len(self.kea.conf['subnet4'][0]['reservations']), 2)\n\t    def test_26_del_reservation(self):\n\t        self._set_std_subnet()\n\t        self._set_std_resa()\n\t        self.kea.del_resa(200)\n\t        self.assertEqual(len(self.kea.conf['subnet4'][0]['reservations']), 0)\n\t    def test_30_set_pool(self):\n", "        expected = {'subnet4': [\n\t            {'id': 100, 'subnet': '192.168.0.0/24', 'pools': [{\n\t                'pool': '192.168.0.100-192.168.0.199',\n\t                'user-context': {'netbox_ip_range_id': 250}\n\t                }], 'reservations': []}]}\n\t        self._set_std_subnet()\n\t        self._set_std_pool()\n\t        self.kea.push()\n\t        self.assertEqual(self.srv_conf['Dhcp4'], expected)\n\t    def test_33_set_pool_conflict_overlap(self):\n", "        self._set_std_subnet()\n\t        self._set_std_pool()\n\t        with self.assertRaises(KeaClientError):\n\t            self.kea.set_pool(100, 251, {'pool': '192.168.0.50-192.168.0.100'})\n\t        with self.assertRaises(KeaClientError):\n\t            self.kea.set_pool(100, 251, {\n\t                'pool': '192.168.0.199-192.168.0.250'})\n\t    def test_35_del_pool(self):\n\t        self._set_std_subnet()\n\t        self._set_std_pool()\n", "        self.kea.del_pool(250)\n\t        self.assertEqual(len(self.kea.conf['subnet4'][0]['pools']), 0)\n"]}
{"filename": "src/netboxkea/config.py", "chunked_list": ["import logging\n\timport sys\n\tfrom argparse import ArgumentParser\n\tfrom dataclasses import dataclass, field\n\ttry:\n\t    import tomllib\n\texcept ModuleNotFoundError:\n\t    import tomli as tomllib\n\tfrom .__about__ import __version__\n\t@dataclass(frozen=True)\n", "class Config:\n\t    config_file: str = None\n\t    check_only: bool = False\n\t    full_sync_at_startup: bool = False\n\t    listen: bool = False\n\t    bind: str = '127.0.0.1'\n\t    port: int = 8001\n\t    secret: str = None\n\t    secret_header: str = 'X-netbox2kea-secret'\n\t    log_level: str = 'warning'\n", "    ext_log_level: str = 'warning'\n\t    syslog_level_prefix: bool = False\n\t    kea_url: str = None\n\t    netbox_url: str = None\n\t    netbox_token: str = None\n\t    prefix_filter: dict = field(default_factory=lambda: {\n\t        'cf_dhcp_enabled': True})\n\t    ipaddress_filter: dict = field(default_factory=lambda: {'status': 'dhcp'})\n\t    iprange_filter: dict = field(default_factory=lambda: {'status': 'dhcp'})\n\t    subnet_prefix_map: dict = field(default_factory=lambda: {\n", "        'option-data.routers': 'custom_fields.dhcp_option_data_routers',\n\t        'option-data.domain-search':\n\t            'custom_fields.dhcp_option_data_domain_search',\n\t        'option-data.domain-name-servers':\n\t            'custom_fields.dhcp_option_data_domain_name_servers',\n\t        'next-server': 'custom_fields.dhcp_next_server',\n\t        'boot-file-name': 'custom_fields.dhcp_boot_file_name',\n\t        'valid-lifetime': 'custom_fields.dhcp_valid_lifetime'})\n\t    pool_iprange_map: dict = field(default_factory=lambda: {})\n\t    reservation_ipaddr_map: dict = field(default_factory=lambda: {\n", "        # Get MAC address from custom field, fallback to assigned interface\n\t        'hw-address': ['custom_fields.dhcp_reservation_hw_address',\n\t                       'assigned_object.mac_address'],\n\t        # Get hostname from DNS name, fallback to device/vm name\n\t        'hostname': ['dns_name', 'assigned_object.device.name',\n\t                     'assigned_object.virtual_machine.name']\n\t        })\n\tdef get_config():\n\t    settings = {}\n\t    parser = ArgumentParser()\n", "    parser.add_argument(\n\t        '--version', action='version', version=f'Version {__version__}')\n\t    parser.add_argument('-c', '--config-file', help='configuration file')\n\t    parser.add_argument('-n', '--netbox-url', help='')\n\t    parser.add_argument('-t', '--netbox-token', help='')\n\t    parser.add_argument('-k', '--kea-url', help='')\n\t    parser.add_argument(\n\t        '-l', '--listen', action='store_true', default=None, help='')\n\t    parser.add_argument('-b', '--bind', help='')\n\t    parser.add_argument('-p', '--port', type=int, help='')\n", "    parser.add_argument(\n\t        '--secret', help=f'Default header: {Config.secret_header}')\n\t    parser.add_argument(\n\t        '-s', '--sync-now', action='store_true', dest='full_sync_at_startup',\n\t        default=None, help='')\n\t    parser.add_argument(\n\t        '--check', action='store_true', dest='check_only', default=None,\n\t        help='')\n\t    parser.add_argument(\n\t        '-v', '--verbose', action='count', default=0,\n", "        help='Increase verbosity. May be specified up to 3 times')\n\t    # TODO: parser.add_argument('-f', '--foreground', help='')\n\t    args = parser.parse_args()\n\t    # Load TOML config file\n\t    if args.config_file is not None:\n\t        with open(args.config_file, 'rb') as f:\n\t            tomlconf = tomllib.load(f)\n\t        settings.update(tomlconf)\n\t    # Load non-None command line arguments\n\t    if args.verbose == 1:\n", "        args.log_level = 'info'\n\t    elif args.verbose == 2:\n\t        args.log_level = 'debug'\n\t        settings['ext_log_level'] = 'info'\n\t    elif args.verbose >= 3:\n\t        args.log_level = 'debug'\n\t        settings['ext_log_level'] = 'debug'\n\t    del args.verbose\n\t    settings.update({k: v for k, v in args.__dict__.items() if v is not None})\n\t    # Check existence of required settings\n", "    for attr in ('kea_url', 'netbox_url'):\n\t        if attr not in settings:\n\t            logging.fatal(\n\t                f'Setting \"{attr}\" not found, neither on command line '\n\t                'arguments nor in configuration file (if any)')\n\t            sys.exit(1)\n\t    conf = Config(**settings)\n\t    if not set(['hw-address', 'hostname']).issubset(\n\t            conf.reservation_ipaddr_map):\n\t        logging.fatal(\n", "            'Setting \"reservation_ipaddr_map\" must have a mapping for '\n\t            '\"hw-address\" and \"hostname\" DHCP parameters')\n\t        sys.exit(1)\n\t    return conf\n"]}
{"filename": "src/netboxkea/logger.py", "chunked_list": ["import logging\n\timport syslog\n\t_SD_DAEMON_MAP = {\n\t    logging.DEBUG: syslog.LOG_DEBUG,\n\t    logging.INFO: syslog.LOG_INFO,\n\t    logging.WARNING: syslog.LOG_WARNING,\n\t    logging.ERROR: syslog.LOG_ERR,\n\t    logging.CRITICAL: syslog.LOG_CRIT\n\t    }\n\tdef init_logger(log_level_name, ext_log_level_name, syslog_level_prefix):\n", "    \"\"\" Configure loggers \"\"\"\n\t    log_level = _level_name_to_int(log_level_name)\n\t    if syslog_level_prefix:\n\t        logger = logging.getLogger()\n\t        logger.setLevel(log_level)\n\t        ch = logging.StreamHandler()\n\t        ch.setFormatter(_SdDaemonFormatter())\n\t        logger.addHandler(ch)\n\t    else:\n\t        logging.basicConfig(\n", "            level=log_level, format='%(asctime)s [%(levelname)s] %(message)s')\n\t        logger = logging.getLogger()\n\t    # Log level for external modules\n\t    ext_log_level = _level_name_to_int(ext_log_level_name)\n\t    logging.getLogger('urllib3.connectionpool').setLevel(ext_log_level)\n\tdef _level_name_to_int(name):\n\t    num = getattr(logging, name.upper(), None)\n\t    if not isinstance(num, int):\n\t        raise ValueError(f'Invalid log level name: {name}')\n\t    return num\n", "class _SdDaemonFormatter(logging.Formatter):\n\t    def format(self, record):\n\t        sd_levelno = _SD_DAEMON_MAP.get(record.levelno, syslog.LOG_INFO)\n\t        return f'<{sd_levelno}>' + super().format(record)\n"]}
{"filename": "src/netboxkea/entry_point.py", "chunked_list": ["import logging\n\tfrom .config import get_config\n\tfrom .connector import Connector\n\tfrom .kea.app import DHCP4App\n\tfrom .listener import WebhookListener\n\tfrom .logger import init_logger\n\tfrom .netbox import NetboxApp\n\tdef run():\n\t    conf = get_config()\n\t    init_logger(conf.log_level, conf.ext_log_level, conf.syslog_level_prefix)\n", "    # Instanciate source, sink and connector\n\t    logging.info(f'netbox: {conf.netbox_url}, kea: {conf.kea_url}')\n\t    nb = NetboxApp(\n\t        conf.netbox_url, conf.netbox_token, prefix_filter=conf.prefix_filter,\n\t        iprange_filter=conf.iprange_filter,\n\t        ipaddress_filter=conf.ipaddress_filter)\n\t    kea = DHCP4App(conf.kea_url)\n\t    conn = Connector(\n\t        nb, kea, conf.subnet_prefix_map, conf.pool_iprange_map,\n\t        conf.reservation_ipaddr_map, check=conf.check_only)\n", "    if not conf.full_sync_at_startup and not conf.listen:\n\t        logging.warning('Neither full sync nor listen mode has been asked')\n\t    # Start a full synchronisation\n\t    if conf.full_sync_at_startup:\n\t        logging.info('Start full sync')\n\t        conn.sync_all()\n\t    # Start listening for events\n\t    if conf.listen:\n\t        logging.info(f'Listen for events on {conf.bind}:{conf.port}')\n\t        server = WebhookListener(\n", "            connector=conn, host=conf.bind, port=conf.port, secret=conf.secret,\n\t            secret_header=conf.secret_header)\n\t        server.run()\n"]}
{"filename": "src/netboxkea/netbox.py", "chunked_list": ["import pynetbox\n\tfrom ipaddress import ip_interface, ip_network\n\tclass NetboxApp:\n\t    def __init__(self, url, token, prefix_filter={}, iprange_filter={},\n\t                 ipaddress_filter={'status': 'dhcp'}):\n\t        self.nb = pynetbox.api(url, token=token)\n\t        self.prefix_filter = prefix_filter\n\t        self.iprange_filter = iprange_filter\n\t        self.ipaddress_filter = ipaddress_filter\n\t    def prefix(self, id_):\n", "        return self.nb.ipam.prefixes.get(id=id_, **self.prefix_filter)\n\t    def prefixes(self, contains):\n\t        return self.nb.ipam.prefixes.filter(\n\t            **self.prefix_filter, contains=contains)\n\t    def all_prefixes(self):\n\t        return self.nb.ipam.prefixes.filter(**self.prefix_filter)\n\t    def ip_range(self, id_):\n\t        return self.nb.ipam.ip_ranges.get(id=id_, **self.iprange_filter)\n\t    def ip_ranges(self, parent):\n\t        # Emulate \"parent\" filter as NetBox API doesn’t support it on\n", "        # ip-ranges objects (v3.4).\n\t        parent_net = ip_network(parent)\n\t        for r in self.nb.ipam.ip_ranges.filter(\n\t                parent=parent, **self.iprange_filter):\n\t            if (ip_interface(r.start_address) in parent_net\n\t                    and ip_interface(r.end_address) in parent_net):\n\t                yield r\n\t    def ip_address(self, id_):\n\t        return self.nb.ipam.ip_addresses.get(id=id_, **self.ipaddress_filter)\n\t    def ip_addresses(self, **filters):\n", "        if not filters:\n\t            raise ValueError(\n\t                'Netboxapp.ip_addresses() requires at least one keyword arg')\n\t        for i in self.nb.ipam.ip_addresses.filter(\n\t                **self.ipaddress_filter, **filters):\n\t            yield i\n"]}
{"filename": "src/netboxkea/listener.py", "chunked_list": ["import logging\n\tfrom json.decoder import JSONDecodeError\n\timport bottle\n\tclass WebhookListener:\n\t    \"\"\" Listen for netbox webhook requests and change DHCP configuration \"\"\"\n\t    def __init__(self, connector, host='127.0.0.1', port=8001, secret=None,\n\t                 secret_header=None):\n\t        self.conn = connector\n\t        self.host = host\n\t        self.port = port\n", "        self.secret = secret\n\t        self.secret_header = secret_header\n\t    def run(self):\n\t        \"\"\" Start web server \"\"\"\n\t        @bottle.route('/event/<name>/', 'POST')\n\t        def new_event(name):\n\t            \"\"\" Define an all-in-one route for our web server \"\"\"\n\t            logging.debug(f'Receive data on /event/{name}/')\n\t            # import json\n\t            # body = bottle.request.body.getvalue()\n", "            # try:\n\t            #     print(json.dumps(json.loads(body), indent=4))\n\t            # except Exception:\n\t            #     print(body.decode())\n\t            if (self.secret_header and bottle.request.get_header(\n\t                    self.secret_header) != self.secret):\n\t                self._abort(403, 'wrong secret or secret header')\n\t            # Parse JSON body from request\n\t            try:\n\t                body = bottle.request.json\n", "            except JSONDecodeError:\n\t                body = bottle.request.body.getvalue().decode()\n\t                self._abort(400, f'malformed body (not JSON):  {body}')\n\t            logging.debug(f'Parsed JSON request: {body}')\n\t            try:\n\t                model, id_, event = (\n\t                    body['model'], body['data']['id'], body['event'])\n\t            except KeyError as e:\n\t                self._abort(400, f'request missing key: {e}')\n\t            try:\n", "                sync_func = getattr(self.conn, f'sync_{model}')\n\t            except AttributeError:\n\t                self._abort(400, f'unsupported target \"{model}\"')\n\t            else:\n\t                logging.info(f'process event: {model} id={id_} {event}')\n\t                # Reload DHCP config before applying any changes\n\t                self.conn.reload_dhcp_config()\n\t                sync_func(id_)\n\t            bottle.response.status = 201\n\t            # Push change to DHCP server\n", "            self.conn.push_to_dhcp()\n\t        # very basic health check, basically proves bottle is already/still running\n\t        # enough for Kubernetes probes\n\t        @bottle.route('/health/')\n\t        def health():\n\t            return 'ok'\n\t        # start server\n\t        bottle.run(host=self.host, port=self.port)\n\t    def _abort(self, code, msg):\n\t        logging.error(msg)\n", "        bottle.abort(code, msg)\n"]}
{"filename": "src/netboxkea/__init__.py", "chunked_list": []}
{"filename": "src/netboxkea/connector.py", "chunked_list": ["import logging\n\tfrom ipaddress import ip_interface\n\tfrom .kea.exceptions import (KeaError, KeaClientError, SubnetNotEqual,\n\t                             SubnetNotFound)\n\tdef _get_nested(obj, attrs, sep='.'):\n\t    \"\"\" Get value from a nested list of attributes or keys separated by sep \"\"\"\n\t    value = obj\n\t    for a in attrs.split(sep):\n\t        # getattr must be tried before dict.get because it is able to trigger\n\t        # additionnal queries to netbox API.\n", "        try:\n\t            value = getattr(value, a)\n\t        except AttributeError:\n\t            value = value[a]\n\t    return value\n\tdef _set_dhcp_attr(dhcp_item, key, value):\n\t    \"\"\"\n\t    Set value to DHCP item dictionary. Key may be nested keys separated\n\t    by dots, in which case each key represents a nested dictionary (or list, if\n\t    the parent attribut is known to use a list).\n", "    \"\"\"\n\t    k1, _, k2 = key.partition('.')\n\t    if not k2:\n\t        dhcp_item[key] = value\n\t    elif k1 in ['option-data']:\n\t        # Some keys hold a list of name/data dicts\n\t        dhcp_item.setdefault(k1, []).append(\n\t            {'name': k2, 'data': value})\n\t    else:\n\t        dhcp_item.setdefault(k1, {})[k2] = value\n", "def _mk_dhcp_item(nb_obj, mapping):\n\t    \"\"\" Convert a netbox object to a DHCP dictionary item \"\"\"\n\t    dhcp_item = {}\n\t    for dhcp_attr, nb_attr in mapping.items():\n\t        # Get value from netbox object\n\t        attrs = [nb_attr] if isinstance(nb_attr, str) else nb_attr\n\t        # Map value is expected to be list of attributes. The first\n\t        # existing and non-null attribute will be used as the DHCP value\n\t        value = None\n\t        for a in attrs:\n", "            try:\n\t                value = _get_nested(nb_obj, a)\n\t            except (TypeError, KeyError):\n\t                continue\n\t            if value:\n\t                break\n\t        # Set value to DHCP setting\n\t        # Kea don’t like None value (TODO even if JSON converts it to \"null\"?)\n\t        if value is not None:\n\t            _set_dhcp_attr(dhcp_item, dhcp_attr, value)\n", "    return dhcp_item\n\tclass Connector:\n\t    \"\"\" Main class that connects Netbox objects to Kea DHCP config items \"\"\"\n\t    def __init__(self, nb, kea, prefix_subnet_map, pool_iprange_map,\n\t                 reservation_ipaddr_map, check=False):\n\t        self.nb = nb\n\t        self.kea = kea\n\t        self.subnet_prefix_map = prefix_subnet_map\n\t        self.pool_iprange_map = pool_iprange_map\n\t        self.reservation_ipaddr_map = reservation_ipaddr_map\n", "        self.check = check\n\t    def sync_all(self):\n\t        \"\"\" Replace current DHCP configuration by a new generated one \"\"\"\n\t        self.kea.pull()\n\t        self.kea.del_all_subnets()\n\t        # Create DHCP configuration for each prefix\n\t        all_failed = None\n\t        for p in self.nb.all_prefixes():\n\t            if all_failed is None:\n\t                all_failed = True\n", "            pl = f'prefix {p}: '\n\t            logging.debug(f'{pl}generate DHCP config')\n\t            # Speed up things by disabling auto-commit\n\t            self.kea.auto_commit = False\n\t            try:\n\t                self._prefix_to_subnet(p, fullsync=True)\n\t            except KeaError as e:\n\t                logging.error(f'{pl}config failed. Error: {e}')\n\t                continue\n\t            # Make intermediate commits only when not in check mode to avoid\n", "            # false errors of missing, not yet created, subnets.\n\t            if not self.check:\n\t                try:\n\t                    self.kea.commit()\n\t                except KeaError as e:\n\t                    logging.error(f'{pl}commit failed. Error: {e}')\n\t                    # Retry with auto-commit enabled to catch the faulty item\n\t                    logging.warning(f'{pl}retry with auto commit on')\n\t                    self.kea.auto_commit = True\n\t                    try:\n", "                        self._prefix_to_subnet(p, fullsync=True)\n\t                    except KeaError as e:\n\t                        logging.error(f'{pl}config failed. Error: {e}')\n\t                        continue\n\t            all_failed = False\n\t        self.kea.auto_commit = True\n\t        if all_failed is not True:\n\t            self.push_to_dhcp()\n\t    def push_to_dhcp(self):\n\t        if self.check:\n", "            logging.info('check mode on: config will NOT be pushed to server')\n\t        else:\n\t            self.kea.push()\n\t    def reload_dhcp_config(self):\n\t        self.kea.pull()\n\t    def sync_prefix(self, id_):\n\t        p = self.nb.prefix(id_)\n\t        self._prefix_to_subnet(p) if p else self.kea.del_subnet(id_)\n\t    def sync_iprange(self, id_):\n\t        r = self.nb.ip_range(id_)\n", "        self._iprange_to_pool(r) if r else self.kea.del_pool(id_)\n\t    def sync_ipaddress(self, id_):\n\t        i = self.nb.ip_address(id_)\n\t        self._ipaddr_to_resa(i) if i else self.kea.del_resa(id_)\n\t    def sync_interface(self, id_):\n\t        for i in self.nb.ip_addresses(interface_id=id_):\n\t            self.sync_ipaddress(i.id)\n\t    def sync_device(self, id_):\n\t        for i in self.nb.ip_addresses(device_id=id_):\n\t            self.sync_ipaddress(i.id)\n", "    def sync_vminterface(self, id_):\n\t        for i in self.nb.ip_addresses(vminterface_id=id_):\n\t            self.sync_ipaddress(i.id)\n\t    def sync_virtualmachine(self, id_):\n\t        for i in self.nb.ip_addresses(virtual_machine_id=id_):\n\t            self.sync_ipaddress(i.id)\n\t    def _prefix_to_subnet(self, pref, fullsync=False):\n\t        subnet = _mk_dhcp_item(pref, self.subnet_prefix_map)\n\t        subnet['subnet'] = pref.prefix\n\t        if not fullsync:\n", "            try:\n\t                self.kea.update_subnet(pref.id, subnet)\n\t            except (SubnetNotEqual, SubnetNotFound):\n\t                # Subnet address has changed or subnet is missing, recreate it\n\t                fullsync = True\n\t        if fullsync:\n\t            self.kea.set_subnet(pref.id, subnet)\n\t            # Add host reservations\n\t            for i in self.nb.ip_addresses(parent=pref.prefix):\n\t                try:\n", "                    self._ipaddr_to_resa(i, prefix=pref)\n\t                except KeaClientError as e:\n\t                    logging.error(f'prefix {pref} > IP {i}: {e}')\n\t            # Add pools\n\t            for r in self.nb.ip_ranges(parent=pref.prefix):\n\t                try:\n\t                    self._iprange_to_pool(r, prefix=pref)\n\t                except KeaClientError as e:\n\t                    logging.error(f'prefix {pref} > range {r}: {e}')\n\t    def _iprange_to_pool(self, iprange, prefix=None):\n", "        prefixes = [prefix] if prefix else self.nb.prefixes(\n\t            contains=iprange.start_address)\n\t        pool = _mk_dhcp_item(iprange, self.pool_iprange_map)\n\t        start = str(ip_interface(iprange.start_address).ip)\n\t        end = str(ip_interface(iprange.end_address).ip)\n\t        pool['pool'] = f'{start}-{end}'\n\t        for pref in prefixes:\n\t            try:\n\t                self.kea.set_pool(pref.id, iprange.id, pool)\n\t            except SubnetNotFound:\n", "                if not prefix:\n\t                    logging.warning(\n\t                        f'subnet {pref.prefix} is missing, sync it again')\n\t                    self._prefix_to_subnet(pref, fullsync=True)\n\t                else:\n\t                    logging.error(f'requested subnet {pref.prefix} not found')\n\t    def _ipaddr_to_resa(self, ip, prefix=None):\n\t        prefixes = [prefix] if prefix else self.nb.prefixes(\n\t            contains=ip.address)\n\t        resa = _mk_dhcp_item(ip, self.reservation_ipaddr_map)\n", "        if not resa.get('hw-address'):\n\t            self.kea.del_resa(ip.id)\n\t            return\n\t        resa['ip-address'] = str(ip_interface(ip.address).ip)\n\t        for pref in prefixes:\n\t            try:\n\t                self.kea.set_reservation(pref.id, ip.id, resa)\n\t            except SubnetNotFound:\n\t                if not prefix:\n\t                    logging.warning(\n", "                        f'subnet {pref.prefix} is missing, sync it again')\n\t                    self._prefix_to_subnet(pref)\n\t                else:\n\t                    logging.error(f'requested subnet {pref.prefix} not found')\n"]}
{"filename": "src/netboxkea/__about__.py", "chunked_list": ["__version__ = \"0.0.1a10\"\n"]}
{"filename": "src/netboxkea/kea/app.py", "chunked_list": ["import logging\n\tfrom copy import deepcopy\n\tfrom ipaddress import ip_interface, ip_network\n\tfrom .api import DHCP4API, FileAPI\n\tfrom .exceptions import (DuplicateValue, KeaCmdError, SubnetNotEqual,\n\t                         SubnetNotFound)\n\t# Kea configuration keys\n\tSUBNETS = 'subnet4'\n\tUSR_CTX = 'user-context'\n\tPOOLS = 'pools'\n", "RESAS = 'reservations'\n\tPREFIX = 'id'\n\tIP_RANGE = 'netbox_ip_range_id'\n\tIP_ADDR = 'netbox_ip_address_id'\n\tdef _autocommit(func):\n\t    \"\"\" Decorator to autocommit changes after method execution \"\"\"\n\t    def wrapper(self, *args, **kwargs):\n\t        res = func(self, *args, **kwargs)\n\t        commit_arg = kwargs.get('commit')\n\t        if commit_arg is True or (commit_arg is None and self.auto_commit):\n", "            self.commit()\n\t        return res\n\t    return wrapper\n\tdef _boundaries(ip_range):\n\t    \"\"\" Return a tuple of first and last ip_interface of the pool \"\"\"\n\t    # pool may be expressed by a \"-\" seperated range or by a network\n\t    try:\n\t        start, end = ip_range.split('-')\n\t    except ValueError:\n\t        net = ip_network(ip_range)\n", "        return ip_interface(net.network_address), ip_interface(\n\t            net.broadcast_address)\n\t    else:\n\t        return ip_interface(start), ip_interface(end)\n\tclass DHCP4App:\n\t    def __init__(self, url=None):\n\t        if url.startswith('http://') or url.startswith('https://'):\n\t            self.api = DHCP4API(url)\n\t        elif url.startswith('file://'):\n\t            self.api = FileAPI(url.removeprefix('file://'))\n", "        else:\n\t            raise ValueError(\n\t                'Kea URL must starts either with \"http(s)://\" or \"file://\"')\n\t        self.conf = None\n\t        self.commit_conf = None\n\t        self._has_commit = False\n\t        self.auto_commit = True\n\t    def pull(self):\n\t        \"\"\" Fetch configuration from DHCP server  \"\"\"\n\t        logging.info('pull running config from DHCP server')\n", "        self.conf = self.api.get_conf()\n\t        # Set minimal expected keys\n\t        self.conf.setdefault(SUBNETS, [])\n\t        for s in self.conf[SUBNETS]:\n\t            for r in s.setdefault(RESAS, []):\n\t                r.setdefault(USR_CTX, {}).setdefault(IP_ADDR, None)\n\t            for p in s.setdefault(POOLS, []):\n\t                p.setdefault(USR_CTX, {}).setdefault(IP_RANGE, None)\n\t        self.commit_conf = deepcopy(self.conf)\n\t        self.ip_uniqueness = self.conf.get('ip-reservations-unique', True)\n", "    def commit(self):\n\t        \"\"\" Record changes to the configuration. Return True if success \"\"\"\n\t        try:\n\t            logging.debug('check configuration')\n\t            self.api.raise_conf_error(self.conf)\n\t        except KeaCmdError:\n\t            # Drop current working config\n\t            logging.error('config check failed, drop uncommited changes')\n\t            self.conf = deepcopy(self.commit_conf)\n\t            raise\n", "        else:\n\t            logging.debug('commit configuration')\n\t            self.commit_conf = deepcopy(self.conf)\n\t            self._has_commit = True\n\t            return True\n\t    def push(self):\n\t        \"\"\" Update DHCP server configuration \"\"\"\n\t        if self._has_commit:\n\t            logging.info('push configuration to runtime DHCP server')\n\t            try:\n", "                self.api.set_conf(self.commit_conf)\n\t                logging.info('write configuration to permanent file')\n\t                self.api.write_conf()\n\t            except KeaCmdError as e:\n\t                logging.error(f'config push or write rejected: {e}')\n\t            self._has_commit = None\n\t        else:\n\t            logging.debug('no commit to push')\n\t    def _check_commit(self, commit=None):\n\t        \"\"\" Commit conf if required by argument or instance attribute \"\"\"\n", "        if commit is True or (commit is None and self.auto_commit):\n\t            self.commit()\n\t    @_autocommit\n\t    def set_subnet(self, prefix_id, subnet_item):\n\t        \"\"\" Replace subnet with prefix ID or append a new one \"\"\"\n\t        self._set_subnet(prefix_id, subnet_item, only_update_options=False)\n\t    @_autocommit\n\t    def update_subnet(self, prefix_id, subnet_item):\n\t        \"\"\"\n\t        Update subnet options (preserve current reservations and pools). Raise\n", "        SubnetNotEqual if network address differs, or SubnetNotFound if no\n\t        subnet prefix ID matches.\n\t        \"\"\"\n\t        self._set_subnet(prefix_id, subnet_item, only_update_options=True)\n\t    def _set_subnet(self, prefix_id, subnet_item, only_update_options):\n\t        \"\"\" Update subnet options, replace subnet or append a new one \"\"\"\n\t        try:\n\t            subnet = subnet_item['subnet']\n\t        except KeyError as e:\n\t            raise TypeError(f'Missing mandatory subnet key: {e}')\n", "        sfound = None\n\t        for s in self.conf[SUBNETS]:\n\t            if s[PREFIX] == prefix_id:\n\t                sfound = s\n\t                if s['subnet'] == subnet:\n\t                    # No network addr change, no need to inspect other subnets\n\t                    break\n\t                elif only_update_options:\n\t                    raise SubnetNotEqual(f'subnet {s[\"subnet\"]} ≠ {subnet}')\n\t            # Continue in order to check duplicates\n", "            elif s['subnet'] == subnet:\n\t                raise DuplicateValue(f'duplicate subnet {subnet}')\n\t        subnet_item[PREFIX] = prefix_id\n\t        if sfound:\n\t            if only_update_options:\n\t                logging.info(f'subnet {subnet}: update with {subnet_item}')\n\t                # Preserve reservations and pools\n\t                subnet_item[RESAS] = sfound[RESAS]\n\t                subnet_item[POOLS] = sfound[POOLS]\n\t            else:\n", "                subnet_item.setdefault(RESAS, [])\n\t                subnet_item.setdefault(POOLS, [])\n\t                logging.info(f'subnet ID {prefix_id}: replace with {subnet}')\n\t            # Clear current subnet (except reservations and pools) in order to\n\t            # drop Kea default options, as they may conflict with our new\n\t            # settings (like min/max-valid-lifetime against valid-lifetime).\n\t            sfound.clear()\n\t            sfound.update(subnet_item)\n\t        elif only_update_options:\n\t            raise SubnetNotFound(f'subnet ID {prefix_id}')\n", "        else:\n\t            subnet_item.setdefault(RESAS, [])\n\t            subnet_item.setdefault(POOLS, [])\n\t            logging.info(f'subnets: add {subnet}, ID {prefix_id}')\n\t            self.conf[SUBNETS].append(subnet_item)\n\t    @_autocommit\n\t    def del_subnet(self, prefix_id, commit=None):\n\t        logging.info(f'subnets: remove subnet {prefix_id} if it exists')\n\t        self.conf[SUBNETS] = [\n\t            s for s in self.conf[SUBNETS] if s[PREFIX] != prefix_id]\n", "    @_autocommit\n\t    def del_all_subnets(self):\n\t        logging.info('delete all current subnets')\n\t        self.conf[SUBNETS].clear()\n\t    @_autocommit\n\t    def set_pool(self, prefix_id, iprange_id, pool_item):\n\t        \"\"\" Replace pool or append a new one \"\"\"\n\t        try:\n\t            start, end = pool_item['pool'].split('-')\n\t        except KeyError as e:\n", "            raise TypeError(f'Missing mandatory pool key: {e}')\n\t        pool_item.setdefault(USR_CTX, {})[IP_RANGE] = iprange_id\n\t        ip_start, ip_end = ip_interface(start), ip_interface(end)\n\t        def raise_conflict(p):\n\t            pl = p.get('pool')\n\t            if pl:\n\t                s, e = _boundaries(pl)\n\t                if s <= ip_start <= e or s <= ip_end <= e:\n\t                    raise DuplicateValue(f'overlaps existing pool {pl}')\n\t        self._set_subnet_item(\n", "            prefix_id, POOLS, IP_RANGE, iprange_id, pool_item, raise_conflict,\n\t            pool_item['pool'])\n\t    @_autocommit\n\t    def del_pool(self, iprange_id):\n\t        self._del_prefix_item(POOLS, IP_RANGE, iprange_id)\n\t    @_autocommit\n\t    def set_reservation(self, prefix_id, ipaddr_id, resa_item):\n\t        \"\"\" Replace host reservation or append a new one \"\"\"\n\t        for k in ('ip-address', 'hw-address'):\n\t            if k not in resa_item:\n", "                raise TypeError(f'Missing mandatory reservation key: {k}')\n\t        resa_item.setdefault(USR_CTX, {})[IP_ADDR] = ipaddr_id\n\t        def raise_conflict(r):\n\t            if r.get('hw-address') == resa_item['hw-address']:\n\t                raise DuplicateValue(\n\t                    f'duplicate hw-address={r[\"hw-address\"]}')\n\t            elif (self.ip_uniqueness and r.get('ip-address') ==\n\t                    resa_item['ip-address']):\n\t                raise DuplicateValue(f'duplicate address={r[\"ip-address\"]}')\n\t        self._set_subnet_item(\n", "            prefix_id, RESAS, IP_ADDR, ipaddr_id, resa_item, raise_conflict,\n\t            resa_item['hw-address'])\n\t    @_autocommit\n\t    def del_resa(self, ipaddr_id):\n\t        self._del_prefix_item(RESAS, IP_ADDR, ipaddr_id)\n\t    def _set_subnet_item(self, prefix_id, item_list, item_key, item_id, new,\n\t                         raise_conflict, display):\n\t        \"\"\" Replace either a pool or a host reservation \"\"\"\n\t        for s in self.conf[SUBNETS]:\n\t            found = None\n", "            if s[PREFIX] == prefix_id:\n\t                # Prefix found\n\t                for i in s[item_list]:\n\t                    if i[USR_CTX][item_key] == item_id:\n\t                        found = i\n\t                    # Continue in order to check duplicates\n\t                    else:\n\t                        raise_conflict(i)\n\t                if found:\n\t                    logging.info(\n", "                        f'subnet {prefix_id} > {item_list} > ID {item_id}: '\n\t                        f'replace with {display}')\n\t                    found.clear()\n\t                    found.update(new)\n\t                else:\n\t                    logging.info(\n\t                        f'subnet {prefix_id} > {item_list}: add {display}, '\n\t                        f'ID {item_id}')\n\t                    s[item_list].append(new)\n\t                break\n", "        else:\n\t            raise SubnetNotFound(f'subnet {prefix_id}')\n\t    def _del_prefix_item(self, item_list, item_key, item_id):\n\t        \"\"\" Delete item from all subnets. Silently ignore non-existent item \"\"\"\n\t        logging.info(f'{item_list}: delete resa {item_id} if it exists')\n\t        for s in self.conf[SUBNETS]:\n\t            s[item_list] = [\n\t                i for i in s[item_list] if i[USR_CTX][item_key] != item_id]\n"]}
{"filename": "src/netboxkea/kea/api.py", "chunked_list": ["import json\n\timport logging\n\timport requests\n\tfrom .exceptions import KeaServerError, KeaCmdError\n\tclass FileAPI:\n\t    \"\"\" Fake Kea DHCP4 API that keep configuration in memory and file \"\"\"\n\t    def __init__(self, uri):\n\t        self.config_file = uri\n\t        if self.config_file:\n\t            try:\n", "                with open(self.config_file, 'rb') as f:\n\t                    self.conf = json.load(f)\n\t            except FileNotFoundError:\n\t                self.conf = {}\n\t        else:\n\t            self.conf = {}\n\t    def get_conf(self):\n\t        return self.conf.get('Dhcp4', {})\n\t    def raise_conf_error(self, config):\n\t        json.dumps(config)\n", "    def set_conf(self, config):\n\t        self.raise_conf_error(config)\n\t        self.conf['Dhcp4'] = config\n\t    def write_conf(self):\n\t        if self.config_file:\n\t            with open(self.config_file, 'w') as f:\n\t                json.dump(self.conf, f, indent=4)\n\tclass DHCP4API:\n\t    def __init__(self, url):\n\t        self.url = url\n", "        self.session = requests.Session()\n\t    def _request_kea(self, command, arguments={}):\n\t        \"\"\" Send command to Kea APP \"\"\"\n\t        payload = {'command': command, 'service': ['dhcp4']}\n\t        if arguments:\n\t            payload['arguments'] = arguments\n\t        try:\n\t            r = self.session.post(self.url, json=payload)\n\t            r.raise_for_status()\n\t            rj = r.json()\n", "        except requests.exceptions.RequestException as e:\n\t            raise KeaServerError(f'API error: {e}')\n\t        # One single command should return a list with one single item\n\t        assert len(rj) == 1\n\t        rj = rj.pop(0)\n\t        result, text = rj['result'], rj.get('text')\n\t        if result != 0:\n\t            raise KeaCmdError(f'command \"{command}\" returns \"{text}\"')\n\t        else:\n\t            logging.debug(f'command \"{command}\" OK (text: {text})')\n", "            return rj.get('arguments')\n\t    def get_conf(self):\n\t        \"\"\" Return configuration from Kea \"\"\"\n\t        return self._request_kea('config-get')['Dhcp4']\n\t    def raise_conf_error(self, config):\n\t        \"\"\" Test configuration and raise errors \"\"\"\n\t        self._request_kea('config-test', {'Dhcp4': config})\n\t    def set_conf(self, config):\n\t        \"\"\" Set configuration on DHCP server \"\"\"\n\t        self._request_kea('config-set', {'Dhcp4': config})\n", "    def write_conf(self):\n\t        \"\"\" On DHCP server write configuration to persitent storage \"\"\"\n\t        self._request_kea('config-write')\n"]}
{"filename": "src/netboxkea/kea/__init__.py", "chunked_list": []}
{"filename": "src/netboxkea/kea/exceptions.py", "chunked_list": ["class KeaError(Exception):\n\t    pass\n\tclass KeaServerError(KeaError):\n\t    pass\n\tclass KeaClientError(KeaError):\n\t    pass\n\tclass SubnetNotEqual(KeaError):\n\t    pass\n\tclass SubnetNotFound(KeaClientError):\n\t    pass\n", "class DuplicateValue(KeaClientError):\n\t    pass\n\tclass KeaCmdError(KeaClientError):\n\t    pass\n"]}
