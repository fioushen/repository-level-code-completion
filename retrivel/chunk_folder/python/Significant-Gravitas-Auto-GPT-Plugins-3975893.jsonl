{"filename": "run_pylint.py", "chunked_list": ["\"\"\"\n\t    https://stackoverflow.com/questions/49100806/\n\t    pylint-and-subprocess-run-returning-exit-status-28\n\t\"\"\"\n\timport subprocess\n\tcmd = \" pylint src\\\\**\\\\*\"\n\ttry:\n\t    subprocComplete = subprocess.run(\n\t        cmd, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n\t    )\n", "    print(subprocComplete.stdout.decode(\"utf-8\"))\n\texcept subprocess.CalledProcessError as err:\n\t    print(err.output.decode(\"utf-8\"))\n"]}
{"filename": "src/autogpt_plugins/__init__.py", "chunked_list": []}
{"filename": "src/autogpt_plugins/wikipedia_search/__init__.py", "chunked_list": ["\"\"\"Wikipedia search integrations.\"\"\"\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom .wikipedia_search import _wikipedia_search\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTWikipediaSearch(AutoGPTPluginTemplate):\n\t    \"\"\"\n", "    Wikipedia search integrations\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"autogpt-wikipedia-search\"\n\t        self._version = \"0.1.0\"\n\t        self._description = \"Wikipedia search integrations.\"\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n", "        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n", "            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[str]\n", "    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completeion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n", "        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completeion is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n\t        return False\n\t    def pre_instruction(self, messages: List[str]) -> List[str]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n", "            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            List[str]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n", "        return False\n\t    def on_instruction(self, messages: List[str]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n", "            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n", "        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        pass\n", "    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n\t        self,\n\t        messages: list[Dict[Any, Any]],\n\t        model: str,\n\t        temperature: float,\n", "        max_tokens: int,\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the chat_completion method.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n", "            bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t        self,\n\t        messages: list[Dict[Any, Any]],\n\t        model: str,\n\t        temperature: float,\n\t        max_tokens: int,\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n", "        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return None\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n", "        \"\"\"This method is called just after the generate_prompt is called,\n\t            but actually before the prompt is generated.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n\t            PromptGenerator: The prompt generator.\n\t        \"\"\"\n\t        prompt.add_command(\n\t            \"wikipedia_search\",\n\t            \"Wikipedia search\",\n", "            {\"query\": \"<query>\"},\n\t            _wikipedia_search,\n\t        )\n\t        return prompt\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n\t        self, text: str\n", "    ) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/wikipedia_search/wikipedia_search.py", "chunked_list": ["\"\"\"Wikipedia search command for Autogpt.\"\"\"\n\tfrom __future__ import annotations\n\timport json\n\timport re\n\tfrom urllib.parse import quote\n\timport requests\n\tHTML_TAG_CLEANER = re.compile(\"<.*?>|&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-f]{1,6});\")\n\tdef _wikipedia_search(query: str, num_results: int = 5) -> str | list[str]:\n\t    \"\"\"Return the results of a Wikipedia search\n\t    Args:\n", "        query (str): The search query.\n\t        num_results (int): The number of results to return.\n\t    Returns:\n\t        str: The results of the search. The resulting string is a `json.dumps`\n\t             of a list of len `num_results` containing dictionaries with the\n\t             following structure: `{'title': <title>, 'summary': <summary>,\n\t             'url': <url to relevant page>}`\n\t    \"\"\"\n\t    search_url = (\n\t        \"https://en.wikipedia.org/w/api.php?action=query&\"\n", "        \"format=json&list=search&utf8=1&formatversion=2&\"\n\t        f\"srsearch={quote(query)}\"\n\t    )\n\t    with requests.Session() as session:\n\t        session.headers.update(\n\t            {\n\t                \"User-Agent\": (\n\t                    \"Mozilla/5.0 (Windows NT 10.0; \"\n\t                    \"Win64; x64) AppleWebKit/537.36 \"\n\t                    \"(KHTML, like Gecko) Chrome/\"\n", "                    \"112.0.5615.49 Safari/537.36\"\n\t                )\n\t            }\n\t        )\n\t        session.headers.update({\"Accept\": \"application/json\"})\n\t        results = session.get(search_url)\n\t        items = []\n\t        try:\n\t            results = results.json()\n\t            for item in results[\"query\"][\"search\"]:\n", "                summary = re.sub(HTML_TAG_CLEANER, \"\", item[\"snippet\"])\n\t                items.append(\n\t                    {\n\t                        \"title\": item[\"title\"],\n\t                        \"summary\": summary,\n\t                        \"url\": f\"http://en.wikipedia.org/?curid={item['pageid']}\",\n\t                    }\n\t                )\n\t                if len(items) == num_results:\n\t                    break\n", "        except Exception as e:\n\t            return f\"'wikipedia_search' on query: '{query}' raised exception: '{e}'\"\n\t    return json.dumps(items, ensure_ascii=False, indent=4)\n"]}
{"filename": "src/autogpt_plugins/bing_search/test_auto_gpt_bing.py", "chunked_list": ["import os\n\timport unittest\n\tfrom typing import List\n\timport requests\n\tfrom . import AutoGPTBingSearch\n\tfrom .bing_search import _bing_search\n\tclass TestAutoGPTBingSearch(unittest.TestCase):\n\t    def setUp(self):\n\t        os.environ[\"BING_API_KEY\"] = \"test_key\"\n\t        os.environ[\"SEARCH_ENGINE\"] = \"bing\"\n", "        self.plugin = AutoGPTBingSearch()\n\t    def tearDown(self):\n\t        os.environ.pop(\"SEARCH_ENGINE\", None)\n\t        os.environ.pop(\"BING_API_KEY\", None)\n\t    def test_bing_search(self):\n\t        query = \"test query\"\n\t        try:\n\t            _bing_search(query)\n\t        except requests.exceptions.HTTPError as e:\n\t            self.assertEqual(e.response.status_code, 401)\n", "    def test_pre_command(self):\n\t        os.environ[\"SEARCH_ENGINE\"] = \"bing\"\n\t        self.plugin = AutoGPTBingSearch()\n\t        command_name, arguments = self.plugin.pre_command(\n\t            \"google\", {\"query\": \"test query\"}\n\t        )\n\t        self.assertEqual(command_name, \"bing_search\")\n\t        self.assertEqual(arguments, {\"query\": \"test query\"})\n\t    def test_can_handle_pre_command(self):\n\t        self.assertTrue(self.plugin.can_handle_pre_command())\n", "    def test_can_handle_post_prompt(self):\n\t        self.assertTrue(self.plugin.can_handle_post_prompt())\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/bing_search/__init__.py", "chunked_list": ["\"\"\"This is the Bing search engines plugin for Auto-GPT.\"\"\"\n\timport os\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom .bing_search import _bing_search\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTBingSearch(AutoGPTPluginTemplate):\n", "    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"Bing-Search-Plugin\"\n\t        self._version = \"0.1.0\"\n\t        self._description = (\n\t            \"This plugin performs Bing searches using the provided query.\"\n\t        )\n\t        self.load_commands = (\n\t            os.getenv(\"SEARCH_ENGINE\")\n\t            and os.getenv(\"SEARCH_ENGINE\").lower() == \"bing\"\n", "            and os.getenv(\"BING_API_KEY\")\n\t        )\n\t    def can_handle_post_prompt(self) -> bool:\n\t        return True\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        if self.load_commands:\n\t            # Add Bing Search command\n\t            prompt.add_command(\n\t                \"Bing Search\",\n\t                \"bing_search\",\n", "                {\"query\": \"<query>\"},\n\t                _bing_search,\n\t            )\n\t        else:\n\t            print(\n\t                \"Warning: Bing-Search-Plugin is not fully functional. \"\n\t                \"Please set the SEARCH_ENGINE and BING_API_KEY environment variables.\"\n\t            )\n\t        return prompt\n\t    def can_handle_pre_command(self) -> bool:\n", "        return True\n\t    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        if command_name == \"google\" and self.load_commands:\n\t            # this command does nothing but it is required to continue performing the post_command function\n\t            return \"bing_search\", {\"query\": arguments[\"query\"]}\n\t        else:\n\t            return command_name, arguments\n\t    def can_handle_post_command(self) -> bool:\n", "        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[Message]\n\t    ) -> Optional[str]:\n\t        pass\n\t    def can_handle_on_response(self) -> bool:\n", "        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n", "        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n", "        return True\n\t    def can_handle_chat_completion(\n\t        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n\t    ) -> bool:\n\t        return False\n\t    def handle_chat_completion(\n\t        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n\t    ) -> str:\n\t        pass\n\t    def can_handle_text_embedding(\n", "        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n\t        self, text: str\n\t    ) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n", "        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/bing_search/bing_search.py", "chunked_list": ["import json\n\timport os\n\timport re\n\timport requests\n\tdef clean_text(text: str) -> str:\n\t    cleaned_text = re.sub(\"<[^>]*>\", \"\", text)  # Remove HTML tags\n\t    cleaned_text = cleaned_text.replace(\n\t        \"\\\\n\", \" \"\n\t    )  # Replace newline characters with spaces\n\t    return cleaned_text\n", "def _bing_search(query: str, num_results=8) -> str:\n\t    \"\"\"\n\t    Perform a Bing search and return the results as a JSON string.\n\t    \"\"\"\n\t    subscription_key = os.getenv(\"BING_API_KEY\")\n\t    # Bing Search API endpoint\n\t    search_url = \"https://api.bing.microsoft.com/v7.0/search\"\n\t    headers = {\"Ocp-Apim-Subscription-Key\": subscription_key}\n\t    params = {\n\t        \"q\": query,\n", "        \"count\": num_results,\n\t        \"textDecorations\": True,\n\t        \"textFormat\": \"HTML\",\n\t    }\n\t    response = requests.get(search_url, headers=headers, params=params)\n\t    response.raise_for_status()\n\t    search_results = response.json()\n\t    # Extract the search result items from the response\n\t    web_pages = search_results.get(\"webPages\", {})\n\t    search_results = web_pages.get(\"value\", [])\n", "    # Create a list of search result dictionaries with 'title', 'href', and 'body' keys\n\t    search_results_list = [\n\t        {\n\t            \"title\": clean_text(item[\"name\"]),\n\t            \"href\": item[\"url\"],\n\t            \"body\": clean_text(item[\"snippet\"]),\n\t        }\n\t        for item in search_results\n\t    ]\n\t    # Return the search results as a JSON string\n", "    return json.dumps(search_results_list, ensure_ascii=False, indent=4)\n"]}
{"filename": "src/autogpt_plugins/bluesky/__init__.py", "chunked_list": ["\"\"\"This is a Bluesky plugin for AutoGPT using atprototools.\"\"\"\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTBluesky(AutoGPTPluginTemplate):\n\t    \"\"\"\n\t    Bluesky plugin for AutoGPT using atprototools.\n", "    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"autogpt-bluesky\"\n\t        self._version = \"0.1.0\"\n\t        self._description = \"Bluesky integration using atprototools.\"\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        \"\"\"This method is called just after the generate_prompt is called,\n\t            but actually before the prompt is generated.\n\t        Args:\n", "            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n\t            PromptGenerator: The prompt generator.\n\t        \"\"\"\n\t        from .bluesky_plugin.bluesky_plugin import (\n\t            get_latest_posts,\n\t            post_message,\n\t            username_and_pwd_set,\n\t        )\n\t        if not username_and_pwd_set():\n", "            return prompt\n\t        prompt.add_command(\n\t            \"post_to_bluesky\", \"Post to Bluesky\", {\n\t                \"text\": \"<text>\"}, post_message\n\t        )\n\t        prompt.add_command(\n\t            \"get_bluesky_posts\", \"Get Blueskey Posts\", {\n\t                \"username\": \"<username>\",\n\t                \"number_of_posts\": \"<number_of_posts>\"}, get_latest_posts)\n\t        return prompt\n", "    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_post_prompt(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n", "        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[str]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completeion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n\t        pass\n", "    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completeion is done.\n\t        Args:\n\t            response (str): The response.\n", "        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n\t        return False\n", "    def pre_instruction(self, messages: List[str]) -> List[str]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            List[str]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n", "        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[str]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            Optional[str]: The resulting message.\n", "        \"\"\"\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n", "        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n", "            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n", "            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n", "        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n\t        self,\n", "        messages: list[Dict[Any, Any]],\n\t        model: str,\n\t        temperature: float,\n\t        max_tokens: int,\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the chat_completion method.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n", "            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t        self,\n\t        messages: list[Dict[Any, Any]],\n\t        model: str,\n\t        temperature: float,\n", "        max_tokens: int,\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n", "        \"\"\"\n\t        return None\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n\t        self, text: str\n\t    ) -> list:\n\t        pass\n", "    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/bluesky/bluesky_plugin/bluesky_plugin.py", "chunked_list": ["\"\"\"This module contains functions for interacting with the Bluesky API via atprototools.\"\"\"\n\timport os\n\timport pandas as pd\n\tfrom atproto import Client\n\tdef username_and_pwd_set() -> bool:\n\t    return True if os.getenv(\"BLUESKY_USERNAME\") and os.getenv(\"BLUESKY_APP_PASSWORD\") else False\n\tdef post_message(text: str) -> str:\n\t    \"\"\"Posts a message to Bluesky.\n\t    Args:\n\t        text (str): The message to post.\n", "    Returns:\n\t        str: The message that was posted.\n\t    \"\"\"\n\t    bluesky_username = os.getenv(\"BLUESKY_USERNAME\")\n\t    bluesky_app_password = os.getenv(\"BLUESKY_APP_PASSWORD\")\n\t    client = Client()\n\t    try:\n\t        client.login(bluesky_username, bluesky_app_password)\n\t        client.send_post(text=text)\n\t    except Exception as e:\n", "        return f\"Error! Message: {e}\"\n\t    return f\"Success! Message: {text}\"\n\tdef get_latest_posts(username: str, number_of_posts=5) -> str | None:\n\t    \"\"\"Gets the latest posts from a user.\n\t    Args:\n\t        username (str): The username to get the messages from.\n\t        number_of_posts (int): The number of posts to get.\n\t    Returns:\n\t        str | None: The latest posts.\n\t    \"\"\"\n", "    bluesky_username = os.getenv(\"BLUESKY_USERNAME\")\n\t    bluesky_app_password = os.getenv(\"BLUESKY_APP_PASSWORD\")\n\t    client = Client()\n\t    try:\n\t        client.login(bluesky_username, bluesky_app_password)\n\t        profile_feed = client.bsky.feed.get_author_feed(\n\t            {'actor': username, 'limit': number_of_posts})\n\t    except Exception as e:\n\t        return f\"Error! Message: {e}\"\n\t    columns = [\"URI\", \"Text\", \"Date\", \"User\", \"Likes\", \"Replies\"]\n", "    posts = []\n\t    for feed in profile_feed.feed:\n\t        posts.append([feed.post.uri, feed.post.record.text, feed.post.record.createdAt,\n\t                      feed.post.author.handle, feed.post.likeCount, feed.post.replyCount])\n\t    df = str(pd.DataFrame(posts, columns=columns))\n\t    print(df)\n\t    return df\n"]}
{"filename": "src/autogpt_plugins/bluesky/bluesky_plugin/__init__.py", "chunked_list": []}
{"filename": "src/autogpt_plugins/bluesky/bluesky_plugin/test_bluesky_plugin.py", "chunked_list": ["import os\n\timport unittest\n\tfrom .bluesky_plugin import get_latest_posts, post_message, username_and_pwd_set\n\tMOCK_USERNAME = \"example.bsky.social\"\n\tMOCK_MESSAGE = \"Hello, World!\"\n\tclass TestBlueskyPlugin(unittest.TestCase):\n\t    def setUp(self):\n\t        os.environ[\"BLUESKY_USERNAME\"] = \"example.bsky.social\"\n\t        os.environ[\"BLUESKY_APP_PASSWORD\"] = \"bsky-social-app-password\"\n\t    def tearDown(self):\n", "        os.environ.pop(\"BLUESKY_USERNAME\", None)\n\t        os.environ.pop(\"BLUESKY_APP_PASSWORD\", None)\n\t    def test_username_and_pwd_set(self):\n\t        self.assertTrue(username_and_pwd_set())\n\t    def test_post_message(self):\n\t        self.assertIsInstance(post_message(MOCK_MESSAGE), str)\n\t    def test_get_latest_posts(self):\n\t        self.assertIsInstance(get_latest_posts(MOCK_USERNAME, 5), str)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/twitter/twitter.py", "chunked_list": ["\"\"\"This module contains functions for interacting with the Twitter API.\"\"\"\n\tfrom __future__ import annotations\n\timport pandas as pd\n\timport tweepy\n\tfrom . import AutoGPTTwitter\n\tplugin = AutoGPTTwitter()\n\tdef post_tweet(tweet_text: str) -> str:\n\t    \"\"\"Posts a tweet to twitter.\n\t    Args:\n\t        tweet (str): The tweet to post.\n", "    Returns:\n\t        str: The tweet that was posted.\n\t    \"\"\"\n\t    _tweetID = plugin.api.update_status(status=tweet_text)\n\t    return f\"Success! Tweet: {_tweetID.text}\"\n\tdef post_reply(tweet_text: str, tweet_id: int) -> str:\n\t    \"\"\"Posts a reply to a tweet.\n\t    Args:\n\t        tweet (str): The tweet to post.\n\t        tweet_id (int): The ID of the tweet to reply to.\n", "    Returns:\n\t        str: The tweet that was posted.\n\t    \"\"\"\n\t    replyID = plugin.api.update_status(\n\t        status=tweet_text,\n\t        in_reply_to_status_id=tweet_id,\n\t        auto_populate_reply_metadata=True,\n\t    )\n\t    return f\"Success! Tweet: {replyID.text}\"\n\tdef get_mentions() -> str | None:\n", "    \"\"\"Gets the most recent mention.\n\t    Args:\n\t        api (tweepy.API): The tweepy API object.\n\t    Returns:\n\t        str | None: The most recent mention.\n\t    \"\"\"\n\t    _tweets = plugin.api.mentions_timeline(tweet_mode=\"extended\")\n\t    for tweet in _tweets:\n\t        return (\n\t            f\"@{tweet.user.screen_name} Replied: {tweet.full_text}\"\n", "            f\" Tweet ID: {tweet.id}\"\n\t        )  # Returns most recent mention\n\tdef search_twitter_user(target_user: str, number_of_tweets: int) -> str:\n\t    \"\"\"Searches a user's tweets given a number of items to retrive and\n\t      returns a dataframe.\n\t    Args:\n\t        target_user (str): The user to search.\n\t        num_of_items (int): The number of items to retrieve.\n\t        api (tweepy.API): The tweepy API object.\n\t    Returns:\n", "        str: The dataframe containing the tweets.\n\t    \"\"\"\n\t    tweets = tweepy.Cursor(\n\t        plugin.api.user_timeline, screen_name=target_user, tweet_mode=\"extended\"\n\t    ).items(number_of_tweets)\n\t    columns = [\"Time\", \"User\", \"ID\", \"Tweet\"]\n\t    data = []\n\t    for tweet in tweets:\n\t        data.append(\n\t            [tweet.created_at, tweet.user.screen_name, tweet.id, tweet.full_text]\n", "        )\n\t    df = str(pd.DataFrame(data, columns=columns))\n\t    print(df)\n\t    return df  # Prints a dataframe object containing the Time, User, ID, and Tweet\n"]}
{"filename": "src/autogpt_plugins/twitter/__init__.py", "chunked_list": ["\"\"\"Twitter API integrations using Tweepy.\"\"\"\n\timport os\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\timport tweepy\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTTwitter(AutoGPTPluginTemplate):\n", "    \"\"\"\n\t    Twitter API integrations using Tweepy\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"autogpt-twitter\"\n\t        self._version = \"0.1.0\"\n\t        self._description = \"Twitter API integrations using Tweepy.\"\n\t        self.twitter_consumer_key = os.getenv(\"TW_CONSUMER_KEY\")\n\t        self.twitter_consumer_secret = os.getenv(\"TW_CONSUMER_SECRET\")\n", "        self.twitter_access_token = os.getenv(\"TW_ACCESS_TOKEN\")\n\t        self.twitter_access_token_secret = os.getenv(\"TW_ACCESS_TOKEN_SECRET\")\n\t        self.tweet_id = []\n\t        self.tweets = []\n\t        self.api = None\n\t        if (\n\t            self.twitter_consumer_key\n\t            and self.twitter_consumer_secret\n\t            and self.twitter_access_token\n\t            and self.twitter_access_token_secret\n", "        ) is not None:\n\t            # Authenticating to twitter\n\t            self.auth = tweepy.OAuth1UserHandler(\n\t                self.twitter_consumer_key,\n\t                self.twitter_consumer_secret,\n\t                self.twitter_access_token,\n\t                self.twitter_access_token_secret,\n\t            )\n\t            self.api = tweepy.API(self.auth)\n\t            self.stream = tweepy.Stream(\n", "                self.twitter_consumer_key,\n\t                self.twitter_consumer_secret,\n\t                self.twitter_access_token,\n\t                self.twitter_access_token_secret,\n\t            )\n\t        else:\n\t            print(\"Twitter credentials not found in .env file.\")\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n", "        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n", "            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[str]\n", "    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completeion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n", "        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completeion is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n\t        return False\n\t    def pre_instruction(self, messages: List[str]) -> List[str]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n", "            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            List[str]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n", "        return False\n\t    def on_instruction(self, messages: List[str]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n", "            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n", "        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        pass\n", "    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n\t        self,\n\t        messages: list[Dict[Any, Any]],\n\t        model: str,\n\t        temperature: float,\n", "        max_tokens: int,\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the chat_completion method.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n", "            bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t        self,\n\t        messages: list[Dict[Any, Any]],\n\t        model: str,\n\t        temperature: float,\n\t        max_tokens: int,\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n", "        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return None\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n", "        \"\"\"This method is called just after the generate_prompt is called,\n\t            but actually before the prompt is generated.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n\t            PromptGenerator: The prompt generator.\n\t        \"\"\"\n\t        if self.api:\n\t            from .twitter import (\n\t                get_mentions,\n", "                post_reply,\n\t                post_tweet,\n\t                search_twitter_user,\n\t            )\n\t            prompt.add_command(\n\t                \"post_tweet\", \"Post Tweet\", {\"tweet_text\": \"<tweet_text>\"}, post_tweet\n\t            )\n\t            prompt.add_command(\n\t                \"post_reply\",\n\t                \"Post Twitter Reply\",\n", "                {\"tweet_text\": \"<tweet_text>\", \"tweet_id\": \"<tweet_id>\"},\n\t                post_reply,\n\t            )\n\t            prompt.add_command(\"get_mentions\", \"Get Twitter Mentions\", {}, get_mentions)\n\t            prompt.add_command(\n\t                \"search_twitter_user\",\n\t                \"Search Twitter\",\n\t                {\n\t                    \"target_user\": \"<target_user>\",\n\t                    \"number_of_tweets\": \"<number_of_tweets\",\n", "                },\n\t                search_twitter_user,\n\t            )\n\t        return prompt\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n\t        self, text: str\n", "    ) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/planner/planner.py", "chunked_list": ["import json\n\timport os\n\tdef check_plan():\n\t    \"\"\"this function checks if the file plan.md exists, if it doesn't exist it gets created\"\"\"\n\t    current_working_directory = os.getcwd()\n\t    workdir = os.path.join(\n\t        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"plan.md\"\n\t    )\n\t    file_name = workdir\n\t    if not os.path.exists(file_name):\n", "        with open(file_name, \"w\") as file:\n\t            file.write(\n\t                \"\"\"\n\t                # Task List and status:\n\t                - [ ] Create a detailed checklist for the current plan and goals\n\t                - [ ] Finally, review that every new task is completed\n\t                ## Notes:\n\t                - Use the run_planning_cycle command frequently to keep this plan up to date.\n\t                        \"\"\"\n\t            )\n", "        print(f\"{file_name} created.\")\n\t    with open(file_name, \"r\") as file:\n\t        return file.read()\n\tdef update_plan():\n\t    \"\"\"this function checks if the file plan.md exists, if it doesn't exist it gets created\"\"\"\n\t    current_working_directory = os.getcwd()\n\t    workdir = os.path.join(current_working_directory, 'autogpt', 'auto_gpt_workspace', 'plan.md')\n\t    file_name = workdir\n\t    with open(file_name, 'r') as file:\n\t        data = file.read()\n", "    response = generate_improved_plan(data)\n\t    with open(file_name, \"w\") as file:\n\t        file.write(response)\n\t    print(f\"{file_name} updated.\")\n\t    return response\n\tdef generate_improved_plan(prompt: str) -> str:\n\t    \"\"\"Generate an improved plan using OpenAI's ChatCompletion functionality\"\"\"\n\t    import openai\n\t    tasks = load_tasks()\n\t    model = os.getenv('PLANNER_MODEL', os.getenv('FAST_LLM_MODEL', 'gpt-3.5-turbo'))\n", "    max_tokens = os.getenv('PLANNER_TOKEN_LIMIT', os.getenv('FAST_TOKEN_LIMIT', 1500))\n\t    temperature = os.getenv('PLANNER_TEMPERATURE', os.getenv('TEMPERATURE', 0.5))\n\t    # Call the OpenAI API for chat completion\n\t    response = openai.ChatCompletion.create(\n\t        model=model,\n\t        messages=[\n\t            {\n\t                \"role\": \"system\",\n\t                \"content\": \"You are an assistant that improves and adds crucial points to plans in .md format.\",\n\t            },\n", "            {\n\t                \"role\": \"user\",\n\t                \"content\": f\"Update the following plan given the task status below, keep the .md format:\\n{prompt}\\n\"\n\t                           f\"Include the current tasks in the improved plan, keep mind of their status and track them \"\n\t                           f\"with a checklist:\\n{tasks}\\n Revised version should comply with the contents of the \"\n\t                           f\"tasks at hand:\",\n\t            },\n\t        ],\n\t        max_tokens=int(max_tokens),\n\t        n=1,\n", "        temperature=float(temperature),\n\t    )\n\t    # Extract the improved plan from the response\n\t    improved_plan = response.choices[0].message.content.strip()\n\t    return improved_plan\n\tdef create_task(task_id=None, task_description: str = None, status=False):\n\t    task = {\"description\": task_description, \"completed\": status}\n\t    tasks = load_tasks()\n\t    tasks[str(task_id)] = task\n\t    current_working_directory = os.getcwd()\n", "    workdir = os.path.join(\n\t        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"tasks.json\"\n\t    )\n\t    file_name = workdir\n\t    with open(file_name, \"w\") as f:\n\t        json.dump(tasks, f)\n\t    return tasks\n\tdef load_tasks() -> dict:\n\t    current_working_directory = os.getcwd()\n\t    workdir = os.path.join(\n", "        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"tasks.json\"\n\t    )\n\t    file_name = workdir\n\t    if not os.path.exists(file_name):\n\t        with open(file_name, \"w\") as f:\n\t            f.write(\"{}\")\n\t    with open(file_name) as f:\n\t        try:\n\t            tasks = json.load(f)\n\t            if isinstance(tasks, list):\n", "                tasks = {}\n\t        except json.JSONDecodeError:\n\t            tasks = {}\n\t    return tasks\n\tdef update_task_status(task_id):\n\t    tasks = load_tasks()\n\t    if str(task_id) not in tasks:\n\t        print(f\"Task with ID {task_id} not found.\")\n\t        return\n\t    tasks[str(task_id)][\"completed\"] = True\n", "    current_working_directory = os.getcwd()\n\t    workdir = os.path.join(\n\t        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"tasks.json\"\n\t    )\n\t    file_name = workdir\n\t    with open(file_name, \"w\") as f:\n\t        json.dump(tasks, f)\n\t    return f\"Task with ID {task_id} has been marked as completed.\"\n"]}
{"filename": "src/autogpt_plugins/planner/__init__.py", "chunked_list": ["\"\"\"This is a task planning system plugin for Auto-GPT. It is able to create tasks, elaborate a plan, improve upon it\n\tand check it again to keep on track.\n\tbuilt by @rihp on github\"\"\"\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom .planner import (\n\t    check_plan,\n\t    create_task,\n\t    load_tasks,\n\t    update_plan,\n", "    update_task_status,\n\t)\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass PlannerPlugin(AutoGPTPluginTemplate):\n\t    \"\"\"\n\t    This is a task planner system plugin for Auto-GPT which \n\t    adds the task planning commands to the prompt.\n", "    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"AutoGPT-Planner-Plugin\"\n\t        self._version = \"0.1.1\"\n\t        self._description = \"This is a simple task planner module for Auto-GPT. It adds the run_planning_cycle \" \\\n\t                            \"command along with other task related commands. Creates a plan.md file and tasks.json \" \\\n\t                            \"to manage the workloads. For help and discussion: \" \\\n\t                            \"https://discord.com/channels/1092243196446249134/1098737397094694922/threads/1102780261604790393\"\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n", "        \"\"\"This method is called just after the generate_prompt is called,\n\t        but actually before the prompt is generated.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n\t            PromptGenerator: The prompt generator.\n\t        \"\"\"\n\t        prompt.add_command(\n\t            \"check_plan\",\n\t            \"Read the plan.md with the next goals to achieve\",\n", "            {},\n\t            check_plan,\n\t        )\n\t        prompt.add_command(\n\t            \"run_planning_cycle\",\n\t            \"Improves the current plan.md and updates it with progress\",\n\t            {},\n\t            update_plan,\n\t        )\n\t        prompt.add_command(\n", "            \"create_task\",\n\t            \"creates a task with a task id, description and a completed status of False \",\n\t            {\n\t                \"task_id\": \"<int>\",\n\t                \"task_description\": \"<The task that must be performed>\",\n\t            },\n\t            create_task,\n\t        )\n\t        prompt.add_command(\n\t            \"load_tasks\",\n", "            \"Checks out the task ids, their descriptionsand a completed status\",\n\t            {},\n\t            load_tasks,\n\t        )\n\t        prompt.add_command(\n\t            \"mark_task_completed\",\n\t            \"Updates the status of a task and marks it as completed\",\n\t            {\"task_id\": \"<int>\"},\n\t            update_task_status,\n\t        )\n", "        return prompt\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n", "        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n", "            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n\t            self, prompt: PromptGenerator, messages: List[Message]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completion is done.\n\t        Args:\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n", "        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            List[Message]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n", "            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n", "        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n", "        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n\t            self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n", "        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n", "    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n", "            self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t          handle the chat_completion method.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t          Returns:\n", "              bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t            self, messages: List[Message], model: str, temperature: float, max_tokens: int\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n", "            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n", "        self, text: str\n\t    ) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n", "        pass"]}
{"filename": "src/autogpt_plugins/api_tools/api_tools.py", "chunked_list": ["\"\"\"API Call command for Autogpt.\"\"\"\n\timport json\n\timport re\n\timport requests\n\tfrom typing import Dict, Optional\n\tfrom urllib.parse import urljoin, urlparse\n\tfrom urllib.parse import urljoin\n\tfrom validators import url as is_valid_url\n\tclass ApiCallCommand:\n\t    \"\"\"\n", "    A class used to make API calls.\n\t    \"\"\"\n\t    def sanitize_string(self, input_string: str) -> str:\n\t        \"\"\"\n\t        Remove potentially harmful characters from the string.\n\t        Args:\n\t            input_string (str): The string to sanitize.\n\t        Returns:\n\t            str: The sanitized string.\n\t        \"\"\"\n", "        return re.sub(r'[^a-zA-Z0-9_: -{}[\\],\"]', '', input_string)\n\t    # End of sanitize_string()\n\t    def sanitize_json(self, input_string: str) -> str:\n\t        \"\"\"\n\t        Sanitize all the values in a JSON string.\n\t        Args:\n\t            input_string (str): The JSON string to sanitize.\n\t        Returns:\n\t            str: The sanitized JSON string.\n\t        \"\"\"\n", "        data = json.loads(input_string)\n\t        sanitized_data = {self.sanitize_string(k): self.sanitize_string(str(v)) for k, v in data.items()}\n\t        return json.dumps(sanitized_data)\n\t    # End of sanitize_json()\n\t    def sanitize(self, input_string: str) -> str:\n\t        \"\"\"\n\t        Remove potentially harmful characters from the input string.\n\t        Args:\n\t            input_string (str): The string to sanitize.\n\t        Returns:\n", "            str: The sanitized string.\n\t        \"\"\"\n\t        try:\n\t            sanitized_string = self.sanitize_json(input_string)\n\t        except json.JSONDecodeError:\n\t            sanitized_string = self.sanitize_string(input_string)\n\t        return sanitized_string\n\t    # End of sanitize()\n\t    def make_api_call(self, host = \"\", endpoint = \"\", mthd = \"GET\", params = {}, body = \"\", \n\t                      hdrs = {\"Content-Type\": \"application/json\"}, timeout = 60) -> str:\n", "        \"\"\"\n\t        Return the results of an API call\n\t        Args:\n\t            host (str): The host to call.\n\t            endpoint (str): The endpoint to call.\n\t            mthd (str): The HTTP method to use.\n\t            params (dict): The query parameters to use.\n\t            body (str): The body to use.\n\t            hdrs (dict): The headers to use.\n\t            timeout (int): The timeout to use.\n", "        Returns:\n\t            str: A JSON string containing the results of the API \n\t                call in the format\n\t                {\"status\": \"success|error\", \"status_code\": int, \"response\": str, \"response\": str}\n\t        \"\"\"\n\t        # Initialize variables  \n\t        response = {}\n\t        # Type-check inputs - host\n\t        if not isinstance(host, str):\n\t            raise ValueError(\"host must be a string\")\n", "        # Type-check inputs - endpoint\n\t        if not isinstance(endpoint, str):\n\t            raise ValueError(\"endpoint must be a string\")\n\t        # Type-check inputs - method\n\t        if not isinstance(mthd, str):\n\t            raise ValueError(\"method must be a string\")\n\t        # Type-check inputs - query_params\n\t        if not params:\n\t            params = {}\n\t        elif isinstance(params, str):\n", "            try:\n\t                params = json.loads(params)\n\t            except json.JSONDecodeError:\n\t                raise ValueError(\"query_params must be a dictionary\")\n\t        elif isinstance(params, dict):\n\t            new_query_params = {}\n\t            for k, v in params.items():\n\t                if k is None:\n\t                    raise ValueError(\"query_params cannot contain None keys\")\n\t                if not isinstance(k, str):\n", "                    k = str(k)\n\t                if v is not None and not isinstance(v, str):\n\t                    v = str(v)\n\t                new_query_params[k] = v\n\t            params = new_query_params\n\t        else:\n\t            raise ValueError(\"query_params must be a dictionary or a JSON string\")\n\t        # Type-check inputs - body\n\t        if not isinstance(body, str):\n\t            try:\n", "                body = str(body)\n\t            except ValueError:\n\t                raise ValueError(\"body must be a string\")\n\t        # Type-check inputs - headers\n\t        if not hdrs:\n\t            hdrs = {}\n\t        elif isinstance(hdrs, str):\n\t            try:\n\t                hdrs = json.loads(hdrs)\n\t            except json.JSONDecodeError:\n", "                raise ValueError(\"headers must be a dictionary\")\n\t        elif isinstance(hdrs, dict):\n\t            new_headers = {}\n\t            for k, v in hdrs.items():\n\t                if k is None:\n\t                    raise ValueError(\"headers cannot contain None keys\")\n\t                if not isinstance(k, str):\n\t                    k = str(k)\n\t                if v is not None and not isinstance(v, str):\n\t                    v = str(v)\n", "                new_headers[k] = v\n\t            hdrs = new_headers\n\t        else:\n\t            raise ValueError(\"headers must be a dictionary or a JSON string\")\n\t        # Type-check inputs - timeout_secs\n\t        if timeout is None:\n\t            raise ValueError(\"timeout_secs must be an integer\")\n\t        elif not isinstance(timeout, int):\n\t            try:\n\t                timeout = int(timeout)\n", "            except ValueError:\n\t                raise ValueError(\"timeout_secs must be an integer\")\n\t        # Validate URL\n\t        if '?' in host or '&' in host:\n\t            raise ValueError(\"Invalid URL: Host must not contain query parameters\")\n\t        sanitized_host = self.sanitize(host)\n\t        sanitized_endpoint = self.sanitize(endpoint)\n\t        if not sanitized_host.startswith((\"http://\", \"https://\")):\n\t            sanitized_host = f\"https://{sanitized_host}\"\n\t        url = urljoin(sanitized_host, sanitized_endpoint)\n", "        if not is_valid_url(url): # type: ignore\n\t            raise ValueError(\"Invalid URL: \" + url)\n\t        # Validate method\n\t        allowed_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"]\n\t        sanitized_method = self.sanitize(mthd).upper()    \n\t        if sanitized_method not in allowed_methods:\n\t            raise ValueError(\"Invalid method: \" + sanitized_method)\n\t        # Validate timeout_secs\n\t        if not timeout > 0:\n\t            raise ValueError(\"timeout_secs must be a positive integer\")\n", "        # Make the request\n\t        try:\n\t            if sanitized_method == \"GET\":\n\t                response = requests.get(url, params=params, headers=hdrs, timeout=timeout)\n\t            elif sanitized_method == \"HEAD\":\n\t                response = requests.head(url, params=params, headers=hdrs, timeout=timeout)\n\t            elif sanitized_method == \"OPTIONS\":\n\t                response = requests.options(url, params=params, headers=hdrs, timeout=timeout)\n\t            elif sanitized_method == \"POST\":\n\t                response = requests.post(url, params=params, json=body, headers=hdrs, timeout=timeout)\n", "            elif sanitized_method == \"PUT\":\n\t                response = requests.put(url, params=params, json=body, headers=hdrs, timeout=timeout)\n\t            elif sanitized_method == \"DELETE\":\n\t                response = requests.delete(url, params=params, json=body, headers=hdrs, timeout=timeout)\n\t            elif sanitized_method == \"PATCH\":\n\t                response = requests.patch(url, params=params, json=body, headers=hdrs, timeout=timeout)\n\t            else:\n\t                raise ValueError(\"Invalid method: \" + mthd)\n\t            response_text = response.text\n\t            response = {\n", "                \"status\": \"success\",\n\t                \"status_code\": response.status_code,\n\t                \"response\": response_text\n\t            }\n\t        except requests.exceptions.RequestException as e:\n\t            response = {\n\t                \"status\": \"error\",\n\t                \"status_code\": None,\n\t                \"response\": str(e)\n\t            }\n", "        return json.dumps(response)\n\t    # End of call_api()\n\t# End of class ApiCallCommand\n"]}
{"filename": "src/autogpt_plugins/api_tools/test_api_tools.py", "chunked_list": ["import json\n\timport random\n\timport requests_mock\n\timport unittest\n\ttry:\n\t    from .api_tools import ApiCallCommand\n\texcept ImportError:\n\t    from api_tools import ApiCallCommand\n\tclass TestAutoGPTAPITools(unittest.TestCase):\n\t    def setUp(self):\n", "        self.plugin_class = ApiCallCommand()\n\t    def test_api_call_get(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a GET request.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n", "    def test_api_call_post(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a POST request.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_put(self):\n", "        \"\"\"Test the self.plugin_class.make_api_call() function with a PUT request.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.put('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='PUT')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_delete(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a DELETE request.\"\"\"\n", "        with requests_mock.Mocker() as m:\n\t            m.delete('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='DELETE')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_patch(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a PATCH request.\"\"\"\n\t        with requests_mock.Mocker() as m:\n", "            m.patch('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='PATCH')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_head(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a HEAD request.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.head('http://example.com/endpoint', text='success', status_code=200)\n", "            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='HEAD')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_options(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a OPTIONS request.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.options('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='OPTIONS')\n", "            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    # Test host errors\n\t    def test_api_call_valid_host(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a valid host.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n", "            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_valid_host_https(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a valid host using HTTPS.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('https://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('https://example.com', '/endpoint')\n\t            response = json.loads(result)\n", "            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_host_without_protocol(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a host without a protocol.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('https://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('example.com', '/endpoint')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n", "            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_host_garbage(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a garbage host.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('garbage', '/endpoint')\n\t        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\t    def test_api_call_host_empty(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an empty host.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n", "            self.plugin_class.make_api_call('', '/endpoint')\n\t        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\t    def test_api_call_host_number(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a host that is a number.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call(123, '/endpoint') # type: ignore\n\t        self.assertIn(\"host must be a string\", str(excinfo.exception))\n\t    def test_api_call_host_none(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with no host.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n", "            self.plugin_class.make_api_call(None, '/endpoint') # type: ignore\n\t        self.assertIn(\"host must be a string\", str(excinfo.exception))\n\t    def test_api_call_host_invalid_protocol(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an invalid protocol.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('ftp://example.com', '/endpoint')\n\t        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\t    def test_api_call_host_query_marker(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with dangerous characters.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n", "            self.plugin_class.make_api_call('http://example.com?test=1', '/endpoint')\n\t        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\t    def test_api_call_host_query_param_marker(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with dangerous characters.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com?test=1', '/endpoint')\n\t        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\t    # Test endpoint errors\n\t    def test_api_call_valid_endpoint(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a valid endpoint.\"\"\"\n", "        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_valid_endpoint_with_query(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a valid endpoint.\"\"\"\n\t        with requests_mock.Mocker() as m:\n", "            m.get('http://example.com/endpoint?test=1', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint?test=1')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_endpoint_empty(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an empty endpoint.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com', text='success', status_code=200)\n", "            result = self.plugin_class.make_api_call('http://example.com', '')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_endpoint_number(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an endpoint that is a number.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', 123) # type: ignore\n\t        self.assertIn(\"endpoint must be a string\", str(excinfo.exception))\n", "    def test_api_call_endpoint_none(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with no endpoint.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', None) # type: ignore\n\t        self.assertIn(\"endpoint must be a string\", str(excinfo.exception))\n\t    # Test method errors    \n\t    def test_api_call_invalid_method(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an invalid method.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='INVALID')\n", "        self.assertIn(\"Invalid method: INVALID\", str(excinfo.exception))\n\t    def test_api_call_none_method(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with no method.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd=None) # type: ignore\n\t        self.assertIn(\"method must be a string\", str(excinfo.exception))\n\t    def test_api_call_empty_method(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an empty method.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='')\n", "        self.assertIn(\"Invalid method\", str(excinfo.exception))\n\t    def test_api_call_number_method(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a number as a method.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd=123) # type: ignore\n\t        self.assertIn(\"method must be a string\", str(excinfo.exception))\n\t    def test_api_call_lowercase_method(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a lowercase method.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n", "            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='get')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    # Test query_params errors\n\t    def test_api_call_valid_query_params_with_number_as_dict_value(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid query_params.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n", "            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={'test': 1})\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_query_params_array(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an array.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', params=['test'])\n\t        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n", "    def test_api_call_query_params_string(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a string.\"\"\"\n\t        # This is interpreted as JSON and converted to a dictionary\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params='{\"test\": 1}')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n", "    def test_api_call_query_params_invalid_json_string(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an invalid JSON string.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', params='{test\": 1')\n\t        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\t    def test_api_call_query_params_empty_string(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an empty string.\"\"\"\n\t        # This should be converted to an empty dictionary\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n", "            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params='')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_query_params_none(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with no query_params.\"\"\"\n\t        # This should be converted to an empty dictionary\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n", "            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params=None)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_query_params_empty_dict(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an empty query_params.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={})\n", "            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_query_params_number(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a number.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', params=123)\n\t        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\t    def test_api_call_query_params_dict_has_key_none_value(self):\n", "        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that has a None value.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={'test': None})\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_query_params_dict_malformed(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a malformed dictionary.\"\"\"\n", "        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', params={None: 'test'})\n\t        self.assertIn(\"query_params cannot contain None keys\", str(excinfo.exception))\n\t    # Test body errors\n\t    def test_api_call_valid_body_with_24k_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='a' * 24000)\n\t            response = json.loads(result)\n", "            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_valid_body_with_random_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            body_length = random.randint(1, 24000)\n\t            body = 'a' * body_length\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n", "            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_valid_body_with_control_code_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='\\x00')\n\t            response = json.loads(result)\n", "            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_valid_body_with_unicode_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=u'\\u2713')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n", "            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_valid_body_with_utf8_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            body = u'\\u2713'.encode('utf-8')\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body) # type: ignore\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n", "            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_valid_body_with_utf16_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            body = u'\\u2713'.encode('utf-16')\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body) # type: ignore\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n", "            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_body_empty(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with an empty body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n", "    def test_api_call_body_none(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a None body.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=None) # type: ignore\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_body_not_string(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is not a string.\"\"\"\n", "        with requests_mock.Mocker() as m:\n\t            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=1) # type: ignore\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_body_json(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is json.\"\"\"\n\t        with requests_mock.Mocker() as m:\n", "            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            body = json.dumps({'test': 'test'})\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_body_json_invalid(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is invalid json.\"\"\"\n\t        with requests_mock.Mocker() as m:\n", "            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            body = '{\"test\": \"test\"]'\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_body_xml(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is xml.\"\"\"\n\t        with requests_mock.Mocker() as m:\n", "            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            body = '<test>test</test>'\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    def test_api_call_body_xml_invalid(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is invalid xml.\"\"\"\n\t        with requests_mock.Mocker() as m:\n", "            m.post('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='<test>test</test>')\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n\t    # Test headers errors\n\t    def test_api_call_valid_headers(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n\t        with requests_mock.Mocker() as m:\n", "            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs={'test': 'test'})\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_valid_headers_with_random_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            headers = {'test': 'a' * random.randint(1, 24000)}\n", "            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_valid_headers_with_control_code_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            headers = {'test': '\\x00'}\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n", "            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_valid_headers_with_unicode_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            headers = {'test': u'\\u2713'}\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n\t            response = json.loads(result)\n", "            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_headers_with_array(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are an array.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            headers = ['test']\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n\t        self.assertIn(\"headers must be a dictionary\", str(excinfo.exception))\n\t    def test_api_call_headers_with_empty_dict(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are an empty dict.\"\"\"\n", "        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs={})\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_headers_with_none(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are None.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n", "            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=None)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_headers_with_not_dict(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are not a dict.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=1)\n\t        self.assertIn(\"headers must be a dictionary\", str(excinfo.exception))\n\t    def test_api_call_headers_with_invalid_key(self):\n", "        \"\"\"Test the self.plugin_class.make_api_call() function with headers that have an invalid key.\"\"\"\n\t        headers = {'test': 'test'}\n\t        headers[1] = 'test' # type: ignore\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200, headers={'test': 'test', '1': 'test'})\n\t            result = self.plugin_class.make_api_call(host='http://example.com', endpoint='/endpoint', hdrs=headers)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t            self.assertEqual(response['response'], 'success')\n", "    def test_api_call_headers_with_invalid_value(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with headers that have an invalid value.\"\"\"\n\t        headers = {'test': 'test'}\n\t        headers['test'] = 1 # type: ignore\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200, headers={'test': '1'})\n\t            result = self.plugin_class.make_api_call(host='http://example.com', endpoint='/endpoint', hdrs=headers)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n", "            self.assertEqual(response['response'], 'success')\n\t    # Test timeout_secs errors\n\t    def test_api_call_valid_timeout_secs(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with valid timeout_secs.\"\"\"\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=1)\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n", "    def test_api_call_timeout_secs_with_string(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a string.\"\"\"\n\t        # The string will be converted to an integer, so no error will be thrown\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='1') # type: ignore\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_timeout_secs_with_float(self):\n", "        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a float.\"\"\"\n\t        # The float will be converted to an integer, so no error will be thrown\n\t        with requests_mock.Mocker() as m:\n\t            m.get('http://example.com/endpoint', text='success', status_code=200)\n\t            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=1.0) # type: ignore\n\t            response = json.loads(result)\n\t            self.assertEqual(response['status'], 'success')\n\t            self.assertEqual(response['status_code'], 200)\n\t    def test_api_call_timeout_secs_with_negative_number(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a negative number.\"\"\"\n", "        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=-1)\n\t        self.assertIn(\"timeout_secs must be a positive integer\", str(excinfo.exception))\n\t    def test_api_call_timeout_secs_with_zero(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is zero.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=0)\n\t        self.assertIn(\"timeout_secs must be a positive integer\", str(excinfo.exception))\n\t    def test_api_call_timeout_secs_with_empty_string(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is an empty string.\"\"\"\n", "        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='') # type: ignore\n\t        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\t    def test_api_call_timeout_secs_with_none_value(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is None.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=None) # type: ignore\n\t        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\t    def test_api_call_timeout_secs_with_random_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is random text.\"\"\"\n", "        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='test') # type: ignore\n\t        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\t    def test_api_call_timeout_secs_with_control_code_text(self):\n\t        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a control code.\"\"\"\n\t        with self.assertRaises(ValueError) as excinfo:\n\t            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='\\x00') # type: ignore\n\t        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n"]}
{"filename": "src/autogpt_plugins/api_tools/__init__.py", "chunked_list": ["\"\"\"API Tools for Autogpt.\"\"\"\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\ttry:\n\t    from .api_tools import ApiCallCommand\n\texcept ImportError:\n\t    from api_tools import ApiCallCommand\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    \"\"\"Message type.\"\"\"\n", "    role: str\n\t    content: str\n\tclass AutoGPTApiTools(AutoGPTPluginTemplate):\n\t    \"\"\"\n\t    API Tools plugin for Autogpt.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"AutoGPTApiTools\"\n\t        self._version = \"0.1.2\"\n", "        self._description = \"Allow AutoGPT to make API calls to outside services.\"\n\t        self.plugin_class = ApiCallCommand()\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n", "        return response\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n", "        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n\t            self, prompt: PromptGenerator, messages: List[str]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completeion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n", "        \"\"\"\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completeion is done.\n\t        Args:\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return response\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n", "        return False\n\t    def pre_instruction(self, messages: List[str]) -> List[str]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            List[str]: The resulting list of messages.\n\t        \"\"\"\n\t        return messages\n\t    def can_handle_on_instruction(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[str]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n", "            Optional[str]: The resulting message.\n\t        \"\"\"\n\t    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n", "        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return response\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n", "            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n\t            self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n", "            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        return command_name, arguments\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n", "        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return ''\n\t    def can_handle_chat_completion(\n\t            self,\n", "            messages: list[Dict[Any, Any]],\n\t            model: str,\n\t            temperature: float,\n\t            max_tokens: int,\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the chat_completion method.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n", "            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t            self,\n\t            messages: list[Dict[Any, Any]],\n\t            model: str,\n\t            temperature: float,\n", "            max_tokens: int,\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n", "        \"\"\"\n\t        return ''\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        \"\"\"This method is called just after the generate_prompt is called,\n\t            but actually before the prompt is generated.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n\t            PromptGenerator: The prompt generator.\n\t        \"\"\"\n", "        prompt.add_command( # type: ignore\n\t            \"api\",\n\t            \"API Call\",\n\t            {\"host\": \"<str>\", \"endpoint\": \"<str>\", \"mthd\": \"<str>\", \"params\": \"<dict>\", \"body\": \"<str>\", \"hdrs\": \"<dict>\", \"timeout\": \"<int>\"},\n\t            self.plugin_class.make_api_call\n\t        )\n\t        return prompt\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n", "        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass\n\t    def can_handle_text_embedding(self, text: str) -> bool:\n\t        return False\n\t    def handle_text_embedding(self, text: str) -> list:  # type: ignore\n\t        pass"]}
{"filename": "src/autogpt_plugins/wolframalpha_search/__init__.py", "chunked_list": ["\"\"\"WolframAlpha search integrations.\"\"\"\n\timport os\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom wolframalpha import Client\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTWolframAlphaSearch(AutoGPTPluginTemplate):\n", "    \"\"\"\n\t    WolframAlpha search integrations\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"autogpt-wolframalpha-search\"\n\t        self._version = \"0.1.0\"\n\t        self._description = (\"WolframAlpha is an answer engine, it answers \"\n\t                             \"factual queries by computing answers from \"\n\t                             \"externally sourced data. It can provide answers \"\n", "                             \"to math, data and science queries.\")\n\t        self.wolframalpha_appid = os.getenv(\"WOLFRAMALPHA_APPID\")\n\t        self.api = None\n\t        if self.wolframalpha_appid is not None:\n\t            self.api = Client(self.wolframalpha_appid)\n\t        else:\n\t            print(\"WolframAlpha AppID not found in .env file.\")\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n", "        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n", "            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n\t            self, prompt: PromptGenerator, messages: List[str]\n", "    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completeion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n", "        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completeion is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n\t        return False\n\t    def pre_instruction(self, messages: List[str]) -> List[str]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n", "            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            List[str]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n", "        return False\n\t    def on_instruction(self, messages: List[str]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n", "            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n", "            self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        pass\n", "    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n\t            self,\n\t            messages: list[Dict[Any, Any]],\n\t            model: str,\n\t            temperature: float,\n", "            max_tokens: int,\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the chat_completion method.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n", "            bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t            self,\n\t            messages: list[Dict[Any, Any]],\n\t            model: str,\n\t            temperature: float,\n\t            max_tokens: int,\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n", "        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return None\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n", "        \"\"\"This method is called just after the generate_prompt is called,\n\t            but actually before the prompt is generated.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n\t            PromptGenerator: The prompt generator.\n\t        \"\"\"\n\t        if self.api:\n\t            from .wolframalpha_search import _wolframalpha_search\n\t            prompt.add_command(\n", "                \"wolframalpha_search\",\n\t                self._description,\n\t                {\"query\": \"<query>\"},\n\t                _wolframalpha_search,\n\t            )\n\t        return prompt\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n", "    def handle_text_embedding(\n\t        self, text: str\n\t    ) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n", "    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/wolframalpha_search/test_wolframalpha_search.py", "chunked_list": ["import os\n\timport unittest\n\timport requests\n\tfrom . import AutoGPTWolframAlphaSearch\n\tclass TestAutoGPTWolframAlphaSearch(unittest.TestCase):\n\t    def setUp(self):\n\t        os.environ[\"WOLFRAMALPHA_APPID\"] = \"test_appid\"\n\t        self.plugin = AutoGPTWolframAlphaSearch()\n\t    def tearDown(self):\n\t        os.environ.pop(\"WOLFRAMALPHA_APPID\", None)\n", "    def test_wolframalpha_search(self):\n\t        query = \"2+2\"\n\t        try:\n\t            from .wolframalpha_search import _wolframalpha_search\n\t            _wolframalpha_search(query)\n\t        except requests.exceptions.HTTPError as e:\n\t            self.assertEqual(e.response.status_code, 401)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/wolframalpha_search/wolframalpha_search.py", "chunked_list": ["from . import AutoGPTWolframAlphaSearch\n\tplugin = AutoGPTWolframAlphaSearch()\n\tdef _wolframalpha_search(query: str) -> str | list[str]:\n\t    res = \"\"\n\t    try:\n\t        ans = plugin.api.query(query)\n\t        res = next(ans.results).text\n\t    except Exception as e:\n\t        return f\"'_wolframalpha_search' on query: '{query}' raised exception: '{e}'\"\n\t    return res\n"]}
{"filename": "src/autogpt_plugins/scenex/test_scenex_plugin.py", "chunked_list": ["from .scenex_plugin import SceneXplain\n\tMOCK_API_KEY = \"secret\"\n\tMOCK_IMAGE = \"https://example.com/image.png\"\n\tMOCK_DESCRIPTION = \"example description\"\n\tdef test_describe_image(requests_mock):\n\t    requests_mock.post(\n\t        SceneXplain.API_ENDPOINT,\n\t        json={\n\t            \"result\": [\n\t                {\n", "                    \"image\": MOCK_IMAGE,\n\t                    \"text\": MOCK_DESCRIPTION,\n\t                }\n\t            ]\n\t        },\n\t    )\n\t    scenex = SceneXplain(MOCK_API_KEY)\n\t    result = scenex.describe_image(\n\t        image=MOCK_IMAGE,\n\t        algorithm=\"Dune\",\n", "        features=[],\n\t        languages=[],\n\t    )\n\t    # Check the results\n\t    assert result == {\n\t        \"image\": MOCK_IMAGE,\n\t        \"description\": MOCK_DESCRIPTION,\n\t    }\n\t    # Check that the mocked functions were called with the correct arguments\n\t    requests_mock.request_history[0].json() == {\n", "        \"data\": [\n\t            {\n\t                \"image\": MOCK_IMAGE,\n\t                \"algorithm\": \"Dune\",\n\t                \"features\": [],\n\t                \"languages\": [],\n\t            }\n\t        ]\n\t    }\n"]}
{"filename": "src/autogpt_plugins/scenex/__init__.py", "chunked_list": ["\"\"\"This is a SceneX plugin for describing images for Auto-GPT.\"\"\"\n\timport os\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom colorama import Fore\n\tfrom .scenex_plugin import SceneXplain\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n", "class AutoGPTSceneXPlugin(AutoGPTPluginTemplate):\n\t    \"\"\"\n\t    This is the Auto-GPT SceneX plugin.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"ImageExplainer\"\n\t        self._version = \"0.0.1\"\n\t        self._description = (\n\t            \"An Image Captioning Tool: Use this tool to generate a detailed caption for an image. \"\n", "            \"The input can be an image file of any format, and \"\n\t            \"the output will be a text description that covers every detail of the image.\"\n\t        )\n\t        self._api_key = os.getenv(\"SCENEX_API_KEY\")\n\t        self.scenexplain = SceneXplain(self._api_key)\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        if self._api_key:\n\t            prompt.add_command(\n\t                self._description,\n\t                \"describe_image\",\n", "                {\n\t                    \"image\": \"<image>\",\n\t                },\n\t                self.scenexplain.describe_image,\n\t            )\n\t        else:\n\t            print(\n\t                Fore.RED\n\t                + f\"{self._name} - {self._version} - SceneX plugin not loaded, because SCENEX_API_KEY was not set in env.\"\n\t            )\n", "        return prompt\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n", "        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n", "            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[Message]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completion is done.\n\t        Args:\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n", "        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            List[Message]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n", "            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n", "        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n", "        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n", "        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n", "    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n", "        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t          handle the chat_completion method.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t          Returns:\n", "              bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n", "            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n", "        self, text: str\n\t    ) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n", "        pass"]}
{"filename": "src/autogpt_plugins/scenex/scenex_plugin.py", "chunked_list": ["from typing import List, Union\n\timport requests\n\tAlgorithm = Union[\"Aqua\", \"Bolt\", \"Comet\", \"Dune\", \"Ember\", \"Flash\"]\n\tclass SceneXplain:\n\t    API_ENDPOINT = \"https://us-central1-causal-diffusion.cloudfunctions.net/describe\"\n\t    def __init__(self, api_key):\n\t        self._api_key = api_key\n\t    def describe_image(\n\t        self,\n\t        image: str,\n", "        algorithm: Algorithm = \"Dune\",\n\t        features: List[str] = [],\n\t        languages: List[str] = [],\n\t    ) -> str:\n\t        headers = {\n\t            \"x-api-key\": f\"token {self._api_key}\",\n\t            \"content-type\": \"application/json\",\n\t        }\n\t        payload = {\n\t            \"data\": [\n", "                {\n\t                    \"image\": image,\n\t                    \"algorithm\": algorithm,\n\t                    \"features\": features,\n\t                    \"languages\": languages,\n\t                }\n\t            ]\n\t        }\n\t        response = requests.post(self.API_ENDPOINT, headers=headers, json=payload)\n\t        result = response.json().get(\"result\", [])\n", "        img = result[0] if result else {}\n\t        return {\"image\": image, \"description\": img.get(\"text\", \"\")}\n"]}
{"filename": "src/autogpt_plugins/astro/test_astro_plugin.py", "chunked_list": ["from .astronauts import get_num_astronauts\n\tdef test_astro():\n\t    assert type(get_num_astronauts())==int"]}
{"filename": "src/autogpt_plugins/astro/__init__.py", "chunked_list": ["\"\"\"This is the email plugin for Auto-GPT.\"\"\"\n\timport os\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTSpacePlugin(AutoGPTPluginTemplate):\n\t    \"\"\"\n", "    This is the Auto-GPT space plugin.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"Auto-GPT-Space-Plugin\"\n\t        self._version = \"0.1.3\"\n\t        self._description = \"Auto-GPT Space Plugin: Get the number of astronauts in space in real-time..\"\n\t        self.load_commands = True\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        if self.load_commands:\n", "            from .astronauts import get_num_astronauts\n\t            prompt.add_command(\n\t                \"Get number of astronauts\",\n\t                \"get_num_astronauts\",\n\t                {},\n\t                get_num_astronauts,\n\t            )\n\t        return prompt\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n", "        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n", "    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n", "        self, prompt: PromptGenerator, messages: List[Message]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n", "        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completion is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n", "        \"\"\"\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n\t        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n\t        \"\"\"This method is called before the instruction chat is done.\n", "        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            List[Message]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n", "            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n", "    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n", "        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n", "    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n", "            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n\t        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n", "          handle the chat_completion method.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t          Returns:\n\t              bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n", "        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n", "        \"\"\"\n\t        pass\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n\t        self, text: str\n\t    ) -> list:\n\t        pass\n", "    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/astro/astronauts.py", "chunked_list": ["import requests\n\tdef get_num_astronauts():\n\t    \"\"\"Get the number of astronauts in space.\n\t    Args:\n\t        None\n\t    Returns:\n\t        int: The number of astronauts in space.\n\t    \"\"\"\n\t    #Get the data\n\t    response = requests.get(\"http://api.open-notify.org/astros.json\")\n", "    #Convert it to JSON\n\t    data = response.json()\n\t    #Extract the number and return it\n\t    return data[\"number\"]\n"]}
{"filename": "src/autogpt_plugins/telegram/telegram_chat.py", "chunked_list": ["import asyncio\n\timport os\n\timport random\n\timport traceback\n\tfrom telegram import Bot, Update\n\tfrom telegram.error import TimedOut\n\tfrom telegram.ext import CallbackContext\n\tresponse_queue = \"\"\n\tclass TelegramUtils:\n\t    def __init__(self, api_key: str = None, chat_id: str = None):\n", "        if not api_key:\n\t            print(\n\t                \"No api key provided. Please set the TELEGRAM_API_KEY environment variable.\"\n\t            )\n\t            print(\"You can get your api key by talking to @BotFather on Telegram.\")\n\t            print(\n\t                \"For more information, please visit: https://core.telegram.org/bots/tutorial#6-botfather\"\n\t            )\n\t            return\n\t        self.api_key = api_key\n", "        if not chat_id:\n\t            print(\n\t                \"TELEGRAM PLUGIN: No chat id provided. Please set the TELEGRAM_CHAT_ID environment variable.\"\n\t            )\n\t            user_input = input(\n\t                \"Would you like to send a test message to your bot to get the id? (y/n): \"\n\t            )\n\t            if user_input == \"y\":\n\t                try:\n\t                    print(\"Please send a message to your telegram bot now.\")\n", "                    update = self.poll_anyMessage()\n\t                    print(\"Message received! Getting chat id...\")\n\t                    chat_id = update.message.chat.id\n\t                    print(\"Your chat id is: \" + str(chat_id))\n\t                    print(\"And the message is: \" + update.message.text)\n\t                    confirmation = random.randint(1000, 9999)\n\t                    print(\"Sending confirmation message: \" + str(confirmation))\n\t                    text = f\"Hello! Your chat id is: {chat_id} and the confirmation code is: {confirmation}\"\n\t                    self.chat_id = chat_id\n\t                    self.send_message(text)  # Send confirmation message\n", "                    print(\n\t                        \"Please set the TELEGRAM_CHAT_ID environment variable to this value.\"\n\t                    )\n\t                except TimedOut:\n\t                    print(\n\t                        \"Error while sending test message. Please check your Telegram bot.\"\n\t                    )\n\t            return\n\t        self.chat_id = chat_id\n\t    def poll_anyMessage(self):\n", "        loop = asyncio.new_event_loop()\n\t        asyncio.set_event_loop(loop)\n\t        return loop.run_until_complete(self.poll_anyMessage_async())\n\t    async def poll_anyMessage_async(self):\n\t        bot = Bot(token=self.api_key)\n\t        last_update = await bot.get_updates(timeout=30)\n\t        if len(last_update) > 0:\n\t            last_update_id = last_update[-1].update_id\n\t        else:\n\t            last_update_id = -1\n", "        while True:\n\t            try:\n\t                print(\"Waiting for first message...\")\n\t                updates = await bot.get_updates(offset=last_update_id + 1, timeout=30)\n\t                for update in updates:\n\t                    if update.message:\n\t                        return update\n\t            except Exception as e:\n\t                print(f\"Error while polling updates: {e}\")\n\t            await asyncio.sleep(1)\n", "    def is_authorized_user(self, update: Update):\n\t        return update.effective_user.id == int(self.chat_id)\n\t    def handle_response(self, update: Update, context: CallbackContext):\n\t        try:\n\t            print(\"Received response: \" + update.message.text)\n\t            if self.is_authorized_user(update):\n\t                response_queue.put(update.message.text)\n\t        except Exception as e:\n\t            print(e)\n\t    async def delete_old_messages(self):\n", "        bot = await self.get_bot()\n\t        updates = await bot.get_updates(offset=0)\n\t        count = 0\n\t        for update in updates:\n\t            try:\n\t                print(\n\t                    \"Deleting message: \"\n\t                    + update.message.text\n\t                    + \" \"\n\t                    + str(update.message.message_id)\n", "                )\n\t                await bot.delete_message(\n\t                    chat_id=update.message.chat.id, message_id=update.message.message_id\n\t                )\n\t            except Exception as e:\n\t                print(\n\t                    f\"Error while deleting message: {e} \\n\"\n\t                    + f\" update: {update} \\n {traceback.format_exc()}\"\n\t                )\n\t            count += 1\n", "        if count > 0:\n\t            print(\"Cleaned up old messages.\")\n\t    async def get_bot(self):\n\t        bot_token = self.api_key\n\t        bot = Bot(token=bot_token)\n\t        commands = await bot.get_my_commands()\n\t        if len(commands) == 0:\n\t            await self.set_commands(bot)\n\t        commands = await bot.get_my_commands()\n\t        return bot\n", "    async def set_commands(self, bot):\n\t        await bot.set_my_commands(\n\t            [\n\t                (\"start\", \"Start Auto-GPT\"),\n\t                (\"stop\", \"Stop Auto-GPT\"),\n\t                (\"help\", \"Show help\"),\n\t                (\"yes\", \"Confirm\"),\n\t                (\"no\", \"Deny\"),\n\t                (\"auto\", \"Let an Agent decide\"),\n\t            ]\n", "        )\n\t    def send_message(self, message):\n\t        try:\n\t            loop = asyncio.get_running_loop()\n\t        except RuntimeError as e:  # 'RuntimeError: There is no current event loop...'\n\t            loop = None\n\t        try:\n\t            if loop and loop.is_running():\n\t                print(\n\t                    \"Sending message async, if this fials its due to rununtil complete task\"\n", "                )\n\t                loop.create_task(self._send_message(message=message))\n\t            else:\n\t                eventloop = asyncio.get_event_loop\n\t                if hasattr(eventloop, \"run_until_complete\") and eventloop.is_running():\n\t                    print(\"Event loop is running\")\n\t                    eventloop.run_until_complete(self._send_message(message=message))\n\t                else:\n\t                    asyncio.run(self._send_message(message=message))\n\t        except RuntimeError as e:\n", "            print(traceback.format_exc())\n\t            print(\"Error while sending message\")\n\t            print(e)\n\t    def send_voice(self, voice_file):\n\t        try:\n\t            self.get_bot().send_voice(\n\t                chat_id=self.chat_id, voice=open(voice_file, \"rb\")\n\t            )\n\t        except RuntimeError:\n\t            print(\"Error while sending voice message\")\n", "    async def _send_message(self, message):\n\t        print(\"Sending message to Telegram.. \")\n\t        recipient_chat_id = self.chat_id\n\t        bot = await self.get_bot()\n\t        # properly handle messages with more than 2000 characters by chunking them\n\t        if len(message) > 2000:\n\t            message_chunks = [\n\t                message[i : i + 2000] for i in range(0, len(message), 2000)\n\t            ]\n\t            for message_chunk in message_chunks:\n", "                await bot.send_message(chat_id=recipient_chat_id, text=message_chunk)\n\t        else:\n\t            await bot.send_message(chat_id=recipient_chat_id, text=message)\n\t    async def ask_user_async(self, prompt):\n\t        global response_queue\n\t        # only display confirm if the prompt doesnt have the string \"\"Continue (y/n):\"\" inside\n\t        if \"Continue (y/n):\" in prompt or \"Waiting for your response...\" in prompt:\n\t            question = (\n\t                prompt\n\t                + \" \\n Confirm: /yes     Decline: /no \\n Or type your answer. \\n or press /auto to let an Agent decide.\"\n", "            )\n\t        elif \"I want Auto-GPT to:\" in prompt:\n\t            question = prompt\n\t        else:\n\t            question = (\n\t                prompt + \" \\n Type your answer or press /auto to let an Agent decide.\"\n\t            )\n\t        response_queue = \"\"\n\t        # await delete_old_messages()\n\t        print(\"Asking user: \" + question)\n", "        await self._send_message(message=question)\n\t        print(\"Waiting for response on Telegram chat...\")\n\t        await self._poll_updates()\n\t        if response_queue == \"/start\":\n\t            response_queue = await self.ask_user(\n\t                self,\n\t                prompt=\"I am already here... \\n Please use /stop to stop me first.\",\n\t            )\n\t        if response_queue == \"/help\":\n\t            response_queue = await self.ask_user(\n", "                self,\n\t                prompt=\"You can use /stop to stop me \\n and /start to start me again.\",\n\t            )\n\t        if response_queue == \"/auto\":\n\t            return \"s\"\n\t        if response_queue == \"/stop\":\n\t            await self._send_message(\"Stopping Auto-GPT now!\")\n\t            exit(0)\n\t        elif response_queue == \"/yes\":\n\t            response_text = \"yes\"\n", "            response_queue = \"yes\"\n\t        elif response_queue == \"/no\":\n\t            response_text = \"no\"\n\t            response_queue = \"no\"\n\t        if response_queue.capitalize() in [\n\t            \"Yes\",\n\t            \"Okay\",\n\t            \"Ok\",\n\t            \"Sure\",\n\t            \"Yeah\",\n", "            \"Yup\",\n\t            \"Yep\",\n\t        ]:\n\t            response_text = \"y\"\n\t        elif response_queue.capitalize() in [\"No\", \"Nope\", \"Nah\", \"N\"]:\n\t            response_text = \"n\"\n\t        else:\n\t            response_text = response_queue\n\t        print(\"Response received from Telegram: \" + response_text)\n\t        return response_text\n", "    async def _poll_updates(self):\n\t        global response_queue\n\t        bot = await self.get_bot()\n\t        print(\"getting updates...\")\n\t        try:\n\t            last_update = await bot.get_updates(timeout=1)\n\t            if len(last_update) > 0:\n\t                last_update_id = last_update[-1].update_id\n\t            else:\n\t                last_update_id = -1\n", "            print(\"last update id: \" + str(last_update_id))\n\t            while True:\n\t                try:\n\t                    print(\"Polling updates...\")\n\t                    updates = await bot.get_updates(\n\t                        offset=last_update_id + 1, timeout=30\n\t                    )\n\t                    for update in updates:\n\t                        if update.message and update.message.text:\n\t                            if self.is_authorized_user(update):\n", "                                response_queue = update.message.text\n\t                                return\n\t                        last_update_id = max(last_update_id, update.update_id)\n\t                except Exception as e:\n\t                    print(f\"Error while polling updates: {e}\")\n\t                await asyncio.sleep(1)\n\t        except RuntimeError:\n\t            print(\"Error while polling updates\")\n\t    def ask_user(self, prompt):\n\t        print(\"Asking user: \" + prompt)\n", "        try:\n\t            loop = asyncio.get_running_loop()\n\t        except RuntimeError:  # 'RuntimeError: There is no current event loop...'\n\t            loop = None\n\t        try:\n\t            if loop and loop.is_running():\n\t                return loop.create_task(self.ask_user_async(prompt=prompt))\n\t            else:\n\t                return asyncio.run(self.ask_user_async(prompt=prompt))\n\t        except TimedOut:\n", "            print(\"Telegram timeout error, trying again...\")\n\t            return self.ask_user(prompt=prompt)\n\tif __name__ == \"__main__\":\n\t    telegram_api_key = os.getenv(\"TELEGRAM_API_KEY\")\n\t    telegram_chat_id = os.getenv(\"TELEGRAM_CHAT_ID\")\n\t    telegram_utils = TelegramUtils(chat_id=telegram_chat_id, api_key=telegram_api_key)\n\t    telegram_utils.send_message(\"Hello World!\")\n"]}
{"filename": "src/autogpt_plugins/telegram/__init__.py", "chunked_list": ["\"\"\"Telegram controller bot integration using python-telegram-bot.\"\"\"\n\timport os\n\timport re\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom .telegram_chat import TelegramUtils\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n", "def remove_color_codes(s: str) -> str:\n\t    ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n\t    return ansi_escape.sub(\"\", s)\n\tclass AutoGPTTelegram(AutoGPTPluginTemplate):\n\t    \"\"\"\n\t    Telegram controller bot integration using python-telegram-bot.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"Auto-GPT-Telegram\"\n", "        self._version = \"0.2.0\"\n\t        self._description = (\n\t            \"This integrates a Telegram chat bot with your autogpt instance.\"\n\t        )\n\t        self.telegram_api_key = os.getenv(\"TELEGRAM_API_KEY\", None)\n\t        self.telegram_chat_id = os.getenv(\"TELEGRAM_CHAT_ID\", None)\n\t        self.telegram_utils = TelegramUtils(\n\t            chat_id=self.telegram_chat_id, api_key=self.telegram_api_key\n\t        )\n\t    def can_handle_on_response(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n", "        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return False\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        \"\"\"This method is called just after the generate_prompt is called,\n\t            but actually before the prompt is generated.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n", "            PromptGenerator: The prompt generator.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n", "        self, prompt: PromptGenerator, messages: List[Message]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n", "        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completion is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n", "        \"\"\"\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n\t        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n\t        \"\"\"This method is called before the instruction chat is done.\n", "        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            List[Message]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n", "            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n", "    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n", "        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n", "    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n", "            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n\t        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n", "          handle the chat_completion method.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t          Returns:\n\t              bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n", "        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            str: The resulting response.\n", "        \"\"\"\n\t        pass\n\t    def can_handle_text_embedding(self, text: str) -> bool:\n\t        return False\n\t    def handle_text_embedding(self, text: str) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return True\n\t    def user_input(self, user_input: str) -> str:\n\t        user_input = remove_color_codes(user_input)\n", "        # if the user_input is too long, shorten it\n\t        try:\n\t            return self.telegram_utils.ask_user(prompt=user_input)\n\t        except Exception as e:\n\t            print(e)\n\t            print(\"Error sending message to telegram\")\n\t            return \"s\"\n\t    def can_handle_report(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the report method.\n", "        Returns:\n\t            bool: True if the plugin can handle the report method.\"\"\"\n\t        return True\n\t    def report(self, message: str) -> None:\n\t        message = remove_color_codes(message)\n\t        # if the message is too long, shorten it\n\t        try :\n\t            self.telegram_utils.send_message(message=message)\n\t        except Exception as e:\n\t            print(e)\n", "            print(\"Error sending message to telegram\")\n\t    def can_handle_text_embedding(self, text: str) -> bool:\n\t        return False\n\t    def handle_text_embedding(self, text: str) -> list:\n\t        pass\n"]}
{"filename": "src/autogpt_plugins/baidu_search/baidu_search.py", "chunked_list": ["import json\n\timport os\n\timport re\n\timport requests\n\tfrom bs4 import BeautifulSoup\n\tdef _baidu_search(query: str, num_results=8):\n\t    '''\n\t    Perform a Baidu search and return the results as a JSON string.\n\t    '''\n\t    headers = {\n", "        'Cookie': os.getenv(\"BAIDU_COOKIE\"),\n\t        'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:112.0) Gecko/20100101 Firefox/112.0\"\n\t    }\n\t    url = f'https://www.baidu.com/s?wd={query}&rn={num_results}'\n\t    response = requests.get(url, headers=headers)\n\t    response.encoding = 'utf-8'\n\t    soup = BeautifulSoup(response.text, 'html.parser')\n\t    search_results = []\n\t    for result in soup.find_all('div', class_=re.compile('^result c-container ')):\n\t        title = result.find('h3', class_='t').get_text()\n", "        link = result.find('a', href=True)['href']\n\t        snippet = result.find('span', class_=re.compile('^content-right_8Zs40'))\n\t        if snippet:\n\t            snippet = snippet.get_text()\n\t        else:\n\t            snippet = ''\n\t        search_results.append({\n\t            'title': title,\n\t            'href': link,\n\t            'snippet': snippet\n", "        })\n\t    return json.dumps(search_results, ensure_ascii=False, indent=4)"]}
{"filename": "src/autogpt_plugins/baidu_search/__init__.py", "chunked_list": ["\"\"\"This is the Baidu search engines plugin for Auto-GPT.\"\"\"\n\timport os\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom .baidu_search import _baidu_search\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTBaiduSearch(AutoGPTPluginTemplate):\n", "    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"Baidu-Search-Plugin\"\n\t        self._version = \"0.1.0\"\n\t        self._description = (\n\t            \"This plugin performs Baidu searches using the provided query.\"\n\t        )\n\t        self.load_commands = (\n\t            os.getenv(\"SEARCH_ENGINE\")\n\t            and os.getenv(\"SEARCH_ENGINE\").lower() == \"baidu\"\n", "            and os.getenv(\"BAIDU_COOKIE\")\n\t        )\n\t    def can_handle_post_prompt(self) -> bool:\n\t        return True\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        if self.load_commands:\n\t            # Add Baidu Search command\n\t            prompt.add_command(\n\t                \"Baidu Search\",\n\t                \"baidu_search\",\n", "                {\"query\": \"<query>\"},\n\t                _baidu_search,\n\t            )\n\t        else:\n\t            print(\n\t                \"Warning: Baidu-Search-Plugin is not fully functional. \"\n\t                \"Please set the SEARCH_ENGINE and BAIDU_COOKIE environment variables.\"\n\t            )\n\t        return prompt\n\t    def can_handle_pre_command(self) -> bool:\n", "        return True\n\t    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        if command_name == \"google\" and self.load_commands:\n\t            return \"baidu_search\", {\"query\": arguments[\"query\"]}\n\t        else:\n\t            return command_name, arguments\n\t    def can_handle_post_command(self) -> bool:\n\t        return False\n", "    def post_command(self, command_name: str, response: str) -> str:\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[Message]\n\t    ) -> Optional[str]:\n\t        pass\n\t    def can_handle_on_response(self) -> bool:\n\t        return False\n", "    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n\t        pass\n", "    def can_handle_on_instruction(self) -> bool:\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        pass\n\t    def can_handle_chat_completion(\n\t        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n", "    ) -> bool:\n\t        return False\n\t    def handle_chat_completion(\n\t        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n\t    ) -> str:\n\t        pass\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n", "    def handle_text_embedding(\n\t        self, text: str\n\t    ) -> list:\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n", "    def report(self, message: str) -> None:\n\t        pass\n"]}
{"filename": "src/autogpt_plugins/baidu_search/test_auto_gpt_baidu_plugin.py", "chunked_list": ["import os\n\timport unittest\n\tfrom typing import List\n\timport requests\n\tfrom . import AutoGPTBaiduSearch\n\tfrom .baidu_search import _baidu_search\n\tclass TestAutoGPTBaiduSearch(unittest.TestCase):\n\t    def setUp(self):\n\t        os.environ[\"BAIDU_COOKIE\"] = \"test_cookie\"\n\t        os.environ[\"SEARCH_ENGINE\"] = \"baidu\"\n", "        self.plugin = AutoGPTBaiduSearch()\n\t    def tearDown(self):\n\t        os.environ.pop(\"SEARCH_ENGINE\", None)\n\t        os.environ.pop(\"BAIDU_COOKIE\", None)\n\t    def test_baidu_search(self):\n\t        query = \"test query\"\n\t        try:\n\t            _baidu_search(query)\n\t        except requests.exceptions.HTTPError as e:\n\t            self.assertEqual(e.response.status_code, 401)\n", "    def test_pre_command(self):\n\t        os.environ[\"SEARCH_ENGINE\"] = \"baidu\"\n\t        self.plugin = AutoGPTBaiduSearch()\n\t        command_name, arguments = self.plugin.pre_command(\n\t            \"google\", {\"query\": \"test query\"}\n\t        )\n\t        self.assertEqual(command_name, \"baidu_search\")\n\t        self.assertEqual(arguments, {\"query\": \"test query\"})\n\t    def test_can_handle_pre_command(self):\n\t        self.assertTrue(self.plugin.can_handle_pre_command())\n", "    def test_can_handle_post_prompt(self):\n\t        self.assertTrue(self.plugin.can_handle_post_prompt())\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/email/__init__.py", "chunked_list": ["\"\"\"This is the email plugin for Auto-GPT.\"\"\"\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom colorama import Fore\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTEmailPlugin(AutoGPTPluginTemplate):\n\t    \"\"\"\n", "    This is the Auto-GPT email plugin.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"Auto-GPT-Email-Plugin\"\n\t        self._version = \"0.2.0\"\n\t        self._description = \"This plugin reads and send emails.\"\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        from .email_plugin.email_plugin import (\n\t            bothEmailAndPwdSet,\n", "            read_emails,\n\t            send_email,\n\t            send_email_with_attachment,\n\t        )\n\t        if bothEmailAndPwdSet():\n\t            prompt.add_command(\n\t                \"Read Emails\",\n\t                \"read_emails\",\n\t                {\n\t                    \"imap_folder\": \"<imap_folder>\",\n", "                    \"imap_search_command\": \"<imap_search_criteria_command>\",\n\t                    \"limit\": \"<email_count_return_limit>\",\n\t                    \"page\": \"<number_of_email_results_page>\",\n\t                },\n\t                read_emails,\n\t            )\n\t            prompt.add_command(\n\t                \"Send Email\",\n\t                \"send_email\",\n\t                {\"to\": \"<to>\", \"subject\": \"<subject>\", \"body\": \"<body>\"},\n", "                send_email,\n\t            )\n\t            prompt.add_command(\n\t                \"Send Email\",\n\t                \"send_email_with_attachment\",\n\t                {\n\t                    \"to\": \"<to>\",\n\t                    \"subject\": \"<subject>\",\n\t                    \"body\": \"<body>\",\n\t                    \"filename\": \"<attachment filename>\",\n", "                },\n\t                send_email_with_attachment,\n\t            )\n\t        else:\n\t            print(\n\t                Fore.RED\n\t                + f\"{self._name} - {self._version} - Email plugin not loaded, because EMAIL_PASSWORD or EMAIL_ADDRESS were not set in env.\"\n\t            )\n\t        return prompt\n\t    def can_handle_post_prompt(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n", "        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n", "    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[Message]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completion is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n", "            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n\t        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n", "        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            List[Message]: The resulting list of messages.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n", "        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[Message]): The list of context messages.\n\t        Returns:\n\t            Optional[str]: The resulting message.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n\t        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n", "        return False\n\t    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n\t        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n", "        \"\"\"\n\t        pass\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n", "        Args:\n\t            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_chat_completion(\n\t        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n\t    ) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t          handle the chat_completion method.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t          Returns:\n\t              bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n", "    def handle_chat_completion(\n\t        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (List[Message]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n", "            str: The resulting response.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n\t        self, text: str\n\t    ) -> list:\n", "        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/email/email_plugin/test_email_plugin.py", "chunked_list": ["import os\n\timport unittest\n\tfrom email.message import EmailMessage\n\tfrom functools import partial\n\tfrom unittest.mock import mock_open, patch\n\tfrom email_plugin import (\n\t    adjust_imap_folder_for_gmail,\n\t    bothEmailAndPwdSet,\n\t    enclose_with_quotes,\n\t    imap_open,\n", "    read_emails,\n\t    send_email,\n\t    send_email_with_attachment_internal,\n\t    split_imap_search_command,\n\t)\n\tMOCK_FROM = \"sender@example.com\"\n\tMOCK_PWD = \"secret\"\n\tMOCK_TO = \"test@example.com\"\n\tMOCK_DATE = \"Fri, 21 Apr 2023 10:00:00 -0000\"\n\tMOCK_CONTENT = \"Test message\"\n", "MOCK_CONTENT_DIRTY = \"\"\"\n\t                        <html>\n\t                            <head>\n\t                                <title> Email Title </title>\n\t                            </head>\n\t                            <body>\n\t                                This is an\n\t                                <div>email template</div>\n\t                                with a \\n return character\n\t                                and a link at the end</a>\n", "                            </body>\n\t                        </html>\n\t                         (https://e.com) \n\t                    \"\"\"\n\tMOCK_SUBJECT = \"Test Subject\"\n\tMOCK_IMAP_SERVER = \"imap.example.com\"\n\tMOCK_SMTP_SERVER = \"smtp.example.com\"\n\tMOCK_SMTP_PORT = \"587\"\n\tMOCK_DRAFT_FOLDER = \"Example/Drafts\"\n\tMOCK_ATTACHMENT_PATH = \"example/file.txt\"\n", "MOCK_ATTACHMENT_NAME = \"file.txt\"\n\tclass TestEmailPlugin(unittest.TestCase):\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": \"test@example.com\",\n\t            \"EMAIL_PASSWORD\": \"test_password\",\n\t        },\n\t    )\n\t    def test_both_email_and_pwd_set(self):\n", "        self.assertTrue(bothEmailAndPwdSet())\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_PASSWORD\": \"test_password\",\n\t        },\n\t        clear=True,\n\t    )\n\t    def test_email_not_set(self):\n\t        self.assertFalse(bothEmailAndPwdSet())\n", "    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": \"\",\n\t            \"EMAIL_PASSWORD\": \"test_password\",\n\t        },\n\t        clear=True,\n\t    )\n\t    def test_email_not_set_2(self):\n\t        self.assertFalse(bothEmailAndPwdSet())\n", "    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": \"test@example.com\",\n\t        },\n\t        clear=True,\n\t    )\n\t    def test_pwd_not_set(self):\n\t        self.assertFalse(bothEmailAndPwdSet())\n\t    @patch.dict(os.environ, {}, clear=True)\n", "    def test_both_email_and_pwd_not_set(self):\n\t        self.assertFalse(bothEmailAndPwdSet())\n\t    def test_adjust_imap_folder_for_gmail_normal_cases(self):\n\t        self.assertEqual(\n\t            adjust_imap_folder_for_gmail(\"Sent\", \"user@gmail.com\"),\n\t            '\"[Gmail]/Sent Mail\"',\n\t        )\n\t        self.assertEqual(\n\t            adjust_imap_folder_for_gmail(\"Drafts\", \"user@googlemail.com\"),\n\t            \"[Gmail]/Drafts\",\n", "        )\n\t        self.assertEqual(\n\t            adjust_imap_folder_for_gmail(\"Inbox\", \"user@gmail.com\"), \"Inbox\"\n\t        )\n\t    def test_adjust_imap_folder_for_gmail_case_insensitivity(self):\n\t        self.assertEqual(\n\t            adjust_imap_folder_for_gmail(\"SeNT\", \"user@GMail.com\"),\n\t            '\"[Gmail]/Sent Mail\"',\n\t        )\n\t        self.assertEqual(\n", "            adjust_imap_folder_for_gmail(\"DRAFTS\", \"user@gOogLemail.com\"),\n\t            \"[Gmail]/Drafts\",\n\t        )\n\t        self.assertEqual(\n\t            adjust_imap_folder_for_gmail(\"InbOx\", \"user@gmail.com\"), \"InbOx\"\n\t        )\n\t    def test_adjust_imap_folder_for_gmail_non_gmail_sender(self):\n\t        self.assertEqual(adjust_imap_folder_for_gmail(\"Sent\", \"user@yahoo.com\"), \"Sent\")\n\t        self.assertEqual(\n\t            adjust_imap_folder_for_gmail(\"Drafts\", \"user@hotmail.com\"), \"Drafts\"\n", "        )\n\t        self.assertEqual(\n\t            adjust_imap_folder_for_gmail(\"SENT\", \"gmail@hotmail.com\"), \"SENT\"\n\t        )\n\t    def test_adjust_imap_folder_for_gmail_edge_cases(self):\n\t        self.assertEqual(adjust_imap_folder_for_gmail(\"\", \"user@gmail.com\"), \"\")\n\t        self.assertEqual(adjust_imap_folder_for_gmail(\"Inbox\", \"\"), \"Inbox\")\n\t        self.assertEqual(adjust_imap_folder_for_gmail(\"\", \"\"), \"\")\n\t    def test_enclose_with_quotes(self):\n\t        assert enclose_with_quotes(\"REVERSE DATE\") == '\"REVERSE DATE\"'\n", "        assert enclose_with_quotes('\"My Search\"') == '\"My Search\"'\n\t        assert enclose_with_quotes(\"'test me'\") == \"'test me'\"\n\t        assert enclose_with_quotes(\"ALL\") == \"ALL\"\n\t        assert enclose_with_quotes(\"quotes needed\") == '\"quotes needed\"'\n\t        assert enclose_with_quotes(\"   whitespace  \") == '\"   whitespace  \"'\n\t        assert enclose_with_quotes(\"whitespace\\te\") == '\"whitespace\\te\"'\n\t        assert enclose_with_quotes(\"\\\"mixed quotes'\") == \"\\\"mixed quotes'\"\n\t        assert enclose_with_quotes(\"'mixed quotes\\\"\") == \"'mixed quotes\\\"\"\n\t    def test_split_imap_search_command(self):\n\t        self.assertEqual(split_imap_search_command(\"SEARCH\"), [\"SEARCH\"])\n", "        self.assertEqual(\n\t            split_imap_search_command(\"SEARCH UNSEEN\"), [\"SEARCH\", \"UNSEEN\"]\n\t        )\n\t        self.assertEqual(\n\t            split_imap_search_command(\"  SEARCH   UNSEEN  \"), [\"SEARCH\", \"UNSEEN\"]\n\t        )\n\t        self.assertEqual(\n\t            split_imap_search_command(\n\t                \"FROM speixoto@caicm.ca SINCE 01-JAN-2022 BEFORE 01-FEB-2023 HAS attachment xls OR HAS attachment xlsx\"\n\t            ),\n", "            [\n\t                \"FROM\",\n\t                \"speixoto@caicm.ca SINCE 01-JAN-2022 BEFORE 01-FEB-2023 HAS attachment xls OR HAS attachment xlsx\",\n\t            ],\n\t        )\n\t        self.assertEqual(\n\t            split_imap_search_command(\"BODY here is my long body\"),\n\t            [\"BODY\", \"here is my long body\"],\n\t        )\n\t        self.assertEqual(split_imap_search_command(\"\"), [])\n", "    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t        },\n\t    )\n\t    def test_imap_open(self, mock_imap):\n", "        # Test imapOpen function\n\t        imap_folder = \"inbox\"\n\t        imap_open(imap_folder, MOCK_FROM, MOCK_PWD)\n\t        # Check if the IMAP object was created and used correctly\n\t        mock_imap.assert_called_once_with(MOCK_IMAP_SERVER)\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(imap_folder)\n\t    # Test for successful email sending without attachment\n\t    @patch(\"smtplib.SMTP\", autospec=True)\n\t    @patch.dict(\n", "        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_SMTP_HOST\": MOCK_SMTP_SERVER,\n\t            \"EMAIL_SMTP_PORT\": MOCK_SMTP_PORT,\n\t        },\n\t    )\n\t    def test_send_email_no_attachment(self, mock_smtp):\n\t        result = send_email(MOCK_TO, MOCK_SUBJECT, MOCK_CONTENT)\n", "        assert result == f\"Email was sent to {MOCK_TO}!\"\n\t        mock_smtp.assert_called_once_with(MOCK_SMTP_SERVER, MOCK_SMTP_PORT)\n\t        # Check if the SMTP object was created and used correctly\n\t        context = mock_smtp.return_value.__enter__.return_value\n\t        context.ehlo.assert_called()\n\t        context.starttls.assert_called_once()\n\t        context.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        context.send_message.assert_called_once()\n\t        context.quit.assert_called_once()\n\t    # Test for reading emails in a specific folder with a specific search command and pagination\n", "    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t        },\n\t    )\n\t    def test_read_emails(self, mock_imap):\n", "        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\t        # Create a mock email message\n\t        message = EmailMessage()\n\t        message[\"From\"] = MOCK_FROM\n\t        message[\"To\"] = MOCK_TO\n\t        message[\"Date\"] = MOCK_DATE\n\t        message[\"Subject\"] = MOCK_SUBJECT\n\t        message.set_content(MOCK_CONTENT)\n\t        # Set up mock IMAP server behavior\n\t        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n", "        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\t        # Test read_emails function\n\t        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n\t        expected_result = [\n\t            {\n\t                \"From\": MOCK_FROM,\n\t                \"To\": MOCK_TO,\n\t                \"Date\": MOCK_DATE,\n\t                \"CC\": \"\",\n\t                \"Subject\": MOCK_SUBJECT,\n", "                \"Message Body\": MOCK_CONTENT,\n\t            }\n\t        ]\n\t        assert result == expected_result\n\t        # Check if the IMAP object was created and used correctly\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n\t        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n\t        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\t    # Test for reading empty emails\n", "    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t        },\n\t    )\n\t    def test_read_empty_emails(self, mock_imap):\n", "        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\t        # Set up mock IMAP server behavior\n\t        mock_imap.return_value.search.return_value = (None, [b\"0\"])\n\t        mock_imap.return_value.fetch.return_value = (None, [])\n\t        # Test read_emails function\n\t        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n\t        expected = \"There are no Emails in your folder `inbox` \"\n\t        expected += \"when searching with imap command `UNSEEN`\"\n\t        assert result == expected\n\t        # Check if the IMAP object was created and used correctly\n", "        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n\t        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n\t        mock_imap.return_value.fetch.assert_called_once_with(b\"0\", \"(BODY.PEEK[])\")\n\t    # Test for reading emails in a specific folder\n\t    # with a specific search command with EMAIL_MARK_AS_SEEN=True\n\t    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n", "            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t            \"EMAIL_MARK_AS_SEEN\": \"True\",\n\t        },\n\t    )\n\t    def test_read_emails_mark_as_read_true(self, mock_imap):\n\t        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\t        # Create a mock email message\n\t        message = EmailMessage()\n", "        message[\"From\"] = MOCK_FROM\n\t        message[\"To\"] = MOCK_TO\n\t        message[\"Date\"] = MOCK_DATE\n\t        message[\"Subject\"] = MOCK_SUBJECT\n\t        message.set_content(MOCK_CONTENT)\n\t        # Set up mock IMAP server behavior\n\t        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n\t        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\t        # Test read_emails function\n\t        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n", "        expected_result = [\n\t            {\n\t                \"From\": MOCK_FROM,\n\t                \"To\": MOCK_TO,\n\t                \"Date\": MOCK_DATE,\n\t                \"CC\": \"\",\n\t                \"Subject\": MOCK_SUBJECT,\n\t                \"Message Body\": MOCK_CONTENT,\n\t            }\n\t        ]\n", "        assert result == expected_result\n\t        # Check if the IMAP object was created and used correctly\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n\t        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n\t        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(RFC822)\")\n\t    # Test for reading emails in a specific folder\n\t    # with a specific search command with EMAIL_MARK_AS_SEEN=False\n\t    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n", "        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t            \"EMAIL_MARK_AS_SEEN\": \"False\",\n\t        },\n\t    )\n\t    def test_read_emails_mark_as_seen_false(self, mock_imap):\n\t        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n", "        # Create a mock email message\n\t        message = EmailMessage()\n\t        message[\"From\"] = MOCK_FROM\n\t        message[\"To\"] = MOCK_TO\n\t        message[\"Date\"] = MOCK_DATE\n\t        message[\"Subject\"] = MOCK_SUBJECT\n\t        message.set_content(MOCK_CONTENT)\n\t        # Set up mock IMAP server behavior\n\t        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n\t        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n", "        # Test read_emails function\n\t        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n\t        expected_result = [\n\t            {\n\t                \"From\": MOCK_FROM,\n\t                \"To\": MOCK_TO,\n\t                \"Date\": MOCK_DATE,\n\t                \"CC\": \"\",\n\t                \"Subject\": MOCK_SUBJECT,\n\t                \"Message Body\": MOCK_CONTENT,\n", "            }\n\t        ]\n\t        assert result == expected_result\n\t        # Check if the IMAP object was created and used correctly\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n\t        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n\t        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\t    def side_effect_for_open(original_open, file_path, *args, **kwargs):\n\t        if file_path == MOCK_ATTACHMENT_PATH:\n", "            return mock_open(read_data=b\"file_content\").return_value\n\t        return original_open(file_path, *args, **kwargs)\n\t    original_open = open\n\t    side_effect_with_original_open = partial(side_effect_for_open, original_open)\n\t    # Test for sending emails with EMAIL_DRAFT_MODE_WITH_FOLDER\n\t    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n", "            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t            \"EMAIL_DRAFT_MODE_WITH_FOLDER\": MOCK_DRAFT_FOLDER,\n\t        },\n\t    )\n\t    @patch(f\"{__name__}.imap_open\")\n\t    @patch(\"builtins.open\", side_effect=side_effect_with_original_open)\n\t    def test_send_emails_with_draft_mode(self, mock_file, mock_imap_open, mock_imap):\n\t        mock_imap_conn = mock_imap_open.return_value\n\t        mock_imap_conn.select.return_value = (\"OK\", [b\"0\"])\n", "        mock_imap_conn.append.return_value = (\"OK\", [b\"1\"])\n\t        result = send_email_with_attachment_internal(\n\t            MOCK_TO,\n\t            MOCK_SUBJECT,\n\t            MOCK_CONTENT,\n\t            MOCK_ATTACHMENT_PATH,\n\t            MOCK_ATTACHMENT_NAME,\n\t        )\n\t        assert result == f\"Email went to {MOCK_DRAFT_FOLDER}!\"\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n", "        mock_imap.return_value.select.assert_called_once_with(MOCK_DRAFT_FOLDER)\n\t        # Get the actual MIME message appended\n\t        mock_imap.return_value.append.assert_called_once()\n\t        append_args, _ = mock_imap.return_value.append.call_args\n\t        actual_mime_msg = append_args[3].decode(\"utf-8\")\n\t        # Check for the presence of relevant information in the MIME message\n\t        assert MOCK_FROM in actual_mime_msg\n\t        assert MOCK_TO in actual_mime_msg\n\t        assert MOCK_SUBJECT in actual_mime_msg\n\t        assert MOCK_CONTENT in actual_mime_msg\n", "        assert MOCK_ATTACHMENT_NAME in actual_mime_msg\n\t    # Test for reading an email where the subject has enconding issues or is null\n\t    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t        },\n", "    )\n\t    def test_read_emails_subject_unknown_encoding(self, mock_imap):\n\t        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\t        # Create a mock email message\n\t        message = EmailMessage()\n\t        message[\"From\"] = MOCK_FROM\n\t        message[\"To\"] = MOCK_TO\n\t        message[\"Date\"] = MOCK_DATE\n\t        message[\"Subject\"] = None\n\t        message.set_content(MOCK_CONTENT)\n", "        # Set up mock IMAP server behavior\n\t        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n\t        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\t        # Test read_emails function\n\t        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n\t        expected_result = [\n\t            {\n\t                \"From\": MOCK_FROM,\n\t                \"To\": MOCK_TO,\n\t                \"Date\": MOCK_DATE,\n", "                \"CC\": \"\",\n\t                \"Subject\": \"\",\n\t                \"Message Body\": MOCK_CONTENT,\n\t            }\n\t        ]\n\t        assert result == expected_result\n\t        # Check if the IMAP object was created and used correctly\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n\t        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n", "        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\t    # Test for reading an email where the body has enconding issues or is null\n\t    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t        },\n", "    )\n\t    def test_read_emails_body_unknown_encoding(self, mock_imap):\n\t        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\t        # Create a mock email message\n\t        message = EmailMessage()\n\t        message[\"From\"] = MOCK_FROM\n\t        message[\"To\"] = MOCK_TO\n\t        message[\"Date\"] = MOCK_DATE\n\t        message[\"Subject\"] = MOCK_SUBJECT\n\t        message.set_content(\"\\n\")\n", "        # Set up mock IMAP server behavior\n\t        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n\t        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\t        # Test read_emails function\n\t        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n\t        expected_result = [\n\t            {\n\t                \"From\": MOCK_FROM,\n\t                \"To\": MOCK_TO,\n\t                \"Date\": MOCK_DATE,\n", "                \"CC\": \"\",\n\t                \"Subject\": MOCK_SUBJECT,\n\t                \"Message Body\": \"\",\n\t            }\n\t        ]\n\t        assert result == expected_result\n\t        # Check if the IMAP object was created and used correctly\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n\t        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n", "        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\t    # Test for cleaning an email's bodies\n\t    @patch(\"imaplib.IMAP4_SSL\")\n\t    @patch.dict(\n\t        os.environ,\n\t        {\n\t            \"EMAIL_ADDRESS\": MOCK_FROM,\n\t            \"EMAIL_PASSWORD\": MOCK_PWD,\n\t            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n\t        },\n", "    )\n\t    def test_clean_email_body(self, mock_imap):\n\t        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\t        # Create a mock email message\n\t        message = EmailMessage()\n\t        message[\"From\"] = MOCK_FROM\n\t        message[\"To\"] = MOCK_TO\n\t        message[\"Date\"] = MOCK_DATE\n\t        message[\"Subject\"] = MOCK_SUBJECT\n\t        message.set_content(MOCK_CONTENT_DIRTY)\n", "        # Set up mock IMAP server behavior\n\t        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n\t        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\t        # Test read_emails with paginationfunction\n\t        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n\t        expected_result = [\n\t            {\n\t                \"From\": MOCK_FROM,\n\t                \"To\": MOCK_TO,\n\t                \"Date\": MOCK_DATE,\n", "                \"CC\": \"\",\n\t                \"Subject\": MOCK_SUBJECT,\n\t                \"Message Body\": \"Email Title This is an email template with a return character and a link at the end (\",\n\t            }\n\t        ]\n\t        assert result == expected_result\n\t        # Check if the IMAP object was created and used correctly\n\t        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n\t        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n\t        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n", "        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/email/email_plugin/email_plugin.py", "chunked_list": ["import email\n\timport imaplib\n\timport json\n\timport mimetypes\n\timport os\n\timport re\n\timport smtplib\n\timport time\n\tfrom email.header import decode_header\n\tfrom email.message import EmailMessage\n", "from bs4 import BeautifulSoup\n\tdef bothEmailAndPwdSet() -> bool:\n\t    return True if os.getenv(\"EMAIL_ADDRESS\") and os.getenv(\"EMAIL_PASSWORD\") else False\n\tdef getSender():\n\t    email_sender = os.getenv(\"EMAIL_ADDRESS\")\n\t    if not email_sender:\n\t        return \"Error: email not sent. EMAIL_ADDRESS not set in environment.\"\n\t    return email_sender\n\tdef getPwd():\n\t    email_password = os.getenv(\"EMAIL_PASSWORD\")\n", "    if not email_password:\n\t        return \"Error: email not sent. EMAIL_PASSWORD not set in environment.\"\n\t    return email_password\n\tdef send_email(to: str, subject: str, body: str) -> str:\n\t    return send_email_with_attachment_internal(to, subject, body, None, None)\n\tdef send_email_with_attachment(to: str, subject: str, body: str, filename: str) -> str:\n\t    attachment_path = filename\n\t    attachment = os.path.basename(filename)\n\t    return send_email_with_attachment_internal(\n\t        to, subject, body, attachment_path, attachment\n", "    )\n\tdef send_email_with_attachment_internal(\n\t    to: str, title: str, message: str, attachment_path: str, attachment: str\n\t) -> str:\n\t    \"\"\"Send an email\n\t    Args:\n\t        to (str): The email of the recipient\n\t        title (str): The title of the email\n\t        message (str): The message content of the email\n\t    Returns:\n", "        str: Any error messages\n\t    \"\"\"\n\t    email_sender = getSender()\n\t    email_password = getPwd()\n\t    msg = EmailMessage()\n\t    msg[\"Subject\"] = title\n\t    msg[\"From\"] = email_sender\n\t    msg[\"To\"] = to\n\t    signature = os.getenv(\"EMAIL_SIGNATURE\")\n\t    if signature:\n", "        message += f\"\\n{signature}\"\n\t    msg.set_content(message)\n\t    if attachment_path:\n\t        ctype, encoding = mimetypes.guess_type(attachment_path)\n\t        if ctype is None or encoding is not None:\n\t            # No guess could be made, or the file is encoded (compressed)\n\t            ctype = \"application/octet-stream\"\n\t        maintype, subtype = ctype.split(\"/\", 1)\n\t        with open(attachment_path, \"rb\") as fp:\n\t            msg.add_attachment(\n", "                fp.read(), maintype=maintype, subtype=subtype, filename=attachment\n\t            )\n\t    draft_folder = os.getenv(\"EMAIL_DRAFT_MODE_WITH_FOLDER\")\n\t    if not draft_folder:\n\t        smtp_host = os.getenv(\"EMAIL_SMTP_HOST\")\n\t        smtp_port = os.getenv(\"EMAIL_SMTP_PORT\")\n\t        # send email\n\t        with smtplib.SMTP(smtp_host, smtp_port) as smtp:\n\t            smtp.ehlo()\n\t            smtp.starttls()\n", "            smtp.login(email_sender, email_password)\n\t            smtp.send_message(msg)\n\t            smtp.quit()\n\t        return f\"Email was sent to {to}!\"\n\t    else:\n\t        conn = imap_open(draft_folder, email_sender, email_password)\n\t        conn.append(\n\t            draft_folder,\n\t            \"\",\n\t            imaplib.Time2Internaldate(time.time()),\n", "            str(msg).encode(\"UTF-8\"),\n\t        )\n\t        return f\"Email went to {draft_folder}!\"\n\tdef read_emails(\n\t        imap_folder: str = \"inbox\", imap_search_command: str = \"UNSEEN\", limit: int = 5,\n\t        page: int = 1) -> str:\n\t    \"\"\"Read emails from an IMAP mailbox.\n\t    This function reads emails from a specified IMAP folder, using a given IMAP search command, limits, and page numbers.\n\t    It returns a list of emails with their details, including the sender, recipient, date, CC, subject, and message body.\n\t    Args:\n", "        imap_folder (str, optional): The name of the IMAP folder to read emails from. Defaults to \"inbox\".\n\t        imap_search_command (str, optional): The IMAP search command to filter emails. Defaults to \"UNSEEN\".\n\t        limit (int, optional): Number of email's the function should return. Defaults to 5 emails.\n\t        page (int, optional): The index of the page result the function should resturn. Defaults to 0, the first page.\n\t    Returns:\n\t        str: A list of dictionaries containing email details if there are any matching emails. Otherwise, returns\n\t             a string indicating that no matching emails were found.\n\t    \"\"\"\n\t    email_sender = getSender()\n\t    imap_folder = adjust_imap_folder_for_gmail(imap_folder, email_sender)\n", "    imap_folder = enclose_with_quotes(imap_folder)\n\t    imap_search_ar = split_imap_search_command(imap_search_command)\n\t    email_password = getPwd()\n\t    mark_as_seen = os.getenv(\"EMAIL_MARK_AS_SEEN\")\n\t    if isinstance(mark_as_seen, str):\n\t        mark_as_seen = json.loads(mark_as_seen.lower())\n\t    conn = imap_open(imap_folder, email_sender, email_password)\n\t    imap_keyword = imap_search_ar[0]\n\t    if len(imap_search_ar) == 1:\n\t        _, search_data = conn.search(None, imap_keyword)\n", "    else:\n\t        argument = enclose_with_quotes(imap_search_ar[1])\n\t        _, search_data = conn.search(None, imap_keyword, argument)\n\t    messages = []\n\t    for num in search_data[0].split():\n\t        if mark_as_seen:\n\t            message_parts = \"(RFC822)\"\n\t        else:\n\t            message_parts = \"(BODY.PEEK[])\"\n\t        _, msg_data = conn.fetch(num, message_parts)\n", "        for response_part in msg_data:\n\t            if isinstance(response_part, tuple):\n\t                msg = email.message_from_bytes(response_part[1])\n\t                # If the subject has unknown encoding, return blank\n\t                if msg[\"Subject\"] is not None:\n\t                    subject, encoding = decode_header(msg[\"Subject\"])[0]\n\t                else:\n\t                    subject = \"\"\n\t                    encoding = \"\"\n\t                if isinstance(subject, bytes):\n", "                    try:\n\t                        # If the subject has unknown encoding, return blank\n\t                        if encoding is not None:\n\t                            subject = subject.decode(encoding)\n\t                        else:\n\t                            subject = \"\"\n\t                    except [LookupError] as e:\n\t                        pass\n\t                body = get_email_body(msg)\n\t                # Clean email body\n", "                body = clean_email_body(body)\n\t                from_address = msg[\"From\"]\n\t                to_address = msg[\"To\"]\n\t                date = msg[\"Date\"]\n\t                cc = msg[\"CC\"] if msg[\"CC\"] else \"\"\n\t                messages.append(\n\t                    {\n\t                        \"From\": from_address,\n\t                        \"To\": to_address,\n\t                        \"Date\": date,\n", "                        \"CC\": cc,\n\t                        \"Subject\": subject,\n\t                        \"Message Body\": body,\n\t                    }\n\t                )\n\t    conn.logout()\n\t    if not messages:\n\t        return (\n\t            f\"There are no Emails in your folder `{imap_folder}` \"\n\t            f\"when searching with imap command `{imap_search_command}`\"\n", "        )\n\t    # Confirm that integer parameters are the right type\n\t    limit = int(limit)\n\t    page = int(page)\n\t    # Validate parameter values\n\t    if limit < 1:\n\t        raise ValueError(\"Error: The message limit should be 1 or greater\")\n\t    page_count = len(messages) // limit + (len(messages) % limit > 0)\n\t    if page < 1 or page > page_count:\n\t        raise ValueError(\"Error: The page value references a page that is not part of the results\")\n", "    # Calculate paginated indexes\n\t    start_index = len(messages) - (page * limit + 1)\n\t    end_index = start_index + limit\n\t    start_index = max(start_index, 0)\n\t    # Return paginated indexes\n\t    if start_index == end_index:\n\t        return [messages[start_index]]\n\t    else:\n\t        return messages[start_index:end_index]\n\tdef adjust_imap_folder_for_gmail(imap_folder: str, email_sender: str) -> str:\n", "    if \"@gmail\" in email_sender.lower() or \"@googlemail\" in email_sender.lower():\n\t        if \"sent\" in imap_folder.lower():\n\t            return '\"[Gmail]/Sent Mail\"'\n\t        if \"draft\" in imap_folder.lower():\n\t            return \"[Gmail]/Drafts\"\n\t    return imap_folder\n\tdef imap_open(\n\t    imap_folder: str, email_sender: str, email_password: str\n\t) -> imaplib.IMAP4_SSL:\n\t    imap_server = os.getenv(\"EMAIL_IMAP_SERVER\")\n", "    conn = imaplib.IMAP4_SSL(imap_server)\n\t    conn.login(email_sender, email_password)\n\t    conn.select(imap_folder)\n\t    return conn\n\tdef get_email_body(msg: email.message.Message) -> str:\n\t    if msg.is_multipart():\n\t        for part in msg.walk():\n\t            content_type = part.get_content_type()\n\t            content_disposition = str(part.get(\"Content-Disposition\"))\n\t            if content_type == \"text/plain\" and \"attachment\" not in content_disposition:\n", "                # If the email body has unknown encoding, return null\n\t                try:\n\t                    return part.get_payload(decode=True).decode()\n\t                except UnicodeDecodeError as e:\n\t                    pass\n\t    else:\n\t        try:\n\t            # If the email body has unknown encoding, return null\n\t            return msg.get_payload(decode=True).decode()\n\t        except UnicodeDecodeError as e:\n", "            pass\n\tdef enclose_with_quotes(s):\n\t    # Check if string contains whitespace\n\t    has_whitespace = bool(re.search(r\"\\s\", s))\n\t    # Check if string is already enclosed by quotes\n\t    is_enclosed = s.startswith((\"'\", '\"')) and s.endswith((\"'\", '\"'))\n\t    # If string has whitespace and is not enclosed by quotes, enclose it with double quotes\n\t    if has_whitespace and not is_enclosed:\n\t        return f'\"{s}\"'\n\t    else:\n", "        return s\n\tdef split_imap_search_command(input_string):\n\t    input_string = input_string.strip()\n\t    parts = input_string.split(maxsplit=1)\n\t    parts = [part.strip() for part in parts]\n\t    return parts\n\tdef clean_email_body(email_body):\n\t    \"\"\"Remove formating and URL's from an email's body\n\t    Args:\n\t        email_body (str, optional): The email's body\n", "    Returns:\n\t        str: The email's body without any formating or URL's\n\t    \"\"\"\n\t    # If body is None, return an empty string\n\t    if email_body is None: email_body = \"\"\n\t    # Remove any HTML tags\n\t    email_body = BeautifulSoup(email_body, \"html.parser\")\n\t    email_body = email_body.get_text()\n\t    # Remove return characters\n\t    email_body = \"\".join(email_body.splitlines())\n", "    # Remove extra spaces\n\t    email_body = \" \".join(email_body.split())\n\t    # Remove unicode characters\n\t    email_body = email_body.encode(\"ascii\", \"ignore\")\n\t    email_body = email_body.decode(\"utf-8\", \"ignore\")\n\t    # Remove any remaining URL's\n\t    email_body = re.sub(r\"http\\S+\", \"\", email_body)\n\t    return email_body\n"]}
{"filename": "src/autogpt_plugins/news_search/__init__.py", "chunked_list": ["\"\"\"This is the News search engine plugin for Auto-GPT.\"\"\"\n\timport os\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\tfrom .news_search import NewsSearch\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n\t    content: str\n\tclass AutoGPTNewsSearch(AutoGPTPluginTemplate):\n", "    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"News-Search-Plugin\"\n\t        self._version = \"0.1.0\"\n\t        self._description = \"This plugin searches the latest news using the provided query and the newsapi aggregator\"\n\t        self.load_commands = os.getenv(\n\t            \"NEWSAPI_API_KEY\"\n\t        )  # Wrapper, if more variables are needed in future\n\t        self.news_search = NewsSearch(os.getenv(\"NEWSAPI_API_KEY\"))\n\t    def can_handle_post_prompt(self) -> bool:\n", "        return True\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        if self.load_commands:\n\t            # Add News Search command\n\t            prompt.add_command(\n\t                \"News Search\",\n\t                \"news_search\",\n\t                {\"query\": \"<query>\"},\n\t                self.news_search.news_everything_search,\n\t            )\n", "        else:\n\t            print(\n\t                \"Warning: News-Search-Plugin is not fully functional. \"\n\t                \"Please set the NEWSAPI_API_KEY environment variable.\"\n\t            )\n\t        return prompt\n\t    def can_handle_pre_command(self) -> bool:\n\t        return False\n\t    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n", "    ) -> Tuple[str, Dict[str, Any]]:\n\t        pass\n\t    def can_handle_post_command(self) -> bool:\n\t        return False\n\t    def post_command(self, command_name: str, response: str) -> str:\n\t        pass\n\t    def can_handle_on_planning(self) -> bool:\n\t        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[Message]\n", "    ) -> Optional[str]:\n\t        pass\n\t    def can_handle_on_response(self) -> bool:\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        pass\n", "    def can_handle_pre_instruction(self) -> bool:\n\t        return False\n\t    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n\t        pass\n\t    def can_handle_on_instruction(self) -> bool:\n\t        return False\n\t    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        return False\n", "    def post_instruction(self, response: str) -> str:\n\t        pass\n\t    def can_handle_pre_command(self) -> bool:\n\t        return False\n\t    def can_handle_chat_completion(\n\t        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n\t    ) -> bool:\n\t        return False\n\t    def handle_chat_completion(\n\t        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n", "    ) -> str:\n\t        pass\n\t    def can_handle_text_embedding(\n\t        self, text: str\n\t    ) -> bool:\n\t        return False\n\t    def handle_text_embedding(\n\t        self, text: str\n\t    ) -> list:\n\t        pass\n", "    def can_handle_user_input(self, user_input: str) -> bool:\n\t        return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n\t    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass"]}
{"filename": "src/autogpt_plugins/news_search/news_search.py", "chunked_list": ["import concurrent.futures\n\tfrom typing import List\n\tfrom newsapi import NewsApiClient\n\tcategories = [\"technology\", \"business\", \"entertainment\", \"health\", \"sports\", \"science\"]\n\tclass NewsSearch(object):\n\t    def __init__(self, api_key):\n\t        self.news_api_client = NewsApiClient(api_key)\n\t    def news_headlines_search(self, category: str, query: str) -> List[str]:\n\t        \"\"\"\n\t        Get top news headlines for category specified.\n", "        Args:\n\t            category (str) : The category specified. Must be one of technology, business, entertainment, health, sports or science.\n\t        Returns:\n\t            list(str): A list of top news headlines for the specified category.\n\t        \"\"\"\n\t        result = self.news_api_client.get_top_headlines(\n\t            category=category, language=\"en\", country=\"us\", page=1, q=query\n\t        )\n\t        return [article[\"title\"] for article in result[\"articles\"][:3]]\n\t    def news_everything_search(self, query: str) -> List[str]:\n", "        \"\"\"\n\t        Get all news for query specified.\n\t        Args:\n\t            query (str) : The query specified.\n\t        Returns:\n\t            list(str): A list of news for the specified category, sorted by relevant.\n\t        \"\"\"\n\t        result = self.news_api_client.get_everything(\n\t            language=\"en\", page=1, q=query, sort_by=\"relevancy\"\n\t        )\n", "        return [article[\"title\"] for article in result[\"articles\"]]\n\t    def news_headlines_search_wrapper(self, query: str) -> List[str]:\n\t        \"\"\"\n\t        Aggregates top news headlines from the categories.\n\t        Returns:\n\t            list(str): A list of top news headlines aggregated from all categories.\n\t        \"\"\"\n\t        with concurrent.futures.ThreadPoolExecutor() as tp:\n\t            futures = []\n\t            for cat in categories:\n", "                futures.append(\n\t                    tp.submit(self.news_headlines_search, category=cat, query=query)\n\t                )\n\t            aggregated_headlines = []\n\t            for fut in concurrent.futures.wait(futures)[0]:\n\t                aggregated_headlines.append(fut.result())\n\t            return aggregated_headlines\n"]}
{"filename": "src/autogpt_plugins/news_search/test_auto_gpt_news_search.py", "chunked_list": ["import json\n\tfrom unittest.mock import Mock\n\timport pytest\n\tfrom .news_search import NewsSearch\n\tclass TestNewsSearch:\n\t    def mock_response(self, *args, **kwargs):\n\t        # Mock Response of NewsAPI. We have result for AutoGPT in technology but not others,\n\t        # whereas Cricket is present in Sports/Entertainment but not others\n\t        if kwargs[\"q\"] == \"AI\" and kwargs[\"category\"] == \"technology\":\n\t            return json.loads(\n", "                \"\"\"{\"status\":\"ok\",\"totalResults\":1,\"articles\": [{\"title\": \"AutoGPT\"}]}\"\"\"\n\t            )\n\t        elif kwargs[\"q\"] == \"Cricket\" and kwargs[\"category\"] in [\n\t            \"entertainment\",\n\t            \"sports\",\n\t        ]:\n\t            return json.loads(\n\t                \"\"\"{\"status\":\"ok\",\"totalResults\":1,\"articles\": [{\"title\": \"World Cup\"}]}\"\"\"\n\t            )\n\t        elif kwargs[\"q\"] == \"Taylor Swift\":\n", "            return json.loads(\n\t                \"\"\"{\"status\": \"ok\",\"totalResults\": 1,\"articles\": [{\"title\": \"The National enlist Taylor Swift for new song The Alcott\"}]}\"\"\"\n\t            )\n\t        else:\n\t            return json.loads(\"\"\"{\"status\":\"ok\",\"totalResults\":0,\"articles\":[]}\"\"\")\n\t    @pytest.fixture(autouse=True)\n\t    def setUp(self):\n\t        self.NewsSearch = NewsSearch(\"testKey\")\n\t        self.NewsSearch.news_api_client.get_top_headlines = Mock(\n\t            side_effect=self.mock_response\n", "        )\n\t        self.NewsSearch.news_api_client.get_everything = Mock(\n\t            side_effect=self.mock_response\n\t        )\n\t    def test_news_search(self):\n\t        # For AI, only technology should be populated. However, we can't rely on ordering,\n\t        # so we'll assert one actual answer and 5 empty answers\n\t        actual_output_autogpt = self.NewsSearch.news_headlines_search_wrapper(\"AI\")\n\t        assert actual_output_autogpt.count([\"AutoGPT\"]) == 1\n\t        assert actual_output_autogpt.count([]) == 5\n", "        # For Cricket, we should have sports/entertainment\n\t        actual_output_cricket = self.NewsSearch.news_headlines_search_wrapper(\"Cricket\")\n\t        assert actual_output_cricket.count([\"World Cup\"]) == 2\n\t        assert actual_output_cricket.count([]) == 4\n\t        actual_output_taylor = self.NewsSearch.news_everything_search(\"Taylor Swift\")\n\t        assert actual_output_taylor.count([\"Taylor Swift\"]) == 0\n\t        assert actual_output_taylor.count([]) == 0\n"]}
{"filename": "src/autogpt_plugins/random_values/__init__.py", "chunked_list": ["\"\"\"Random Values commands.\"\"\"\n\tfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\tfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\ttry:\n\t    from .random_values import RandomValues\n\texcept ImportError:\n\t    from random_values import RandomValues\n\tPromptGenerator = TypeVar(\"PromptGenerator\")\n\tclass Message(TypedDict):\n\t    role: str\n", "    content: str\n\tclass AutoGPTRandomValues(AutoGPTPluginTemplate):\n\t    \"\"\"\n\t    Random Values plugin for Auto-GPT.\n\t    \"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._name = \"AutoGPTRandomValues\"\n\t        self._version = \"0.1.2\"\n\t        self._description = \"Enable Auto-GPT with the power of random values.\"\n", "        self.plugin_class = RandomValues(self)\n\t    def can_handle_on_response(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_response method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_response method.\"\"\"\n\t        return False\n\t    def on_response(self, response: str, *args, **kwargs) -> str:\n\t        \"\"\"This method is called when a response is received from the model.\"\"\"\n\t        return response\n", "    def can_handle_post_prompt(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_prompt method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_prompt method.\"\"\"\n\t        return True\n\t    def can_handle_on_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the on_planning method.\n\t        Returns:\n", "            bool: True if the plugin can handle the on_planning method.\"\"\"\n\t        return False\n\t    def on_planning(\n\t        self, prompt: PromptGenerator, messages: List[str]\n\t    ) -> Optional[str]:\n\t        \"\"\"This method is called before the planning chat completeion is done.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t            messages (List[str]): The list of messages.\n\t        \"\"\"\n", "        pass\n\t    def can_handle_post_planning(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_planning method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_planning method.\"\"\"\n\t        return False\n\t    def post_planning(self, response: str) -> str:\n\t        \"\"\"This method is called after the planning chat completeion is done.\n\t        Args:\n", "            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return response\n\t    def can_handle_pre_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n", "        return False\n\t    def pre_instruction(self, messages: List[str]) -> List[str]:\n\t        \"\"\"This method is called before the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n\t            List[str]: The resulting list of messages.\n\t        \"\"\"\n\t        return messages\n\t    def can_handle_on_instruction(self) -> bool:\n", "        \"\"\"This method is called to check that the plugin can\n\t        handle the on_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the on_instruction method.\"\"\"\n\t        return False\n\t    def on_instruction(self, messages: List[str]) -> Optional[str]:\n\t        \"\"\"This method is called when the instruction chat is done.\n\t        Args:\n\t            messages (List[str]): The list of context messages.\n\t        Returns:\n", "            Optional[str]: The resulting message.\n\t        \"\"\"\n\t        pass\n\t    def can_handle_post_instruction(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_instruction method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_instruction method.\"\"\"\n\t        return False\n\t    def post_instruction(self, response: str) -> str:\n", "        \"\"\"This method is called after the instruction chat is done.\n\t        Args:\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return response\n\t    def can_handle_pre_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the pre_command method.\n", "        Returns:\n\t            bool: True if the plugin can handle the pre_command method.\"\"\"\n\t        return False\n\t    def pre_command(\n\t        self, command_name: str, arguments: Dict[str, Any]\n\t    ) -> Tuple[str, Dict[str, Any]]:\n\t        \"\"\"This method is called before the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            arguments (Dict[str, Any]): The arguments.\n", "        Returns:\n\t            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n\t        \"\"\"\n\t        return command_name, arguments\n\t    def can_handle_post_command(self) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the post_command method.\n\t        Returns:\n\t            bool: True if the plugin can handle the post_command method.\"\"\"\n\t        return False\n", "    def post_command(self, command_name: str, response: str) -> str:\n\t        \"\"\"This method is called after the command is executed.\n\t        Args:\n\t            command_name (str): The command name.\n\t            response (str): The response.\n\t        Returns:\n\t            str: The resulting response.\n\t        \"\"\"\n\t        return response\n\t    def can_handle_chat_completion(\n", "        self,\n\t        messages: list[Dict[Any, Any]],\n\t        model: str,\n\t        temperature: float,\n\t        max_tokens: int,\n\t    ) -> bool:\n\t        \"\"\"This method is called to check that the plugin can\n\t        handle the chat_completion method.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n", "            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n\t            bool: True if the plugin can handle the chat_completion method.\"\"\"\n\t        return False\n\t    def handle_chat_completion(\n\t        self,\n\t        messages: list[Dict[Any, Any]],\n\t        model: str,\n", "        temperature: float,\n\t        max_tokens: int,\n\t    ) -> str:\n\t        \"\"\"This method is called when the chat completion is done.\n\t        Args:\n\t            messages (Dict[Any, Any]): The messages.\n\t            model (str): The model name.\n\t            temperature (float): The temperature.\n\t            max_tokens (int): The max tokens.\n\t        Returns:\n", "            str: The resulting response.\n\t        \"\"\"\n\t        return ''\n\t    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n\t        \"\"\"This method is called just after the generate_prompt is called,\n\t            but actually before the prompt is generated.\n\t        Args:\n\t            prompt (PromptGenerator): The prompt generator.\n\t        Returns:\n\t            PromptGenerator: The prompt generator.\n", "        \"\"\"\n\t        prompt.add_command(  # type: ignore\n\t            \"rnd_num\",\n\t            \"Random Numbers\",\n\t            {\"min\": \"<int>\", \"max\": \"<int>\", \"cnt\": \"<int>\"},\n\t            self.plugin_class.random_number,\n\t        )\n\t        prompt.add_command(  # type: ignore\n\t            \"uuids\", \n\t            \"Make UUIDs\", \n", "            {\"cnt\": \"<int>\"}, \n\t            self.plugin_class.make_uuids\n\t        )\n\t        prompt.add_command(  # type: ignore\n\t            \"make_str\",\n\t            \"Generate Strings\",\n\t            {\"len\": \"<int>\", \"cnt\": \"<int>\"},\n\t            self.plugin_class.generate_string,\n\t        )\n\t        prompt.add_command( # type: ignore\n", "            \"pwds\",\n\t            \"Create Passwords\",\n\t            {\"len\": \"<int>\", \"cnt\": \"<int>\"},\n\t            self.plugin_class.generate_password,\n\t        )\n\t        prompt.add_command( # type: ignore\n\t            \"lorem_ipsum\",\n\t            \"Create Lorem Sentences\",\n\t            {\"cnt\": \"<int>\"},\n\t            self.plugin_class.generate_placeholder_text,\n", "        )\n\t        return prompt\n\t    def can_handle_text_embedding(self, text: str) -> bool:  # type: ignore\n\t        return False\n\t    def handle_text_embedding(self, text: str) -> list:  # type: ignore\n\t        pass\n\t    def can_handle_user_input(self, user_input: str) -> bool:\n\t            return False\n\t    def user_input(self, user_input: str) -> str:\n\t        return user_input\n", "    def can_handle_report(self) -> bool:\n\t        return False\n\t    def report(self, message: str) -> None:\n\t        pass\n"]}
{"filename": "src/autogpt_plugins/random_values/test_random_valaues.py", "chunked_list": ["import json\n\timport string\n\tfrom unittest.mock import Mock\n\tfrom unittest import TestCase\n\ttry:\n\t    from .random_values import RandomValues\n\texcept ImportError:\n\t    from random_values import RandomValues\n\tclass TestRandomValueCommands(TestCase):\n\t    # _random_number Tests\n", "    def setUp(self):\n\t        self.random_values = RandomValues(Mock())\n\t    def test_random_number(self):\n\t        result = json.loads(self.random_values.random_number(min=10, max=20, cnt=5))\n\t        self.assertEqual(len(result), 5)\n\t        for num in result:\n\t            self.assertTrue(10 <= num <= 20)\n\t    def test_random_number_using_strings(self):\n\t        result = json.loads(self.random_values.random_number(min=\"10\", max=\"20\", cnt=\"5\"))\n\t        self.assertEqual(len(result), 5)\n", "        for num in result:\n\t            self.assertTrue(10 <= num <= 20)\n\t    def test_random_number_using_missing_min(self):\n\t        result = json.loads(self.random_values.random_number(max=20, cnt=5))\n\t        self.assertEqual(len(result), 5)\n\t        for num in result:\n\t            self.assertTrue(0 <= num <= 20)\n\t    def test_random_number_using_missing_max(self):\n\t        result = json.loads(self.random_values.random_number(min=10, cnt=5))\n\t        self.assertEqual(len(result), 5)\n", "        for num in result:\n\t            self.assertTrue(10 <= num <= 65535)\n\t    def test_random_number_using_missing_count(self):\n\t        result = json.loads(self.random_values.random_number(min=10, max=20))\n\t        self.assertEqual(len(result), 1)\n\t        for num in result:\n\t            self.assertTrue(10 <= num <= 20)\n\t    def test_random_number_min_using_garbage(self):\n\t        with self.assertRaises(ValueError) as e:\n\t            self.random_values.random_number(min=\"foo\", max=\"20\", cnt=\"5\")\n", "        self.assertEqual(str(e.exception), \"min must be an integer\")\n\t    def test_random_number_max_using_garbage(self):\n\t        with self.assertRaises(ValueError) as e:\n\t            self.random_values.random_number(min=\"10\", max=\"bar\", cnt=\"5\")\n\t        self.assertEqual(str(e.exception), \"max must be an integer\")\n\t    def test_random_number_count_using_garbage(self):\n\t        with self.assertRaises(ValueError) as e:\n\t            self.random_values.random_number(min=\"10\", max=\"20\", cnt=\"baz\")\n\t        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\t    def test_make_uuids(self):\n", "        result = json.loads(self.random_values.make_uuids(cnt=5))\n\t        self.assertEqual(len(result), 5)\n\t        for uid in result:\n\t            self.assertIsInstance(uid, str)\n\t            self.assertEqual(len(uid), 36)  # UUIDs have 36 characters\n\t    def test_make_uuids_using_strings(self):\n\t        result = json.loads(self.random_values.make_uuids(cnt=\"5\"))\n\t        self.assertEqual(len(result), 5)\n\t        for uid in result:\n\t            self.assertIsInstance(uid, str)\n", "            self.assertEqual(len(uid), 36)\n\t    def test_make_uuids_using_missing_count(self):\n\t        # If missing, count defaults to 1\n\t        result = json.loads(self.random_values.make_uuids())\n\t        self.assertEqual(len(result), 1)\n\t        for uid in result:\n\t            self.assertIsInstance(uid, str)\n\t            self.assertEqual(len(uid), 36)\n\t    def test_make_uuids_using_garbage(self):\n\t        with self.assertRaises(ValueError) as e:\n", "            self.random_values.make_uuids(cnt=\"foo\")\n\t        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\t    # _generate_string Tests\n\t    def test_generate_string(self):\n\t        result = json.loads(self.random_values.generate_string(len=10, cnt=5))\n\t        self.assertEqual(len(result), 5)\n\t        for string in result:\n\t            self.assertEqual(len(string), 10)\n\t            # Strings should only contain letters and numbers\n\t            self.assertTrue(string.isalnum())\n", "    def test_generate_string_using_strings(self):\n\t        result = json.loads(self.random_values.generate_string(len=\"10\", cnt=\"5\"))\n\t        self.assertEqual(len(result), 5)\n\t        for string in result:\n\t            self.assertEqual(len(string), 10)\n\t            # Strings should only contain letters and numbers\n\t            self.assertTrue(string.isalnum())\n\t    def test_generate_string_using_missing_length(self):\n\t        # If missing, length defaults to 10\n\t        result = json.loads(self.random_values.generate_string(cnt=5))\n", "        self.assertEqual(len(result), 5)\n\t        for string in result:\n\t            self.assertEqual(len(string), 10)\n\t            # Strings should only contain letters and numbers\n\t            self.assertTrue(string.isalnum())\n\t    def test_generate_string_using_missing_count(self):\n\t        # If missing, count defaults to 1\n\t        result = json.loads(self.random_values.generate_string(len=10))\n\t        self.assertEqual(len(result), 1)\n\t        for string in result:\n", "            self.assertEqual(len(string), 10)\n\t            # Strings should only contain letters and numbers\n\t            self.assertTrue(string.isalnum())\n\t    def test_generate_string_using_garbage(self):\n\t        with self.assertRaises(ValueError) as e:\n\t            self.random_values.generate_string(len=\"foo\", cnt=\"bar\")\n\t        self.assertEqual(str(e.exception), \"len must be an integer\")\n\t    # _generate_password Tests\n\t    def test_generate_password(self):\n\t        result = json.loads(self.random_values.generate_password(len=10, cnt=5))\n", "        self.assertEqual(len(result), 5)\n\t        for password in result:\n\t            self.assertEqual(len(password), 10)\n\t            # Passwords should contain letters, numbers, and symbols\n\t            self.assertTrue(self.is_password(password))\n\t    def test_generate_password_using_strings(self):\n\t        result = json.loads(self.random_values.generate_password(len=\"10\", cnt=\"5\"))\n\t        self.assertEqual(len(result), 5)\n\t        for password in result:\n\t            self.assertEqual(len(password), 10)\n", "            # Passwords should contain letters, numbers, and symbols\n\t            self.assertTrue(self.is_password(password))\n\t    def test_generate_password_using_missing_length(self):\n\t        # If missing, length defaults to 10\n\t        result = json.loads(self.random_values.generate_password(cnt=5))\n\t        self.assertEqual(len(result), 5)\n\t        for password in result:\n\t            self.assertEqual(len(password), 16)\n\t            # Passwords should contain letters, numbers, and symbols\n\t            self.assertTrue(self.is_password(password))\n", "    def test_generate_password_using_missing_count(self):\n\t        # If missing, count defaults to 1\n\t        result = json.loads(self.random_values.generate_password(len=10))\n\t        self.assertEqual(len(result), 1)\n\t        for password in result:\n\t            self.assertEqual(len(password), 10)\n\t            # Passwords should contain letters, numbers, and symbols\n\t            self.assertTrue(self.is_password(password))\n\t    def test_generate_password_using_garbage(self):\n\t        with self.assertRaises(ValueError) as e:\n", "            self.random_values.generate_password(len=\"foo\", cnt=\"bar\")\n\t        self.assertEqual(str(e.exception), \"len must be an integer\")\n\t    # _generate_placeholder_text Tests\n\t    def test_generate_placeholder_text(self):\n\t        result = json.loads(self.random_values.generate_placeholder_text(cnt=5))\n\t        self.assertEqual(len(result), 5)\n\t        for text in result:\n\t            self.assertGreater(len(text), 3)\n\t    def test_generate_placeholder_text_using_strings(self):\n\t        result = json.loads(self.random_values.generate_placeholder_text(cnt=\"5\"))\n", "        self.assertEqual(len(result), 5)\n\t        for text in result:\n\t            self.assertGreater(len(text), 3)\n\t    def test_generate_placeholder_text_using_empty_string(self):\n\t        with self.assertRaises(ValueError) as e:\n\t            self.random_values.generate_placeholder_text(cnt=\"\")\n\t        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\t    def test_generate_placeholder_text_using_garbage(self):\n\t        with self.assertRaises(ValueError) as e:\n\t            self.random_values.generate_placeholder_text(cnt=\"foo\")\n", "        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\t    # checks that the given string only contains ascii letters, digits & punctuation\n\t    def is_password(self, input_str):\n\t        characters = string.ascii_letters + string.digits + string.punctuation\n\t        for character in input_str:\n\t            if character not in characters:\n\t                return False\n\t        return True\n"]}
{"filename": "src/autogpt_plugins/random_values/random_values.py", "chunked_list": ["\"\"\"Random Values classes for Autogpt.\"\"\"\n\timport json\n\timport random\n\timport string\n\timport uuid\n\timport lorem\n\t\"\"\"Random Number function for Autogpt.\"\"\"\n\tclass RandomValues:\n\t    \"\"\"Random Values plugin for Auto-GPT.\"\"\"\n\t    def __init__(self, plugin):\n", "        self.plugin = plugin\n\t    def random_number(self, min:int|str = 0, max:int|str = 65535, cnt:int|str = 1) -> str:\n\t        \"\"\"\n\t        Return a random integer between min and max\n\t        Args:\n\t            min (int): The minimum value\n\t            max (int): The maximum value\n\t            cnt (int): The number of random numbers to return\n\t        Returns:\n\t            str: a json array with 1 to \"count\" random numbers in the format\n", "            [\"<random_number>\"]\n\t        \"\"\"\n\t        # Type-check the arguments\n\t        try:\n\t            min = int(min)\n\t        except ValueError:\n\t            raise ValueError(\"min must be an integer\")\n\t        try:\n\t            max = int(max)\n\t        except ValueError:\n", "            raise ValueError(\"max must be an integer\")\n\t        try:\n\t            cnt = int(cnt)\n\t        except ValueError:\n\t            raise ValueError(\"cnt must be an integer\")\n\t        # Ensure min is less than max\n\t        if min > max:\n\t            min, max = max, min\n\t        # Test ranges\n\t        if not (1 <= cnt <= 65535):\n", "            raise ValueError(\"cnt must be between 1 and 65535\")\n\t        if not (0 <= min <= 65535):\n\t            raise ValueError(\"min must be between 0 and 65535\")\n\t        if not (0 <= max <= 65535):\n\t            raise ValueError(\"max must be between 0 and 65535\")\n\t        # Make random numbers\n\t        random_numbers = []\n\t        if isinstance(min, int) and isinstance(max, int):\n\t            for _ in range(cnt):\n\t                random_numbers.append(random.randint(min, max))\n", "        else:\n\t            for _ in range(cnt):\n\t                random_numbers.append(random.uniform(min, max))\n\t        return json.dumps(random_numbers)\n\t    # End of random_number()\n\t    def make_uuids(self, cnt:int|str = 1) -> str:\n\t        \"\"\"\n\t        Return a UUID\n\t        Args:\n\t            cnt (int): The number of UUIDs to return\n", "        Returns:\n\t            str: a json array with 1 to \"count\" UUIDs\n\t            [\"<UUID>\"]\n\t        \"\"\"\n\t        # Type-check the arguments\n\t        if not isinstance(cnt, int):\n\t            try:\n\t                cnt = int(cnt)\n\t            except ValueError:\n\t                raise ValueError(\"cnt must be an integer\")\n", "        # Make values sane\n\t        if not (1 <= cnt <= 65535):\n\t            raise ValueError(\"cnt must be between 1 and 65535\")\n\t        # Do the thing\n\t        uuids = []\n\t        for _ in range(cnt):\n\t            uuids.append(str(uuid.uuid4()))\n\t        return json.dumps(uuids)\n\t    # End of make_uuids()\n\t    def generate_string(self, len:int|str = 10, cnt:int|str = 1) -> str:\n", "        \"\"\"\n\t        Return a random string\n\t        Args:\n\t            len (int): The length of the string\n\t            cnt (int): The number of strings to return\n\t        Returns:\n\t            str: a json array with 1 to \"count\" strings of \"length\" length\n\t            [\"<string>\"]\n\t        \"\"\"\n\t        # Type-check the arguments\n", "        if not isinstance(len, int):\n\t            try:\n\t                len = int(len)\n\t            except ValueError:\n\t                raise ValueError(\"len must be an integer\")\n\t        if not isinstance(cnt, int):\n\t            try:\n\t                cnt = int(cnt)\n\t            except ValueError:\n\t                raise ValueError(\"cnt must be an integer\")\n", "        # Range checks\n\t        if not (1 <= cnt <= 65535):\n\t            raise ValueError(\"cnt must be between 1 and 65535\")\n\t        if not (1 <= len <= 65535):\n\t            raise ValueError(\"len must be between 1 and 65535\")\n\t        # Do the thing\n\t        strings = []\n\t        for _ in range(cnt):\n\t            strings.append(\n\t                \"\".join(random.choice(string.ascii_letters) for i in range(len))\n", "            )\n\t        return json.dumps(strings)\n\t    def generate_password(self, len:int|str = 16, cnt:int|str = 1) -> str:\n\t        \"\"\"\n\t        Return a random password of letters, numbers, and punctuation\n\t        Args:\n\t            len (int): The length of the password\n\t            cnt (int): The number of passwords to return\n\t        Returns:\n\t            str: a json array with 1 to \"count\" passwords of \"length\" length\n", "            [\"<password>\"]\n\t        \"\"\"\n\t        # Type-check the arguments\n\t        if not isinstance(len, int):\n\t            try:\n\t                len = int(len)\n\t            except ValueError:\n\t                raise ValueError(\"len must be an integer\")\n\t        if not isinstance(cnt, int):\n\t            try:\n", "                cnt = int(cnt)\n\t            except ValueError:\n\t                raise ValueError(\"cnt must be an integer\")\n\t        # Make values sane\n\t        if not (6 <= len <= 65535):\n\t            raise ValueError(\"len must be between 6 and 65535\")\n\t        if not (1 <= cnt <= 65535):\n\t            raise ValueError(\"cnt must be between 1 and 65535\")\n\t        # Do the thing\n\t        passwords = []\n", "        for _ in range(cnt):\n\t            passwords.append(\n\t                \"\".join(\n\t                    random.choice(string.ascii_letters + string.digits + string.punctuation)\n\t                    for i in range(len)\n\t                )\n\t            )\n\t        return json.dumps(passwords)\n\t    def generate_placeholder_text(self, cnt:int|str = 1) -> str:\n\t        \"\"\"\n", "        Return a random sentence of lorem ipsum text\n\t        Args:\n\t            cnt (int): The number of sentences to return\n\t        Returns:\n\t            str: a json array with 1 to \"sentences\" strings of lorem ipsum\n\t            [\"<string>\"]\n\t        \"\"\"\n\t        # Type-check the arguments\n\t        if not isinstance(cnt, int):\n\t            try:\n", "                cnt = int(cnt)\n\t            except ValueError:\n\t                raise ValueError(\"cnt must be an integer\")\n\t        # Make values sane\n\t        if not (1 <= cnt <= 65535):\n\t            raise ValueError(\"cnt must be between 1 and 65535\")\n\t        # Do the thing\n\t        strings = []\n\t        for _ in range(cnt):\n\t            strings.append(lorem.get_sentence())\n", "        return json.dumps(strings)\n"]}
