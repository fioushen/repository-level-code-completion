{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\tsetup(\n\t    name='symlogos',\n\t    version='0.1.0',\n\t    packages=find_packages(),\n\t    install_requires=[\n\t        \"sympy>=1.7.1\"\n\t    ],\n\t    extras_require={\n\t        \"tests\": [\"pytest\"],\n", "    },\n\t    classifiers=[\n\t        \"Development Status :: 3 - Alpha\",\n\t        \"Intended Audience :: Education\",\n\t        \"Intended Audience :: Science/Research\",\n\t        \"License :: OSI Approved :: MIT License\",\n\t        \"Natural Language :: English\",\n\t        \"Operating System :: OS Independent\",\n\t        \"Programming Language :: Python\",\n\t        \"Programming Language :: Python :: 3\",\n", "        \"Programming Language :: Python :: 3.6\",\n\t        \"Programming Language :: Python :: 3.7\",\n\t        \"Programming Language :: Python :: 3.8\",\n\t        \"Programming Language :: Python :: 3.9\",\n\t        \"Programming Language :: Python :: 3.10\",\n\t        \"Programming Language :: Python :: 3.11\",\n\t        \"Topic :: Scientific/Engineering\",\n\t        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n\t        \"Topic :: Scientific/Engineering :: Information Analysis\",\n\t        \"Topic :: Scientific/Engineering :: Mathematics\",\n", "        \"Topic :: Software Development :: Libraries\",\n\t        \"Topic :: Software Development :: Libraries :: Python Modules\",\n\t        \"Topic :: Utilities\",\n\t    ],\n\t    author='Greg Bonney',\n\t    author_email='gnbonney@gmail.com',\n\t    description='SymLogos is a Python library that extends the capabilities of SymPy to support higher-order modal logic for formal reasoning and theorem proving.',\n\t    long_description=open('README.md').read(),\n\t    long_description_content_type='text/markdown',\n\t    url='https://github.com/gnbonney/symlogos',\n", "    license='MIT',\n\t)\n"]}
{"filename": "main.py", "chunked_list": ["from symlogos.functions_and_predicates import Proposition, Term, FunctionApplication, Predicate, Forall, Exists, Implication\n\tdef demonstrate_propositions():\n\t    print(\"=== Propositions ===\")\n\t    p = Proposition(\"p\")\n\t    not_p = ~p\n\t    box_p = p.box()\n\t    diamond_p = p.diamond()\n\t    print(\"p:\", p)\n\t    print(\"¬p:\", not_p)\n\t    print(\"□p:\", box_p)\n", "    print(\"◇p:\", diamond_p)\n\t    print()\n\tdef demonstrate_predicates_quantifiers():\n\t    print(\"=== Predicates and Quantifiers ===\")\n\t    x = Term(\"x\")\n\t    y = Term(\"y\")\n\t    Px = Predicate(\"P\", x)\n\t    Py = Predicate(\"P\", y)\n\t    forall_px = Forall(x, Px)\n\t    exists_py = Exists(y, Py)\n", "    print(\"Px:\", Px)\n\t    print(\"Py:\", Py)\n\t    print(\"∀xPx:\", forall_px)\n\t    print(\"∃yPy:\", exists_py)\n\t    print()\n\tdef demonstrate_function_application():\n\t    print(\"=== Function Application ===\")\n\t    x = Term(\"x\")\n\t    y = Term(\"y\")\n\t    f = FunctionApplication(\"f\", x)\n", "    g = FunctionApplication(\"g\", y)\n\t    print(\"f(x):\", f)\n\t    print(\"g(y):\", g)\n\t    print()\n\tdef demonstrate_implications():\n\t    print(\"=== Implications ===\")\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    p_implies_q = Implication(p, q)\n\t    not_p_implies_not_q = Implication(~p, ~q)\n", "    print(\"p -> q:\", p_implies_q)\n\t    print(\"¬p -> ¬q:\", not_p_implies_not_q)\n\t    print()\n\tif __name__ == \"__main__\":\n\t    demonstrate_propositions()\n\t    demonstrate_predicates_quantifiers()\n\t    demonstrate_function_application()\n\t    demonstrate_implications()\n"]}
{"filename": "symlogos/modal_logic.py", "chunked_list": ["from .proposition import Proposition\n\tfrom symlogos.connectives import Implication\n\tfrom .modal_operators import Necessity, Possibility\n\tfrom .rules import Rule\n\tfrom symlogos.rules import Rule\n\tclass ModalLogic:\n\t    @staticmethod\n\t    def necessitation() -> Rule:\n\t        p = Proposition(\"p\")\n\t        return Rule(\"Necessitation\", [p], Necessity(p))\n", "    @staticmethod\n\t    def distribution_axiom() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Distribution Axiom\", [Necessity(Implication(p, q))], Implication(Necessity(p), Necessity(q)))\n\t    @staticmethod\n\t    def possibility_axiom() -> Rule:\n\t        p = Proposition(\"p\")\n\t        return Rule(\"Possibility Axiom\", [Possibility(p)], Necessity(Possibility(p)))\n\t    @staticmethod\n", "    def modal_modus_ponens() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Modal Modus Ponens\", [Necessity(Implication(p, q)), Necessity(p)], Necessity(q))\n\t    @staticmethod\n\t    def t_schema() -> Rule:\n\t        p = Proposition(\"p\")\n\t        return Rule(\"T-schema\", [Necessity(p)], p)\n"]}
{"filename": "symlogos/rules.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tfrom symlogos.expressions_and_terms import LogicalExpression\n\tfrom sympy.core.basic import Basic\n\tfrom typing import List\n\tfrom symlogos.signed_formula import SignedFormula\n\tclass Rule:\n\t    def __init__(self, name: str, premises: List[Basic], conclusion: Basic) -> None:\n\t        self.name = name\n\t        self.premises = premises\n\t        self.conclusion = conclusion\n", "    def __str__(self) -> str:\n\t        premises_str = \", \".join(map(str, self.premises))\n\t        return f\"{self.name}: {premises_str} ⊢ {self.conclusion}\"\n\t    def __repr__(self) -> str:\n\t        premises_repr = \", \".join(map(repr, self.premises))\n\t        return f\"Rule('{self.name}', [{premises_repr}], {repr(self.conclusion)})\"\n\t    def apply(self, *args) -> LogicalExpression:\n\t        if len(args) != len(self.premises):\n\t            raise ValueError(\"Wrong number of arguments\")\n\t        match_dicts = []\n", "        for premise, arg in zip(self.premises, args):\n\t            current_match = premise.match(arg)\n\t            print(f\"Matching {premise} with {arg}: {current_match}\")  # Debug print\n\t            if current_match is None:\n\t                return None\n\t            match_dicts.append(current_match)\n\t        match_dict = {}\n\t        for d in match_dicts:\n\t            match_dict.update(d)\n\t        result = self.conclusion.substitute_all_terms(match_dict)\n", "        print(f\"Rule applied: {result}\")  # Debug print\n\t        return result\n\t    def to_nnf(self) -> \"Rule\":\n\t        nnf_premises = [premise.to_nnf() for premise in self.premises]\n\t        nnf_conclusion = self.conclusion.to_nnf()\n\t        return Rule(self.name, nnf_premises, nnf_conclusion)\n\tdef check_consistency():\n\t    pass\n\tdef check_validity():\n\t    pass\n", "class TableauRule(ABC):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        self.signed_formula = signed_formula\n\t    @abstractmethod\n\t    def is_applicable(self):\n\t        \"\"\"\n\t        Check if the rule is applicable to the signed_formula.\n\t        \"\"\"\n\t        pass\n\t    @abstractmethod\n", "    def apply(self):\n\t        \"\"\"\n\t        Apply the rule to the signed_formula and return a list of branches,\n\t        where each branch is a list of SignedFormulas.\n\t        \"\"\"\n\t        pass"]}
{"filename": "symlogos/modal_operators.py", "chunked_list": ["from .expressions_and_terms import LogicalExpression, simplify_expression\n\tfrom symlogos.connectives import And\n\tfrom symlogos.proposition import Proposition\n\tfrom typing import Any, Dict, Union\n\tclass Necessity(LogicalExpression):\n\t    def __init__(self, expr: Any) -> None:\n\t        self.expr = expr\n\t    def __str__(self) -> str:\n\t        return f\"□{self.expr}\"\n\t    def __eq__(self, other: \"Necessity\") -> bool:\n", "        if not isinstance(other, Necessity):\n\t            return False\n\t        return self.expr == other.expr\n\t    def __hash__(self):\n\t        return hash((type(self), self.expr))\n\t    def __repr__(self):\n\t        return f\"Necessity({repr(self.expr)})\"\n\t    def simplify(self) -> bool:\n\t        expr_simplified = simplify_expression(self.expr)\n\t        if expr_simplified == True:\n", "            return True\n\t        if expr_simplified == False:\n\t            return False\n\t        return Necessity(expr_simplified)\n\t    def substitute(self, mapping):\n\t        new_expr = self.expr.substitute(mapping)\n\t        return Necessity(new_expr)\n\t    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Necessity\":\n\t        new_expr = self.expr.substitute_all_terms(term_replacement_dict)\n\t        return Necessity(new_expr)\n", "    def match(self, expression: \"Necessity\") -> Dict[Any, Any]:\n\t        if isinstance(expression, Necessity):\n\t            match_result = self.expr.match(expression.expr)\n\t            if match_result is not None:\n\t                return match_result\n\t        return None\n\tclass Possibility(LogicalExpression):\n\t    def __init__(self, expr: Union[bool, And, Proposition]) -> None:\n\t        self.expr = expr\n\t    def __eq__(self, other: \"Possibility\") -> bool:\n", "        if isinstance(other, Possibility):\n\t            return self.expr == other.expr\n\t        return False\n\t    def __hash__(self):\n\t        return hash((type(self), self.expr))\n\t    def __str__(self) -> str:\n\t        return f\"◇{self.expr}\"\n\t    def __repr__(self):\n\t        return f\"Possibility({repr(self.expr)})\"\n\t    def simplify(self) -> bool:\n", "        expr_simplified = simplify_expression(self.expr)\n\t        if expr_simplified == True:\n\t            return True\n\t        if expr_simplified == False:\n\t            return False\n\t        return Possibility(expr_simplified)\n\t    def match(self, other: \"Possibility\") -> Dict[Any, Any]:\n\t        if isinstance(other, Possibility):\n\t            match_result = self.expr.match(other.expr)\n\t            if match_result is None:\n", "                print(f\"Matching failed for expressions: self: {self}, other: {other}\")\n\t            else:\n\t                print(f\"Match successful: self: {self}, other: {other}, bindings: {match_result}\")\n\t            return match_result\n\t        else:\n\t            match_result = self.expr.match(other)\n\t            if match_result is None:\n\t                print(f\"Matching failed for expressions with different types: self: {self}, other: {other}\")\n\t            else:\n\t                print(f\"Match successful: self: {self}, other: {other}, bindings: {match_result}\")\n", "            return match_result\n"]}
{"filename": "symlogos/quantifiers.py", "chunked_list": ["from .expressions_and_terms import LogicalExpression\n\tfrom symlogos.expressions_and_terms import Term\n\tfrom symlogos.functions_and_predicates import Predicate\n\tfrom symlogos.modal_operators import Necessity\n\tfrom symlogos.proposition import Proposition\n\tfrom sympy.core.symbol import Symbol\n\tfrom typing import Any, Dict, Union\n\tclass Forall(LogicalExpression):\n\t    def __init__(self, variable: Union[Symbol, Term, str, Proposition], predicate: Union[Predicate, Necessity, Proposition]) -> None:\n\t        self.variable = variable\n", "        self.predicate = predicate\n\t    def instantiate(self, term):\n\t        return self.predicate.substitute({self.variable: term})\n\t    def __repr__(self):\n\t        return f\"∀{self.variable}: {self.predicate}\"\n\t    def __eq__(self, other: \"Forall\") -> bool:\n\t        return isinstance(other, Forall) and self.variable == other.variable and self.predicate == other.predicate\n\t    def __hash__(self):\n\t        return hash((type(self), self.variable, self.predicate))\n\t    def __str__(self) -> str:\n", "        return f\"∀{self.variable}: {self.predicate}\"\n\t    def __repr__(self):\n\t        return f\"Forall({repr(self.variable)}, {repr(self.predicate)})\"\n\t    def substitute(self, mapping: Dict[Term, Term]) -> \"Forall\":\n\t        new_bound_variable = mapping.get(self.variable, self.variable)\n\t        new_predicate = self.predicate.substitute(mapping)\n\t        return Forall(new_bound_variable, new_predicate)\n\t    def substitute_all(self, substitutions):\n\t        # Prevent the bound variable from being substituted\n\t        if self.variable in substitutions:\n", "            del substitutions[self.variable]\n\t        # Use the default implementation for the remaining substitutions\n\t        return super().substitute_all(substitutions)\n\t    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Forall\":\n\t        new_predicate = self.predicate.substitute_all_terms(term_replacement_dict)\n\t        return Forall(self.variable, new_predicate)\n\t    def match(self, other: \"Forall\") -> Dict[Any, Any]:\n\t        if isinstance(other, Forall):\n\t            variable_match = self.variable.match(other.variable)\n\t            predicate_match = self.predicate.match(other.predicate)\n", "            print(f\"Forall match: self: {self}, other: {other}, variable_match: {variable_match}, predicate_match: {predicate_match}\")\n\t            if variable_match is not None and predicate_match is not None:\n\t                bindings = {}\n\t                bindings.update(variable_match)\n\t                bindings.update(predicate_match)\n\t                return bindings\n\t        return None\n\t    def to_nnf(self) -> \"Forall\":\n\t        return Forall(self.variable, self.predicate.to_nnf())\n\tclass Exists(LogicalExpression):\n", "    def __init__(self, variable: Union[str, Symbol, Term, Proposition], predicate: Union[Predicate, Proposition]) -> None:\n\t        self.variable = variable\n\t        self.predicate = predicate\n\t    def __str__(self) -> str:\n\t        return f\"∃{self.variable}: {self.predicate}\"\n\t    def __eq__(self, other: \"Exists\") -> bool:\n\t        if not isinstance(other, Exists):\n\t            return False\n\t        return self.variable == other.variable and self.predicate == other.predicate\n\t    def __hash__(self):\n", "        return hash((type(self), self.variable, self.predicate))\n\t    def __repr__(self):\n\t        return f\"Exists({repr(self.variable)}, {repr(self.predicate)})\"\n\t    def substitute(self, mapping):\n\t        if self.variable in mapping:\n\t            raise ValueError(f\"Cannot substitute bound variable '{self.variable}'\")\n\t        new_expr = self.predicate.substitute(mapping)\n\t        return Exists(self.variable, new_expr)\n\t    def match(self, expression: \"Exists\") -> Dict[Term, Term]:\n\t        if isinstance(expression, Exists):\n", "            predicate_match = self.predicate.match(expression.predicate)\n\t            if predicate_match is not None:\n\t                print(f\"Match successful: self: {self}, expression: {expression}, substitutions: {predicate_match}\")\n\t                return predicate_match\n\t            else:\n\t                print(f\"Matching failed for predicates: self.predicate: {self.predicate}, expression.predicate: {expression.predicate}\")\n\t        else:\n\t            print(f\"Matching failed for different types: self: {self}, expression: {expression}\")\n\t        return None\n\t    def to_nnf(self) -> \"Exists\":\n", "        return Exists(self.variable, self.predicate.to_nnf())\n"]}
{"filename": "symlogos/functions_and_predicates.py", "chunked_list": ["from __future__ import annotations\n\timport sympy\n\tfrom .expressions_and_terms import LogicalExpression\n\t# higher-order predicates\n\tclass Predicate(LogicalExpression):\n\t    def __new__(cls: Type[Predicate], name: Union[    sympy.core.symbol.Symbol, str], *terms) -> \"Predicate\":\n\t        obj = super().__new__(cls)\n\t        obj.symbol = sympy.Symbol(str(name))  # Convert name to string before creating a sympy.Symbol\n\t        obj.terms = tuple(terms[0]) if len(terms) == 1 and isinstance(terms[0], (list, tuple)) else terms\n\t        return obj\n", "    def __eq__(self, other: \"Predicate\") -> bool:\n\t        if not isinstance(other, Predicate):\n\t            return False\n\t        return self.symbol == other.symbol and self.terms == other.terms\n\t    def __hash__(self):\n\t        return hash((type(self), self.symbol, self.terms))\n\t    def __str__(self) -> str:\n\t        return f\"{self.symbol}({', '.join(map(str, self.terms))})\"\n\t    def __repr__(self):\n\t        return f\"Predicate('{self.symbol}', {', '.join(map(repr, self.terms))})\"\n", "    def substitute(self, mapping: Dict[Term, Term]) -> \"Predicate\":\n\t        new_args = [mapping.get(term, term) for term in self.terms]\n\t        return Predicate(self.symbol, *new_args)\n\t    def substitute_all_terms(self, term_replacement_dict: Dict[Term, Term]) -> \"Predicate\":\n\t        new_terms = [term_replacement_dict.get(term, term) for term in self.terms]\n\t        new_predicate = Predicate(self.symbol, *new_terms)\n\t        return new_predicate\n\t    def evaluate(self, valuation=None):\n\t        if valuation is None:\n\t            return self\n", "        if self.symbol in valuation:\n\t            value = valuation[self.symbol]\n\t            if isinstance(value, bool):\n\t                return value\n\t        new_args = [arg.evaluate(valuation) if isinstance(arg, LogicalExpression) else arg for arg in self.terms]\n\t        return Predicate(self.symbol, *new_args)\n\t    def match(self, other: \"Predicate\") -> Dict[Term, Term]:\n\t        if isinstance(other, Predicate):\n\t            if self.symbol == other.symbol and len(self.terms) == len(other.terms):\n\t                bindings = {}\n", "                for t1, t2 in zip(self.terms, other.terms):\n\t                    b = t1.match(t2)\n\t                    if b is None:\n\t                        print(f\"Matching failed for: self: {self}, other: {other}, terms: {t1}, {t2}\")\n\t                        return None\n\t                    print(f\"Matched terms: {t1}, {t2}, binding: {b}\")\n\t                    bindings.update(b)\n\t                print(f\"Match successful: self: {self}, other: {other}, bindings: {bindings}\")\n\t                return bindings\n\t            else:\n", "                print(f\"Matching failed due to different symbol or term count: self: {self}, other: {other}\")\n\t                return None\n\t        else:\n\t            print(f\"Matching failed as other is not a Predicate: self: {self}, other: {other}\")\n\t            return None\n\t    def is_atomic(self):\n\t        return True\n\t    def to_nnf(self) -> \"Predicate\":\n\t        return self\n\t# high order functions\n", "from sympy import Basic, Symbol\n\timport sympy.core.symbol\n\tfrom symlogos.expressions_and_terms import Term\n\tfrom typing import Dict, Optional, Type, Union\n\tclass HigherOrderFunction(Basic):\n\t    def __new__(cls: Type[HigherOrderFunction], name: str, arg_function: Optional[HigherOrderFunction]=None, return_function: Optional[Union[Predicate, HigherOrderFunction]]=None, *args) -> \"HigherOrderFunction\":\n\t        obj = super().__new__(cls)\n\t        obj._name = Symbol(name)\n\t        obj._arg_function = arg_function\n\t        obj._return_function = return_function\n", "        obj._args = args\n\t        return obj\n\t    @property\n\t    def name(self) ->     sympy.core.symbol.Symbol:\n\t        return self._name\n\t    @property\n\t    def arg_function(self):\n\t        return self._arg_function\n\t    @arg_function.setter\n\t    def arg_function(self, value):\n", "        self._arg_function = value\n\t    @property\n\t    def return_function(self):\n\t        return self._return_function\n\t    @return_function.setter\n\t    def return_function(self, value):\n\t        self._return_function = value\n\t    def __str__(self) -> str:\n\t        arg_str = f\"({', '.join(map(str, self.args))})\" if self.args else \"\"\n\t        if self.arg_function and self.return_function:\n", "            return f\"{self.name}({self.arg_function}) -> {self.return_function}{arg_str}\"\n\t        elif self.arg_function:\n\t            return f\"{self.name}({self.arg_function}{arg_str})\"\n\t        elif self.return_function:\n\t            return f\"{self.name} -> {self.return_function}{arg_str}\"\n\t        else:\n\t            return f\"{self.name}{arg_str}\"\n\t    def __repr__(self) -> str:\n\t        return f\"HigherOrderFunction('{self.name}', {repr(self.arg_function)}, {repr(self.return_function)})\"\n\t    def match(self, expr):\n", "        if isinstance(expr, HigherOrderFunction) and self.name == expr.name:\n\t            # check argument function\n\t            if self.arg_function is None or self.arg_function.match(expr.arg_function):\n\t                # check return function\n\t                if self.return_function is None or self.return_function.match(expr.return_function):\n\t                    # match arguments\n\t                    if len(self.args) != len(expr.args):\n\t                        print(f\"Matching failed due to different argument count: self: {self}, expr: {expr}\")\n\t                        return None\n\t                    substitutions = {}\n", "                    for i in range(len(self.args)):\n\t                        arg1 = self.args[i]\n\t                        arg2 = expr.args[i]\n\t                        result = arg1.match(arg2)\n\t                        if result is None:\n\t                            print(f\"Matching failed for arguments: self: {self}, expr: {expr}, args: {arg1}, {arg2}\")\n\t                            return None\n\t                        print(f\"Matched arguments: {arg1}, {arg2}, binding: {result}\")\n\t                        substitutions.update(result)\n\t                    print(f\"Match successful: self: {self}, expr: {expr}, bindings: {substitutions}\")\n", "                    return substitutions\n\t            else:\n\t                print(f\"Matching failed due to argument or return function mismatch: self: {self}, expr: {expr}\")\n\t                return None\n\t        else:\n\t            print(f\"Matching failed as expr is not a HigherOrderFunction or name mismatch: self: {self}, expr: {expr}\")\n\t            return None\n\tclass FunctionApplication(LogicalExpression):\n\t    def __init__(self, function_symbol: Union[HigherOrderFunction, str], *args) -> None:\n\t        self.function_symbol = function_symbol\n", "        self.arguments = args\n\t    def __str__(self) -> str:\n\t        args_str = ', '.join(str(arg) for arg in self.arguments)\n\t        return f\"{self.function_symbol}({args_str})\"\n\t    def __eq__(self, other: \"FunctionApplication\") -> bool:\n\t        if not isinstance(other, FunctionApplication):\n\t            return False\n\t        return self.function_symbol == other.function_symbol and self.arguments == other.arguments\n\t    def substitute(self, mapping):\n\t        new_args = tuple(arg.substitute(mapping) for arg in self.arguments)\n", "        return FunctionApplication(self.function_symbol, *new_args)\n\t    def variables(self):\n\t        variables = set()\n\t        for arg in self.arguments:\n\t            variables |= arg.variables()\n\t        return variables\n\t    def match(self, other):\n\t        if isinstance(other, FunctionApplication):\n\t            if self.function_symbol != other.function_symbol or len(self.arguments) != len(other.arguments):\n\t                return None\n", "            match = {}\n\t            for arg_self, arg_other in zip(self.arguments, other.arguments):\n\t                partial_match = arg_self.match(arg_other)\n\t                if partial_match is None:\n\t                    return None\n\t                for key, value in partial_match.items():\n\t                    if key in match and match[key] != value:\n\t                        return None\n\t                    match[key] = value\n\t            return match\n", "        return None\n"]}
{"filename": "symlogos/tableau_prover.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Optional\n\tfrom symlogos.first_order_rules import AlphaRule, BetaRule, DeltaRule, GammaRule\n\tfrom symlogos.modal_operators import Necessity, Possibility\n\tfrom symlogos.proposition import Proposition\n\tfrom symlogos.tableau_node import TableauNode\n\tfrom .signed_formula import SignedFormula\n\tfrom .connectives import And, Or, Not, Implication\n\tfrom .quantifiers import Forall, Exists\n\tfrom symlogos.signed_formula import SignedFormula\n", "from symlogos.modal_rules import ModalBoxTRule, ModalBoxFRule, ModalDiamondTRule, ModalDiamondFRule\n\tclass TableauProver:\n\t    def __init__(self):\n\t        self.tableau_formulas = set()\n\t    def is_sound(self, premises, conclusion):\n\t        # Create a set of signed formulas for the premises with the sign \"T\"\n\t        tableau_formulas = {SignedFormula(\"T\", premise) for premise in premises}\n\t        # Create a signed formula for the negation of the conclusion with the sign \"F\"\n\t        negated_conclusion = SignedFormula(\"F\", Not(conclusion))\n\t        # Add the negated conclusion to the tableau formulas\n", "        tableau_formulas.add(negated_conclusion)\n\t        # Print statements for debugging\n\t        print(\"Premises:\", premises)\n\t        print(\"Conclusion:\", conclusion)\n\t        print(\"Negated Conclusion:\", negated_conclusion)\n\t        print(\"Tableau Formulas:\", tableau_formulas)\n\t        # Pass the signed formula to your tableau expansion methods and proceed with the tableau method\n\t        initial_node = TableauNode(negated_conclusion)\n\t        result = self.tableau_expansion(initial_node)\n\t        # Check if the tableau is closed\n", "        return not result\n\t    def _handle_and_or(self, param):\n\t        if isinstance(param, TableauNode):\n\t            formula = param.signed_formula.formula\n\t            signed_formula = param.signed_formula\n\t        elif isinstance(param, SignedFormula):\n\t            formula = param.formula\n\t            signed_formula = param\n\t        else:\n\t            raise ValueError(\"unexpected input to _handle_and_or\")\n", "        if isinstance(formula, Implication):\n\t            if signed_formula.sign == \"T\":\n\t                return [SignedFormula(\"F\", formula.left), SignedFormula(\"T\", formula.right)]\n\t            else:\n\t                return [SignedFormula(\"T\", formula.left), SignedFormula(\"F\", formula.right)]\n\t        elif isinstance(formula, Not) and isinstance(formula.inner, Implication):\n\t            inner_formula = formula.inner\n\t            if signed_formula.sign == \"T\":\n\t                return [SignedFormula(\"T\", inner_formula.left), SignedFormula(\"F\", inner_formula.right)]\n\t            else:\n", "                return [SignedFormula(\"F\", inner_formula.left), SignedFormula(\"T\", inner_formula.right)]\n\t        elif isinstance(formula, And):\n\t            if signed_formula.sign == \"T\":\n\t                return [SignedFormula(\"T\", formula.left), SignedFormula(\"T\", formula.right)]\n\t            else:\n\t                return [SignedFormula(\"F\", formula.left), SignedFormula(\"F\", formula.right)]\n\t        else:\n\t            rule = AlphaRule(signed_formula)\n\t            return rule.apply()\n\t    def _handle_quantifiers(self, node, signed_formula):\n", "        if signed_formula.sign == \"T\" and isinstance(signed_formula.formula, Forall) or signed_formula.sign == \"F\" and isinstance(signed_formula.formula, Exists):\n\t            rule = GammaRule(signed_formula)\n\t        else:\n\t            rule = DeltaRule(signed_formula)\n\t        return [child.signed_formula for child in rule.apply(node)]\n\t    def _handle_modal_operators(self, signed_formula):\n\t        formula = signed_formula.formula\n\t        if isinstance(formula, Necessity):\n\t            rule = ModalBoxTRule(signed_formula) if signed_formula.sign == \"T\" else ModalBoxFRule(signed_formula)\n\t        else:  # isinstance(formula, Possibility)\n", "            rule = ModalDiamondTRule(signed_formula) if signed_formula.sign == \"T\" else ModalDiamondFRule(signed_formula)\n\t        return rule.apply()\n\t    def _handle_not(self, signed_formula):\n\t        formula = signed_formula.formula\n\t        new_sign = \"T\" if signed_formula.sign == \"F\" else \"F\"\n\t        new_signed_formula = SignedFormula(new_sign, formula.expr)\n\t        return [new_signed_formula]\n\t    def tableau_expansion(self, node: TableauNode, depth=0, max_depth=1000):\n\t        signed_formula = node.signed_formula\n\t        # Debug: Print the current signed formula and depth\n", "        print(f\"Depth: {depth}, Current signed formula: {signed_formula}\")\n\t        # Check for termination conditions\n\t        if depth >= max_depth:\n\t            # Maximum depth reached; cannot determine if the tableau is closed\n\t            return False\n\t        # Check if the tableau is closed\n\t        if self._is_tableau_closed(node):\n\t            print(f\"Tableau closed at depth {depth} with signed formula {signed_formula}\")\n\t            return True\n\t        # Apply tableau rules to the signed formula\n", "        formula = signed_formula.formula\n\t        if isinstance(formula, And) or isinstance(formula, Or):\n\t            new_signed_formulas = self._handle_and_or(signed_formula)\n\t        elif isinstance(formula, Forall) or isinstance(formula, Exists):\n\t            new_signed_formulas = self._handle_quantifiers(node, signed_formula)\n\t        elif isinstance(formula, Necessity) or isinstance(formula, Possibility):\n\t            new_signed_formulas = self._handle_modal_operators(signed_formula)\n\t        elif isinstance(formula, Not):\n\t            new_signed_formulas = self._handle_not(signed_formula)\n\t        else:\n", "            new_signed_formulas = []\n\t        # Debug: Print the new signed formulas generated\n\t        print(f\"New signed formulas: {new_signed_formulas}\")\n\t        results = [self.tableau_expansion(node.add_child(new_signed_formula), depth + 1, max_depth) for new_signed_formula in new_signed_formulas]\n\t        return any(results)\n\t    def _is_tableau_closed(self, node: TableauNode) -> bool:\n\t        signed_formulas = [node.signed_formula] + [ancestor.signed_formula for ancestor in node.get_ancestors()]\n\t        print(\"Signed formulas in the current branch:\")\n\t        for sf in signed_formulas:\n\t            print(sf)\n", "        for sf1 in signed_formulas:\n\t            for sf2 in signed_formulas:\n\t                if sf1.formula == sf2.formula and sf1.sign != sf2.sign:\n\t                    return True\n\t        return False\n"]}
{"filename": "symlogos/tableau_node.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Optional, List\n\tfrom symlogos.signed_formula import SignedFormula\n\tclass TableauNode:\n\t    def __init__(self, signed_formula: SignedFormula, parent: Optional[TableauNode]=None) -> None:\n\t        self.signed_formula = signed_formula\n\t        self.parent = parent\n\t        self.children = []\n\t    def add_child(self, signed_formula):\n\t        child_node = TableauNode(signed_formula, parent=self)\n", "        self.children.append(child_node)\n\t        return child_node\n\t    def get_next_fresh_constant_index(self):\n\t        if self.parent:\n\t            return self.parent.get_next_fresh_constant_index() + 1\n\t        else:\n\t            return 0\n\t    def get_next_fresh_variable_index(self) -> int:\n\t        if self.parent:\n\t            return self.parent.get_next_fresh_variable_index() + 1\n", "        else:\n\t            return 0\n\t    def get_ancestors(self) -> List['TableauNode']:\n\t        ancestors = []\n\t        current_node = self.parent\n\t        while current_node is not None:\n\t            ancestors.append(current_node)\n\t            current_node = current_node.parent\n\t        return ancestors"]}
{"filename": "symlogos/__init__.py", "chunked_list": []}
{"filename": "symlogos/quantified_logic.py", "chunked_list": ["from .proposition import Proposition\n\tfrom .rules import Rule\n\tfrom .modal_logic import Necessity\n\tfrom .quantifiers import Exists, Forall\n\tfrom symlogos.rules import Rule\n\tclass QuantifiedLogic:\n\t    @staticmethod\n\t    def existential_instantiation() -> Rule:\n\t        x = Proposition(\"x\")\n\t        Fx = Proposition(\"Fx\")\n", "        c = Proposition(\"c\")\n\t        return Rule(\"Existential Instantiation\", [Exists(x, Fx)], Fx.substitute(x, c))\n\t    @staticmethod\n\t    def barcan_formula() -> Rule:\n\t        x = Proposition(\"x\")\n\t        Fx = Proposition(\"Fx\")\n\t        return Rule(\"Barcan Formula\", [Necessity(Forall(x, Fx))], Forall(x, Necessity(Fx)))\n"]}
{"filename": "symlogos/modal_rules.py", "chunked_list": ["from symlogos.signed_formula import SignedFormula\n\tfrom symlogos.modal_operators import Necessity, Possibility\n\tfrom symlogos.rules import TableauRule\n\tclass ModalBoxTRule(TableauRule):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n\t    def apply(self) -> list:\n\t        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n\t        if not isinstance(self.signed_formula.formula, Necessity) or self.signed_formula.sign != \"T\":\n\t            raise ValueError(\"Invalid signed formula for ModalBoxTRule\")\n", "        new_signed_formula = SignedFormula(\"T\", self.signed_formula.formula.expr)\n\t        result= [new_signed_formula]\n\t        print(f\"{self.__class__.__name__}: Result: {result}\")\n\t        return result\n\t    def is_applicable(self) -> bool:\n\t        return self.signed_formula.sign == \"T\" and isinstance(self.signed_formula.formula, Necessity)\n\tclass ModalBoxFRule(TableauRule):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n\t    def apply(self) -> list:\n", "        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n\t        if not isinstance(self.signed_formula.formula, Necessity) or self.signed_formula.sign != \"F\":\n\t            raise ValueError(\"Invalid signed formula for ModalBoxFRule\")\n\t        new_signed_formula = SignedFormula(\"F\", self.signed_formula.formula.expr)\n\t        result = [new_signed_formula]\n\t        print(f\"{self.__class__.__name__}: Result: {result}\")\n\t        return result\n\t    def is_applicable(self) -> bool:\n\t        return self.signed_formula.sign == \"F\" and isinstance(self.signed_formula.formula, Necessity)\n\tclass ModalDiamondTRule(TableauRule):\n", "    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n\t    def apply(self) -> list:\n\t        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n\t        if not isinstance(self.signed_formula.formula, Possibility) or self.signed_formula.sign != \"T\":\n\t            raise ValueError(\"Invalid signed formula for ModalDiamondTRule\")\n\t        new_signed_formula = SignedFormula(\"T\", self.signed_formula.formula.expr)\n\t        result = [new_signed_formula]\n\t        print(f\"{self.__class__.__name__}: Result: {result}\")\n\t        return result\n", "    def is_applicable(self) -> bool:\n\t        return self.signed_formula.sign == \"T\" and isinstance(self.signed_formula.formula, Possibility)\n\tclass ModalDiamondFRule(TableauRule):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n\t    def apply(self) -> list:\n\t        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n\t        if not isinstance(self.signed_formula.formula, Possibility) or self.signed_formula.sign != \"F\":\n\t            raise ValueError(\"Invalid signed formula for ModalDiamondFRule\")\n\t        new_signed_formula = SignedFormula(\"F\", self.signed_formula.formula.expr)\n", "        result = [new_signed_formula]\n\t        print(f\"{self.__class__.__name__}: Result: {result}\")\n\t        return result\n\t    def is_applicable(self) -> bool:\n\t        return self.signed_formula.sign == \"F\" and isinstance(self.signed_formula.formula, Possibility)\n"]}
{"filename": "symlogos/classical_propositional_logic.py", "chunked_list": ["from .connectives import Implication, And, Or, Not\n\tfrom .proposition import Proposition\n\tfrom symlogos.rules import Rule\n\tclass ClassicalPropositionalLogic:\n\t    @staticmethod\n\t    def modus_ponens() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Modus Ponens\", [p, Implication(p, q)], q)\n\t    @staticmethod\n", "    def modus_tollens() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Modus Tollens\", [Implication(p, q), Not(q)], Not(p))\n\t    @staticmethod\n\t    def disjunction_introduction() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Disjunction Introduction\", [p], Or(p, q))\n\t    @staticmethod\n", "    def disjunction_elimination() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        r = Proposition(\"r\")\n\t        return Rule(\"Disjunction Elimination\", [Or(p, q), Implication(p, r), Implication(q, r)], r)\n\t    @staticmethod\n\t    def conjunction_introduction() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Conjunction Introduction\", [p, q], And(p, q))\n", "    @staticmethod\n\t    def conjunction_elimination1() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Conjunction Elimination 1\", [And(p, q)], p)\n\t    @staticmethod\n\t    def conjunction_elimination2() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Conjunction Elimination 2\", [And(p, q)], q)\n", "    @staticmethod\n\t    def commutativity_and() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Commutativity of And\", [And(p, q)], And(q, p))\n\t    @staticmethod\n\t    def commutativity_or() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Commutativity of Or\", [Or(p, q)], Or(q, p))\n", "    @staticmethod\n\t    def associativity_and() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        r = Proposition(\"r\")\n\t        return Rule(\"Associativity of And\", [And(p, And(q, r))], And(And(p, q), r))\n\t    @staticmethod\n\t    def associativity_or() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n", "        r = Proposition(\"r\")\n\t        return Rule(\"Associativity of Or\", [Or(p, Or(q, r))], Or(Or(p, q), r))\n\t    @staticmethod\n\t    def idempotency_and() -> Rule:\n\t        p = Proposition(\"p\")\n\t        return Rule(\"Idempotency of And\", [And(p, p)], p)\n\t    @staticmethod\n\t    def idempotency_or() -> Rule:\n\t        p = Proposition(\"p\")\n\t        return Rule(\"Idempotency of Or\", [Or(p, p)], p)\n", "    @staticmethod\n\t    def double_negation_elimination() -> Rule:\n\t        p = Proposition(\"p\")\n\t        return Rule(\"Double Negation Elimination\", [Not(Not(p))], p)\n\t    @staticmethod\n\t    def distribution_and_over_or() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        r = Proposition(\"r\")\n\t        return Rule(\"Distribution of And over Or\", [And(p, Or(q, r))], Or(And(p, q), And(p, r)))\n", "    @staticmethod\n\t    def distribution_or_over_and() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        r = Proposition(\"r\")\n\t        return Rule(\"Distribution of Or over And\", [Or(p, And(q, r))], And(Or(p, q), Or(p, r)))\n\t    @staticmethod\n\t    def absorption_and() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n", "        return Rule(\"Absorption of And\", [And(p, Or(p, q))], p)\n\t    @staticmethod\n\t    def absorption_or() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Absorption of Or\", [Or(p, And(p, q))], p)\n\t    @staticmethod\n\t    def negation_and_to_or() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n", "        return Rule(\"Negation of And to Or\", [Not(And(p, q))], Or(Not(p), Not(q)))\n\t    @staticmethod\n\t    def negation_or_to_and() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n\t        return Rule(\"Negation of Or to And\", [Not(Or(p, q))], And(Not(p), Not(q)))\n\t    @staticmethod\n\t    def implication_to_or() -> Rule:\n\t        p = Proposition(\"p\")\n\t        q = Proposition(\"q\")\n", "        return Rule(\"Implication to Or\", [Implication(p, q)], Or(Not(p), q))\n"]}
{"filename": "symlogos/connectives.py", "chunked_list": ["from __future__ import annotations\n\tfrom .expressions_and_terms import LogicalExpression, simplify_expression\n\tfrom symlogos.expressions_and_terms import Term\n\tfrom typing import Any, Dict, Union, TYPE_CHECKING\n\tif TYPE_CHECKING:\n\t    from symlogos.proposition import Proposition\n\t    from symlogos.modal_operators import Necessity\n\tclass Implication(LogicalExpression):\n\t    def __init__(self, antecedent: Union['Proposition', 'Necessity', Term], consequent: Union['Proposition', 'Necessity', Term]) -> None:\n\t        self.antecedent = antecedent\n", "        self.consequent = consequent\n\t    @property\n\t    def left(self):\n\t        return self.antecedent\n\t    @property\n\t    def right(self):\n\t        return self.consequent\n\t    def __hash__(self):\n\t        return hash((type(self), self.antecedent, self.consequent))\n\t    def __eq__(self, other: \"Implication\") -> bool:\n", "        if isinstance(other, Implication):\n\t            return self.antecedent == other.antecedent and self.consequent == other.consequent\n\t        return False\n\t    def __str__(self) -> str:\n\t        antecedent_str = str(self.antecedent)\n\t        consequent_str = str(self.consequent)\n\t        return f\"({antecedent_str} → {consequent_str})\"\n\t    def __repr__(self):\n\t        return f\"Implication({repr(self.antecedent)}, {repr(self.consequent)})\"\n\t    def substitute(self, variable, replacement):\n", "        antecedent_substituted = self.antecedent.substitute(variable, replacement)\n\t        consequent_substituted = self.consequent.substitute(variable, replacement)\n\t        return Implication(antecedent_substituted, consequent_substituted)\n\t    def evaluate(self, valuation=None):\n\t        if valuation is None:\n\t            return self\n\t        antecedent_val = self.antecedent.evaluate(valuation)\n\t        consequent_val = self.consequent.evaluate(valuation)\n\t        if isinstance(antecedent_val, bool) and isinstance(consequent_val, bool):\n\t            return not antecedent_val or consequent_val\n", "        else:\n\t            return Implication(antecedent_val, consequent_val)\n\t    def simplify(self):\n\t        antecedent_simplified = simplify_expression(self.antecedent)\n\t        consequent_simplified = simplify_expression(self.consequent)\n\t        if antecedent_simplified == True:\n\t            return consequent_simplified\n\t        if antecedent_simplified == False or consequent_simplified == True:\n\t            return True\n\t        if antecedent_simplified == consequent_simplified:\n", "            return True\n\t        return Implication(antecedent_simplified, consequent_simplified)\n\t    def match(self, other: \"Implication\") -> Dict[Any, Any]:\n\t        if self == other:\n\t            return {}\n\t        return None\n\t    def to_nnf(self) -> \"Or\":\n\t        negated_antecedent = Not(self.antecedent).to_nnf()\n\t        consequent_nnf = self.consequent.to_nnf()\n\t        return Or(negated_antecedent, consequent_nnf)\n", "class And(LogicalExpression):\n\t    def __init__(self, left: Any, right: Union[And, Term, Or, 'Proposition', Not]) -> None:\n\t        self.left = left\n\t        self.right = right\n\t    def __hash__(self):\n\t        return hash((type(self), self.left, self.right))\n\t    def __str__(self) -> str:\n\t        left_str = str(self.left)\n\t        right_str = str(self.right)\n\t        return f\"({left_str} ∧ {right_str})\"\n", "    def __repr__(self):\n\t        return f\"And({repr(self.left)}, {repr(self.right)})\"\n\t    def substitute(self, variable: 'Proposition', replacement: 'Proposition') -> \"And\":\n\t        left_substituted = self.left.substitute(variable, replacement)\n\t        right_substituted = self.right.substitute(variable, replacement)\n\t        return And(left_substituted, right_substituted)\n\t    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"And\":\n\t        left_substituted = self.left.substitute_all_terms(term_replacement_dict)\n\t        right_substituted = self.right.substitute_all_terms(term_replacement_dict)\n\t        return And(left_substituted, right_substituted)\n", "    def evaluate(self, valuation=None):\n\t        if valuation is None:\n\t            return self\n\t        left_val = self.left.evaluate(valuation)\n\t        right_val = self.right.evaluate(valuation)\n\t        if isinstance(left_val, bool) and isinstance(right_val, bool):\n\t            return left_val and right_val\n\t        else:\n\t            return And(left_val, right_val)\n\t    def __eq__(self, other: \"And\") -> bool:\n", "        if isinstance(other, And):\n\t            return self.left == other.left and self.right == other.right\n\t        return False\n\t    def simplify(self) -> Union['Proposition', bool, And]:\n\t        left_simplified = simplify_expression(self.left)\n\t        right_simplified = simplify_expression(self.right)\n\t        if left_simplified == True:\n\t            return right_simplified\n\t        if right_simplified == True:\n\t            return left_simplified\n", "        if left_simplified == False or right_simplified == False:\n\t            return False\n\t        if isinstance(left_simplified, Not) and isinstance(left_simplified.expr, Not):\n\t            left_simplified = left_simplified.expr.expr\n\t        if isinstance(right_simplified, Not) and isinstance(right_simplified.expr, Not):\n\t            right_simplified = right_simplified.expr.expr\n\t        if left_simplified == self.left and right_simplified == self.right:\n\t            return self\n\t        return And(left_simplified, right_simplified)\n\t    def match(self, other: \"And\", bindings: None=None) -> Dict[Any, Any]:\n", "        if bindings is None:\n\t            bindings = {}\n\t        if isinstance(other, And):\n\t            left_match = self.left.match(other.left, bindings)\n\t            right_match = self.right.match(other.right, bindings)\n\t            if left_match is None or right_match is None:\n\t                return None\n\t            new_bindings = dict(bindings)\n\t            new_bindings.update(left_match)\n\t            new_bindings.update(right_match)\n", "            return new_bindings\n\t        if isinstance(other, LogicalExpression):\n\t            return bindings\n\t        return None\n\t    def to_nnf(self) -> \"And\":\n\t        return And(*(arg.to_nnf() for arg in self.args))\n\tclass Or(LogicalExpression):\n\t    def __init__(self, left: Union['Proposition', And, Or, Not], right: Union['Proposition', Or, Not, And]) -> None:\n\t        self.left = left\n\t        self.right = right\n", "    def __hash__(self):\n\t        return hash((type(self), self.left, self.right))\n\t    def __repr__(self):\n\t        return f\"({self.left} ∨ {self.right})\"\n\t    def __eq__(self, other: \"Or\") -> bool:\n\t        if not isinstance(other, Or):\n\t            return False\n\t        return self.left == other.left and self.right == other.right\n\t    def variables(self):\n\t        return self.left.variables().union(self.right.variables())\n", "    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Or\":\n\t        new_left = self.left.substitute_all_terms(term_replacement_dict)\n\t        new_right = self.right.substitute_all_terms(term_replacement_dict)\n\t        return Or(new_left, new_right)\n\t    def match(self, other: \"Or\", bindings: None=None) -> Dict[Any, Any]:\n\t        if bindings is None:\n\t            bindings = {}\n\t        if isinstance(other, Or):\n\t            left_match = self.left.match(other.left, bindings)\n\t            if left_match is not None:\n", "                right_match = self.right.match(other.right, left_match)\n\t                if right_match is not None:\n\t                    return right_match\n\t        return None\n\t    def to_nnf(self) -> \"Or\":\n\t        return Or(*(arg.to_nnf() for arg in self.args))\n\tclass Not(LogicalExpression):\n\t    def __init__(self, expr: Union[And, bool, Or, 'Proposition', Not]) -> None:\n\t        super().__init__()\n\t        self.expr = expr\n", "    def __eq__(self, other: \"Not\") -> bool:\n\t        if isinstance(other, Not):\n\t            return self.expr == other.expr\n\t        return False\n\t    def __hash__(self):\n\t        return hash((type(self), self.expr))\n\t    def __str__(self) -> str:\n\t        return f\"¬{str(self.expr)}\"\n\t    def __repr__(self):\n\t        return f\"Not({repr(self.expr)})\"\n", "    def substitute(self, variable: 'Proposition', replacement: 'Proposition') -> \"Not\":\n\t        return Not(self.expr.substitute(variable, replacement))\n\t    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Not\":\n\t        new_expr = self.expr.substitute_all_terms(term_replacement_dict)  # Change this line\n\t        return Not(new_expr)\n\t    def evaluate(self, valuation=None):\n\t        if valuation is None:\n\t            return self\n\t        expr_val = self.expr.evaluate(valuation)\n\t        if isinstance(expr_val, bool):\n", "            return not expr_val\n\t        else:\n\t            return Not(expr_val)\n\t    def simplify(self) -> Union['Proposition', bool, Not]:\n\t        simplified_inner = simplify_expression(self.expr)\n\t        if isinstance(simplified_inner, Not):\n\t            return simplified_inner.expr\n\t        if simplified_inner == True:\n\t            return False\n\t        if simplified_inner == False:\n", "            return True\n\t        return Not(simplified_inner)\n\t    def __eq__(self, other: \"Not\") -> bool:\n\t        if isinstance(other, Not):\n\t            return self.expr == other.expr\n\t        return False\n\t    def match(self, other: \"Not\") -> Dict[Any, Any]:\n\t        if isinstance(other, Not):\n\t            print(f\"Matching Not: self: {self}, other: {other}\")\n\t            result = self.expr.match(other.expr)\n", "            print(f\"Match result: {result}\")\n\t            return result\n\t        else:\n\t            print(f\"Matching without Not: self: {self}, other: {other}\")\n\t            result = self.expr.match(other)\n\t            print(f\"Match result: {result}\")\n\t            return result\n\t    def to_nnf(self) -> \"Not\":\n\t        inner = self.expr\n\t        if inner.is_atomic():\n", "            return self\n\t        if isinstance(inner, And):\n\t            return Or(*(Not(expr).to_nnf() for expr in inner.expr))\n\t        if isinstance(inner, Or):\n\t            return And(*(Not(expr).to_nnf() for expr in inner.expr))\n\t        if isinstance(inner, Not):\n\t            return inner.expr.to_nnf()"]}
{"filename": "symlogos/first_order_rules.py", "chunked_list": ["from symlogos.connectives import And, Implication, Or\n\tfrom symlogos.expressions_and_terms import Term\n\tfrom symlogos.quantifiers import Exists, Forall\n\tfrom symlogos.rules import TableauRule\n\tfrom symlogos.signed_formula import SignedFormula\n\tfrom typing import List\n\tfrom symlogos.tableau_node import TableauNode\n\tclass AlphaRule(TableauRule):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n", "    def __hash__(self):\n\t        return hash((type(self), self.signed_formula))\n\t    def is_applicable(self) -> bool:\n\t        formula = self.signed_formula.formula\n\t        return isinstance(formula, And) or isinstance(formula, Or)\n\t    def apply(self) -> List[SignedFormula]:\n\t        print(f\"AlphaRule: Applying rule to {self.signed_formula}\")\n\t        if not self.is_applicable():\n\t            raise ValueError(\"Alpha rule is not applicable to the given formula\")\n\t        formula = self.signed_formula.formula\n", "        left = formula.left\n\t        right = formula.right\n\t        if isinstance(formula, And):\n\t            if self.signed_formula.is_positive():\n\t                result = [SignedFormula('T', left), SignedFormula('T', right)]\n\t            else:\n\t                result = [SignedFormula('F', left), SignedFormula('F', right)]\n\t        elif isinstance(formula, Or):\n\t            if self.signed_formula.is_positive():\n\t                result = [SignedFormula('T', left), SignedFormula('T', right)]\n", "            else:\n\t                result = [SignedFormula('F', left), SignedFormula('F', right)]\n\t        print(f\"AlphaRule: Result: {result}\")\n\t        return result\n\tclass BetaRule(TableauRule):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n\t    def __hash__(self):\n\t        return hash((type(self), self.signed_formula))\n\t    def is_applicable(self) -> bool:\n", "        formula = self.signed_formula.formula\n\t        return isinstance(formula, Implication)\n\t    def apply(self) -> List[SignedFormula]:\n\t        if not self.is_applicable():\n\t            raise ValueError(\"Beta rule is not applicable to the given formula\")\n\t        formula = self.signed_formula.formula\n\t        if isinstance(formula, Implication):\n\t            antecedent = formula.antecedent\n\t            consequent = formula.consequent\n\t            if self.signed_formula.is_positive():\n", "                return [SignedFormula('F', antecedent), SignedFormula('T', consequent)]\n\t            else:\n\t                return [SignedFormula('T', antecedent), SignedFormula('F', consequent)]\n\tclass GammaRule(TableauRule):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n\t    def __hash__(self):\n\t        return hash((type(self), self.signed_formula))\n\t    def is_applicable(self) -> bool:\n\t        return isinstance(self.signed_formula.formula, Exists) and self.signed_formula.sign == \"F\"\n", "    def apply(self, node: TableauNode) -> List[TableauNode]:\n\t        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n\t        quantifier_formula = self.signed_formula.formula\n\t        if not self.is_applicable():\n\t            raise ValueError(\"GammaRule can only be applied to negated Exists quantifiers\")\n\t        fresh_variable = Term(\"v_\" + str(node.get_next_fresh_variable_index()))\n\t        instantiated_formula = quantifier_formula.predicate.substitute({quantifier_formula.variable: fresh_variable})\n\t        new_node = TableauNode(SignedFormula(\"T\", instantiated_formula), node)\n\t        node.children.append(new_node)\n\t        result = [new_node]\n", "        print(f\"{self.__class__.__name__}: Result: {result}\")\n\t        return result\n\tclass DeltaRule(TableauRule):\n\t    def __init__(self, signed_formula: SignedFormula) -> None:\n\t        super().__init__(signed_formula)\n\t    def __hash__(self):\n\t        return hash((type(self), self.signed_formula))\n\t    def is_applicable(self):\n\t        return isinstance(self.signed_formula.formula, Forall)\n\t    def apply(self, node: TableauNode) -> List[TableauNode]:\n", "        quantifier_formula = self.signed_formula.formula\n\t        if not (isinstance(quantifier_formula, Forall) and self.signed_formula.sign == \"F\"):\n\t            raise ValueError(\"DeltaRule can only be applied to negated Forall quantifiers\")\n\t        fresh_variable = Term(\"v_\" + str(node.get_next_fresh_variable_index()))\n\t        instantiated_formula = quantifier_formula.predicate.substitute({quantifier_formula.variable: fresh_variable})\n\t        new_node = TableauNode(SignedFormula(\"T\", instantiated_formula), node)\n\t        node.children.append(new_node)\n\t        result = [new_node]\n\t        print(f\"{self.__class__.__name__}: Result: {result}\")\n\t        return result"]}
{"filename": "symlogos/axiom_set.py", "chunked_list": ["from symlogos.proposition import Proposition\n\tclass AxiomSet:\n\t    def __init__(self) -> None:\n\t        self.axioms = set()\n\t    def add_axiom(self, axiom: Proposition) -> None:\n\t        self.axioms.add(axiom)\n\t    def remove_axiom(self, axiom: Proposition) -> None:\n\t        if axiom in self.axioms:\n\t            self.axioms.remove(axiom)\n\t    def __iter__(self):\n", "        return iter(self.axioms)\n\t    def __len__(self) -> int:\n\t        return len(self.axioms)\n\t    def __contains__(self, axiom: Proposition) -> bool:\n\t        return axiom in self.axioms\n\t    def __repr__(self) -> str:\n\t        return f\"AxiomSet({', '.join(map(str, self.axioms))})\""]}
{"filename": "symlogos/expressions_and_terms.py", "chunked_list": ["from __future__ import annotations\n\timport abc\n\timport sympy\n\tfrom typing import Any, Dict, Type, Union, TYPE_CHECKING\n\tif TYPE_CHECKING:\n\t    from symlogos.connectives import Implication, Not\n\t    from symlogos.modal_operators import Possibility\n\t    from symlogos.proposition import Proposition\n\tclass CombinedMeta(sympy.Basic.__class__, abc.ABCMeta):\n\t    pass\n", "class LogicalExpression(sympy.Basic, metaclass=CombinedMeta):\n\t    @abc.abstractmethod\n\t    def __eq__(self, other):\n\t        pass\n\t    @abc.abstractmethod\n\t    def __hash__(self):\n\t        pass\n\t    @abc.abstractmethod\n\t    def match(self, other):\n\t        pass\n", "    def substitute(self, mapping):\n\t        raise NotImplementedError(\"Substitution not implemented for this class\")\n\t    def substitute_all(self, substitutions):\n\t        return self.subs(substitutions)\n\t    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> Union['Possibility', 'Implication']:\n\t        return self.subs(term_replacement_dict)\n\t    def evaluate(self, assignment):\n\t        return self.subs(assignment).evalf()\n\t    def is_atomic(self):\n\t        return False\n", "    def to_nnf(self) -> 'Proposition':\n\t        if self.is_atomic():\n\t            return self\n\t        else:\n\t            raise NotImplementedError(f\"to_nnf is not implemented for the class {type(self)}\")\n\tclass Term(sympy.Basic):\n\t    def __new__(cls: Type[Term], name: str) -> \"Term\":\n\t        obj = super().__new__(cls)\n\t        obj.symbol = sympy.Symbol(name)\n\t        return obj\n", "    def __eq__(self, other: \"Term\") -> bool:\n\t        if isinstance(other, Term):\n\t            return self.symbol == other.symbol\n\t        return False\n\t    def __hash__(self) -> int:\n\t        return hash((type(self), self.symbol))\n\t    def __str__(self) -> str:\n\t        return str(self.symbol)\n\t    def __repr__(self) -> str:\n\t        return f\"Term('{self.symbol}')\"\n", "    def substitute(self, mapping):\n\t        if self in mapping:\n\t            return mapping[self]\n\t        return self\n\t    def evaluate(self, assignment):\n\t        if self.symbol in assignment:\n\t            return assignment[self.symbol]\n\t        else:\n\t            raise ValueError(f\"Assignment for term '{self.symbol}' not found.\")\n\t    def match(self, other: \"Term\") -> Dict[Term, Term]:\n", "        if isinstance(other, Term):\n\t            if self.symbol == other.symbol:\n\t                print(f\"Match successful: self: {self}, other: {other}\")\n\t                return {}\n\t            elif self.is_variable() or other.is_variable():\n\t                print(f\"Match successful: self: {self}, other: {other}\")\n\t                return {self: other}\n\t            else:\n\t                print(f\"Matching failed for terms: self: {self}, other: {other}\")\n\t                return None\n", "        else:\n\t            print(f\"Matching failed for different types: self: {self}, other: {other}\")\n\t            return None\n\t    def is_variable(self) -> bool:\n\t        return self.symbol.name.islower()\n\tdef simplify_expression(expr: Union['Not', bool, 'Proposition']) -> Union['Not', bool, 'Proposition']:\n\t    if isinstance(expr, LogicalExpression):\n\t        return expr.simplify()\n\t    return expr\n"]}
{"filename": "symlogos/proposition.py", "chunked_list": ["from __future__ import annotations\n\timport sympy\n\tfrom .expressions_and_terms import LogicalExpression\n\tfrom typing import Any, Dict, Type, Union, TYPE_CHECKING\n\tif TYPE_CHECKING:\n\t    from symlogos.connectives import Not\n\tclass Proposition(LogicalExpression):\n\t    def __new__(cls: Type[Proposition], name: str) -> \"Proposition\":\n\t        obj = super().__new__(cls)\n\t        obj.name = sympy.Symbol(name)\n", "        return obj\n\t    def __eq__(self, other: Union[bool, Proposition, Not]) -> bool:\n\t        if isinstance(other, Proposition):\n\t            return self.name == other.name\n\t        return False\n\t    def __hash__(self) -> int:\n\t        return hash((type(self), self.name))\n\t    def __str__(self) -> str:\n\t        return str(self.name)\n\t    def __repr__(self):\n", "        return f\"Proposition('{self.name}')\"\n\t    def match(self, other: \"Proposition\", bindings: None=None) -> Dict[Any, Any]:\n\t        if bindings is None:\n\t            bindings = {}\n\t        if isinstance(other, Proposition):\n\t            if self.name == other.name:\n\t                return bindings\n\t            elif self.is_variable() or other.is_variable():\n\t                if self not in bindings:\n\t                    bindings[self] = other\n", "                    return bindings\n\t                elif bindings[self] == other:\n\t                    return bindings\n\t            return None\n\t        return None\n\t    def evaluate(self, assignment: Dict[Proposition, bool]) -> bool:\n\t        return assignment.get(self, self)\n\t    def simplify(self) -> \"Proposition\":\n\t        return self\n\t    def substitute(self, variable: \"Proposition\", replacement: \"Proposition\") -> \"Proposition\":\n", "        if self == variable:\n\t            return replacement\n\t        else:\n\t            return self\n\t    def substitute_all(self, substitutions):\n\t        new_attributes = {}\n\t        for attr, value in self.__dict__.items():\n\t            if isinstance(value, sympy.Basic):\n\t                new_attributes[attr] = value.subs(substitutions)\n\t            else:\n", "                new_attributes[attr] = value\n\t        result = self.__class__(*new_attributes.values())\n\t        return result\n\t    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Proposition\":\n\t        return self.subs(term_replacement_dict)\n\t    def is_atomic(self) -> bool:\n\t        return True\n"]}
{"filename": "symlogos/signed_formula.py", "chunked_list": ["from sympy.core.basic import Basic\n\tclass SignedFormula:\n\t    def __init__(self, sign: str, formula: Basic) -> None:\n\t        if sign not in ('T', 'F'):\n\t            raise ValueError(\"Sign must be either 'T' or 'F'\")\n\t        self.sign = sign\n\t        self.formula = formula\n\t    def __str__(self):\n\t        return f\"{self.sign} {self.formula}\"\n\t    def __eq__(self, other: \"SignedFormula\") -> bool:\n", "        if not isinstance(other, SignedFormula):\n\t            return False\n\t        return self.sign == other.sign and self.formula == other.formula\n\t    def __hash__(self):\n\t        return hash((type(self), self.sign, self.formula))\n\t    def is_positive(self) -> bool:\n\t        return self.sign == 'T'\n\t    def is_negative(self):\n\t        return self.sign == 'F'\n"]}
{"filename": "utils/project_analyzer.py", "chunked_list": ["import os\n\timport sys\n\timport ast\n\tdef analyze_module(file_path):\n\t    try:\n\t        with open(file_path, \"r\", encoding=\"utf-8\") as file:\n\t            content = file.read()\n\t        tree = ast.parse(content)\n\t        classes = [node for node in tree.body if isinstance(node, ast.ClassDef)]\n\t        functions = [node for node in tree.body if isinstance(node, ast.FunctionDef)]\n", "        def get_function_summary(func):\n\t            arg_info = []\n\t            for arg in func.args.args:\n\t                arg_type = ast.unparse(arg.annotation) if arg.annotation is not None else \"unknown\"\n\t                arg_info.append((arg.arg, arg_type))\n\t            return_type = ast.unparse(func.returns) if func.returns else \"unknown\"\n\t            return (func.name, arg_info, return_type)\n\t        function_summary = [get_function_summary(func) for func in functions]\n\t        class_summary = []\n\t        for cls in classes:\n", "            methods = [node for node in cls.body if isinstance(node, ast.FunctionDef)]\n\t            method_summary = [get_function_summary(method) for method in methods]\n\t            class_summary.append((cls.name, method_summary))\n\t        return {\n\t            \"classes\": class_summary,\n\t            \"functions\": function_summary,\n\t        }\n\t    except SyntaxError as e:\n\t        print(f\"Error: Unable to parse '{file_path}' due to a syntax error: {e}\")\n\t        return {\n", "            \"classes\": [],\n\t            \"functions\": [],\n\t        }\n\tdef analyze_project(project_root):\n\t    project_summary = {}\n\t    for root, dirs, files in os.walk(project_root):\n\t        # Ignore directories starting with \".\" and named \"test\"\n\t        dirs[:] = [d for d in dirs if not d.startswith(\".\") and d.lower() != \"test\"]\n\t        for file in files:\n\t            if file.endswith(\".py\") and not file.startswith(\"test_\"):\n", "                file_path = os.path.join(root, file)\n\t                module_name = os.path.relpath(file_path, project_root).replace(\"\\\\\", \".\").replace(\"/\", \".\")[:-3]\n\t                module_summary = analyze_module(file_path)\n\t                if module_summary[\"classes\"] or module_summary[\"functions\"]:\n\t                    project_summary[module_name] = module_summary\n\t    return project_summary\n\tdef print_summary(summary):\n\t    for module, items in summary.items():\n\t        print(f\"# Module: {module}\\n\")\n\t        if items[\"classes\"]:\n", "            print(\"## Classes:\\n\")\n\t            for cls, methods in items[\"classes\"]:\n\t                print(f\"### {cls}\\n\")\n\t                if methods:\n\t                    print(\"#### Methods:\\n\")\n\t                    for func, args, return_type in methods:\n\t                        args_str = ', '.join(f\"{name}: {arg_type}\" for name, arg_type in args)\n\t                        print(f\"- `{func}({args_str}) -> {return_type}`\\n\")\n\t        if items[\"functions\"]:\n\t            print(\"## Functions:\\n\")\n", "            for func, args, return_type in items[\"functions\"]:\n\t                args_str = ', '.join(f\"{name}: {arg_type}\" for name, arg_type in args)\n\t                print(f\"- `{func}({args_str}) -> {return_type}`\\n\")\n\t        print(\"---\\n\")\n\tif __name__ == \"__main__\":\n\t    if len(sys.argv) < 2:\n\t        print(\"Usage: python project_analyzer.py <project_root>\")\n\t        sys.exit(1)\n\t    project_root = sys.argv[1]\n\t    summary = analyze_project(project_root)\n", "    print_summary(summary)\n"]}
{"filename": "utils/automate_monkeytype.py", "chunked_list": ["import os\n\timport argparse\n\timport subprocess\n\tdef discover_modules(project_root):\n\t    modules = []\n\t    for root, dirs, files in os.walk(project_root):\n\t        dirs[:] = [d for d in dirs if not d.startswith('test')]  # Ignore test directories\n\t        for file in files:\n\t            if file.endswith('.py') and not file.startswith('test_'):  # Ignore test files\n\t                file_path = os.path.join(root, file)\n", "                module_name = \"symlogos.\" + os.path.splitext(file_path[len(project_root) + 1:].replace(os.sep, '.'))[0]\n\t                modules.append(module_name)\n\t    return modules\n\tdef main(project_root):\n\t    os.chdir(project_root)  # Change the current working directory to the project root\n\t    # Run MonkeyType to collect runtime types\n\t    subprocess.run(['monkeytype', 'run', '-m', 'pytest'])\n\t    # Generate and apply type annotations for each module\n\t    modules = discover_modules(project_root)\n\t    for module in modules:\n", "        subprocess.run(['monkeytype', 'stub', module])\n\t        subprocess.run(['monkeytype', 'apply', module])\n\tif __name__ == '__main__':\n\t    parser = argparse.ArgumentParser(description='Automate MonkeyType for a Python project')\n\t    parser.add_argument('project_root', help='Path to the project root directory')\n\t    args = parser.parse_args()\n\t    main(args.project_root)\n"]}
{"filename": "tests/test_symlogos.py", "chunked_list": ["from sympy import symbols, Symbol\n\tfrom symlogos.axiom_set import AxiomSet\n\tfrom symlogos.connectives import Implication, And, Not\n\tfrom symlogos.expressions_and_terms import LogicalExpression, Term\n\tfrom symlogos.functions_and_predicates import Predicate, HigherOrderFunction, FunctionApplication\n\tfrom symlogos.modal_operators import Possibility, Necessity\n\tfrom symlogos.proposition import Proposition\n\tfrom symlogos.quantifiers import Forall, Exists\n\tfrom symlogos.rules import Rule\n\tdef test_negation():\n", "    p = Proposition('p')\n\t    not_p = Not(p)\n\t    assert str(not_p) == '¬p'\n\tdef test_box_operator():\n\t    p = Proposition('p')\n\t    box_p = Necessity(p)\n\t    assert str(box_p) == '□p'\n\tdef test_diamond_operator():\n\t    p = Proposition('p')\n\t    diamond_p = Possibility(p)\n", "    assert str(diamond_p) == '◇p'\n\tdef test_expression_string_representation():\n\t    p = Proposition('p')\n\t    not_p = Not(p)\n\t    assert str(not_p) == '¬p'\n\tdef test_expression_complex_operations():\n\t    p, q = Proposition(\"p\"), Proposition(\"q\")\n\t    expr = Not(And(p, q))\n\t    assert str(expr) == \"¬(p ∧ q)\"\n\tdef test_expression_complex_operations_2():\n", "    p, q = Proposition(\"p\"), Proposition(\"q\")\n\t    expr = Necessity(And(p, q))\n\t    assert str(expr) == \"□(p ∧ q)\"\n\tdef test_expression_complex_operations_3():\n\t    p, q = Proposition(\"p\"), Proposition(\"q\")\n\t    expr = Possibility(And(p, q))\n\t    assert str(expr) == \"◇(p ∧ q)\"\n\tdef test_predicate():\n\t    x, y = symbols(\"x y\")\n\t    Px = Predicate(\"P\", x)\n", "    assert str(Px) == \"P(x)\"\n\t    Py = Predicate(\"P\", y)\n\t    assert str(Py) == \"P(y)\"\n\tdef test_forall():\n\t    x = symbols(\"x\")\n\t    Px = Predicate(\"P\", x)\n\t    forall_px = Forall(x, Px)\n\t    assert str(forall_px) == \"∀x: P(x)\"\n\tdef test_forall_substitution():\n\t    x = Term(\"x\")\n", "    c = Term(\"c\")\n\t    P = Predicate(\"P\", x)\n\t    forall_px = Forall(x, P)\n\t    result = forall_px.substitute({x: c})\n\t    assert result == Forall(c, Predicate(\"P\", c))\n\tdef test_exists():\n\t    y = symbols(\"y\")\n\t    Py = Predicate(\"P\", y)\n\t    exists_py = Exists(y, Py)\n\t    assert str(exists_py) == \"∃y: P(y)\"\n", "def test_higher_order_function():\n\t    f = HigherOrderFunction(\"f\")\n\t    assert str(f) == \"f\"\n\t    assert repr(f) == \"HigherOrderFunction('f', None, None)\"\n\tdef test_higher_order_function_with_arg_function():\n\t    g = HigherOrderFunction(\"g\")\n\t    f_of_g = HigherOrderFunction(\"f\", arg_function=g)\n\t    assert str(f_of_g) == \"f(g)\"\n\t    assert repr(f_of_g) == \"HigherOrderFunction('f', HigherOrderFunction('g', None, None), None)\"\n\tdef test_higher_order_function_with_return_function():\n", "    g = HigherOrderFunction(\"g\")\n\t    f_to_g = HigherOrderFunction(\"f\", return_function=g)\n\t    assert str(f_to_g) == \"f -> g\"\n\t    assert repr(f_to_g) == \"HigherOrderFunction('f', None, HigherOrderFunction('g', None, None))\"\n\tdef test_higher_order_function_with_arg_and_return_function():\n\t    h = HigherOrderFunction(\"h\")\n\t    g = HigherOrderFunction(\"g\")\n\t    f_of_h_to_g = HigherOrderFunction(\"f\", arg_function=h, return_function=g)\n\t    assert str(f_of_h_to_g) == \"f(h) -> g\"\n\t    assert repr(f_of_h_to_g) == \"HigherOrderFunction('f', HigherOrderFunction('h', None, None), HigherOrderFunction('g', None, None))\"\n", "def test_substitute():\n\t    p, q = Proposition(\"p\"), Proposition(\"q\")\n\t    not_p = Not(p)\n\t    not_q = Not(q)\n\t    assert not_p.substitute(p, q) == not_q\n\t    and_pq = And(p, q)\n\t    and_pr = And(p, p)\n\t    assert and_pq.substitute(q, p) == and_pr\n\tdef test_evaluate():\n\t    p = Proposition(\"p\")\n", "    q = Proposition(\"q\")\n\t    assignment = {p: True, q: False}\n\t    assert p.evaluate(assignment) == True\n\t    assert q.evaluate(assignment) == False\n\tdef test_simplify():\n\t    p, q = Proposition(\"p\"), Proposition(\"q\")\n\t    and_true_p = And(True, p)\n\t    assert and_true_p.simplify() == p\n\t    and_false_p = And(False, p)\n\t    assert and_false_p.simplify() == False\n", "    not_true = Not(True)\n\t    assert not_true.simplify() == False\n\t    not_false = Not(False)\n\t    assert not_false.simplify() == True\n\t    not_not_p = Not(Not(p))\n\t    assert not_not_p.simplify() == p\n\t    necessity_true = Necessity(True)\n\t    assert necessity_true.simplify() == True\n\t    possibility_true = Possibility(True)\n\t    assert possibility_true.simplify() == True\n", "def test_complex_simplify():\n\t    p, q = Proposition(\"p\"), Proposition(\"q\")\n\t    complex_expr = And(p, Not(Not(q)))\n\t    simplified_expr = And(p, q)\n\t    assert complex_expr.simplify() == simplified_expr\n\tdef test_add_remove_axiom():\n\t    axiom_set = AxiomSet()\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    assert len(axiom_set) == 0\n", "    assert p not in axiom_set\n\t    axiom_set.add_axiom(p)\n\t    assert len(axiom_set) == 1\n\t    assert p in axiom_set\n\t    axiom_set.add_axiom(q)\n\t    assert len(axiom_set) == 2\n\t    assert q in axiom_set\n\t    axiom_set.remove_axiom(p)\n\t    assert len(axiom_set) == 1\n\t    assert p not in axiom_set\n", "    assert q in axiom_set\n\tdef test_iterate_axioms():\n\t    axiom_set = AxiomSet()\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    axiom_set.add_axiom(p)\n\t    axiom_set.add_axiom(q)\n\t    axiom_list = [axiom for axiom in axiom_set]\n\t    assert p in axiom_list\n\t    assert q in axiom_list\n", "def test_repr():\n\t    axiom_set = AxiomSet()\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    axiom_set.add_axiom(p)\n\t    axiom_set.add_axiom(q)\n\t    assert \"p\" in repr(axiom_set)\n\t    assert \"q\" in repr(axiom_set)\n\tdef test_term_creation():\n\t    t = Term('x')\n", "    assert isinstance(t, Term)\n\t    assert t.symbol == Symbol('x')\n\tdef test_term_str():\n\t    t = Term('x')\n\t    assert str(t) == 'x'\n\tdef test_term_repr():\n\t    t = Term('x')\n\t    assert repr(t) == \"Term('x')\"\n\tdef test_rule_creation():\n\t    A = Term('A')\n", "    B = Term('B')\n\t    f = FunctionApplication('f', A)\n\t    g = FunctionApplication('g', B)\n\t    rule = Rule('example_rule', [f], g)\n\t    assert isinstance(rule, Rule)\n\t    assert rule.name == 'example_rule'\n\t    assert rule.premises == [f]\n\t    assert rule.conclusion == g\n\t    assert str(rule) == \"example_rule: f(A) ⊢ g(B)\"\n\tdef test_rule_str():\n", "    premise1 = Term('x')\n\t    premise2 = Term('y')\n\t    conclusion = Term('z')\n\t    rule = Rule('R1', [premise1, premise2], conclusion)\n\t    assert str(rule) == \"R1: x, y ⊢ z\"\n\tdef test_rule_repr():\n\t    premise1 = Term('x')\n\t    premise2 = Term('y')\n\t    conclusion = Term('z')\n\t    rule = Rule('R1', [premise1, premise2], conclusion)\n", "    assert repr(rule) == \"Rule('R1', [Term('x'), Term('y')], Term('z'))\"\n\tdef test_rule_apply():\n\t    x = Term(\"x\")\n\t    y = Term(\"y\")\n\t    P = Predicate(\"P\", x)\n\t    Q = Predicate(\"Q\", y)\n\t    R = Predicate(\"R\", x, y)\n\t    premise1 = P\n\t    premise2 = Q\n\t    conclusion = R\n", "    rule = Rule(\"TestRule\", [premise1, premise2], conclusion)\n\t    a = Term(\"a\")\n\t    b = Term(\"b\")\n\t    result = rule.apply(Predicate(\"P\", a), Predicate(\"Q\", b))\n\t    assert result == Predicate(\"R\", a, b)\n\tdef test_modus_ponens():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    modus_ponens = Rule(\"Modus Ponens\", [Implication(p, q), p], q)\n\t    premise1 = Implication(p, q)\n", "    premise2 = p\n\t    result = modus_ponens.apply(premise1, premise2)\n\t    assert result == q\n\tdef test_modus_tollens():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    modus_tollens = Rule(\"Modus Tollens\", [Implication(p, q), Not(q)], Not(p))\n\t    premise1 = Implication(p, q)\n\t    premise2 = Not(q)\n\t    result = modus_tollens.apply(premise1, premise2)\n", "    assert result == Not(p)\n\tdef test_universal_instantiation():\n\t    x = Term(\"x\")\n\t    c = Term(\"c\")\n\t    P = Predicate(\"P\", x)\n\t    forall_px = Forall(x, P)\n\t    universal_instantiation = Rule(\"Universal Instantiation\", [forall_px], Predicate(\"P\", c))\n\t    premise = forall_px\n\t    result = universal_instantiation.apply(premise)\n\t    assert result == Predicate(\"P\", c)\n", "def test_existential_instantiation():\n\t    x = Term(\"x\")\n\t    P = Predicate(\"P\", x)\n\t    premise = Exists(x, P)\n\t    rule = Rule(\"Existential Instantiation\", [premise], P)\n\t    a = Term(\"a\")\n\t    result = rule.apply(Exists(x, Predicate(\"P\", a)))\n\t    assert result == Predicate(\"P\", a)\n\tdef test_modal_modus_ponens():\n\t    p = Proposition(\"p\")\n", "    q = Proposition(\"q\")\n\t    box_p_implies_q = Necessity(Implication(p, q))\n\t    box_p = Necessity(p)\n\t    modal_modus_ponens = Rule(\"Modal Modus Ponens\", [box_p_implies_q, box_p], Necessity(q))\n\t    premise1 = box_p_implies_q\n\t    premise2 = box_p\n\t    result = modal_modus_ponens.apply(premise1, premise2)\n\t    assert result == Necessity(q)\n\tdef test_barcan_formula():\n\t    x = Term(\"x\")\n", "    P = Predicate(\"P\", x)\n\t    forall_P = Forall(x, P)\n\t    box_forall_P = Necessity(forall_P)\n\t    box_P = Necessity(P)\n\t    forall_box_P = Forall(x, box_P)\n\t    barcan_formula = Rule(\"Barcan Formula\", [forall_box_P], box_forall_P)\n\t    premise = forall_box_P\n\t    result = barcan_formula.apply(premise)\n\t    assert result == box_forall_P"]}
{"filename": "tests/test_tableau_prover_extracted_methods.py", "chunked_list": ["import pytest\n\tfrom symlogos.expressions_and_terms import Term\n\tfrom symlogos.functions_and_predicates import Predicate\n\tfrom symlogos.tableau_node import TableauNode\n\tfrom symlogos.tableau_prover import TableauProver\n\tfrom symlogos.signed_formula import SignedFormula\n\tfrom symlogos.connectives import And, Or, Not\n\tfrom symlogos.quantifiers import Forall, Exists\n\tfrom symlogos.proposition import Proposition\n\tfrom symlogos.modal_operators import Necessity, Possibility\n", "@pytest.fixture\n\tdef tableau_prover():\n\t    return TableauProver()\n\tdef test_handle_and_or(tableau_prover):\n\t    A = Proposition(\"A\")\n\t    B = Proposition(\"B\")\n\t    signed_formula_and = SignedFormula(\"T\", And(A, B))\n\t    signed_formula_or = SignedFormula(\"F\", Or(A, B))\n\t    new_signed_formulas_and = tableau_prover._handle_and_or(signed_formula_and)\n\t    new_signed_formulas_or = tableau_prover._handle_and_or(signed_formula_or)\n", "    # Assertions for And\n\t    assert len(new_signed_formulas_and) == 2\n\t    assert all(sf.sign == \"T\" for sf in new_signed_formulas_and)\n\t    assert {sf.formula for sf in new_signed_formulas_and} == {A, B}\n\t    # Assertions for Or\n\t    assert len(new_signed_formulas_or) == 2\n\t    assert all(sf.sign == \"F\" for sf in new_signed_formulas_or)\n\t    assert {sf.formula for sf in new_signed_formulas_or} == {A, B}\n\tdef test_handle_quantifiers(tableau_prover):\n\t    P = Predicate(\"P\")\n", "    x = Term(\"x\")\n\t    Px = Predicate(\"P\", x)\n\t    signed_formula_exists = SignedFormula(\"F\", Exists(x, Px))\n\t    signed_formula_example = SignedFormula(\"T\", Px)\n\t    node = TableauNode(signed_formula_example)\n\t    new_signed_formulas_exists = tableau_prover._handle_quantifiers(node, signed_formula_exists)\n\t    # Assertions for negated Exists quantifier\n\t    assert len(new_signed_formulas_exists) == 1\n\t    assert new_signed_formulas_exists[0].sign == \"T\"  \n\t    assert isinstance(new_signed_formulas_exists[0].formula, Predicate)\n", "    assert str(new_signed_formulas_exists[0].formula.symbol) == \"P\"  # This line is updated\n\tdef test_handle_modal_operators(tableau_prover):\n\t    A = Proposition(\"A\")\n\t    signed_formula_box_t = SignedFormula(\"T\", Necessity(A))\n\t    signed_formula_box_f = SignedFormula(\"F\", Necessity(A))\n\t    signed_formula_diamond_t = SignedFormula(\"T\", Possibility(A))\n\t    signed_formula_diamond_f = SignedFormula(\"F\", Possibility(A))\n\t    new_signed_formulas_box_t = tableau_prover._handle_modal_operators(signed_formula_box_t)\n\t    new_signed_formulas_box_f = tableau_prover._handle_modal_operators(signed_formula_box_f)\n\t    new_signed_formulas_diamond_t = tableau_prover._handle_modal_operators(signed_formula_diamond_t)\n", "    new_signed_formulas_diamond_f = tableau_prover._handle_modal_operators(signed_formula_diamond_f)\n\t    # Assertions for Necessity(T)\n\t    assert len(new_signed_formulas_box_t) == 1\n\t    assert new_signed_formulas_box_t[0].sign == \"T\"\n\t    assert new_signed_formulas_box_t[0].formula == A\n\t    # Assertions for Necessity(F)\n\t    assert len(new_signed_formulas_box_f) == 1\n\t    assert new_signed_formulas_box_f[0].sign == \"F\"\n\t    assert new_signed_formulas_box_f[0].formula == A\n\t    # Assertions for Possibility(T)\n", "    assert len(new_signed_formulas_diamond_t) == 1\n\t    assert new_signed_formulas_diamond_t[0].sign == \"T\"\n\t    assert new_signed_formulas_diamond_t[0].formula == A\n\t    # Assertions for Possibility(F)\n\t    assert len(new_signed_formulas_diamond_f) == 1\n\t    assert new_signed_formulas_diamond_f[0].sign == \"F\"\n\t    assert new_signed_formulas_diamond_f[0].formula == A\n\tdef test_handle_not(tableau_prover):\n\t    A = Proposition(\"A\")\n\t    signed_formula = SignedFormula(\"T\", Not(A))\n", "    new_signed_formulas = tableau_prover._handle_not(signed_formula)\n\t    # Add your assertions here, e.g.,\n\t    assert len(new_signed_formulas) == 1\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_nnf.py", "chunked_list": ["import pytest\n\tfrom symlogos.expressions_and_terms import LogicalExpression\n\tfrom symlogos.proposition import Proposition\n\tfrom symlogos.quantifiers import Forall, Exists\n\tfrom symlogos.functions_and_predicates import Predicate\n\tfrom symlogos.connectives import Implication, Not, And, Or\n\tfrom symlogos.rules import Rule\n\tdef test_proposition_to_nnf():\n\t    p = Proposition(\"p\")\n\t    assert p.to_nnf() == p\n", "def test_not_to_nnf():\n\t    p = Proposition(\"p\")\n\t    not_p = Not(p)\n\t    assert not_p.to_nnf() == not_p\n\tdef test_and_to_nnf():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    and_expr = And(p, q)\n\t    assert and_expr.to_nnf() == and_expr\n\tdef test_or_to_nnf():\n", "    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    or_expr = Or(p, q)\n\t    assert or_expr.to_nnf() == or_expr\n\tdef test_forall_to_nnf():\n\t    Px = Predicate(\"P\", \"x\")\n\t    forall_px = Forall(\"x\", Px)\n\t    assert forall_px.to_nnf() == forall_px\n\tdef test_exists_to_nnf():\n\t    Px = Predicate(\"P\", \"x\")\n", "    exists_px = Exists(\"x\", Px)\n\t    assert exists_px.to_nnf() == exists_px\n\tdef test_logical_expression_to_nnf_not_implemented():\n\t    class DummyExpression(LogicalExpression):\n\t        def __eq__(self, other):\n\t            return isinstance(other, DummyExpression)\n\t        def __hash__(self):\n\t            return hash(type(self))\n\t        def match(self, pattern):\n\t            return isinstance(pattern, DummyExpression)\n", "    dummy_expr = DummyExpression()\n\t    with pytest.raises(NotImplementedError):\n\t        dummy_expr.to_nnf()\n\tdef test_rule_to_nnf():\n\t    # Define propositions\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    # Define logical expressions\n\t    not_p = Not(p)\n\t    not_q = Not(q)\n", "    p_implies_q = Implication(p, q)\n\t    # Create a rule with premises and a conclusion\n\t    rule = Rule(\"Implication elimination\", [p_implies_q, p], q)\n\t    # Call the to_nnf method on the rule object\n\t    nnf_rule = rule.to_nnf()\n\t    # Check if the premises and conclusion of the nnf_rule are in NNF\n\t    assert nnf_rule.premises[0] == p_implies_q.to_nnf()\n\t    assert nnf_rule.premises[1] == p.to_nnf()\n\t    assert nnf_rule.conclusion == q.to_nnf()\n"]}
{"filename": "tests/test_function_application.py", "chunked_list": ["from symlogos.expressions_and_terms import Term\n\tfrom symlogos.quantifiers import Forall\n\tfrom symlogos.functions_and_predicates import Predicate, HigherOrderFunction, FunctionApplication\n\t# def test_function_application_predicate():\n\t#     x = Term(\"x\")\n\t#     y = Term(\"y\")\n\t#     R = Predicate(\"R\", 2)\n\t#     relation_application = FunctionApplication(R, x, y)\n\t#     assert relation_application == FunctionApplication(Predicate(\"R\", 2), Term(\"x\"), Term(\"y\"))\n\tdef test_function_application_higher_order():\n", "    x = Term(\"x\")\n\t    g = Predicate(\"g\", 1)\n\t    h = HigherOrderFunction(\"h\", return_function=g)\n\t    higher_order_application = FunctionApplication(h, x)\n\t    assert higher_order_application == FunctionApplication(HigherOrderFunction(\"h\", return_function=Predicate(\"g\", 1)), Term(\"x\"))\n\tdef test_forall_application():\n\t    x = Term(\"x\")\n\t    P = Predicate(\"P\", x)\n\t    forall_px = Forall(x, P)\n\t    assert forall_px == Forall(Term(\"x\"), Predicate(\"P\", Term(\"x\")))\n"]}
{"filename": "tests/test_modal_logic.py", "chunked_list": ["from symlogos.modal_logic import ModalLogic\n\tfrom symlogos.proposition import Proposition\n\tfrom symlogos.modal_operators import Necessity, Possibility\n\tfrom symlogos.connectives import Implication\n\tdef test_necessitation():\n\t    p = Proposition(\"p\")\n\t    rule = ModalLogic.necessitation()\n\t    premises = [p]\n\t    expected_result = Necessity(p)\n\t    result = rule.apply(*premises)\n", "    assert result == expected_result\n\tdef test_distribution_axiom():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ModalLogic.distribution_axiom()\n\t    premises = [Necessity(Implication(p, q))]\n\t    expected_result = Implication(Necessity(p), Necessity(q))\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_possibility_axiom():\n", "    p = Proposition(\"p\")\n\t    rule = ModalLogic.possibility_axiom()\n\t    premises = [Possibility(p)]\n\t    expected_result = Necessity(Possibility(p))\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_modal_modus_ponens():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ModalLogic.modal_modus_ponens()\n", "    premises = [Necessity(Implication(p, q)), Necessity(p)]\n\t    expected_result = Necessity(q)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_t_schema():\n\t    p = Proposition(\"p\")\n\t    rule = ModalLogic.t_schema()\n\t    premises = [Necessity(p)]\n\t    expected_result = p\n\t    result = rule.apply(*premises)\n", "    assert result == expected_result\n"]}
{"filename": "tests/test_classical_propositional_logic.py", "chunked_list": ["from symlogos.classical_propositional_logic import *\n\tfrom symlogos.connectives import Implication, And, Or, Not\n\tfrom symlogos.proposition import Proposition\n\tdef test_modus_ponens():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.modus_ponens()\n\t    premises = [p, Implication(p, q)]\n\t    expected_result = q\n\t    result = rule.apply(*premises)\n", "    assert result == expected_result\n\tdef test_modus_tollens():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.modus_tollens()\n\t    premises = [Implication(p, q), Not(q)]\n\t    expected_result = Not(p)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_disjunction_introduction():\n", "    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.disjunction_introduction()\n\t    premises = [p]\n\t    expected_result = Or(p, q)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_disjunction_elimination():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n", "    r = Proposition(\"r\")\n\t    rule = ClassicalPropositionalLogic.disjunction_elimination()\n\t    premises = [Or(p, q), Implication(p, r), Implication(q, r)]\n\t    expected_result = r\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_conjunction_introduction():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.conjunction_introduction()\n", "    premises = [p, q]\n\t    expected_result = And(p, q)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_conjunction_elimination1():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.conjunction_elimination1()\n\t    premises = [And(p, q)]\n\t    expected_result = p\n", "    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_conjunction_elimination2():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.conjunction_elimination2()\n\t    premises = [And(p, q)]\n\t    expected_result = q\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n", "def test_distribution_and_over_or():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    r = Proposition(\"r\")\n\t    rule = ClassicalPropositionalLogic.distribution_and_over_or()\n\t    premise = And(p, Or(q, r))\n\t    expected_result = Or(And(p, q), And(p, r))\n\t    result = rule.apply(premise)\n\t    assert result == expected_result\n\tdef test_distribution_or_over_and():\n", "    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    r = Proposition(\"r\")\n\t    rule = ClassicalPropositionalLogic.distribution_or_over_and()\n\t    premise = Or(p, And(q, r))\n\t    expected_result = And(Or(p, q), Or(p, r))\n\t    result = rule.apply(premise)\n\t    assert result == expected_result\n\tdef test_absorption_and():\n\t    p = Proposition(\"p\")\n", "    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.absorption_and()\n\t    premise = And(p, Or(p, q))\n\t    expected_result = p\n\t    result = rule.apply(premise)\n\t    assert result == expected_result\n\tdef test_absorption_or():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.absorption_or()\n", "    premise = Or(p, And(p, q))\n\t    expected_result = p\n\t    result = rule.apply(premise)\n\t    assert result == expected_result\n\tdef test_negation_and_to_or():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.negation_and_to_or()\n\t    premise = Not(And(p, q))\n\t    expected_result = Or(Not(p), Not(q))\n", "    result = rule.apply(premise)\n\t    assert result == expected_result\n\tdef test_negation_or_to_and():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.negation_or_to_and()\n\t    premise = Not(Or(p, q))\n\t    expected_result = And(Not(p), Not(q))\n\t    result = rule.apply(premise)\n\t    assert result == expected_result\n", "def test_implication_to_or():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.implication_to_or()\n\t    premise = Implication(p, q)\n\t    expected_result = Or(Not(p), q)\n\t    result = rule.apply(premise)\n\t    assert result == expected_result\n\tdef test_commutativity_and():\n\t    p = Proposition(\"p\")\n", "    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.commutativity_and()\n\t    premises = [And(p, q)]\n\t    expected_result = And(q, p)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_commutativity_or():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    rule = ClassicalPropositionalLogic.commutativity_or()\n", "    premises = [Or(p, q)]\n\t    expected_result = Or(q, p)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_associativity_and():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    r = Proposition(\"r\")\n\t    rule = ClassicalPropositionalLogic.associativity_and()\n\t    premises = [And(p, And(q, r))]\n", "    expected_result = And(And(p, q), r)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_associativity_or():\n\t    p = Proposition(\"p\")\n\t    q = Proposition(\"q\")\n\t    r = Proposition(\"r\")\n\t    rule = ClassicalPropositionalLogic.associativity_or()\n\t    premises = [Or(p, Or(q, r))]\n\t    expected_result = Or(Or(p, q), r)\n", "    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_idempotency_and():\n\t    p = Proposition(\"p\")\n\t    rule = ClassicalPropositionalLogic.idempotency_and()\n\t    premises = [And(p, p)]\n\t    expected_result = p\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_idempotency_or():\n", "    p = Proposition(\"p\")\n\t    rule = ClassicalPropositionalLogic.idempotency_or()\n\t    premises = [Or(p, p)]\n\t    expected_result = p\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_double_negation_elimination():\n\t    p = Proposition(\"p\")\n\t    rule = ClassicalPropositionalLogic.double_negation_elimination()\n\t    premises = [Not(Not(p))]\n", "    expected_result = p\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n"]}
{"filename": "tests/test_tableau_prover.py", "chunked_list": ["import pytest\n\tfrom symlogos.expressions_and_terms import Term\n\tfrom symlogos.connectives import And, Or, Implication\n\tfrom symlogos.functions_and_predicates import Predicate\n\tfrom symlogos.modal_operators import Necessity\n\tfrom symlogos.quantifiers import Forall, Exists\n\tfrom symlogos.signed_formula import SignedFormula\n\tfrom symlogos.tableau_prover import TableauProver, TableauNode\n\tfrom symlogos.first_order_rules import AlphaRule, BetaRule, GammaRule, DeltaRule\n\tfrom symlogos.proposition import Proposition\n", "def test_alpha_rule():\n\t    f1 = And(Term(\"A\"), Term(\"B\"))\n\t    sf = SignedFormula(\"T\", f1)\n\t    alpha_rule = AlphaRule(sf)\n\t    assert alpha_rule.is_applicable()\n\t    new_signed_formulas = alpha_rule.apply()\n\t    assert len(new_signed_formulas) == 2\n\t    assert SignedFormula(\"T\", Term(\"A\")) in new_signed_formulas\n\t    assert SignedFormula(\"T\", Term(\"B\")) in new_signed_formulas\n\tdef test_beta_rule():\n", "    f1 = Implication(Term(\"A\"), Term(\"B\"))\n\t    sf = SignedFormula(\"T\", f1)\n\t    beta_rule = BetaRule(sf)\n\t    assert beta_rule.is_applicable()\n\t    new_signed_formulas = beta_rule.apply()\n\t    assert len(new_signed_formulas) == 2\n\t    assert SignedFormula(\"F\", Term(\"A\")) in new_signed_formulas\n\t    assert SignedFormula(\"T\", Term(\"B\")) in new_signed_formulas\n\tdef test_gamma_rule():\n\t    x = Term(\"x\")\n", "    P = Predicate(\"P\", x)\n\t    f1 = Exists(x, P)\n\t    sf = SignedFormula(\"F\", f1)\n\t    gamma_rule = GammaRule(sf)\n\t    node = TableauNode(sf)\n\t    gamma_rule.apply(node)\n\t    # Check if the node has exactly one child\n\t    assert len(node.children) == 1\n\t    # Check if the child node has the correct signed formula\n\t    child_signed_formula = node.children[0].signed_formula\n", "    fresh_variable = Term(\"v_0\")\n\t    expected_signed_formula = SignedFormula(\"T\", P.substitute({x: fresh_variable}))\n\t    assert child_signed_formula == expected_signed_formula\n\tdef test_delta_rule():\n\t    x = Term(\"x\")\n\t    P = Predicate(\"P\", [x])\n\t    f1 = Forall(x, P)\n\t    sf = SignedFormula(\"F\", f1)\n\t    delta_rule = DeltaRule(sf)\n\t    node = TableauNode(sf)\n", "    delta_rule.apply(node)\n\t    assert len(node.children) == 1\n\t    assert node.children[0].signed_formula == SignedFormula(\"T\", Predicate(\"P\", [Term(\"v_0\")]))\n\tdef is_tableau_structure_correct(tableau, expected_structure):\n\t    def _compare_nodes(node, expected_node):\n\t        if not node or not expected_node:\n\t            return False\n\t        if node.signed_formula != expected_node.signed_formula:\n\t            return False\n\t        if len(node.children) != len(expected_node.children):\n", "            return False\n\t        for child, expected_child in zip(node.children, expected_node.children):\n\t            if not _compare_nodes(child, expected_child):\n\t                return False\n\t        return True\n\t    return _compare_nodes(tableau, expected_structure)\n\tdef test_tableau_structure_correct_and():\n\t    A = Proposition(\"A\")\n\t    B = Proposition(\"B\")\n\t    conjunction = And(A, B)\n", "    tableau_root = TableauNode(SignedFormula(\"T\", conjunction))\n\t    tableau_A = TableauNode(SignedFormula(\"T\", A))\n\t    tableau_B = TableauNode(SignedFormula(\"T\", B))\n\t    tableau_root.children = [tableau_A, tableau_B]\n\t    expected_structure = tableau_root\n\t    assert is_tableau_structure_correct(tableau_root, expected_structure)\n\tdef test_tableau_structure_correct_or():\n\t    A = Proposition(\"A\")\n\t    B = Proposition(\"B\")\n\t    disjunction = Or(A, B)\n", "    tableau_root = TableauNode(SignedFormula(\"T\", disjunction))\n\t    tableau_A = TableauNode(SignedFormula(\"T\", A))\n\t    tableau_B = TableauNode(SignedFormula(\"T\", B))\n\t    tableau_root.children = [tableau_A]\n\t    tableau_A.children = [tableau_B]\n\t    expected_structure = tableau_root\n\t    assert is_tableau_structure_correct(tableau_root, expected_structure)\n\tdef test_tableau_structure_correct_implication():\n\t    A = Proposition(\"A\")\n\t    B = Proposition(\"B\")\n", "    implication = Implication(A, B)\n\t    tableau_root = TableauNode(SignedFormula(\"T\", implication))\n\t    tableau_A = TableauNode(SignedFormula(\"F\", A))\n\t    tableau_B = TableauNode(SignedFormula(\"T\", B))\n\t    tableau_root.children = [tableau_A, tableau_B]\n\t    expected_structure = tableau_root\n\t    assert is_tableau_structure_correct(tableau_root, expected_structure)\n\tdef test_tableau_prover():\n\t    A = Proposition(\"A\")\n\t    B = Proposition(\"B\")\n", "    C = Proposition(\"C\")\n\t    # Example: A -> (B -> A)\n\t    premises = []\n\t    conclusion = Implication(A, Implication(B, A))\n\t    prover = TableauProver()\n\t    assert prover.is_sound(premises, conclusion)\n\t    # Example: (A -> B), A |- B\n\t    premises = [Implication(A, B), A]\n\t    conclusion = B\n\t    prover = TableauProver()\n", "    assert prover.is_sound(premises, conclusion)\n\t    # Example: (A -> B), (B -> C), A |- C\n\t    premises = [Implication(A, B), Implication(B, C), A]\n\t    conclusion = C\n\t    prover = TableauProver()\n\t    assert prover.is_sound(premises, conclusion)\n\t    # Example: A -> (B -> A)\n\t    premises = []\n\t    conclusion = Implication(A, Implication(B, A))\n\t    prover = TableauProver()\n", "    assert prover.is_sound(premises, conclusion)\n\t    # Example: A, (A -> B), (B -> C) |- C\n\t    premises = [A, Implication(A, B), Implication(B, C)]\n\t    conclusion = C\n\t    prover = TableauProver()\n\t    assert prover.is_sound(premises, conclusion)\n\t    # Example: (A and B) -> (B and A)\n\t    premises = []\n\t    conclusion = Implication(And(A, B), And(B, A))\n\t    prover = TableauProver()\n", "    assert prover.is_sound(premises, conclusion)\n\t    # Example: (A or B) -> (B or A)\n\t    premises = []\n\t    conclusion = Implication(Or(A, B), Or(B, A))\n\t    prover = TableauProver()\n\t    assert prover.is_sound(premises, conclusion)\n\tdef test_modal_tableau_prover():\n\t    A = Proposition(\"A\")\n\t    # Example: (□A -> A) -> A\n\t    premises = []\n", "    conclusion = Implication(Implication(Necessity(A), A), A)\n\t    prover = TableauProver()\n\t    assert prover.is_sound(premises, conclusion)"]}
{"filename": "tests/test_quantified_logic.py", "chunked_list": ["from symlogos.proposition import Proposition\n\tfrom symlogos.quantified_logic import QuantifiedLogic\n\tfrom symlogos.quantifiers import Exists\n\tfrom symlogos.modal_operators import Necessity\n\tfrom symlogos.quantifiers import Forall\n\tdef test_existential_instantiation():\n\t    x = Proposition(\"x\")\n\t    Fx = Proposition(\"Fx\")\n\t    c = Proposition(\"c\")\n\t    rule = QuantifiedLogic.existential_instantiation()\n", "    premises = [Exists(x, Fx)]\n\t    expected_result = Fx.substitute(x, c)\n\t    result = rule.apply(*premises)\n\t    assert result == expected_result\n\tdef test_barcan_formula():\n\t    x = Proposition(\"x\")\n\t    Fx = Proposition(\"Fx\")\n\t    rule = QuantifiedLogic.barcan_formula()\n\t    premises = [Necessity(Forall(x, Fx))]\n\t    expected_result = Forall(x, Necessity(Fx))\n", "    result = rule.apply(*premises)\n\t    assert result == expected_result"]}
{"filename": "tests/test_modal_tableau_rules.py", "chunked_list": ["import pytest\n\tfrom symlogos.modal_rules import ModalBoxTRule, ModalBoxFRule, ModalDiamondTRule, ModalDiamondFRule\n\tfrom symlogos.signed_formula import SignedFormula\n\tfrom symlogos.modal_operators import Necessity, Possibility\n\tfrom symlogos.proposition import Proposition\n\t@pytest.fixture\n\tdef A():\n\t    return Proposition(\"A\")\n\t@pytest.fixture\n\tdef B():\n", "    return Proposition(\"B\")\n\tdef test_modal_box_t_rule(A):\n\t    signed_formula = SignedFormula(\"T\", Necessity(A))\n\t    rule = ModalBoxTRule(signed_formula)\n\t    new_signed_formulas = rule.apply()\n\t    assert len(new_signed_formulas) == 1\n\t    assert new_signed_formulas[0] == SignedFormula(\"T\", A)\n\tdef test_modal_box_f_rule(A):\n\t    signed_formula = SignedFormula(\"F\", Necessity(A))\n\t    rule = ModalBoxFRule(signed_formula)\n", "    new_signed_formulas = rule.apply()\n\t    assert len(new_signed_formulas) == 1\n\t    assert new_signed_formulas[0] == SignedFormula(\"F\", A)\n\tdef test_modal_diamond_t_rule(A):\n\t    signed_formula = SignedFormula(\"T\", Possibility(A))\n\t    rule = ModalDiamondTRule(signed_formula)\n\t    new_signed_formulas = rule.apply()\n\t    assert len(new_signed_formulas) == 1\n\t    assert new_signed_formulas[0] == SignedFormula(\"T\", A)\n\tdef test_modal_diamond_f_rule(A):\n", "    signed_formula = SignedFormula(\"F\", Possibility(A))\n\t    rule = ModalDiamondFRule(signed_formula)\n\t    new_signed_formulas = rule.apply()\n\t    assert len(new_signed_formulas) == 1\n\t    assert new_signed_formulas[0] == SignedFormula(\"F\", A)\n"]}
