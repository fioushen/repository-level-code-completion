{"filename": "pytypest/_fixture_factory.py", "chunked_list": ["from __future__ import annotations\n\tfrom functools import update_wrapper\n\tfrom typing import TYPE_CHECKING, Protocol, overload\n\tfrom ._fixture import Fixture\n\tfrom ._scope import Scope\n\tif TYPE_CHECKING:\n\t    from typing import Callable, Iterator, Literal, TypeVar\n\t    from typing_extensions import ParamSpec\n\t    R = TypeVar('R')\n\t    P = ParamSpec('P')\n", "class FixtureMaker(Protocol):\n\t    \"\"\"\n\t    The type of the callback returned by the @fixture\n\t    when the decorator is called without the wrapped function\n\t    and it has a function scope.\n\t    \"\"\"\n\t    @overload\n\t    def __call__(self, callback: Callable[P, Iterator[R]]) -> Fixture[P, R]:\n\t        pass\n\t    @overload\n", "    def __call__(self, callback: Callable[P, R]) -> Fixture[P, R]:\n\t        pass\n\t    def __call__(self, callback):\n\t        pass\n\tclass FixtureMakerWithScope(Protocol):\n\t    \"\"\"\n\t    The type of the callback returned by the @fixture\n\t    when non-function `scope` is passed.\n\t    For non-function scope, fixtures must not accept arguments.\n\t    The reason is that it cannot be properly cached.\n", "    \"\"\"\n\t    @overload\n\t    def __call__(self, callback: Callable[[], Iterator[R]]) -> Fixture[[], R]:\n\t        pass\n\t    @overload\n\t    def __call__(self, callback: Callable[[], R]) -> Fixture[[], R]:\n\t        pass\n\t    def __call__(self, callback):\n\t        pass\n\t@overload\n", "def fixture(\n\t    callback: None = None,\n\t    *,\n\t    scope: Literal[Scope.FUNCTION] = Scope.FUNCTION,\n\t) -> FixtureMaker:\n\t    \"\"\"fixture decorator with explicit function scope.\n\t    ::\n\t        @fixture(scope=Scope.FUNCTION)\n\t        def get_user():\n\t            return User()\n", "    \"\"\"\n\t    pass\n\t@overload\n\tdef fixture(\n\t    callback: None = None,\n\t    *,\n\t    scope: Scope,\n\t) -> FixtureMakerWithScope:\n\t    \"\"\"fixture decorator with scope.\n\t    ::\n", "        @fixture(scope=Scope.SESSION)\n\t        def get_user():\n\t            return User()\n\t    \"\"\"\n\t    pass\n\t@overload\n\tdef fixture(callback: Callable[P, Iterator[R]]) -> Fixture[P, R]:\n\t    \"\"\"fixture decorator with teardown without scope.\n\t    ::\n\t        @fixture\n", "        def get_user():\n\t            yield User()\n\t    \"\"\"\n\t    pass\n\t@overload\n\tdef fixture(callback: Callable[P, R]) -> Fixture[P, R]:\n\t    \"\"\"fixture decorator without teardown without scope.\n\t    ::\n\t        @fixture\n\t        def get_user():\n", "            return User()\n\t    \"\"\"\n\t    pass\n\tdef fixture(\n\t    callback: Callable | None = None,\n\t    **kwargs,\n\t) -> Fixture[P, R] | Callable[[Callable], Fixture]:\n\t    \"\"\"A decorator to create a new fixture.\n\t    Fixtures are executed only when called, cached for the given scope,\n\t    and may have teardown logic that is executed when exiting the scope.\n", "    ::\n\t        @fixture\n\t        def get_user() -> Iterator[User]:\n\t            # setup\n\t            u = User()\n\t            # fixtures can use other fixtures\n\t            db = get_database()\n\t            db.insert(u)\n\t            # provide data for the test\n\t            yield u\n", "            # teardown\n\t            db.delete(u)\n\t    You can call the fixture to get the yielded value::\n\t        def test_user():\n\t            user = get_user()\n\t    Or you can use it as a context manager::\n\t        def test_user():\n\t            with get_user as user:\n\t                ...\n\t    Fixtures can accept arguments::\n", "        @fixture\n\t        def get_user(name: str):\n\t            ...\n\t        def test_user():\n\t            conn = get_user(name='Guido')\n\t    Fixtures without teardown may use `return` instead of `yield`::\n\t        @fixture\n\t        def get_user() -> User:\n\t            return User()\n\t    Fixtures can be called not only from test functions,\n", "    but from other fixtures, pytest fixtures, or helper functions\n\t    within a test run.\n\t    \"\"\"\n\t    if callback is not None:\n\t        fixture = Fixture(callback, **kwargs)\n\t        return update_wrapper(fixture, callback)\n\t    def wrapper(callback: Callable) -> Fixture:\n\t        fixture = Fixture(callback, **kwargs)\n\t        return update_wrapper(fixture, callback)\n\t    return wrapper\n"]}
{"filename": "pytypest/_scope.py", "chunked_list": ["from enum import Enum\n\tclass Scope(Enum):\n\t    \"\"\"Scope for which the fixture.\n\t    The scope defines when the fixture cache will be reset\n\t    and the teardown executed.\n\t    \"\"\"\n\t    FUNCTION = 'function'\n\t    \"\"\"\n\t    Default. Teardown is called at the end of the test function.\n\t    \"\"\"\n", "    CLASS = 'class'\n\t    \"\"\"\n\t    Teardown is called after the last test in a test class.\n\t    \"\"\"\n\t    MODULE = 'module'\n\t    \"\"\"\n\t    Teardown is called after the last test in a file.\n\t    \"\"\"\n\t    PACKAGE = 'package'\n\t    \"\"\"\n", "    Experimental. Teardown is called after the last test in a directory.\n\t    \"\"\"\n\t    SESSION = 'session'\n\t    \"\"\"\n\t    Teardown is called after the last tests overall in the current session.\n\t    \"\"\"\n"]}
{"filename": "pytypest/_manager.py", "chunked_list": ["from __future__ import annotations\n\tfrom dataclasses import dataclass, field\n\tfrom typing import Callable\n\tfrom ._hub import hub\n\tfrom ._scope import Scope\n\tfrom ._scope_manager import ScopeManager\n\tdef defer(scope: Scope, callback: Callable[[], None]) -> None:\n\t    \"\"\"Schedule the callback to be called when leaving the scope.\n\t    ::\n\t        defer(Scope.FUNCTION, self.teardown)\n", "    \"\"\"\n\t    if hub.manager is None:\n\t        raise RuntimeError('pytest plugin is not activated')\n\t    scope_manager = hub.manager.get_scope(scope)\n\t    scope_manager.defer(callback)\n\t@dataclass(frozen=True)\n\tclass Manager:\n\t    \"\"\"Holds a stack of scope managers with smaller scope being on top.\n\t    \"\"\"\n\t    _scopes: list[ScopeManager] = field(default_factory=list)\n", "    def get_scope(self, scope: Scope) -> ScopeManager:\n\t        for scope_manager in self._scopes:\n\t            if scope_manager.scope is scope:\n\t                return scope_manager\n\t        raise LookupError(f'cannot find ScopeManager for `{scope.value}` scope')\n\t    def enter_scope(self, scope: Scope) -> None:\n\t        scope_manager = ScopeManager(scope)\n\t        self._scopes.append(scope_manager)\n\t        scope_manager.enter_scope()\n\t    def exit_scope(self, scope: Scope) -> None:\n", "        scope_manager = self._scopes.pop()\n\t        assert scope_manager.scope == scope\n\t        scope_manager.exit_scope()\n"]}
{"filename": "pytypest/_autouse.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom ._hub import hub\n\tif TYPE_CHECKING:\n\t    from ._fixture import Fixture\n\tdef autouse(*fixtures: Fixture[[], None]) -> None:\n\t    \"\"\"Register fixtures to be used automatically when entering a scope.\n\t    Can be called only once in runtime.\n\t    ::\n\t        autouse(\n", "            create_database,\n\t            clear_cache,\n\t            fixtures.forbid_networking,\n\t        )\n\t    \"\"\"\n\t    if hub.autouse is not None:\n\t        raise RuntimeError('autouse can be called only once')\n\t    hub.autouse = fixtures\n"]}
{"filename": "pytypest/_parametrize.py", "chunked_list": ["from __future__ import annotations\n\timport inspect\n\tfrom typing import TYPE_CHECKING, Callable\n\timport pytest\n\tfrom typing_extensions import ParamSpec\n\tfrom ._case import Case\n\tif TYPE_CHECKING:\n\t    from _pytest.mark import ParameterSet\n\tP = ParamSpec('P')\n\tdef parametrize(\n", "    func: Callable[P, None],\n\t    *cases: Case[P],\n\t    **named_cases: Case[P],\n\t) -> Callable[[], None]:\n\t    \"\"\"Create a test for each case, each test calling the given func.\n\t    ::\n\t        def _test_add(a: int, b: int, exp: int) -> None:\n\t            assert a + b == exp\n\t        test_add = parametrize(\n\t            _test_add,\n", "            case(3, 4, exp=7),\n\t            case(4, 5, exp=9),\n\t            zeros=case(0, 0, exp=0),\n\t        )\n\t    \"\"\"\n\t    sig = inspect.Signature.from_callable(func)\n\t    params = list(sig.parameters)\n\t    table: list[ParameterSet | list] = []\n\t    row: ParameterSet | list\n\t    all_cases = list(cases)\n", "    for name, case in named_cases.items():\n\t        all_cases.append(case.with_id(name))\n\t    for case in all_cases:\n\t        bound = sig.bind(*case.args, **case.kwargs)\n\t        bound.apply_defaults()\n\t        row = [bound.arguments[p] for p in params]\n\t        if case.id or case.tags:\n\t            marks = [getattr(pytest.mark, tag) for tag in (case.tags or [])]\n\t            row = pytest.param(*row, id=case.id, marks=tuple(marks))\n\t        table.append(row)\n", "    func.__defaults__ = ()\n\t    return pytest.mark.parametrize(params, table)(func)\n"]}
{"filename": "pytypest/_fixture.py", "chunked_list": ["from __future__ import annotations\n\timport inspect\n\tfrom dataclasses import dataclass, field\n\tfrom enum import Enum\n\tfrom typing import Callable, Generic, Iterator, Literal, TypeVar\n\tfrom typing_extensions import ParamSpec\n\tfrom ._manager import defer\n\tfrom ._scope import Scope\n\tR = TypeVar('R')\n\tP = ParamSpec('P')\n", "class Sentinel(Enum):\n\t    \"\"\"A helper to define a singleton sentinel object in a mypy-friendly way.\n\t    ::\n\t        _: Literal[Sentinel.UNSET] = Sentinel.UNSET\n\t    \"\"\"\n\t    UNSET = object()\n\t@dataclass\n\tclass Fixture(Generic[P, R]):\n\t    \"\"\"A test fixture with setup and optional teardown.\n\t    Should be constructed using :func:`pytypest.fixture`::\n", "        @fixture\n\t        def get_user() -> Iterator[User]:\n\t            ... # setup\n\t            yield User()\n\t            ... # teardown\n\t    \"\"\"\n\t    _callback: Callable[P, R | Iterator[R]]\n\t    scope: Scope = Scope.FUNCTION\n\t    _iters: list[Iterator[R]] = field(default_factory=list)\n\t    _result: R | Literal[Sentinel.UNSET] = Sentinel.UNSET\n", "    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:\n\t        \"\"\"Allows the fixture to be called as a function.\n\t        ::\n\t            @fixture\n\t            def get_user():\n\t                ...\n\t            user = get_user()\n\t        \"\"\"\n\t        if self.scope != Scope.FUNCTION:\n\t            msg = 'fixtures with non-function scope must not accept arguments'\n", "            assert not args and not kwargs, msg\n\t        is_cached = self._result != Sentinel.UNSET and not args and not kwargs\n\t        if is_cached:\n\t            return self._result  # type: ignore[return-value]\n\t        result = self.setup(*args, **kwargs)\n\t        defer(self.scope, self.teardown)\n\t        return result\n\t    def setup(self, *args: P.args, **kwargs: P.kwargs) -> R:\n\t        \"\"\"Execute setup logic of the fixture and get its result.\n\t        Setup is everything that goes before `yield` or `return`.\n", "        Avoid using this method directly. It doesn't use cached results,\n\t        doesn't use the scope, and doesn't defer teardown.\n\t        Prefer calling the fixture or using it as a context manager.\n\t        \"\"\"\n\t        if inspect.isgeneratorfunction(self._callback):\n\t            iterator = self._callback(*args, **kwargs)\n\t            result = next(iterator)\n\t            self._iters.append(iterator)\n\t        else:\n\t            result = self._callback(*args, **kwargs)\n", "        if not args and not kwargs:\n\t            self._result = result\n\t        return result\n\t    def teardown(self) -> None:\n\t        \"\"\"Execute teardown logic of the fixture (if available).\n\t        Teardown is the code that goes after `yield` (if `yield` is present).\n\t        Can be safely called mutiple times.\n\t        \"\"\"\n\t        for iterator in self._iters:\n\t            try:\n", "                next(iterator)\n\t            except StopIteration:\n\t                pass\n\t            else:\n\t                raise RuntimeError('fixture must have at most one yield')\n\t        self._iters = []\n\t        self._result = Sentinel.UNSET\n\t    def __enter__(self) -> R:\n\t        \"\"\"Allows the fixture to be used as a context manager.\n\t        ::\n", "            @fixture\n\t            def get_user():\n\t                ...\n\t            with get_user as user:\n\t                ...\n\t        Regardless of the scope, the setup is executed when entering\n\t        the context, and the teardown is when leaving it.\n\t        \"\"\"\n\t        return self.setup()\n\t    def __exit__(self, *exc_info) -> None:\n", "        self.teardown()\n"]}
{"filename": "pytypest/__init__.py", "chunked_list": ["\"\"\"Type-safe and maintainable fixtures and parametrization for pytest.\n\t\"\"\"\n\tfrom . import experimental, fixtures\n\tfrom ._autouse import autouse\n\tfrom ._case import case\n\tfrom ._fixture_factory import fixture\n\tfrom ._parametrize import parametrize\n\tfrom ._scope import Scope\n\t__version__ = '1.0.0'\n\t__all__ = [\n", "    'autouse',\n\t    'case',\n\t    'experimental',\n\t    'fixture',\n\t    'fixtures',\n\t    'parametrize',\n\t    'Scope',\n\t]\n"]}
{"filename": "pytypest/_scope_manager.py", "chunked_list": ["from __future__ import annotations\n\tfrom collections import deque\n\tfrom dataclasses import dataclass, field\n\tfrom typing import Callable\n\tfrom ._scope import Scope\n\tFinalizer = Callable[[], None]\n\t@dataclass\n\tclass ScopeManager:\n\t    scope: Scope\n\t    _deferred: deque[Finalizer] = field(default_factory=deque)\n", "    def defer(self, callback: Finalizer) -> None:\n\t        self._deferred.append(callback)\n\t    def enter_scope(self) -> None:\n\t        assert not self._deferred\n\t    def exit_scope(self) -> None:\n\t        while self._deferred:\n\t            callback = self._deferred.pop()\n\t            callback()\n"]}
{"filename": "pytypest/_plugin.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Iterator\n\timport pytest\n\tfrom ._hub import hub\n\tfrom ._manager import Manager\n\tfrom ._scope import Scope\n\tSESSION_ATTR = '_pytypest_manager'\n\tdef pytest_sessionstart(session: pytest.Session) -> None:\n\t    manager = Manager()\n\t    hub.manager = manager\n", "    setattr(session, SESSION_ATTR, manager)\n\tdef _manage_scope(request: pytest.FixtureRequest) -> Iterator[None]:\n\t    hub.request = request\n\t    manager: Manager = getattr(request.session, SESSION_ATTR)\n\t    scope = Scope(request.scope)\n\t    manager.enter_scope(scope)\n\t    if hub.autouse:\n\t        for fixture in hub.autouse:\n\t            if fixture.scope == scope:\n\t                fixture()\n", "    yield\n\t    manager.exit_scope(scope)\n\t    hub.request = None\n\tenter_function = pytest.fixture(scope='function', autouse=True)(_manage_scope)\n\tenter_class = pytest.fixture(scope='class', autouse=True)(_manage_scope)\n\tenter_module = pytest.fixture(scope='module', autouse=True)(_manage_scope)\n\tenter_package = pytest.fixture(scope='package', autouse=True)(_manage_scope)\n\tenter_session = pytest.fixture(scope='session', autouse=True)(_manage_scope)\n"]}
{"filename": "pytypest/_hub.py", "chunked_list": ["from __future__ import annotations\n\tfrom dataclasses import dataclass\n\tfrom typing import TYPE_CHECKING\n\tif TYPE_CHECKING:\n\t    import pytest\n\t    from ._fixture import Fixture\n\t    from ._manager import Manager\n\t@dataclass\n\tclass Hub:\n\t    \"\"\"Singleton holding all global state.\n", "    \"\"\"\n\t    manager: Manager | None = None\n\t    request: pytest.FixtureRequest | None = None\n\t    autouse: tuple[Fixture[[], None], ...] | None = None\n\t    def reset(self) -> None:\n\t        \"\"\"Clean up all global state.\n\t        Used for pytypest's unit tests' isolation.\n\t        \"\"\"\n\t        self.manager = None\n\t        self.request = None\n", "        self.autouse = None\n\thub = Hub()\n"]}
{"filename": "pytypest/_case.py", "chunked_list": ["from __future__ import annotations\n\timport dataclasses\n\tfrom typing import Any, Generic, TypeVar\n\tfrom typing_extensions import ParamSpec\n\tP = ParamSpec('P')\n\tS = TypeVar('S')\n\t@dataclasses.dataclass(frozen=True)\n\tclass CaseMaker:\n\t    \"\"\"Create a new test case to be used with parametrized tests.\n\t    ::\n", "        def _test_add(a: int, b: int, exp: int):\n\t            assert a + b == exp\n\t        test_add = parametrize(\n\t            _test_add,\n\t            case(4, 5, exp=9),\n\t        )\n\t    \"\"\"\n\t    _id: str | None = None\n\t    _tags: tuple[str, ...] | None = None\n\t    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> Case[P]:\n", "        return Case(args=args, kwargs=kwargs, id=self._id, tags=self._tags)\n\t    def id(self, id: str) -> CaseMaker:\n\t        \"\"\"Give a name to the test case.\n\t        ::\n\t            test_logout = parametrize(\n\t                _test_logout,\n\t                case.id('anonymous_user')(user1),\n\t            )\n\t        \"\"\"\n\t        return dataclasses.replace(self, _id=id)\n", "    def tags(self, *tags: str) -> CaseMaker:\n\t        \"\"\"Mark the case with tags that can be used to filter specific tests.\n\t        ::\n\t            test_logout = parametrize(\n\t                _test_logout,\n\t                case.tags('slow', 'integration')(user1),\n\t            )\n\t        \"\"\"\n\t        return dataclasses.replace(self, _tags=tags)\n\tcase = CaseMaker()\n", "@dataclasses.dataclass(frozen=True)\n\tclass Case(Generic[P]):\n\t    \"\"\"A single test case for parametrized tests.\n\t    Use :func:`pytypest.case` to create a new one.\n\t    \"\"\"\n\t    args: tuple\n\t    kwargs: dict[str, Any]\n\t    id: str | None = None\n\t    tags: tuple[str, ...] | None = None\n\t    def with_id(self, id: str) -> Case[P]:\n", "        return dataclasses.replace(self, id=id)\n"]}
{"filename": "pytypest/fixtures/_helpers.py", "chunked_list": ["from __future__ import annotations\n\tfrom dataclasses import dataclass\n\tfrom typing import Callable\n\timport pytest\n\t@dataclass(frozen=True)\n\tclass NetworkGuard:\n\t    allowed: frozenset[tuple[str, int]]\n\t    wrapped: Callable[..., list]\n\t    def __call__(\n\t        self,\n", "        host: bytes | str | None,\n\t        port: bytes | str | int | None,\n\t        *args,\n\t        **kwargs,\n\t    ) -> list:\n\t        if (host, port) not in self.allowed:\n\t            msg = f'connection to {host}:{port} is not allowed'  # type: ignore\n\t            pytest.fail(msg)\n\t        return self.wrapped(host, port, *args, **kwargs)\n"]}
{"filename": "pytypest/fixtures/__init__.py", "chunked_list": ["from __future__ import annotations\n\tfrom ._misc import (\n\t    chdir, defer, enter_context, forbid_networking, get_project_root,\n\t    preserve_mapping,\n\t)\n\tfrom ._pytest import (\n\t    capture_logs, capture_std, delattr, get_pytest_fixture, get_request,\n\t    make_temp_dir, monkeypatch, record_warnings, setattr,\n\t)\n\t__all__ = [\n", "    'capture_logs',\n\t    'capture_std',\n\t    'chdir',\n\t    'defer',\n\t    'delattr',\n\t    'enter_context',\n\t    'forbid_networking',\n\t    'get_project_root',\n\t    'get_pytest_fixture',\n\t    'get_request',\n", "    'make_temp_dir',\n\t    'monkeypatch',\n\t    'preserve_mapping',\n\t    'record_warnings',\n\t    'setattr',\n\t]\n"]}
{"filename": "pytypest/fixtures/_misc.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\timport socket\n\timport unittest.mock\n\tfrom pathlib import Path\n\tfrom typing import (\n\t    Callable, ContextManager, Iterator, MutableMapping, Sequence, TypeVar,\n\t)\n\tfrom .._fixture_factory import fixture\n\tfrom .._hub import hub\n", "from ._helpers import NetworkGuard\n\tT = TypeVar('T')\n\t@fixture\n\tdef defer(callback: Callable[[], object]) -> Iterator[None]:\n\t    \"\"\"Execute the given callback when leaving the test function.\n\t    It's a nice way to clean up after a test function without\n\t    creating a fixture or a context manager.\n\t    Similar to :pytest:`pytest.FixtureRequest.addfinalizer`.\n\t    ::\n\t        stream = open('some-file.txt')\n", "        defer(stream.close)\n\t    \"\"\"\n\t    yield\n\t    callback()\n\t@fixture\n\tdef enter_context(manager: ContextManager[T]) -> Iterator[T]:\n\t    \"\"\"\n\t    Enter the context manager, return its result,\n\t    and exit the context when leaving the test function.\n\t    It's a bit imilar to `contextlib.ExitStack` in a sense\n", "    that it helps to keep code indentation low\n\t    when entering multiple context managers.\n\t    ::\n\t        stream = enter_context(open('some_file'))\n\t    \"\"\"\n\t    with manager as value:\n\t        yield value\n\t@fixture\n\tdef forbid_networking(\n\t    *,\n", "    allowed: Sequence[tuple[str, int]] = (),\n\t) -> Iterator[None]:\n\t    \"\"\"Forbid network connections during the test.\n\t    This fixture is a good candidate for :func:`pytypest.autouse`.\n\t    The `allowed` argument accepts a sequence of `(host, port)` pairs\n\t    to which connections should still be allowed.\n\t    ::\n\t        forbid_networking(allowed=[('example.com', 443)])\n\t    \"\"\"\n\t    guard = NetworkGuard(\n", "        allowed=frozenset(allowed),\n\t        wrapped=socket.getaddrinfo,\n\t    )\n\t    socket.getaddrinfo = guard\n\t    yield\n\t    socket.getaddrinfo = guard.wrapped\n\t@fixture\n\tdef chdir(path: Path | str) -> Iterator[None]:\n\t    \"\"\"Change the current working dir to the given path.\n\t    Similar to :pytest:`pytest.MonkeyPatch.chdir`.\n", "    ::\n\t        chdir('/')\n\t    \"\"\"\n\t    old_path = Path.cwd()\n\t    os.chdir(path)\n\t    yield\n\t    os.chdir(old_path)\n\t@fixture\n\tdef preserve_mapping(target: MutableMapping) -> Iterator[None]:\n\t    \"\"\"Restore the current state of the mapping after leaving the test.\n", "    After calling the fixture, you can safely modify the given mapping,\n\t    and these changes will be reverted before the next test starts.\n\t    It's not a deep copy, though. If you modify a list inside of the mapping,\n\t    that modification will escape the test.\n\t    ::\n\t        import sys\n\t        preserve_mapping(sys.modules)\n\t        sys.modules['requests'] = Mock()\n\t    \"\"\"\n\t    with unittest.mock.patch.dict(target):\n", "        yield\n\tdef get_project_root() -> Path:\n\t    \"\"\"Get the path to the root directory of the project.\n\t    ::\n\t        root = get_project_root()\n\t        assert (root / 'pyproject.toml').exists()\n\t    https://docs.pytest.org/en/7.1.x/reference/customize.html#finding-the-rootdir\n\t    \"\"\"\n\t    if hub.request is None:\n\t        raise RuntimeError('pytest plugin is not active')\n", "    return hub.request.session.config.rootpath\n"]}
{"filename": "pytypest/fixtures/_pytest.py", "chunked_list": ["from __future__ import annotations\n\tfrom pathlib import Path\n\tfrom typing import Any, Iterator\n\timport pytest\n\tfrom .._fixture_factory import fixture\n\tfrom .._hub import hub\n\t@fixture\n\tdef get_request() -> pytest.FixtureRequest:\n\t    \"\"\"Get meta information about the currently running test.\n\t    A wrapper around :pytest:`request` pytest fixture.\n", "    ::\n\t        request = get_request()\n\t        verbosity = request.config.getoption(\"verbose\")\n\t        if verbosity > 0:\n\t            ...\n\t    \"\"\"\n\t    if hub.request is None:\n\t        raise RuntimeError('pytest plugin is not active')\n\t    return hub.request\n\t@fixture\n", "def get_pytest_fixture(name: str) -> Any:\n\t    \"\"\"Get a pytest fixture by its name.\n\t    A wrapper around :pytest:`pytest.FixtureRequest.getfixturevalue`.\n\t    This is useful for using fixtures from third-party pytest plugins.\n\t    All built-in pytest fixtures already have a convenient wrapper in pytypest.\n\t    For example, get ``event_loop`` fixture from pytest-asyncio::\n\t        from asyncio import AbstractEventLoop\n\t        loop: AbstractEventLoop = get_pytest_fixture('event_loop')\n\t    \"\"\"\n\t    request = get_request()\n", "    return request.getfixturevalue(name)\n\t@fixture\n\tdef capture_std(*, binary: bool = False, fd: bool = False) -> pytest.CaptureFixture:\n\t    \"\"\"Capture stdout and stderr.\n\t    A wrapper around :pytest:`capsys`, :pytest:`capfd`, :pytest:`capsysbinary`,\n\t    and :pytest:`capfdbinary` pytest fixtures.\n\t    ::\n\t        cap = capture_std()\n\t        print('hello')\n\t        captured = cap.readouterr()\n", "        assert captured.out.rstrip() == 'hello'\n\t    \"\"\"\n\t    root = 'fd' if fd else 'sys'\n\t    suffix = 'binary' if binary else ''\n\t    return get_pytest_fixture(f'cap{root}{suffix}')\n\t@fixture\n\tdef capture_logs() -> pytest.LogCaptureFixture:\n\t    \"\"\"Capture all log records.\n\t    A wrapper around :pytest:`caplog` pytest fixture.\n\t    ::\n", "        import logging\n\t        cap = capture_logs()\n\t        logging.warning('oh hi mark')\n\t        record = cap.records[-1]\n\t        assert record.message == 'oh hi mark'\n\t    \"\"\"\n\t    return get_pytest_fixture('caplog')\n\t@fixture\n\tdef record_warnings() -> pytest.WarningsRecorder:\n\t    \"\"\"Record all warnings (emitted using ``warnings`` module).\n", "    A wrapper around :pytest:`recwarn` pytest fixture.\n\t    ::\n\t        import warnings\n\t        rec = fixtures.record_warnings()\n\t        warnings.warn('oh hi mark', UserWarning)\n\t        w = rec.pop(UserWarning)\n\t        assert str(w.message) == 'oh hi mark'\n\t    \"\"\"\n\t    return get_pytest_fixture('recwarn')\n\t@fixture\n", "def make_temp_dir(basename: str | None = None, numbered: bool = True) -> Path:\n\t    \"\"\"Create a temporary directory.\n\t    A wrapper around :pytest:`tmp_path` and :pytest:`tmp_path_factory`\n\t    pytest fixtures.\n\t    Args:\n\t        basename: if specified, the created directory will have this name.\n\t        numbered: if True (default), ensure the directory is unique\n\t            by adding a numbered suffix greater than any existing one.\n\t    ::\n\t        dir_path = fixtures.make_temp_dir()\n", "        file_path = dir_path / 'example.py'\n\t        file_path.write_text('1 + 2')\n\t        ...\n\t        content = file_path.read_text()\n\t        assert content == '1 + 2'\n\t    \"\"\"\n\t    if basename is not None:\n\t        factory: pytest.TempPathFactory = get_pytest_fixture('tmp_path_factory')\n\t        return factory.mktemp(basename=basename, numbered=numbered)\n\t    return get_pytest_fixture('tmp_path')\n", "@fixture\n\tdef monkeypatch() -> Iterator[pytest.MonkeyPatch]:\n\t    \"\"\"Patch attributes of objects for the duration of test.\n\t    A wrapper around :pytest:`monkeypatch` pytest fixture.\n\t    Usually, you don't need to use this fixture directly. The preferred way to\n\t    patch things is using :func:`pytypest.fixtures.setattr`,\n\t    :func:`pytypest.fixtures.delattr`, and :func:`pytypest.fixtures.preserve_mapping`.\n\t    \"\"\"\n\t    patcher = pytest.MonkeyPatch()\n\t    yield patcher\n", "    patcher.undo()\n\t@fixture\n\tdef setattr(\n\t    target: object | str,\n\t    name: str,\n\t    value: object,\n\t    *,\n\t    must_exist: bool = True,\n\t) -> Iterator[None]:\n\t    \"\"\"Patch an attribute for the duration of test.\n", "    A wrapper around :pytest:`pytest.MonkeyPatch.setattr`.\n\t    The target can be either the object to patch or the full import path to the object.\n\t    The target can be any object, including modules, classes, methods, and functions.\n\t    ::\n\t        from unittest.mock import Mock\n\t        mock = Mock()\n\t        setattr('logging', 'info', mock)\n\t    \"\"\"\n\t    patcher = pytest.MonkeyPatch()\n\t    if isinstance(target, str):\n", "        patcher.setattr(f'{target}.{name}', value, raising=must_exist)\n\t    else:\n\t        patcher.setattr(target, name, value, raising=must_exist)\n\t    yield\n\t    patcher.undo()\n\t@fixture\n\tdef delattr(\n\t    target: object | str,\n\t    name: str,\n\t    *,\n", "    must_exist: bool = True,\n\t) -> Iterator[None]:\n\t    \"\"\"Delete attribute of an object for the duration of test.\n\t    A wrapper around :pytest:`pytest.MonkeyPatch.delattr`.\n\t    The target can be either the object to patch or the full import path to the object.\n\t    The target can be any object, including modules, classes, methods, and functions.\n\t    ::\n\t        delattr(logging, 'info')\n\t    \"\"\"\n\t    patcher = pytest.MonkeyPatch()\n", "    if isinstance(target, str):\n\t        patcher.delattr(f'{target}.{name}', raising=must_exist)\n\t    else:\n\t        patcher.delattr(target, name, raising=must_exist)\n\t    yield\n\t    patcher.undo()\n"]}
{"filename": "pytypest/experimental/__init__.py", "chunked_list": ["from ._attr import attr\n\tfrom ._patcher import patcher\n\t__all__ = ['attr', 'patcher']\n"]}
{"filename": "pytypest/experimental/_patcher.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Any, Iterator, TypeVar\n\timport pytest\n\tfrom .._fixture_factory import fixture\n\tK = TypeVar('K')\n\tV = TypeVar('V')\n\tclass AttrPatcher:\n\t    def __init__(\n\t        self,\n\t        patcher: pytest.MonkeyPatch,\n", "        target: object | str,\n\t    ) -> None:\n\t        self.__patcher = patcher\n\t        self.__target = target\n\t    def __setattr__(self, name: str, value: object) -> None:\n\t        if name.startswith('_AttrPatcher__'):\n\t            return super().__setattr__(name, value)\n\t        if isinstance(self.__target, str):\n\t            self.__patcher.setattr(f'{self.__target}.{name}', value)\n\t        else:\n", "            self.__patcher.setattr(self.__target, name, value)\n\t    def __delattr__(self, name: str) -> None:\n\t        self.__patcher.delattr(self.__target, name)\n\t@fixture\n\tdef patcher(target: object | str) -> Iterator[Any]:\n\t    \"\"\"A fixture to patch and delete attributes of the given object.\n\t    Patch an attribute::\n\t        patcher(logging).info = Mock()\n\t    Delete an attribute::\n\t        del patcher(logging).info\n", "    The object can be also specified as a full import path string::\n\t        patcher('logging').info = Mock()\n\t    All changes to the object will be reverted when leaving the context.\n\t    \"\"\"\n\t    monkey_patcher = pytest.MonkeyPatch()\n\t    yield AttrPatcher(monkey_patcher, target)\n\t    monkey_patcher.undo()\n"]}
{"filename": "pytypest/experimental/_attr.py", "chunked_list": ["from __future__ import annotations\n\tfrom dataclasses import dataclass\n\tfrom typing import TYPE_CHECKING, Any, Generic, TypeVar, overload\n\tfrom typing_extensions import ParamSpec\n\tif TYPE_CHECKING:\n\t    from .._fixture import Fixture\n\tP = ParamSpec('P')\n\tR = TypeVar('R')\n\tdef attr(fixture: Fixture[P, R], *args: P.args, **kwargs: P.kwargs) -> Attr[P, R]:\n\t    \"\"\"A wrapper to use a fixture as a container attribute.\n", "    A fixture wrapped with ``attr`` can be accessed as a class attribute\n\t    without explicitly calling it. It's equivalent to defining a ``@property``\n\t    that calls the fixture inside and returns its result but shorter.\n\t    ::\n\t        class Fixtures:\n\t            user = attr(get_user)\n\t        def test_user():\n\t            f = Fixtures()\n\t            assert f.user.name == 'mark'\n\t    \"\"\"\n", "    return Attr(fixture, args, kwargs)\n\t@dataclass(frozen=True)\n\tclass Attr(Generic[P, R]):\n\t    fixture: Fixture[P, R]\n\t    args: tuple\n\t    kwargs: dict[str, Any]\n\t    @overload\n\t    def __get__(self, obj: None, objtype: type) -> Attr[P, R]:\n\t        pass\n\t    @overload\n", "    def __get__(self, obj: object, objtype: type) -> R:\n\t        pass\n\t    def __get__(self, obj: object | None, objtype: type) -> Attr[P, R] | R:\n\t        if obj is None:\n\t            return self\n\t        return self.fixture(*self.args, **self.kwargs)\n"]}
{"filename": "tests/test_parametrize.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\timport pytest\n\tfrom pytypest import case, parametrize\n\tif TYPE_CHECKING:\n\t    from _pytest.mark.structures import Mark\n\tdef test_parametrize() -> None:\n\t    def inner(a: int, b: int):\n\t        pass\n\t    wrapped = parametrize(\n", "        inner,\n\t        case(3, 4),\n\t        case(5, b=6),\n\t        case(a=7, b=8),\n\t        case(b=10, a=9),\n\t        case.id('one')(11, 12),\n\t        case.tags('two', 'three')(13, 14),\n\t        four=case(15, 16),\n\t    )\n\t    mark: Mark\n", "    (mark,) = wrapped.pytestmark  # type: ignore[attr-defined]\n\t    assert mark.name == 'parametrize'\n\t    assert mark.args == (\n\t        ['a', 'b'],\n\t        [\n\t            [3, 4], [5, 6], [7, 8], [9, 10],\n\t            pytest.param(11, 12, id='one'),\n\t            pytest.param(13, 14, marks=(pytest.mark.two, pytest.mark.three)),\n\t            pytest.param(15, 16, id='four'),\n\t        ],\n", "    )\n\tdef test_preserve_marks() -> None:\n\t    @pytest.mark.two\n\t    def inner(a: int, b: int):\n\t        pass\n\t    wrapped = parametrize(inner, case(3, 4))\n\t    wrapped = pytest.mark.three(wrapped)\n\t    marks = wrapped.pytestmark  # type: ignore[attr-defined]\n\t    assert len(marks) == 3\n"]}
{"filename": "tests/test_fixture.py", "chunked_list": ["from typing import Callable\n\timport pytest\n\tfrom pytypest import Scope, fixture\n\tdef test_setup_return() -> None:\n\t    log = []\n\t    @fixture\n\t    def fixt():\n\t        log.append(42)\n\t        return 13\n\t    assert fixt.setup() == 13\n", "    assert log == [42]\n\tdef test_setup_yield() -> None:\n\t    log = []\n\t    @fixture\n\t    def fixt():\n\t        log.append(42)\n\t        yield 13\n\t    assert fixt.setup() == 13\n\t    assert log == [42]\n\tdef test_teardown_return() -> None:\n", "    @fixture\n\t    def fixt():\n\t        return 13\n\t    fixt.teardown()\n\t    assert fixt.setup() == 13\n\t    fixt.teardown()\n\tdef test_teardown_yield() -> None:\n\t    log = []\n\t    @fixture\n\t    def fixt():\n", "        yield 13\n\t        log.append(42)\n\t    fixt.teardown()\n\t    assert fixt.setup() == 13\n\t    fixt.teardown()\n\t    assert log == [42]\n\tdef test_teardown_on_leaving_scope(isolated: None, scoped: Callable) -> None:\n\t    log = []\n\t    @fixture(scope=Scope.CLASS)\n\t    def fixt():\n", "        log.append('s')\n\t        yield 62\n\t        log.append('t')\n\t    with scoped('class'):\n\t        with scoped('function'):\n\t            assert log == []\n\t            for _ in range(4):\n\t                assert fixt() == 62\n\t                assert log == ['s']\n\t        assert log == ['s']\n", "    assert log == ['s', 't']\n\tdef test_disallow_double_yield(isolated, scoped):\n\t    @fixture\n\t    def fixt():\n\t        yield\n\t        yield\n\t    msg = 'fixture must have at most one yield'\n\t    with pytest.raises(RuntimeError, match=msg):\n\t        with scoped('function'):\n\t            fixt()\n", "def test_plugin_not_active():\n\t    @fixture\n\t    def fixt():\n\t        yield\n\t    msg = 'pytest plugin is not activated'\n\t    with pytest.raises(RuntimeError, match=msg):\n\t        fixt()\n\tdef test_context_manager(isolated, scoped):\n\t    log = []\n\t    @fixture\n", "    def fixt():\n\t        log.append('s')\n\t        yield 67\n\t        log.append('t')\n\t    with scoped('function'):\n\t        assert log == []\n\t        with fixt as val:\n\t            assert log == ['s']\n\t            assert val == 67\n\t        assert log == ['s', 't']\n", "    assert log == ['s', 't']\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_autouse.py", "chunked_list": ["import pytest\n\tfrom pytypest import Scope, autouse, fixture\n\tdef test_double_autouse(isolated) -> None:\n\t    @fixture\n\t    def fixt():\n\t        yield\n\t    autouse(fixt)\n\t    msg = 'autouse can be called only once'\n\t    with pytest.raises(RuntimeError, match=msg):\n\t        autouse(fixt)\n", "def test_autouse(isolated, scoped) -> None:\n\t    log = []\n\t    @fixture(scope=Scope.CLASS)\n\t    def fixt():\n\t        log.append('s')\n\t        yield\n\t        log.append('t')\n\t    autouse(fixt)\n\t    assert log == []\n\t    with scoped('class'):\n", "        assert log == ['s']\n\t        with scoped('function'):\n\t            assert log == ['s']\n\t        assert log == ['s']\n\t    assert log == ['s', 't']\n"]}
{"filename": "tests/test_experimental.py", "chunked_list": ["from __future__ import annotations\n\tfrom pytypest import experimental, fixture\n\tclass Global:\n\t    attr: int = 42\n\tdef test_setattr(isolated, scoped):\n\t    class A:\n\t        a = 13\n\t    with scoped('function'):\n\t        p = experimental.patcher(A)\n\t        p.a = 54\n", "        assert A.a == 54\n\t    assert A.a == 13\n\tdef test_setattr__str_target(isolated, scoped):\n\t    target = f'{Global.__module__}.{Global.__name__}'\n\t    with scoped('function'):\n\t        p = experimental.patcher(target)\n\t        p.attr = 99\n\t        assert Global.attr == 99\n\t    assert Global.attr == 42\n\tdef test_delattr(isolated, scoped):\n", "    class A:\n\t        a = 13\n\t    with scoped('function'):\n\t        p = experimental.patcher(A)\n\t        del p.a\n\t        assert not hasattr(A, 'a')\n\t    assert A.a == 13\n\tdef test_attr(isolated, scoped):\n\t    log = []\n\t    @fixture\n", "    def fixt():\n\t        log.append('s')\n\t        yield 14\n\t        log.append('t')\n\t    class Container:\n\t        val = experimental.attr(fixt)\n\t    c = Container()\n\t    assert Container.val.fixture is fixt\n\t    with scoped('function'):\n\t        assert log == []\n", "        for _ in range(4):\n\t            assert c.val == 14\n\t            assert log == ['s']\n\t    assert log == ['s', 't']\n"]}
{"filename": "tests/test_fixtrues.py", "chunked_list": ["from __future__ import annotations\n\tfrom contextlib import contextmanager\n\tfrom pathlib import Path\n\timport pytest\n\timport requests\n\tfrom pytypest import fixtures\n\tclass Global:\n\t    attr: int = 42\n\tdef test_get_request(isolated, scoped) -> None:\n\t    with scoped('function'):\n", "        req = fixtures.get_request()\n\t        assert req.function is test_get_request\n\t        assert req.scope == 'function'\n\tdef test_get_request__not_active() -> None:\n\t    msg = 'pytest plugin is not active'\n\t    with pytest.raises(RuntimeError, match=msg):\n\t        fixtures.get_request()\n\tdef test_make_temp_dir(isolated, scoped) -> None:\n\t    with scoped('function'):\n\t        path = fixtures.make_temp_dir()\n", "        assert path.is_dir()\n\tdef test_make_temp_dir__basename(isolated, scoped) -> None:\n\t    with scoped('function'):\n\t        path = fixtures.make_temp_dir('hello', numbered=False)\n\t        assert path.is_dir()\n\t        assert path.name == 'hello'\n\tdef test_make_temp_dir__numbered(isolated, scoped) -> None:\n\t    with scoped('function'):\n\t        path = fixtures.make_temp_dir('hello', numbered=True)\n\t        assert path.is_dir()\n", "        assert path.name == 'hello0'\n\tdef test_chdir(isolated, scoped) -> None:\n\t    dir1 = Path.cwd()\n\t    with scoped('function'):\n\t        fixtures.chdir(dir1.parent)\n\t        dir2 = Path.cwd()\n\t        assert dir2 == dir1.parent\n\tdef test_get_pytest_fixture(isolated, scoped, tmp_path) -> None:\n\t    with scoped('function'):\n\t        path = fixtures.get_pytest_fixture('tmp_path')\n", "        assert path is tmp_path\n\t@pytest.mark.parametrize('given, expected', [\n\t    (fixtures.capture_std, 'capsys'),\n\t    (lambda: fixtures.capture_std(binary=True), 'capsysbinary'),\n\t    (lambda: fixtures.capture_std(fd=True), 'capfd'),\n\t    (lambda: fixtures.capture_std(binary=True, fd=True), 'capfdbinary'),\n\t    (fixtures.capture_logs, 'caplog'),\n\t    (fixtures.record_warnings, 'recwarn'),\n\t])\n\tdef test_proxying(isolated, scoped, given, expected, request) -> None:\n", "    with scoped('function'):\n\t        fixt1 = request.getfixturevalue(expected)\n\t        fixt2 = fixtures.get_pytest_fixture(expected)\n\t        fixt3 = given()\n\t        assert fixt1 is fixt2\n\t        assert fixt2 is fixt3\n\tdef test_defer(isolated, scoped) -> None:\n\t    log = []\n\t    with scoped('function'):\n\t        fixtures.defer(lambda: log.append(1))\n", "        assert log == []\n\t    assert log == [1]\n\tdef test_defer__no_scope(isolated, scoped) -> None:\n\t    msg = 'cannot find ScopeManager for `function` scope'\n\t    with pytest.raises(LookupError, match=msg):\n\t        fixtures.defer(lambda: None)\n\t    with scoped('class'):\n\t        with pytest.raises(LookupError, match=msg):\n\t            fixtures.defer(lambda: None)\n\tdef test_enter_context(isolated, scoped) -> None:\n", "    log = []\n\t    @contextmanager\n\t    def man():\n\t        log.append('enter')\n\t        yield 17\n\t        log.append('exit')\n\t    with scoped('function'):\n\t        res = fixtures.enter_context(man())\n\t        assert log == ['enter']\n\t        assert res == 17\n", "    assert log == ['enter', 'exit']\n\tdef test_forbid_networking__bad_host(isolated, scoped) -> None:\n\t    with scoped('function'):\n\t        fixtures.forbid_networking()\n\t        msg = 'connection to example.com:443 is not allowed'\n\t        with pytest.raises(BaseException, match=msg):\n\t            requests.get('https://example.com/')\n\tdef test_forbid_networking__bad_port(isolated, scoped) -> None:\n\t    with scoped('function'):\n\t        fixtures.forbid_networking(allowed=[('example.com', 80)])\n", "        msg = 'connection to example.com:443 is not allowed'\n\t        with pytest.raises(BaseException, match=msg):\n\t            requests.get('https://example.com/')\n\tdef test_forbid_networking__allowed_host_port(isolated, scoped) -> None:\n\t    with scoped('function'):\n\t        fixtures.forbid_networking(\n\t            allowed=[('example.com', 443)],\n\t        )\n\t        requests.get('https://example.com/')\n\tdef test_monkeypatch(isolated, scoped):\n", "    class A:\n\t        a = 13\n\t    with scoped('function'):\n\t        p = fixtures.monkeypatch()\n\t        p.setattr(A, 'a', 54)\n\t        assert A.a == 54\n\tdef test_setattr(isolated, scoped):\n\t    class A:\n\t        a = 13\n\t    with scoped('function'):\n", "        fixtures.setattr(A, 'a', 54)\n\t        assert A.a == 54\n\t    assert A.a == 13\n\tdef test_setattr__str_target(isolated, scoped):\n\t    target = f'{Global.__module__}.{Global.__name__}'\n\t    with scoped('function'):\n\t        fixtures.setattr(target, 'attr', 99)\n\t        assert Global.attr == 99\n\t    assert Global.attr == 42\n\tdef test_delattr(isolated, scoped):\n", "    class A:\n\t        a = 13\n\t    with scoped('function'):\n\t        fixtures.delattr(A, 'a')\n\t        assert not hasattr(A, 'a')\n\t    assert A.a == 13\n\tdef test_delattr__str_target(isolated, scoped):\n\t    target = f'{Global.__module__}.{Global.__name__}'\n\t    with scoped('function'):\n\t        fixtures.delattr(target, 'attr')\n", "        assert not hasattr(Global, 'attr')\n\t    assert Global.attr == 42\n\tdef test_preserve_mapping(isolated, scoped):\n\t    d = {1: 2, 3: 4, 5: 6}\n\t    with scoped('function'):\n\t        fixtures.preserve_mapping(d)\n\t        d[1] = 7\n\t        del d[5]\n\t        assert d == {1: 7, 3: 4}\n\t    assert d == {1: 2, 3: 4, 5: 6}\n", "def test_get_project_root(isolated, scoped):\n\t    with scoped('function'):\n\t        root = fixtures.get_project_root()\n\t        assert (root / 'pyproject.toml').is_file()\n\t        assert (root / 'pytypest').is_dir()\n\tdef test_get_project_root__not_active() -> None:\n\t    msg = 'pytest plugin is not active'\n\t    with pytest.raises(RuntimeError, match=msg):\n\t        fixtures.get_project_root()\n\tdef test_capture_std(isolated, scoped):\n", "    with scoped('function'):\n\t        cap = fixtures.capture_std()\n\t        print('hello')\n\t        captured = cap.readouterr()\n\t        assert captured.out == 'hello\\n'\n\tdef test_capture_logs(isolated, scoped):\n\t    with scoped('function'):\n\t        import logging\n\t        cap = fixtures.capture_logs()\n\t        logging.warning('oh hi mark')\n", "        record = cap.records[-1]\n\t        assert record.message == 'oh hi mark'\n\tdef test_record_warnings(isolated, scoped):\n\t    with scoped('function'):\n\t        import warnings\n\t        rec = fixtures.record_warnings()\n\t        warnings.warn('oh hi mark', UserWarning, stacklevel=1)\n\t        w = rec.pop(UserWarning)\n\t        assert str(w.message) == 'oh hi mark'\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["from __future__ import annotations\n\tfrom contextlib import contextmanager\n\tfrom typing import Callable, Iterator\n\timport pytest\n\tfrom pytypest import _plugin\n\tfrom pytypest._hub import hub\n\t@pytest.fixture\n\tdef isolated(request: pytest.FixtureRequest) -> Iterator[None]:\n\t    _plugin.pytest_sessionstart(request.session)\n\t    yield\n", "    hub.reset()\n\t    delattr(request.session, _plugin.SESSION_ATTR)\n\t@pytest.fixture\n\tdef scoped(request: pytest.FixtureRequest) -> Iterator[Callable]:\n\t    @contextmanager\n\t    def wrapper(scope: str):\n\t        from _pytest.scope import Scope\n\t        old_scope = request._scope\n\t        request._scope = Scope(scope)\n\t        it = _plugin._manage_scope(request)\n", "        next(it)\n\t        try:\n\t            yield\n\t        finally:\n\t            try:\n\t                next(it)\n\t            except StopIteration:\n\t                pass\n\t            request._scope = old_scope\n\t    yield wrapper\n"]}
{"filename": "integration/test_args.py", "chunked_list": ["\"\"\"Fixtures with arguments aren't cached.\n\t\"\"\"\n\tfrom typing import Iterator\n\tfrom pytypest import fixture\n\t_setup = []\n\t@fixture\n\tdef fixt(a, b) -> Iterator[int]:\n\t    _setup.append(a)\n\t    return a + b\n\tdef test_simple1():\n", "    n = fixt(6, b=7)\n\t    assert n == 13\n\t    assert _setup == [6]\n\tdef test_simple2():\n\t    n = fixt(a=3, b=4)\n\t    assert n == 7\n\t    assert _setup == [6, 3]\n\tdef test_double():\n\t    n1 = fixt(a=3, b=4)\n\t    assert n1 == 7\n", "    assert _setup == [6, 3, 3]\n\t    n1 = fixt(a=4, b=5)\n\t    assert n1 == 9\n\t    assert _setup == [6, 3, 3, 4]\n\tdef test_after():\n\t    assert _setup == [6, 3, 3, 4]\n"]}
{"filename": "integration/test_teardown.py", "chunked_list": ["\"\"\"The basic test for fixtures with teardown.\n\t\"\"\"\n\tfrom typing import Iterator\n\tfrom pytypest import fixture\n\t_setup = []\n\t_teardown = []\n\t@fixture\n\tdef fixt() -> Iterator[int]:\n\t    _setup.append(0)\n\t    yield 13\n", "    _teardown.append(0)\n\tdef test_simple():\n\t    n = fixt()\n\t    assert n == 13\n\t    assert _setup == [0]\n\t    assert _teardown == []\n\tdef test_after():\n\t    assert _setup == [0]\n\t    assert _teardown == [0]\n"]}
{"filename": "integration/test_simple.py", "chunked_list": ["\"\"\"The most basic test for the most basic fixture.\n\t\"\"\"\n\tfrom pytypest import fixture\n\t@fixture\n\tdef fixt() -> int:\n\t    return 13\n\tdef test_simple():\n\t    n = fixt()\n\t    assert n == 13\n"]}
{"filename": "integration/test_parametrize.py", "chunked_list": ["\"\"\"The basic test for `parametrize` and `case`.\n\t\"\"\"\n\tfrom pytypest import case, parametrize\n\tdef _test_double(x: int, exp: int):\n\t    assert x * 2 == exp\n\ttest_double = parametrize(\n\t    _test_double,\n\t    case(3, 6),\n\t    case(3, exp=6),\n\t    case(x=3, exp=6),\n", "    case.id('pos-only')(3, 6),\n\t)\n\tdef _test_divide(x: int, y: int = 1, *, exp: int):\n\t    assert x // y == exp\n\ttest_divide = parametrize(\n\t    _test_divide,\n\t    case(8, 2, exp=4),\n\t    case(3, exp=3),\n\t)\n"]}
{"filename": "integration/test_attr.py", "chunked_list": ["\"\"\"Fixtures can be combined into containers.\n\tFixtures in a container instance must be available without calling them.\n\t\"\"\"\n\tfrom pytypest import fixture\n\tfrom pytypest.experimental import attr\n\t_setup = []\n\t@fixture\n\tdef fixt() -> int:\n\t    _setup.append(0)\n\t    return 13\n", "class Container:\n\t    val = attr(fixt)\n\tdef test_simple():\n\t    assert _setup == []\n\t    assert Container.val.fixture is fixt\n\t    assert _setup == []\n\t    c = Container()\n\t    assert _setup == []\n\t    assert c.val == 13\n\t    assert _setup == [0]\n"]}
{"filename": "integration/test_scope_class.py", "chunked_list": ["\"\"\"Teardown for class-scoped fixtures is executed after leaving the class scope.\n\t\"\"\"\n\tfrom typing import Iterator\n\tfrom pytypest import Scope, fixture\n\t_setup = []\n\t_teardown = []\n\t@fixture(scope=Scope.CLASS)\n\tdef fixt() -> Iterator[int]:\n\t    _setup.append(0)\n\t    yield 13\n", "    _teardown.append(0)\n\tclass TestClass:\n\t    def test_simple_1(self):\n\t        n = fixt()\n\t        assert n == 13\n\t        assert _setup == [0]\n\t        assert _teardown == []\n\t    def test_simple_2(self):\n\t        n = fixt()\n\t        assert n == 13\n", "        assert _setup == [0]\n\t        assert _teardown == []\n\t    def test_after_test(self):\n\t        assert _setup == [0]\n\t        assert _teardown == []\n\tdef test_after_class():\n\t    assert _setup == [0]\n\t    assert _teardown == [0]\n"]}
{"filename": "integration/__init__.py", "chunked_list": []}
{"filename": "integration/test_args_n_teardown.py", "chunked_list": ["\"\"\"Teardown must be executed for fixtures with arguments.\n\t\"\"\"\n\tfrom typing import Iterator\n\tfrom pytypest import fixture\n\t_setup = []\n\t_teardown = []\n\t@fixture\n\tdef fixt(a, b) -> Iterator[int]:\n\t    _setup.append(a)\n\t    yield a + b\n", "    _teardown.append(a)\n\tdef test_simple1():\n\t    n = fixt(6, b=7)\n\t    assert n == 13\n\t    assert _setup == [6]\n\t    assert _teardown == []\n\tdef test_simple2():\n\t    n1 = fixt(a=3, b=4)\n\t    assert n1 == 7\n\t    n2 = fixt(a=5, b=4)\n", "    assert n2 == 9\n\t    assert _setup == [6, 3, 5]\n\t    assert _teardown == [6]\n\tdef test_after():\n\t    assert _setup == [6, 3, 5]\n\t    assert _teardown == [6, 3, 5]\n"]}
{"filename": "integration/test_unwrap.py", "chunked_list": ["\"\"\"\n\tTeardown for fixtures must be executed in the reverse order to how they are called.\n\tSo, the first called fixture is teared down the last.\n\t\"\"\"\n\tfrom __future__ import annotations\n\tfrom typing import Iterator\n\tfrom pytypest import fixture\n\t_setup = []\n\t_teardown = []\n\t@fixture\n", "def a() -> Iterator[None]:\n\t    _setup.append('a')\n\t    yield\n\t    _teardown.append('a')\n\t@fixture\n\tdef b() -> Iterator[None]:\n\t    _setup.append('b')\n\t    yield\n\t    _teardown.append('b')\n\t@fixture\n", "def c() -> Iterator[None]:\n\t    a()\n\t    _setup.append('c')\n\t    yield\n\t    _teardown.append('c')\n\tdef test_simple() -> None:\n\t    c()\n\t    b()\n\t    a()\n\t    assert _setup == ['a', 'c', 'b']\n", "def test_after() -> None:\n\t    assert _teardown == ['b', 'c', 'a']\n"]}
{"filename": "docs/conf.py", "chunked_list": ["project = 'pytypest'\n\tcopyright = '2023, @orsinium'\n\tauthor = '@orsinium'\n\ttemplates_path = ['_templates']\n\thtml_theme = 'alabaster'\n\tautodoc_typehints_format = 'short'\n\tautodoc_preserve_defaults = True\n\tautodoc_member_order = 'bysource'\n\textensions = [\n\t    'sphinx.ext.autodoc',\n", "    'sphinx.ext.napoleon',\n\t    'sphinx.ext.autosummary',\n\t    'sphinx.ext.extlinks',\n\t    'myst_parser',\n\t]\n\textlinks = {\n\t    'pytest': ('https://docs.pytest.org/en/latest/reference/reference.html#%s', '%s'),\n\t}\n"]}
