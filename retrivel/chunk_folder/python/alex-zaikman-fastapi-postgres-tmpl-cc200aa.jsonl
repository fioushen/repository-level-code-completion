{"filename": "tests/mock_db.py", "chunked_list": ["import os\n\timport psycopg\n\timport testing.postgresql\n\tfrom singleton_meta import SingletonMeta\n\tclass _Postgresql(metaclass=SingletonMeta):\n\t    def __init__(self):\n\t        self.__postgresql = self._postgres_factory()\n\t    @staticmethod\n\t    def _init_db(db):\n\t        os.environ.setdefault('DB_NULL_POOL', 'true')\n", "        os.environ.setdefault('DB_ECHO', 'true')\n\t        conn = psycopg.connect(db.url())\n\t        cur = conn.cursor()\n\t        with open(os.path.join(os.path.dirname(__file__), '../db/init.sql'), 'r', encoding=\"UTF-8\") as fp:\n\t            _ = [(cur.execute(statement.strip())) for statement in fp.read().split(';') if statement.strip()]\n\t        conn.commit()\n\t        cur.close()\n\t        conn.close()\n\t    def _postgres_factory(self):\n\t        \"\"\"\n", "        Creates an initial fake database for use in unit tests.\n\t        \"\"\"\n\t        postgres_factory = testing.postgresql.PostgresqlFactory(cache_initialized_db=True,\n\t                                                                on_initialized=self._init_db)\n\t        return postgres_factory\n\t    def __call__(self, *args, **kwargs):\n\t        return self.__postgresql()\n\t    def clear_cache(self):\n\t        self.__postgresql.clear_cache()\n\tPostgresql = _Postgresql()\n"]}
{"filename": "tests/base.py", "chunked_list": ["import unittest\n\tfrom database import DataBase\n\tfrom tests.mock_db import Postgresql\n\tclass TestBase(unittest.IsolatedAsyncioTestCase):\n\t    @classmethod\n\t    def setUpClass(cls) -> None:\n\t        cls.postgresql = Postgresql()\n\t    async def asyncSetUp(self):\n\t        self.db = DataBase(self.postgresql.url().replace('postgresql', 'postgresql+asyncpg'))  # pylint: disable=attribute-defined-outside-init\n\t    @classmethod\n", "    def tearDownClass(cls) -> None:\n\t        Postgresql.clear_cache()\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["import sys\n\tsys.path.append(\"src\")\n"]}
{"filename": "tests/test_schema.py", "chunked_list": ["from schema.users import users\n\tfrom tests.base import TestBase\n\tclass TestSchema(TestBase):\n\t    async def test_select_users(self):\n\t        async with self.db.async_session.begin() as session:\n\t            res = await session.execute(users.select())\n\t            self.assertEqual(len(res.all()), 2)\n"]}
{"filename": "tests/api_base.py", "chunked_list": ["from fastapi.openapi.models import Response\n\tfrom fastapi.testclient import TestClient\n\tfrom tests.base import TestBase\n\tclass AuthHeader:\n\t    def __init__(self, response: Response):\n\t        self._tokens = response.json()\n\t        self.status_code = response.status_code\n\t    @property\n\t    def auth(self):\n\t        return {\"Authorization\": f\"Bearer {self._tokens.get('access_token')}\"}\n", "    @property\n\t    def refresh(self):\n\t        return {\"Authorization\": f\"Bearer {self._tokens.get('refresh_token')}\"}\n\tclass TestAPIBase(TestBase):\n\t    async def asyncSetUp(self):\n\t        await super().asyncSetUp()\n\t        from api import app  # pylint: disable=import-outside-toplevel\n\t        self.client = TestClient(app)  # pylint: disable=attribute-defined-outside-init\n\t    async def asyncTearDown(self) -> None:\n\t        self.client.close()\n", "        await super().asyncTearDown()\n\t    def login(self, email, password) -> AuthHeader:\n\t        response = self.client.post(\"/token\", data={\"username\": email, \"password\": password})\n\t        return AuthHeader(response)\n"]}
{"filename": "tests/test_user_ep.py", "chunked_list": ["from fastapi import status\n\tfrom tests.api_base import TestAPIBase\n\tclass TestUserEP(TestAPIBase):\n\t    async def test_crud_users(self):\n\t        headers = self.login('admin@gmail.com', 'admin123')\n\t        response = self.client.post(\n\t            url='/user',\n\t            headers=headers.auth,\n\t            json={\n\t                \"email\": \"test@test.com\",\n", "                \"scopes\": [\n\t                    \"ADMIN\"\n\t                ],\n\t                \"password\": \"test123\"\n\t            }\n\t        )\n\t        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n\t        res = self.login('test@test.com', 'test123')\n\t        self.assertEqual(res.status_code, status.HTTP_200_OK)\n"]}
{"filename": "tests/test_auth.py", "chunked_list": ["# import datetime\n\t# import datetime as dt\n\t# import os\n\t# import time\n\t# import time_machine\n\tfrom fastapi import status\n\tfrom tests.api_base import TestAPIBase, AuthHeader\n\tclass TestAuth(TestAPIBase):\n\t    async def asyncSetUp(self):\n\t        await super().asyncSetUp()\n", "        self.headers = self.login('admin@gmail.com', 'admin123')  # pylint: disable=attribute-defined-outside-init\n\t    async def test_auth(self):\n\t        response = self.client.get(url='/user', headers=self.headers.auth)\n\t        self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')\n\t        response = self.client.get(url='/user')\n\t        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'no auth headers')\n\t        response = self.client.get(url='/user', headers={\"Authorization\": \"Bearer blasdfdfwerwewfer44r44fr44f4f4c4f4ff4f4\"})\n\t        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, \"bad auth headers\")\n\t    async def test_refresh(self):\n\t        response = self.client.get(url='/user', headers=self.headers.refresh)\n", "        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'ep with refresh')\n\t        response = self.client.post(url='/refresh', headers=self.headers.auth)\n\t        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'refresh with auth')\n\t        response = self.client.post(url='/refresh', headers=self.headers.refresh)\n\t        self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')\n\t        new_headers = AuthHeader(response)\n\t        response = self.client.get(url='/user', headers=new_headers.auth)\n\t        self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')\n\t    # async def test_expiration(self):\n\t    #\n", "    #     with time_machine.travel(0, tick=False) as traveller:\n\t    #         response = self.client.get(url='/user', headers=self.headers.auth)\n\t    #         self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')\n\t    #\n\t    #         traveller.shift(datetime.timedelta(minutes=555))\n\t    #         response = self.client.get(url='/user', headers=self.headers.auth)\n\t    #         self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'expired token')\n"]}
{"filename": "src/database.py", "chunked_list": ["import os\n\tfrom sqlalchemy import NullPool\n\tfrom sqlalchemy.ext.asyncio import AsyncAttrs, AsyncSession\n\tfrom sqlalchemy.ext.asyncio import create_async_engine\n\tfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\n\tfrom singleton_meta import SingletonMeta\n\tclass DataBase(metaclass=SingletonMeta):\n\t    def __init__(self, url=None):\n\t        self.engine = self._create_async_engine(url)\n\t        self.async_session = sessionmaker(self.engine, class_=AsyncSession, expire_on_commit=False)\n", "    @staticmethod\n\t    def _create_async_engine(url):\n\t        if url is None:\n\t            db_host = os.environ.get('DB_HOST', default='localhost')\n\t            db_port = os.environ.get('DB_PORT', default='5432')\n\t            db_user = os.environ.get('DB_USER', default='postgres')\n\t            db_password = os.environ.get('DB_PASSWORD', default='postgres')\n\t            db_name = os.environ.get('DB_NAME', default='postgres')\n\t            url = f\"postgresql+asyncpg://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}\"\n\t        kwargs = {'url': url}\n", "        if os.environ.get('DB_NULL_POOL', default=None) is not None:\n\t            kwargs.update(poolclass=NullPool)\n\t        if os.environ.get('DB_ECHO', default=None) is not None:\n\t            kwargs.update(echo=True)\n\t        return create_async_engine(\n\t            **kwargs\n\t        )\n\t    async def get_session(self) -> AsyncSession:\n\t        async with self.async_session() as session:\n\t            async with session.begin():\n", "                try:\n\t                    yield session\n\t                except Exception as exc:  # pylint: disable=bare-except\n\t                    await session.rollback()\n\t                    raise exc\n\t                await session.commit()\n\t    class Base(AsyncAttrs, DeclarativeBase):\n\t        pass\n"]}
{"filename": "src/auth.py", "chunked_list": ["import hashlib\n\timport logging\n\timport os\n\timport string\n\tfrom datetime import datetime, timedelta\n\tfrom random import choice\n\tfrom fastapi import HTTPException, Depends, status\n\tfrom fastapi.security import OAuth2PasswordBearer, SecurityScopes\n\tfrom jose import JWTError, jwt\n\tfrom jose.constants import ALGORITHMS\n", "from passlib.context import CryptContext\n\tfrom database import DataBase\n\tfrom models.token import TokenData, TokenType\n\tfrom models.users import User\n\tfrom schema.users import get_db_user\n\tdef _gen_secret_key():\n\t    return hashlib.sha512(''.join(choice(string.ascii_letters)\n\t                                  for _ in range(29)).encode()).hexdigest()\n\t# Auth conf\n\tAPI_ALGORITHM = os.environ.get(\"API_ALGORITHM\", ALGORITHMS.HS256)\n", "API_ACCESS_TOKEN_EXPIRE_MINUTES = os.environ.get(\"API_ACCESS_TOKEN_EXPIRE_MINUTES\", 15)\n\tAPI_REFRESH_TOKEN_EXPIRE_DAYS = os.environ.get(\"API_REFRESH_TOKEN_EXPIRE_DAYS\", 30)\n\tAPI_SECRET_KEY = os.environ.get(\"API_SECRET_KEY\", _gen_secret_key())\n\tAPI_REFRESH_SECRET_KEY = os.environ.get(\"API_REFRESH_SECRET_KEY\", _gen_secret_key())\n\t_pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\toauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\tlogger = logging.getLogger(\"api\")\n\tdef verify_hashed(plain: str, hashed: str) -> bool:\n\t    return _pwd_context.verify(plain, hashed)\n\tdef get_hash(str_to_hash: str) -> str:\n", "    \"\"\"\n\t    :rtype: object\n\t    \"\"\"\n\t    return _pwd_context.hash(str_to_hash)\n\tasync def validate_token_data(security_scopes: SecurityScopes,\n\t                              session=Depends(DataBase().get_session),\n\t                              token__: str = Depends(oauth2_scheme)\n\t                              ) -> TokenData:\n\t    credentials_exception = HTTPException(\n\t        status_code=status.HTTP_401_UNAUTHORIZED,\n", "        detail=\"Could not validate credentials\",\n\t        headers={\"WWW-Authenticate\": f'Bearer scope=\"{security_scopes.scope_str}\"'},\n\t    )\n\t    # parse token payload\n\t    try:\n\t        payload = jwt.decode(token__, API_SECRET_KEY, algorithms=[API_ALGORITHM])\n\t    except JWTError as exc:\n\t        raise credentials_exception from exc\n\t    return await validate_token(token__, session, payload, credentials_exception, security_scopes)\n\tasync def validate_refresh_token_data(token__: str = Depends(oauth2_scheme),\n", "                                      session=Depends(DataBase().get_session)) -> TokenData:\n\t    credentials_exception = HTTPException(\n\t        status_code=status.HTTP_401_UNAUTHORIZED,\n\t        detail=\"Could not validate credentials\",\n\t        headers={\"WWW-Authenticate\": f'Bearer token=\"{token__}\"'},\n\t    )\n\t    # parse token payload\n\t    try:\n\t        payload = jwt.decode(token__, API_REFRESH_SECRET_KEY, algorithms=[API_ALGORITHM])\n\t    except JWTError as exc:\n", "        raise credentials_exception from exc\n\t    return await validate_token(token__, session, payload, credentials_exception)\n\tasync def validate_token(token__,\n\t                         session,\n\t                         payload,\n\t                         credentials_exception,\n\t                         security_scopes=None):\n\t    if security_scopes:\n\t        # validate Scopes\n\t        if not set(payload['scopes']).intersection(security_scopes.scopes):\n", "            raise credentials_exception\n\t    _user = await get_db_user(session=session, email=payload['email'])\n\t    if security_scopes:\n\t        if set(_user.scopes) != set(payload['scopes']):\n\t            raise HTTPException(\n\t                status_code=status.HTTP_403_FORBIDDEN,\n\t                detail=\"insufficient privileges\",\n\t                headers={\"WWW-Authenticate\": f'Bearer token=\"{token__}\"'},\n\t            )\n\t    return TokenData(user=User(**payload), exp=payload['exp'])\n", "def create_access_token(data: dict):\n\t    expire = datetime.utcnow() + timedelta(minutes=int(API_ACCESS_TOKEN_EXPIRE_MINUTES))\n\t    data['token_title'] = TokenType.ACCESS\n\t    encoded_jwt = jwt.encode({\"exp\": expire, **data}, API_SECRET_KEY, algorithm=API_ALGORITHM)\n\t    return encoded_jwt\n\tdef create_refresh_token(data: dict):\n\t    expire = datetime.utcnow() + timedelta(days=int(API_REFRESH_TOKEN_EXPIRE_DAYS))\n\t    data['token_title'] = TokenType.REFRESH\n\t    encoded_jwt = jwt.encode({\"exp\": expire, **data}, API_REFRESH_SECRET_KEY, algorithm=API_ALGORITHM)\n\t    return encoded_jwt\n", "# def get_logger(bt: BackgroundTasks,\n\t#                context_id: str = Depends(get_context)):\n\t#     return lambda msg, func=logger.info: bt.add_task(func, msg, extra={\"context_id\": context_id})\n\tif __name__ == '__main__':\n\t    print(get_hash('admin123'))\n"]}
{"filename": "src/api.py", "chunked_list": ["import logging\n\timport uvicorn\n\tfrom fastapi import FastAPI, Depends, status, Response, Security, BackgroundTasks, HTTPException\n\tfrom fastapi.middleware.cors import CORSMiddleware\n\tfrom fastapi.security import OAuth2PasswordRequestForm\n\tfrom starlette.responses import RedirectResponse\n\tfrom auth import create_refresh_token, create_access_token, validate_refresh_token_data\n\tfrom auth import verify_hashed\n\tfrom database import DataBase\n\tfrom endpoints import user_api\n", "from middleware import ContextIdMiddleware, TimeMiddleware\n\tfrom models.token import TokenData, Token\n\tfrom models.users import User\n\tfrom schema.users import get_db_user\n\tlogger = logging.getLogger(\"api\")\n\tapp = FastAPI(title=\"Demo app.\", version='1.0.0', description=\"FastAPI and postgres demo.\")\n\tapp.include_router(user_api.router)\n\tapp.add_middleware(TimeMiddleware)\n\tapp.add_middleware(ContextIdMiddleware)\n\tapp.add_middleware(\n", "    CORSMiddleware,\n\t    allow_origins=[\"*\"],\n\t    allow_credentials=True,\n\t    allow_methods=[\"*\"],\n\t    allow_headers=[\"*\"],\n\t    expose_headers=[TimeMiddleware.HEADER_NAME, ContextIdMiddleware.HEADER_NAME]\n\t)\n\t@app.on_event(\"startup\")\n\tasync def startup():\n\t    db = DataBase()  # warmup db connection\n", "    async with db.engine.begin() as conn:\n\t        await conn.run_sync(db.Base.metadata.create_all)\n\t# @app.on_event(\"shutdown\")\n\t# def shutdown_db_client():\n\t#     db = DataBase()\n\t#     db.async_session.close_all()\n\t#     db.engine.dispose()\n\t@app.get(\"/ping\")\n\tasync def ping(bt: BackgroundTasks,\n\t               context_id: str = Depends(ContextIdMiddleware.get_context)):\n", "    bt.add_task(logger.debug, \"ping\", extra={\"context_id\": context_id})\n\t    return Response(status_code=status.HTTP_200_OK)\n\t@app.get(\"/\")\n\tasync def redirect_root():  # pragma: no cover\n\t    \"\"\"Reroutes the default path to docs\"\"\"\n\t    return RedirectResponse(\"/docs\")\n\t@app.post('/refresh', tags=['Auth'], response_model=Token)\n\tasync def refresh(bt: BackgroundTasks, session=Depends(DataBase().get_session),\n\t                  context_id: str = Depends(ContextIdMiddleware.get_context),\n\t                  token: TokenData = Security(validate_refresh_token_data),\n", "                  ):\n\t    bt.add_task(logger.info, f'Getting token and refresh for {token.user.email}',\n\t                extra={\"context_id\": context_id})\n\t    _user = await get_db_user(session=session, email=token.user.email)\n\t    refresh_token = create_refresh_token(data=User.from_orm(_user).dict())\n\t    access_token = create_access_token(data=User.from_orm(_user).dict())\n\t    bt.add_task(logger.info, f'Login succeeded for {token.user.email}',\n\t                extra={\"context_id\": context_id})\n\t    return {\"access_token\": access_token,\n\t            \"refresh_token\": refresh_token,\n", "            \"token_type\": \"bearer\"}\n\t@app.post('/token', tags=['Auth'], response_model=Token)\n\tasync def get_token(bt: BackgroundTasks,\n\t                    context_id: str = Depends(ContextIdMiddleware.get_context),\n\t                    session=Depends(DataBase().get_session),\n\t                    form_data: OAuth2PasswordRequestForm = Depends()):\n\t    bt.add_task(logger.info, f'Getting token for {form_data.username}',\n\t                extra={\"context_id\": context_id})\n\t    exception = HTTPException(\n\t        status_code=status.HTTP_401_UNAUTHORIZED,\n", "        detail=\"Incorrect email or password\",\n\t        headers={\"WWW-Authenticate\": \"Bearer\"})\n\t    _user = await get_db_user(session=session, email=form_data.username)\n\t    # test\n\t    if not _user or not verify_hashed(plain=form_data.password, hashed=_user.password):\n\t        bt.add_task(logger.warning,\n\t                    f'Illegal password for {form_data.username}',\n\t                    extra={\"context_id\": context_id})\n\t        raise exception\n\t    refresh_token = create_refresh_token(data=User.from_orm(_user).dict())\n", "    access_token = create_access_token(data=User.from_orm(_user).dict())\n\t    bt.add_task(logger.info, f'Login succeeded for {form_data.username}',\n\t                extra={\"context_id\": context_id})\n\t    return {\"access_token\": access_token,\n\t            \"refresh_token\": refresh_token,\n\t            \"token_type\": \"bearer\"}\n\tif __name__ == '__main__':\n\t    uvicorn.run(\"api:app\",\n\t                host=\"0.0.0.0\",\n\t                port=8001,\n", "                log_config=\"logger.json\",\n\t                log_level=logging.DEBUG)\n"]}
{"filename": "src/__init__.py", "chunked_list": []}
{"filename": "src/singleton_meta.py", "chunked_list": ["from weakref import WeakValueDictionary\n\tclass SingletonMeta(type):\n\t    _instances = WeakValueDictionary()\n\t    def __call__(cls, *args, **kwargs):\n\t        if cls not in cls._instances:\n\t            instance = super().__call__(*args, **kwargs)\n\t            cls._instances[cls] = instance\n\t        return cls._instances[cls]\n"]}
{"filename": "src/middleware.py", "chunked_list": ["import time\n\tfrom uuid import uuid4\n\tfrom starlette.middleware.base import BaseHTTPMiddleware\n\tfrom starlette.requests import Request\n\tclass ContextIdMiddleware(BaseHTTPMiddleware):\n\t    HEADER_NAME = \"X-Context-Id\"\n\t    async def dispatch(self, request: Request, call_next):\n\t        context_id = request.headers.get('context-id', str(uuid4()))\n\t        request.state.context_id = context_id\n\t        response = await call_next(request)\n", "        response.headers[self.HEADER_NAME] = context_id\n\t        return response\n\t    @staticmethod\n\t    def get_context(request: Request) -> str:\n\t        return request.state.context_id\n\tclass TimeMiddleware(BaseHTTPMiddleware):\n\t    \"\"\"This middleware adds \"X-Process-Time\" header with server code execution time.\"\"\"\n\t    HEADER_NAME = \"X-Process-Time\"\n\t    async def dispatch(self, request: Request, call_next):\n\t        start_time = time.time()\n", "        response = await call_next(request)\n\t        process_time = time.time() - start_time\n\t        response.headers[self.HEADER_NAME] = str(f'{process_time:0.4f} sec')\n\t        return response\n"]}
{"filename": "src/endpoints/__init__.py", "chunked_list": []}
{"filename": "src/endpoints/user_api.py", "chunked_list": ["from typing import List\n\tfrom fastapi import APIRouter, Depends, Security, Body, status\n\tfrom auth import validate_token_data, get_hash\n\tfrom database import DataBase\n\tfrom models.scopes import Scope\n\tfrom models.token import TokenData\n\tfrom models.users import NewUser, DisplayUser\n\tfrom schema.users import users\n\trouter = APIRouter(tags=[\"User\"], prefix=\"/user\")\n\t@router.get(\"/\", response_model=List[DisplayUser], description='List users.')\n", "async def list_users(session=Depends(DataBase().get_session),\n\t                     token: TokenData = Security(validate_token_data,  # pylint: disable=unused-argument\n\t                                                 scopes=[Scope.ADMIN, Scope.USER])\n\t                     ):\n\t    query = users.select()\n\t    result = await session.execute(query)\n\t    return result.all()\n\t@router.post(\"/\", status_code=status.HTTP_201_CREATED, description='Add new user')\n\tasync def create_new_user(session=Depends(DataBase().get_session),\n\t                          new_user: NewUser = Body(...),\n", "                          token: TokenData = Security(validate_token_data, scopes=[Scope.ADMIN])  # pylint: disable=unused-argument\n\t                          ):\n\t    query_params = new_user.dict()\n\t    query_params.pop('id', None)  # ensure id is not passed.\n\t    query_params['password'] = get_hash(query_params['password'])  # hash password\n\t    query = users.insert().values(**query_params)\n\t    await session.execute(query)\n"]}
{"filename": "src/models/scopes.py", "chunked_list": ["from enum import Enum\n\tclass Scope(str, Enum):\n\t    ADMIN = 'ADMIN'\n\t    USER = 'USER'\n"]}
{"filename": "src/models/users.py", "chunked_list": ["from typing import List\n\tfrom pydantic import BaseModel, Field\n\tfrom models.scopes import Scope\n\tclass _UserBase(BaseModel):\n\t    email: str = Field(...)\n\t    scopes: List[Scope] = Field(...)\n\t    class Config:\n\t        orm_mode = True\n\tclass NewUser(_UserBase):\n\t    password: str = Field(...)\n", "    class Config:\n\t        orm_mode = True\n\tclass DisplayUser(_UserBase):\n\t    id: int = Field(...)\n\t    class Config:\n\t        orm_mode = True\n\tclass User(NewUser, DisplayUser):\n\t    id: int = Field(...)\n\t    class Config:\n\t        orm_mode = True\n"]}
{"filename": "src/models/__init__.py", "chunked_list": []}
{"filename": "src/models/token.py", "chunked_list": ["from enum import Enum\n\tfrom pydantic import BaseModel, Field\n\tfrom models.users import User\n\tclass TokenType(str, Enum):\n\t    ACCESS = 'ACCESS'\n\t    REFRESH = 'REFRESH'\n\tclass Token(BaseModel):\n\t    \"\"\"jwt token\"\"\"\n\t    access_token: str = Field(...)\n\t    refresh_token: str = Field(...)\n", "    token_type: str = Field(...)\n\tclass TokenData(BaseModel):\n\t    \"\"\"jwt token\"\"\"\n\t    exp: int = Field(...)\n\t    user: User = Field(...)\n"]}
{"filename": "src/schema/users.py", "chunked_list": ["import sqlalchemy\n\tfrom database import DataBase\n\tUSER_ID_SEQ = sqlalchemy.Sequence('user_id_seq', start=1, increment=1)\n\tusers = sqlalchemy.Table(\n\t    \"users\",\n\t    DataBase.Base.metadata,\n\t    sqlalchemy.Column(\"id\",\n\t                      sqlalchemy.Integer, USER_ID_SEQ,\n\t                      primary_key=True\n\t                      ),\n", "    sqlalchemy.Column(\"email\", sqlalchemy.String),\n\t    sqlalchemy.Column(\"password\", sqlalchemy.String),\n\t    sqlalchemy.Column(\"scopes\", sqlalchemy.ARRAY(sqlalchemy.String)),\n\t    schema='public'\n\t)\n\tasync def get_db_user(session, email):\n\t    query = users.select().where(users.c.email == email.lower())\n\t    _user = await session.execute(query)\n\t    _user = _user.first()\n\t    return _user\n"]}
{"filename": "src/schema/__init__.py", "chunked_list": []}
