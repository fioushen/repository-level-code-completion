{"filename": "setup.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport io\n\timport os\n\tfrom setuptools import setup, find_packages\n\tpackage_root = os.path.abspath(os.path.dirname(__file__))\n\treadme_filename = os.path.join(package_root, \"README.md\")\n\twith io.open(readme_filename, encoding=\"utf-8\") as readme_file:\n\t    readme = readme_file.read()\n", "packages = [package for package in find_packages() if package.startswith(\"google\")]\n\t# Determine which namespaces are needed.\n\tnamespaces = [\"google\"]\n\tif \"google.cloud\" in packages:\n\t    namespaces.append(\"google.cloud\")\n\tname = \"google-cloud-alloydb-connector\"\n\tdescription = \"A Python client library for connecting securely to your Google Cloud AlloyDB instances.\"\n\tversion = {}\n\twith open(\"google/cloud/alloydb/connector/version.py\") as fp:\n\t    exec(fp.read(), version)\n", "version = version[\"__version__\"]\n\trelease_status = \"Development Status :: 4 - Beta\"\n\tcore_dependencies = [\n\t    \"aiohttp\",\n\t    \"cryptography>=38.0.3\",\n\t    \"requests\",\n\t    \"google-auth\",\n\t]\n\tsetup(\n\t    name=name,\n", "    version=version,\n\t    description=description,\n\t    long_description=readme,\n\t    long_description_content_type=\"text/markdown\",\n\t    author=\"Google LLC\",\n\t    author_email=\"googleapis-packages@google.com\",\n\t    license=\"Apache 2.0\",\n\t    url=\"https://github.com/GoogleCloudPlatform/alloydb-python-connector\",\n\t    classifiers=[\n\t        release_status,\n", "        \"Intended Audience :: Developers\",\n\t        \"License :: OSI Approved :: Apache Software License\",\n\t        \"Programming Language :: Python\",\n\t        \"Programming Language :: Python :: 3.8\",\n\t        \"Programming Language :: Python :: 3.9\",\n\t        \"Programming Language :: Python :: 3.10\",\n\t        \"Programming Language :: Python :: 3.11\",\n\t    ],\n\t    platforms=\"Posix; MacOS X; Windows\",\n\t    packages=packages,\n", "    namespace_packages=namespaces,\n\t    install_requires=core_dependencies,\n\t    extras_require={\n\t        \"pg8000\": [\"pg8000==1.29.8\"],\n\t    },\n\t    python_requires=\">=3.8\",\n\t    include_package_data=True,\n\t    zip_safe=False,\n\t)\n"]}
{"filename": "noxfile.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     https://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import absolute_import\n\timport os\n\timport nox\n\tBLACK_VERSION = \"black==22.3.0\"\n\tLINT_PATHS = [\"google\", \"tests\", \"noxfile.py\", \"setup.py\"]\n\tSYSTEM_TEST_PYTHON_VERSIONS = [\"3.8\", \"3.9\", \"3.10\", \"3.11\"]\n\tUNIT_TEST_PYTHON_VERSIONS = [\"3.8\", \"3.9\", \"3.10\", \"3.11\"]\n", "@nox.session\n\tdef lint(session):\n\t    \"\"\"Run linters.\n\t    Returns a failure if the linters find linting errors or sufficiently\n\t    serious code quality issues.\n\t    \"\"\"\n\t    session.install(\"-r\", \"requirements-test.txt\")\n\t    session.install(\"-r\", \"requirements.txt\")\n\t    session.install(\n\t        \"flake8\",\n", "        \"flake8-import-order\",\n\t        \"flake8-annotations\",\n\t        \"mypy\",\n\t        BLACK_VERSION,\n\t        \"types-setuptools\",\n\t        \"twine\",\n\t    )\n\t    session.run(\n\t        \"black\",\n\t        \"--check\",\n", "        *LINT_PATHS,\n\t    )\n\t    session.run(\n\t        \"flake8\",\n\t        \"--import-order-style=google\",\n\t        \"--application-import-names=google,tests\",\n\t        \"google\",\n\t        \"tests\",\n\t    )\n\t    session.run(\"mypy\", \"google\", \"--install-types\", \"--non-interactive\")\n", "    session.run(\"python\", \"setup.py\", \"sdist\")\n\t    session.run(\"twine\", \"check\", \"dist/*\")\n\t@nox.session\n\tdef blacken(session):\n\t    \"\"\"Run black.\n\t    Format code to uniform standard.\n\t    \"\"\"\n\t    session.install(BLACK_VERSION)\n\t    session.run(\n\t        \"black\",\n", "        *LINT_PATHS,\n\t    )\n\t@nox.session()\n\tdef cover(session):\n\t    \"\"\"Run the final coverage report.\n\t    This outputs the coverage report aggregating coverage from the unit\n\t    test runs (not system test runs), and then erases coverage data.\n\t    \"\"\"\n\t    session.install(\"coverage\", \"pytest-cov\")\n\t    session.run(\"coverage\", \"report\", \"--show-missing\", \"--fail-under=0\")\n", "    session.run(\"coverage\", \"erase\")\n\tdef default(session, path):\n\t    # Install all test dependencies, then install this package in-place.\n\t    session.install(\"-r\", \"requirements-test.txt\")\n\t    session.install(\"-e\", \".\")\n\t    session.install(\"-r\", \"requirements.txt\")\n\t    # Run pytest with coverage.\n\t    session.run(\n\t        \"pytest\",\n\t        \"--cov=google.cloud.alloydb.connector\",\n", "        \"-v\",\n\t        \"--cov-config=.coveragerc\",\n\t        \"--cov-report=\",\n\t        \"--cov-fail-under=0\",\n\t        \"--junitxml=sponge_log.xml\",\n\t        path,\n\t        *session.posargs,\n\t    )\n\t@nox.session(python=UNIT_TEST_PYTHON_VERSIONS)\n\tdef unit(session):\n", "    \"\"\"Run the unit test suite.\"\"\"\n\t    default(session, os.path.join(\"tests\", \"unit\"))\n\t@nox.session(python=SYSTEM_TEST_PYTHON_VERSIONS)\n\tdef system(session):\n\t    default(session, os.path.join(\"tests\", \"system\"))\n"]}
{"filename": "tests/system/test_pg8000_connection.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom datetime import datetime\n\timport os\n\timport pg8000\n\timport sqlalchemy\n\tfrom google.cloud.alloydb.connector import Connector\n\tdef init_connection_engine(connector: Connector) -> sqlalchemy.engine.Engine:\n\t    def getconn() -> pg8000.dbapi.Connection:\n", "        conn: pg8000.dbapi.Connection = connector.connect(\n\t            os.environ[\"ALLOYDB_INSTANCE_URI\"],\n\t            \"pg8000\",\n\t            user=os.environ[\"ALLOYDB_USER\"],\n\t            password=os.environ[\"ALLOYDB_PASS\"],\n\t            db=os.environ[\"ALLOYDB_DB\"],\n\t        )\n\t        return conn\n\t    # create SQLAlchemy connection pool\n\t    pool = sqlalchemy.create_engine(\n", "        \"postgresql+pg8000://\",\n\t        creator=getconn,\n\t    )\n\t    pool.dialect.description_encoding = None\n\t    return pool\n\tdef test_pg8000_time() -> None:\n\t    \"\"\"Basic test to get time from database.\"\"\"\n\t    with Connector() as connector:\n\t        pool = init_connection_engine(connector)\n\t        with pool.connect() as conn:\n", "            time = conn.execute(sqlalchemy.text(\"SELECT NOW()\")).fetchone()\n\t            conn.commit()\n\t            curr_time = time[0]\n\t            assert type(curr_time) == datetime\n"]}
{"filename": "tests/unit/test_connector.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport asyncio\n\tfrom threading import Thread\n\tfrom mock import patch\n\tfrom mocks import FakeAlloyDBClient, FakeCredentials\n\timport pytest\n\tfrom google.cloud.alloydb.connector import Connector\n\tdef test_Connector_init(credentials: FakeCredentials) -> None:\n", "    \"\"\"\n\t    Test to check whether the __init__ method of Connector\n\t    properly sets default attributes.\n\t    \"\"\"\n\t    connector = Connector(credentials)\n\t    assert connector._quota_project is None\n\t    assert connector._alloydb_api_endpoint == \"https://alloydb.googleapis.com\"\n\t    assert connector._client is None\n\t    assert connector._credentials == credentials\n\t    connector.close()\n", "def test_Connector_context_manager(credentials: FakeCredentials) -> None:\n\t    \"\"\"\n\t    Test to check whether the __init__ method of Connector\n\t    properly sets defaults as context manager.\n\t    \"\"\"\n\t    with Connector(credentials) as connector:\n\t        assert connector._quota_project is None\n\t        assert connector._alloydb_api_endpoint == \"https://alloydb.googleapis.com\"\n\t        assert connector._client is None\n\t        assert connector._credentials == credentials\n", "def test_Connector_close(credentials: FakeCredentials) -> None:\n\t    \"\"\"\n\t    Test that Connector's close method stops event loop and\n\t    background thread.\n\t    \"\"\"\n\t    with Connector(credentials) as connector:\n\t        loop: asyncio.AbstractEventLoop = connector._loop\n\t        thread: Thread = connector._thread\n\t        assert loop.is_running() is True\n\t        assert thread.is_alive() is True\n", "    assert loop.is_running() is False\n\t    assert thread.is_alive() is False\n\tdef test_connect(credentials: FakeCredentials) -> None:\n\t    \"\"\"\n\t    Test that connector.connect returns connection object.\n\t    \"\"\"\n\t    client = FakeAlloyDBClient()\n\t    with Connector(credentials) as connector:\n\t        connector._client = client\n\t        # patch db connection creation\n", "        with patch(\"pg8000.dbapi.connect\") as mock_connect:\n\t            mock_connect.return_value = True\n\t            connection = connector.connect(\n\t                \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t                \"pg8000\",\n\t                user=\"test-user\",\n\t                password=\"test-password\",\n\t                db=\"test-db\",\n\t            )\n\t        # check connection is returned\n", "        assert connection is True\n\tdef test_connect_unsupported_driver(credentials: FakeCredentials) -> None:\n\t    \"\"\"\n\t    Test that connector.connect errors with unsupported database driver.\n\t    \"\"\"\n\t    client = FakeAlloyDBClient()\n\t    with Connector(credentials) as connector:\n\t        connector._client = client\n\t        # try to connect using unsupported driver, should raise ValueError\n\t        with pytest.raises(ValueError) as exc_info:\n", "            connector.connect(\n\t                \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t                \"bad_driver\",\n\t            )\n\t        # assert custom error message for unsupported driver is present\n\t        assert (\n\t            exc_info.value.args[0]\n\t            == \"Driver 'bad_driver' is not a supported database driver.\"\n\t        )\n"]}
{"filename": "tests/unit/test_rate_limiter.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport asyncio\n\timport pytest\n\tfrom google.cloud.alloydb.connector.rate_limiter import AsyncRateLimiter\n\t@pytest.mark.asyncio\n\tasync def test_rate_limiter_throttles_requests() -> None:\n\t    \"\"\"Test to check whether rate limiter will throttle incoming requests.\"\"\"\n\t    counter = 0\n", "    # allow 2 requests to go through every 10 seconds\n\t    rate_limiter = AsyncRateLimiter(max_capacity=2, rate=1 / 10)\n\t    async def increment() -> None:\n\t        await rate_limiter.acquire()\n\t        nonlocal counter\n\t        counter += 1\n\t    # create 5 tasks calling increment()\n\t    tasks = [asyncio.create_task(increment()) for _ in range(5)]\n\t    # wait 5 seconds and check tasks\n\t    done, pending = await asyncio.wait(tasks, timeout=5)\n", "    # verify 2 tasks completed and 3 pending due to rate limiter\n\t    assert counter == 2\n\t    assert len(done) == 2\n\t    assert len(pending) == 3\n\t    # cleanup pending tasks\n\t    for task in pending:\n\t        task.cancel()\n\t@pytest.mark.asyncio\n\tasync def test_rate_limiter_completes_all_tasks() -> None:\n\t    \"\"\"Test to check all requests will go through rate limiter successfully.\"\"\"\n", "    counter = 0\n\t    # allow 1 request to go through per second\n\t    rate_limiter = AsyncRateLimiter(max_capacity=1, rate=1)\n\t    async def increment() -> None:\n\t        await rate_limiter.acquire()\n\t        nonlocal counter\n\t        counter += 1\n\t    # create 5 tasks calling increment()\n\t    tasks = [asyncio.create_task(increment()) for _ in range(5)]\n\t    done, pending = await asyncio.wait(tasks, timeout=6)\n", "    # verify all tasks done and none pending\n\t    assert counter == 5\n\t    assert len(done) == 5\n\t    assert len(pending) == 0\n"]}
{"filename": "tests/unit/mocks.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom datetime import datetime, timedelta\n\tfrom typing import Any, Callable, List, Optional, Tuple\n\tfrom cryptography import x509\n\tfrom cryptography.hazmat.primitives import hashes, serialization\n\tfrom cryptography.hazmat.primitives.asymmetric import rsa\n\tfrom cryptography.x509.oid import NameOID\n\tfrom google.cloud.alloydb.connector.utils import _create_certificate_request\n", "class FakeCredentials:\n\t    def __init__(self) -> None:\n\t        self.token: Optional[str] = None\n\t        self.expiry: Optional[datetime] = None\n\t    def refresh(self, request: Callable) -> None:\n\t        \"\"\"Refreshes the access token.\"\"\"\n\t        self.token = \"12345\"\n\t        self.expiry = datetime.now() + timedelta(minutes=60)\n\t    @property\n\t    def expired(self) -> bool:\n", "        \"\"\"Checks if the credentials are expired.\n\t        Note that credentials can be invalid but not expired because\n\t        Credentials with expiry set to None are considered to never\n\t        expire.\n\t        \"\"\"\n\t        return False if not self.expiry else True\n\t    @property\n\t    def valid(self) -> bool:\n\t        \"\"\"Checks the validity of the credentials.\n\t        This is True if the credentials have a token and the token\n", "        is not expired.\n\t        \"\"\"\n\t        return self.token is not None and not self.expired\n\tdef generate_cert(\n\t    common_name: str, expires_in: int = 60\n\t) -> Tuple[x509.CertificateBuilder, rsa.RSAPrivateKey]:\n\t    \"\"\"\n\t    Generate a private key and cert object to be used in testing.\n\t    Args:\n\t        common_name (str): The Common Name for the certificate.\n", "        expires_in (int): Time in minutes until expiry of certificate.\n\t    Returns:\n\t        Tuple[x509.CertificateBuilder, rsa.RSAPrivateKey]\n\t    \"\"\"\n\t    # generate private key\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    # calculate expiry time\n\t    now = datetime.now()\n\t    expiration = now + timedelta(minutes=expires_in)\n\t    # configure cert subject\n", "    subject = issuer = x509.Name(\n\t        [\n\t            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n\t            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"California\"),\n\t            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Mountain View\"),\n\t            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Google Inc\"),\n\t            x509.NameAttribute(NameOID.COMMON_NAME, common_name),\n\t        ]\n\t    )\n\t    # build cert\n", "    cert = (\n\t        x509.CertificateBuilder()\n\t        .subject_name(subject)\n\t        .issuer_name(issuer)\n\t        .public_key(key.public_key())\n\t        .serial_number(x509.random_serial_number())\n\t        .not_valid_before(now)\n\t        .not_valid_after(expiration)\n\t    )\n\t    return cert, key\n", "class FakeInstance:\n\t    \"\"\"Fake AlloyDB instance to use for testing\"\"\"\n\t    def __init__(\n\t        self,\n\t        project: str = \"test-project\",\n\t        region: str = \"test-region\",\n\t        cluster: str = \"test-cluster\",\n\t        name: str = \"test-instance\",\n\t        ip_address: str = \"127.0.0.1\",\n\t        server_name: str = \"00000000-0000-0000-0000-000000000000.server.alloydb\",\n", "        cert_before: datetime = datetime.now(),\n\t        cert_expiry: datetime = datetime.now() + timedelta(hours=1),\n\t    ) -> None:\n\t        self.project = project\n\t        self.region = region\n\t        self.cluster = cluster\n\t        self.name = name\n\t        self.ip_address = ip_address\n\t        self.server_name = server_name\n\t        self.cert_before = cert_before\n", "        self.cert_expiry = cert_expiry\n\t    def generate_certs(self) -> None:\n\t        \"\"\"\n\t        Build certs required for chain of trust with testing server.\n\t        \"\"\"\n\t        # build root cert\n\t        self.root_cert, self.root_key = generate_cert(\"root.alloydb\")\n\t        # create self signed root cert\n\t        self.root_cert = self.root_cert.sign(self.root_key, hashes.SHA256())\n\t        # build intermediate cert\n", "        self.intermediate_cert, self.intermediate_key = generate_cert(\"client.alloydb\")\n\t        # create intermediate cert signed by root cert\n\t        self.intermediate_cert = self.intermediate_cert.sign(\n\t            self.root_key, hashes.SHA256()\n\t        )\n\t        # build server cert\n\t        self.server_cert, self.server_key = generate_cert(self.server_name)\n\t        # create server cert signed by root cert\n\t        self.server_cert = self.server_cert.sign(self.root_key, hashes.SHA256())\n\t    def get_pem_certs(self) -> Tuple[str, str, str]:\n", "        \"\"\"Helper method to get all certs in pem string format.\"\"\"\n\t        pem_root = self.root_cert.public_bytes(\n\t            encoding=serialization.Encoding.PEM\n\t        ).decode(\"UTF-8\")\n\t        pem_intermediate = self.intermediate_cert.public_bytes(\n\t            encoding=serialization.Encoding.PEM\n\t        ).decode(\"UTF-8\")\n\t        pem_server = self.server_cert.public_bytes(\n\t            encoding=serialization.Encoding.PEM\n\t        ).decode(\"UTF-8\")\n", "        return (pem_root, pem_intermediate, pem_server)\n\tclass FakeAlloyDBClient:\n\t    \"\"\"Fake class for testing AlloyDBClient\"\"\"\n\t    def __init__(self) -> None:\n\t        self.instance = FakeInstance()\n\t    async def _get_metadata(*args: Any, **kwargs: Any) -> str:\n\t        return \"127.0.0.1\"\n\t    async def _get_client_certificate(\n\t        self,\n\t        project: str,\n", "        region: str,\n\t        cluster: str,\n\t        key: rsa.RSAPrivateKey,\n\t    ) -> Tuple[str, List[str]]:\n\t        self.instance.generate_certs()\n\t        root_cert, intermediate_cert, _ = self.instance.get_pem_certs()\n\t        csr = _create_certificate_request(key)\n\t        # build client cert\n\t        client_cert = (\n\t            x509.CertificateBuilder()\n", "            .subject_name(csr.subject)\n\t            .issuer_name(self.instance.intermediate_cert.issuer)\n\t            .public_key(csr.public_key())\n\t            .serial_number(x509.random_serial_number())\n\t            .not_valid_before(self.instance.cert_before)\n\t            .not_valid_after(self.instance.cert_expiry)\n\t        )\n\t        # sign client cert with intermediate cert\n\t        client_cert = client_cert.sign(self.instance.intermediate_key, hashes.SHA256())\n\t        client_cert = client_cert.public_bytes(\n", "            encoding=serialization.Encoding.PEM\n\t        ).decode(\"UTF-8\")\n\t        return (client_cert, [intermediate_cert, root_cert])\n\t    async def close(self) -> None:\n\t        pass\n"]}
{"filename": "tests/unit/test_instance.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport asyncio\n\tfrom datetime import datetime, timedelta\n\timport aiohttp\n\tfrom cryptography.hazmat.primitives.asymmetric import rsa\n\tfrom mocks import FakeAlloyDBClient\n\timport pytest\n\tfrom google.cloud.alloydb.connector.exceptions import RefreshError\n", "from google.cloud.alloydb.connector.instance import Instance\n\tfrom google.cloud.alloydb.connector.refresh import _is_valid, RefreshResult\n\t@pytest.mark.asyncio\n\tasync def test_Instance_init() -> None:\n\t    \"\"\"\n\t    Test to check whether the __init__ method of Instance\n\t    can tell if the instance URI that's passed in is formatted correctly.\n\t    \"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    async with aiohttp.ClientSession() as client:\n", "        instance = Instance(\n\t            \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t            client,\n\t            key,\n\t        )\n\t        assert (\n\t            instance._project == \"test-project\"\n\t            and instance._region == \"test-region\"\n\t            and instance._cluster == \"test-cluster\"\n\t            and instance._name == \"test-instance\"\n", "        )\n\t@pytest.mark.asyncio\n\tasync def test_Instance_init_invalid_instant_uri() -> None:\n\t    \"\"\"\n\t    Test to check whether the __init__ method of Instance\n\t    will throw error for invalid instance URI.\n\t    \"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    async with aiohttp.ClientSession() as client:\n\t        with pytest.raises(ValueError):\n", "            Instance(\"invalid/instance/uri/\", client, key)\n\t@pytest.mark.asyncio\n\tasync def test_Instance_close() -> None:\n\t    \"\"\"\n\t    Test that Instance's close method\n\t    cancels tasks gracefully.\n\t    \"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    client = FakeAlloyDBClient()\n\t    instance = Instance(\n", "        \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t        client,\n\t        key,\n\t    )\n\t    # make sure tasks aren't cancelled\n\t    assert instance._current.cancelled() is False\n\t    assert instance._next.cancelled() is False\n\t    # run close() to cancel tasks\n\t    await instance.close()\n\t    # verify tasks are cancelled\n", "    assert (instance._current.done() or instance._current.cancelled()) is True\n\t    assert instance._next.cancelled() is True\n\t@pytest.mark.asyncio\n\tasync def test_perform_refresh() -> None:\n\t    \"\"\"Test that _perform refresh returns valid RefreshResult\"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    client = FakeAlloyDBClient()\n\t    instance = Instance(\n\t        \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t        client,\n", "        key,\n\t    )\n\t    refresh = await instance._perform_refresh()\n\t    assert refresh.instance_ip == \"127.0.0.1\"\n\t    assert refresh.expiration == client.instance.cert_expiry.replace(microsecond=0)\n\t    # close instance\n\t    await instance.close()\n\t@pytest.mark.asyncio\n\tasync def test_schedule_refresh_replaces_result() -> None:\n\t    \"\"\"\n", "    Test to check whether _schedule_refresh replaces a valid refresh result\n\t    with another refresh result.\n\t    \"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    client = FakeAlloyDBClient()\n\t    instance = Instance(\n\t        \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t        client,\n\t        key,\n\t    )\n", "    # check current refresh is valid\n\t    assert await _is_valid(instance._current) is True\n\t    current_refresh = instance._current\n\t    # schedule new refresh\n\t    await instance._schedule_refresh(0)\n\t    new_refresh = instance._current\n\t    # verify current has been replaced with new refresh\n\t    assert current_refresh != new_refresh\n\t    # check new refresh is valid\n\t    assert await _is_valid(new_refresh) is True\n", "    # close instance\n\t    await instance.close()\n\t@pytest.mark.asyncio\n\tasync def test_schedule_refresh_wont_replace_valid_result_with_invalid() -> None:\n\t    \"\"\"\n\t    Test to check whether _schedule_refresh won't replace a valid\n\t    refresh result with an invalid one.\n\t    \"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    client = FakeAlloyDBClient()\n", "    instance = Instance(\n\t        \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t        client,\n\t        key,\n\t    )\n\t    # check current refresh is valid\n\t    assert await _is_valid(instance._current) is True\n\t    current_refresh = instance._current\n\t    # set certificate to be expired\n\t    client.instance.cert_before = datetime.now() - timedelta(minutes=20)\n", "    client.instance.cert_expiry = datetime.now() - timedelta(minutes=10)\n\t    # schedule new refresh\n\t    new_refresh = instance._schedule_refresh(0)\n\t    # check new refresh is invalid\n\t    assert await _is_valid(new_refresh) is False\n\t    # check current was not replaced\n\t    assert current_refresh == instance._current\n\t    # close instance\n\t    await instance.close()\n\t@pytest.mark.asyncio\n", "async def test_schedule_refresh_expired_cert() -> None:\n\t    \"\"\"\n\t    Test to check whether _schedule_refresh will throw RefreshError on\n\t    expired certificate.\n\t    \"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    client = FakeAlloyDBClient()\n\t    # set certificate to be expired\n\t    client.instance.cert_before = datetime.now() - timedelta(minutes=20)\n\t    client.instance.cert_expiry = datetime.now() - timedelta(minutes=10)\n", "    instance = Instance(\n\t        \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t        client,\n\t        key,\n\t    )\n\t    # check RefreshError is thrown\n\t    with pytest.raises(RefreshError):\n\t        await instance._current\n\t    # close instance\n\t    await instance.close()\n", "@pytest.mark.asyncio\n\tasync def test_force_refresh_cancels_pending_refresh() -> None:\n\t    \"\"\"\n\t    Test that force_refresh cancels pending task if refresh_in_progress event is not set.\n\t    \"\"\"\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    client = FakeAlloyDBClient()\n\t    instance = Instance(\n\t        \"projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance\",\n\t        client,\n", "        key,\n\t    )\n\t    # make sure initial refresh is finished\n\t    await instance._current\n\t    # since the pending refresh isn't for another ~56 min, the refresh_in_progress event\n\t    # shouldn't be set\n\t    pending_refresh = instance._next\n\t    assert instance._refresh_in_progress.is_set() is False\n\t    instance.force_refresh()\n\t    # pending_refresh has to be awaited for it to raised as cancelled\n", "    with pytest.raises(asyncio.CancelledError):\n\t        assert await pending_refresh\n\t    # verify pending_refresh has now been cancelled\n\t    assert pending_refresh.cancelled() is True\n\t    assert isinstance(await instance._current, RefreshResult)\n\t    # close instance\n\t    await instance.close()\n"]}
{"filename": "tests/unit/test_refresh.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom datetime import datetime, timedelta\n\timport ssl\n\tfrom cryptography import x509\n\tfrom cryptography.hazmat.primitives import hashes, serialization\n\tfrom cryptography.hazmat.primitives.asymmetric import rsa\n\tfrom mocks import FakeInstance\n\tfrom google.cloud.alloydb.connector.refresh import (\n", "    _seconds_until_refresh,\n\t    RefreshResult,\n\t)\n\tfrom google.cloud.alloydb.connector.utils import _create_certificate_request\n\tdef test_seconds_until_refresh_over_1_hour() -> None:\n\t    \"\"\"\n\t    Test _seconds_until_refresh returns proper time in seconds.\n\t    If expiration is over 1 hour, should return duration/2.\n\t    \"\"\"\n\t    now = datetime.now()\n", "    assert _seconds_until_refresh(now + timedelta(minutes=62), now) == 31 * 60\n\tdef test_seconds_until_refresh_under_1_hour_over_4_mins() -> None:\n\t    \"\"\"\n\t    Test _seconds_until_refresh returns proper time in seconds.\n\t    If expiration is under 1 hour and over 4 minutes,\n\t    should return duration-refresh_buffer (refresh_buffer = 4 minutes).\n\t    \"\"\"\n\t    now = datetime.now()\n\t    assert _seconds_until_refresh(now + timedelta(minutes=5), now) == 60\n\tdef test_seconds_until_refresh_under_4_mins() -> None:\n", "    \"\"\"\n\t    Test _seconds_until_refresh returns proper time in seconds.\n\t    If expiration is under 4 minutes, should return 0.\n\t    \"\"\"\n\t    assert _seconds_until_refresh(datetime.now() + timedelta(minutes=3)) == 0\n\tdef test_RefreshResult_init_(fake_instance: FakeInstance) -> None:\n\t    \"\"\"\n\t    Test to check whether the __init__ method of RefreshResult\n\t    can correctly initialize TLS context.\n\t    \"\"\"\n", "    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    fake_instance.generate_certs()\n\t    root_cert, intermediate_cert, _ = fake_instance.get_pem_certs()\n\t    csr = _create_certificate_request(key)\n\t    # build client cert\n\t    client_cert = (\n\t        x509.CertificateBuilder()\n\t        .subject_name(csr.subject)\n\t        .issuer_name(fake_instance.intermediate_cert.issuer)\n\t        .public_key(csr.public_key())\n", "        .serial_number(x509.random_serial_number())\n\t        .not_valid_before(datetime.now())\n\t        .not_valid_after(datetime.now() + timedelta(minutes=10))\n\t    )\n\t    # sign client cert with intermediate cert\n\t    client_cert = client_cert.sign(fake_instance.intermediate_key, hashes.SHA256())\n\t    client_cert = client_cert.public_bytes(encoding=serialization.Encoding.PEM).decode(\n\t        \"UTF-8\"\n\t    )\n\t    certs = (client_cert, [intermediate_cert, root_cert])\n", "    refresh = RefreshResult(fake_instance.ip_address, key, certs)\n\t    # verify TLS requirements\n\t    assert refresh.context.minimum_version == ssl.TLSVersion.TLSv1_3\n\t    assert refresh.context.request_ssl is False\n"]}
{"filename": "tests/unit/test_client.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport json\n\tfrom typing import Any\n\tfrom aiohttp import web\n\tfrom cryptography.hazmat.primitives.asymmetric import rsa\n\tfrom mocks import FakeCredentials\n\timport pytest\n\tfrom google.cloud.alloydb.connector.client import AlloyDBClient\n", "from google.cloud.alloydb.connector.version import __version__ as version\n\tasync def connectionInfo(request: Any) -> web.Response:\n\t    response = {\n\t        \"ipAddress\": \"127.0.0.1\",\n\t        \"instanceUid\": \"123456789\",\n\t    }\n\t    return web.Response(content_type=\"application/json\", body=json.dumps(response))\n\tasync def generateClientCertificate(request: Any) -> web.Response:\n\t    response = {\n\t        \"pemCertificate\": \"This is the client cert\",\n", "        \"pemCertificateChain\": [\n\t            \"This is the intermediate cert\",\n\t            \"This is the root cert\",\n\t        ],\n\t    }\n\t    return web.Response(content_type=\"application/json\", body=json.dumps(response))\n\t@pytest.fixture\n\tasync def client(aiohttp_client: Any) -> Any:\n\t    app = web.Application()\n\t    metadata_uri = \"/v1beta/projects/test-project/locations/test-region/clusters/test-cluster/instances/test-instance/connectionInfo\"\n", "    app.router.add_get(metadata_uri, connectionInfo)\n\t    client_cert_uri = \"/v1beta/projects/test-project/locations/test-region/clusters/test-cluster:generateClientCertificate\"\n\t    app.router.add_post(client_cert_uri, generateClientCertificate)\n\t    return await aiohttp_client(app)\n\t@pytest.mark.asyncio\n\tasync def test__get_metadata(client: Any, credentials: FakeCredentials) -> None:\n\t    \"\"\"\n\t    Test _get_metadata returns successfully.\n\t    \"\"\"\n\t    test_client = AlloyDBClient(\"\", \"\", credentials, client)\n", "    ip_address = await test_client._get_metadata(\n\t        \"test-project\",\n\t        \"test-region\",\n\t        \"test-cluster\",\n\t        \"test-instance\",\n\t    )\n\t    assert ip_address == \"127.0.0.1\"\n\t@pytest.mark.asyncio\n\tasync def test__get_client_certificate(\n\t    client: Any, credentials: FakeCredentials\n", ") -> None:\n\t    \"\"\"\n\t    Test _get_client_certificate returns successfully.\n\t    \"\"\"\n\t    test_client = AlloyDBClient(\"\", \"\", credentials, client)\n\t    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t    certs = await test_client._get_client_certificate(\n\t        \"test-project\", \"test-region\", \"test-cluster\", key\n\t    )\n\t    client_cert, cert_chain = certs\n", "    assert client_cert == \"This is the client cert\"\n\t    assert cert_chain[0] == \"This is the intermediate cert\"\n\t    assert cert_chain[1] == \"This is the root cert\"\n\t@pytest.mark.asyncio\n\tasync def test_AlloyDBClient_init_(credentials: FakeCredentials) -> None:\n\t    \"\"\"\n\t    Test to check whether the __init__ method of AlloyDBClient\n\t    can correctly initialize a client.\n\t    \"\"\"\n\t    client = AlloyDBClient(\"www.test-endpoint.com\", \"my-quota-project\", credentials)\n", "    # verify base endpoint is set\n\t    assert client._alloydb_api_endpoint == \"www.test-endpoint.com\"\n\t    # verify proper headers are set\n\t    assert client._client.headers[\"User-Agent\"] == f\"alloydb-python-connector/{version}\"\n\t    assert client._client.headers[\"x-goog-user-project\"] == \"my-quota-project\"\n\t    # close client\n\t    await client.close()\n"]}
{"filename": "tests/unit/conftest.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom mocks import (\n\t    FakeCredentials,\n\t    FakeInstance,\n\t)\n\timport pytest\n\t@pytest.fixture\n\tdef credentials() -> FakeCredentials:\n", "    return FakeCredentials()\n\t@pytest.fixture\n\tdef fake_instance() -> FakeInstance:\n\t    return FakeInstance()\n"]}
{"filename": "google/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\ttry:\n\t    import pkg_resources\n\t    pkg_resources.declare_namespace(__name__)\n\texcept ImportError:\n\t    import pkgutil\n\t    __path__ = pkgutil.extend_path(__path__, __name__)\n"]}
{"filename": "google/cloud/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\ttry:\n\t    import pkg_resources\n\t    pkg_resources.declare_namespace(__name__)\n\texcept ImportError:\n\t    import pkgutil\n\t    __path__ = pkgutil.extend_path(__path__, __name__)\n"]}
{"filename": "google/cloud/alloydb/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\ttry:\n\t    import pkg_resources\n\t    pkg_resources.declare_namespace(__name__)\n\texcept ImportError:\n\t    import pkgutil\n\t    __path__ = pkgutil.extend_path(__path__, __name__)\n"]}
{"filename": "google/cloud/alloydb/connector/instance.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\timport asyncio\n\timport logging\n\tfrom typing import Tuple, TYPE_CHECKING\n\tfrom google.cloud.alloydb.connector.exceptions import RefreshError\n\tfrom google.cloud.alloydb.connector.rate_limiter import AsyncRateLimiter\n\tfrom google.cloud.alloydb.connector.refresh import (\n", "    _is_valid,\n\t    _seconds_until_refresh,\n\t    RefreshResult,\n\t)\n\tif TYPE_CHECKING:\n\t    import ssl\n\t    from cryptography.hazmat.primitives.asymmetric import rsa\n\t    from google.cloud.alloydb.connector.client import AlloyDBClient\n\tlogger = logging.getLogger(name=__name__)\n\tclass Instance:\n", "    \"\"\"\n\t    Manages the information used to connect to the AlloyDB instance.\n\t    Periodically calls the AlloyDB Admin API, automatically refreshing the\n\t    required information approximately 4 minutes before the previous\n\t    certificate expires (every ~56 minutes).\n\t    Args:\n\t        instance_uri (str): The instance URI of the AlloyDB instance.\n\t            ex. projects/<PROJECT>/locations/<REGION>/clusters/<CLUSTER>/instances/<INSTANCE>\n\t        client (AlloyDBClient): Client used to make requests to AlloyDB Admin APIs.\n\t        key (rsa.RSAPrivateKey): Client private key used in refresh operation\n", "            to generate client certificate.\n\t    \"\"\"\n\t    def __init__(\n\t        self, instance_uri: str, client: AlloyDBClient, key: rsa.RSAPrivateKey\n\t    ) -> None:\n\t        # validate and parse instance_uri\n\t        instance_uri_split = instance_uri.split(\"/\")\n\t        # should take form \"projects/<PROJECT>/locations/<REGION>/clusters/<CLUSTER>/instances/<INSTANCE>\"\n\t        if len(instance_uri_split) == 8:\n\t            self._instance_uri = instance_uri\n", "            self._project = instance_uri_split[1]\n\t            self._region = instance_uri_split[3]\n\t            self._cluster = instance_uri_split[5]\n\t            self._name = instance_uri_split[7]\n\t        else:\n\t            raise ValueError(\n\t                \"Arg `instance_uri` must have \"\n\t                \"format: projects/<PROJECT>/locations/<REGION>/clusters/<CLUSTER>/instances/<INSTANCE>, \"\n\t                f\"got {instance_uri}.\"\n\t            )\n", "        self._client = client\n\t        self._key = key\n\t        self._refresh_rate_limiter = AsyncRateLimiter(\n\t            max_capacity=2,\n\t            rate=1 / 30,\n\t        )\n\t        self._refresh_in_progress = asyncio.locks.Event()\n\t        # For the initial refresh operation, set current = next so that\n\t        # connection requests block until the first refresh is complete.\n\t        self._current: asyncio.Task = self._schedule_refresh(0)\n", "        self._next: asyncio.Task = self._current\n\t    async def _perform_refresh(self) -> RefreshResult:\n\t        \"\"\"\n\t        Perform a refresh operation on an AlloyDB instance.\n\t        Retrieves metadata and generates new client certificate\n\t        required to connect securely to the AlloyDB instance.\n\t        Returns:\n\t            RefreshResult: Result of the refresh operation.\n\t        \"\"\"\n\t        self._refresh_in_progress.set()\n", "        logger.debug(f\"['{self._instance_uri}']: Entered _perform_refresh\")\n\t        try:\n\t            await self._refresh_rate_limiter.acquire()\n\t            # fetch metadata\n\t            metadata_task = asyncio.create_task(\n\t                self._client._get_metadata(\n\t                    self._project,\n\t                    self._region,\n\t                    self._cluster,\n\t                    self._name,\n", "                )\n\t            )\n\t            # generate client and CA certs\n\t            certs_task = asyncio.create_task(\n\t                self._client._get_client_certificate(\n\t                    self._project,\n\t                    self._region,\n\t                    self._cluster,\n\t                    self._key,\n\t                )\n", "            )\n\t            ip_addr, certs = await asyncio.gather(metadata_task, certs_task)\n\t        except Exception:\n\t            logger.debug(\n\t                f\"['{self._instance_uri}']: Error occurred during _perform_refresh.\"\n\t            )\n\t            raise\n\t        finally:\n\t            self._refresh_in_progress.clear()\n\t        return RefreshResult(ip_addr, self._key, certs)\n", "    def _schedule_refresh(self, delay: int) -> asyncio.Task:\n\t        \"\"\"\n\t        Schedule a refresh operation.\n\t        Args:\n\t            delay (int): Time in seconds to sleep before performing refresh.\n\t        Returns:\n\t            asyncio.Task[RefreshResult]: A task representing the scheduled\n\t                refresh operation.\n\t        \"\"\"\n\t        return asyncio.create_task(self._refresh_operation(delay))\n", "    async def _refresh_operation(self, delay: int) -> RefreshResult:\n\t        \"\"\"\n\t        A coroutine that sleeps for the specified amount of time before\n\t        running _perform_refresh.\n\t        Args:\n\t            delay (int): Time in seconds to sleep before performing refresh.\n\t        Returns:\n\t            RefreshResult: Refresh result for an AlloyDB instance.\n\t        \"\"\"\n\t        refresh_task: asyncio.Task\n", "        try:\n\t            if delay > 0:\n\t                logger.debug(f\"['{self._instance_uri}']: Entering sleep\")\n\t                await asyncio.sleep(delay)\n\t            refresh_task = asyncio.create_task(self._perform_refresh())\n\t            refresh_result = await refresh_task\n\t            # check that refresh is valid\n\t            if not await _is_valid(refresh_task):\n\t                raise RefreshError(\n\t                    f\"['{self._instance_uri}']: Invalid refresh operation. Certficate appears to be expired.\"\n", "                )\n\t        # bad refresh attempt\n\t        except Exception:\n\t            logger.info(\n\t                f\"['{self._instance_uri}']: \"\n\t                \"An error occurred while performing refresh. \"\n\t                \"Scheduling another refresh attempt immediately\"\n\t            )\n\t            # check if current refresh result is invalid (expired),\n\t            # don't want to replace valid result with invalid refresh\n", "            if not await _is_valid(self._current):\n\t                self._current = refresh_task\n\t            # schedule new refresh attempt immediately\n\t            self._next = self._schedule_refresh(0)\n\t            raise\n\t        # if valid refresh, replace current with valid refresh result and schedule next refresh\n\t        self._current = refresh_task\n\t        # calculate refresh delay based on certificate expiration\n\t        delay = _seconds_until_refresh(refresh_result.expiration)\n\t        self._next = self._schedule_refresh(delay)\n", "        return refresh_result\n\t    def force_refresh(self) -> None:\n\t        \"\"\"\n\t        Schedules a new refresh operation immediately to be used\n\t        for future connection attempts.\n\t        \"\"\"\n\t        # if next refresh is not already in progress, cancel it and schedule new one immediately\n\t        if not self._refresh_in_progress.is_set():\n\t            self._next.cancel()\n\t            self._next = self._schedule_refresh(0)\n", "        # block all sequential connection attempts on the next refresh result\n\t        self._current = self._next\n\t    async def connection_info(self) -> Tuple[str, ssl.SSLContext]:\n\t        \"\"\"\n\t        Return connection info for current refresh result.\n\t        Returns:\n\t            Tuple[str, ssl.SSLContext]: AlloyDB instance IP address\n\t                and configured TLS connection.\n\t        \"\"\"\n\t        refresh: RefreshResult = await self._current\n", "        return refresh.instance_ip, refresh.context\n\t    async def close(self) -> None:\n\t        \"\"\"\n\t        Cancel refresh tasks.\n\t        \"\"\"\n\t        logger.debug(f\"['{self._instance_uri}']: Waiting for _current to be cancelled\")\n\t        self._current.cancel()\n\t        logger.debug(f\"['{self._instance_uri}']: Waiting for _next to be cancelled\")\n\t        self._next.cancel()\n\t        # gracefully wait for tasks to cancel\n", "        tasks = asyncio.gather(self._current, self._next, return_exceptions=True)\n\t        await asyncio.wait_for(tasks, timeout=2.0)\n"]}
{"filename": "google/cloud/alloydb/connector/version.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t__version__ = \"0.1.3-dev\"\n"]}
{"filename": "google/cloud/alloydb/connector/rate_limiter.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport asyncio\n\tclass AsyncRateLimiter(object):\n\t    \"\"\"\n\t    An asyncio-compatible rate limiter.\n\t    Uses the Token Bucket algorithm (https://en.wikipedia.org/wiki/Token_bucket)\n\t    to limit the number of function calls over a time interval using an event queue.\n\t    Args:\n", "        max_capacity (int): The maximum capacity of tokens the bucket\n\t            will store at any one time. Defaults to 1.\n\t        rate (float): The number of tokens that should be added per second.\n\t            Defaults to 1 / 60.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        max_capacity: int = 1,\n\t        rate: float = 1 / 60,\n\t    ) -> None:\n", "        self._rate = rate\n\t        self._max_capacity = max_capacity\n\t        self._loop = asyncio.get_running_loop()\n\t        self._tokens: float = max_capacity\n\t        self._last_token_update = self._loop.time()\n\t        self._lock = asyncio.Lock()\n\t    def _update_token_count(self) -> None:\n\t        \"\"\"\n\t        Calculates how much time has passed since the last leak and removes the\n\t        appropriate amount of events from the queue.\n", "        Leaking is done lazily, meaning that if there is a large time gap between\n\t        leaks, the next set of calls might be a burst if burst_size > 1\n\t        \"\"\"\n\t        now = self._loop.time()\n\t        time_elapsed = now - self._last_token_update\n\t        new_tokens = time_elapsed * self._rate\n\t        self._tokens = min(new_tokens + self._tokens, self._max_capacity)\n\t        self._last_token_update = now\n\t    async def _wait_for_next_token(self) -> None:\n\t        \"\"\"\n", "        Wait until enough time has elapsed to add another token.\n\t        \"\"\"\n\t        token_deficit = 1 - self._tokens\n\t        if token_deficit > 0:\n\t            wait_time = token_deficit / self._rate\n\t            await asyncio.sleep(wait_time)\n\t    async def acquire(self) -> None:\n\t        \"\"\"\n\t        Waits for a token to become available, if necessary, then subtracts token and allows\n\t        request to go through.\n", "        \"\"\"\n\t        async with self._lock:\n\t            self._update_token_count()\n\t            if self._tokens < 1:\n\t                await self._wait_for_next_token()\n\t                self._update_token_count()\n\t            self._tokens -= 1\n"]}
{"filename": "google/cloud/alloydb/connector/client.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\timport logging\n\tfrom typing import List, Optional, Tuple, TYPE_CHECKING\n\timport aiohttp\n\tfrom cryptography.hazmat.primitives import serialization\n\tfrom google.auth.transport.requests import Request\n\tfrom google.cloud.alloydb.connector.utils import _create_certificate_request\n", "from google.cloud.alloydb.connector.version import __version__ as version\n\tif TYPE_CHECKING:\n\t    from cryptography.hazmat.primitives.asymmetric import rsa\n\t    from google.auth.credentials import Credentials\n\tUSER_AGENT: str = f\"alloydb-python-connector/{version}\"\n\tAPI_VERSION: str = \"v1beta\"\n\tlogger = logging.getLogger(name=__name__)\n\tclass AlloyDBClient:\n\t    def __init__(\n\t        self,\n", "        alloydb_api_endpoint: str,\n\t        quota_project: Optional[str],\n\t        credentials: Credentials,\n\t        client: Optional[aiohttp.ClientSession] = None,\n\t    ) -> None:\n\t        \"\"\"\n\t        Establish the client to be used for AlloyDB Admin API requests.\n\t        Args:\n\t            alloydb_api_endpoint (str): Base URL to use when calling\n\t                the AlloyDB API endpoint.\n", "            quota_project (str): The Project ID for an existing Google Cloud\n\t                project. The project specified is used for quota and\n\t                billing purposes.\n\t            credentials (google.auth.credentials.Credentials):\n\t                A credentials object created from the google-auth Python library.\n\t                Must have the AlloyDB Admin scopes. For more info check out\n\t                https://google-auth.readthedocs.io/en/latest/.\n\t            client (aiohttp.ClientSession): Async client used to make requests to\n\t                AlloyDB Admin APIs.\n\t                Optional, defaults to None and creates new client.\n", "        \"\"\"\n\t        headers = {\n\t            \"x-goog-api-client\": USER_AGENT,\n\t            \"User-Agent\": USER_AGENT,\n\t            \"Content-Type\": \"application/json\",\n\t        }\n\t        if quota_project:\n\t            headers[\"x-goog-user-project\"] = quota_project\n\t        self._client = client if client else aiohttp.ClientSession(headers=headers)\n\t        self._credentials = credentials\n", "        self._alloydb_api_endpoint = alloydb_api_endpoint\n\t    async def _get_metadata(\n\t        self,\n\t        project: str,\n\t        region: str,\n\t        cluster: str,\n\t        name: str,\n\t    ) -> str:\n\t        \"\"\"\n\t        Fetch the metadata for a given AlloyDB instance.\n", "        Call the AlloyDB Admin APIs connectInfo method to retrieve the\n\t        information about an AlloyDB instance that is used to create secure\n\t        connections.\n\t        Args:\n\t            project (str): Google Cloud project ID that the AlloyDB instance\n\t                resides in.\n\t            region (str): Google Cloud region of the AlloyDB instance.\n\t            cluster (str): The name of the AlloyDB cluster.\n\t            name (str): The name of the AlloyDB instance.\n\t        Returns:\n", "            str: IP address of the AlloyDB instance.\n\t        \"\"\"\n\t        logger.debug(f\"['{project}/{region}/{cluster}/{name}']: Requesting metadata\")\n\t        if not self._credentials.valid:\n\t            request = Request()\n\t            self._credentials.refresh(request)\n\t        headers = {\n\t            \"Authorization\": f\"Bearer {self._credentials.token}\",\n\t        }\n\t        url = f\"{self._alloydb_api_endpoint}/{API_VERSION}/projects/{project}/locations/{region}/clusters/{cluster}/instances/{name}/connectionInfo\"\n", "        resp = await self._client.get(url, headers=headers, raise_for_status=True)\n\t        resp_dict = await resp.json()\n\t        return resp_dict[\"ipAddress\"]\n\t    async def _get_client_certificate(\n\t        self,\n\t        project: str,\n\t        region: str,\n\t        cluster: str,\n\t        key: rsa.RSAPrivateKey,\n\t    ) -> Tuple[str, List[str]]:\n", "        \"\"\"\n\t        Fetch a client certificate for the given AlloyDB cluster.\n\t        Call the AlloyDB Admin API's generateClientCertificate\n\t        method to create a signed TLS certificate that is authorized to connect via the\n\t        AlloyDB instance's serverside proxy. The cert is valid for twenty-four hours.\n\t        Args:\n\t            project (str): Google Cloud project ID that the AlloyDB instance\n\t                resides in.\n\t            region (str): Google Cloud region of the AlloyDB instance.\n\t            cluster (str): The name of the AlloyDB cluster.\n", "            key (rsa.RSAPrivateKey): Client private key used in refresh operation\n\t                to generate client certificate.\n\t        Returns:\n\t            Tuple[str, list[str]]: Tuple containing the client certificate\n\t                and certificate chain for the AlloyDB instance.\n\t        \"\"\"\n\t        logger.debug(f\"['{project}/{region}/{cluster}']: Requesting client certificate\")\n\t        if not self._credentials.valid:\n\t            request = Request()\n\t            self._credentials.refresh(request)\n", "        headers = {\n\t            \"Authorization\": f\"Bearer {self._credentials.token}\",\n\t        }\n\t        url = f\"{self._alloydb_api_endpoint}/{API_VERSION}/projects/{project}/locations/{region}/clusters/{cluster}:generateClientCertificate\"\n\t        # create the certificate signing request\n\t        csr = _create_certificate_request(key)\n\t        csr_str = csr.public_bytes(encoding=serialization.Encoding.PEM).decode(\"utf-8\")\n\t        data = {\n\t            \"pemCsr\": csr_str,\n\t            \"certDuration\": \"3600s\",\n", "        }\n\t        resp = await self._client.post(\n\t            url, headers=headers, json=data, raise_for_status=True\n\t        )\n\t        resp_dict = await resp.json()\n\t        return (resp_dict[\"pemCertificate\"], resp_dict[\"pemCertificateChain\"])\n\t    async def close(self) -> None:\n\t        \"\"\"Close AlloyDBClient gracefully.\"\"\"\n\t        await self._client.close()\n"]}
{"filename": "google/cloud/alloydb/connector/__init__.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom .connector import Connector\n\t__ALL__ = [Connector]\n\ttry:\n\t    import pkg_resources\n\t    pkg_resources.declare_namespace(__name__)\n\texcept ImportError:\n\t    import pkgutil\n", "    __path__ = pkgutil.extend_path(__path__, __name__)\n"]}
{"filename": "google/cloud/alloydb/connector/connector.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\timport asyncio\n\tfrom functools import partial\n\tfrom threading import Thread\n\tfrom types import TracebackType\n\tfrom typing import Any, Dict, Optional, Type, TYPE_CHECKING\n\tfrom cryptography.hazmat.primitives.asymmetric import rsa\n", "from google.auth import default\n\tfrom google.auth.credentials import with_scopes_if_required\n\tfrom google.cloud.alloydb.connector.client import AlloyDBClient\n\tfrom google.cloud.alloydb.connector.instance import Instance\n\timport google.cloud.alloydb.connector.pg8000 as pg8000\n\tif TYPE_CHECKING:\n\t    from google.auth.credentials import Credentials\n\tclass Connector:\n\t    \"\"\"A class to configure and create connections to Cloud SQL instances.\n\t    Args:\n", "        credentials (google.auth.credentials.Credentials):\n\t            A credentials object created from the google-auth Python library.\n\t            If not specified, Application Default Credentials are used.\n\t        quota_project (str): The Project ID for an existing Google Cloud\n\t            project. The project specified is used for quota and\n\t            billing purposes.\n\t            Defaults to None, picking up project from environment.\n\t        alloydb_api_endpoint (str): Base URL to use when calling\n\t            the AlloyDB API endpoint. Defaults to \"https://alloydb.googleapis.com\".\n\t    \"\"\"\n", "    def __init__(\n\t        self,\n\t        credentials: Optional[Credentials] = None,\n\t        quota_project: Optional[str] = None,\n\t        alloydb_api_endpoint: str = \"https://alloydb.googleapis.com\",\n\t    ) -> None:\n\t        # create event loop and start it in background thread\n\t        self._loop: asyncio.AbstractEventLoop = asyncio.new_event_loop()\n\t        self._thread = Thread(target=self._loop.run_forever, daemon=True)\n\t        self._thread.start()\n", "        self._instances: Dict[str, Instance] = {}\n\t        # initialize default params\n\t        self._quota_project = quota_project\n\t        self._alloydb_api_endpoint = alloydb_api_endpoint\n\t        # initialize credentials\n\t        scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n\t        if credentials:\n\t            self._credentials = with_scopes_if_required(credentials, scopes=scopes)\n\t        # otherwise use application default credentials\n\t        else:\n", "            self._credentials, _ = default(scopes=scopes)\n\t        self._key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n\t        self._client: Optional[AlloyDBClient] = None\n\t    def connect(self, instance_uri: str, driver: str, **kwargs: Any) -> Any:\n\t        \"\"\"\n\t        Prepares and returns a database DBAPI connection object.\n\t        Starts background tasks to refresh the certificates and get\n\t        AlloyDB instance IP address. Creates a secure TLS connection\n\t        to establish connection to AlloyDB instance.\n\t        Args:\n", "            instance_uri (str): The instance URI of the AlloyDB instance.\n\t                ex. projects/<PROJECT>/locations/<REGION>/clusters/<CLUSTER>/instances/<INSTANCE>\n\t            driver (str): A string representing the database driver to connect with.\n\t                Supported drivers are pg8000.\n\t            **kwargs: Pass in any database driver-specific arguments needed\n\t                to fine tune connection.\n\t        Returns:\n\t            connection: A DBAPI connection to the specified AlloyDB instance.\n\t        \"\"\"\n\t        # call async connect and wait on result\n", "        connect_task = asyncio.run_coroutine_threadsafe(\n\t            self.connect_async(instance_uri, driver, **kwargs), self._loop\n\t        )\n\t        return connect_task.result()\n\t    async def connect_async(self, instance_uri: str, driver: str, **kwargs: Any) -> Any:\n\t        \"\"\"\n\t        Asynchronously prepares and returns a database connection object.\n\t        Starts tasks to refresh the certificates and get\n\t        AlloyDB instance IP address. Creates a secure TLS connection\n\t        to establish connection to AlloyDB instance.\n", "        Args:\n\t            instance_uri (str): The instance URI of the AlloyDB instance.\n\t                ex. projects/<PROJECT>/locations/<REGION>/clusters/<CLUSTER>/instances/<INSTANCE>\n\t            driver (str): A string representing the database driver to connect with.\n\t                Supported drivers are pg8000.\n\t            **kwargs: Pass in any database driver-specific arguments needed\n\t                to fine tune connection.\n\t        Returns:\n\t            connection: A DBAPI connection to the specified AlloyDB instance.\n\t        \"\"\"\n", "        if self._client is None:\n\t            # lazy init client as it has to be initialized in async context\n\t            self._client = AlloyDBClient(\n\t                self._alloydb_api_endpoint, self._quota_project, self._credentials\n\t            )\n\t        # use existing connection info if possible\n\t        if instance_uri in self._instances:\n\t            instance = self._instances[instance_uri]\n\t        else:\n\t            instance = Instance(\n", "                instance_uri,\n\t                self._client,\n\t                self._key,\n\t            )\n\t            self._instances[instance_uri] = instance\n\t        connect_func = {\n\t            \"pg8000\": pg8000.connect,\n\t        }\n\t        # only accept supported database drivers\n\t        try:\n", "            connector = connect_func[driver]\n\t        except KeyError:\n\t            raise ValueError(f\"Driver '{driver}' is not a supported database driver.\")\n\t        # Host and ssl options come from the certificates and instance IP address\n\t        # so we don't want the user to specify them.\n\t        kwargs.pop(\"host\", None)\n\t        kwargs.pop(\"ssl\", None)\n\t        kwargs.pop(\"port\", None)\n\t        # get connection info for AlloyDB instance\n\t        ip_address, context = await instance.connection_info()\n", "        # synchronous drivers are blocking and run using executor\n\t        try:\n\t            connect_partial = partial(connector, ip_address, context, **kwargs)\n\t            return await self._loop.run_in_executor(None, connect_partial)\n\t        except Exception:\n\t            # we attempt a force refresh, then throw the error\n\t            instance.force_refresh()\n\t            raise\n\t    def __enter__(self) -> \"Connector\":\n\t        \"\"\"Enter context manager by returning Connector object\"\"\"\n", "        return self\n\t    def __exit__(\n\t        self,\n\t        exc_type: Optional[Type[BaseException]],\n\t        exc_val: Optional[BaseException],\n\t        exc_tb: Optional[TracebackType],\n\t    ) -> None:\n\t        \"\"\"Exit context manager by closing Connector\"\"\"\n\t        self.close()\n\t    def close(self) -> None:\n", "        \"\"\"Close Connector by stopping tasks and releasing resources.\"\"\"\n\t        close_future = asyncio.run_coroutine_threadsafe(\n\t            self.close_async(), loop=self._loop\n\t        )\n\t        # Will attempt to gracefully shut down tasks for 3s\n\t        close_future.result(timeout=3)\n\t        # if background thread exists for Connector, clean it up\n\t        if self._thread:\n\t            # stop event loop running in background thread\n\t            self._loop.call_soon_threadsafe(self._loop.stop)\n", "            # wait for thread to finish closing (i.e. loop to stop)\n\t            self._thread.join()\n\t    async def close_async(self) -> None:\n\t        \"\"\"Helper function to cancel Instances' tasks\n\t        and close client.\"\"\"\n\t        await asyncio.gather(\n\t            *[instance.close() for instance in self._instances.values()]\n\t        )\n\t        if self._client:\n\t            await self._client.close()\n"]}
{"filename": "google/cloud/alloydb/connector/utils.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\tfrom typing import List, Tuple, TYPE_CHECKING\n\tfrom cryptography import x509\n\tfrom cryptography.hazmat.primitives import hashes, serialization\n\tfrom cryptography.x509.oid import NameOID\n\tif TYPE_CHECKING:\n\t    from cryptography.hazmat.primitives.asymmetric import rsa\n", "def _write_to_file(\n\t    dir_path: str, cert_chain: List[str], client_cert: str, key: rsa.RSAPrivateKey\n\t) -> Tuple[str, str, str]:\n\t    \"\"\"\n\t    Helper function to write the server_ca, client certificate and\n\t    private key to .pem files in a given directory.\n\t    \"\"\"\n\t    ca_filename = f\"{dir_path}/ca.pem\"\n\t    cert_chain_filename = f\"{dir_path}/chain.pem\"\n\t    key_filename = f\"{dir_path}/priv.pem\"\n", "    key_bytes = key.private_bytes(\n\t        encoding=serialization.Encoding.PEM,\n\t        format=serialization.PrivateFormat.TraditionalOpenSSL,\n\t        encryption_algorithm=serialization.NoEncryption(),\n\t    )\n\t    # add client cert to beginning of cert chain\n\t    full_chain = [client_cert] + cert_chain\n\t    with open(ca_filename, \"w+\") as ca_out:\n\t        ca_out.write(\"\".join(cert_chain))\n\t    with open(cert_chain_filename, \"w+\") as chain_out:\n", "        chain_out.write(\"\".join(full_chain))\n\t    with open(key_filename, \"wb\") as priv_out:\n\t        priv_out.write(key_bytes)\n\t    return (ca_filename, cert_chain_filename, key_filename)\n\tdef _create_certificate_request(\n\t    private_key: rsa.RSAPrivateKey,\n\t) -> x509.CertificateSigningRequest:\n\t    csr = (\n\t        x509.CertificateSigningRequestBuilder()\n\t        .subject_name(\n", "            x509.Name(\n\t                [\n\t                    x509.NameAttribute(NameOID.COMMON_NAME, \"alloydb-connector\"),\n\t                    x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n\t                    x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"CA\"),\n\t                    x509.NameAttribute(NameOID.LOCALITY_NAME, \"Sunnyvale\"),\n\t                    x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Google LLC\"),\n\t                    x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, \"Cloud\"),\n\t                ]\n\t            )\n", "        )\n\t        .sign(private_key, hashes.SHA256())\n\t    )\n\t    return csr\n"]}
{"filename": "google/cloud/alloydb/connector/pg8000.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport ssl\n\tfrom typing import Any, TYPE_CHECKING\n\tSERVER_PROXY_PORT = 5433\n\tif TYPE_CHECKING:\n\t    import pg8000\n\tdef connect(\n\t    ip_address: str, ctx: ssl.SSLContext, **kwargs: Any\n", ") -> \"pg8000.dbapi.Connection\":\n\t    \"\"\"Create a pg8000 DBAPI connection object.\n\t    Args:\n\t        ip_address (str): IP address of AlloyDB instance to connect to.\n\t        ctx (ssl.SSLContext): Context used to create a TLS connection\n\t            with AlloyDB instance ssl certificates.\n\t    Returns:\n\t        pg8000.dbapi.Connection: A pg8000 Connection object for\n\t        the AlloyDB instance.\n\t    \"\"\"\n", "    # Connecting through pg8000 is done by passing in an SSL Context and setting the\n\t    # \"request_ssl\" attr to false. This works because when \"request_ssl\" is false,\n\t    # the driver skips the database level SSL/TLS exchange, but still uses the\n\t    # ssl_context (if it is not None) to create the connection.\n\t    try:\n\t        import pg8000\n\t    except ImportError:\n\t        raise ImportError(\n\t            'Unable to import module \"pg8000.\" Please install and try again.'\n\t        )\n", "    user = kwargs.pop(\"user\")\n\t    db = kwargs.pop(\"db\")\n\t    passwd = kwargs.pop(\"password\")\n\t    setattr(ctx, \"request_ssl\", False)\n\t    return pg8000.dbapi.connect(\n\t        user,\n\t        database=db,\n\t        password=passwd,\n\t        host=ip_address,\n\t        port=SERVER_PROXY_PORT,\n", "        ssl_context=ctx,\n\t        **kwargs,\n\t    )\n"]}
{"filename": "google/cloud/alloydb/connector/exceptions.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tclass RefreshError(Exception):\n\t    pass\n"]}
{"filename": "google/cloud/alloydb/connector/refresh.py", "chunked_list": ["# Copyright 2023 Google LLC\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom __future__ import annotations\n\timport asyncio\n\tfrom datetime import datetime\n\timport logging\n\timport ssl\n\tfrom tempfile import TemporaryDirectory\n\tfrom typing import List, Tuple, TYPE_CHECKING\n", "from cryptography import x509\n\tfrom google.cloud.alloydb.connector.utils import _write_to_file\n\tif TYPE_CHECKING:\n\t    from cryptography.hazmat.primitives.asymmetric import rsa\n\tlogger = logging.getLogger(name=__name__)\n\t# _refresh_buffer is the amount of time before a refresh's result expires\n\t# that a new refresh operation begins.\n\t_refresh_buffer: int = 4 * 60  # 4 minutes\n\tdef _seconds_until_refresh(expiration: datetime, now: datetime = datetime.now()) -> int:\n\t    \"\"\"\n", "    Calculates the duration to wait before starting the next refresh.\n\t    Usually the duration will be half of the time until certificate\n\t    expiration.\n\t    Args:\n\t        expiration (datetime.datetime): Time of certificate expiration.\n\t        now (datetime.datetime): Current time. Defaults to datetime.now()\n\t    Returns:\n\t        int: Time in seconds to wait before performing next refresh.\n\t    \"\"\"\n\t    duration = int((expiration - now).total_seconds())\n", "    # if certificate duration is less than 1 hour\n\t    if duration < 3600:\n\t        # something is wrong with certificate, refresh now\n\t        if duration < _refresh_buffer:\n\t            return 0\n\t        # otherwise wait until 4 minutes before expiration for next refresh\n\t        return duration - _refresh_buffer\n\t    return duration // 2\n\tclass RefreshResult:\n\t    \"\"\"\n", "    Manages the result of a refresh operation.\n\t    Holds the certificates and IP address of an AlloyDB instance.\n\t    Builds the TLS context required to connect to AlloyDB database.\n\t    Args:\n\t        instance_ip (str): The IP address of the AlloyDB instance.\n\t        key (rsa.RSAPrivateKey): Private key for the client connection.\n\t        certs (Tuple[str, List(str)]): Client cert and CA certs for establishing\n\t            the chain of trust used in building the TLS context.\n\t    \"\"\"\n\t    def __init__(\n", "        self, instance_ip: str, key: rsa.RSAPrivateKey, certs: Tuple[str, List[str]]\n\t    ) -> None:\n\t        self.instance_ip = instance_ip\n\t        self._key = key\n\t        self._certs = certs\n\t        # create TLS context\n\t        self.context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\t        # update ssl.PROTOCOL_TLS_CLIENT default\n\t        self.context.check_hostname = False\n\t        # force TLSv1.3\n", "        self.context.minimum_version = ssl.TLSVersion.TLSv1_3\n\t        # add request_ssl attribute to ssl.SSLContext, required for pg8000 driver\n\t        self.context.request_ssl = False  # type: ignore\n\t        client_cert, cert_chain = self._certs\n\t        # get expiration from client certificate\n\t        cert_obj = x509.load_pem_x509_certificate(client_cert.encode(\"UTF-8\"))\n\t        self.expiration = cert_obj.not_valid_after\n\t        # tmpdir and its contents are automatically deleted after the CA cert\n\t        # and cert chain are loaded into the SSLcontext. The values\n\t        # need to be written to files in order to be loaded by the SSLContext\n", "        with TemporaryDirectory() as tmpdir:\n\t            ca_filename, cert_chain_filename, key_filename = _write_to_file(\n\t                tmpdir, cert_chain, client_cert, self._key\n\t            )\n\t            self.context.load_cert_chain(cert_chain_filename, keyfile=key_filename)\n\t            self.context.load_verify_locations(cafile=ca_filename)\n\tasync def _is_valid(task: asyncio.Task) -> bool:\n\t    try:\n\t        result = await task\n\t        # valid if current time is before cert expiration\n", "        if datetime.now() < result.expiration:\n\t            return True\n\t    except Exception:\n\t        # suppress any errors from task\n\t        logger.debug(\"Current refresh result is invalid.\")\n\t    return False\n"]}
