{"filename": "badger_os/launcher.py", "chunked_list": ["import gc\n\timport os\n\timport time\n\timport math\n\timport badger2040\n\timport badger_os\n\timport jpegdec\n\tAPP_DIR = \"/examples\"\n\tFONT_SIZE = 2\n\tchanged = False\n", "exited_to_launcher = False\n\twoken_by_button = badger2040.woken_by_button()  # Must be done before we clear_pressed_to_wake\n\tif badger2040.pressed_to_wake(badger2040.BUTTON_A) and badger2040.pressed_to_wake(badger2040.BUTTON_C):\n\t    # Pressing A and C together at start quits app\n\t    exited_to_launcher = badger_os.state_clear_running()\n\t    badger2040.reset_pressed_to_wake()\n\telse:\n\t    # Otherwise restore previously running app\n\t    badger_os.state_launch()\n\tdisplay = badger2040.Badger2040()\n", "display.set_font(\"bitmap8\")\n\tdisplay.led(128)\n\tjpeg = jpegdec.JPEG(display.display)\n\tstate = {\n\t    \"page\": 0,\n\t    \"running\": \"launcher\"\n\t}\n\tbadger_os.state_load(\"launcher\", state)\n\texamples = [x[:-3] for x in os.listdir(\"/examples\") if x.endswith(\".py\")]\n\t# Approximate center lines for buttons A, B and C\n", "centers = (41, 147, 253)\n\tMAX_PAGE = math.ceil(len(examples) / 3)\n\tWIDTH = 296\n\tdef map_value(input, in_min, in_max, out_min, out_max):\n\t    return (((input - in_min) * (out_max - out_min)) / (in_max - in_min)) + out_min\n\tdef draw_disk_usage(x):\n\t    _, f_used, _ = badger_os.get_disk_usage()\n\t    display.set_pen(15)\n\t    display.image(\n\t        bytearray(\n", "            (\n\t                0b00000000,\n\t                0b00111100,\n\t                0b00111100,\n\t                0b00111100,\n\t                0b00111000,\n\t                0b00000000,\n\t                0b00000000,\n\t                0b00000001,\n\t            )\n", "        ),\n\t        8,\n\t        8,\n\t        x,\n\t        4,\n\t    )\n\t    display.rectangle(x + 10, 3, 80, 10)\n\t    display.set_pen(0)\n\t    display.rectangle(x + 11, 4, 78, 8)\n\t    display.set_pen(15)\n", "    display.rectangle(x + 12, 5, int(76 / 100.0 * f_used), 6)\n\t    display.text(\"{:.2f}%\".format(f_used), x + 91, 4, WIDTH, 1.0)\n\tdef render():\n\t    display.set_pen(15)\n\t    display.clear()\n\t    display.set_pen(0)\n\t    max_icons = min(3, len(examples[(state[\"page\"] * 3):]))\n\t    for i in range(max_icons):\n\t        x = centers[i]\n\t        label = examples[i + (state[\"page\"] * 3)]\n", "        icon_label = label.replace(\"_\", \"-\")\n\t        icon = f\"{APP_DIR}/icon-{icon_label}.jpg\"\n\t        label = label.replace(\"_\", \" \")\n\t        jpeg.open_file(icon)\n\t        jpeg.decode(x - 26, 30)\n\t        display.set_pen(0)\n\t        w = display.measure_text(label, FONT_SIZE)\n\t        display.text(label, int(x - (w / 2)), 16 + 80, WIDTH, FONT_SIZE)\n\t    for i in range(MAX_PAGE):\n\t        x = 286\n", "        y = int((128 / 2) - (MAX_PAGE * 10 / 2) + (i * 10))\n\t        display.set_pen(0)\n\t        display.rectangle(x, y, 8, 8)\n\t        if state[\"page\"] != i:\n\t            display.set_pen(15)\n\t            display.rectangle(x + 1, y + 1, 6, 6)\n\t    display.set_pen(0)\n\t    display.rectangle(0, 0, WIDTH, 16)\n\t    draw_disk_usage(90)\n\t    display.set_pen(15)\n", "    display.text(\"badgerOS\", 4, 4, WIDTH, 1.0)\n\t    display.update()\n\tdef wait_for_user_to_release_buttons():\n\t    while display.pressed_any():\n\t        time.sleep(0.01)\n\tdef launch_example(index):\n\t    wait_for_user_to_release_buttons()\n\t    file = examples[(state[\"page\"] * 3) + index]\n\t    file = f\"{APP_DIR}/{file}\"\n\t    for k in locals().keys():\n", "        if k not in (\"gc\", \"file\", \"badger_os\"):\n\t            del locals()[k]\n\t    gc.collect()\n\t    badger_os.launch(file)\n\tdef button(pin):\n\t    global changed\n\t    changed = True\n\t    if pin == badger2040.BUTTON_A:\n\t        launch_example(0)\n\t    if pin == badger2040.BUTTON_B:\n", "        launch_example(1)\n\t    if pin == badger2040.BUTTON_C:\n\t        launch_example(2)\n\t    if pin == badger2040.BUTTON_UP:\n\t        if state[\"page\"] > 0:\n\t            state[\"page\"] -= 1\n\t        render()\n\t    if pin == badger2040.BUTTON_DOWN:\n\t        if state[\"page\"] < MAX_PAGE - 1:\n\t            state[\"page\"] += 1\n", "        render()\n\tif exited_to_launcher or not woken_by_button:\n\t    wait_for_user_to_release_buttons()\n\t    display.set_update_speed(badger2040.UPDATE_MEDIUM)\n\t    render()\n\tdisplay.set_update_speed(badger2040.UPDATE_FAST)\n\twhile True:\n\t    # Sometimes a button press or hold will keep the system\n\t    # powered *through* HALT, so latch the power back on.\n\t    display.keepalive()\n", "    if display.pressed(badger2040.BUTTON_A):\n\t        button(badger2040.BUTTON_A)\n\t    if display.pressed(badger2040.BUTTON_B):\n\t        button(badger2040.BUTTON_B)\n\t    if display.pressed(badger2040.BUTTON_C):\n\t        button(badger2040.BUTTON_C)\n\t    if display.pressed(badger2040.BUTTON_UP):\n\t        button(badger2040.BUTTON_UP)\n\t    if display.pressed(badger2040.BUTTON_DOWN):\n\t        button(badger2040.BUTTON_DOWN)\n", "    if changed:\n\t        badger_os.state_save(\"launcher\", state)\n\t        changed = False\n\t    display.halt()\n"]}
{"filename": "badger_os/main.py", "chunked_list": ["import launcher  # noqa F401\n"]}
{"filename": "badger_os/WIFI_CONFIG.py", "chunked_list": ["SSID = \"\"\n\tPSK = \"\"\n\tCOUNTRY = \"\"\n"]}
{"filename": "badger_os/examples/help.py", "chunked_list": ["import badger2040\n\tfrom badger2040 import WIDTH\n\tTEXT_SIZE = 0.45\n\tLINE_HEIGHT = 20\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\tdisplay.set_thickness(2)\n\t# Clear to white\n\tdisplay.set_pen(15)\n\tdisplay.clear()\n", "display.set_font(\"bitmap8\")\n\tdisplay.set_pen(0)\n\tdisplay.rectangle(0, 0, WIDTH, 16)\n\tdisplay.set_pen(15)\n\tdisplay.text(\"badgerOS\", 3, 4, WIDTH, 1)\n\tdisplay.text(\"help\", WIDTH - display.measure_text(\"help\", 0.4) - 4, 4, WIDTH, 1)\n\tdisplay.set_font(\"sans\")\n\tdisplay.set_pen(0)\n\tTEXT_SIZE = 0.62\n\ty = 20 + int(LINE_HEIGHT / 2)\n", "display.set_font(\"sans\")\n\tdisplay.text(\"Up/Down - Change page\", 0, y, WIDTH, TEXT_SIZE)\n\ty += LINE_HEIGHT\n\tdisplay.text(\"a, b or c - Launch app\", 0, y, WIDTH, TEXT_SIZE)\n\ty += LINE_HEIGHT\n\tdisplay.text(\"a & c - Exit app\", 0, y, WIDTH, TEXT_SIZE)\n\ty += LINE_HEIGHT\n\tdisplay.update()\n\t# Call halt in a loop, on battery this switches off power.\n\t# On USB, the app will exit when A+C is pressed because the launcher picks that up.\n", "while True:\n\t    display.keepalive()\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/info.py", "chunked_list": ["import badger2040\n\tfrom badger2040 import WIDTH\n\tTEXT_SIZE = 1\n\tLINE_HEIGHT = 15\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\t# Clear to white\n\tdisplay.set_pen(15)\n\tdisplay.clear()\n\tdisplay.set_font(\"bitmap8\")\n", "display.set_pen(0)\n\tdisplay.rectangle(0, 0, WIDTH, 16)\n\tdisplay.set_pen(15)\n\tdisplay.text(\"badgerOS\", 3, 4, WIDTH, 1)\n\tdisplay.text(\"info\", WIDTH - display.measure_text(\"help\", 0.4) - 4, 4, WIDTH, 1)\n\tdisplay.set_pen(0)\n\ty = 16 + int(LINE_HEIGHT / 2)\n\tdisplay.text(\"Made by Pimoroni, powered by MicroPython\", 5, y, WIDTH, TEXT_SIZE)\n\ty += LINE_HEIGHT\n\tdisplay.text(\"Dual-core RP2040, 133MHz, 264KB RAM\", 5, y, WIDTH, TEXT_SIZE)\n", "y += LINE_HEIGHT\n\tdisplay.text(\"2MB Flash (1MB OS, 1MB Storage)\", 5, y, WIDTH, TEXT_SIZE)\n\ty += LINE_HEIGHT\n\tdisplay.text(\"296x128 pixel Black/White e-Ink\", 5, y, WIDTH, TEXT_SIZE)\n\ty += LINE_HEIGHT\n\ty += LINE_HEIGHT\n\tdisplay.text(\"For more info:\", 5, y, WIDTH, TEXT_SIZE)\n\ty += LINE_HEIGHT\n\tdisplay.text(\"https://pimoroni.com/badger2040\", 5, y, WIDTH, TEXT_SIZE)\n\tdisplay.update()\n", "# Call halt in a loop, on battery this switches off power.\n\t# On USB, the app will exit when A+C is pressed because the launcher picks that up.\n\twhile True:\n\t    display.keepalive()\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/news.py", "chunked_list": ["import badger2040\n\tfrom badger2040 import WIDTH\n\timport machine\n\tfrom urllib import urequest\n\timport gc\n\timport qrcode\n\timport badger_os\n\t# URLS to use (Entertainment, Science and Technology)\n\tURL = [\"http://feeds.bbci.co.uk/news/entertainment_and_arts/rss.xml\",\n\t       \"http://feeds.bbci.co.uk/news/science_and_environment/rss.xml\",\n", "       \"http://feeds.bbci.co.uk/news/technology/rss.xml\"]\n\tcode = qrcode.QRCode()\n\tstate = {\n\t    \"current_page\": 0,\n\t    \"feed\": 2\n\t}\n\tbadger_os.state_load(\"news\", state)\n\t# Display Setup\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n", "display.set_update_speed(2)\n\t# Setup buttons\n\tbutton_a = machine.Pin(badger2040.BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\tbutton_b = machine.Pin(badger2040.BUTTON_B, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\tbutton_c = machine.Pin(badger2040.BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\tbutton_down = machine.Pin(badger2040.BUTTON_DOWN, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\tbutton_up = machine.Pin(badger2040.BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\tdef read_until(stream, char):\n\t    result = b\"\"\n\t    while True:\n", "        c = stream.read(1)\n\t        if c == char:\n\t            return result\n\t        result += c\n\tdef discard_until(stream, c):\n\t    while stream.read(1) != c:\n\t        pass\n\tdef parse_xml_stream(s, accept_tags, group_by, max_items=3):\n\t    tag = []\n\t    text = b\"\"\n", "    count = 0\n\t    current = {}\n\t    while True:\n\t        char = s.read(1)\n\t        if len(char) == 0:\n\t            break\n\t        if char == b\"<\":\n\t            next_char = s.read(1)\n\t            # Discard stuff like <?xml vers...\n\t            if next_char == b\"?\":\n", "                discard_until(s, b\">\")\n\t                continue\n\t            # Detect <![CDATA\n\t            elif next_char == b\"!\":\n\t                s.read(1)  # Discard [\n\t                discard_until(s, b\"[\")  # Discard CDATA[\n\t                text = read_until(s, b\"]\")\n\t                discard_until(s, b\">\")  # Discard ]>\n\t                gc.collect()\n\t            elif next_char == b\"/\":\n", "                current_tag = read_until(s, b\">\")\n\t                top_tag = tag[-1]\n\t                # Populate our result dict\n\t                if top_tag in accept_tags:\n\t                    current[top_tag.decode(\"utf-8\")] = text.decode(\"utf-8\")\n\t                # If we've found a group of items, yield the dict\n\t                elif top_tag == group_by:\n\t                    yield current\n\t                    current = {}\n\t                    count += 1\n", "                    if count == max_items:\n\t                        return\n\t                tag.pop()\n\t                text = b\"\"\n\t                gc.collect()\n\t                continue\n\t            else:\n\t                current_tag = read_until(s, b\">\")\n\t                tag += [next_char + current_tag.split(b\" \")[0]]\n\t                text = b\"\"\n", "                gc.collect()\n\t        else:\n\t            text += char\n\tdef measure_qr_code(size, code):\n\t    w, h = code.get_size()\n\t    module_size = int(size / w)\n\t    return module_size * w, module_size\n\tdef draw_qr_code(ox, oy, size, code):\n\t    size, module_size = measure_qr_code(size, code)\n\t    display.set_pen(15)\n", "    display.rectangle(ox, oy, size, size)\n\t    display.set_pen(0)\n\t    for x in range(size):\n\t        for y in range(size):\n\t            if code.get_module(x, y):\n\t                display.rectangle(ox + x * module_size, oy + y * module_size, module_size, module_size)\n\t# A function to get the data from an RSS Feed, this in case BBC News.\n\tdef get_rss(url):\n\t    try:\n\t        stream = urequest.urlopen(url)\n", "        output = list(parse_xml_stream(stream, [b\"title\", b\"description\", b\"guid\", b\"pubDate\"], b\"item\"))\n\t        return output\n\t    except OSError as e:\n\t        print(e)\n\t        return False\n\t# Connects to the wireless network. Ensure you have entered your details in WIFI_CONFIG.py :).\n\tdisplay.connect()\n\tprint(state[\"feed\"])\n\tfeed = get_rss(URL[state[\"feed\"]])\n\tdef draw_page():\n", "    # Clear the display\n\t    display.set_pen(15)\n\t    display.clear()\n\t    display.set_pen(0)\n\t    # Draw the page header\n\t    display.set_font(\"bitmap6\")\n\t    display.set_pen(0)\n\t    display.rectangle(0, 0, WIDTH, 20)\n\t    display.set_pen(15)\n\t    display.text(\"News\", 3, 4)\n", "    display.text(\"Page: \" + str(state[\"current_page\"] + 1), WIDTH - display.measure_text(\"Page:  \") - 4, 4)\n\t    display.set_pen(0)\n\t    display.set_font(\"bitmap8\")\n\t    # Draw articles from the feed if they're available.\n\t    if feed:\n\t        page = state[\"current_page\"]\n\t        display.set_pen(0)\n\t        display.text(feed[page][\"title\"], 2, 30, WIDTH - 130, 2)\n\t        code.set_text(feed[page][\"guid\"])\n\t        draw_qr_code(WIDTH - 100, 25, 100, code)\n", "    else:\n\t        display.set_pen(0)\n\t        display.rectangle(0, 60, WIDTH, 25)\n\t        display.set_pen(15)\n\t        display.text(\"Unable to display news! Check your network settings in WIFI_CONFIG.py\", 5, 65, WIDTH, 1)\n\t    display.update()\n\tdraw_page()\n\twhile True:\n\t    changed = False\n\t    if button_down.value():\n", "        if state[\"current_page\"] < 2:\n\t            state[\"current_page\"] += 1\n\t            changed = True\n\t    if button_up.value():\n\t        if state[\"current_page\"] > 0:\n\t            state[\"current_page\"] -= 1\n\t            changed = True\n\t    if button_a.value():\n\t        state[\"feed\"] = 0\n\t        state[\"current_page\"] = 0\n", "        feed = get_rss(URL[state[\"feed\"]])\n\t        badger_os.state_save(\"news\", state)\n\t        changed = True\n\t    if button_b.value():\n\t        state[\"feed\"] = 1\n\t        state[\"current_page\"] = 0\n\t        feed = get_rss(URL[state[\"feed\"]])\n\t        badger_os.state_save(\"news\", state)\n\t        changed = True\n\t    if button_c.value():\n", "        state[\"feed\"] = 2\n\t        state[\"current_page\"] = 0\n\t        feed = get_rss(URL[state[\"feed\"]])\n\t        badger_os.state_save(\"news\", state)\n\t        changed = True\n\t    if changed:\n\t        draw_page()\n"]}
{"filename": "badger_os/examples/fonts.py", "chunked_list": ["import badger2040\n\timport badger_os\n\t# Global Constants\n\tFONT_NAMES = (\n\t    (\"sans\", 0.7, 2),\n\t    (\"gothic\", 0.7, 2),\n\t    (\"cursive\", 0.7, 2),\n\t    (\"serif\", 0.7, 2),\n\t    (\"serif_italic\", 0.7, 2),\n\t    (\"bitmap6\", 3, 1),\n", "    (\"bitmap8\", 2, 1),\n\t    (\"bitmap14_outline\", 1, 1)\n\t)\n\tWIDTH = badger2040.WIDTH\n\tHEIGHT = badger2040.HEIGHT\n\tMENU_TEXT_SIZE = 0.5\n\tMENU_SPACING = 16\n\tMENU_WIDTH = 84\n\tMENU_PADDING = 5\n\tTEXT_INDENT = MENU_WIDTH + 10\n", "ARROW_THICKNESS = 3\n\tARROW_WIDTH = 18\n\tARROW_HEIGHT = 14\n\tARROW_PADDING = 2\n\t# ------------------------------\n\t#      Drawing functions\n\t# ------------------------------\n\t# Draw a upward arrow\n\tdef draw_up(x, y, width, height, thickness, padding):\n\t    border = (thickness // 4) + padding\n", "    display.line(x + border, y + height - border,\n\t                 x + (width // 2), y + border)\n\t    display.line(x + (width // 2), y + border,\n\t                 x + width - border, y + height - border)\n\t# Draw a downward arrow\n\tdef draw_down(x, y, width, height, thickness, padding):\n\t    border = (thickness // 2) + padding\n\t    display.line(x + border, y + border,\n\t                 x + (width // 2), y + height - border)\n\t    display.line(x + (width // 2), y + height - border,\n", "                 x + width - border, y + border)\n\t# Draw the frame of the reader\n\tdef draw_frame():\n\t    display.set_pen(15)\n\t    display.clear()\n\t    display.set_pen(12)\n\t    display.rectangle(WIDTH - ARROW_WIDTH, 0, ARROW_WIDTH, HEIGHT)\n\t    display.set_pen(0)\n\t    draw_up(WIDTH - ARROW_WIDTH, (HEIGHT // 4) - (ARROW_HEIGHT // 2),\n\t            ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n", "    draw_down(WIDTH - ARROW_WIDTH, ((HEIGHT * 3) // 4) - (ARROW_HEIGHT // 2),\n\t              ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t# Draw the fonts and menu\n\tdef draw_fonts():\n\t    display.set_font(\"bitmap8\")\n\t    for i in range(len(FONT_NAMES)):\n\t        name, size, thickness = FONT_NAMES[i]\n\t        display.set_pen(0)\n\t        if i == state[\"selected_font\"]:\n\t            display.rectangle(0, i * MENU_SPACING, MENU_WIDTH, MENU_SPACING)\n", "            display.set_pen(15)\n\t        display.text(name, MENU_PADDING, (i * MENU_SPACING) + int((MENU_SPACING - 8) / 2), WIDTH, MENU_TEXT_SIZE)\n\t    name, size, thickness = FONT_NAMES[state[\"selected_font\"]]\n\t    display.set_font(name)\n\t    y = 0 if name.startswith(\"bitmap\") else 10\n\t    display.set_pen(0)\n\t    for line in (\"The quick\", \"brown fox\", \"jumps over\", \"the lazy dog.\", \"0123456789\", \"!\\\"£$%^&*()\"):\n\t        display.text(line, TEXT_INDENT, y, WIDTH, size)\n\t        y += 22\n\t    display.update()\n", "# ------------------------------\n\t#        Program setup\n\t# ------------------------------\n\t# Global variables\n\tstate = {\"selected_font\": 0}\n\tbadger_os.state_load(\"fonts\", state)\n\t# Create a new Badger and set it to update FAST\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\tdisplay.set_update_speed(badger2040.UPDATE_FAST)\n", "changed = True\n\t# ------------------------------\n\t#       Main program loop\n\t# ------------------------------\n\twhile True:\n\t    # Sometimes a button press or hold will keep the system\n\t    # powered *through* HALT, so latch the power back on.\n\t    display.keepalive()\n\t    if display.pressed(badger2040.BUTTON_UP):\n\t        state[\"selected_font\"] -= 1\n", "        if state[\"selected_font\"] < 0:\n\t            state[\"selected_font\"] = len(FONT_NAMES) - 1\n\t        changed = True\n\t    if display.pressed(badger2040.BUTTON_DOWN):\n\t        state[\"selected_font\"] += 1\n\t        if state[\"selected_font\"] >= len(FONT_NAMES):\n\t            state[\"selected_font\"] = 0\n\t        changed = True\n\t    if changed:\n\t        draw_frame()\n", "        draw_fonts()\n\t        badger_os.state_save(\"fonts\", state)\n\t        changed = False\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/clock.py", "chunked_list": ["import time\n\timport machine\n\timport badger2040\n\tdisplay = badger2040.Badger2040()\n\tdisplay.set_update_speed(2)\n\tdisplay.set_thickness(4)\n\tWIDTH, HEIGHT = display.get_bounds()\n\tif badger2040.is_wireless():\n\t    import ntptime\n\t    try:\n", "        display.connect()\n\t        if display.isconnected():\n\t            ntptime.settime()\n\t    except (RuntimeError, OSError) as e:\n\t        print(f\"Wireless Error: {e.value}\")\n\t# Thonny overwrites the Pico RTC so re-sync from the physical RTC if we can\n\ttry:\n\t    badger2040.pcf_to_pico_rtc()\n\texcept RuntimeError:\n\t    pass\n", "rtc = machine.RTC()\n\tdisplay.set_font(\"gothic\")\n\tcursors = [\"year\", \"month\", \"day\", \"hour\", \"minute\"]\n\tset_clock = False\n\ttoggle_set_clock = False\n\tcursor = 0\n\tlast = 0\n\tbutton_a = badger2040.BUTTONS[badger2040.BUTTON_A]\n\tbutton_b = badger2040.BUTTONS[badger2040.BUTTON_B]\n\tbutton_c = badger2040.BUTTONS[badger2040.BUTTON_C]\n", "button_up = badger2040.BUTTONS[badger2040.BUTTON_UP]\n\tbutton_down = badger2040.BUTTONS[badger2040.BUTTON_DOWN]\n\t# Button handling function\n\tdef button(pin):\n\t    global last, set_clock, toggle_set_clock, cursor, year, month, day, hour, minute\n\t    time.sleep(0.01)\n\t    if not pin.value():\n\t        return\n\t    if button_a.value() and button_c.value():\n\t        machine.reset()\n", "    adjust = 0\n\t    if pin == button_b:\n\t        toggle_set_clock = True\n\t        if set_clock:\n\t            rtc.datetime((year, month, day, 0, hour, minute, second, 0))\n\t            if badger2040.is_wireless():\n\t                badger2040.pico_rtc_to_pcf()\n\t        return\n\t    if set_clock:\n\t        if pin == button_c:\n", "            cursor += 1\n\t            cursor %= len(cursors)\n\t        if pin == button_a:\n\t            cursor -= 1\n\t            cursor %= len(cursors)\n\t        if pin == button_up:\n\t            adjust = 1\n\t        if pin == button_down:\n\t            adjust = -1\n\t        if cursors[cursor] == \"year\":\n", "            year += adjust\n\t            year = max(year, 2022)\n\t            day = min(day, days_in_month(month, year))\n\t        if cursors[cursor] == \"month\":\n\t            month += adjust\n\t            month = min(max(month, 1), 12)\n\t            day = min(day, days_in_month(month, year))\n\t        if cursors[cursor] == \"day\":\n\t            day += adjust\n\t            day = min(max(day, 1), days_in_month(month, year))\n", "        if cursors[cursor] == \"hour\":\n\t            hour += adjust\n\t            hour %= 24\n\t        if cursors[cursor] == \"minute\":\n\t            minute += adjust\n\t            minute %= 60\n\t        draw_clock()\n\tdef days_in_month(month, year):\n\t    if month == 2 and ((year % 4 == 0 and year % 100 != 0) or year % 400 == 0):\n\t        return 29\n", "    return (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[month - 1]\n\tdef draw_clock():\n\t    global second_offset, second_unit_offset\n\t    hms = \"{:02}:{:02}:{:02}\".format(hour, minute, second)\n\t    ymd = \"{:04}/{:02}/{:02}\".format(year, month, day)\n\t    hms_width = display.measure_text(hms, 1.8)\n\t    hms_offset = int((badger2040.WIDTH / 2) - (hms_width / 2))\n\t    h_width = display.measure_text(hms[0:2], 1.8)\n\t    mi_width = display.measure_text(hms[3:5], 1.8)\n\t    mi_offset = display.measure_text(hms[0:3], 1.8)\n", "    ymd_width = display.measure_text(ymd, 1.0)\n\t    ymd_offset = int((badger2040.WIDTH / 2) - (ymd_width / 2))\n\t    y_width = display.measure_text(ymd[0:4], 1.0)\n\t    m_width = display.measure_text(ymd[5:7], 1.0)\n\t    m_offset = display.measure_text(ymd[0:5], 1.0)\n\t    d_width = display.measure_text(ymd[8:10], 1.0)\n\t    d_offset = display.measure_text(ymd[0:8], 1.0)\n\t    display.set_pen(15)\n\t    display.clear()\n\t    display.set_pen(0)\n", "    display.text(hms, hms_offset, 40, 0, 1.8)\n\t    display.text(ymd, ymd_offset, 100, 0, 1.0)\n\t    hms = \"{:02}:{:02}:\".format(hour, minute)\n\t    second_offset = hms_offset + display.measure_text(hms, 1.8)\n\t    hms = \"{:02}:{:02}:{}\".format(hour, minute, second // 10)\n\t    second_unit_offset = hms_offset + display.measure_text(hms, 1.8)\n\t    if set_clock:\n\t        display.set_pen(0)\n\t        if cursors[cursor] == \"year\":\n\t            display.line(ymd_offset, 120, ymd_offset + y_width, 120, 4)\n", "        if cursors[cursor] == \"month\":\n\t            display.line(ymd_offset + m_offset, 120, ymd_offset + m_offset + m_width, 120, 4)\n\t        if cursors[cursor] == \"day\":\n\t            display.line(ymd_offset + d_offset, 120, ymd_offset + d_offset + d_width, 120, 4)\n\t        if cursors[cursor] == \"hour\":\n\t            display.line(hms_offset, 70, hms_offset + h_width, 70, 4)\n\t        if cursors[cursor] == \"minute\":\n\t            display.line(hms_offset + mi_offset, 70, hms_offset + mi_offset + mi_width, 70, 4)\n\t    display.set_update_speed(2)\n\t    display.update()\n", "    display.set_update_speed(3)\n\tdef draw_second():\n\t    global second_offset, second_unit_offset\n\t    display.set_pen(15)\n\t    display.rectangle(second_offset, 8, 75, 56)\n\t    display.set_pen(0)\n\t    if second // 10 != last_second // 10:\n\t        s = \"{:02}\".format(second)\n\t        display.text(s, second_offset, 40, 0, 1.8)\n\t        display.partial_update(second_offset, 8, 75, 56)\n", "        s = \"{}\".format(second // 10)\n\t        second_unit_offset = second_offset + display.measure_text(s, 1.8)\n\t    else:\n\t        s = \"{}\".format(second % 10)\n\t        display.text(s, second_unit_offset, 40, 0, 1.8)\n\t        display.partial_update(second_unit_offset, 8, 75 - (second_unit_offset - second_offset), 56)\n\t        time.sleep(0.9)\n\tfor b in badger2040.BUTTONS.values():\n\t    b.irq(trigger=machine.Pin.IRQ_RISING, handler=button)\n\tyear, month, day, wd, hour, minute, second, _ = rtc.datetime()\n", "if (year, month, day) == (2021, 1, 1):\n\t    rtc.datetime((2022, 2, 28, 0, 12, 0, 0, 0))\n\tlast_second = second\n\tlast_minute = minute\n\tdraw_clock()\n\twhile True:\n\t    if not set_clock:\n\t        year, month, day, wd, hour, minute, second, _ = rtc.datetime()\n\t        if second != last_second:\n\t            if minute != last_minute:\n", "                draw_clock()\n\t                last_minute = minute\n\t            else:\n\t                draw_second()\n\t            last_second = second\n\t    if toggle_set_clock:\n\t        set_clock = not set_clock\n\t        print(f\"Set clock changed to: {set_clock}\")\n\t        toggle_set_clock = False\n\t        draw_clock()\n", "    time.sleep(0.01)\n"]}
{"filename": "badger_os/examples/weather.py", "chunked_list": ["# This example grabs current weather details from Open Meteo and displays them on Badger 2040 W.\n\t# Find out more about the Open Meteo API at https://open-meteo.com\n\timport badger2040\n\tfrom badger2040 import WIDTH\n\timport urequests\n\timport jpegdec\n\t# Set your latitude/longitude here (find yours by right clicking in Google Maps!)\n\tLAT = 53.38609085276884\n\tLNG = -1.4239983439328177\n\tTIMEZONE = \"auto\"  # determines time zone from lat/long\n", "URL = \"http://api.open-meteo.com/v1/forecast?latitude=\" + str(LAT) + \"&longitude=\" + str(LNG) + \"&current_weather=true&timezone=\" + TIMEZONE\n\t# Display Setup\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\tdisplay.set_update_speed(2)\n\tjpeg = jpegdec.JPEG(display.display)\n\t# Connects to the wireless network. Ensure you have entered your details in WIFI_CONFIG.py :).\n\tdisplay.connect()\n\tdef get_data():\n\t    global weathercode, temperature, windspeed, winddirection, date, time\n", "    print(f\"Requesting URL: {URL}\")\n\t    r = urequests.get(URL)\n\t    # open the json data\n\t    j = r.json()\n\t    print(\"Data obtained!\")\n\t    print(j)\n\t    # parse relevant data from JSON\n\t    current = j[\"current_weather\"]\n\t    temperature = current[\"temperature\"]\n\t    windspeed = current[\"windspeed\"]\n", "    winddirection = calculate_bearing(current[\"winddirection\"])\n\t    weathercode = current[\"weathercode\"]\n\t    date, time = current[\"time\"].split(\"T\")\n\t    r.close()\n\tdef calculate_bearing(d):\n\t    # calculates a compass direction from the wind direction in degrees\n\t    dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW']\n\t    ix = round(d / (360. / len(dirs)))\n\t    return dirs[ix % len(dirs)]\n\tdef draw_page():\n", "    # Clear the display\n\t    display.set_pen(15)\n\t    display.clear()\n\t    display.set_pen(0)\n\t    # Draw the page header\n\t    display.set_font(\"bitmap6\")\n\t    display.set_pen(0)\n\t    display.rectangle(0, 0, WIDTH, 20)\n\t    display.set_pen(15)\n\t    display.text(\"Weather\", 3, 4)\n", "    display.set_pen(0)\n\t    display.set_font(\"bitmap8\")\n\t    if temperature is not None:\n\t        # Choose an appropriate icon based on the weather code\n\t        # Weather codes from https://open-meteo.com/en/docs\n\t        # Weather icons from https://fontawesome.com/\n\t        if weathercode in [71, 73, 75, 77, 85, 86]:  # codes for snow\n\t            jpeg.open_file(\"/icons/icon-snow.jpg\")\n\t        elif weathercode in [51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82]:  # codes for rain\n\t            jpeg.open_file(\"/icons/icon-rain.jpg\")\n", "        elif weathercode in [1, 2, 3, 45, 48]:  # codes for cloud\n\t            jpeg.open_file(\"/icons/icon-cloud.jpg\")\n\t        elif weathercode in [0]:  # codes for sun\n\t            jpeg.open_file(\"/icons/icon-sun.jpg\")\n\t        elif weathercode in [95, 96, 99]:  # codes for storm\n\t            jpeg.open_file(\"/icons/icon-storm.jpg\")\n\t        jpeg.decode(13, 40, jpegdec.JPEG_SCALE_FULL)\n\t        display.set_pen(0)\n\t        display.text(f\"Temperature: {temperature}°C\", int(WIDTH / 3), 28, WIDTH - 105, 2)\n\t        display.text(f\"Wind Speed: {windspeed}kmph\", int(WIDTH / 3), 48, WIDTH - 105, 2)\n", "        display.text(f\"Wind Direction: {winddirection}\", int(WIDTH / 3), 68, WIDTH - 105, 2)\n\t        display.text(f\"Last update: {date}, {time}\", int(WIDTH / 3), 88, WIDTH - 105, 2)\n\t    else:\n\t        display.set_pen(0)\n\t        display.rectangle(0, 60, WIDTH, 25)\n\t        display.set_pen(15)\n\t        display.text(\"Unable to display weather! Check your network settings in WIFI_CONFIG.py\", 5, 65, WIDTH, 1)\n\t    display.update()\n\tget_data()\n\tdraw_page()\n", "# Call halt in a loop, on battery this switches off power.\n\t# On USB, the app will exit when A+C is pressed because the launcher picks that up.\n\twhile True:\n\t    display.keepalive()\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/list.py", "chunked_list": ["import binascii\n\timport badger2040\n\timport badger_os\n\t# **** Put your list title here *****\n\tlist_title = \"Checklist\"\n\tlist_file = \"checklist.txt\"\n\t# Global Constantsu\n\tWIDTH = badger2040.WIDTH\n\tHEIGHT = badger2040.HEIGHT\n\tARROW_THICKNESS = 3\n", "ARROW_WIDTH = 18\n\tARROW_HEIGHT = 14\n\tARROW_PADDING = 2\n\tMAX_ITEM_CHARS = 26\n\tTITLE_TEXT_SIZE = 0.7\n\tITEM_TEXT_SIZE = 0.6\n\tITEM_SPACING = 20\n\tLIST_START = 40\n\tLIST_PADDING = 2\n\tLIST_WIDTH = WIDTH - LIST_PADDING - LIST_PADDING - ARROW_WIDTH\n", "LIST_HEIGHT = HEIGHT - LIST_START - LIST_PADDING - ARROW_HEIGHT\n\t# Default list items - change the list items by editing checklist.txt\n\tlist_items = [\"Badger\", \"Badger\", \"Badger\", \"Badger\", \"Badger\", \"Mushroom\", \"Mushroom\", \"Snake\"]\n\tsave_checklist = False\n\ttry:\n\t    with open(\"checklist.txt\", \"r\") as f:\n\t        raw_list_items = f.read()\n\t    if raw_list_items.find(\" X\\n\") != -1:\n\t        # Have old style checklist, preserve state and note we should resave the list to remove the Xs\n\t        list_items = []\n", "        state = {\n\t            \"current_item\": 0,\n\t            \"checked\": []\n\t        }\n\t        for item in raw_list_items.strip().split(\"\\n\"):\n\t            if item.endswith(\" X\"):\n\t                state[\"checked\"].append(True)\n\t                item = item[:-2]\n\t            else:\n\t                state[\"checked\"].append(False)\n", "            list_items.append(item)\n\t        state[\"items_hash\"] = binascii.crc32(\"\\n\".join(list_items))\n\t        badger_os.state_save(\"list\", state)\n\t        save_checklist = True\n\t    else:\n\t        list_items = [item.strip() for item in raw_list_items.strip().split(\"\\n\")]\n\texcept OSError:\n\t    save_checklist = True\n\tif save_checklist:\n\t    with open(\"checklist.txt\", \"w\") as f:\n", "        for item in list_items:\n\t            f.write(item + \"\\n\")\n\t# ------------------------------\n\t#      Drawing functions\n\t# ------------------------------\n\t# Draw the list of items\n\tdef draw_list(items, item_states, start_item, highlighted_item, x, y, width, height, item_height, columns):\n\t    item_x = 0\n\t    item_y = 0\n\t    current_col = 0\n", "    for i in range(start_item, len(items)):\n\t        if i == highlighted_item:\n\t            display.set_pen(12)\n\t            display.rectangle(item_x, item_y + y - (item_height // 2), width // columns, item_height)\n\t        display.set_pen(0)\n\t        display.text(items[i], item_x + x + item_height, item_y + y, WIDTH, ITEM_TEXT_SIZE)\n\t        draw_checkbox(item_x, item_y + y - (item_height // 2), item_height, 15, 0, 2, item_states[i], 2)\n\t        item_y += item_height\n\t        if item_y >= height - (item_height // 2):\n\t            item_x += width // columns\n", "            item_y = 0\n\t            current_col += 1\n\t            if current_col >= columns:\n\t                return\n\t# Draw a upward arrow\n\tdef draw_up(x, y, width, height, thickness, padding):\n\t    border = (thickness // 4) + padding\n\t    display.line(x + border, y + height - border,\n\t                 x + (width // 2), y + border)\n\t    display.line(x + (width // 2), y + border,\n", "                 x + width - border, y + height - border)\n\t# Draw a downward arrow\n\tdef draw_down(x, y, width, height, thickness, padding):\n\t    border = (thickness // 2) + padding\n\t    display.line(x + border, y + border,\n\t                 x + (width // 2), y + height - border)\n\t    display.line(x + (width // 2), y + height - border,\n\t                 x + width - border, y + border)\n\t# Draw a left arrow\n\tdef draw_left(x, y, width, height, thickness, padding):\n", "    border = (thickness // 2) + padding\n\t    display.line(x + width - border, y + border,\n\t                 x + border, y + (height // 2))\n\t    display.line(x + border, y + (height // 2),\n\t                 x + width - border, y + height - border)\n\t# Draw a right arrow\n\tdef draw_right(x, y, width, height, thickness, padding):\n\t    border = (thickness // 2) + padding\n\t    display.line(x + border, y + border,\n\t                 x + width - border, y + (height // 2))\n", "    display.line(x + width - border, y + (height // 2),\n\t                 x + border, y + height - border)\n\t# Draw a tick\n\tdef draw_tick(x, y, width, height, thickness, padding):\n\t    border = (thickness // 2) + padding\n\t    display.line(x + border, y + ((height * 2) // 3),\n\t                 x + (width // 2), y + height - border)\n\t    display.line(x + (width // 2), y + height - border,\n\t                 x + width - border, y + border)\n\t# Draw a cross\n", "def draw_cross(x, y, width, height, thickness, padding):\n\t    border = (thickness // 2) + padding\n\t    display.line(x + border, y + border, x + width - border, y + height - border)\n\t    display.line(x + width - border, y + border, x + border, y + height - border)\n\t# Draw a checkbox with or without a tick\n\tdef draw_checkbox(x, y, size, background, foreground, thickness, tick, padding):\n\t    border = (thickness // 2) + padding\n\t    display.set_pen(background)\n\t    display.rectangle(x + border, y + border, size - (border * 2), size - (border * 2))\n\t    display.set_pen(foreground)\n", "    display.line(x + border, y + border, x + size - border, y + border)\n\t    display.line(x + border, y + border, x + border, y + size - border)\n\t    display.line(x + size - border, y + border, x + size - border, y + size - border)\n\t    display.line(x + border, y + size - border, x + size - border, y + size - border)\n\t    if tick:\n\t        draw_tick(x, y, size, size, thickness, 2 + border)\n\t# ------------------------------\n\t#        Program setup\n\t# ------------------------------\n\tchanged = True\n", "state = {\n\t    \"current_item\": 0,\n\t}\n\tbadger_os.state_load(\"list\", state)\n\titems_hash = binascii.crc32(\"\\n\".join(list_items))\n\tif \"items_hash\" not in state or state[\"items_hash\"] != items_hash:\n\t    # Item list changed, or not yet written reset the list\n\t    state[\"current_item\"] = 0\n\t    state[\"items_hash\"] = items_hash\n\t    state[\"checked\"] = [False] * len(list_items)\n", "    changed = True\n\t# Global variables\n\titems_per_page = 0\n\t# Create a new Badger and set it to update FAST\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\tdisplay.set_font(\"sans\")\n\tdisplay.set_thickness(2)\n\tif changed:\n\t    display.set_update_speed(badger2040.UPDATE_FAST)\n", "else:\n\t    display.set_update_speed(badger2040.UPDATE_TURBO)\n\t# Find out what the longest item is\n\tlongest_item = 0\n\tfor i in range(len(list_items)):\n\t    while True:\n\t        item = list_items[i]\n\t        item_length = display.measure_text(item, ITEM_TEXT_SIZE)\n\t        if item_length > 0 and item_length > LIST_WIDTH - ITEM_SPACING:\n\t            list_items[i] = item[:-1]\n", "        else:\n\t            break\n\t    longest_item = max(longest_item, display.measure_text(list_items[i], ITEM_TEXT_SIZE))\n\t# And use that to calculate the number of columns we can fit onscreen and how many items that would give\n\tlist_columns = 1\n\twhile longest_item + ITEM_SPACING < (LIST_WIDTH // (list_columns + 1)):\n\t    list_columns += 1\n\titems_per_page = ((LIST_HEIGHT // ITEM_SPACING) + 1) * list_columns\n\t# ------------------------------\n\t#       Main program loop\n", "# ------------------------------\n\twhile True:\n\t    # Sometimes a button press or hold will keep the system\n\t    # powered *through* HALT, so latch the power back on.\n\t    display.keepalive()\n\t    if len(list_items) > 0:\n\t        if display.pressed(badger2040.BUTTON_A):\n\t            if state[\"current_item\"] > 0:\n\t                page = state[\"current_item\"] // items_per_page\n\t                state[\"current_item\"] = max(state[\"current_item\"] - (items_per_page) // list_columns, 0)\n", "                if page != state[\"current_item\"] // items_per_page:\n\t                    display.update_speed(badger2040.UPDATE_FAST)\n\t                changed = True\n\t        if display.pressed(badger2040.BUTTON_B):\n\t            state[\"checked\"][state[\"current_item\"]] = not state[\"checked\"][state[\"current_item\"]]\n\t            changed = True\n\t        if display.pressed(badger2040.BUTTON_C):\n\t            if state[\"current_item\"] < len(list_items) - 1:\n\t                page = state[\"current_item\"] // items_per_page\n\t                state[\"current_item\"] = min(state[\"current_item\"] + (items_per_page) // list_columns, len(list_items) - 1)\n", "                if page != state[\"current_item\"] // items_per_page:\n\t                    display.update_speed(badger2040.UPDATE_FAST)\n\t                changed = True\n\t        if display.pressed(badger2040.BUTTON_UP):\n\t            if state[\"current_item\"] > 0:\n\t                state[\"current_item\"] -= 1\n\t                changed = True\n\t        if display.pressed(badger2040.BUTTON_DOWN):\n\t            if state[\"current_item\"] < len(list_items) - 1:\n\t                state[\"current_item\"] += 1\n", "                changed = True\n\t    if changed:\n\t        badger_os.state_save(\"list\", state)\n\t        display.set_pen(15)\n\t        display.clear()\n\t        display.set_pen(12)\n\t        display.rectangle(WIDTH - ARROW_WIDTH, 0, ARROW_WIDTH, HEIGHT)\n\t        display.rectangle(0, HEIGHT - ARROW_HEIGHT, WIDTH, ARROW_HEIGHT)\n\t        y = LIST_PADDING + 12\n\t        display.set_pen(0)\n", "        display.text(list_title, LIST_PADDING, y, WIDTH, TITLE_TEXT_SIZE)\n\t        y += 12\n\t        display.set_pen(0)\n\t        display.line(LIST_PADDING, y, WIDTH - LIST_PADDING - ARROW_WIDTH, y)\n\t        if len(list_items) > 0:\n\t            page_item = 0\n\t            if items_per_page > 0:\n\t                page_item = (state[\"current_item\"] // items_per_page) * items_per_page\n\t            # Draw the list\n\t            display.set_pen(0)\n", "            draw_list(list_items, state[\"checked\"], page_item, state[\"current_item\"], LIST_PADDING, LIST_START,\n\t                      LIST_WIDTH, LIST_HEIGHT, ITEM_SPACING, list_columns)\n\t            # Draw the interaction button icons\n\t            display.set_pen(0)\n\t            # Previous item\n\t            if state[\"current_item\"] > 0:\n\t                draw_up(WIDTH - ARROW_WIDTH, (HEIGHT // 4) - (ARROW_HEIGHT // 2),\n\t                        ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t            # Next item\n\t            if state[\"current_item\"] < (len(list_items) - 1):\n", "                draw_down(WIDTH - ARROW_WIDTH, ((HEIGHT * 3) // 4) - (ARROW_HEIGHT // 2),\n\t                          ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t            # Previous column\n\t            if state[\"current_item\"] > 0:\n\t                draw_left((WIDTH // 7) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n\t                          ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t            # Next column\n\t            if state[\"current_item\"] < (len(list_items) - 1):\n\t                draw_right(((WIDTH * 6) // 7) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n\t                           ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n", "            if state[\"checked\"][state[\"current_item\"]]:\n\t                # Tick off item\n\t                draw_cross((WIDTH // 2) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n\t                           ARROW_HEIGHT, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t            else:\n\t                # Untick item\n\t                draw_tick((WIDTH // 2) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n\t                          ARROW_HEIGHT, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t        else:\n\t            # Say that the list is empty\n", "            empty_text = \"Nothing Here\"\n\t            text_length = display.measure_text(empty_text, ITEM_TEXT_SIZE)\n\t            display.text(empty_text, ((LIST_PADDING + LIST_WIDTH) - text_length) // 2, (LIST_HEIGHT // 2) + LIST_START - (ITEM_SPACING // 4), WIDTH, ITEM_TEXT_SIZE)\n\t        display.update()\n\t        display.set_update_speed(badger2040.UPDATE_TURBO)\n\t        changed = False\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/image.py", "chunked_list": ["import os\n\timport badger2040\n\tfrom badger2040 import HEIGHT, WIDTH\n\timport badger_os\n\timport jpegdec\n\tTOTAL_IMAGES = 0\n\t# Turn the act LED on as soon as possible\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\tdisplay.set_update_speed(badger2040.UPDATE_NORMAL)\n", "jpeg = jpegdec.JPEG(display.display)\n\t# Load images\n\ttry:\n\t    IMAGES = [f for f in os.listdir(\"/images\") if f.endswith(\".jpg\")]\n\t    TOTAL_IMAGES = len(IMAGES)\n\texcept OSError:\n\t    pass\n\tstate = {\n\t    \"current_image\": 0,\n\t    \"show_info\": True\n", "}\n\tdef show_image(n):\n\t    file = IMAGES[n]\n\t    name = file.split(\".\")[0]\n\t    jpeg.open_file(\"/images/{}\".format(file))\n\t    jpeg.decode()\n\t    if state[\"show_info\"]:\n\t        name_length = display.measure_text(name, 0.5)\n\t        display.set_pen(0)\n\t        display.rectangle(0, HEIGHT - 21, name_length + 11, 21)\n", "        display.set_pen(15)\n\t        display.rectangle(0, HEIGHT - 20, name_length + 10, 20)\n\t        display.set_pen(0)\n\t        display.text(name, 5, HEIGHT - 10, WIDTH, 0.5)\n\t        for i in range(TOTAL_IMAGES):\n\t            x = 286\n\t            y = int((128 / 2) - (TOTAL_IMAGES * 10 / 2) + (i * 10))\n\t            display.set_pen(0)\n\t            display.rectangle(x, y, 8, 8)\n\t            if state[\"current_image\"] != i:\n", "                display.set_pen(15)\n\t                display.rectangle(x + 1, y + 1, 6, 6)\n\t    display.update()\n\tif TOTAL_IMAGES == 0:\n\t    raise RuntimeError(\"To run this demo, create an /images directory on your device and upload some 1bit 296x128 pixel images.\")\n\tbadger_os.state_load(\"image\", state)\n\tchanged = True\n\twhile True:\n\t    # Sometimes a button press or hold will keep the system\n\t    # powered *through* HALT, so latch the power back on.\n", "    display.keepalive()\n\t    if display.pressed(badger2040.BUTTON_UP):\n\t        if state[\"current_image\"] > 0:\n\t            state[\"current_image\"] -= 1\n\t            changed = True\n\t    if display.pressed(badger2040.BUTTON_DOWN):\n\t        if state[\"current_image\"] < TOTAL_IMAGES - 1:\n\t            state[\"current_image\"] += 1\n\t            changed = True\n\t    if display.pressed(badger2040.BUTTON_A):\n", "        state[\"show_info\"] = not state[\"show_info\"]\n\t        changed = True\n\t    if changed:\n\t        show_image(state[\"current_image\"])\n\t        badger_os.state_save(\"image\", state)\n\t        changed = False\n\t    # Halt the Badger to save power, it will wake up if any of the front buttons are pressed\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/ebook.py", "chunked_list": ["import badger2040\n\timport gc\n\timport badger_os\n\t# **** Put the name of your text file here *****\n\ttext_file = \"/books/289-0-wind-in-the-willows-abridged.txt\"  # File must be on the MicroPython device\n\tgc.collect()\n\t# Global Constants\n\tWIDTH = badger2040.WIDTH\n\tHEIGHT = badger2040.HEIGHT\n\tARROW_THICKNESS = 3\n", "ARROW_WIDTH = 18\n\tARROW_HEIGHT = 14\n\tARROW_PADDING = 2\n\tTEXT_PADDING = 4\n\tTEXT_WIDTH = WIDTH - TEXT_PADDING - TEXT_PADDING - ARROW_WIDTH\n\tFONTS = [\"sans\", \"gothic\", \"cursive\", \"serif\"]\n\tTHICKNESSES = [2, 1, 1, 2]\n\t# ------------------------------\n\t#      Drawing functions\n\t# ------------------------------\n", "# Draw a upward arrow\n\tdef draw_up(x, y, width, height, thickness, padding):\n\t    border = (thickness // 4) + padding\n\t    display.line(x + border, y + height - border,\n\t                 x + (width // 2), y + border)\n\t    display.line(x + (width // 2), y + border,\n\t                 x + width - border, y + height - border)\n\t# Draw a downward arrow\n\tdef draw_down(x, y, width, height, thickness, padding):\n\t    border = (thickness // 2) + padding\n", "    display.line(x + border, y + border,\n\t                 x + (width // 2), y + height - border)\n\t    display.line(x + (width // 2), y + height - border,\n\t                 x + width - border, y + border)\n\t# Draw the frame of the reader\n\tdef draw_frame():\n\t    display.set_pen(15)\n\t    display.clear()\n\t    display.set_pen(12)\n\t    display.rectangle(WIDTH - ARROW_WIDTH, 0, ARROW_WIDTH, HEIGHT)\n", "    display.set_pen(0)\n\t    if state[\"current_page\"] > 0:\n\t        draw_up(WIDTH - ARROW_WIDTH, (HEIGHT // 4) - (ARROW_HEIGHT // 2),\n\t                ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t    draw_down(WIDTH - ARROW_WIDTH, ((HEIGHT * 3) // 4) - (ARROW_HEIGHT // 2),\n\t              ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\t# ------------------------------\n\t#        Program setup\n\t# ------------------------------\n\t# Global variables\n", "state = {\n\t    \"last_offset\": 0,\n\t    \"current_page\": 0,\n\t    \"font_idx\": 0,\n\t    \"text_size\": 0.5,\n\t    \"offsets\": []\n\t}\n\tbadger_os.state_load(\"ebook\", state)\n\ttext_spacing = int(34 * state[\"text_size\"])\n\t# Create a new Badger and set it to update FAST\n", "display = badger2040.Badger2040()\n\tdisplay.led(128)\n\tdisplay.set_update_speed(badger2040.UPDATE_FAST)\n\t# ------------------------------\n\t#         Render page\n\t# ------------------------------\n\tdef render_page():\n\t    row = 0\n\t    line = \"\"\n\t    pos = ebook.tell()\n", "    next_pos = pos\n\t    add_newline = False\n\t    display.set_font(FONTS[state[\"font_idx\"]])\n\t    display.set_thickness(THICKNESSES[state[\"font_idx\"]])\n\t    while True:\n\t        # Read a full line and split it into words\n\t        words = ebook.readline().split(\" \")\n\t        # Take the length of the first word and advance our position\n\t        next_word = words[0]\n\t        if len(words) > 1:\n", "            next_pos += len(next_word) + 1\n\t        else:\n\t            next_pos += len(next_word)  # This is the last word on the line\n\t        # Advance our position further if the word contains special characters\n\t        if '\\u201c' in next_word:\n\t            next_word = next_word.replace('\\u201c', '\\\"')\n\t            next_pos += 2\n\t        if '\\u201d' in next_word:\n\t            next_word = next_word.replace('\\u201d', '\\\"')\n\t            next_pos += 2\n", "        if '\\u2019' in next_word:\n\t            next_word = next_word.replace('\\u2019', '\\'')\n\t            next_pos += 2\n\t        # Rewind the file back from the line end to the start of the next word\n\t        ebook.seek(next_pos)\n\t        # Strip out any new line characters from the word\n\t        next_word = next_word.strip()\n\t        # If an empty word is encountered assume that means there was a blank line\n\t        if len(next_word) == 0:\n\t            add_newline = True\n", "        # Append the word to the current line and measure its length\n\t        appended_line = line\n\t        if len(line) > 0 and len(next_word) > 0:\n\t            appended_line += \" \"\n\t        appended_line += next_word\n\t        appended_length = display.measure_text(appended_line, state[\"text_size\"])\n\t        # Would this appended line be longer than the text display area, or was a blank line spotted?\n\t        if appended_length >= TEXT_WIDTH or add_newline:\n\t            # Yes, so write out the line prior to the append\n\t            print(line)\n", "            display.set_pen(0)\n\t            display.text(line, TEXT_PADDING, (row * text_spacing) + (text_spacing // 2) + TEXT_PADDING, WIDTH, state[\"text_size\"])\n\t            # Clear the line and move on to the next row\n\t            line = \"\"\n\t            row += 1\n\t            # Have we reached the end of the page?\n\t            if (row * text_spacing) + text_spacing >= HEIGHT:\n\t                print(\"+++++\")\n\t                display.update()\n\t                # Reset the position to the start of the word that made this line too long\n", "                ebook.seek(pos)\n\t                return\n\t            else:\n\t                # Set the line to the word and advance the current position\n\t                line = next_word\n\t                pos = next_pos\n\t            # A new line was spotted, so advance a row\n\t            if add_newline:\n\t                print(\"\")\n\t                row += 1\n", "                if (row * text_spacing) + text_spacing >= HEIGHT:\n\t                    print(\"+++++\")\n\t                    display.update()\n\t                    return\n\t                add_newline = False\n\t        else:\n\t            # The appended line was not too long, so set it as the line and advance the current position\n\t            line = appended_line\n\t            pos = next_pos\n\t# ------------------------------\n", "#       Main program loop\n\t# ------------------------------\n\tlaunch = True\n\tchanged = False\n\t# Open the book file\n\tebook = open(text_file, \"r\")\n\tif len(state[\"offsets\"]) > state[\"current_page\"]:\n\t    ebook.seek(state[\"offsets\"][state[\"current_page\"]])\n\telse:\n\t    state[\"current_page\"] = 0\n", "    state[\"offsets\"] = []\n\twhile True:\n\t    # Sometimes a button press or hold will keep the system\n\t    # powered *through* HALT, so latch the power back on.\n\t    display.keepalive()\n\t    # Was the next page button pressed?\n\t    if display.pressed(badger2040.BUTTON_DOWN):\n\t        state[\"current_page\"] += 1\n\t        changed = True\n\t    # Was the previous page button pressed?\n", "    if display.pressed(badger2040.BUTTON_UP):\n\t        if state[\"current_page\"] > 0:\n\t            state[\"current_page\"] -= 1\n\t            if state[\"current_page\"] == 0:\n\t                ebook.seek(0)\n\t            else:\n\t                ebook.seek(state[\"offsets\"][state[\"current_page\"] - 1])  # Retrieve the start position of the last page\n\t            changed = True\n\t    if display.pressed(badger2040.BUTTON_A):\n\t        state[\"text_size\"] += 0.1\n", "        if state[\"text_size\"] > 0.8:\n\t            state[\"text_size\"] = 0.5\n\t        text_spacing = int(34 * state[\"text_size\"])\n\t        state[\"offsets\"] = []\n\t        ebook.seek(0)\n\t        state[\"current_page\"] = 0\n\t        changed = True\n\t    if display.pressed(badger2040.BUTTON_B):\n\t        state[\"font_idx\"] += 1\n\t        if (state[\"font_idx\"] >= len(FONTS)):\n", "            state[\"font_idx\"] = 0\n\t        state[\"offsets\"] = []\n\t        ebook.seek(0)\n\t        state[\"current_page\"] = 0\n\t        changed = True\n\t    if launch and not changed:\n\t        if state[\"current_page\"] > 0 and len(state[\"offsets\"]) > state[\"current_page\"] - 1:\n\t            ebook.seek(state[\"offsets\"][state[\"current_page\"] - 1])\n\t        changed = True\n\t        launch = False\n", "    if changed:\n\t        draw_frame()\n\t        render_page()\n\t        # Is the next page one we've not displayed before?\n\t        if state[\"current_page\"] >= len(state[\"offsets\"]):\n\t            state[\"offsets\"].append(ebook.tell())  # Add its start position to the state[\"offsets\"] list\n\t        badger_os.state_save(\"ebook\", state)\n\t        changed = False\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/badge.py", "chunked_list": ["import badger2040\n\timport jpegdec\n\t# Global Constants\n\tWIDTH = badger2040.WIDTH\n\tHEIGHT = badger2040.HEIGHT\n\tIMAGE_WIDTH = 104\n\tCOMPANY_HEIGHT = 30\n\tDETAILS_HEIGHT = 20\n\tNAME_HEIGHT = HEIGHT - COMPANY_HEIGHT - (DETAILS_HEIGHT * 2) - 2\n\tTEXT_WIDTH = WIDTH - IMAGE_WIDTH - 1\n", "COMPANY_TEXT_SIZE = 0.6\n\tDETAILS_TEXT_SIZE = 0.5\n\tLEFT_PADDING = 5\n\tNAME_PADDING = 20\n\tDETAIL_SPACING = 10\n\tBADGE_PATH = \"/badges/badge.txt\"\n\tDEFAULT_TEXT = \"\"\"mustelid inc\n\tH. Badger\n\tRP2040\n\t2MB Flash\n", "E ink\n\t296x128px\n\t/badges/badge.jpg\n\t\"\"\"\n\t# ------------------------------\n\t#      Utility functions\n\t# ------------------------------\n\t# Reduce the size of a string until it fits within a given width\n\tdef truncatestring(text, text_size, width):\n\t    while True:\n", "        length = display.measure_text(text, text_size)\n\t        if length > 0 and length > width:\n\t            text = text[:-1]\n\t        else:\n\t            text += \"\"\n\t            return text\n\t# ------------------------------\n\t#      Drawing functions\n\t# ------------------------------\n\t# Draw the badge, including user text\n", "def draw_badge():\n\t    display.set_pen(0)\n\t    display.clear()\n\t    # Draw badge image\n\t    jpeg.open_file(badge_image)\n\t    jpeg.decode(WIDTH - IMAGE_WIDTH, 0)\n\t    # Draw a border around the image\n\t    display.set_pen(0)\n\t    display.line(WIDTH - IMAGE_WIDTH, 0, WIDTH - 1, 0)\n\t    display.line(WIDTH - IMAGE_WIDTH, 0, WIDTH - IMAGE_WIDTH, HEIGHT - 1)\n", "    display.line(WIDTH - IMAGE_WIDTH, HEIGHT - 1, WIDTH - 1, HEIGHT - 1)\n\t    display.line(WIDTH - 1, 0, WIDTH - 1, HEIGHT - 1)\n\t    # Uncomment this if a white background is wanted behind the company\n\t    # display.set_pen(15)\n\t    # display.rectangle(1, 1, TEXT_WIDTH, COMPANY_HEIGHT - 1)\n\t    # Draw the company\n\t    display.set_pen(15)  # Change this to 0 if a white background is used\n\t    display.set_font(\"serif\")\n\t    display.text(company, LEFT_PADDING, (COMPANY_HEIGHT // 2) + 1, WIDTH, COMPANY_TEXT_SIZE)\n\t    # Draw a white background behind the name\n", "    display.set_pen(15)\n\t    display.rectangle(1, COMPANY_HEIGHT + 1, TEXT_WIDTH, NAME_HEIGHT)\n\t    # Draw the name, scaling it based on the available width\n\t    display.set_pen(0)\n\t    display.set_font(\"sans\")\n\t    name_size = 2.0  # A sensible starting scale\n\t    while True:\n\t        name_length = display.measure_text(name, name_size)\n\t        if name_length >= (TEXT_WIDTH - NAME_PADDING) and name_size >= 0.1:\n\t            name_size -= 0.01\n", "        else:\n\t            display.text(name, (TEXT_WIDTH - name_length) // 2, (NAME_HEIGHT // 2) + COMPANY_HEIGHT + 1, WIDTH, name_size)\n\t            break\n\t    # Draw a white backgrounds behind the details\n\t    display.set_pen(15)\n\t    display.rectangle(1, HEIGHT - DETAILS_HEIGHT * 2, TEXT_WIDTH, DETAILS_HEIGHT - 1)\n\t    display.rectangle(1, HEIGHT - DETAILS_HEIGHT, TEXT_WIDTH, DETAILS_HEIGHT - 1)\n\t    # Draw the first detail's title and text\n\t    display.set_pen(0)\n\t    display.set_font(\"sans\")\n", "    name_length = display.measure_text(detail1_title, DETAILS_TEXT_SIZE)\n\t    display.text(detail1_title, LEFT_PADDING, HEIGHT - ((DETAILS_HEIGHT * 3) // 2), WIDTH, DETAILS_TEXT_SIZE)\n\t    display.text(detail1_text, 5 + name_length + DETAIL_SPACING, HEIGHT - ((DETAILS_HEIGHT * 3) // 2), WIDTH, DETAILS_TEXT_SIZE)\n\t    # Draw the second detail's title and text\n\t    name_length = display.measure_text(detail2_title, DETAILS_TEXT_SIZE)\n\t    display.text(detail2_title, LEFT_PADDING, HEIGHT - (DETAILS_HEIGHT // 2), WIDTH, DETAILS_TEXT_SIZE)\n\t    display.text(detail2_text, LEFT_PADDING + name_length + DETAIL_SPACING, HEIGHT - (DETAILS_HEIGHT // 2), WIDTH, DETAILS_TEXT_SIZE)\n\t    display.update()\n\t# ------------------------------\n\t#        Program setup\n", "# ------------------------------\n\t# Create a new Badger and set it to update NORMAL\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\tdisplay.set_update_speed(badger2040.UPDATE_NORMAL)\n\tdisplay.set_thickness(2)\n\tjpeg = jpegdec.JPEG(display.display)\n\t# Open the badge file\n\ttry:\n\t    badge = open(BADGE_PATH, \"r\")\n", "except OSError:\n\t    with open(BADGE_PATH, \"w\") as f:\n\t        f.write(DEFAULT_TEXT)\n\t        f.flush()\n\t    badge = open(BADGE_PATH, \"r\")\n\t# Read in the next 6 lines\n\tcompany = badge.readline()        # \"mustelid inc\"\n\tname = badge.readline()           # \"H. Badger\"\n\tdetail1_title = badge.readline()  # \"RP2040\"\n\tdetail1_text = badge.readline()   # \"2MB Flash\"\n", "detail2_title = badge.readline()  # \"E ink\"\n\tdetail2_text = badge.readline()   # \"296x128px\"\n\tbadge_image = badge.readline()    # /badges/badge.jpg\n\t# Truncate all of the text (except for the name as that is scaled)\n\tcompany = truncatestring(company, COMPANY_TEXT_SIZE, TEXT_WIDTH)\n\tdetail1_title = truncatestring(detail1_title, DETAILS_TEXT_SIZE, TEXT_WIDTH)\n\tdetail1_text = truncatestring(detail1_text, DETAILS_TEXT_SIZE,\n\t                              TEXT_WIDTH - DETAIL_SPACING - display.measure_text(detail1_title, DETAILS_TEXT_SIZE))\n\tdetail2_title = truncatestring(detail2_title, DETAILS_TEXT_SIZE, TEXT_WIDTH)\n\tdetail2_text = truncatestring(detail2_text, DETAILS_TEXT_SIZE,\n", "                              TEXT_WIDTH - DETAIL_SPACING - display.measure_text(detail2_title, DETAILS_TEXT_SIZE))\n\t# ------------------------------\n\t#       Main program\n\t# ------------------------------\n\tdraw_badge()\n\twhile True:\n\t    # Sometimes a button press or hold will keep the system\n\t    # powered *through* HALT, so latch the power back on.\n\t    display.keepalive()\n\t    # If on battery, halt the Badger to save power, it will wake up if any of the front buttons are pressed\n", "    display.halt()\n"]}
{"filename": "badger_os/examples/qrgen.py", "chunked_list": ["import badger2040\n\timport qrcode\n\timport time\n\timport os\n\timport badger_os\n\t# Check that the qrcodes directory exists, if not, make it\n\ttry:\n\t    os.mkdir(\"/qrcodes\")\n\texcept OSError:\n\t    pass\n", "# Check that there is a qrcode.txt, if not preload\n\ttry:\n\t    text = open(\"/qrcodes/qrcode.txt\", \"r\")\n\texcept OSError:\n\t    text = open(\"/qrcodes/qrcode.txt\", \"w\")\n\t    if badger2040.is_wireless():\n\t        text.write(\"\"\"https://pimoroni.com/badger2040w\n\tBadger 2040 W\n\t* 296x128 1-bit e-ink\n\t* 2.4GHz wireless & RTC\n", "* five user buttons\n\t* user LED\n\t* 2MB QSPI flash\n\tScan this code to learn\n\tmore about Badger 2040 W.\n\t\"\"\")\n\t    else:\n\t        text.write(\"\"\"https://pimoroni.com/badger2040\n\tBadger 2040\n\t* 296x128 1-bit e-ink\n", "* five user buttons\n\t* user LED\n\t* 2MB QSPI flash\n\tScan this code to learn\n\tmore about Badger 2040.\n\t\"\"\")\n\t    text.flush()\n\t    text.seek(0)\n\t# Load all available QR Code Files\n\ttry:\n", "    CODES = [f for f in os.listdir(\"/qrcodes\") if f.endswith(\".txt\")]\n\t    TOTAL_CODES = len(CODES)\n\texcept OSError:\n\t    pass\n\tprint(f'There are {TOTAL_CODES} QR Codes available:')\n\tfor codename in CODES:\n\t    print(f'File: {codename}')\n\tdisplay = badger2040.Badger2040()\n\tcode = qrcode.QRCode()\n\tstate = {\n", "    \"current_qr\": 0\n\t}\n\tdef measure_qr_code(size, code):\n\t    w, h = code.get_size()\n\t    module_size = int(size / w)\n\t    return module_size * w, module_size\n\tdef draw_qr_code(ox, oy, size, code):\n\t    size, module_size = measure_qr_code(size, code)\n\t    display.set_pen(15)\n\t    display.rectangle(ox, oy, size, size)\n", "    display.set_pen(0)\n\t    for x in range(size):\n\t        for y in range(size):\n\t            if code.get_module(x, y):\n\t                display.rectangle(ox + x * module_size, oy + y * module_size, module_size, module_size)\n\tdef draw_qr_file(n):\n\t    display.led(128)\n\t    file = CODES[n]\n\t    codetext = open(\"/qrcodes/{}\".format(file), \"r\")\n\t    lines = codetext.read().strip().split(\"\\n\")\n", "    code_text = lines.pop(0)\n\t    title_text = lines.pop(0)\n\t    detail_text = lines\n\t    # Clear the Display\n\t    display.set_pen(15)  # Change this to 0 if a white background is used\n\t    display.clear()\n\t    display.set_pen(0)\n\t    code.set_text(code_text)\n\t    size, _ = measure_qr_code(128, code)\n\t    left = top = int((badger2040.HEIGHT / 2) - (size / 2))\n", "    draw_qr_code(left, top, 128, code)\n\t    left = 128 + 5\n\t    display.text(title_text, left, 20, badger2040.WIDTH, 2)\n\t    top = 40\n\t    for line in detail_text:\n\t        display.text(line, left, top, badger2040.WIDTH, 1)\n\t        top += 10\n\t    if TOTAL_CODES > 1:\n\t        for i in range(TOTAL_CODES):\n\t            x = 286\n", "            y = int((128 / 2) - (TOTAL_CODES * 10 / 2) + (i * 10))\n\t            display.set_pen(0)\n\t            display.rectangle(x, y, 8, 8)\n\t            if state[\"current_qr\"] != i:\n\t                display.set_pen(15)\n\t                display.rectangle(x + 1, y + 1, 6, 6)\n\t    display.update()\n\tbadger_os.state_load(\"qrcodes\", state)\n\tchanged = True\n\twhile True:\n", "    # Sometimes a button press or hold will keep the system\n\t    # powered *through* HALT, so latch the power back on.\n\t    display.keepalive()\n\t    if TOTAL_CODES > 1:\n\t        if display.pressed(badger2040.BUTTON_UP):\n\t            if state[\"current_qr\"] > 0:\n\t                state[\"current_qr\"] -= 1\n\t                changed = True\n\t        if display.pressed(badger2040.BUTTON_DOWN):\n\t            if state[\"current_qr\"] < TOTAL_CODES - 1:\n", "                state[\"current_qr\"] += 1\n\t                changed = True\n\t    if display.pressed(badger2040.BUTTON_B) or display.pressed(badger2040.BUTTON_C):\n\t        display.set_pen(15)\n\t        display.clear()\n\t        badger_os.warning(display, \"To add QR codes, connect Badger 2040 W to a PC, load up Thonny, and add files to /qrcodes directory.\")\n\t        time.sleep(4)\n\t        changed = True\n\t    if changed:\n\t        draw_qr_file(state[\"current_qr\"])\n", "        badger_os.state_save(\"qrcodes\", state)\n\t        changed = False\n\t    # Halt the Badger to save power, it will wake up if any of the front buttons are pressed\n\t    display.halt()\n"]}
{"filename": "badger_os/examples/net_info.py", "chunked_list": ["import badger2040\n\tfrom badger2040 import WIDTH\n\timport network\n\tTEXT_SIZE = 1\n\tLINE_HEIGHT = 16\n\t# Display Setup\n\tdisplay = badger2040.Badger2040()\n\tdisplay.led(128)\n\t# Connects to the wireless network. Ensure you have entered your details in WIFI_CONFIG.py :).\n\tdisplay.connect()\n", "net = network.WLAN(network.STA_IF).ifconfig()\n\t# Page Header\n\tdisplay.set_pen(15)\n\tdisplay.clear()\n\tdisplay.set_pen(0)\n\tdisplay.set_pen(0)\n\tdisplay.rectangle(0, 0, WIDTH, 20)\n\tdisplay.set_pen(15)\n\tdisplay.text(\"badgerOS\", 3, 4)\n\tdisplay.text(\"Network Details\", WIDTH - display.measure_text(\"Network Details\") - 4, 4)\n", "display.set_pen(0)\n\ty = 35 + int(LINE_HEIGHT / 2)\n\tif net:\n\t    display.text(\"> LOCAL IP: {}\".format(net[0]), 0, y, WIDTH)\n\t    y += LINE_HEIGHT\n\t    display.text(\"> Subnet: {}\".format(net[1]), 0, y, WIDTH)\n\t    y += LINE_HEIGHT\n\t    display.text(\"> Gateway: {}\".format(net[2]), 0, y, WIDTH)\n\t    y += LINE_HEIGHT\n\t    display.text(\"> DNS: {}\".format(net[3]), 0, y, WIDTH)\n", "else:\n\t    display.text(\"> No network connection!\", 0, y, WIDTH)\n\t    y += LINE_HEIGHT\n\t    display.text(\"> Check details in WIFI_CONFIG.py\", 0, y, WIDTH)\n\tdisplay.update()\n\t# Call halt in a loop, on battery this switches off power.\n\t# On USB, the app will exit when A+C is pressed because the launcher picks that up.\n\twhile True:\n\t    display.keepalive()\n\t    display.halt()\n"]}
{"filename": "firmware/PIMORONI_BADGER2040W/manifest.py", "chunked_list": ["include(\"$(PORT_DIR)/boards/manifest.py\")\n\tfreeze(\"lib/\")\n\t# mip, ntptime, urequests, webrepl etc - see:\n\t# https://github.com/micropython/micropython-lib/blob/master/micropython/bundles/bundle-networking/manifest.py\n\trequire(\"bundle-networking\")\n\t# Bluetooth\n\trequire(\"aioble\")\n\trequire(\"urllib.urequest\")\n\trequire(\"umqtt.simple\")"]}
{"filename": "firmware/PIMORONI_BADGER2040W/lib/badger2040.py", "chunked_list": ["import machine\n\timport micropython\n\tfrom picographics import PicoGraphics, DISPLAY_INKY_PACK\n\timport time\n\timport wakeup\n\timport pcf85063a\n\tBUTTON_DOWN = 11\n\tBUTTON_A = 12\n\tBUTTON_B = 13\n\tBUTTON_C = 14\n", "BUTTON_UP = 15\n\tBUTTON_USER = None  # User button not available on W\n\tBUTTON_MASK = 0b11111 << 11\n\tSYSTEM_VERY_SLOW = 0\n\tSYSTEM_SLOW = 1\n\tSYSTEM_NORMAL = 2\n\tSYSTEM_FAST = 3\n\tSYSTEM_TURBO = 4\n\tUPDATE_NORMAL = 0\n\tUPDATE_MEDIUM = 1\n", "UPDATE_FAST = 2\n\tUPDATE_TURBO = 3\n\tRTC_ALARM = 8\n\tLED = 22\n\tENABLE_3V3 = 10\n\tBUSY = 26\n\tWIDTH = 296\n\tHEIGHT = 128\n\tSYSTEM_FREQS = [\n\t    4000000,\n", "    12000000,\n\t    48000000,\n\t    133000000,\n\t    250000000\n\t]\n\tBUTTONS = {\n\t    BUTTON_DOWN: machine.Pin(BUTTON_DOWN, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_A: machine.Pin(BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_B: machine.Pin(BUTTON_B, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_C: machine.Pin(BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN),\n", "    BUTTON_UP: machine.Pin(BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t}\n\tWAKEUP_MASK = 0\n\ti2c = machine.I2C(0)\n\trtc = pcf85063a.PCF85063A(i2c)\n\ti2c.writeto_mem(0x51, 0x00, b'\\x00')  # ensure rtc is running (this should be default?)\n\trtc.enable_timer_interrupt(False)\n\tenable = machine.Pin(ENABLE_3V3, machine.Pin.OUT)\n\tenable.on()\n\tdef is_wireless():\n", "    return True\n\tdef woken_by_rtc():\n\t    return bool(wakeup.get_gpio_state() & (1 << RTC_ALARM))\n\tdef woken_by_button():\n\t    return wakeup.get_gpio_state() & BUTTON_MASK > 0\n\tdef pressed_to_wake(button):\n\t    return wakeup.get_gpio_state() & (1 << button) > 0\n\tdef reset_pressed_to_wake():\n\t    wakeup.reset_gpio_state()\n\tdef pressed_to_wake_get_once(button):\n", "    global WAKEUP_MASK\n\t    result = (wakeup.get_gpio_state() & ~WAKEUP_MASK & (1 << button)) > 0\n\t    WAKEUP_MASK |= (1 << button)\n\t    return result\n\tdef system_speed(speed):\n\t    try:\n\t        machine.freq(SYSTEM_FREQS[speed])\n\t    except IndexError:\n\t        pass\n\tdef turn_on():\n", "    enable.on()\n\tdef turn_off():\n\t    time.sleep(0.05)\n\t    enable.off()\n\t    # Simulate an idle state on USB power by blocking\n\t    # until an RTC alarm or button event\n\t    rtc_alarm = machine.Pin(RTC_ALARM)\n\t    while True:\n\t        if rtc_alarm.value():\n\t            return\n", "        for button in BUTTONS.values():\n\t            if button.value():\n\t                return\n\tdef pico_rtc_to_pcf():\n\t    # Set the PCF85063A to the time stored by Pico W's RTC\n\t    year, month, day, dow, hour, minute, second, _ = machine.RTC().datetime()\n\t    rtc.datetime((year, month, day, hour, minute, second, dow))\n\tdef pcf_to_pico_rtc():\n\t    # Set Pico W's RTC to the time stored by the PCF85063A\n\t    t = rtc.datetime()\n", "    # BUG ERRNO 22, EINVAL, when date read from RTC is invalid for the Pico's RTC.\n\t    try:\n\t        machine.RTC().datetime((t[0], t[1], t[2], t[6], t[3], t[4], t[5], 0))\n\t        return True\n\t    except OSError:\n\t        return False\n\tdef sleep_for(minutes):\n\t    year, month, day, hour, minute, second, dow = rtc.datetime()\n\t    # if the time is very close to the end of the minute, advance to the next minute\n\t    # this aims to fix the edge case where the board goes to sleep right as the RTC triggers, thus never waking up\n", "    if second >= 55:\n\t        minute += 1\n\t    # Can't sleep beyond a month, so clamp the sleep to a 28 day maximum\n\t    minutes = min(minutes, 40320)\n\t    # Calculate the future alarm date; first, turn the current time into seconds since epoch\n\t    sec_since_epoch = time.mktime((year, month, day, hour, minute, second, dow, 0))\n\t    # Add the required minutes to this\n\t    sec_since_epoch += minutes * 60\n\t    # And convert it back into a more useful tuple\n\t    (ayear, amonth, aday, ahour, aminute, asecond, adow, adoy) = time.localtime(sec_since_epoch)\n", "    # And now set the alarm as before, now including the day\n\t    rtc.clear_alarm_flag()\n\t    rtc.set_alarm(0, aminute, ahour, aday)\n\t    rtc.enable_alarm_interrupt(True)\n\t    turn_off()\n\tclass Badger2040():\n\t    def __init__(self):\n\t        self.display = PicoGraphics(DISPLAY_INKY_PACK)\n\t        self._led = machine.PWM(machine.Pin(LED))\n\t        self._led.freq(1000)\n", "        self._led.duty_u16(0)\n\t        self._update_speed = 0\n\t    def __getattr__(self, item):\n\t        # Glue to redirect calls to PicoGraphics\n\t        return getattr(self.display, item)\n\t    def update(self):\n\t        t_start = time.ticks_ms()\n\t        self.display.update()\n\t        t_elapsed = time.ticks_ms() - t_start\n\t        delay_ms = [4700, 2600, 900, 250][self._update_speed]\n", "        if t_elapsed < delay_ms:\n\t            time.sleep((delay_ms - t_elapsed) / 1000)\n\t    def set_update_speed(self, speed):\n\t        self.display.set_update_speed(speed)\n\t        self._update_speed = speed\n\t    def led(self, brightness):\n\t        brightness = max(0, min(255, brightness))\n\t        self._led.duty_u16(int(brightness * 256))\n\t    def invert(self, invert):\n\t        raise RuntimeError(\"Display invert not supported in PicoGraphics.\")\n", "    def thickness(self, thickness):\n\t        raise RuntimeError(\"Thickness not supported in PicoGraphics.\")\n\t    def halt(self):\n\t        turn_off()\n\t    def keepalive(self):\n\t        turn_on()\n\t    def pressed(self, button):\n\t        return BUTTONS[button].value() == 1 or pressed_to_wake_get_once(button)\n\t    def pressed_any(self):\n\t        for button in BUTTONS.values():\n", "            if button.value():\n\t                return True\n\t        return False\n\t    @micropython.native\n\t    def icon(self, data, index, data_w, icon_size, x, y):\n\t        s_x = (index * icon_size) % data_w\n\t        s_y = int((index * icon_size) / data_w)\n\t        for o_y in range(icon_size):\n\t            for o_x in range(icon_size):\n\t                o = ((o_y + s_y) * data_w) + (o_x + s_x)\n", "                bm = 0b10000000 >> (o & 0b111)\n\t                if data[o >> 3] & bm:\n\t                    self.display.pixel(x + o_x, y + o_y)\n\t    def image(self, data, w, h, x, y):\n\t        for oy in range(h):\n\t            row = data[oy]\n\t            for ox in range(w):\n\t                if row & 0b1 == 0:\n\t                    self.display.pixel(x + ox, y + oy)\n\t                row >>= 1\n", "    def status_handler(self, mode, status, ip):\n\t        self.display.set_update_speed(2)\n\t        print(mode, status, ip)\n\t        self.display.set_pen(15)\n\t        self.display.clear()\n\t        self.display.set_pen(0)\n\t        if status:\n\t            self.display.text(\"Connected!\", 10, 10, 300, 0.5)\n\t            self.display.text(ip, 10, 30, 300, 0.5)\n\t        else:\n", "            self.display.text(\"Connecting...\", 10, 10, 300, 0.5)\n\t        self.update()\n\t    def isconnected(self):\n\t        import network\n\t        return network.WLAN(network.STA_IF).isconnected()\n\t    def ip_address(self):\n\t        import network\n\t        return network.WLAN(network.STA_IF).ifconfig()[0]\n\t    def connect(self, **args):\n\t        from network_manager import NetworkManager\n", "        import WIFI_CONFIG\n\t        import uasyncio\n\t        import gc\n\t        status_handler = args.get(\"status_handler\", self.status_handler)\n\t        if WIFI_CONFIG.COUNTRY == \"\":\n\t            raise RuntimeError(\"You must populate WIFI_CONFIG.py for networking.\")\n\t        network_manager = NetworkManager(WIFI_CONFIG.COUNTRY, status_handler=status_handler)\n\t        uasyncio.get_event_loop().run_until_complete(network_manager.client(WIFI_CONFIG.SSID, WIFI_CONFIG.PSK))\n\t        gc.collect()\n"]}
{"filename": "firmware/PIMORONI_BADGER2040W/lib/badger_os.py", "chunked_list": ["import os\n\timport gc\n\timport time\n\timport json\n\timport machine\n\timport badger2040\n\tdef get_battery_level():\n\t    return 0\n\t    # Battery measurement\n\t    vbat_adc = machine.ADC(badger2040.PIN_BATTERY)\n", "    vref_adc = machine.ADC(badger2040.PIN_1V2_REF)\n\t    vref_en = machine.Pin(badger2040.PIN_VREF_POWER)\n\t    vref_en.init(machine.Pin.OUT)\n\t    vref_en.value(0)\n\t    # Enable the onboard voltage reference\n\t    vref_en.value(1)\n\t    # Calculate the logic supply voltage, as will be lower that the usual 3.3V when running off low batteries\n\t    vdd = 1.24 * (65535 / vref_adc.read_u16())\n\t    vbat = (\n\t        (vbat_adc.read_u16() / 65535) * 3 * vdd\n", "    )  # 3 in this is a gain, not rounding of 3.3V\n\t    # Disable the onboard voltage reference\n\t    vref_en.value(0)\n\t    # Convert the voltage to a level to display onscreen\n\t    return vbat\n\tdef get_disk_usage():\n\t    # f_bfree and f_bavail should be the same?\n\t    # f_files, f_ffree, f_favail and f_flag are unsupported.\n\t    f_bsize, f_frsize, f_blocks, f_bfree, _, _, _, _, _, f_namemax = os.statvfs(\"/\")\n\t    f_total_size = f_frsize * f_blocks\n", "    f_total_free = f_bsize * f_bfree\n\t    f_total_used = f_total_size - f_total_free\n\t    f_used = 100 / f_total_size * f_total_used\n\t    f_free = 100 / f_total_size * f_total_free\n\t    return f_total_size, f_used, f_free\n\tdef state_running():\n\t    state = {\"running\": \"launcher\"}\n\t    state_load(\"launcher\", state)\n\t    return state[\"running\"]\n\tdef state_clear_running():\n", "    running = state_running()\n\t    state_modify(\"launcher\", {\"running\": \"launcher\"})\n\t    return running != \"launcher\"\n\tdef state_set_running(app):\n\t    state_modify(\"launcher\", {\"running\": app})\n\tdef state_launch():\n\t    app = state_running()\n\t    if app is not None and app != \"launcher\":\n\t        launch(app)\n\tdef state_delete(app):\n", "    try:\n\t        os.remove(\"/state/{}.json\".format(app))\n\t    except OSError:\n\t        pass\n\tdef state_save(app, data):\n\t    try:\n\t        with open(\"/state/{}.json\".format(app), \"w\") as f:\n\t            f.write(json.dumps(data))\n\t            f.flush()\n\t    except OSError:\n", "        import os\n\t        try:\n\t            os.stat(\"/state\")\n\t        except OSError:\n\t            os.mkdir(\"/state\")\n\t            state_save(app, data)\n\tdef state_modify(app, data):\n\t    state = {}\n\t    state_load(app, state)\n\t    state.update(data)\n", "    state_save(app, state)\n\tdef state_load(app, defaults):\n\t    try:\n\t        data = json.loads(open(\"/state/{}.json\".format(app), \"r\").read())\n\t        if type(data) is dict:\n\t            defaults.update(data)\n\t            return True\n\t    except (OSError, ValueError):\n\t        pass\n\t    state_save(app, defaults)\n", "    return False\n\tdef launch(file):\n\t    state_set_running(file)\n\t    gc.collect()\n\t    button_a = machine.Pin(badger2040.BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\t    button_c = machine.Pin(badger2040.BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\t    def quit_to_launcher(pin):\n\t        if button_a.value() and button_c.value():\n\t            machine.reset()\n\t    button_a.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n", "    button_c.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n\t    try:\n\t        __import__(file)\n\t    except ImportError:\n\t        # If the app doesn't exist, notify the user\n\t        warning(None, f\"Could not launch: {file}\")\n\t        time.sleep(4.0)\n\t    except Exception as e:\n\t        # If the app throws an error, catch it and display!\n\t        print(e)\n", "        warning(None, str(e))\n\t        time.sleep(4.0)\n\t    # If the app exits or errors, do not relaunch!\n\t    state_clear_running()\n\t    machine.reset()  # Exit back to launcher\n\t# Draw an overlay box with a given message within it\n\tdef warning(display, message, width=badger2040.WIDTH - 20, height=badger2040.HEIGHT - 20, line_spacing=20, text_size=0.6):\n\t    print(message)\n\t    if display is None:\n\t        display = badger2040.Badger2040()\n", "        display.led(128)\n\t    # Draw a light grey background\n\t    display.set_pen(12)\n\t    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\t    width -= 20\n\t    height -= 20\n\t    display.set_pen(15)\n\t    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\t    # Take the provided message and split it up into\n\t    # lines that fit within the specified width\n", "    words = message.split(\" \")\n\t    lines = []\n\t    current_line = \"\"\n\t    for word in words:\n\t        if display.measure_text(current_line + word + \" \", text_size) < width:\n\t            current_line += word + \" \"\n\t        else:\n\t            lines.append(current_line.strip())\n\t            current_line = word + \" \"\n\t    lines.append(current_line.strip())\n", "    display.set_pen(0)\n\t    # Display each line of text from the message, centre-aligned\n\t    num_lines = len(lines)\n\t    for i in range(num_lines):\n\t        length = display.measure_text(lines[i], text_size)\n\t        current_line = (i * line_spacing) - ((num_lines - 1) * line_spacing) // 2\n\t        display.text(lines[i], (badger2040.WIDTH - length) // 2, (badger2040.HEIGHT // 2) + current_line, badger2040.WIDTH, text_size)\n\t    display.update()\n"]}
{"filename": "firmware/PIMORONI_BADGER2040W/lib/network_manager.py", "chunked_list": ["import rp2\n\timport network\n\timport machine\n\timport uasyncio\n\tclass NetworkManager:\n\t    _ifname = (\"Client\", \"Access Point\")\n\t    def __init__(self, country=\"GB\", client_timeout=60, access_point_timeout=5, status_handler=None, error_handler=None):\n\t        rp2.country(country)\n\t        self._ap_if = network.WLAN(network.AP_IF)\n\t        self._sta_if = network.WLAN(network.STA_IF)\n", "        self._mode = network.STA_IF\n\t        self._client_timeout = client_timeout\n\t        self._access_point_timeout = access_point_timeout\n\t        self._status_handler = status_handler\n\t        self._error_handler = error_handler\n\t        self.UID = (\"{:02X}\" * 8).format(*machine.unique_id())\n\t    def isconnected(self):\n\t        return self._sta_if.isconnected() or self._ap_if.isconnected()\n\t    def config(self, var):\n\t        if self._sta_if.active():\n", "            return self._sta_if.config(var)\n\t        else:\n\t            if var == \"password\":\n\t                return self.UID\n\t            return self._ap_if.config(var)\n\t    def mode(self):\n\t        if self._sta_if.isconnected():\n\t            return self._ifname[0]\n\t        if self._ap_if.isconnected():\n\t            return self._ifname[1]\n", "        return None\n\t    def ifaddress(self):\n\t        if self._sta_if.isconnected():\n\t            return self._sta_if.ifconfig()[0]\n\t        if self._ap_if.isconnected():\n\t            return self._ap_if.ifconfig()[0]\n\t        return '0.0.0.0'\n\t    def disconnect(self):\n\t        if self._sta_if.isconnected():\n\t            self._sta_if.disconnect()\n", "        if self._ap_if.isconnected():\n\t            self._ap_if.disconnect()\n\t    async def wait(self, mode):\n\t        while not self.isconnected():\n\t            self._handle_status(mode, None)\n\t            await uasyncio.sleep_ms(1000)\n\t    def _handle_status(self, mode, status):\n\t        if callable(self._status_handler):\n\t            self._status_handler(self._ifname[mode], status, self.ifaddress())\n\t    def _handle_error(self, mode, msg):\n", "        if callable(self._error_handler):\n\t            if self._error_handler(self._ifname[mode], msg):\n\t                return\n\t        raise RuntimeError(msg)\n\t    async def client(self, ssid, psk):\n\t        if self._sta_if.isconnected():\n\t            self._handle_status(network.STA_IF, True)\n\t            return\n\t        self._ap_if.disconnect()\n\t        self._ap_if.active(False)\n", "        self._sta_if.active(True)\n\t        self._sta_if.config(pm=0xa11140)\n\t        self._sta_if.connect(ssid, psk)\n\t        try:\n\t            await uasyncio.wait_for(self.wait(network.STA_IF), self._client_timeout)\n\t            self._handle_status(network.STA_IF, True)\n\t        except uasyncio.TimeoutError:\n\t            self._sta_if.active(False)\n\t            self._handle_status(network.STA_IF, False)\n\t            self._handle_error(network.STA_IF, \"WIFI Client Failed\")\n", "    async def access_point(self):\n\t        if self._ap_if.isconnected():\n\t            self._handle_status(network.AP_IF, True)\n\t            return\n\t        self._sta_if.disconnect()\n\t        self._sta_if.active(False)\n\t        self._ap_if.ifconfig((\"10.10.1.1\", \"255.255.255.0\", \"10.10.1.1\", \"10.10.1.1\"))\n\t        self._ap_if.config(password=self.UID)\n\t        self._ap_if.active(True)\n\t        try:\n", "            await uasyncio.wait_for(self.wait(network.AP_IF), self._access_point_timeout)\n\t            self._handle_status(network.AP_IF, True)\n\t        except uasyncio.TimeoutError:\n\t            self._sta_if.active(False)\n\t            self._handle_status(network.AP_IF, False)\n\t            self._handle_error(network.AP_IF, \"WIFI Client Failed\")\n"]}
{"filename": "firmware/PIMORONI_BADGER2040/manifest.py", "chunked_list": ["include(\"$(PORT_DIR)/boards/manifest.py\")\n\tfreeze(\"lib/\")"]}
{"filename": "firmware/PIMORONI_BADGER2040/lib/badger2040.py", "chunked_list": ["import machine\n\timport micropython\n\tfrom picographics import PicoGraphics, DISPLAY_INKY_PACK\n\timport time\n\timport wakeup\n\tBUTTON_DOWN = 11\n\tBUTTON_A = 12\n\tBUTTON_B = 13\n\tBUTTON_C = 14\n\tBUTTON_UP = 15\n", "BUTTON_USER = 23\n\tBUTTON_MASK = 0b11111 << 11\n\tSYSTEM_VERY_SLOW = 0\n\tSYSTEM_SLOW = 1\n\tSYSTEM_NORMAL = 2\n\tSYSTEM_FAST = 3\n\tSYSTEM_TURBO = 4\n\tUPDATE_NORMAL = 0\n\tUPDATE_MEDIUM = 1\n\tUPDATE_FAST = 2\n", "UPDATE_TURBO = 3\n\tLED = 25\n\tENABLE_3V3 = 10\n\tBUSY = 26\n\tWIDTH = 296\n\tHEIGHT = 128\n\tSYSTEM_FREQS = [\n\t    4000000,\n\t    12000000,\n\t    48000000,\n", "    133000000,\n\t    250000000\n\t]\n\tBUTTONS = {\n\t    BUTTON_DOWN: machine.Pin(BUTTON_DOWN, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_A: machine.Pin(BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_B: machine.Pin(BUTTON_B, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_C: machine.Pin(BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_UP: machine.Pin(BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN),\n\t    BUTTON_USER: machine.Pin(BUTTON_USER, machine.Pin.IN, machine.Pin.PULL_UP),\n", "}\n\tWAKEUP_MASK = 0\n\tenable = machine.Pin(ENABLE_3V3, machine.Pin.OUT)\n\tenable.on()\n\tdef is_wireless():\n\t    return False\n\tdef woken_by_rtc():\n\t    return False  # Badger 2040 does not include an RTC\n\tdef woken_by_button():\n\t    return wakeup.get_gpio_state() & BUTTON_MASK > 0\n", "def pressed_to_wake(button):\n\t    return wakeup.get_gpio_state() & (1 << button) > 0\n\tdef reset_pressed_to_wake():\n\t    wakeup.reset_gpio_state()\n\tdef pressed_to_wake_get_once(button):\n\t    global WAKEUP_MASK\n\t    if button == BUTTON_USER:\n\t        return False\n\t    result = (wakeup.get_gpio_state() & ~WAKEUP_MASK & (1 << button)) > 0\n\t    WAKEUP_MASK |= (1 << button)\n", "    return result\n\tdef system_speed(speed):\n\t    try:\n\t        machine.freq(SYSTEM_FREQS[speed])\n\t    except IndexError:\n\t        pass\n\tdef turn_on():\n\t    enable.on()\n\tdef turn_off():\n\t    time.sleep(0.05)\n", "    enable.off()\n\t    # Simulate an idle state on USB power by blocking\n\t    # until a button event\n\t    while True:\n\t        for pin, button in BUTTONS.items():\n\t            if pin == BUTTON_USER:\n\t                if not button.value():\n\t                    return\n\t                continue\n\t            if button.value():\n", "                return\n\tdef sleep_for(minutes=None):\n\t    raise RuntimeError(\"Badger 2040 does not include an RTC.\")\n\tpico_rtc_to_pcf = pcf_to_pico_rtc = sleep_for\n\tclass Badger2040():\n\t    def __init__(self):\n\t        self.display = PicoGraphics(DISPLAY_INKY_PACK)\n\t        self._led = machine.PWM(machine.Pin(LED))\n\t        self._led.freq(1000)\n\t        self._led.duty_u16(0)\n", "        self._update_speed = 0\n\t    def __getattr__(self, item):\n\t        # Glue to redirect calls to PicoGraphics\n\t        return getattr(self.display, item)\n\t    def update(self):\n\t        t_start = time.ticks_ms()\n\t        self.display.update()\n\t        t_elapsed = time.ticks_ms() - t_start\n\t        delay_ms = [4700, 2600, 900, 250][self._update_speed]\n\t        if t_elapsed < delay_ms:\n", "            time.sleep((delay_ms - t_elapsed) / 1000)\n\t    def set_update_speed(self, speed):\n\t        self.display.set_update_speed(speed)\n\t        self._update_speed = speed\n\t    def led(self, brightness):\n\t        brightness = max(0, min(255, brightness))\n\t        self._led.duty_u16(int(brightness * 256))\n\t    def invert(self, invert):\n\t        raise RuntimeError(\"Display invert not supported in PicoGraphics.\")\n\t    def thickness(self, thickness):\n", "        raise RuntimeError(\"Thickness not supported in PicoGraphics.\")\n\t    def halt(self):\n\t        turn_off()\n\t    def keepalive(self):\n\t        turn_on()\n\t    def pressed(self, button):\n\t        return BUTTONS[button].value() == (0 if button == BUTTON_USER else 1) or pressed_to_wake_get_once(button)\n\t    def pressed_any(self):\n\t        for pin, button in BUTTONS.items():\n\t            if pin == BUTTON_USER:\n", "                if not button.value():\n\t                    return True\n\t                continue\n\t            if button.value():\n\t                return True\n\t        return False\n\t    @micropython.native\n\t    def icon(self, data, index, data_w, icon_size, x, y):\n\t        s_x = (index * icon_size) % data_w\n\t        s_y = int((index * icon_size) / data_w)\n", "        for o_y in range(icon_size):\n\t            for o_x in range(icon_size):\n\t                o = ((o_y + s_y) * data_w) + (o_x + s_x)\n\t                bm = 0b10000000 >> (o & 0b111)\n\t                if data[o >> 3] & bm:\n\t                    self.display.pixel(x + o_x, y + o_y)\n\t    def image(self, data, w, h, x, y):\n\t        for oy in range(h):\n\t            row = data[oy]\n\t            for ox in range(w):\n", "                if row & 0b1 == 0:\n\t                    self.display.pixel(x + ox, y + oy)\n\t                row >>= 1\n\t    def isconnected(self):\n\t        return False\n\t    def ip_address(self):\n\t        return (0, 0, 0, 0)\n\t    def connect(self):\n\t        pass\n"]}
{"filename": "firmware/PIMORONI_BADGER2040/lib/badger_os.py", "chunked_list": ["import os\n\timport gc\n\timport time\n\timport json\n\timport machine\n\timport badger2040\n\tdef get_battery_level():\n\t    return 0\n\t    # Battery measurement\n\t    vbat_adc = machine.ADC(badger2040.PIN_BATTERY)\n", "    vref_adc = machine.ADC(badger2040.PIN_1V2_REF)\n\t    vref_en = machine.Pin(badger2040.PIN_VREF_POWER)\n\t    vref_en.init(machine.Pin.OUT)\n\t    vref_en.value(0)\n\t    # Enable the onboard voltage reference\n\t    vref_en.value(1)\n\t    # Calculate the logic supply voltage, as will be lower that the usual 3.3V when running off low batteries\n\t    vdd = 1.24 * (65535 / vref_adc.read_u16())\n\t    vbat = (\n\t        (vbat_adc.read_u16() / 65535) * 3 * vdd\n", "    )  # 3 in this is a gain, not rounding of 3.3V\n\t    # Disable the onboard voltage reference\n\t    vref_en.value(0)\n\t    # Convert the voltage to a level to display onscreen\n\t    return vbat\n\tdef get_disk_usage():\n\t    # f_bfree and f_bavail should be the same?\n\t    # f_files, f_ffree, f_favail and f_flag are unsupported.\n\t    f_bsize, f_frsize, f_blocks, f_bfree, _, _, _, _, _, f_namemax = os.statvfs(\"/\")\n\t    f_total_size = f_frsize * f_blocks\n", "    f_total_free = f_bsize * f_bfree\n\t    f_total_used = f_total_size - f_total_free\n\t    f_used = 100 / f_total_size * f_total_used\n\t    f_free = 100 / f_total_size * f_total_free\n\t    return f_total_size, f_used, f_free\n\tdef state_running():\n\t    state = {\"running\": \"launcher\"}\n\t    state_load(\"launcher\", state)\n\t    return state[\"running\"]\n\tdef state_clear_running():\n", "    running = state_running()\n\t    state_modify(\"launcher\", {\"running\": \"launcher\"})\n\t    return running != \"launcher\"\n\tdef state_set_running(app):\n\t    state_modify(\"launcher\", {\"running\": app})\n\tdef state_launch():\n\t    app = state_running()\n\t    if app is not None and app != \"launcher\":\n\t        launch(app)\n\tdef state_delete(app):\n", "    try:\n\t        os.remove(\"/state/{}.json\".format(app))\n\t    except OSError:\n\t        pass\n\tdef state_save(app, data):\n\t    try:\n\t        with open(\"/state/{}.json\".format(app), \"w\") as f:\n\t            f.write(json.dumps(data))\n\t            f.flush()\n\t    except OSError:\n", "        import os\n\t        try:\n\t            os.stat(\"/state\")\n\t        except OSError:\n\t            os.mkdir(\"/state\")\n\t            state_save(app, data)\n\tdef state_modify(app, data):\n\t    state = {}\n\t    state_load(app, state)\n\t    state.update(data)\n", "    state_save(app, state)\n\tdef state_load(app, defaults):\n\t    try:\n\t        data = json.loads(open(\"/state/{}.json\".format(app), \"r\").read())\n\t        if type(data) is dict:\n\t            defaults.update(data)\n\t            return True\n\t    except (OSError, ValueError):\n\t        pass\n\t    state_save(app, defaults)\n", "    return False\n\tdef launch(file):\n\t    state_set_running(file)\n\t    gc.collect()\n\t    button_a = machine.Pin(badger2040.BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\t    button_c = machine.Pin(badger2040.BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\t    def quit_to_launcher(pin):\n\t        if button_a.value() and button_c.value():\n\t            machine.reset()\n\t    button_a.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n", "    button_c.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n\t    try:\n\t        __import__(file)\n\t    except ImportError:\n\t        # If the app doesn't exist, notify the user\n\t        warning(None, f\"Could not launch: {file}\")\n\t        time.sleep(4.0)\n\t    except Exception as e:\n\t        # If the app throws an error, catch it and display!\n\t        print(e)\n", "        warning(None, str(e))\n\t        time.sleep(4.0)\n\t    # If the app exits or errors, do not relaunch!\n\t    state_clear_running()\n\t    machine.reset()  # Exit back to launcher\n\t# Draw an overlay box with a given message within it\n\tdef warning(display, message, width=badger2040.WIDTH - 20, height=badger2040.HEIGHT - 20, line_spacing=20, text_size=0.6):\n\t    print(message)\n\t    if display is None:\n\t        display = badger2040.Badger2040()\n", "        display.led(128)\n\t    # Draw a light grey background\n\t    display.set_pen(12)\n\t    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\t    width -= 20\n\t    height -= 20\n\t    display.set_pen(15)\n\t    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\t    # Take the provided message and split it up into\n\t    # lines that fit within the specified width\n", "    words = message.split(\" \")\n\t    lines = []\n\t    current_line = \"\"\n\t    for word in words:\n\t        if display.measure_text(current_line + word + \" \", text_size) < width:\n\t            current_line += word + \" \"\n\t        else:\n\t            lines.append(current_line.strip())\n\t            current_line = word + \" \"\n\t    lines.append(current_line.strip())\n", "    display.set_pen(0)\n\t    # Display each line of text from the message, centre-aligned\n\t    num_lines = len(lines)\n\t    for i in range(num_lines):\n\t        length = display.measure_text(lines[i], text_size)\n\t        current_line = (i * line_spacing) - ((num_lines - 1) * line_spacing) // 2\n\t        display.text(lines[i], (badger2040.WIDTH - length) // 2, (badger2040.HEIGHT // 2) + current_line, badger2040.WIDTH, text_size)\n\t    display.update()\n"]}
